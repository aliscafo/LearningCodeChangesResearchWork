562
#method_before
public int run(String[] args) {
    if (args[0].equals("-c")) {
        client();
    } else if (args[0].equals("-s")) {
        server();
    } else {
        Log.e(TAG, "Usage: HidlTestJava  -c(lient) | -s(erver)");
        return 1;
    }
    return 0;
}
#method_after
public int run(String[] args) throws RemoteException {
    if (args[0].equals("-c")) {
        client();
    } else if (args[0].equals("-s")) {
        server();
    } else {
        Log.e(TAG, "Usage: HidlTestJava  -c(lient) | -s(erver)");
        return 1;
    }
    return 0;
}
#end_block

#method_before
public void heyItsMe(IBazCallback cb) {
    Log.d(TAG, "SERVER: heyItsMe");
}
#method_after
public void heyItsMe(IBazCallback cb) throws RemoteException {
    mCalled = true;
    cb.heyItsMe(null);
}
#end_block

#method_before
public void hey() {
    Log.d(TAG, "SERVER: hey");
}
#method_after
public void hey() {
    mCalled = true;
}
#end_block

#method_before
private void client() {
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService("baz");
        baseProxy.someBaseMethod();
    }
    IBaz proxy = IBaz.getService("baz");
    proxy.someBaseMethod();
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        Expect(toString(result), "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])");
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        Expect(toString(outputArray), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        Expect(fooVecToString(outputVec), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        Expect(toString(out), "VectorOfArray(" + "0c:0d:0e:0f:10:11, " + "06:07:08:09:0a:0b, " + "00:01:02:03:04:05)");
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        Expect(macAddressVecToString(out), "[0c:0d:0e:0f:10:11, 06:07:08:09:0a:0b, 00:01:02:03:04:05]");
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    {
        String[][] in = new String[5][3];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    Expect(toString(proxy.someBoolMethod(true)), "false");
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        Expect(toString(proxy.someBoolArrayMethod(someBoolArray)), "[false, true, false, true]");
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        Expect(booleanVecToString(proxy.someBoolVectorMethod(someBoolVec)), "[false, true, false]");
    }
    proxy.doThis(1.0f);
    Expect(toString(proxy.doThatAndReturnSomething(1)), "666");
    Expect(toString(proxy.doQuiteABit(1, 2L, 3.0f, 4.0)), "666.5");
    {
        int[] paramArray = new int[15];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
        }
        Expect(toString(proxy.doSomethingElse(paramArray)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, " + "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1, 2]");
        Expect(integerVecToString(proxy.mapThisVector(paramVec)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]");
    }
    Expect(toString(proxy.doStuffAndReturnAString()), "'Hello, world!'");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    Expect(toString(proxy.useAnEnum(IBaz.SomeEnum.goober)), "-64");
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        Expect(toString(proxy.haveSomeStrings(stringArray)), "['Hello', 'World']");
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        Expect(stringVecToString(proxy.haveAStringVec(stringVec)), "['Hello', 'World']");
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
    }
}
#method_after
private void client() throws RemoteException {
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService("baz");
        baseProxy.someBaseMethod();
    }
    IBaz proxy = IBaz.getService("baz");
    proxy.someBaseMethod();
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        Expect(toString(result), "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])");
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        Expect(toString(outputArray), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        Expect(fooVecToString(outputVec), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        Expect(toString(out), "VectorOfArray(" + "0c:0d:0e:0f:10:11, " + "06:07:08:09:0a:0b, " + "00:01:02:03:04:05)");
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        Expect(macAddressVecToString(out), "[0c:0d:0e:0f:10:11, 06:07:08:09:0a:0b, 00:01:02:03:04:05]");
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    {
        String[][] in = new String[5][3];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    Expect(toString(proxy.someBoolMethod(true)), "false");
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        Expect(toString(proxy.someBoolArrayMethod(someBoolArray)), "[false, true, false, true]");
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        Expect(booleanVecToString(proxy.someBoolVectorMethod(someBoolVec)), "[false, true, false]");
    }
    proxy.doThis(1.0f);
    Expect(toString(proxy.doThatAndReturnSomething(1)), "666");
    Expect(toString(proxy.doQuiteABit(1, 2L, 3.0f, 4.0)), "666.5");
    {
        int[] paramArray = new int[15];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
        }
        Expect(toString(proxy.doSomethingElse(paramArray)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, " + "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1, 2]");
        Expect(integerVecToString(proxy.mapThisVector(paramVec)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]");
    }
    Expect(toString(proxy.doStuffAndReturnAString()), "'Hello, world!'");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    Expect(toString(proxy.useAnEnum(IBaz.SomeEnum.goober)), "-64");
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        Expect(toString(proxy.haveSomeStrings(stringArray)), "['Hello', 'World']");
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        Expect(stringVecToString(proxy.haveAStringVec(stringVec)), "['Hello', 'World']");
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#end_block

#method_before
public void callMe(IBazCallback cb) {
    Log.d(TAG, "callMe");
    cb.heyItsMe(new BazCallback());
}
#method_after
public void callMe(IBazCallback cb) throws RemoteException {
    Log.d(TAG, "callMe");
    cb.heyItsMe(new BazCallback());
}
#end_block

#method_before
public void iAmFreeNow() {
    if (mStoredCallback != null) {
        mStoredCallback.hey();
    }
}
#method_after
public void iAmFreeNow() throws RemoteException {
    if (mStoredCallback != null) {
        mStoredCallback.hey();
    }
}
#end_block

#method_before
@Override
public File vmExecutable(File vmHome) {
    // TODO(user): Allow the 32/64 version of dalvik to be selected rather than the default
    // standard configurations of Android systems and windows.
    File bin = new File(vmHome, "bin");
    Preconditions.checkState(bin.exists() && bin.isDirectory(), "Could not find %s under android root %s", bin, vmHome);
    String executableName = vmExecutable;
    File dalvikvm = new File(bin, executableName);
    if (!dalvikvm.exists() || dalvikvm.isDirectory()) {
        throw new IllegalStateException(String.format("Cannot find %s binary in %s", executableName, bin));
    }
    return dalvikvm;
}
#method_after
@Override
public File vmExecutable(File vmHome) {
    File bin = new File(vmHome, "bin");
    Preconditions.checkState(bin.exists() && bin.isDirectory(), "Could not find %s under android root %s", bin, vmHome);
    String executableName = vmExecutable;
    File dalvikvm = new File(bin, executableName);
    if (!dalvikvm.exists() || dalvikvm.isDirectory()) {
        throw new IllegalStateException(String.format("Cannot find %s binary in %s", executableName, bin));
    }
    return dalvikvm;
}
#end_block

#method_before
@Override
public File customVmHomeDir(Map<String, String> vmGroupMap, String vmConfigName) {
    // Support a handful of specific commands:
    switch(vmConfigName) {
        // run with Android framework code already initialized.
        case "app_process":
        // same as not using --vm (selects 64-bit on 64-bit, 32-bit on 32-bit)
        case "dalvikvm":
        // 32-bit specific dalvikvm (e.g. if running on 64-bit device)
        case "dalvikvm32":
        // 64-bit specific dalvikvm (which is already default on 64-bit)
        case "dalvikvm64":
        case // similar to dalvikvm but goes through a script with better settings.
        "art":
            {
                // Usually passed as vmHome to vmExecutable, but we don't get that passed here.
                String vmHome = vmAndroidRoot;
                // Do not return the binary here. We return the new vmHome used by #vmExecutable.
                // Remember that the home directory was changed, and accordingly update the executable name.
                vmExecutable = vmConfigName;
                File androidRootFile = new File(vmHome);
                if (!androidRootFile.exists()) {
                    throw new IllegalStateException(String.format("%s does not exist", androidRootFile));
                } else if (!androidRootFile.isDirectory()) {
                    throw new IllegalStateException(String.format("%s is not a directory", androidRootFile));
                }
                return androidRootFile;
            }
    }
    // Unknown vm, throw an exception.
    Joiner.MapJoiner mapJoiner = Joiner.on(',').withKeyValueSeparator("=");
    String mapString = (vmGroupMap == null) ? "<null>" : mapJoiner.join(vmGroupMap);
    if (vmConfigName == null) {
        vmConfigName = "<null>";
    }
    // and maybe even app_process.
    throw new UnsupportedOperationException("Running with a custom Dalvik VM is not currently supported (group map = '" + mapString + "', vmConfigName = '" + vmConfigName + "')");
}
#method_after
@Override
public File customVmHomeDir(Map<String, String> vmGroupMap, String vmConfigName) {
    // Support a handful of specific commands:
    switch(vmConfigName) {
        // run with Android framework code already initialized.
        case "app_process":
        // same as not using --vm (selects 64-bit on 64-bit, 32-bit on 32-bit)
        case "dalvikvm":
        // 32-bit specific dalvikvm (e.g. if running on 64-bit device)
        case "dalvikvm32":
        // 64-bit specific dalvikvm (which is already default on 64-bit)
        case "dalvikvm64":
        case // similar to dalvikvm but goes through a script with better settings.
        "art":
            {
                // Usually passed as vmHome to vmExecutable, but we don't get that passed here.
                String vmHome = vmAndroidRoot;
                // Do not return the binary here. We return the new vmHome used by #vmExecutable.
                // Remember that the home directory was changed, and accordingly update the executable name.
                vmExecutable = vmConfigName;
                File androidRootFile = new File(vmHome);
                if (!androidRootFile.exists()) {
                    throw new IllegalStateException(String.format("%s does not exist", androidRootFile));
                } else if (!androidRootFile.isDirectory()) {
                    throw new IllegalStateException(String.format("%s is not a directory", androidRootFile));
                }
                return androidRootFile;
            }
    }
    // Unknown vm, throw an exception.
    Joiner.MapJoiner mapJoiner = Joiner.on(',').withKeyValueSeparator("=");
    String mapString = (vmGroupMap == null) ? "<null>" : mapJoiner.join(vmGroupMap);
    if (vmConfigName == null) {
        vmConfigName = "<null>";
    }
    throw new UnsupportedOperationException("Running with a custom Dalvik VM is not currently supported (group map = '" + mapString + "', vmConfigName = '" + vmConfigName + "')");
}
#end_block

#method_before
BluetoothCodecConfig getCodecConfig() {
    return mCodecConfig;
}
#method_after
BluetoothCodecConfig getCodecConfig() {
    synchronized (this) {
        return mCodecConfig;
    }
}
#end_block

#method_before
private void onCodecConfigChanged(int codecType, int codecPriority, int sampleRate, int bitsPerSample, int channelMode, long codecSpecific1, long codecSpecific2, long codecSpecific3, long codecSpecific4) {
    BluetoothCodecConfig prevCodecConfig;
    BluetoothCodecConfig newCodecConfig = new BluetoothCodecConfig(codecType, codecPriority, sampleRate, bitsPerSample, channelMode, codecSpecific1, codecSpecific2, codecSpecific3, codecSpecific4);
    synchronized (this) {
        prevCodecConfig = mCodecConfig;
        mCodecConfig = newCodecConfig;
    }
    Intent intent = new Intent(BluetoothA2dp.ACTION_CODEC_CONFIG_CHANGED);
    intent.putExtra(BluetoothCodecConfig.EXTRA_CODEC_CONFIG, newCodecConfig);
    intent.putExtra(BluetoothCodecConfig.EXTRA_PREVIOUS_CODEC_CONFIG, prevCodecConfig);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    mContext.sendBroadcast(intent, A2dpService.BLUETOOTH_PERM);
    log("A2DP Codec Config : " + prevCodecConfig + "->" + newCodecConfig);
    // Inform the Audio Service: toggle the Device connected state off
    // and on so the Audio Service can reset accordingly the audio feeding
    // parameters in the Audio HAL to the Bluetooth stack.
    boolean audioParametersHaveChanged = false;
    if ((prevCodecConfig != null) && ((prevCodecConfig.getSampleRate() != newCodecConfig.getSampleRate()) || (prevCodecConfig.getBitsPerSample() != newCodecConfig.getBitsPerSample()) || (prevCodecConfig.getChannelMode() != newCodecConfig.getChannelMode()))) {
        audioParametersHaveChanged = true;
    }
    if (audioParametersHaveChanged && (mCurrentDevice != null) && (getCurrentState() == mConnected)) {
        int delay1 = mAudioManager.setBluetoothA2dpDeviceConnectionState(mCurrentDevice, BluetoothProfile.STATE_DISCONNECTED, BluetoothProfile.A2DP);
        int delay2 = mAudioManager.setBluetoothA2dpDeviceConnectionState(mCurrentDevice, BluetoothProfile.STATE_CONNECTED, BluetoothProfile.A2DP);
        logd("Delay for broadcasting the connection state: delay1=" + delay1 + " delay2=" + delay2);
    }
}
#method_after
private void onCodecConfigChanged(int codecType, int codecPriority, int sampleRate, int bitsPerSample, int channelMode, long codecSpecific1, long codecSpecific2, long codecSpecific3, long codecSpecific4) {
    BluetoothCodecConfig prevCodecConfig;
    BluetoothCodecConfig newCodecConfig = new BluetoothCodecConfig(codecType, codecPriority, sampleRate, bitsPerSample, channelMode, codecSpecific1, codecSpecific2, codecSpecific3, codecSpecific4);
    synchronized (this) {
        prevCodecConfig = mCodecConfig;
        mCodecConfig = newCodecConfig;
    }
    Intent intent = new Intent(BluetoothA2dp.ACTION_CODEC_CONFIG_CHANGED);
    intent.putExtra(BluetoothCodecConfig.EXTRA_CODEC_CONFIG, newCodecConfig);
    intent.putExtra(BluetoothCodecConfig.EXTRA_PREVIOUS_CODEC_CONFIG, prevCodecConfig);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    log("A2DP Codec Config : " + prevCodecConfig + "->" + newCodecConfig);
    // parameters in the Audio HAL to the Bluetooth stack.
    if (!newCodecConfig.sameAudioFeedingParameters(prevCodecConfig) && (mCurrentDevice != null) && (getCurrentState() == mConnected)) {
        // Add the device only if it is currently connected
        intent.putExtra(BluetoothDevice.EXTRA_DEVICE, mCurrentDevice);
        mAudioManager.handleBluetoothA2dpDeviceConfigChange(mCurrentDevice);
    }
    mContext.sendBroadcast(intent, A2dpService.BLUETOOTH_PERM);
}
#end_block

#method_before
@Rpc(description = "Install certificate for RSA VPN.")
public void installCertificate(@RpcParameter(name = "vpnProfile") JSONObject vpnProfile, @RpcParameter(name = "certFile") String certFile, @RpcParameter(name = "password") String password) throws RemoteException {
    VpnProfile profile = genLegacyVpnProfile(vpnProfile);
    mCertHelper.installCertificate(profile, certFile, password);
}
#method_after
@Rpc(description = "Install certificate for RSA VPNs.")
public void installCertificate(@RpcParameter(name = "vpnProfile") JSONObject vpnProfile, @RpcParameter(name = "certFile") String certFile, @RpcParameter(name = "password") String password) throws RemoteException {
    VpnProfile profile = genLegacyVpnProfile(vpnProfile);
    mCertHelper.installCertificate(profile, certFile, password);
}
#end_block

#method_before
public static Index getInstance(Context context) {
    if (sInstance == null) {
        sInstance = new Index(context, BASE_AUTHORITY);
    }
    return sInstance;
}
#method_after
public static Index getInstance(Context context) {
    if (sInstance == null) {
        synchronized (Index.class) {
            if (sInstance == null) {
                sInstance = new Index(context.getApplicationContext(), BASE_AUTHORITY);
            }
        }
    }
    return sInstance;
}
#end_block

#method_before
public static final ProcessStartResult startWebView(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) {
    return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, null, zygoteArgs);
}
#method_after
public static final ProcessStartResult startWebView(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String invokeWith, String[] zygoteArgs) {
    return WebViewZygote.getProcess().start(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, invokeWith, zygoteArgs);
}
#end_block

#method_before
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    if (app.pid > 0 && app.pid != MY_PID) {
        checkTime(startTime, "startProcess: removing from pids map");
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        checkTime(startTime, "startProcess: done removing from pids map");
        app.setPid(0);
    }
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    checkTime(startTime, "startProcess: starting to update cpu stats");
    updateCpuStats();
    checkTime(startTime, "startProcess: done updating cpu stats");
    try {
        try {
            final int userId = UserHandle.getUserId(app.uid);
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                checkTime(startTime, "startProcess: getting gids from package manager");
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);
                mountExternal = mountServiceInternal.getExternalStorageMountMode(uid, app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[2];
            } else {
                gids = new int[permGids.length + 2];
                System.arraycopy(permGids, 0, gids, 2, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getUserGid(UserHandle.getUserId(uid));
        }
        checkTime(startTime, "startProcess: building args");
        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopComponent != null && app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL && (app.info.flags & ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int debugFlags = 0;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;
            // Also turn on CheckJNI for debuggable apps. It's quite
            // awkward to turn on otherwise.
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // system is booted in safe mode.
        if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if ("1".equals(SystemProperties.get("debug.checkjni"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String genDebugInfoProperty = SystemProperties.get("debug.generate-debug-info");
        if ("true".equals(genDebugInfoProperty)) {
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if ("1".equals(SystemProperties.get("debug.jni.logging"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if ("1".equals(SystemProperties.get("debug.assert"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
            // Enable all debug flags required by the native debugger.
            // Don't interpret anything
            debugFlags |= Zygote.DEBUG_ALWAYS_JIT;
            // Generate debug info
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            // Disbale optimizations
            debugFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;
            mNativeDebuggingApp = null;
        }
        String invokeWith = null;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            // Debuggable apps may include a wrapper script with their library directory.
            String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh";
            if (new File(wrapperFileName).exists()) {
                invokeWith = "/system/bin/logwrapper " + wrapperFileName;
            }
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null)
            entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        Process.ProcessStartResult startResult;
        if (hostingType.equals("webview_service")) {
            startResult = Process.startWebView(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs);
        } else {
            startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs);
        }
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(startTime, "startProcess: done updating battery stats");
        EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : "");
        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, app.info.seinfo, app.info.sourceDir, startResult.pid);
        } catch (RemoteException ex) {
        // Ignore
        }
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }
        checkTime(startTime, "startProcess: building log message");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(startResult.pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, uid);
        if (!isActivityProcess) {
            buf.append(" [");
            buf.append(entryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(hostingType);
        if (hostingNameStr != null) {
            buf.append(" ");
            buf.append(hostingNameStr);
        }
        Slog.i(TAG, buf.toString());
        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        checkTime(startTime, "startProcess: starting to update pids map");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(startResult.pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, "Reusing pid " + startResult.pid + " while app is still mapped to it");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(startTime, "startProcess: done updating pids map");
    } catch (RuntimeException e) {
        Slog.e(TAG, "Failure starting process " + app.processName, e);
        // Something went very wrong while trying to start this process; one
        // common case is when the package is frozen due to an active
        // upgrade. To recover, clean up any active bookkeeping related to
        // starting this process. (We already invoked this method once when
        // the package was initially frozen through KILL_APPLICATION_MSG, so
        // it doesn't hurt to use it again.)
        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
    }
}
#method_after
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    if (app.pid > 0 && app.pid != MY_PID) {
        checkTime(startTime, "startProcess: removing from pids map");
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        checkTime(startTime, "startProcess: done removing from pids map");
        app.setPid(0);
    }
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    checkTime(startTime, "startProcess: starting to update cpu stats");
    updateCpuStats();
    checkTime(startTime, "startProcess: done updating cpu stats");
    try {
        try {
            final int userId = UserHandle.getUserId(app.uid);
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                checkTime(startTime, "startProcess: getting gids from package manager");
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);
                mountExternal = mountServiceInternal.getExternalStorageMountMode(uid, app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[2];
            } else {
                gids = new int[permGids.length + 2];
                System.arraycopy(permGids, 0, gids, 2, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getUserGid(UserHandle.getUserId(uid));
        }
        checkTime(startTime, "startProcess: building args");
        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopComponent != null && app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL && (app.info.flags & ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int debugFlags = 0;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;
            // Also turn on CheckJNI for debuggable apps. It's quite
            // awkward to turn on otherwise.
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // system is booted in safe mode.
        if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if ("1".equals(SystemProperties.get("debug.checkjni"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String genDebugInfoProperty = SystemProperties.get("debug.generate-debug-info");
        if ("true".equals(genDebugInfoProperty)) {
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if ("1".equals(SystemProperties.get("debug.jni.logging"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if ("1".equals(SystemProperties.get("debug.assert"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
            // Enable all debug flags required by the native debugger.
            // Don't interpret anything
            debugFlags |= Zygote.DEBUG_ALWAYS_JIT;
            // Generate debug info
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            // Disbale optimizations
            debugFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;
            mNativeDebuggingApp = null;
        }
        String invokeWith = null;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            // Debuggable apps may include a wrapper script with their library directory.
            String wrapperFileName = app.info.nativeLibraryDir + "/wrap.sh";
            if (new File(wrapperFileName).exists()) {
                invokeWith = "/system/bin/logwrapper " + wrapperFileName;
            }
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null)
            entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        Process.ProcessStartResult startResult;
        if (hostingType.equals("webview_service")) {
            startResult = Process.startWebView(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, null, entryPointArgs);
        } else {
            startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, invokeWith, entryPointArgs);
        }
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(startTime, "startProcess: done updating battery stats");
        EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : "");
        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, app.info.seinfo, app.info.sourceDir, startResult.pid);
        } catch (RemoteException ex) {
        // Ignore
        }
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }
        checkTime(startTime, "startProcess: building log message");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(startResult.pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, uid);
        if (!isActivityProcess) {
            buf.append(" [");
            buf.append(entryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(hostingType);
        if (hostingNameStr != null) {
            buf.append(" ");
            buf.append(hostingNameStr);
        }
        Slog.i(TAG, buf.toString());
        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        checkTime(startTime, "startProcess: starting to update pids map");
        ProcessRecord oldApp;
        synchronized (mPidsSelfLocked) {
            oldApp = mPidsSelfLocked.get(startResult.pid);
        }
        // If there is already an app occupying that pid that hasn't been cleaned up
        if (oldApp != null && !app.isolated) {
            // Clean up anything relating to this pid first
            Slog.w(TAG, "Reusing pid " + startResult.pid + " while app is still mapped to it");
            cleanUpApplicationRecordLocked(oldApp, false, false, -1, true);
        }
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(startTime, "startProcess: done updating pids map");
    } catch (RuntimeException e) {
        Slog.e(TAG, "Failure starting process " + app.processName, e);
        // Something went very wrong while trying to start this process; one
        // common case is when the package is frozen due to an active
        // upgrade. To recover, clean up any active bookkeeping related to
        // starting this process. (We already invoked this method once when
        // the package was initially frozen through KILL_APPLICATION_MSG, so
        // it doesn't hurt to use it again.)
        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
    }
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("HSWanMetrics{mStatus=%s, mSymmetric=%s, mCapped=%s, " + "mDlSpeed=%d, mUlSpeed=%d, mDlLoad=%f, mUlLoad=%f, mLMD=%d}", mStatus, mSymmetric, mCapped, mDownlinkSpeed, mUplinkSpeed, mDownlinkLoad * 100.0 / 256.0, mUplinkLoad * 100.0 / 256.0, mLMD);
}
#method_after
@Override
public String toString() {
    return String.format("HSWanMetrics{mStatus=%s, mSymmetric=%s, mCapped=%s, " + "mDlSpeed=%d, mUlSpeed=%d, mDlLoad=%f, mUlLoad=%f, mLMD=%d}", mStatus, mSymmetric, mCapped, mDownlinkSpeed, mUplinkSpeed, mDownlinkLoad * 100.0 / MAX_LOAD, mUplinkLoad * 100.0 / MAX_LOAD, mLMD);
}
#end_block

#method_before
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    mValidScoredNetwork = buildScoredNetwork(VALID_KEY, mockRssiCurve);
    mScoreCache = new WifiNetworkScoreCache(mockContext);
    initializeCacheWithValidScoredNetwork();
    HandlerThread thread = new HandlerThread("WifiNetworkScoreCacheTest Handler Thread");
    thread.start();
    mHandler = new Handler(thread.getLooper());
}
#method_after
@Before
public void setUp() {
    MockitoAnnotations.initMocks(this);
    when(mockContext.getApplicationContext()).thenReturn(mockApplicationContext);
    mValidScoredNetwork = buildScoredNetwork(VALID_KEY, mockRssiCurve);
    mScoreCache = new WifiNetworkScoreCache(mockContext);
    initializeCacheWithValidScoredNetwork();
    HandlerThread thread = new HandlerThread("WifiNetworkScoreCacheTest Handler Thread");
    thread.start();
    mHandler = new Handler(thread.getLooper());
    mLatch = new CountDownLatch(1);
    mCacheListener = new CacheListener(mHandler) {

        @Override
        public void networkCacheUpdated(List<ScoredNetwork> updatedNetworks) {
            mUpdatedNetworksCaptor = updatedNetworks;
            mLatch.countDown();
        }
    };
}
#end_block

#method_before
@Override
public final void updateScores(List<ScoredNetwork> networks) {
    if (networks == null) {
        return;
    }
    Log.e(TAG, "updateScores list size=" + networks.size());
    synchronized (mNetworkCache) {
        for (ScoredNetwork network : networks) {
            String networkKey = buildNetworkKey(network);
            if (networkKey == null)
                continue;
            mNetworkCache.put(networkKey, network);
        }
    }
    if (mListener != null) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                mListener.networkCacheUpdated(networks);
            }
        });
    }
}
#method_after
@Override
public final void updateScores(List<ScoredNetwork> networks) {
    if (networks == null || networks.isEmpty()) {
        return;
    }
    Log.d(TAG, "updateScores list size=" + networks.size());
    synchronized (mNetworkCache) {
        for (ScoredNetwork network : networks) {
            String networkKey = buildNetworkKey(network);
            if (networkKey == null)
                continue;
            mNetworkCache.put(networkKey, network);
        }
    }
    synchronized (mCacheLock) {
        if (mListener != null) {
            mListener.post(networks);
        }
    }
}
#end_block

#method_before
@Nullable
@Override
public String getErrorText(String inputString) {
    try {
        if (inputString == null || inputString.trim().length() == 0) {
            return "Enter a new name";
        }
        if (myAllowXmlExtension && inputString.endsWith(DOT_XML)) {
            inputString = inputString.substring(0, inputString.length() - DOT_XML.length());
        }
        if (myAllowXmlExtension && myIsImageType && AndroidUtils.hasImageExtension(inputString)) {
            inputString = inputString.substring(0, inputString.lastIndexOf('.'));
        }
        if (!myIsFileType) {
            inputString = convertNameToRFormat(inputString);
        }
        if (myAllowXmlExtension) {
            if (inputString.indexOf('.') != -1 && !inputString.endsWith(DOT_XML)) {
                if (myIsImageType) {
                    return "The filename must end with .xml or .png";
                } else {
                    return "The filename must end with .xml";
                }
            }
        }
        // be represented as Java identifiers in the R file:
        if (!Character.isJavaIdentifierStart(inputString.charAt(0))) {
            return "The resource name must begin with a character";
        }
        for (int i = 1, n = inputString.length(); i < n; i++) {
            char c = inputString.charAt(i);
            if (!Character.isJavaIdentifierPart(c)) {
                return String.format("'%1$c' is not a valid resource name character", c);
            }
        }
        if (myIsFileType) {
            char first = inputString.charAt(0);
            if (!(first >= 'a' && first <= 'z')) {
                return String.format("File-based resource names must start with a lowercase letter.");
            }
            // "%s: Invalid file name: must contain only [a-z0-9_.]","
            for (int i = 0, n = inputString.length(); i < n; i++) {
                char c = inputString.charAt(i);
                if (!((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_')) {
                    return String.format("File-based resource names must contain only lowercase a-z, 0-9, or _.");
                }
            }
        }
        if (!AndroidUtils.isIdentifier(inputString)) {
            // but we've dealt with those above.
            return String.format("%1$s is not a valid name (reserved Java keyword)", inputString);
        }
        if (myExisting != null && (myUnique || myExist)) {
            boolean exists = myExisting.contains(inputString);
            if (myUnique && exists) {
                return String.format("%1$s already exists", inputString);
            } else if (myExist && !exists) {
                return String.format("%1$s does not exist", inputString);
            }
        }
        return null;
    } catch (Exception e) {
        LOG.error("Validation failed: " + e.toString(), e);
        return "";
    }
}
#method_after
@Nullable
@Override
public String getErrorText(String inputString) {
    try {
        if (inputString == null || inputString.trim().length() == 0) {
            return "Enter a new name";
        }
        if (myAllowXmlExtension && inputString.endsWith(DOT_XML)) {
            inputString = inputString.substring(0, inputString.length() - DOT_XML.length());
        }
        if (myAllowXmlExtension && myIsImageType && AndroidUtils.hasImageExtension(inputString)) {
            inputString = inputString.substring(0, inputString.lastIndexOf('.'));
        }
        if (!myIsFileType) {
            inputString = AndroidResourceUtil.getFieldNameByResourceName(inputString);
        }
        if (myAllowXmlExtension) {
            if (inputString.indexOf('.') != -1 && !inputString.endsWith(DOT_XML)) {
                if (myIsImageType) {
                    return "The filename must end with .xml or .png";
                } else {
                    return "The filename must end with .xml";
                }
            }
        }
        // be represented as Java identifiers in the R file:
        if (!Character.isJavaIdentifierStart(inputString.charAt(0))) {
            return "The resource name must begin with a character";
        }
        for (int i = 1, n = inputString.length(); i < n; i++) {
            char c = inputString.charAt(i);
            if (!Character.isJavaIdentifierPart(c)) {
                return String.format("'%1$c' is not a valid resource name character", c);
            }
        }
        if (myIsFileType) {
            char first = inputString.charAt(0);
            if (!(first >= 'a' && first <= 'z')) {
                return String.format("File-based resource names must start with a lowercase letter.");
            }
            // "%s: Invalid file name: must contain only [a-z0-9_.]","
            for (int i = 0, n = inputString.length(); i < n; i++) {
                char c = inputString.charAt(i);
                if (!((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9') || c == '_')) {
                    return String.format("File-based resource names must contain only lowercase a-z, 0-9, or _.");
                }
            }
        }
        if (!AndroidUtils.isIdentifier(inputString)) {
            // but we've dealt with those above.
            return String.format("%1$s is not a valid name (reserved Java keyword)", inputString);
        }
        if (myExisting != null && (myUnique || myExist)) {
            boolean exists = myExisting.contains(inputString);
            if (myUnique && exists) {
                return String.format("%1$s already exists", inputString);
            } else if (myExist && !exists) {
                return String.format("%1$s does not exist", inputString);
            }
        }
        return null;
    } catch (Exception e) {
        LOG.error("Validation failed: " + e.toString(), e);
        return "";
    }
}
#end_block

#method_before
public static ResourceNameValidator create(boolean allowXmlExtension, @Nullable LocalResourceRepository appResources, @NotNull ResourceType type) {
    Set<String> existing = null;
    if (appResources != null) {
        existing = new HashSet<String>();
        Collection<String> items = appResources.getItemsOfType(type);
        for (String resourceName : items) {
            existing.add(convertNameToRFormat(resourceName));
        }
    }
    boolean isFileType = ResourceHelper.isFileBasedResourceType(type);
    return new ResourceNameValidator(allowXmlExtension, existing, isFileType, type == ResourceType.DRAWABLE);
}
#method_after
public static ResourceNameValidator create(boolean allowXmlExtension, @Nullable LocalResourceRepository appResources, @NotNull ResourceType type) {
    Set<String> existing = null;
    if (appResources != null) {
        existing = new HashSet<String>();
        Collection<String> items = appResources.getItemsOfType(type);
        for (String resourceName : items) {
            existing.add(AndroidResourceUtil.getFieldNameByResourceName(resourceName));
        }
    }
    boolean isFileType = ResourceHelper.isFileBasedResourceType(type);
    return new ResourceNameValidator(allowXmlExtension, existing, isFileType, type == ResourceType.DRAWABLE);
}
#end_block

#method_before
void start(Callback<LocalPrintJob> callback) {
    if (DEBUG)
        Log.d(TAG, "start() " + mPrintJob);
    if (mState != STATE_INIT) {
        Log.w(TAG, "Invalid start state " + mState);
        return;
    }
    mPrintJob.start();
    mState = STATE_DISCOVERY;
    mCallback = callback;
    mPrintService.getDiscovery().start(this);
    mMainHandler.postDelayed(new Runnable() {

        @Override
        public void run() {
            if (DEBUG)
                Log.d(TAG, "Discovery timeout");
            if (mState == STATE_DISCOVERY) {
                mPrintService.getDiscovery().stop(LocalPrintJob.this);
                finish(false, mPrintService.getString(R.string.printer_offline));
            }
        }
    }, DISCOVERY_TIMEOUT);
}
#method_after
void start(Consumer<LocalPrintJob> callback) {
    if (DEBUG)
        Log.d(TAG, "start() " + mPrintJob);
    if (mState != STATE_INIT) {
        Log.w(TAG, "Invalid start state " + mState);
        return;
    }
    mPrintJob.start();
    // Acquire a lock so that WiFi isn't put to sleep while we send the job
    mPrintService.lockWifi();
    mState = STATE_DISCOVERY;
    mCompleteConsumer = callback;
    mPrintService.getDiscovery().start(this);
    mMainHandler.postDelayed(() -> {
        if (DEBUG)
            Log.d(TAG, "Discovery timeout");
        if (mState == STATE_DISCOVERY) {
            mPrintService.getDiscovery().stop(LocalPrintJob.this);
            finish(false, mPrintService.getString(R.string.printer_offline));
        }
    }, DISCOVERY_TIMEOUT);
}
#end_block

#method_before
void cancel() {
    if (DEBUG)
        Log.d(TAG, "cancel() " + mPrintJob + " in state " + mState);
    switch(mState) {
        case STATE_DISCOVERY:
            // Cancel immediately
            mPrintService.getDiscovery().stop(this);
            mState = STATE_CANCEL;
            finish(false, null);
            break;
        case STATE_STARTED:
            // Request cancel and wait for completion
            mState = STATE_CANCEL;
            mBackend.cancel();
            break;
    }
}
#method_after
void cancel() {
    if (DEBUG)
        Log.d(TAG, "cancel() " + mPrintJob + " in state " + mState);
    switch(mState) {
        case STATE_DISCOVERY:
            // Cancel immediately
            mPrintService.getDiscovery().stop(this);
            mState = STATE_CANCEL;
            finish(false, null);
            break;
        case STATE_DELIVERING:
            // Request cancel and wait for completion
            mState = STATE_CANCEL;
            mBackend.cancel();
            break;
    }
}
#end_block

#method_before
@Override
public void onPrinterFound(DiscoveredPrinter printer) {
    if (mState != STATE_DISCOVERY)
        return;
    if (printer.getId(mPrintService).equals(mPrintJob.getInfo().getPrinterId())) {
        if (DEBUG)
            Log.d(TAG, "onPrinterFound() " + printer.name + " state=" + mState);
        mPath = printer.path;
        mPrintService.getCapabilitiesCache().request(printer, true, new Callback<LocalPrinterCapabilities>() {

            @Override
            public void onCallback(LocalPrinterCapabilities localPrinterCapabilities) {
                onCapabilities(localPrinterCapabilities);
            }
        });
        mPrintService.getDiscovery().stop(this);
    }
}
#method_after
@Override
public void onPrinterFound(DiscoveredPrinter printer) {
    if (mState != STATE_DISCOVERY)
        return;
    if (printer.getId(mPrintService).equals(mPrintJob.getInfo().getPrinterId())) {
        if (DEBUG)
            Log.d(TAG, "onPrinterFound() " + printer.name + " state=" + mState);
        mPath = printer.path;
        mPrintService.getCapabilitiesCache().request(printer, true, this::handleCapabilities);
        mPrintService.getDiscovery().stop(this);
    }
}
#end_block

#method_before
private void finish(boolean success, String error) {
    mMainHandler.removeCallbacksAndMessages(null);
    if (success) {
        // Job must not be blocked before completion
        mPrintJob.start();
        mPrintJob.complete();
    } else if (mState == STATE_CANCEL) {
        mPrintJob.cancel();
    } else {
        mPrintJob.fail(error);
    }
    mState = STATE_DONE;
    mCallback.onCallback(LocalPrintJob.this);
}
#method_after
private void finish(boolean success, String error) {
    mPrintService.unlockWifi();
    mBackend.closeDocument();
    mMainHandler.removeCallbacksAndMessages(null);
    if (success) {
        // Job must not be blocked before completion
        mPrintJob.start();
        mPrintJob.complete();
    } else if (mState == STATE_CANCEL) {
        mPrintJob.cancel();
    } else {
        mPrintJob.fail(error);
    }
    mState = STATE_DONE;
    mCompleteConsumer.accept(LocalPrintJob.this);
}
#end_block

#method_before
public void start(Listener listener) {
    mListeners.add(listener);
    for (DiscoveredPrinter printer : mPrinters.values()) {
        listener.onPrinterFound(printer);
    }
    start();
}
#method_after
public void start(Listener listener) {
    mListeners.add(listener);
    mPrinters.values().forEach(listener::onPrinterFound);
    start();
}
#end_block

#method_before
void printerFound(DiscoveredPrinter printer) {
    DiscoveredPrinter current = mPrinters.get(printer.getUri());
    if (Objects.equals(current, printer)) {
        Log.d(TAG, "Already have the reported printer, ignoring");
        return;
    }
    mPrinters.put(printer.getUri(), printer);
    for (Listener listener : mListeners) {
        listener.onPrinterFound(printer);
    }
}
#method_after
void printerFound(DiscoveredPrinter printer) {
    DiscoveredPrinter current = mPrinters.get(printer.getUri());
    if (Objects.equals(current, printer)) {
        if (DEBUG)
            Log.d(TAG, "Already have the reported printer, ignoring");
        return;
    }
    mPrinters.put(printer.getUri(), printer);
    for (Listener listener : mListeners) {
        listener.onPrinterFound(printer);
    }
}
#end_block

#method_before
void allPrintersLost() {
    for (DiscoveredPrinter printer : new ArrayList<>(getPrinters())) {
        printerLost(printer.getUri());
    }
}
#method_after
void allPrintersLost() {
    for (DiscoveredPrinter printer : mPrinters.values()) {
        for (Listener listener : mListeners) {
            listener.onPrinterLost(printer);
        }
    }
    mPrinters.clear();
}
#end_block

#method_before
public Collection<DiscoveredPrinter> getPrinters() {
    return mPrinters.values();
}
#method_after
Collection<DiscoveredPrinter> getPrinters() {
    return mPrinters.values();
}
#end_block

#method_before
private static DiscoveredPrinter toNetworkPrinter(NsdServiceInfo info) {
    // Honor printers that deliberately opt-out
    if (Objects.equals(getStringAttribute(info, ATTRIBUTE_PRINT_WFDS), VALUE_PRINT_WFDS_OPT_OUT)) {
        if (DEBUG)
            Log.d(TAG, "Opted out: " + info);
        return null;
    }
    // Collect resource path
    String resourcePath = getStringAttribute(info, ATTRIBUTE_RP);
    if (TextUtils.isEmpty(resourcePath)) {
        if (DEBUG)
            Log.d(TAG, "Missing RP" + info);
        return null;
    }
    if (resourcePath.startsWith("/")) {
        resourcePath = resourcePath.substring(1);
    }
    // Hopefully has a UUID
    Uri uuidUri = null;
    String uuid = getStringAttribute(info, ATTRIBUTE_UUID);
    if (!TextUtils.isEmpty(uuid)) {
        uuidUri = Uri.parse(PREFIX_URN_UUID + uuid);
    }
    // Must be IPv4
    if (!(info.getHost() instanceof Inet4Address)) {
        if (DEBUG)
            Log.d(TAG, "Not IPv4" + info);
        return null;
    }
    Uri path = Uri.parse("ipp://" + info.getHost().getHostAddress() + ":" + info.getPort() + "/" + resourcePath);
    String location = getStringAttribute(info, ATTRIBUTE_NOTE);
    return new DiscoveredPrinter(uuidUri, info.getServiceName(), path, location);
}
#method_after
private static DiscoveredPrinter toNetworkPrinter(NsdServiceInfo info) {
    // Honor printers that deliberately opt-out
    if (VALUE_PRINT_WFDS_OPT_OUT.equals(getStringAttribute(info, ATTRIBUTE_PRINT_WFDS))) {
        if (DEBUG)
            Log.d(TAG, "Opted out: " + info);
        return null;
    }
    // Collect resource path
    String resourcePath = getStringAttribute(info, ATTRIBUTE_RP);
    if (TextUtils.isEmpty(resourcePath)) {
        if (DEBUG)
            Log.d(TAG, "Missing RP" + info);
        return null;
    }
    if (resourcePath.startsWith("/")) {
        resourcePath = resourcePath.substring(1);
    }
    // Hopefully has a UUID
    Uri uuidUri = null;
    String uuid = getStringAttribute(info, ATTRIBUTE_UUID);
    if (!TextUtils.isEmpty(uuid)) {
        uuidUri = Uri.parse(PREFIX_URN_UUID + uuid);
    }
    // Must be IPv4
    if (!(info.getHost() instanceof Inet4Address)) {
        if (DEBUG)
            Log.d(TAG, "Not IPv4" + info);
        return null;
    }
    Uri path = Uri.parse("ipp://" + info.getHost().getHostAddress() + ":" + info.getPort() + "/" + resourcePath);
    String location = getStringAttribute(info, ATTRIBUTE_NOTE);
    return new DiscoveredPrinter(uuidUri, info.getServiceName(), path, location);
}
#end_block

#method_before
@Override
void onStop() {
    if (DEBUG)
        Log.d(TAG, "onStop()");
    if (mServiceListener != null) {
        mNsdManager.stopServiceDiscovery(mServiceListener);
        mServiceListener = null;
    }
    mMainHandler.removeCallbacksAndMessages(null);
    NsdResolveQueue.getInstance().clear();
}
#method_after
@Override
void onStop() {
    if (DEBUG)
        Log.d(TAG, "onStop()");
    if (mServiceListener != null) {
        mNsdManager.stopServiceDiscovery(mServiceListener);
        mServiceListener = null;
    }
    mMainHandler.removeCallbacksAndMessages(null);
    NsdResolveQueue.getInstance(getPrintService()).clear();
}
#end_block

#method_before
@Override
public void onDiscoveryStopped(String s) {
    if (DEBUG)
        Log.d(TAG, "onDiscoveryStopped");
    // On the main thread, notify loss of all known printers
    mMainHandler.post(new Runnable() {

        @Override
        public void run() {
            allPrintersLost();
        }
    });
}
#method_after
@Override
public void onDiscoveryStopped(String s) {
    if (DEBUG)
        Log.d(TAG, "onDiscoveryStopped");
    // On the main thread, notify loss of all known printers
    mMainHandler.post(() -> allPrintersLost());
}
#end_block

#method_before
@Override
public void onServiceFound(final NsdServiceInfo info) {
    if (DEBUG)
        Log.d(TAG, "onServiceFound - " + info.getServiceName());
    NsdResolveQueue.getInstance().resolve(mNsdManager, info, this);
}
#method_after
@Override
public void onServiceFound(final NsdServiceInfo info) {
    if (DEBUG)
        Log.d(TAG, "onServiceFound - " + info.getServiceName());
    NsdResolveQueue.getInstance(getPrintService()).resolve(mNsdManager, info, this);
}
#end_block

#method_before
@Override
public void onServiceLost(final NsdServiceInfo info) {
    if (DEBUG)
        Log.d(TAG, "onServiceLost - " + info.getServiceName());
    // On the main thread, seek the missing printer by name and notify its loss
    mMainHandler.post(new Runnable() {

        @Override
        public void run() {
            for (DiscoveredPrinter printer : getPrinters()) {
                if (TextUtils.equals(printer.name, info.getServiceName())) {
                    printerLost(printer.getUri());
                    return;
                }
            }
        }
    });
}
#method_after
@Override
public void onServiceLost(final NsdServiceInfo info) {
    if (DEBUG)
        Log.d(TAG, "onServiceLost - " + info.getServiceName());
    // On the main thread, seek the missing printer by name and notify its loss
    mMainHandler.post(() -> {
        for (DiscoveredPrinter printer : getPrinters()) {
            if (TextUtils.equals(printer.name, info.getServiceName())) {
                printerLost(printer.getUri());
                return;
            }
        }
    });
}
#end_block

#method_before
@Override
public void onServiceResolved(final NsdServiceInfo info) {
    final DiscoveredPrinter printer = toNetworkPrinter(info);
    if (DEBUG)
        Log.d(TAG, "Service " + info.getServiceName() + " resolved to " + printer);
    if (printer == null) {
        return;
    }
    mMainHandler.post(new Runnable() {

        @Override
        public void run() {
            printerFound(printer);
        }
    });
}
#method_after
@Override
public void onServiceResolved(final NsdServiceInfo info) {
    final DiscoveredPrinter printer = toNetworkPrinter(info);
    if (DEBUG)
        Log.d(TAG, "Service " + info.getServiceName() + " resolved to " + printer);
    if (printer == null) {
        return;
    }
    mMainHandler.post(() -> printerFound(printer));
}
#end_block

#method_before
public static NsdResolveQueue getInstance() {
    synchronized (sLock) {
        if (sInstance == null) {
            sInstance = new NsdResolveQueue();
        }
        return sInstance;
    }
}
#method_after
public static NsdResolveQueue getInstance(Context context) {
    synchronized (sLock) {
        if (sInstance == null) {
            sInstance = new NsdResolveQueue(context);
        }
        return sInstance;
    }
}
#end_block

#method_before
public void resolve(NsdManager nsdManager, NsdServiceInfo serviceInfo, NsdManager.ResolveListener listener) {
    synchronized (mLock) {
        Log.d(TAG, "Adding resolve of " + serviceInfo.getServiceName() + " to queue size=" + mResolveRequests.size());
        mResolveRequests.addLast(new NsdResolveRequest(nsdManager, serviceInfo, listener));
        if (mResolveRequests.size() == 1) {
            resolveNextRequest();
        }
    }
}
#method_after
public void resolve(NsdManager nsdManager, NsdServiceInfo serviceInfo, NsdManager.ResolveListener listener) {
    if (DEBUG) {
        Log.d(TAG, "Adding resolve of " + serviceInfo.getServiceName() + " to queue size=" + mResolveRequests.size());
    }
    mResolveRequests.addLast(new NsdResolveRequest(nsdManager, serviceInfo, listener));
    if (mResolveRequests.size() == 1) {
        resolveNextRequest();
    }
}
#end_block

#method_before
void clear() {
    synchronized (mLock) {
        while (mResolveRequests.size() > 1) {
            mResolveRequests.remove(1);
        }
    }
}
#method_after
void clear() {
    while (mResolveRequests.size() > 1) {
        mResolveRequests.remove(1);
    }
}
#end_block

#method_before
@Override
public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
    if (DEBUG) {
        Log.d(TAG, "onResolveFailed " + serviceInfo.getServiceName() + " errorCode=" + errorCode + " (" + (System.currentTimeMillis() - mStartTime) + " ms)");
    }
    listener.onResolveFailed(serviceInfo, errorCode);
    synchronized (mLock) {
        mResolveRequests.pop();
        resolveNextRequest();
    }
}
#method_after
@Override
public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) {
    if (DEBUG) {
        Log.d(TAG, "onResolveFailed " + serviceInfo.getServiceName() + " errorCode=" + errorCode + " (" + (System.currentTimeMillis() - mStartTime) + " ms)");
    }
    mMainHandler.post(() -> {
        listener.onResolveFailed(serviceInfo, errorCode);
        mResolveRequests.pop();
        resolveNextRequest();
    });
}
#end_block

#method_before
@Override
public void onServiceResolved(NsdServiceInfo serviceInfo) {
    if (DEBUG) {
        Log.d(TAG, "onServiceResolved " + serviceInfo.getServiceName() + " (" + (System.currentTimeMillis() - mStartTime) + " ms)");
    }
    listener.onServiceResolved(serviceInfo);
    synchronized (mLock) {
        mResolveRequests.pop();
        resolveNextRequest();
    }
}
#method_after
@Override
public void onServiceResolved(NsdServiceInfo serviceInfo) {
    if (DEBUG) {
        Log.d(TAG, "onServiceResolved " + serviceInfo.getServiceName() + " (" + (System.currentTimeMillis() - mStartTime) + " ms)");
    }
    mMainHandler.post(() -> {
        listener.onServiceResolved(serviceInfo);
        mResolveRequests.pop();
        resolveNextRequest();
    });
}
#end_block

#method_before
public static void deleteAll(File target) throws IOException {
    if (DEBUG)
        Log.d(TAG, "Deleting " + target);
    if (target.isDirectory()) {
        for (File child : target.listFiles()) {
            deleteAll(child);
        }
    }
    // noinspection ResultOfMethodCallIgnored
    target.delete();
}
#method_after
public static void deleteAll(File target) {
    if (DEBUG)
        Log.d(TAG, "Deleting " + target);
    if (target.isDirectory()) {
        for (File child : target.listFiles()) {
            deleteAll(child);
        }
    }
    target.delete();
}
#end_block

#method_before
@Override
protected Integer doInBackground(Void... voids) {
    if (DEBUG)
        Log.d(TAG, "doInBackground() job=" + mJobParams + ", cap=" + mCapabilities);
    File tempFolder = new File(mContext.getFilesDir(), Backend.TEMP_JOB_FOLDER);
    if (!FileUtils.makeDirectory(tempFolder)) {
        Log.w(TAG, "makeDirectory failure");
        return Backend.ERROR_FILE;
    }
    File pdfFile = new File(tempFolder, mJobId + ".pdf");
    try {
        try {
            FileUtils.copy(new BufferedInputStream(new FileInputStream(mSourceFileDescriptor)), new BufferedOutputStream(new FileOutputStream(pdfFile)));
        } catch (IOException e) {
            Log.w(TAG, "Error while copying to " + pdfFile, e);
            return Backend.ERROR_FILE;
        }
        String[] files = new String[] { pdfFile.toString() };
        // Address, without port.
        String address = mDestination.getHost() + mDestination.getPath();
        if (isCancelled())
            return Backend.ERROR_CANCEL;
        // Get default job parameters
        int result = mBackend.getJni().callNativeGetDefaultJobParameters(mDestination.getHost(), mDestination.getPort(), mJobParams, mCapabilities);
        if (result != 0) {
            if (DEBUG)
                Log.w(TAG, "callNativeGetDefaultJobParameters failure: " + result);
            return Backend.ERROR_UNKNOWN;
        }
        if (isCancelled())
            return Backend.ERROR_CANCEL;
        // Fill in job parameters from capabilities and print job info.
        populateJobParams();
        // Finalize job parameters
        mBackend.getJni().callNativeGetFinalJobParameters(address, mDestination.getPort(), mJobParams, mCapabilities);
        if (isCancelled())
            return Backend.ERROR_CANCEL;
        if (DEBUG) {
            Log.d(TAG, "callNativeStartJob address=" + address + " port=" + mDestination.getPort() + " mime=" + MIME_TYPE_PDF + " files=" + files[0] + " job=" + mJobParams);
        }
        // Initiate job
        result = mBackend.getJni().callNativeStartJob(address, mDestination.getPort(), MIME_TYPE_PDF, mJobParams, mCapabilities, files, null);
        if (result < 0) {
            Log.w(TAG, "callNativeStartJob failure: " + result);
            return Backend.ERROR_UNKNOWN;
        }
        pdfFile = null;
        return result;
    } finally {
        if (pdfFile != null) {
            // noinspection ResultOfMethodCallIgnored
            pdfFile.delete();
        }
    }
}
#method_after
@Override
protected Integer doInBackground(Void... voids) {
    if (DEBUG)
        Log.d(TAG, "doInBackground() job=" + mJobParams + ", cap=" + mCapabilities);
    File tempFolder = new File(mContext.getFilesDir(), Backend.TEMP_JOB_FOLDER);
    if (!FileUtils.makeDirectory(tempFolder)) {
        Log.w(TAG, "makeDirectory failure");
        return Backend.ERROR_FILE;
    }
    File pdfFile = new File(tempFolder, mJobId + ".pdf");
    try {
        try {
            FileUtils.copy(new BufferedInputStream(new FileInputStream(mSourceFileDescriptor)), new BufferedOutputStream(new FileOutputStream(pdfFile)));
        } catch (IOException e) {
            Log.w(TAG, "Error while copying to " + pdfFile, e);
            return Backend.ERROR_FILE;
        }
        String[] files = new String[] { pdfFile.toString() };
        // Address, without port.
        String address = mDestination.getHost() + mDestination.getPath();
        if (isCancelled())
            return Backend.ERROR_CANCEL;
        // Get default job parameters
        int result = mBackend.nativeGetDefaultJobParameters(mJobParams);
        if (result != 0) {
            if (DEBUG)
                Log.w(TAG, "nativeGetDefaultJobParameters failure: " + result);
            return Backend.ERROR_UNKNOWN;
        }
        if (isCancelled())
            return Backend.ERROR_CANCEL;
        // Fill in job parameters from capabilities and print job info.
        populateJobParams();
        // Finalize job parameters
        mBackend.nativeGetFinalJobParameters(mJobParams, mCapabilities);
        if (isCancelled())
            return Backend.ERROR_CANCEL;
        if (DEBUG) {
            Log.d(TAG, "nativeStartJob address=" + address + " port=" + mDestination.getPort() + " mime=" + MIME_TYPE_PDF + " files=" + files[0] + " job=" + mJobParams);
        }
        // Initiate job
        result = mBackend.nativeStartJob(Backend.getIp(address), mDestination.getPort(), MIME_TYPE_PDF, mJobParams, mCapabilities, files, null);
        if (result < 0) {
            Log.w(TAG, "nativeStartJob failure: " + result);
            return Backend.ERROR_UNKNOWN;
        }
        pdfFile = null;
        return result;
    } finally {
        if (pdfFile != null) {
            pdfFile.delete();
        }
    }
}
#end_block

#method_before
@Override
public void onCreate() {
    if (DEBUG) {
        try {
            PackageInfo pInfo = getPackageManager().getPackageInfo(getPackageName(), 0);
            String version = pInfo.versionName;
            Log.d(TAG, "onCreate() " + version);
        } catch (PackageManager.NameNotFoundException ignored) {
        }
    }
    super.onCreate();
    sInstance = new WeakReference<>(this);
    mCapabilitiesCache = new CapabilitiesCache(this);
    mManualDiscovery = new ManualDiscovery(this);
    mDiscovery = new MultiDiscovery(this, new WifiMonitor.Factory(), new MdnsDiscovery(this), mManualDiscovery);
    mJobQueue = new JobQueue();
    mMainHandler = new Handler(getMainLooper());
}
#method_after
@Override
public void onCreate() {
    if (DEBUG) {
        try {
            PackageInfo pInfo = getPackageManager().getPackageInfo(getPackageName(), 0);
            String version = pInfo.versionName;
            Log.d(TAG, "onCreate() " + version);
        } catch (PackageManager.NameNotFoundException ignored) {
        }
    }
    super.onCreate();
    sInstance = new WeakReference<>(this);
    mBackend = new Backend(this);
    mCapabilitiesCache = new CapabilitiesCache(this, mBackend, CapabilitiesCache.DEFAULT_MAX_CONCURRENT);
    mManualDiscovery = new ManualDiscovery(this);
    mDiscovery = new MultiDiscovery(this, new WifiMonitor.Factory(), new MdnsDiscovery(this), mManualDiscovery);
    mJobQueue = new JobQueue();
    mMainHandler = new Handler(getMainLooper());
    WifiManager wifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
    mWifiLock = wifiManager.createWifiLock(WifiManager.WIFI_MODE_FULL, TAG);
}
#end_block

#method_before
@Override
public void onDestroy() {
    if (DEBUG)
        Log.d(TAG, "onDestroy()");
    mCapabilitiesCache.close();
    mManualDiscovery.close();
    Backend.getInstance(this).close();
    sInstance = null;
    mMainHandler.removeCallbacksAndMessages(null);
    super.onDestroy();
}
#method_after
@Override
public void onDestroy() {
    if (DEBUG)
        Log.d(TAG, "onDestroy()");
    mCapabilitiesCache.close();
    mManualDiscovery.close();
    mBackend.close();
    unlockWifi();
    sInstance = null;
    mMainHandler.removeCallbacksAndMessages(null);
    super.onDestroy();
}
#end_block

#method_before
@Override
protected PrinterDiscoverySession onCreatePrinterDiscoverySession() {
    if (DEBUG)
        Log.d(TAG, "onCreatePrinterDiscoverySession");
    if (!mWifiChecked && !WifiMonitor.isConnected(this)) {
        Toast.makeText(this, getString(R.string.wifi_required, getString(R.string.app_name)), Toast.LENGTH_LONG).show();
        mWifiChecked = true;
    }
    return new LocalDiscoverySession(this);
}
#method_after
@Override
protected PrinterDiscoverySession onCreatePrinterDiscoverySession() {
    if (DEBUG)
        Log.d(TAG, "onCreatePrinterDiscoverySession");
    return new LocalDiscoverySession(this);
}
#end_block

#method_before
@Override
protected void onPrintJobQueued(PrintJob printJob) {
    if (DEBUG)
        Log.d(TAG, "onPrintJobQueued");
    if (WifiMonitor.isConnected(this)) {
        mJobQueue.print(new LocalPrintJob(this, Backend.getInstance(this), printJob));
    } else {
        printJob.fail(getString(R.string.wifi_not_connected));
    }
}
#method_after
@Override
protected void onPrintJobQueued(PrintJob printJob) {
    if (DEBUG)
        Log.d(TAG, "onPrintJobQueued");
    if (WifiMonitor.isConnected(this)) {
        mJobQueue.print(new LocalPrintJob(this, mBackend, printJob));
    } else {
        printJob.fail(getString(R.string.wifi_not_connected));
    }
}
#end_block

#method_before
public void addManualPrinter(String hostname, PrinterAddCallback callback) {
    if (DEBUG)
        Log.d(TAG, "addManualPrinter " + hostname);
    // Repair supplied hostname as much as possible
    Uri base = Uri.parse(DEFAULT_IPP_SCHEME + "://" + hostname + ":" + DEFAULT_IPP_PORT);
    CapabilitiesCallback capabilitiesCallback = new CapabilitiesCallback(sIppPaths.length, callback);
    // No path was supplied, try known paths
    for (String path : sIppPaths) {
        DiscoveredPrinter printer = new DiscoveredPrinter(null, "unknown", base.buildUpon().encodedPath(path).build(), null);
        getPrintService().getCapabilitiesCache().request(printer, false, capabilitiesCallback);
    }
}
#method_after
public void addManualPrinter(String hostname, PrinterAddCallback callback) {
    if (DEBUG)
        Log.d(TAG, "addManualPrinter " + hostname);
    // Repair supplied hostname as much as possible
    Uri base = Uri.parse(DEFAULT_IPP_SCHEME + "://" + hostname + ":" + DEFAULT_IPP_PORT);
    new CapabilitiesFinder(base, callback).startNext();
}
#end_block

#method_before
private void save() {
    File cached = new File(getPrintService().getCacheDir(), CACHE_FILE);
    if (cached.exists()) {
        // noinspection ResultOfMethodCallIgnored
        cached.delete();
    }
    try (JsonWriter writer = new JsonWriter(new BufferedWriter(new FileWriter(cached)))) {
        writer.beginObject().name("manualPrinters");
        writer.beginArray();
        for (DiscoveredPrinter printer : mManualPrinters) {
            if (DEBUG)
                Log.d(TAG, "Writing " + printer);
            printer.write(writer);
        }
        writer.endArray();
        writer.endObject();
    } catch (NullPointerException | IOException ignored) {
        Log.w(TAG, "Error while storing", ignored);
    }
}
#method_after
private void save() {
    File cachedPrintersFile = new File(getPrintService().getCacheDir(), CACHE_FILE);
    if (cachedPrintersFile.exists()) {
        cachedPrintersFile.delete();
    }
    try (JsonWriter writer = new JsonWriter(new BufferedWriter(new FileWriter(cachedPrintersFile)))) {
        writer.beginObject();
        writer.name("manualPrinters");
        writer.beginArray();
        for (DiscoveredPrinter printer : mManualPrinters) {
            if (DEBUG)
                Log.d(TAG, "Writing " + printer);
            printer.write(writer);
        }
        writer.endArray();
        writer.endObject();
    } catch (NullPointerException | IOException e) {
        Log.w(TAG, "Error while storing", e);
    }
}
#end_block

#method_before
private void load() {
    File cached = new File(getPrintService().getCacheDir(), CACHE_FILE);
    if (!cached.exists())
        return;
    try (JsonReader reader = new JsonReader(new BufferedReader(new FileReader(cached)))) {
        reader.beginObject();
        while (reader.hasNext()) {
            String itemName = reader.nextName();
            if (itemName.equals("manualPrinters")) {
                reader.beginArray();
                while (reader.hasNext()) {
                    addManualPrinter(new DiscoveredPrinter(reader));
                }
                reader.endArray();
            }
        }
        reader.endObject();
    } catch (IllegalStateException | IOException ignored) {
        Log.w(TAG, "Error while restoring", ignored);
    }
    if (DEBUG)
        Log.d(TAG, "After load we have " + mManualPrinters.size() + " manual printers");
}
#method_after
private void load() {
    File cachedPrintersFile = new File(getPrintService().getCacheDir(), CACHE_FILE);
    if (!cachedPrintersFile.exists())
        return;
    try (JsonReader reader = new JsonReader(new BufferedReader(new FileReader(cachedPrintersFile)))) {
        reader.beginObject();
        while (reader.hasNext()) {
            String itemName = reader.nextName();
            if (itemName.equals("manualPrinters")) {
                reader.beginArray();
                while (reader.hasNext()) {
                    addManualPrinter(new DiscoveredPrinter(reader));
                }
                reader.endArray();
            }
        }
        reader.endObject();
    } catch (IllegalStateException | IOException ignored) {
        Log.w(TAG, "Error while restoring", ignored);
    }
    if (DEBUG)
        Log.d(TAG, "After load we have " + mManualPrinters.size() + " manual printers");
}
#end_block

#method_before
@Override
protected Void doInBackground(Void... voids) {
    if (DEBUG)
        Log.d(TAG, "doInBackground() for " + mJobId);
    // Success will result in a jobCallback.
    mBackend.getJni().callNativeCancelJob(mJobId);
    return null;
}
#method_after
@Override
protected Void doInBackground(Void... voids) {
    if (DEBUG)
        Log.d(TAG, "doInBackground() for " + mJobId);
    // Success will result in a jobCallback.
    mBackend.nativeCancelJob(mJobId);
    return null;
}
#end_block

#method_before
PrinterInfo createPrinterInfo() {
    if (mCapabilities != null && !mCapabilities.isSupported) {
        // Fail out if not supported.
        return null;
    }
    String description = mDiscoveredPrinter.getDescription(mPrintService);
    boolean idle = mFound && mCapabilities != null;
    PrinterInfo.Builder builder = new PrinterInfo.Builder(mPrinterId, mDiscoveredPrinter.name, PrinterInfo.STATUS_IDLE).setDescription(description).setStatus(idle ? PrinterInfo.STATUS_IDLE : PrinterInfo.STATUS_UNAVAILABLE);
    if (mCapabilities != null) {
        // Add capabilities if we have them
        PrinterCapabilitiesInfo.Builder capabilitiesBuilder = new PrinterCapabilitiesInfo.Builder(mPrinterId);
        mCapabilities.buildCapabilities(mPrintService, capabilitiesBuilder);
        builder.setCapabilities(capabilitiesBuilder.build());
    }
    return builder.build();
}
#method_after
PrinterInfo createPrinterInfo() {
    if (mCapabilities != null && !mCapabilities.isSupported) {
        // Fail out if not supported.
        return null;
    }
    String description = mDiscoveredPrinter.getDescription(mPrintService);
    boolean idle = mFound && mCapabilities != null;
    PrinterInfo.Builder builder = new PrinterInfo.Builder(mPrinterId, mDiscoveredPrinter.name, idle ? PrinterInfo.STATUS_IDLE : PrinterInfo.STATUS_UNAVAILABLE).setDescription(description);
    if (mCapabilities != null) {
        // Add capabilities if we have them
        PrinterCapabilitiesInfo.Builder capabilitiesBuilder = new PrinterCapabilitiesInfo.Builder(mPrinterId);
        mCapabilities.buildCapabilities(mPrintService, capabilitiesBuilder);
        builder.setCapabilities(capabilitiesBuilder.build());
    }
    return builder.build();
}
#end_block

#method_before
void found() {
    mLastSeenTime = System.currentTimeMillis();
    mFound = true;
    // Check for cached capabilities
    Uri printerUri = mDiscoveredPrinter.getUri();
    LocalPrinterCapabilities capabilities = mPrintService.getCapabilitiesCache().get(printerUri);
    if (DEBUG)
        Log.d(TAG, "Printer " + mDiscoveredPrinter + " has caps=" + capabilities);
    if (capabilities != null) {
        // Report current capabilities
        onCallback(capabilities);
    } else {
        // Announce printer and fetch capabilities
        mSession.onPrinter(this);
        requestCapabilities();
    }
}
#method_after
void found() {
    mLastSeenTime = System.currentTimeMillis();
    mFound = true;
    // Check for cached capabilities
    Uri printerUri = mDiscoveredPrinter.getUri();
    LocalPrinterCapabilities capabilities = mPrintService.getCapabilitiesCache().get(printerUri);
    if (DEBUG)
        Log.d(TAG, "Printer " + mDiscoveredPrinter + " has caps=" + capabilities);
    if (capabilities != null) {
        // Report current capabilities
        onCapabilities(capabilities);
    } else {
        // Announce printer and fetch capabilities
        mSession.handlePrinter(this);
        requestCapabilities();
    }
}
#end_block

#method_before
public void write(JsonWriter writer) throws IOException {
    writer.beginObject().name("name").value(name).name("path").value(path.toString());
    if (uuid != null) {
        writer.name("uuid").value(uuid.toString());
    }
    if (!TextUtils.isEmpty(location)) {
        writer.name("location").value(location);
    }
    writer.endObject();
}
#method_after
public void write(JsonWriter writer) throws IOException {
    writer.beginObject();
    writer.name("name").value(name);
    writer.name("path").value(path.toString());
    if (uuid != null) {
        writer.name("uuid").value(uuid.toString());
    }
    if (!TextUtils.isEmpty(location)) {
        writer.name("location").value(location);
    }
    writer.endObject();
}
#end_block

#method_before
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + (name != null ? name.hashCode() : 0);
    result = 31 * result + (uuid != null ? uuid.hashCode() : 0);
    result = 31 * result + (path != null ? path.hashCode() : 0);
    result = 31 * result + (location != null ? location.hashCode() : 0);
    return result;
}
#method_after
@Override
public int hashCode() {
    int result = 17;
    result = 31 * result + name.hashCode();
    result = 31 * result + (uuid != null ? uuid.hashCode() : 0);
    result = 31 * result + path.hashCode();
    result = 31 * result + (location != null ? location.hashCode() : 0);
    return result;
}
#end_block

#method_before
@Override
protected LocalPrinterCapabilities doInBackground(Void... dummy) {
    long start = System.currentTimeMillis();
    LocalPrinterCapabilities printerCaps = new LocalPrinterCapabilities();
    boolean online = isDeviceOnline(mUri);
    if (DEBUG) {
        Log.d(TAG, "isDeviceOnline uri=" + mUri + " online=" + online + " (" + (System.currentTimeMillis() - start) + "ms)");
    }
    if (!online)
        return null;
    // Do not permit more than a single call to this API or crashes may result
    sJniLock.lock();
    int status = -1;
    start = System.currentTimeMillis();
    try {
        status = mJni.callNativeGetCapabilities(mUri.getHost(), mUri.getPort(), mUri.getPath(), mUri.getScheme(), printerCaps);
    } finally {
        sJniLock.unlock();
    }
    if (DEBUG) {
        Log.d(TAG, "callNativeGetCapabilities uri=" + mUri + " status=" + status + " (" + (System.currentTimeMillis() - start) + "ms)");
    }
    return status == BackendConstants.STATUS_OK ? printerCaps : null;
}
#method_after
@Override
protected LocalPrinterCapabilities doInBackground(Void... dummy) {
    long start = System.currentTimeMillis();
    LocalPrinterCapabilities printerCaps = new LocalPrinterCapabilities();
    boolean online = isDeviceOnline(mUri);
    if (DEBUG) {
        Log.d(TAG, "isDeviceOnline uri=" + mUri + " online=" + online + " (" + (System.currentTimeMillis() - start) + "ms)");
    }
    if (!online)
        return null;
    // Do not permit more than a single call to this API or crashes may result
    sJniLock.lock();
    int status = -1;
    start = System.currentTimeMillis();
    try {
        status = mBackend.nativeGetCapabilities(Backend.getIp(mUri.getHost()), mUri.getPort(), mUri.getPath(), mUri.getScheme(), printerCaps);
    } finally {
        sJniLock.unlock();
    }
    if (DEBUG) {
        Log.d(TAG, "callNativeGetCapabilities uri=" + mUri + " status=" + status + " (" + (System.currentTimeMillis() - start) + "ms)");
    }
    return status == BackendConstants.STATUS_OK ? printerCaps : null;
}
#end_block

#method_before
public WifiMonitor create(Context context, Callback<Boolean> callback) {
    return new WifiMonitor(context, callback);
}
#method_after
public WifiMonitor create(Context context, Listener listener) {
    return new WifiMonitor(context, listener);
}
#end_block

#method_before
@Override
public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
    if (DEBUG)
        Log.d(TAG, "onServiceConnected");
    mLocalPrint = BuiltInPrintService.getInstance();
    if (mLocalPrint == null)
        return;
    // Set up the UI now that we have a bound service
    PreferenceScreen screen = getPreferenceManager().createPreferenceScreen(getActivity());
    setPreferenceScreen(screen);
    AddPrinterPreference addPrinterPreference = new AddPrinterPreference();
    screen.addPreference(addPrinterPreference);
    // noinspection ConstantConditions
    registerForContextMenu(getView().findViewById(android.R.id.list));
    mManualDiscovery = mLocalPrint.getManualDiscovery();
    mManualDiscovery.start(this);
    // Simulate a click on add printer since that is likely what the user came here to do.
    addPrinterPreference.onPreferenceClick(addPrinterPreference);
}
#method_after
@Override
public void onServiceConnected(ComponentName componentName, IBinder iBinder) {
    if (DEBUG)
        Log.d(TAG, "onServiceConnected");
    mLocalPrint = BuiltInPrintService.getInstance();
    // Set up the UI now that we have a bound service
    PreferenceScreen screen = getPreferenceManager().createPreferenceScreen(getActivity());
    setPreferenceScreen(screen);
    AddPrinterPreference addPrinterPreference = new AddPrinterPreference();
    screen.addPreference(addPrinterPreference);
    registerForContextMenu(getView().findViewById(android.R.id.list));
    mManualDiscovery = mLocalPrint.getManualDiscovery();
    mManualDiscovery.start(this);
    // Simulate a click on add printer since that is likely what the user came here to do.
    addPrinterPreference.onPreferenceClick(addPrinterPreference);
}
#end_block

#method_before
@Override
public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
    if (view instanceof ListView) {
        int position = ((AdapterView.AdapterContextMenuInfo) menuInfo).position;
        Preference preference = getPreferenceScreen().getPreference(position);
        if (preference instanceof ManualPrinterPreference) {
            final DiscoveredPrinter printer = ((ManualPrinterPreference) preference).printer;
            menu.setHeaderTitle(printer.name);
            MenuItem forgetItem = menu.add(Menu.NONE, R.string.forget_printer, Menu.NONE, R.string.forget_printer);
            forgetItem.setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener() {

                @Override
                public boolean onMenuItemClick(MenuItem menuItem) {
                    mManualDiscovery.removeManualPrinter(printer);
                    return true;
                }
            });
        }
    }
}
#method_after
@Override
public void onCreateContextMenu(ContextMenu menu, View view, ContextMenu.ContextMenuInfo menuInfo) {
    if (view instanceof ListView) {
        int position = ((AdapterView.AdapterContextMenuInfo) menuInfo).position;
        Preference preference = getPreferenceScreen().getPreference(position);
        if (preference instanceof ManualPrinterPreference) {
            final DiscoveredPrinter printer = ((ManualPrinterPreference) preference).printer;
            menu.setHeaderTitle(printer.name);
            MenuItem forgetItem = menu.add(Menu.NONE, R.string.forget_printer, Menu.NONE, R.string.forget_printer);
            forgetItem.setOnMenuItemClickListener(menuItem -> {
                mManualDiscovery.removeManualPrinter(printer);
                return true;
            });
        }
    }
}
#end_block

#method_before
@SuppressLint("InflateParams")
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG)
        Log.d(TAG, "onCreate");
    View view = getLayoutInflater().inflate(R.layout.manual_printer_add, null);
    setView(view);
    setTitle(R.string.add_manual_printer);
    setButton(AlertDialog.BUTTON_NEGATIVE, getContext().getString(android.R.string.cancel), (OnClickListener) null);
    setButton(AlertDialog.BUTTON_POSITIVE, getContext().getString(R.string.add), (OnClickListener) null);
    super.onCreate(savedInstanceState);
    mAddButton = getButton(AlertDialog.BUTTON_POSITIVE);
    mHostnameView = (TextView) findViewById(R.id.hostname);
    mProgressBar = (ProgressBar) findViewById(R.id.progress);
    mAddButton.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View view) {
            onAdd();
        }
    });
    // Update add button as contents change
    mHostnameView.addTextChangedListener(this);
    mHostnameView.setOnEditorActionListener(this);
    mHostnameView.setOnKeyListener(this);
    // Force open keyboard if appropriate
    openKeyboard(mHostnameView);
    updateButtonState();
}
#method_after
@SuppressLint("InflateParams")
@Override
protected void onCreate(Bundle savedInstanceState) {
    if (DEBUG)
        Log.d(TAG, "onCreate");
    View view = getLayoutInflater().inflate(R.layout.manual_printer_add, null);
    setView(view);
    setTitle(R.string.add_manual_printer);
    setButton(AlertDialog.BUTTON_NEGATIVE, getContext().getString(android.R.string.cancel), (OnClickListener) null);
    setButton(AlertDialog.BUTTON_POSITIVE, getContext().getString(R.string.add), (OnClickListener) null);
    super.onCreate(savedInstanceState);
    mAddButton = getButton(AlertDialog.BUTTON_POSITIVE);
    mHostnameView = (TextView) findViewById(R.id.hostname);
    mProgressBar = (ProgressBar) findViewById(R.id.progress);
    mAddButton.setOnClickListener(view1 -> addPrinter());
    // Update add button as contents change
    mHostnameView.addTextChangedListener(this);
    mHostnameView.setOnEditorActionListener(this);
    mHostnameView.setOnKeyListener(this);
    // Force open keyboard if appropriate
    openKeyboard(mHostnameView);
    updateButtonState();
}
#end_block

#method_before
@Override
public boolean onEditorAction(TextView textView, int id, KeyEvent keyEvent) {
    if (id == EditorInfo.IME_ACTION_DONE && mAddButton.isEnabled()) {
        onAdd();
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onEditorAction(TextView textView, int id, KeyEvent keyEvent) {
    if (id == EditorInfo.IME_ACTION_DONE && mAddButton.isEnabled()) {
        addPrinter();
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public boolean onKey(View view, int keyCode, KeyEvent keyEvent) {
    if (keyCode == KeyEvent.KEYCODE_ENTER && mAddButton.isEnabled()) {
        onAdd();
        return true;
    }
    return false;
}
#method_after
@Override
public boolean onKey(View view, int keyCode, KeyEvent keyEvent) {
    if (keyCode == KeyEvent.KEYCODE_ENTER && mAddButton.isEnabled()) {
        addPrinter();
        return true;
    }
    return false;
}
#end_block

#method_before
public void renderPageStripe(int x, int y, int width, int height, double zoomFactor, ByteBuffer target) {
    if (DEBUG) {
        Log.d(TAG, "renderPageStripe() x=" + x + " y=" + y + " width=" + width + " height=" + height + " zoomFactor=" + zoomFactor);
    }
    // Allocate and clear bitmap to white with no transparency
    Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    bitmap.eraseColor(0xFFFFFFFF);
    // Use a scaling matrix to increase DPI (default is 72dpi)
    Matrix matrix = new Matrix();
    matrix.setScale((float) zoomFactor, (float) zoomFactor);
    matrix.postTranslate(0, -y);
    // Render
    mPage.render(bitmap, new Rect(0, 0, width, height), matrix, PdfRenderer.Page.RENDER_MODE_FOR_PRINT);
    // Copy rendered pixels into supplied ByteArray
    bitmap.copyPixelsToBuffer(target);
}
#method_after
public boolean renderPageStripe(int page, int y, int width, int height, double zoomFactor, ByteBuffer target) {
    if (DEBUG) {
        Log.d(TAG, "renderPageStripe() page=" + page + " y=" + y + " w=" + width + " h=" + height + " zoom=" + zoomFactor);
    }
    if (mService == null)
        return false;
    try {
        long start = System.currentTimeMillis();
        ParcelFileDescriptor input = mService.renderPageStripe(page - 1, y, width, height, zoomFactor);
        // Copy received data into the ByteBuffer
        int expectedSize = width * height * 3;
        byte[] readBuffer = new byte[128 * 1024];
        try (InputStream in = new ParcelFileDescriptor.AutoCloseInputStream(input)) {
            int length;
            while ((length = in.read(readBuffer, 0, readBuffer.length)) > 0) {
                target.put(readBuffer, 0, length);
            }
        }
        if (target.position() != expectedSize) {
            Log.w(TAG, "Render failed: expected " + target.position() + ", got " + expectedSize + " bytes");
            return false;
        }
        if (DEBUG)
            Log.d(TAG, "Received (" + (System.currentTimeMillis() - start) + "ms)");
        return true;
    } catch (RemoteException | IOException | IllegalArgumentException | OutOfMemoryError ex) {
        Log.w(TAG, "Render failed", ex);
        return false;
    }
}
#end_block

#method_before
@Override
public String toString() {
    return "LocalJobParams{" + " borderless=" + borderless + " duplex=" + duplex + " pdf_render_resolution=" + pdf_render_resolution + " job_name=" + job_name + " job_originating_user_name=" + job_originating_user_name + " media_size=" + media_size + " media_type=" + media_type + " media_tray=" + media_tray + " render_flags=" + render_flags + " num_copies=" + num_copies + " color_space=" + color_space + " print_resolution=" + print_resolution + " printable_width=" + printable_width + " printable_height=" + printable_height + " job_margin_top=" + job_margin_top + " job_margin_left=" + job_margin_left + " job_margin_right=" + job_margin_right + " job_margin_bottom=" + job_margin_bottom + " page_width=" + page_width + " page_height=" + page_height + " page_margin_top=" + page_margin_top + " page_margin_left=" + page_margin_left + " page_margin_right=" + page_margin_right + " page_margin_bottom=" + page_margin_bottom + " fit_to_page=" + fit_to_page + " auto_rotate=" + auto_rotate + " fill_page=" + fill_page + " portrait_mode=" + portrait_mode + " landscape_mode=" + landscape_mode + " page_range=" + page_range + " document_category=" + document_category + " nativeData=" + nativeData + " alignment=" + alignment + " document_scaling=" + document_scaling + "}";
}
#method_after
@Override
public String toString() {
    return "LocalJobParams{" + " borderless=" + borderless + " duplex=" + duplex + " pdf_render_resolution=" + pdf_render_resolution + " job_name=" + job_name + " job_originating_user_name=" + job_originating_user_name + " media_size=" + media_size + " media_type=" + media_type + " media_tray=" + media_tray + " render_flags=" + render_flags + " num_copies=" + num_copies + " color_space=" + color_space + " print_resolution=" + print_resolution + " printable_width=" + printable_width + " printable_height=" + printable_height + " job_margin_top=" + job_margin_top + " job_margin_left=" + job_margin_left + " job_margin_right=" + job_margin_right + " job_margin_bottom=" + job_margin_bottom + " page_width=" + page_width + " page_height=" + page_height + " page_margin_top=" + page_margin_top + " page_margin_left=" + page_margin_left + " page_margin_right=" + page_margin_right + " page_margin_bottom=" + page_margin_bottom + " fit_to_page=" + fit_to_page + " auto_rotate=" + auto_rotate + " fill_page=" + fill_page + " portrait_mode=" + portrait_mode + " landscape_mode=" + landscape_mode + " page_range=" + page_range + " document_category=" + document_category + " nativeData=" + !(nativeData == null) + " alignment=" + alignment + " document_scaling=" + document_scaling + "}";
}
#end_block

#method_before
@Override
void onStart() {
    if (DEBUG)
        Log.d(TAG, "onStart()");
    mWifiMonitor = mWifiMonitorFactory.create(getPrintService(), new Callback<Boolean>() {

        @Override
        public void onCallback(Boolean connected) {
            if (connected) {
                if (DEBUG)
                    Log.d(TAG, "Connected, starting discovery");
                for (Discovery discovery : mDiscoveries) {
                    discovery.start(mChildListener);
                }
            } else {
                if (DEBUG)
                    Log.d(TAG, "Disconnected, stopping discovery");
                for (Discovery discovery : mDiscoveries) {
                    discovery.stop(mChildListener);
                }
                allPrintersLost();
            }
        }
    });
}
#method_after
@Override
void onStart() {
    if (DEBUG)
        Log.d(TAG, "onStart()");
    mWifiMonitor = mWifiMonitorFactory.create(getPrintService(), connected -> {
        if (connected) {
            if (DEBUG)
                Log.d(TAG, "Connected, starting discovery");
            for (Discovery discovery : mDiscoveries) {
                discovery.start(mChildListener);
            }
        } else {
            if (DEBUG)
                Log.d(TAG, "Disconnected, stopping discovery");
            for (Discovery discovery : mDiscoveries) {
                discovery.stop(mChildListener);
            }
            allPrintersLost();
        }
    });
}
#end_block

#method_before
public void request(DiscoveredPrinter printer, boolean priority, Callback<LocalPrinterCapabilities> callback) {
    if (DEBUG) {
        Log.d(TAG, "request() printer=" + printer + " priority=" + priority + ", callback=" + callback);
    }
    Uri printerUri = printer.getUri();
    Uri printerPath = printer.path;
    LocalPrinterCapabilities capabilities = get(printer.getUri());
    if (capabilities != null && capabilities.nativeData != null) {
        callback.onCallback(capabilities);
        return;
    }
    Request request = mRequests.get(printerUri);
    if (request == null) {
        request = new Request(printer);
        mRequests.put(printerUri, request);
    }
    if (!request.printer.path.equals(printerPath)) {
        Log.w(TAG, "Capabilities request for printer " + printer + " overlaps with different path " + request.printer.path);
        callback.onCallback(null);
        return;
    }
    request.callbacks.add(callback);
    if (priority) {
        request.priority = true;
    }
    startNextRequest();
}
#method_after
public void request(DiscoveredPrinter printer, boolean highPriority, OnLocalPrinterCapabilities onLocalPrinterCapabilities) {
    if (DEBUG)
        Log.d(TAG, "request() printer=" + printer + " high=" + highPriority);
    Uri printerUri = printer.getUri();
    Uri printerPath = printer.path;
    LocalPrinterCapabilities capabilities = get(printer.getUri());
    if (capabilities != null && capabilities.nativeData != null) {
        onLocalPrinterCapabilities.onCapabilities(capabilities);
        return;
    }
    Request request = mRequests.get(printerUri);
    if (request == null) {
        request = new Request(printer);
        mRequests.put(printerUri, request);
    } else if (!request.printer.path.equals(printerPath)) {
        Log.w(TAG, "Capabilities request for printer " + printer + " overlaps with different path " + request.printer.path);
        onLocalPrinterCapabilities.onCapabilities(null);
        return;
    }
    request.callbacks.add(onLocalPrinterCapabilities);
    if (highPriority) {
        request.highPriority = true;
    }
    startNextRequest();
}
#end_block

#method_before
private void startNextRequest() {
    final Request request = getNextRequest();
    if (request == null)
        return;
    request.querying = true;
    mBackend.getCapabilities(request.printer.path, new Callback<LocalPrinterCapabilities>() {

        @Override
        public void onCallback(LocalPrinterCapabilities capabilities) {
            DiscoveredPrinter printer = request.printer;
            if (DEBUG) {
                Log.d(TAG, "Capabilities for " + printer + " cap=" + capabilities);
            }
            if (mClosed)
                return;
            mRequests.remove(printer.getUri());
            // Grab uuid from capabilities if possible
            Uri capUuid = null;
            if (capabilities != null) {
                if (!TextUtils.isEmpty(capabilities.uuid)) {
                    capUuid = Uri.parse(capabilities.uuid);
                }
                if (printer.uuid != null && !printer.uuid.equals(capUuid)) {
                    Log.w(TAG, "UUID mismatch for " + printer + "; rejecting capabilities");
                    capabilities = null;
                }
            }
            if (capabilities == null) {
                remove(printer.getUri());
            } else {
                Uri key = printer.getUri();
                if (printer.uuid == null) {
                    // For non-uuid URIs, evict later
                    evictOnNetworkChange(key);
                    if (capUuid != null) {
                        // Upgrade to UUID if we have it
                        key = capUuid;
                    }
                }
                put(key, capabilities);
            }
            for (Callback<LocalPrinterCapabilities> callback : request.callbacks) {
                callback.onCallback(capabilities);
            }
            startNextRequest();
        }
    });
}
#method_after
private void startNextRequest() {
    final Request request = getNextRequest();
    if (request == null)
        return;
    request.querying = true;
    mBackend.getCapabilities(request.printer.path, capabilities -> {
        DiscoveredPrinter printer = request.printer;
        if (DEBUG)
            Log.d(TAG, "Capabilities for " + printer + " cap=" + capabilities);
        if (mClosed)
            return;
        mRequests.remove(printer.getUri());
        // Grab uuid from capabilities if possible
        Uri capUuid = null;
        if (capabilities != null) {
            if (!TextUtils.isEmpty(capabilities.uuid)) {
                capUuid = Uri.parse(capabilities.uuid);
            }
            if (printer.uuid != null && !printer.uuid.equals(capUuid)) {
                Log.w(TAG, "UUID mismatch for " + printer + "; rejecting capabilities");
                capabilities = null;
            }
        }
        if (capabilities == null) {
            remove(printer.getUri());
        } else {
            Uri key = printer.getUri();
            if (printer.uuid == null) {
                // For non-uuid URIs, evict later
                evictOnNetworkChange(key);
                if (capUuid != null) {
                    // Upgrade to UUID if we have it
                    key = capUuid;
                }
            }
            put(key, capabilities);
        }
        for (OnLocalPrinterCapabilities callback : request.callbacks) {
            callback.onCapabilities(capabilities);
        }
        startNextRequest();
    });
}
#end_block

#method_before
private Request getNextRequest() {
    Request found = null;
    int total = 0;
    for (Request request : mRequests.values()) {
        if (request.querying) {
            total++;
        } else if (found == null || (!found.priority && request.priority)) {
            // First outstanding, or higher priority request
            found = request;
        }
    }
    if (total >= mMaxConcurrent)
        return null;
    return found;
}
#method_after
private Request getNextRequest() {
    Request found = null;
    int total = 0;
    for (Request request : mRequests.values()) {
        if (request.querying) {
            total++;
        } else if (found == null || (!found.highPriority && request.highPriority)) {
            // First outstanding, or higher highPriority request
            found = request;
        }
    }
    if (total >= mMaxConcurrent)
        return null;
    return found;
}
#end_block

#method_before
private String getApplicationVersion(Context context) {
    try {
        PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
        return packageInfo != null ? packageInfo.versionName : VERSION_UNKNOWN;
    } catch (PackageManager.NameNotFoundException e) {
        return VERSION_UNKNOWN;
    }
}
#method_after
private String getApplicationVersion(Context context) {
    try {
        PackageInfo packageInfo = context.getPackageManager().getPackageInfo(context.getPackageName(), 0);
        return packageInfo.versionName;
    } catch (PackageManager.NameNotFoundException e) {
        return VERSION_UNKNOWN;
    }
}
#end_block

#method_before
public void getCapabilities(Uri uri, final Callback<LocalPrinterCapabilities> callback) {
    if (DEBUG)
        Log.d(TAG, "getCapabilities()");
    Context context = mContext.get();
    if (context == null)
        return;
    new GetCapabilitiesTask(context, uri) {

        @Override
        protected void onPostExecute(LocalPrinterCapabilities result) {
            callback.onCallback(result);
        }
    }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
#method_after
public void getCapabilities(Uri uri, final Consumer<LocalPrinterCapabilities> capabilitiesConsumer) {
    if (DEBUG)
        Log.d(TAG, "getCapabilities()");
    new GetCapabilitiesTask(this, uri) {

        @Override
        protected void onPostExecute(LocalPrinterCapabilities result) {
            capabilitiesConsumer.accept(result);
        }
    }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
#end_block

#method_before
public void print(Uri uri, PrintJob printJob, LocalPrinterCapabilities capabilities, Callback<JobStatus> listener) {
    if (DEBUG)
        Log.d(TAG, "print()");
    Context context = mContext.get();
    if (context == null)
        return;
    if (mStartTask != null) {
        throw new RuntimeException("Cannot start print while a print is already in progress");
    }
    mJobStatusListener = listener;
    mJobStatus = new JobStatus();
    mStartTask = new StartJobTask(context, uri, printJob, capabilities) {

        @Override
        public void onCancelled(Integer result) {
            if (DEBUG)
                Log.d(TAG, "StartJobTask::onCancelled " + result);
            onPostExecute(ERROR_CANCEL);
        }

        @Override
        protected void onPostExecute(Integer result) {
            if (DEBUG)
                Log.d(TAG, "StartJobTask::onPostExecute " + result);
            mStartTask = null;
            if (result > 0) {
                mJobStatus = new JobStatus.Builder(mJobStatus).setId(result).build();
            } else {
                mJobStatus = new JobStatus.Builder().setJobState(BackendConstants.JOB_STATE_DONE).setJobResult(result == ERROR_CANCEL ? BackendConstants.JOB_DONE_CANCELLED : BackendConstants.JOB_DONE_ERROR).build();
                if (mJobStatusListener != null)
                    mJobStatusListener.onCallback(mJobStatus);
                mJobStatusListener = null;
            }
        }
    };
    mStartTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
#method_after
public void print(Uri uri, PrintJob printJob, LocalPrinterCapabilities capabilities, Consumer<JobStatus> listener) {
    if (DEBUG)
        Log.d(TAG, "print()");
    mJobStatusListener = listener;
    mCurrentJobStatus = new JobStatus();
    mStartTask = new StartJobTask(mContext, this, uri, printJob, capabilities) {

        @Override
        public void onCancelled(Integer result) {
            if (DEBUG)
                Log.d(TAG, "StartJobTask::onCancelled " + result);
            onPostExecute(ERROR_CANCEL);
        }

        @Override
        protected void onPostExecute(Integer result) {
            if (DEBUG)
                Log.d(TAG, "StartJobTask::onPostExecute " + result);
            mStartTask = null;
            if (result > 0) {
                mCurrentJobStatus = new JobStatus.Builder(mCurrentJobStatus).setId(result).build();
            } else if (mJobStatusListener != null) {
                String jobResult = BackendConstants.JOB_DONE_ERROR;
                if (result == ERROR_CANCEL) {
                    jobResult = BackendConstants.JOB_DONE_CANCELLED;
                } else if (result == ERROR_FILE) {
                    jobResult = BackendConstants.JOB_DONE_CORRUPT;
                }
                // If the start attempt failed and we are still listening, notify and be done
                mCurrentJobStatus = new JobStatus.Builder().setJobState(BackendConstants.JOB_STATE_DONE).setJobResult(jobResult).build();
                mJobStatusListener.accept(mCurrentJobStatus);
                mJobStatusListener = null;
            }
        }
    };
    mStartTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
}
#end_block

#method_before
public void cancel() {
    if (DEBUG)
        Log.d(TAG, "cancel()");
    Context context = mContext.get();
    if (context == null)
        return;
    if (mStartTask != null) {
        if (DEBUG)
            Log.d(TAG, "cancelling start task");
        mStartTask.cancel(true);
    } else if (mJobStatus.getId() != JobStatus.ID_UNKNOWN) {
        if (DEBUG)
            Log.d(TAG, "cancelling job via new task");
        new CancelJobTask(context, mJobStatus.getId()).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    } else {
        if (DEBUG)
            Log.d(TAG, "Nothing to cancel in backend, ignoring");
    }
}
#method_after
public void cancel() {
    if (DEBUG)
        Log.d(TAG, "cancel()");
    if (mStartTask != null) {
        if (DEBUG)
            Log.d(TAG, "cancelling start task");
        mStartTask.cancel(true);
    } else if (mCurrentJobStatus != null && mCurrentJobStatus.getId() != JobStatus.ID_UNKNOWN) {
        if (DEBUG)
            Log.d(TAG, "cancelling job via new task");
        new CancelJobTask(this, mCurrentJobStatus.getId()).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
    } else {
        if (DEBUG)
            Log.d(TAG, "Nothing to cancel in backend, ignoring");
    }
}
#end_block

#method_before
public void close() {
    mJni.callNativeExit();
    sInstance = null;
}
#method_after
public void close() {
    nativeExit();
    PdfRender.getInstance(mContext).close();
}
#end_block

#method_before
@Override
public void jobCallback(final int jobId, final JobCallbackParams params) {
    mMainHandler.post(new Runnable() {

        @Override
        public void run() {
            if (DEBUG)
                Log.d(TAG, "jobCallback() jobId=" + jobId + ", params=" + params);
            JobStatus.Builder builder = new JobStatus.Builder(mJobStatus);
            builder.setId(params.jobId);
            if (!TextUtils.isEmpty(params.printerState)) {
                updateBlockedReasons(builder, params);
            } else if (!TextUtils.isEmpty(params.jobState)) {
                builder.setJobState(params.jobState);
                if (!TextUtils.isEmpty(params.jobDoneResult)) {
                    builder.setJobResult(params.jobDoneResult);
                }
                updateBlockedReasons(builder, params);
            }
            mJobStatus = builder.build();
            if (mJobStatusListener != null) {
                mJobStatusListener.onCallback(mJobStatus);
            }
            if (mJobStatus.isJobDone()) {
                mJni.callNativeEndJob(jobId);
                // Reset status for next job.
                mJobStatus = new JobStatus();
                mJobStatusListener = null;
                Context context = mContext.get();
                if (context != null) {
                    try {
                        FileUtils.deleteAll(new File(context.getFilesDir(), Backend.TEMP_JOB_FOLDER));
                    } catch (IOException ignored) {
                    }
                }
            }
        }
    });
}
#method_after
@Override
public void jobCallback(final int jobId, final JobCallbackParams params) {
    mMainHandler.post(() -> {
        if (DEBUG)
            Log.d(TAG, "jobCallback() jobId=" + jobId + ", params=" + params);
        JobStatus.Builder builder = new JobStatus.Builder(mCurrentJobStatus);
        builder.setId(params.jobId);
        if (!TextUtils.isEmpty(params.printerState)) {
            updateBlockedReasons(builder, params);
        } else if (!TextUtils.isEmpty(params.jobState)) {
            builder.setJobState(params.jobState);
            if (!TextUtils.isEmpty(params.jobDoneResult)) {
                builder.setJobResult(params.jobDoneResult);
            }
            updateBlockedReasons(builder, params);
        }
        mCurrentJobStatus = builder.build();
        if (mJobStatusListener != null) {
            mJobStatusListener.accept(mCurrentJobStatus);
        }
        if (mCurrentJobStatus.isJobDone()) {
            nativeEndJob(jobId);
            // Reset status for next job.
            mCurrentJobStatus = new JobStatus();
            mJobStatusListener = null;
            FileUtils.deleteAll(new File(mContext.getFilesDir(), Backend.TEMP_JOB_FOLDER));
        }
    });
}
#end_block

#method_before
private void startNextJob() {
    if (mJobs.isEmpty() || mCurrent != null)
        return;
    mCurrent = mJobs.remove(0);
    mCurrent.start(new Callback<LocalPrintJob>() {

        @Override
        public void onCallback(LocalPrintJob job) {
            mCurrent = null;
            startNextJob();
        }
    });
}
#method_after
private void startNextJob() {
    if (mJobs.isEmpty() || mCurrent != null)
        return;
    mCurrent = mJobs.remove(0);
    mCurrent.start(job -> {
        mCurrent = null;
        startNextJob();
    });
}
#end_block

#method_before
@Override
public void onStartPrinterDiscovery(List<PrinterId> priorityList) {
    if (DEBUG)
        Log.d(TAG, "onStartPrinterDiscovery() " + priorityList);
    // Replace priority IDs with the current list.
    mPriorityIds.clear();
    mPriorityIds.addAll(priorityList);
    // Mark all known printers as "not found". They may return shortly or may expire
    for (LocalPrinter localPrinter : mPrinters.values()) {
        localPrinter.notFound();
    }
    monitorExpiredPrinters();
    mPrintService.getDiscovery().start(this);
}
#method_after
@Override
public void onStartPrinterDiscovery(List<PrinterId> priorityList) {
    if (DEBUG)
        Log.d(TAG, "onStartPrinterDiscovery() " + priorityList);
    // Replace priority IDs with the current list.
    mPriorityIds.clear();
    mPriorityIds.addAll(priorityList);
    // Mark all known printers as "not found". They may return shortly or may expire
    mPrinters.values().forEach(LocalPrinter::notFound);
    monitorExpiredPrinters();
    mPrintService.getDiscovery().start(this);
}
#end_block

#method_before
@Override
public void onStartPrinterStateTracking(final PrinterId printerId) {
    if (DEBUG)
        Log.d(TAG, "onStartPrinterStateTracking() " + printerId);
    LocalPrinter localPrinter = mPrinters.get(printerId);
    mTrackingIds.add(printerId);
    // We cannot track the printer yet; wait until it is discovered
    if (localPrinter == null)
        return;
    // Immediately request a refresh of capabilities
    localPrinter.requestCapabilities();
}
#method_after
@Override
public void onStartPrinterStateTracking(final PrinterId printerId) {
    if (DEBUG)
        Log.d(TAG, "onStartPrinterStateTracking() " + printerId);
    LocalPrinter localPrinter = mPrinters.get(printerId);
    mTrackingIds.add(printerId);
    // We cannot track the printer yet; wait until it is discovered
    if (localPrinter == null || !localPrinter.isFound())
        return;
    // Immediately request a refresh of capabilities
    localPrinter.requestCapabilities();
}
#end_block

#method_before
@Override
public void onStopPrinterStateTracking(PrinterId printerId) {
    if (DEBUG)
        Log.d(TAG, "onStopPrinterStateTracking() " + printerId.getLocalId());
    mTrackingIds.remove(printerId);
    LocalPrinter localPrinter = mPrinters.get(printerId);
    if (localPrinter != null)
        localPrinter.stopCapabilityMonitoring();
}
#method_after
@Override
public void onStopPrinterStateTracking(PrinterId printerId) {
    if (DEBUG)
        Log.d(TAG, "onStopPrinterStateTracking() " + printerId.getLocalId());
    mTrackingIds.remove(printerId);
}
#end_block

#method_before
@Override
public void onPrinterLost(DiscoveredPrinter lostPrinter) {
    if (DEBUG)
        Log.d(TAG, "onPrinterLost() " + lostPrinter);
    PrinterId printerId = lostPrinter.getId(mPrintService);
    if (printerId.getLocalId().startsWith("ipp")) {
        // Forget capabilities for network addresses (which are not globally unique)
        mCapabilitiesCache.remove(lostPrinter.getUri());
    }
    LocalPrinter localPrinter = mPrinters.get(printerId);
    if (localPrinter == null)
        return;
    localPrinter.notFound();
    onPrinter(localPrinter);
    monitorExpiredPrinters();
}
#method_after
@Override
public void onPrinterLost(DiscoveredPrinter lostPrinter) {
    if (DEBUG)
        Log.d(TAG, "onPrinterLost() " + lostPrinter);
    PrinterId printerId = lostPrinter.getId(mPrintService);
    if (printerId.getLocalId().startsWith("ipp")) {
        // Forget capabilities for network addresses (which are not globally unique)
        mCapabilitiesCache.remove(lostPrinter.getUri());
    }
    LocalPrinter localPrinter = mPrinters.get(printerId);
    if (localPrinter == null)
        return;
    localPrinter.notFound();
    handlePrinter(localPrinter);
    monitorExpiredPrinters();
}
#end_block

#method_before
boolean isPriority(PrinterId printerId) {
    return mPriorityIds.contains(printerId) || isTracked(printerId);
}
#method_after
boolean isPriority(PrinterId printerId) {
    return mPriorityIds.contains(printerId) || mTrackingIds.contains(printerId);
}
#end_block

#method_before
private void saveKnownGood() {
    File file = new File(mPrintService.getCacheDir(), KNOWN_GOOD_FILE);
    if (file.isDirectory())
        return;
    try (JsonWriter writer = new JsonWriter(new FileWriter(file))) {
        writer.beginArray();
        for (int i = 0; i < Math.min(KNOWN_GOOD_MAX, mKnownGood.size()); i++) {
            writer.value(mKnownGood.get(i).getLocalId());
        }
        writer.endArray();
    } catch (IOException e) {
        Log.w(TAG, "Failed to write known good list", e);
    }
}
#method_after
private void saveKnownGood() {
    File file = new File(mPrintService.getCacheDir(), KNOWN_GOOD_FILE);
    try (JsonWriter writer = new JsonWriter(new FileWriter(file))) {
        writer.beginArray();
        for (int i = 0; i < Math.min(KNOWN_GOOD_MAX, mKnownGood.size()); i++) {
            writer.value(mKnownGood.get(i).getLocalId());
        }
        writer.endArray();
    } catch (IOException e) {
        Log.w(TAG, "Failed to write known good list", e);
    }
}
#end_block

#method_before
@Override
public void run() {
    boolean allFound = true;
    List<PrinterId> idsToRemove = new ArrayList<>();
    for (LocalPrinter localPrinter : mPrinters.values()) {
        if (localPrinter.isExpired()) {
            if (DEBUG)
                Log.d(TAG, "Expiring " + localPrinter);
            idsToRemove.add(localPrinter.getPrinterId());
        }
        if (!localPrinter.isFound())
            allFound = false;
    }
    for (PrinterId printerId : idsToRemove) {
        mPrinters.remove(printerId);
    }
    removePrinters(idsToRemove);
    if (!allFound) {
        mPrintService.getMainHandler().postDelayed(this, PRINTER_EXPIRATION_MILLIS);
    } else {
        mExpirePrinters = null;
    }
}
#method_after
@Override
public void run() {
    boolean allFound = true;
    List<PrinterId> idsToRemove = new ArrayList<>();
    for (LocalPrinter localPrinter : mPrinters.values()) {
        if (localPrinter.isExpired()) {
            if (DEBUG)
                Log.d(TAG, "Expiring " + localPrinter);
            idsToRemove.add(localPrinter.getPrinterId());
        }
        if (!localPrinter.isFound())
            allFound = false;
    }
    idsToRemove.forEach(mPrinters::remove);
    removePrinters(idsToRemove);
    if (!allFound) {
        mPrintService.getMainHandler().postDelayed(this, PRINTER_EXPIRATION_MILLIS);
    } else {
        mExpirePrinters = null;
    }
}
#end_block

#method_before
public void updatePacketRates(WifiLinkLayerStats stats, long timeStamp) {
    if (stats != null) {
        long txgood = stats.txmpdu_be + stats.txmpdu_bk + stats.txmpdu_vi + stats.txmpdu_vo;
        long txretries = stats.retries_be + stats.retries_bk + stats.retries_vi + stats.retries_vo;
        long rxgood = stats.rxmpdu_be + stats.rxmpdu_bk + stats.rxmpdu_vi + stats.rxmpdu_vo;
        long txbad = stats.lostmpdu_be + stats.lostmpdu_bk + stats.lostmpdu_vi + stats.lostmpdu_vo;
        if (mLastPacketCountUpdateTimeStamp != RESET_TIME_STAMP && txBad <= txbad && txSuccess <= txgood && rxSuccess <= rxgood && txRetries <= txretries) {
            txBadRate = txBadRate * 0.4 + (txbad - txBad) * 5000 / (timeStamp - mLastPacketCountUpdateTimeStamp) * 0.6;
            txSuccessRate = txSuccessRate * 0.4 + (txgood - txSuccess) * 5000 / (timeStamp - mLastPacketCountUpdateTimeStamp) * 0.6;
            rxSuccessRate = rxSuccessRate * 0.4 + (rxgood - rxSuccess) * 5000 / (timeStamp - mLastPacketCountUpdateTimeStamp) * 0.6;
            txRetriesRate = txRetriesRate * 0.4 + (txretries - txRetries) * 5000 / (timeStamp - mLastPacketCountUpdateTimeStamp) * 0.6;
        } else {
            txBadRate = 0;
            txSuccessRate = 0;
            rxSuccessRate = 0;
            txRetriesRate = 0;
        }
        txBad = txbad;
        txSuccess = txgood;
        rxSuccess = rxgood;
        txRetries = txretries;
        mLastPacketCountUpdateTimeStamp = timeStamp;
    } else {
        txBad = 0;
        txSuccess = 0;
        rxSuccess = 0;
        txRetries = 0;
        txBadRate = 0;
        txSuccessRate = 0;
        rxSuccessRate = 0;
        txRetriesRate = 0;
        mLastPacketCountUpdateTimeStamp = RESET_TIME_STAMP;
    }
}
#method_after
public void updatePacketRates(WifiLinkLayerStats stats, long timeStamp) {
    if (stats != null) {
        long txgood = stats.txmpdu_be + stats.txmpdu_bk + stats.txmpdu_vi + stats.txmpdu_vo;
        long txretries = stats.retries_be + stats.retries_bk + stats.retries_vi + stats.retries_vo;
        long rxgood = stats.rxmpdu_be + stats.rxmpdu_bk + stats.rxmpdu_vi + stats.rxmpdu_vo;
        long txbad = stats.lostmpdu_be + stats.lostmpdu_bk + stats.lostmpdu_vi + stats.lostmpdu_vo;
        if (mLastPacketCountUpdateTimeStamp != RESET_TIME_STAMP && mLastPacketCountUpdateTimeStamp < timeStamp && txBad <= txbad && txSuccess <= txgood && rxSuccess <= rxgood && txRetries <= txretries) {
            long timeDelta = timeStamp - mLastPacketCountUpdateTimeStamp;
            double lastSampleWeight = Math.exp(-1.0 * timeDelta / FILTER_TIME_CONSTANT);
            double currentSampleWeight = 1.0 - lastSampleWeight;
            txBadRate = txBadRate * lastSampleWeight + (txbad - txBad) * OUTPUT_SCALE_FACTOR / timeDelta * currentSampleWeight;
            txSuccessRate = txSuccessRate * lastSampleWeight + (txgood - txSuccess) * OUTPUT_SCALE_FACTOR / timeDelta * currentSampleWeight;
            rxSuccessRate = rxSuccessRate * lastSampleWeight + (rxgood - rxSuccess) * OUTPUT_SCALE_FACTOR / timeDelta * currentSampleWeight;
            txRetriesRate = txRetriesRate * lastSampleWeight + (txretries - txRetries) * OUTPUT_SCALE_FACTOR / timeDelta * currentSampleWeight;
        } else {
            txBadRate = 0;
            txSuccessRate = 0;
            rxSuccessRate = 0;
            txRetriesRate = 0;
        }
        txBad = txbad;
        txSuccess = txgood;
        rxSuccess = rxgood;
        txRetries = txretries;
        mLastPacketCountUpdateTimeStamp = timeStamp;
    } else {
        txBad = 0;
        txSuccess = 0;
        rxSuccess = 0;
        txRetries = 0;
        txBadRate = 0;
        txSuccessRate = 0;
        rxSuccessRate = 0;
        txRetriesRate = 0;
        mLastPacketCountUpdateTimeStamp = RESET_TIME_STAMP;
    }
}
#end_block

#method_before
private byte[] getTestData() throws IOException {
    ByteArrayOutputStream stream = new ByteArrayOutputStream();
    stream.write(TEST_LANGUAGE.getBytes(StandardCharsets.US_ASCII));
    // Padding for language code.
    stream.write(new byte[] { (byte) 0x0 });
    stream.write(TEST_TEXT.getBytes(StandardCharsets.UTF_8));
    return stream.toByteArray();
}
#method_after
private byte[] getTestData(String language, String text) throws IOException {
    ByteArrayOutputStream stream = new ByteArrayOutputStream();
    stream.write(language.getBytes(StandardCharsets.US_ASCII));
    // Padding for language code.
    stream.write(new byte[] { (byte) 0x0 });
    stream.write(text.getBytes(StandardCharsets.UTF_8));
    return stream.toByteArray();
}
#end_block

#method_before
@Test(expected = ProtocolException.class)
public void parseBufferWithLengthLessThanMinimum() throws Exception {
    byte[] testData = getTestData();
    ByteBuffer buffer = ByteBuffer.allocate(testData.length + 1);
    buffer.put((byte) (I18Name.MINIMUM_LENGTH - 1));
    buffer.put(testData);
    // Rewind buffer for reading.
    buffer.position(0);
    I18Name.parse(buffer);
}
#method_after
@Test(expected = ProtocolException.class)
public void parseBufferWithLengthLessThanMinimum() throws Exception {
    byte[] data = getDefaultTestData();
    I18Name.parse(getTestBuffer(data, I18Name.MINIMUM_LENGTH - 1));
}
#end_block

#method_before
@Test
public void parseBufferWithFrenchData() throws Exception {
    // Test data for French.
    String language = "fr";
    String text = "Hello World";
    byte[] languageBytes = language.getBytes(StandardCharsets.US_ASCII);
    byte[] textBytes = text.getBytes(StandardCharsets.UTF_8);
    int dataLength = I18Name.LANGUAGE_CODE_LENGTH + textBytes.length;
    ByteBuffer buffer = ByteBuffer.allocate(dataLength + 1);
    buffer.put((byte) dataLength);
    buffer.put(languageBytes);
    // Padding for language code.
    buffer.put((byte) 0);
    buffer.put(textBytes);
    // Rewind buffer for reading.
    buffer.position(0);
    I18Name actualName = I18Name.parse(buffer);
    I18Name expectedName = new I18Name(language, Locale.forLanguageTag(language), text);
    assertEquals(expectedName, actualName);
}
#method_after
@Test
public void parseBufferWithFrenchData() throws Exception {
    // Test data for French.
    String language = "fr";
    String text = "Hello World";
    byte[] data = getTestData(language, text);
    I18Name actualName = I18Name.parse(getTestBuffer(data, data.length));
    I18Name expectedName = new I18Name(language, Locale.forLanguageTag(language), text);
    assertEquals(expectedName, actualName);
}
#end_block

#method_before
@Test
public void parseBufferWithEmptyText() throws Exception {
    byte[] language = TEST_LANGUAGE.getBytes(StandardCharsets.US_ASCII);
    int dataLength = I18Name.LANGUAGE_CODE_LENGTH;
    ByteBuffer buffer = ByteBuffer.allocate(dataLength + 1);
    buffer.put((byte) dataLength);
    buffer.put(language);
    // Padding for language code.
    buffer.put((byte) 0);
    // Rewind buffer for reading.
    buffer.position(0);
    I18Name actualName = I18Name.parse(buffer);
    I18Name expectedName = new I18Name(TEST_LANGUAGE, TEST_LOCALE, "");
    assertEquals(expectedName, actualName);
}
#method_after
@Test
public void parseBufferWithEmptyText() throws Exception {
    byte[] data = getTestData(TEST_LANGUAGE, "");
    I18Name actualName = I18Name.parse(getTestBuffer(data, data.length));
    I18Name expectedName = new I18Name(TEST_LANGUAGE, TEST_LOCALE, "");
    assertEquals(expectedName, actualName);
}
#end_block

#method_before
public static IPAddressTypeAvailabilityElement parse(ByteBuffer payload) throws ProtocolException {
    if (payload.remaining() != EXPECTED_BUFFER_LENGTH) {
        throw new ProtocolException("Unexpected buffer length: " + payload.remaining());
    }
    int ipField = payload.get() & 0xFF;
    int v6Availability = ipField & 0x3;
    if (!IPV6_AVAILABILITY.contains(v6Availability)) {
        v6Availability = IPV6_UNKNOWN;
    }
    int v4Availability = (ipField >> 2) & 0x3f;
    if (!IPV4_AVAILABILITY.contains(v4Availability)) {
        v4Availability = IPV4_UNKNOWN;
    }
    return new IPAddressTypeAvailabilityElement(v4Availability, v6Availability);
}
#method_after
public static IPAddressTypeAvailabilityElement parse(ByteBuffer payload) throws ProtocolException {
    if (payload.remaining() != EXPECTED_BUFFER_LENGTH) {
        throw new ProtocolException("Unexpected buffer length: " + payload.remaining());
    }
    int ipField = payload.get() & 0xFF;
    int v6Availability = ipField & IPV6_AVAILABILITY_MASK;
    if (!IPV6_AVAILABILITY.contains(v6Availability)) {
        v6Availability = IPV6_UNKNOWN;
    }
    int v4Availability = (ipField >> 2) & IPV4_AVAILABILITY_MASK;
    if (!IPV4_AVAILABILITY.contains(v4Availability)) {
        v4Availability = IPV4_UNKNOWN;
    }
    return new IPAddressTypeAvailabilityElement(v4Availability, v6Availability);
}
#end_block

#method_before
@Test
public void parseBufferWithEmptyVenueName() throws Exception {
    byte[] testData = getTestData(new String[0]);
    ByteBuffer buffer = ByteBuffer.allocate(testData.length);
    buffer.put(testData);
    buffer.position(0);
    assertTrue(VenueNameElement.parse(buffer).getNames().isEmpty());
}
#method_after
@Test
public void parseBufferWithEmptyVenueName() throws Exception {
    ByteBuffer buffer = ByteBuffer.wrap(getTestData(new String[0]));
    assertTrue(VenueNameElement.parse(buffer).getNames().isEmpty());
}
#end_block

#method_before
@Test
public void parseBufferWithValidVenueNames() throws Exception {
    byte[] testData = getTestData(new String[] { TEST_VENUE_NAME1, TEST_VENUE_NAME2 });
    ByteBuffer buffer = ByteBuffer.allocate(testData.length);
    buffer.put(testData);
    buffer.position(0);
    // Setup expected element.
    List<I18Name> nameList = new ArrayList<>();
    nameList.add(new I18Name(TEST_LANGUAGE, TEST_LOCALE, TEST_VENUE_NAME1));
    nameList.add(new I18Name(TEST_LANGUAGE, TEST_LOCALE, TEST_VENUE_NAME2));
    VenueNameElement expectedElement = new VenueNameElement(nameList);
    assertEquals(expectedElement, VenueNameElement.parse(buffer));
}
#method_after
@Test
public void parseBufferWithValidVenueNames() throws Exception {
    // Setup expected element.
    List<I18Name> nameList = new ArrayList<>();
    nameList.add(new I18Name(TEST_LANGUAGE, TEST_LOCALE, TEST_VENUE_NAME1));
    nameList.add(new I18Name(TEST_LANGUAGE, TEST_LOCALE, TEST_VENUE_NAME2));
    VenueNameElement expectedElement = new VenueNameElement(nameList);
    ByteBuffer buffer = ByteBuffer.wrap(getTestData(new String[] { TEST_VENUE_NAME1, TEST_VENUE_NAME2 }));
    assertEquals(expectedElement, VenueNameElement.parse(buffer));
}
#end_block

#method_before
@Test
public void parseBufferWithMaxLengthVenueName() throws Exception {
    // Venue name with maximum length.
    byte[] textData = new byte[VenueNameElement.MAXIMUM_VENUE_NAME_LENGTH];
    Arrays.fill(textData, (byte) 'a');
    String text = new String(textData);
    byte[] testData = getTestData(new String[] { text });
    ByteBuffer buffer = ByteBuffer.allocate(testData.length);
    buffer.put(testData);
    buffer.position(0);
    // Setup expected element.
    List<I18Name> nameList = new ArrayList<>();
    nameList.add(new I18Name(TEST_LANGUAGE, TEST_LOCALE, text));
    VenueNameElement expectedElement = new VenueNameElement(nameList);
    assertEquals(expectedElement, VenueNameElement.parse(buffer));
}
#method_after
@Test
public void parseBufferWithMaxLengthVenueName() throws Exception {
    // Venue name with maximum length.
    byte[] textData = new byte[VenueNameElement.MAXIMUM_VENUE_NAME_LENGTH];
    Arrays.fill(textData, (byte) 'a');
    String text = new String(textData);
    ByteBuffer buffer = ByteBuffer.wrap(getTestData(new String[] { text }));
    // Setup expected element.
    List<I18Name> nameList = new ArrayList<>();
    nameList.add(new I18Name(TEST_LANGUAGE, TEST_LOCALE, text));
    VenueNameElement expectedElement = new VenueNameElement(nameList);
    assertEquals(expectedElement, VenueNameElement.parse(buffer));
}
#end_block

#method_before
@Test(expected = ProtocolException.class)
public void parseBufferWithVenueNameLengthExceedMax() throws Exception {
    byte[] textData = new byte[VenueNameElement.MAXIMUM_VENUE_NAME_LENGTH + 1];
    Arrays.fill(textData, (byte) 'a');
    String text = new String(textData);
    byte[] testData = getTestData(new String[] { text });
    ByteBuffer buffer = ByteBuffer.allocate(testData.length);
    buffer.put(testData);
    buffer.position(0);
    VenueNameElement.parse(buffer);
}
#method_after
@Test(expected = ProtocolException.class)
public void parseBufferWithVenueNameLengthExceedMax() throws Exception {
    byte[] textData = new byte[VenueNameElement.MAXIMUM_VENUE_NAME_LENGTH + 1];
    Arrays.fill(textData, (byte) 'a');
    String text = new String(textData);
    ByteBuffer buffer = ByteBuffer.wrap(getTestData(new String[] { text }));
    VenueNameElement.parse(buffer);
}
#end_block

#method_before
@Test
public void parseBufferWithDefaultTestData() throws Exception {
    byte[] testData = getDefaultTestData();
    ByteBuffer buffer = ByteBuffer.allocate(testData.length);
    buffer.put(testData);
    buffer.position(0);
    // Setup expected element.
    RoamingConsortiumElement expectedElement = getDefaultElement();
    assertEquals(expectedElement, RoamingConsortiumElement.parse(buffer));
}
#method_after
@Test
public void parseBufferWithDefaultTestData() throws Exception {
    // Setup expected element.
    RoamingConsortiumElement expectedElement = getDefaultElement();
    ByteBuffer buffer = ByteBuffer.wrap(getDefaultTestData());
    assertEquals(expectedElement, RoamingConsortiumElement.parse(buffer));
}
#end_block

#method_before
public static String readStringWithByteLength(ByteBuffer payload, Charset charset) {
    int length = (int) readInteger(payload, payload.order(), 1);
    return readString(payload, length, charset);
}
#method_after
public static String readStringWithByteLength(ByteBuffer payload, Charset charset) {
    int length = payload.get() & 0xFF;
    return readString(payload, length, charset);
}
#end_block

#method_before
protected TrustManagerImpl getSSLParametersTrustManager(SSLParametersImpl params) throws IllegalAccessException {
    return (TrustManagerImpl) sslParamtersTrustManager.get(params);
}
#method_after
protected TrustManagerImpl getSSLParametersTrustManager(SSLParametersImpl params) throws IllegalAccessException {
    return (TrustManagerImpl) sslParametersTrustManager.get(params);
}
#end_block

#method_before
private static ApkLite parseApkLite(String codePath, Resources res, XmlPullParser parser, AttributeSet attrs, int flags, Signature[] signatures, Certificate[][] certificates) throws IOException, XmlPullParserException, PackageParserException {
    final Pair<String, String> packageSplit = parsePackageSplitNames(parser, attrs);
    int installLocation = PARSE_DEFAULT_INSTALL_LOCATION;
    int versionCode = 0;
    int revisionCode = 0;
    boolean debuggable = false;
    boolean coreApp = false;
    boolean multiArch = false;
    boolean use32bitAbi = false;
    boolean extractNativeLibs = true;
    for (int i = 0; i < attrs.getAttributeCount(); i++) {
        final String attr = attrs.getAttributeName(i);
        if (attr.equals("installLocation")) {
            installLocation = attrs.getAttributeIntValue(i, PARSE_DEFAULT_INSTALL_LOCATION);
        } else if (attr.equals("versionCode")) {
            versionCode = attrs.getAttributeIntValue(i, 0);
        } else if (attr.equals("revisionCode")) {
            revisionCode = attrs.getAttributeIntValue(i, 0);
        } else if (attr.equals("coreApp")) {
            coreApp = attrs.getAttributeBooleanValue(i, false);
        }
    }
    // Only search the tree when the tag is directly below <manifest>
    int type;
    final int searchDepth = parser.getDepth() + 1;
    final List<VerifierInfo> verifiers = new ArrayList<VerifierInfo>();
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() >= searchDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        if (parser.getDepth() == searchDepth && "package-verifier".equals(parser.getName())) {
            final VerifierInfo verifier = parseVerifier(res, parser, attrs, flags);
            if (verifier != null) {
                verifiers.add(verifier);
            }
        }
        if (parser.getDepth() == searchDepth && "application".equals(parser.getName())) {
            for (int i = 0; i < attrs.getAttributeCount(); ++i) {
                final String attr = attrs.getAttributeName(i);
                if ("debuggable".equals(attr)) {
                    debuggable = attrs.getAttributeBooleanValue(i, false);
                }
                if ("multiArch".equals(attr)) {
                    multiArch = attrs.getAttributeBooleanValue(i, false);
                }
                if ("use32bitAbi".equals(attr)) {
                    use32bitAbi = attrs.getAttributeBooleanValue(i, false);
                }
                if ("extractNativeLibs".equals(attr)) {
                    extractNativeLibs = attrs.getAttributeBooleanValue(i, true);
                }
            }
        }
    }
    return new ApkLite(codePath, packageSplit.first, packageSplit.second, versionCode, revisionCode, installLocation, verifiers, signatures, certificates, coreApp, debuggable, multiArch, use32bitAbi, extractNativeLibs);
}
#method_after
private static ApkLite parseApkLite(String codePath, Resources res, XmlPullParser parser, AttributeSet attrs, int flags, Signature[] signatures, Certificate[][] certificates) throws IOException, XmlPullParserException, PackageParserException {
    final Pair<String, String> packageSplit = parsePackageSplitNames(parser, attrs);
    int installLocation = PARSE_DEFAULT_INSTALL_LOCATION;
    int versionCode = 0;
    int revisionCode = 0;
    boolean coreApp = false;
    boolean debuggable = false;
    boolean multiArch = false;
    boolean use32bitAbi = false;
    boolean extractNativeLibs = true;
    for (int i = 0; i < attrs.getAttributeCount(); i++) {
        final String attr = attrs.getAttributeName(i);
        if (attr.equals("installLocation")) {
            installLocation = attrs.getAttributeIntValue(i, PARSE_DEFAULT_INSTALL_LOCATION);
        } else if (attr.equals("versionCode")) {
            versionCode = attrs.getAttributeIntValue(i, 0);
        } else if (attr.equals("revisionCode")) {
            revisionCode = attrs.getAttributeIntValue(i, 0);
        } else if (attr.equals("coreApp")) {
            coreApp = attrs.getAttributeBooleanValue(i, false);
        }
    }
    // Only search the tree when the tag is directly below <manifest>
    int type;
    final int searchDepth = parser.getDepth() + 1;
    final List<VerifierInfo> verifiers = new ArrayList<VerifierInfo>();
    while ((type = parser.next()) != XmlPullParser.END_DOCUMENT && (type != XmlPullParser.END_TAG || parser.getDepth() >= searchDepth)) {
        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
            continue;
        }
        if (parser.getDepth() == searchDepth && "package-verifier".equals(parser.getName())) {
            final VerifierInfo verifier = parseVerifier(res, parser, attrs, flags);
            if (verifier != null) {
                verifiers.add(verifier);
            }
        }
        if (parser.getDepth() == searchDepth && "application".equals(parser.getName())) {
            for (int i = 0; i < attrs.getAttributeCount(); ++i) {
                final String attr = attrs.getAttributeName(i);
                if ("debuggable".equals(attr)) {
                    debuggable = attrs.getAttributeBooleanValue(i, false);
                }
                if ("multiArch".equals(attr)) {
                    multiArch = attrs.getAttributeBooleanValue(i, false);
                }
                if ("use32bitAbi".equals(attr)) {
                    use32bitAbi = attrs.getAttributeBooleanValue(i, false);
                }
                if ("extractNativeLibs".equals(attr)) {
                    extractNativeLibs = attrs.getAttributeBooleanValue(i, true);
                }
            }
        }
    }
    return new ApkLite(codePath, packageSplit.first, packageSplit.second, versionCode, revisionCode, installLocation, verifiers, signatures, certificates, coreApp, debuggable, multiArch, use32bitAbi, extractNativeLibs);
}
#end_block

#method_before
@Override
public void onCreate() {
    mHandlerThread = new HandlerThread("RecommendationProvider");
    mHandlerThread.start();
    mHandler = new Handler(mHandlerThread.getLooper());
    mProvider = new DefaultNetworkRecommendationProvider(mHandler);
}
#method_after
@Override
public void onCreate() {
    mHandlerThread = new HandlerThread("RecommendationProvider");
    mHandlerThread.start();
    mHandler = new Handler(mHandlerThread.getLooper());
    mProvider = new DefaultNetworkRecommendationProvider(mHandler, (NetworkScoreManager) getSystemService(Context.NETWORK_SCORE_SERVICE));
}
#end_block

#method_before
public IBinder onBind(Intent intent) {
    return mProvider.getBinder();
}
#method_after
@Override
public IBinder onBind(Intent intent) {
    return mProvider.getBinder();
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    writer.print("Count: " + mProvider.counter);
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    mProvider.dump(fd, writer, args);
}
#end_block

#method_before
@Override
public RecommendationResult onRequestRecommendation(RecommendationRequest request) {
    counter++;
    ScanResult recommendedScanResult = null;
    ScanResult[] results = request.getScanResults();
    for (int i = 0; i < results.length; i++) {
        if (recommendedScanResult == null) {
            recommendedScanResult = results[i];
            continue;
        }
        if (results[i].level > recommendedScanResult.level) {
            recommendedScanResult = results[i];
            continue;
        }
    }
    WifiConfiguration recommendedConfig = new WifiConfiguration();
    recommendedConfig.SSID = "\"" + recommendedScanResult.SSID + "\"";
    recommendedConfig.BSSID = recommendedScanResult.BSSID;
    recommendedConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
    Log.d(TAG, "Recommending:" + recommendedConfig);
    return new RecommendationResult(recommendedConfig);
}
#method_after
@Override
public void onRequestRecommendation(RecommendationRequest request, NetworkRecommendationProvider.ResultCallback callback) {
    ScanResult recommendedScanResult = null;
    ScanResult[] results = request.getScanResults();
    for (int i = 0; i < results.length; i++) {
        ScanResult result = results[i];
        // a future CL.
        if (!"[ESS]".equals(result.capabilities)) {
            continue;
        }
        // If we don't have a candidate recommendation, use the first network we see.
        if (recommendedScanResult == null) {
            recommendedScanResult = result;
            continue;
        }
        // If the candidate network has a higher rssi, use it.
        if (result.level > recommendedScanResult.level) {
            recommendedScanResult = result;
            continue;
        }
    }
    if (recommendedScanResult == null) {
        callback.onResult(new RecommendationResult(null));
        return;
    }
    // Build a configuration based on the scan.
    WifiConfiguration recommendedConfig = new WifiConfiguration();
    recommendedConfig.SSID = "\"" + recommendedScanResult.SSID + "\"";
    recommendedConfig.BSSID = recommendedScanResult.BSSID;
    recommendedConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.NONE);
    synchronized (this) {
        mLastRecommended = recommendedConfig;
        mRecommendationCounter++;
    }
    callback.onResult(new RecommendationResult(recommendedConfig));
}
#end_block

#method_before
public void testMultiCharMinusSignAndPercentage() {
    DecimalFormatSymbols dfs;
    dfs = new DecimalFormatSymbols(Locale.forLanguageTag("ar"));
    assertEquals('%', dfs.getPercent());
    assertEquals('-', dfs.getMinusSign());
    dfs = new DecimalFormatSymbols(Locale.forLanguageTag("fa"));
    assertEquals('٪', dfs.getPercent());
    assertEquals('−', dfs.getMinusSign());
}
#method_after
public void testMultiCharMinusSignAndPercentage() {
    DecimalFormatSymbols dfs;
    // There have during the years been numerous bugs and workarounds around the decimal format
    // symbols used for Arabic and Farsi. Most of the problems have had to do with bidi control
    // characters and the Unicode bidi algorithm, which have not worked well together with code
    // assuming that these symbols can be represented as a single Java char.
    // 
    // This test case exists to verify that java.text.DecimalFormatSymbols in Android gets some
    // kind of sensible values for these symbols (and not, as bugs have caused in the past,
    // empty strings or only bidi control characters without any actual symbols).
    // 
    // It is expected that the symbols may change with future CLDR updates.
    dfs = new DecimalFormatSymbols(Locale.forLanguageTag("ar"));
    assertEquals('%', dfs.getPercent());
    assertEquals('-', dfs.getMinusSign());
    dfs = new DecimalFormatSymbols(Locale.forLanguageTag("fa"));
    assertEquals('٪', dfs.getPercent());
    assertEquals('−', dfs.getMinusSign());
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    initMocks(this);
    // Returning the initial timestamp.
    when(mClock.getWallClockMillis()).thenReturn(0L);
}
#method_after
@Before
public void setUp() throws Exception {
    initMocks(this);
    // Returning the initial timestamp.
    when(mClock.getElapsedSinceBootMillis()).thenReturn(0L);
}
#end_block

#method_before
@Test
public void verifyExpiration() throws Exception {
    long initialTime = 0;
    ANQPData data = new ANQPData(mClock, null);
    assertFalse(data.expired(ANQPData.DATA_LIFETIME_MILLISECONDS - 1));
    assertTrue(data.expired(ANQPData.DATA_LIFETIME_MILLISECONDS));
}
#method_after
@Test
public void verifyExpiration() throws Exception {
    ANQPData data = new ANQPData(mClock, null);
    assertFalse(data.expired(ANQPData.DATA_LIFETIME_MILLISECONDS - 1));
    assertTrue(data.expired(ANQPData.DATA_LIFETIME_MILLISECONDS));
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    if (mANQPElements == null) {
        sb.append(", unresolved, ");
    } else {
        sb.append(", ").append(mANQPElements.size()).append(" elements, ");
    }
    long now = mClock.getWallClockMillis();
    sb.append(" expires in ").append(Utils.toHMS(mExpiryTime - now)).append(' ');
    sb.append(expired(now) ? 'x' : '-');
    sb.append(mANQPElements == null ? 'u' : '-');
    return sb.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder sb = new StringBuilder();
    if (mANQPElements == null) {
        sb.append(", unresolved, ");
    } else {
        sb.append(", ").append(mANQPElements.size()).append(" elements, ");
    }
    long now = mClock.getElapsedSinceBootMillis();
    sb.append(" expires in ").append(Utils.toHMS(mExpiryTime - now)).append(' ');
    sb.append(expired(now) ? 'x' : '-');
    sb.append(mANQPElements == null ? 'u' : '-');
    return sb.toString();
}
#end_block

#method_before
@Test
public void buildStandardESSKey() throws Exception {
    ANQPNetworkKey expectedKey = new ANQPNetworkKey(SSID, 0, 0);
    ANQPNetworkKey actualKey = ANQPNetworkKey.buildKey(SSID, BSSID, 0, ANQP_DOMAIN_ID);
    assertEquals(expectedKey, actualKey);
}
#method_after
@Test
public void buildStandardESSKey() throws Exception {
    ANQPNetworkKey expectedKey = new ANQPNetworkKey(SSID, 0, 0, ANQP_DOMAIN_ID);
    ANQPNetworkKey actualKey = ANQPNetworkKey.buildKey(SSID, BSSID, 0, ANQP_DOMAIN_ID);
    assertEquals(expectedKey, actualKey);
}
#end_block

#method_before
@Test
public void buildHessidKey() throws Exception {
    ANQPNetworkKey expectedKey = new ANQPNetworkKey(null, 0, HESSID);
    ANQPNetworkKey actualKey = ANQPNetworkKey.buildKey(SSID, BSSID, HESSID, ANQP_DOMAIN_ID);
    assertEquals(expectedKey, actualKey);
}
#method_after
@Test
public void buildHessidKey() throws Exception {
    ANQPNetworkKey expectedKey = new ANQPNetworkKey(null, 0, HESSID, ANQP_DOMAIN_ID);
    ANQPNetworkKey actualKey = ANQPNetworkKey.buildKey(SSID, BSSID, HESSID, ANQP_DOMAIN_ID);
    assertEquals(expectedKey, actualKey);
}
#end_block

#method_before
@Test
public void buildAPKey() throws Exception {
    ANQPNetworkKey expectedKey = new ANQPNetworkKey(SSID, BSSID, 0);
    ANQPNetworkKey actualKey = ANQPNetworkKey.buildKey(SSID, BSSID, HESSID, 0);
    assertEquals(expectedKey, actualKey);
}
#method_after
@Test
public void buildAPKey() throws Exception {
    ANQPNetworkKey expectedKey = new ANQPNetworkKey(SSID, BSSID, 0, 0);
    ANQPNetworkKey actualKey = ANQPNetworkKey.buildKey(SSID, BSSID, HESSID, 0);
    assertEquals(expectedKey, actualKey);
}
#end_block

#method_before
public void sweep() {
    long now = mClock.getWallClockMillis();
    // Check if it is time to perform the sweep.
    if (now < mLastSweep + CACHE_SWEEP_INTERVAL_MILLISECONDS) {
        return;
    }
    // Get all expired keys.
    List<ANQPNetworkKey> expiredKeys = new ArrayList<>();
    for (Map.Entry<ANQPNetworkKey, ANQPData> entry : mANQPCache.entrySet()) {
        if (entry.getValue().expired(now)) {
            expiredKeys.add(entry.getKey());
        }
    }
    // Remove all expired entries.
    for (ANQPNetworkKey key : expiredKeys) {
        mANQPCache.remove(key);
    }
    mLastSweep = now;
}
#method_after
public void sweep() {
    long now = mClock.getElapsedSinceBootMillis();
    // Check if it is time to perform the sweep.
    if (now < mLastSweep + CACHE_SWEEP_INTERVAL_MILLISECONDS) {
        return;
    }
    // Get all expired keys.
    List<ANQPNetworkKey> expiredKeys = new ArrayList<>();
    for (Map.Entry<ANQPNetworkKey, ANQPData> entry : mANQPCache.entrySet()) {
        if (entry.getValue().expired(now)) {
            expiredKeys.add(entry.getKey());
        }
    }
    // Remove all expired entries.
    for (ANQPNetworkKey key : expiredKeys) {
        mANQPCache.remove(key);
    }
    mLastSweep = now;
}
#end_block

#method_before
public void dump(PrintWriter out) {
    out.println("Last sweep " + Utils.toHMS(mClock.getWallClockMillis() - mLastSweep) + " ago.");
    for (ANQPData anqpData : mANQPCache.values()) {
        out.println(anqpData);
    }
}
#method_after
public void dump(PrintWriter out) {
    out.println("Last sweep " + Utils.toHMS(mClock.getElapsedSinceBootMillis() - mLastSweep) + " ago.");
    for (ANQPData anqpData : mANQPCache.values()) {
        out.println(anqpData);
    }
}
#end_block

#method_before
public static ANQPNetworkKey buildKey(String ssid, long bssid, long hessid, int anqpDomainId) {
    if (anqpDomainId == 0) {
        return new ANQPNetworkKey(ssid, bssid, 0);
    } else if (hessid != 0L) {
        return new ANQPNetworkKey(null, 0, hessid);
    }
    return new ANQPNetworkKey(ssid, 0, 0);
}
#method_after
public static ANQPNetworkKey buildKey(String ssid, long bssid, long hessid, int anqpDomainId) {
    if (anqpDomainId == 0) {
        return new ANQPNetworkKey(ssid, bssid, 0, 0);
    } else if (hessid != 0L) {
        return new ANQPNetworkKey(null, 0, hessid, anqpDomainId);
    }
    return new ANQPNetworkKey(ssid, 0, 0, anqpDomainId);
}
#end_block

#method_before
@Override
public int hashCode() {
    if (mHESSID != 0) {
        return (int) ((mHESSID >>> 32) * 31 + mHESSID);
    } else if (mBSSID != 0) {
        return (int) ((mSSID.hashCode() * 31 + (mBSSID >>> 32)) * 31 + mBSSID);
    } else {
        return mSSID.hashCode();
    }
}
#method_after
@Override
public int hashCode() {
    if (mHESSID != 0) {
        return (int) (((mHESSID >>> 32) * 31 + mHESSID) * 31 + mAnqpDomainID);
    } else if (mBSSID != 0) {
        return (int) ((mSSID.hashCode() * 31 + (mBSSID >>> 32)) * 31 + mBSSID);
    } else {
        return mSSID.hashCode() * 31 + mAnqpDomainID;
    }
}
#end_block

#method_before
@Override
public boolean equals(Object thatObject) {
    if (thatObject == this) {
        return true;
    }
    if (!(thatObject instanceof ANQPNetworkKey)) {
        return false;
    }
    ANQPNetworkKey that = (ANQPNetworkKey) thatObject;
    return TextUtils.equals(that.mSSID, mSSID) && that.mBSSID == mBSSID && that.mHESSID == mHESSID;
}
#method_after
@Override
public boolean equals(Object thatObject) {
    if (thatObject == this) {
        return true;
    }
    if (!(thatObject instanceof ANQPNetworkKey)) {
        return false;
    }
    ANQPNetworkKey that = (ANQPNetworkKey) thatObject;
    return TextUtils.equals(that.mSSID, mSSID) && that.mBSSID == mBSSID && that.mHESSID == mHESSID && that.mAnqpDomainID == mAnqpDomainID;
}
#end_block

#method_before
@Override
public String toString() {
    if (mHESSID != 0L) {
        return "HESSID:" + Utils.macToString(mHESSID);
    } else if (mBSSID != 0L) {
        return Utils.macToString(mBSSID) + ":<" + Utils.toUnicodeEscapedString(mSSID) + ">";
    } else {
        return '<' + Utils.toUnicodeEscapedString(mSSID) + '>';
    }
}
#method_after
@Override
public String toString() {
    if (mHESSID != 0L) {
        return Utils.macToString(mHESSID) + ":" + mAnqpDomainID;
    } else if (mBSSID != 0L) {
        return Utils.macToString(mBSSID) + ":<" + Utils.toUnicodeEscapedString(mSSID) + ">";
    } else {
        return "<" + Utils.toUnicodeEscapedString(mSSID) + ">:" + mAnqpDomainID;
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    initMocks(this);
    // Returning the initial timestamp.
    when(mClock.getWallClockMillis()).thenReturn(0L);
    mCache = new AnqpCache(mClock);
}
#method_after
@Before
public void setUp() throws Exception {
    initMocks(this);
    // Returning the initial timestamp.
    when(mClock.getElapsedSinceBootMillis()).thenReturn(0L);
    mCache = new AnqpCache(mClock);
}
#end_block

#method_before
@Test
public void sweepRemoveExpiredEntry() throws Exception {
    mCache.addEntry(ENTRY_KEY, null);
    // Sweep the cache when the entry is not expired.
    when(mClock.getWallClockMillis()).thenReturn(AnqpCache.CACHE_SWEEP_INTERVAL_MILLISECONDS);
    mCache.sweep();
    assertNotNull(mCache.getEntry(ENTRY_KEY));
    // Sweep the cache when the entry is expired.
    when(mClock.getWallClockMillis()).thenReturn(ANQPData.DATA_LIFETIME_MILLISECONDS);
    mCache.sweep();
    assertNull(mCache.getEntry(ENTRY_KEY));
}
#method_after
@Test
public void sweepRemoveExpiredEntry() throws Exception {
    mCache.addEntry(ENTRY_KEY, null);
    // Sweep the cache when the entry is not expired.
    when(mClock.getElapsedSinceBootMillis()).thenReturn(AnqpCache.CACHE_SWEEP_INTERVAL_MILLISECONDS);
    mCache.sweep();
    assertNotNull(mCache.getEntry(ENTRY_KEY));
    // Sweep the cache when the entry is expired.
    when(mClock.getElapsedSinceBootMillis()).thenReturn(ANQPData.DATA_LIFETIME_MILLISECONDS);
    mCache.sweep();
    assertNull(mCache.getEntry(ENTRY_KEY));
}
#end_block

#method_before
protected void addCommonClientTlvs(ByteBuffer buf) {
    addTlv(buf, DHCP_MAX_MESSAGE_SIZE, (short) MAX_LENGTH);
    addTlv(buf, DHCP_VENDOR_CLASS_ID, getVendorId());
    final String hn = getHostname();
    if (hn != null && !hn.isEmpty())
        addTlv(buf, DHCP_HOST_NAME, hn);
}
#method_after
protected void addCommonClientTlvs(ByteBuffer buf) {
    addTlv(buf, DHCP_MAX_MESSAGE_SIZE, (short) MAX_LENGTH);
    addTlv(buf, DHCP_VENDOR_CLASS_ID, getVendorId());
    final String hn = getHostname();
    if (!TextUtils.isEmpty(hn))
        addTlv(buf, DHCP_HOST_NAME, hn);
}
#end_block

#method_before
public void addDomain(Iterator<String> labels, Match match) {
    String labelName = labels.next();
    // Create the Label object if it doesn't exist yet.
    Label subLabel = mSubDomains.get(labelName);
    if (subLabel == null) {
        subLabel = new Label(Match.None);
        mSubDomains.put(labelName, subLabel);
    }
    if (labels.hasNext()) {
        // Adding sub-domain.
        subLabel.addDomain(labels, match);
    } else {
        // End of the domain, update the match status.
        subLabel.mMatch = match;
    }
}
#method_after
public void addDomain(Iterator<String> labels, int match) {
    String labelName = labels.next();
    // Create the Label object if it doesn't exist yet.
    Label subLabel = mSubDomains.get(labelName);
    if (subLabel == null) {
        subLabel = new Label(MATCH_NONE);
        mSubDomains.put(labelName, subLabel);
    }
    if (labels.hasNext()) {
        // Adding sub-domain.
        subLabel.addDomain(labels, match);
    } else {
        // End of the domain, update the match status.
        subLabel.mMatch = match;
    }
}
#end_block

#method_before
public Match getMatch() {
    return mMatch;
}
#method_after
public int getMatch() {
    return mMatch;
}
#end_block

#method_before
public Match isSubDomain(String domainName) {
    if (TextUtils.isEmpty(domainName)) {
        return Match.None;
    }
    List<String> domainLabels = Utils.splitDomain(domainName);
    Label label = mRoot;
    Match match = Match.None;
    for (String labelString : domainLabels) {
        label = label.getSubLabel(labelString);
        if (label == null) {
            break;
        } else if (label.getMatch() != Match.None) {
            match = label.getMatch();
            if (match == Match.Primary) {
                break;
            }
        }
    }
    return match;
}
#method_after
public int isSubDomain(String domainName) {
    if (TextUtils.isEmpty(domainName)) {
        return MATCH_NONE;
    }
    List<String> domainLabels = Utils.splitDomain(domainName);
    Label label = mRoot;
    int match = MATCH_NONE;
    for (String labelString : domainLabels) {
        label = label.getSubLabel(labelString);
        if (label == null) {
            break;
        } else if (label.getMatch() != MATCH_NONE) {
            match = label.getMatch();
            if (match == MATCH_PRIMARY) {
                break;
            }
        }
    }
    return match;
}
#end_block

#method_before
@Test
public void createMatcherWithEmptyDomains() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher(null, null);
    assertEquals(Match.None, domainMatcher.isSubDomain("google.com"));
}
#method_after
@Test
public void createMatcherWithEmptyDomains() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher(null, null);
    assertEquals(DomainMatcher.MATCH_NONE, domainMatcher.isSubDomain("google.com"));
}
#end_block

#method_before
@Test
public void matchNullDomain() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher(PRIMARY_DOMAIN, Arrays.asList(SECONDARY_DOMAIN1, SECONDARY_DOMAIN2));
    assertEquals(Match.None, domainMatcher.isSubDomain(null));
}
#method_after
@Test
public void matchNullDomain() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher(PRIMARY_DOMAIN, Arrays.asList(SECONDARY_DOMAIN1, SECONDARY_DOMAIN2));
    assertEquals(DomainMatcher.MATCH_NONE, domainMatcher.isSubDomain(null));
}
#end_block

#method_before
@Test
public void matchTestDomains() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher(PRIMARY_DOMAIN, Arrays.asList(SECONDARY_DOMAIN1, SECONDARY_DOMAIN2));
    for (Map.Entry<String, Match> entry : TEST_DOMAIN_MAP.entrySet()) {
        assertEquals(entry.getValue(), domainMatcher.isSubDomain(entry.getKey()));
    }
}
#method_after
@Test
public void matchTestDomains() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher(PRIMARY_DOMAIN, Arrays.asList(SECONDARY_DOMAIN1, SECONDARY_DOMAIN2));
    for (Map.Entry<String, Integer> entry : TEST_DOMAIN_MAP.entrySet()) {
        assertEquals(entry.getValue().intValue(), domainMatcher.isSubDomain(entry.getKey()));
    }
}
#end_block

#method_before
@Test
public void matchDomainWithBothPrimaryAndSecondary() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher(PRIMARY_DOMAIN, Arrays.asList(PRIMARY_DOMAIN));
    assertEquals(Match.Primary, domainMatcher.isSubDomain(PRIMARY_DOMAIN));
}
#method_after
@Test
public void matchDomainWithBothPrimaryAndSecondary() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher(PRIMARY_DOMAIN, Arrays.asList(PRIMARY_DOMAIN));
    assertEquals(DomainMatcher.MATCH_PRIMARY, domainMatcher.isSubDomain(PRIMARY_DOMAIN));
}
#end_block

#method_before
@Test
public void matchDomainWhenSecondaryIsSubdomainOfPrimary() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher("google.com", Arrays.asList("test.google.com"));
    assertEquals(Match.Primary, domainMatcher.isSubDomain("google.com"));
    assertEquals(Match.Primary, domainMatcher.isSubDomain("test.google.com"));
    assertEquals(Match.Primary, domainMatcher.isSubDomain("abcd.test.google.com"));
}
#method_after
@Test
public void matchDomainWhenSecondaryIsSubdomainOfPrimary() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher("google.com", Arrays.asList("test.google.com"));
    assertEquals(DomainMatcher.MATCH_PRIMARY, domainMatcher.isSubDomain("google.com"));
    assertEquals(DomainMatcher.MATCH_PRIMARY, domainMatcher.isSubDomain("test.google.com"));
    assertEquals(DomainMatcher.MATCH_PRIMARY, domainMatcher.isSubDomain("abcd.test.google.com"));
}
#end_block

#method_before
@Test
public void matchDomainWhenPrimaryIsSubdomainOfSecondary() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher("test.google.com", Arrays.asList("google.com"));
    assertEquals(Match.Secondary, domainMatcher.isSubDomain("google.com"));
    assertEquals(Match.Secondary, domainMatcher.isSubDomain("test2.google.com"));
    assertEquals(Match.Primary, domainMatcher.isSubDomain("test.google.com"));
    assertEquals(Match.Primary, domainMatcher.isSubDomain("adcd.test.google.com"));
}
#method_after
@Test
public void matchDomainWhenPrimaryIsSubdomainOfSecondary() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher("test.google.com", Arrays.asList("google.com"));
    assertEquals(DomainMatcher.MATCH_SECONDARY, domainMatcher.isSubDomain("google.com"));
    assertEquals(DomainMatcher.MATCH_SECONDARY, domainMatcher.isSubDomain("test2.google.com"));
    assertEquals(DomainMatcher.MATCH_PRIMARY, domainMatcher.isSubDomain("test.google.com"));
    assertEquals(DomainMatcher.MATCH_PRIMARY, domainMatcher.isSubDomain("adcd.test.google.com"));
}
#end_block

#method_before
@Test
public void matchDomainWithEmptyLabel() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher("test.google..com", Arrays.asList("google..com"));
    assertEquals(Match.Primary, domainMatcher.isSubDomain("test.google..com"));
    assertEquals(Match.Secondary, domainMatcher.isSubDomain("google..com"));
}
#method_after
@Test
public void matchDomainWithEmptyLabel() throws Exception {
    DomainMatcher domainMatcher = new DomainMatcher("test.google..com", Arrays.asList("google..com"));
    assertEquals(DomainMatcher.MATCH_PRIMARY, domainMatcher.isSubDomain("test.google..com"));
    assertEquals(DomainMatcher.MATCH_SECONDARY, domainMatcher.isSubDomain("google..com"));
}
#end_block

#method_before
private float findMinUserTypeAutoComb(RenderScript rs, ScriptC_reduce_auto_comb s, Allocation alloc) {
    s.set_x_startval(mX);
    s.set_y_startval(mY);
    s.set_multiplier(mMultiplier);
    return s.reduce_find_min_user_type_auto_comb(alloc).get();
}
#method_after
private float findMinUserTypeAutoComb(RenderScript rs, ScriptC_reduce_auto_comb s, Allocation alloc) {
    s.set_a_startval(mX);
    s.set_b_startval(mY);
    s.set_multiplier(mMultiplier);
    return s.reduce_find_min_user_type_auto_comb(alloc).get();
}
#end_block

#method_before
private float findMinUserType(RenderScript rs, ScriptC_reduce s, Allocation alloc) {
    s.set_x_startval(mX);
    s.set_y_startval(mY);
    s.set_multiplier(mMultiplier);
    return s.reduce_find_min_user_type(alloc).get();
}
#method_after
private float findMinUserType(RenderScript rs, ScriptC_reduce s, Allocation alloc) {
    s.set_a_startval(mX);
    s.set_b_startval(mY);
    s.set_multiplier(mMultiplier);
    return s.reduce_find_min_user_type(alloc).get();
}
#end_block

#method_before
private float findMinUserType1DAutoComb(RenderScript rs, ScriptC_reduce_auto_comb s, int xCount) {
    ScriptField_MinUserType minUserType = new ScriptField_MinUserType(rs, xCount);
    for (int i = 0; i < xCount; i++) {
        ScriptField_MinUserType.Item val = new ScriptField_MinUserType.Item();
        val.x = i + idxOffset;
        val.y = i + idxOffset;
        minUserType.set(val, i, true);
    }
    Allocation alloc = minUserType.getAllocation();
    return findMinUserTypeAutoComb(rs, s, alloc);
}
#method_after
private float findMinUserType1DAutoComb(RenderScript rs, ScriptC_reduce_auto_comb s, int xCount) {
    ScriptField_MinUserType minUserType = new ScriptField_MinUserType(rs, xCount);
    for (int i = 0; i < xCount; i++) {
        ScriptField_MinUserType.Item val = new ScriptField_MinUserType.Item();
        val.a = i + idxOffset;
        val.b = i + idxOffset;
        minUserType.set(val, i, true);
    }
    Allocation alloc = minUserType.getAllocation();
    return findMinUserTypeAutoComb(rs, s, alloc);
}
#end_block

#method_before
private float findMinUserType1D(RenderScript rs, ScriptC_reduce s, int xCount) {
    ScriptField_MinUserType minUserType = new ScriptField_MinUserType(rs, xCount);
    for (int i = 0; i < xCount; i++) {
        ScriptField_MinUserType.Item val = new ScriptField_MinUserType.Item();
        val.x = i + idxOffset;
        val.y = i + idxOffset;
        minUserType.set(val, i, true);
    }
    Allocation alloc = minUserType.getAllocation();
    return findMinUserType(rs, s, alloc);
}
#method_after
private float findMinUserType1D(RenderScript rs, ScriptC_reduce s, int xCount) {
    ScriptField_MinUserType minUserType = new ScriptField_MinUserType(rs, xCount);
    for (int i = 0; i < xCount; i++) {
        ScriptField_MinUserType.Item val = new ScriptField_MinUserType.Item();
        val.a = i + idxOffset;
        val.b = i + idxOffset;
        minUserType.set(val, i, true);
    }
    Allocation alloc = minUserType.getAllocation();
    return findMinUserType(rs, s, alloc);
}
#end_block

#method_before
public WifiConnectivityManager makeWifiConnectivityManager(WifiInfo wifiInfo, boolean hasConnectionRequests) {
    return new WifiConnectivityManager(mContext, mWifiStateMachine, getWifiScanner(), mWifiConfigManager, wifiInfo, mWifiNetworkSelector, mNetworkScoreManager, mWifiNetworkScoreCache, mWifiLastResortWatchdog, mWifiMetrics, mWifiStateMachineHandlerThread.getLooper(), mClock, hasConnectionRequests, mFrameworkFacade);
}
#method_after
public WifiConnectivityManager makeWifiConnectivityManager(WifiInfo wifiInfo, boolean hasConnectionRequests) {
    return new WifiConnectivityManager(mContext, mWifiStateMachine, getWifiScanner(), mWifiConfigManager, wifiInfo, mWifiNetworkSelector, mWifiLastResortWatchdog, mWifiMetrics, mWifiStateMachineHandlerThread.getLooper(), mClock, hasConnectionRequests, mFrameworkFacade, mSavedNetworkEvaluator, mExternalScoreEvaluator, mRecommendedNetworkEvaluator);
}
#end_block

#method_before
WifiConnectivityManager createConnectivityManager() {
    return new WifiConnectivityManager(mContext, mWifiStateMachine, mWifiScanner, mWifiConfigManager, mWifiInfo, mWifiNS, mNetworkScoreManager, mScoreCache, mWifiLastResortWatchdog, mWifiMetrics, mLooper.getLooper(), mClock, true, mFrameworkFacade);
}
#method_after
WifiConnectivityManager createConnectivityManager() {
    return new WifiConnectivityManager(mContext, mWifiStateMachine, mWifiScanner, mWifiConfigManager, mWifiInfo, mWifiNS, mWifiLastResortWatchdog, mWifiMetrics, mLooper.getLooper(), mClock, true, mFrameworkFacade, null, null, null);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mRecommendedNetworkEvaluator = new RecommendedNetworkEvaluator(mNetworkScoreCache, mNetworkScoreManager, mWifiConfigManager, mLocalLog);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mRecommendedNetworkEvaluator = new RecommendedNetworkEvaluator(mNetworkScoreCache, mNetworkScoreManager, mWifiConfigManager, new LocalLog(0));
    when(mWifiConfigManager.getSavedNetworkForScanDetailAndCache(TRUSTED_SCAN_DETAIL)).thenReturn(TRUSTED_WIFI_CONFIGURATION);
    when(mWifiConfigManager.getSavedNetworkForScanDetailAndCache(UNTRUSTED_SCAN_DETAIL)).thenReturn(null);
}
#end_block

#method_before
@Test
public void testUpdate_allNetworksScored() {
    when(mNetworkScoreCache.isScoredNetwork(SCAN_DETAIL1.getScanResult())).thenReturn(true);
    when(mNetworkScoreCache.isScoredNetwork(SCAN_DETAIL2.getScanResult())).thenReturn(true);
    mRecommendedNetworkEvaluator.update(Lists.newArrayList(SCAN_DETAIL1, SCAN_DETAIL2));
    verifyZeroInteractions(mNetworkScoreManager);
}
#method_after
@Test
public void testUpdate_allNetworksScored() {
    when(mNetworkScoreCache.isScoredNetwork(TRUSTED_SCAN_DETAIL.getScanResult())).thenReturn(true);
    when(mNetworkScoreCache.isScoredNetwork(UNTRUSTED_SCAN_DETAIL.getScanResult())).thenReturn(true);
    mRecommendedNetworkEvaluator.update(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL));
    verifyZeroInteractions(mNetworkScoreManager);
}
#end_block

#method_before
@Test
public void testUpdate_oneScored_oneUnscored() {
    when(mNetworkScoreCache.isScoredNetwork(SCAN_DETAIL1.getScanResult())).thenReturn(true);
    when(mNetworkScoreCache.isScoredNetwork(SCAN_DETAIL2.getScanResult())).thenReturn(false);
    mRecommendedNetworkEvaluator.update(Lists.newArrayList(SCAN_DETAIL1, SCAN_DETAIL2));
    verify(mNetworkScoreManager).requestScores(mNetworkKeyArrayCaptor.capture());
    assertEquals(1, mNetworkKeyArrayCaptor.getValue().length);
    assertEquals(new NetworkKey(new WifiKey(SCAN_DETAIL2.getSSID(), SCAN_DETAIL2.getBSSIDString())), mNetworkKeyArrayCaptor.getValue()[0]);
}
#method_after
@Test
public void testUpdate_oneScored_oneUnscored() {
    when(mNetworkScoreCache.isScoredNetwork(TRUSTED_SCAN_DETAIL.getScanResult())).thenReturn(true);
    when(mNetworkScoreCache.isScoredNetwork(UNTRUSTED_SCAN_DETAIL.getScanResult())).thenReturn(false);
    mRecommendedNetworkEvaluator.update(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL));
    verify(mNetworkScoreManager).requestScores(mNetworkKeyArrayCaptor.capture());
    assertEquals(1, mNetworkKeyArrayCaptor.getValue().length);
    NetworkKey expectedNetworkKey = new NetworkKey(new WifiKey(ScanResultUtil.createQuotedSSID(UNTRUSTED_SCAN_DETAIL.getSSID()), UNTRUSTED_SCAN_DETAIL.getBSSIDString()));
    assertEquals(expectedNetworkKey, mNetworkKeyArrayCaptor.getValue()[0]);
}
#end_block

#method_before
@Test
public void testEvaluateNetworks_emptyScanList() {
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(new ArrayList<ScanDetail>(), null, null, false, false, null);
    assertNull(result);
    verifyZeroInteractions(mWifiConfigManager, mNetworkScoreManager);
}
#method_after
@Test
public void testEvaluateNetworks_emptyScanList() {
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(new ArrayList<ScanDetail>(), null, null, false, false, /* untrustedNetworkAllowed */
    null);
    assertNull(result);
    verifyZeroInteractions(mWifiConfigManager, mNetworkScoreManager);
}
#end_block

#method_before
@Test
public void testEvaluateNetworks_nullRecommendation() {
    when(mWifiConfigManager.wasEphemeralNetworkDeleted(anyString())).thenReturn(false);
    when(mNetworkScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(null);
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(Lists.newArrayList(SCAN_DETAIL1, SCAN_DETAIL2), null, null, false, false, /* untrustedNetworkAllowed */
    null);
    assertNull(result);
    verify(mNetworkScoreManager).requestRecommendation(any(RecommendationRequest.class));
    verify(mWifiConfigManager, never()).setNetworkCandidateScanResult(anyInt(), any(ScanResult.class), anyInt());
}
#method_after
@Test
public void testEvaluateNetworks_nullRecommendation() {
    when(mWifiConfigManager.wasEphemeralNetworkDeleted(anyString())).thenReturn(false);
    when(mNetworkScoreManager.requestRecommendation(any(RecommendationRequest.class))).thenReturn(null);
    WifiConfiguration result = mRecommendedNetworkEvaluator.evaluateNetworks(Lists.newArrayList(TRUSTED_SCAN_DETAIL, UNTRUSTED_SCAN_DETAIL), null, null, false, false, /* untrustedNetworkAllowed */
    null);
    assertNull(result);
    verify(mNetworkScoreManager).requestRecommendation(any(RecommendationRequest.class));
}
#end_block

#method_before
private void updateNetworkScoreCache(List<ScanDetail> scanDetails) {
    ArrayList<NetworkKey> unscoredNetworks = new ArrayList<NetworkKey>();
    for (ScanDetail scanDetail : scanDetails) {
        ScanResult scanResult = scanDetail.getScanResult();
        // Is there a score for this network? If not, request a score.
        if (!mNetworkScoreCache.isScoredNetwork(scanResult)) {
            try {
                WifiKey wifiKey = new WifiKey("\"" + scanResult.SSID + "\"", scanResult.BSSID);
                unscoredNetworks.add(new NetworkKey(wifiKey));
            } catch (IllegalArgumentException e) {
                mLocalLog.log("Invalid SSID=" + scanResult.SSID + " BSSID=" + scanResult.BSSID + " for network score. Skip.");
            }
        }
    }
    // Kick the score manager if there are any unscored network.
    if (!unscoredNetworks.isEmpty()) {
        NetworkKey[] unscoredNetworkKeys = unscoredNetworks.toArray(new NetworkKey[unscoredNetworks.size()]);
        mNetworkScoreManager.requestScores(unscoredNetworkKeys);
    }
}
#method_after
private void updateNetworkScoreCache(List<ScanDetail> scanDetails) {
    ArrayList<NetworkKey> unscoredNetworks = new ArrayList<NetworkKey>();
    for (int i = 0; i < scanDetails.size(); i++) {
        ScanResult scanResult = scanDetails.get(i).getScanResult();
        // Is there a score for this network? If not, request a score.
        if (!mNetworkScoreCache.isScoredNetwork(scanResult)) {
            try {
                WifiKey wifiKey = new WifiKey("\"" + scanResult.SSID + "\"", scanResult.BSSID);
                unscoredNetworks.add(new NetworkKey(wifiKey));
            } catch (IllegalArgumentException e) {
                mLocalLog.log("Invalid SSID=" + scanResult.SSID + " BSSID=" + scanResult.BSSID + " for network score. Skip.");
            }
        }
    }
    // Kick the score manager if there are any unscored network.
    if (!unscoredNetworks.isEmpty()) {
        NetworkKey[] unscoredNetworkKeys = unscoredNetworks.toArray(new NetworkKey[unscoredNetworks.size()]);
        mNetworkScoreManager.requestScores(unscoredNetworkKeys);
    }
}
#end_block

#method_before
@Override
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    List<ScanResult> scanResults = new ArrayList<>();
    for (int i = 0; i < scanDetails.size(); i++) {
        ScanResult scanResult = scanDetails.get(i).getScanResult();
        if (!mWifiConfigManager.wasEphemeralNetworkDeleted(ScanResultUtil.createQuotedSSID(scanResult.SSID))) {
            scanResults.add(scanResult);
        }
    }
    if (scanResults.isEmpty()) {
        return null;
    }
    NetworkCapabilities networkCapabilities = new NetworkCapabilities();
    if (untrustedNetworkAllowed) {
        networkCapabilities.removeCapability(NetworkCapabilities.NET_CAPABILITY_TRUSTED);
    }
    RecommendationRequest request = new RecommendationRequest.Builder().setScanResults(scanResults.toArray(new ScanResult[scanResults.size()])).setNetworkCapabilities(networkCapabilities).build();
    RecommendationResult result = mNetworkScoreManager.requestRecommendation(request);
    if (result != null && result.getWifiConfiguration() != null) {
        WifiConfiguration wifiConfiguration = result.getWifiConfiguration();
        mWifiConfigManager.setNetworkCandidateScanResult(wifiConfiguration.networkId, wifiConfiguration.getNetworkSelectionStatus().getCandidate(), 0);
        return wifiConfiguration;
    }
    return null;
}
#method_after
@Override
public WifiConfiguration evaluateNetworks(List<ScanDetail> scanDetails, WifiConfiguration currentNetwork, String currentBssid, boolean connected, boolean untrustedNetworkAllowed, List<Pair<ScanDetail, WifiConfiguration>> connectableNetworks) {
    List<ScanResult> scanResults = new ArrayList<>();
    for (int i = 0; i < scanDetails.size(); i++) {
        ScanDetail scanDetail = scanDetails.get(i);
        ScanResult scanResult = scanDetail.getScanResult();
        if (mWifiConfigManager.wasEphemeralNetworkDeleted(ScanResultUtil.createQuotedSSID(scanResult.SSID))) {
            continue;
        }
        scanResult.untrusted = mWifiConfigManager.getSavedNetworkForScanDetailAndCache(scanDetail) == null;
        if (!untrustedNetworkAllowed && scanResult.untrusted) {
            continue;
        }
        scanResults.add(scanResult);
    }
    if (scanResults.isEmpty()) {
        return null;
    }
    RecommendationRequest request = new RecommendationRequest.Builder().setScanResults(scanResults.toArray(new ScanResult[scanResults.size()])).build();
    RecommendationResult result = mNetworkScoreManager.requestRecommendation(request);
    if (result != null && result.getWifiConfiguration() != null) {
        WifiConfiguration wifiConfiguration = result.getWifiConfiguration();
        // WifiConfiguration for untrusted networks. Also call setNetworkCandidateScanResult.
        return wifiConfiguration;
    }
    return null;
}
#end_block

#method_before
private static void performSystemServerDexOpt(String classPath) {
    final String[] classPathElements = classPath.split(":");
    final InstallerConnection installer = new InstallerConnection();
    installer.waitForConnection();
    final String instructionSet = VMRuntime.getRuntime().vmInstructionSet();
    try {
        String sharedLibraries = "";
        for (String classPathElement : classPathElements) {
            // System server is fully AOTed and never profiled
            // for profile guided compilation.
            // TODO: Make this configurable between INTERPRET_ONLY, SPEED, SPACE and EVERYTHING?
            int dexoptNeeded;
            try {
                dexoptNeeded = DexFile.getDexOptNeeded(classPathElement, instructionSet, "speed", false);
            } catch (FileNotFoundException ignored) {
                // Do not add to the classpath.
                Log.w(TAG, "Missing classpath element for system server: " + classPathElement);
                continue;
            } catch (IOException e) {
                // Not fully clear what to do here as we don't know the cause of the
                // IO exception. Add to the classpath to be conservative, but don't
                // attempt to compile it.
                Log.w(TAG, "Error checking classpath element for system server: " + classPathElement, e);
                dexoptNeeded = DexFile.NO_DEXOPT_NEEDED;
            }
            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
                final int dexFlags = 0;
                final String compilerFilter = "speed";
                final String uuid = null;
                try {
                    installer.dexopt(classPathElement, Process.SYSTEM_UID, "*", instructionSet, dexoptNeeded, null, dexFlags, compilerFilter, uuid, sharedLibraries);
                } catch (InstallerException e) {
                    // Ignore (but log), we need this on the classpath for fallback mode.
                    Log.w(TAG, "Failed compiling classpath element for system server: " + classPathElement, e);
                }
            }
            if (!sharedLibraries.isEmpty()) {
                sharedLibraries += ":";
            }
            sharedLibraries += classPathElement;
        }
    } finally {
        installer.disconnect();
    }
}
#method_after
private static void performSystemServerDexOpt(String classPath) {
    final String[] classPathElements = classPath.split(":");
    final InstallerConnection installer = new InstallerConnection();
    installer.waitForConnection();
    final String instructionSet = VMRuntime.getRuntime().vmInstructionSet();
    try {
        String sharedLibraries = "";
        for (String classPathElement : classPathElements) {
            // System server is fully AOTed and never profiled
            // for profile guided compilation.
            // TODO: Make this configurable between INTERPRET_ONLY, SPEED, SPACE and EVERYTHING?
            int dexoptNeeded;
            try {
                dexoptNeeded = DexFile.getDexOptNeeded(classPathElement, instructionSet, "speed", false);
            } catch (FileNotFoundException ignored) {
                // Do not add to the classpath.
                Log.w(TAG, "Missing classpath element for system server: " + classPathElement);
                continue;
            } catch (IOException e) {
                // Not fully clear what to do here as we don't know the cause of the
                // IO exception. Add to the classpath to be conservative, but don't
                // attempt to compile it.
                Log.w(TAG, "Error checking classpath element for system server: " + classPathElement, e);
                dexoptNeeded = DexFile.NO_DEXOPT_NEEDED;
            }
            if (dexoptNeeded != DexFile.NO_DEXOPT_NEEDED) {
                final String packageName = "*";
                final String outputPath = null;
                final int dexFlags = 0;
                final String compilerFilter = "speed";
                final String uuid = StorageManager.UUID_PRIVATE_INTERNAL;
                try {
                    installer.dexopt(classPathElement, Process.SYSTEM_UID, packageName, instructionSet, dexoptNeeded, outputPath, dexFlags, compilerFilter, uuid, sharedLibraries);
                } catch (InstallerException e) {
                    // Ignore (but log), we need this on the classpath for fallback mode.
                    Log.w(TAG, "Failed compiling classpath element for system server: " + classPathElement, e);
                }
            }
            if (!sharedLibraries.isEmpty()) {
                sharedLibraries += ":";
            }
            sharedLibraries += classPathElement;
        }
    } finally {
        installer.disconnect();
    }
}
#end_block

#method_before
@Override
public SignatureSpi getCurrentSpi() {
    if (lock == null && sigSpi != null) {
        // No need synchronized protection in this case.
        return sigSpi;
    }
    synchronized (lock) {
        return sigSpi;
    }
}
#method_after
@Override
public SignatureSpi getCurrentSpi() {
    if (lock == null) {
        return sigSpi;
    }
    synchronized (lock) {
        return sigSpi;
    }
}
#end_block

#method_before
@Override
protected void dump(final FileDescriptor fd, final PrintWriter writer, final String[] args) {
    mContext.enforceCallingOrSelfPermission(permission.DUMP, TAG);
    NetworkScorerAppData currentScorer = mNetworkScorerAppManager.getActiveScorer();
    if (currentScorer == null) {
        writer.println("Scoring is disabled.");
        return;
    }
    writer.println("Current scorer: " + currentScorer.mPackageName);
    sendCallback(new Consumer<INetworkScoreCache>() {

        @Override
        public void accept(INetworkScoreCache networkScoreCache) {
            try {
                networkScoreCache.asBinder().dump(fd, args);
            } catch (RemoteException e) {
                writer.println("Unable to dump score cache");
                if (Log.isLoggable(TAG, Log.VERBOSE)) {
                    Log.v(TAG, "Unable to dump score cache", e);
                }
            }
        }
    }, getScoreCacheLists());
    if (mServiceConnection != null) {
        mServiceConnection.dump(fd, writer, args);
    } else {
        writer.println("ScoringServiceConnection: null");
    }
    writer.flush();
}
#method_after
@Override
protected void dump(final FileDescriptor fd, final PrintWriter writer, final String[] args) {
    mContext.enforceCallingOrSelfPermission(permission.DUMP, TAG);
    NetworkScorerAppData currentScorer = mNetworkScorerAppManager.getActiveScorer();
    if (currentScorer == null) {
        writer.println("Scoring is disabled.");
        return;
    }
    writer.println("Current scorer: " + currentScorer.mPackageName);
    sendCallback(new Consumer<INetworkScoreCache>() {

        @Override
        public void accept(INetworkScoreCache networkScoreCache) {
            try {
                TransferPipe.dumpAsync(networkScoreCache.asBinder(), fd, args);
            } catch (IOException | RemoteException e) {
                writer.println("Failed to dump score cache: " + e);
            }
        }
    }, getScoreCacheLists());
    if (mServiceConnection != null) {
        mServiceConnection.dump(fd, writer, args);
    } else {
        writer.println("ScoringServiceConnection: null");
    }
    writer.flush();
}
#end_block

#method_before
public static String runPoc(String pathToPoc, ITestDevice device) throws Exception {
    String fullResourceName = pathToPoc;
    File pocFile = File.createTempFile("poc", "");
    try {
        try (InputStream in = AdbUtils.class.getResourceAsStream(fullResourceName);
            OutputStream out = new BufferedOutputStream(new FileOutputStream(pocFile))) {
            if (in == null) {
                throw new IllegalArgumentException("Resource not found: " + fullResourceName);
            }
            byte[] buf = new byte[65536];
            int chunkSize;
            while ((chunkSize = in.read(buf)) != -1) {
                out.write(buf, 0, chunkSize);
            }
        }
        pocFile.setExecutable(true);
        device.pushFile(pocFile, "/data/local/tmp/poc");
        device.executeShellCommand("chmod +x /data/local/tmp/poc");
        return device.executeShellCommand("/data/local/tmp/poc");
    } finally {
        pocFile.delete();
    }
}
#method_after
public static String runPoc(String pathToPoc, ITestDevice device) throws Exception {
    String fullResourceName = pathToPoc;
    File pocFile = File.createTempFile("poc", "");
    try {
        pocFile = extractResource(fullResourceName, pocFile);
        device.pushFile(pocFile, "/data/local/tmp/poc");
        device.executeShellCommand("chmod +x /data/local/tmp/poc");
        return device.executeShellCommand("/data/local/tmp/poc");
    } finally {
        pocFile.delete();
    }
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    getDevice().waitForDeviceOnline(60 * 1000);
    bootTime = java.lang.System.currentTimeMillis() / 1000 - Integer.parseInt(getDevice().executeShellCommand("cut -f1 -d. /proc/uptime").trim());
// May need to watch for soft reboot, going to ask guangzhu@ when he gets back
// systemUiPid = Integer.parseInt(getDevice().executeShellCommand("pgrep -f com.android.systemui").trim());
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    kernelStartTime = System.currentTimeMillis() / 1000 - Integer.parseInt(getDevice().executeShellCommand("cut -f1 -d. /proc/uptime").trim());
// TODO:(badash@): Watch for other things to track.
// Specifically time when app framework starts
}
#end_block

#method_before
public void enableAdbRoot(ITestDevice mDevice) throws DeviceNotAvailableException {
    boolean isUserDebug = "userdebug".equals(mDevice.executeShellCommand("getprop ro.build.type").trim());
    if (!isUserDebug) {
        // TODO(badash@): This would Noop once cl: ag/1594311 is in
        return;
    }
    String output = mDevice.executeAdbCommand("root");
    mDevice.waitForDeviceOnline();
}
#method_after
public void enableAdbRoot(ITestDevice mDevice) throws DeviceNotAvailableException {
    boolean isUserDebug = "userdebug".equals(mDevice.executeShellCommand("getprop ro.build.type").trim());
    if (!isUserDebug) {
        // TODO(badash@): This would Noop once cl: ag/1594311 is in
        return;
    }
    mDevice.executeAdbCommand("root");
}
#end_block

#method_before
@Override
public void tearDown() throws Exception {
    getDevice().waitForDeviceOnline(60 * 1000);
    assertTrue("Phone has crashed", (java.lang.System.currentTimeMillis() / 1000 - Integer.parseInt(getDevice().executeShellCommand("cut -f1 -d. /proc/uptime").trim()) - bootTime < 2));
// assertEquals("Phone has soft reset", systemUiPid, Integer.parseInt(getDevice().executeShellCommand("pgrep -f com.android.systemui").trim()));
}
#method_after
@Override
public void tearDown() throws Exception {
    getDevice().waitForDeviceOnline(60 * 1000);
    assertTrue("Phone has had a hard reset", (System.currentTimeMillis() / 1000 - Integer.parseInt(getDevice().executeShellCommand("cut -f1 -d. /proc/uptime").trim()) - kernelStartTime < 2));
    // TODO(badash@): add ability to catch runtime restart
    getDevice().executeAdbCommand("unroot");
}
#end_block

#method_before
public void testHelperCmdLine() throws Exception {
    mDevice = getDevice();
    enableAdbRoot(mDevice);
    String command = "cd /sys/kernel/slab; ls -l 2>/dev/null | grep ffffffc0";
    assertEquals("Lines do not match:", "", AdbUtils.runCommandLine(command, mDevice));
}
#method_after
public void testHelperCmdLine() throws Exception {
    enableAdbRoot(getDevice());
    String command = "cd /sys/kernel/slab; ls -l 2>/dev/null | grep ffffffc0";
    assertEquals("Lines do not match:", "", AdbUtils.runCommandLine(command, getDevice()));
}
#end_block

#method_before
public void testHelperPocRoot() throws Exception {
    mDevice = getDevice();
    enableAdbRoot(mDevice);
    AdbUtils.runPoc("/test-case", mDevice);
}
#method_after
public void testHelperPocRoot() throws Exception {
    enableAdbRoot(getDevice());
    AdbUtils.runPoc("/test-case", getDevice());
}
#end_block

#method_before
public void testHelperApk() throws Exception {
    String installResult = AdbUtils.runApk("/crash_mod.apk", getDevice());
    assertNull("failed to install apk", installResult);
}
#method_after
public void testHelperApk() throws Exception {
    String installResult = AdbUtils.installApk("/crash_mod.apk", getDevice());
    assertNull("failed to install apk", installResult);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mContext.getContentResolver()).thenReturn(mContentResolver);
    when(mFrameworkFacade.getIntegerSetting(mContext, Settings.Global.WIFI_WAKEUP_ENABLED, 0)).thenReturn(1);
    when(mWifiInjector.getWifiScanner()).thenReturn(mWifiScanner);
    TestLooper testLooper = new TestLooper();
    mWifiWakeupController = new WifiWakeupController(mContext, testLooper.getLooper(), mFrameworkFacade, mWifiInjector);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mContext.getContentResolver()).thenReturn(mContentResolver);
    when(mFrameworkFacade.getIntegerSetting(mContext, Settings.Global.WIFI_WAKEUP_ENABLED, 0)).thenReturn(1);
    TestLooper testLooper = new TestLooper();
    mWifiWakeupController = new WifiWakeupController(mContext, testLooper.getLooper(), mFrameworkFacade);
}
#end_block

#method_before
private void readImageFileDirectory(ByteOrderAwarenessDataInputStream dataInputStream, int hint) throws IOException {
    if (dataInputStream.peek() + 2 > dataInputStream.mLength) {
        // Return if there is no data from the offset.
        return;
    }
    // See JEITA CP-3451 Figure 5. page 9.
    short numberOfDirectoryEntry = dataInputStream.readShort();
    if (dataInputStream.peek() + 12 * numberOfDirectoryEntry > dataInputStream.mLength) {
        // Return if the size of entries is too big.
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "numberOfDirectoryEntry: " + numberOfDirectoryEntry);
    }
    for (short i = 0; i < numberOfDirectoryEntry; ++i) {
        int tagNumber = dataInputStream.readUnsignedShort();
        int dataFormat = dataInputStream.readUnsignedShort();
        int numberOfComponents = dataInputStream.readInt();
        // next four bytes is for data
        long nextEntryOffset = dataInputStream.peek() + 4;
        // offset or value.
        // Look up a corresponding tag from tag number
        final ExifTag tag = (ExifTag) sExifTagMapsForReading[hint].get(tagNumber);
        if (DEBUG) {
            Log.d(TAG, String.format("hint: %d, tagNumber: %d, tagName: %s, dataFormat: %d, " + "numberOfComponents: %d", hint, tagNumber, tag != null ? tag.name : null, dataFormat, numberOfComponents));
        }
        if (tag == null || dataFormat <= 0 || dataFormat >= IFD_FORMAT_BYTES_PER_FORMAT.length || numberOfComponents < 0) {
            // number of components.
            if (tag == null) {
                Log.w(TAG, "Skip the tag entry since tag number is not defined: " + tagNumber);
            } else if (dataFormat <= 0 || dataFormat >= IFD_FORMAT_BYTES_PER_FORMAT.length) {
                Log.w(TAG, "Skip the tag entry since data format is invalid: " + dataFormat);
            } else {
                Log.w(TAG, "Skip the tag entry since number of components is invalid: " + numberOfComponents);
            }
            dataInputStream.seek(nextEntryOffset);
            continue;
        }
        // Read a value from data field or seek to the value offset which is stored in data
        // field if the size of the entry value is bigger than 4.
        int byteCount = numberOfComponents * IFD_FORMAT_BYTES_PER_FORMAT[dataFormat];
        if (byteCount > 4) {
            long offset = dataInputStream.readUnsignedInt();
            if (DEBUG) {
                Log.d(TAG, "seek to data offset: " + offset);
            }
            if (offset + byteCount <= dataInputStream.mLength) {
                dataInputStream.seek(offset);
            } else {
                // Skip if invalid data offset.
                Log.w(TAG, "Skip the tag entry since data offset is invalid: " + offset);
                dataInputStream.seek(nextEntryOffset);
                continue;
            }
        }
        // Recursively parse IFD when a IFD pointer tag appears.
        int innerIfdHint = getIfdHintFromTagNumber(tagNumber);
        if (DEBUG) {
            Log.d(TAG, "innerIfdHint: " + innerIfdHint + " byteCount: " + byteCount);
        }
        if (innerIfdHint >= 0) {
            long offset = -1L;
            // Get offset from data field
            switch(dataFormat) {
                case IFD_FORMAT_USHORT:
                    {
                        offset = dataInputStream.readUnsignedShort();
                        break;
                    }
                case IFD_FORMAT_SSHORT:
                    {
                        offset = dataInputStream.readShort();
                        break;
                    }
                case IFD_FORMAT_ULONG:
                    {
                        offset = dataInputStream.readUnsignedInt();
                        break;
                    }
                case IFD_FORMAT_SLONG:
                    {
                        offset = dataInputStream.readInt();
                        break;
                    }
                default:
                    {
                        // Nothing to do
                        break;
                    }
            }
            if (DEBUG) {
                Log.d(TAG, String.format("Offset: %d, tagName: %s", offset, tag.name));
            }
            if (offset > 0L && offset < dataInputStream.mLength) {
                dataInputStream.seek(offset);
                readImageFileDirectory(dataInputStream, innerIfdHint);
            } else {
                Log.w(TAG, "Skip jump into the IFD since its offset is invalid: " + offset);
            }
            dataInputStream.seek(nextEntryOffset);
            continue;
        }
        byte[] bytes = new byte[numberOfComponents * IFD_FORMAT_BYTES_PER_FORMAT[dataFormat]];
        dataInputStream.readFully(bytes);
        mAttributes[hint].put(tag.name, new ExifAttribute(dataFormat, numberOfComponents, bytes));
        if (dataInputStream.peek() != nextEntryOffset) {
            dataInputStream.seek(nextEntryOffset);
        }
    }
    if (dataInputStream.peek() + 4 <= dataInputStream.mLength) {
        long nextIfdOffset = dataInputStream.readUnsignedInt();
        if (DEBUG) {
            Log.d(TAG, String.format("nextIfdOffset: %d", nextIfdOffset));
        }
        // since the first IFD offset is at least 8.
        if (nextIfdOffset > 8 && nextIfdOffset < dataInputStream.mLength) {
            dataInputStream.seek(nextIfdOffset);
            readImageFileDirectory(dataInputStream, IFD_THUMBNAIL_HINT);
        }
    }
}
#method_after
private void readImageFileDirectory(ByteOrderAwarenessDataInputStream dataInputStream, int hint) throws IOException {
    if (dataInputStream.peek() + 2 > dataInputStream.mLength) {
        // Return if there is no data from the offset.
        return;
    }
    // See JEITA CP-3451 Figure 5. page 9.
    short numberOfDirectoryEntry = dataInputStream.readShort();
    if (dataInputStream.peek() + 12 * numberOfDirectoryEntry > dataInputStream.mLength) {
        // Return if the size of entries is too big.
        return;
    }
    if (DEBUG) {
        Log.d(TAG, "numberOfDirectoryEntry: " + numberOfDirectoryEntry);
    }
    for (short i = 0; i < numberOfDirectoryEntry; ++i) {
        int tagNumber = dataInputStream.readUnsignedShort();
        int dataFormat = dataInputStream.readUnsignedShort();
        int numberOfComponents = dataInputStream.readInt();
        // next four bytes is for data
        long nextEntryOffset = dataInputStream.peek() + 4;
        // offset or value.
        // Look up a corresponding tag from tag number
        final ExifTag tag = (ExifTag) sExifTagMapsForReading[hint].get(tagNumber);
        if (DEBUG) {
            Log.d(TAG, String.format("hint: %d, tagNumber: %d, tagName: %s, dataFormat: %d, " + "numberOfComponents: %d", hint, tagNumber, tag != null ? tag.name : null, dataFormat, numberOfComponents));
        }
        long byteCount = 0;
        boolean valid = false;
        if (tag == null) {
            Log.w(TAG, "Skip the tag entry since tag number is not defined: " + tagNumber);
        } else if (dataFormat <= 0 || dataFormat >= IFD_FORMAT_BYTES_PER_FORMAT.length) {
            Log.w(TAG, "Skip the tag entry since data format is invalid: " + dataFormat);
        } else {
            byteCount = (long) numberOfComponents * IFD_FORMAT_BYTES_PER_FORMAT[dataFormat];
            if (byteCount < 0 || byteCount > Integer.MAX_VALUE) {
                Log.w(TAG, "Skip the tag entry since number of components is invalid: " + numberOfComponents);
            } else {
                valid = true;
            }
        }
        if (!valid) {
            dataInputStream.seek(nextEntryOffset);
            continue;
        }
        // field if the size of the entry value is bigger than 4.
        if (byteCount > 4) {
            long offset = dataInputStream.readUnsignedInt();
            if (DEBUG) {
                Log.d(TAG, "seek to data offset: " + offset);
            }
            if (offset + byteCount <= dataInputStream.mLength) {
                dataInputStream.seek(offset);
            } else {
                // Skip if invalid data offset.
                Log.w(TAG, "Skip the tag entry since data offset is invalid: " + offset);
                dataInputStream.seek(nextEntryOffset);
                continue;
            }
        }
        // Recursively parse IFD when a IFD pointer tag appears.
        int innerIfdHint = getIfdHintFromTagNumber(tagNumber);
        if (DEBUG) {
            Log.d(TAG, "innerIfdHint: " + innerIfdHint + " byteCount: " + byteCount);
        }
        if (innerIfdHint >= 0) {
            long offset = -1L;
            // Get offset from data field
            switch(dataFormat) {
                case IFD_FORMAT_USHORT:
                    {
                        offset = dataInputStream.readUnsignedShort();
                        break;
                    }
                case IFD_FORMAT_SSHORT:
                    {
                        offset = dataInputStream.readShort();
                        break;
                    }
                case IFD_FORMAT_ULONG:
                    {
                        offset = dataInputStream.readUnsignedInt();
                        break;
                    }
                case IFD_FORMAT_SLONG:
                    {
                        offset = dataInputStream.readInt();
                        break;
                    }
                default:
                    {
                        // Nothing to do
                        break;
                    }
            }
            if (DEBUG) {
                Log.d(TAG, String.format("Offset: %d, tagName: %s", offset, tag.name));
            }
            if (offset > 0L && offset < dataInputStream.mLength) {
                dataInputStream.seek(offset);
                readImageFileDirectory(dataInputStream, innerIfdHint);
            } else {
                Log.w(TAG, "Skip jump into the IFD since its offset is invalid: " + offset);
            }
            dataInputStream.seek(nextEntryOffset);
            continue;
        }
        byte[] bytes = new byte[numberOfComponents * IFD_FORMAT_BYTES_PER_FORMAT[dataFormat]];
        dataInputStream.readFully(bytes);
        mAttributes[hint].put(tag.name, new ExifAttribute(dataFormat, numberOfComponents, bytes));
        if (dataInputStream.peek() != nextEntryOffset) {
            dataInputStream.seek(nextEntryOffset);
        }
    }
    if (dataInputStream.peek() + 4 <= dataInputStream.mLength) {
        long nextIfdOffset = dataInputStream.readUnsignedInt();
        if (DEBUG) {
            Log.d(TAG, String.format("nextIfdOffset: %d", nextIfdOffset));
        }
        // since the first IFD offset is at least 8.
        if (nextIfdOffset > 8 && nextIfdOffset < dataInputStream.mLength) {
            dataInputStream.seek(nextIfdOffset);
            readImageFileDirectory(dataInputStream, IFD_THUMBNAIL_HINT);
        }
    }
}
#end_block

#method_before
public ApkSigner build() {
    return new ApkSigner(mSignerConfigs, mMinSdkVersion, mV1SigningEnabled, mV2SigningEnabled, mOtherSignersSignaturesPreserved, mCreatedBy, mSignerEngine, mInputApkFile, mInputApkDataSource, mOutputApkFile, mOutputApkDataSink, mOutputApkDataSource);
}
#method_after
public SignerConfig build() {
    return new SignerConfig(mName, mPrivateKey, mCertificates);
}
#end_block

#method_before
private void test_block_filtersAsExpected(InetAddress senderBindAddress, InetAddress receiverBindAddress, InetAddress groupAddress, NetworkInterface networkInterface) throws Exception {
    if (!supportsMulticast) {
        return;
    }
    DatagramChannel sendingChannel = DatagramChannel.open();
    // In order to block a sender the sender's address must be known. The sendingChannel is
    // explicitly bound to a known, non-loopback address.
    sendingChannel.bind(new InetSocketAddress(senderBindAddress, 0));
    InetSocketAddress sendingAddress = (InetSocketAddress) sendingChannel.getLocalAddress();
    DatagramChannel receivingChannel = DatagramChannel.open();
    configureChannelForReceiving(receivingChannel);
    receivingChannel.bind(new InetSocketAddress(receiverBindAddress, 0));
    InetSocketAddress localReceivingAddress = (InetSocketAddress) receivingChannel.getLocalAddress();
    InetSocketAddress groupSocketAddress = new InetSocketAddress(groupAddress, localReceivingAddress.getPort());
    MembershipKey membershipKey = receivingChannel.join(groupSocketAddress.getAddress(), networkInterface);
    ByteBuffer receiveBuffer = ByteBuffer.allocate(10);
    // Send a message. It should be received.
    String msg1 = "Hello1";
    sendMessage(sendingChannel, msg1, groupSocketAddress);
    InetSocketAddress sourceAddress1 = (InetSocketAddress) receivingChannel.receive(receiveBuffer);
    assertEquals(sourceAddress1, sendingAddress);
    assertEquals(msg1, new String(receiveBuffer.array(), 0, receiveBuffer.position()));
    // Now block the sender
    membershipKey.block(sendingAddress.getAddress());
    // Send a message. It should be filtered.
    String msg2 = "Hello2";
    sendMessage(sendingChannel, msg2, groupSocketAddress);
    receiveBuffer.position(0);
    InetSocketAddress sourceAddress2 = (InetSocketAddress) receivingChannel.receive(receiveBuffer);
    assertNull(sourceAddress2);
    // Now unblock the sender
    membershipKey.unblock(sendingAddress.getAddress());
    // Send a message. It should be received.
    String msg3 = "Hello3";
    sendMessage(sendingChannel, msg3, groupSocketAddress);
    receiveBuffer.position(0);
    InetSocketAddress sourceAddress3 = (InetSocketAddress) receivingChannel.receive(receiveBuffer);
    assertEquals(sourceAddress3, sendingAddress);
    assertEquals(msg3, new String(receiveBuffer.array(), 0, receiveBuffer.position()));
    sendingChannel.close();
    receivingChannel.close();
}
#method_after
private void test_block_filtersAsExpected(InetAddress senderBindAddress, InetAddress receiverBindAddress, InetAddress groupAddress, NetworkInterface networkInterface) throws Exception {
    if (!supportsMulticast) {
        return;
    }
    DatagramChannel sendingChannel = DatagramChannel.open();
    // In order to block a sender the sender's address must be known. The sendingChannel is
    // explicitly bound to a known, non-loopback address.
    sendingChannel.bind(new InetSocketAddress(senderBindAddress, 0));
    InetSocketAddress sendingAddress = (InetSocketAddress) sendingChannel.getLocalAddress();
    DatagramChannel receivingChannel = DatagramChannel.open();
    configureChannelForReceiving(receivingChannel);
    receivingChannel.bind(new InetSocketAddress(receiverBindAddress, 0));
    InetSocketAddress localReceivingAddress = (InetSocketAddress) receivingChannel.getLocalAddress();
    InetSocketAddress groupSocketAddress = new InetSocketAddress(groupAddress, localReceivingAddress.getPort());
    MembershipKey membershipKey = receivingChannel.join(groupSocketAddress.getAddress(), networkInterface);
    ByteBuffer receiveBuffer = ByteBuffer.allocate(10);
    // Send a message. It should be received.
    String msg1 = "Hello1";
    sendMessage(sendingChannel, msg1, groupSocketAddress);
    blockUntilAvailableOrTimeout(receivingChannel.socket(), 1000);
    InetSocketAddress sourceAddress1 = (InetSocketAddress) receivingChannel.receive(receiveBuffer);
    assertEquals(sourceAddress1, sendingAddress);
    assertEquals(msg1, new String(receiveBuffer.array(), 0, receiveBuffer.position()));
    // Now block the sender
    membershipKey.block(sendingAddress.getAddress());
    // Send a message. It should be filtered.
    String msg2 = "Hello2";
    sendMessage(sendingChannel, msg2, groupSocketAddress);
    blockUntilAvailableOrTimeout(receivingChannel.socket(), 1000);
    receiveBuffer.position(0);
    InetSocketAddress sourceAddress2 = (InetSocketAddress) receivingChannel.receive(receiveBuffer);
    assertNull(sourceAddress2);
    // Now unblock the sender
    membershipKey.unblock(sendingAddress.getAddress());
    // Send a message. It should be received.
    String msg3 = "Hello3";
    sendMessage(sendingChannel, msg3, groupSocketAddress);
    blockUntilAvailableOrTimeout(receivingChannel.socket(), 1000);
    receiveBuffer.position(0);
    InetSocketAddress sourceAddress3 = (InetSocketAddress) receivingChannel.receive(receiveBuffer);
    assertEquals(sourceAddress3, sendingAddress);
    assertEquals(msg3, new String(receiveBuffer.array(), 0, receiveBuffer.position()));
    sendingChannel.close();
    receivingChannel.close();
}
#end_block

#method_before
private static void sendMessage(DatagramChannel sendingChannel, String msg, InetSocketAddress targetAddress) throws IOException {
    ByteBuffer sendBuffer = ByteBuffer.wrap(msg.getBytes());
    sendingChannel.send(sendBuffer, targetAddress);
    // Wait for a short period to leave time for the packet to be delivered.
    try {
        Thread.sleep(100);
    } catch (InterruptedException ignored) {
    }
}
#method_after
private static void sendMessage(DatagramChannel sendingChannel, String msg, InetSocketAddress targetAddress) throws IOException {
    ByteBuffer sendBuffer = ByteBuffer.wrap(msg.getBytes());
    sendingChannel.send(sendBuffer, targetAddress);
}
#end_block

#method_before
public boolean installCertsAndKeys() {
    // Install CA certificate.
    if (mConfig.credential.caCertificate != null) {
        String alias = formatAliasName(Credentials.CA_CERTIFICATE, mUid);
        if (!mKeyStore.putCertInKeyStore(alias, mConfig.credential.caCertificate)) {
            Log.e(TAG, "Failed to install CA Certificate");
            uninstallCertsAndKeys();
            return false;
        }
        mCaCertificateAlias = alias;
    }
    // Install the client private key.
    if (mConfig.credential.clientPrivateKey != null) {
        String alias = formatAliasName(Credentials.USER_PRIVATE_KEY, mUid);
        if (!mKeyStore.putKeyInKeyStore(alias, mConfig.credential.clientPrivateKey)) {
            Log.e(TAG, "Failed to install client private key");
            uninstallCertsAndKeys();
            return false;
        }
        mClientPrivateKeyAlias = alias;
    }
    // Install the client certificate.
    if (mConfig.credential.clientCertificateChain != null) {
        X509Certificate clientCert = getClientCertificate(mConfig.credential.clientCertificateChain, mConfig.credential.certCredential.certSha256FingerPrint);
        if (clientCert == null) {
            Log.e(TAG, "Failed to locate client certificate");
            uninstallCertsAndKeys();
            return false;
        }
        String alias = formatAliasName(Credentials.USER_CERTIFICATE, mUid);
        if (!mKeyStore.putCertInKeyStore(alias, clientCert)) {
            Log.e(TAG, "Failed to install client certificate");
            uninstallCertsAndKeys();
            return false;
        }
        mClientCertificateAlias = alias;
    }
    // Clear the keys and certificates in the configuration.
    mConfig.credential.caCertificate = null;
    mConfig.credential.clientPrivateKey = null;
    mConfig.credential.clientCertificateChain = null;
    return true;
}
#method_after
public boolean installCertsAndKeys() {
    // Install CA certificate.
    if (mConfig.credential.caCertificate != null) {
        String alias = formatAliasName(Credentials.CA_CERTIFICATE, mProviderId);
        if (!mKeyStore.putCertInKeyStore(alias, mConfig.credential.caCertificate)) {
            Log.e(TAG, "Failed to install CA Certificate");
            uninstallCertsAndKeys();
            return false;
        }
        mCaCertificateAlias = alias;
    }
    // Install the client private key.
    if (mConfig.credential.clientPrivateKey != null) {
        String alias = formatAliasName(Credentials.USER_PRIVATE_KEY, mProviderId);
        if (!mKeyStore.putKeyInKeyStore(alias, mConfig.credential.clientPrivateKey)) {
            Log.e(TAG, "Failed to install client private key");
            uninstallCertsAndKeys();
            return false;
        }
        mClientPrivateKeyAlias = alias;
    }
    // Install the client certificate.
    if (mConfig.credential.clientCertificateChain != null) {
        X509Certificate clientCert = getClientCertificate(mConfig.credential.clientCertificateChain, mConfig.credential.certCredential.certSha256FingerPrint);
        if (clientCert == null) {
            Log.e(TAG, "Failed to locate client certificate");
            uninstallCertsAndKeys();
            return false;
        }
        String alias = formatAliasName(Credentials.USER_CERTIFICATE, mProviderId);
        if (!mKeyStore.putCertInKeyStore(alias, clientCert)) {
            Log.e(TAG, "Failed to install client certificate");
            uninstallCertsAndKeys();
            return false;
        }
        mClientCertificateAlias = alias;
    }
    // Clear the keys and certificates in the configuration.
    mConfig.credential.caCertificate = null;
    mConfig.credential.clientPrivateKey = null;
    mConfig.credential.clientCertificateChain = null;
    return true;
}
#end_block

#method_before
public boolean addProvider(PasspointConfiguration config) {
    if (config == null) {
        Log.e(TAG, "Configuration not provided");
        return false;
    }
    if (!config.validate()) {
        Log.e(TAG, "Invalid configuration");
        return false;
    }
    // Verify IMSI against the IMSI of the installed SIM cards for SIM credential.
    if (config.credential.simCredential != null) {
        try {
            if (mSimAccessor.getMatchingImsis(new IMSIParameter(config.credential.simCredential.imsi)) == null) {
                Log.e(TAG, "IMSI does not match any SIM card");
                return false;
            }
        } catch (IOException e) {
            return false;
        }
    }
    // Create a provider and install the necessary certificates and keys.
    PasspointProvider newProvider = mWifiInjector.makePasspointProvider(config);
    if (!newProvider.installCertsAndKeys()) {
        Log.e(TAG, "Failed to install certificates and keys to keystore");
        return false;
    }
    // Detect existing configuration in the same base domain.
    PasspointProvider existingProvider = findProviderInSameBaseDomain(config.homeSp.fqdn);
    if (existingProvider != null) {
        Log.d(TAG, "Replacing configuration for " + existingProvider.getConfig().homeSp.fqdn + " with " + config.homeSp.fqdn);
        existingProvider.uninstallCertsAndKeys();
        mProviders.remove(existingProvider.getConfig().homeSp.fqdn);
    }
    mProviders.put(config.homeSp.fqdn, newProvider);
    return true;
}
#method_after
public boolean addProvider(PasspointConfiguration config) {
    if (config == null) {
        Log.e(TAG, "Configuration not provided");
        return false;
    }
    if (!config.validate()) {
        Log.e(TAG, "Invalid configuration");
        return false;
    }
    // Verify IMSI against the IMSI of the installed SIM cards for SIM credential.
    if (config.credential.simCredential != null) {
        try {
            if (mSimAccessor.getMatchingImsis(new IMSIParameter(config.credential.simCredential.imsi)) == null) {
                Log.e(TAG, "IMSI does not match any SIM card");
                return false;
            }
        } catch (IOException e) {
            return false;
        }
    }
    // Create a provider and install the necessary certificates and keys.
    PasspointProvider newProvider = mObjectFactory.makePasspointProvider(config, mKeyStore, mClock.getWallClockMillis());
    if (!newProvider.installCertsAndKeys()) {
        Log.e(TAG, "Failed to install certificates and keys to keystore");
        return false;
    }
    // Detect existing configuration in the same base domain.
    PasspointProvider existingProvider = findProviderInSameBaseDomain(config.homeSp.fqdn);
    if (existingProvider != null) {
        Log.d(TAG, "Replacing configuration for " + existingProvider.getConfig().homeSp.fqdn + " with " + config.homeSp.fqdn);
        existingProvider.uninstallCertsAndKeys();
        mProviders.remove(existingProvider.getConfig().homeSp.fqdn);
    }
    mProviders.put(config.homeSp.fqdn, newProvider);
    return true;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    initMocks(this);
    mManager = new PasspointManager(mContext, mWifiInjector, mSimAccessor);
    ArgumentCaptor<PasspointEventHandler.Callbacks> callbacks = ArgumentCaptor.forClass(PasspointEventHandler.Callbacks.class);
    verify(mWifiInjector).makePasspointEventHandler(callbacks.capture());
    mCallbacks = callbacks.getValue();
}
#method_after
@Before
public void setUp() throws Exception {
    initMocks(this);
    mManager = new PasspointManager(mContext, mWifiNative, mWifiKeyStore, mClock, mSimAccessor, mObjectFactory);
    ArgumentCaptor<PasspointEventHandler.Callbacks> callbacks = ArgumentCaptor.forClass(PasspointEventHandler.Callbacks.class);
    verify(mObjectFactory).makePasspointEventHandler(any(WifiNative.class), callbacks.capture());
    mCallbacks = callbacks.getValue();
}
#end_block

#method_before
@Test
public void addRemoveProviderWithValidUserCredential() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.caCertificate = FakeKeys.CA_CERT0;
    config.credential.userCredential = new Credential.UserCredential();
    config.credential.userCredential.username = "username";
    config.credential.userCredential.password = "password";
    config.credential.userCredential.eapType = EAPConstants.EAP_TTLS;
    config.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    PasspointProvider provider = createMockProvider(config);
    when(mWifiInjector.makePasspointProvider(config)).thenReturn(provider);
    assertTrue(mManager.addProvider(config));
    verifyInstalledConfig(config);
    // Remove the provider.
    assertTrue(mManager.removeProvider(TEST_FQDN));
    verify(provider).uninstallCertsAndKeys();
    assertEquals(null, mManager.getProviderConfigs());
}
#method_after
@Test
public void addRemoveProviderWithValidUserCredential() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.caCertificate = FakeKeys.CA_CERT0;
    config.credential.userCredential = new Credential.UserCredential();
    config.credential.userCredential.username = "username";
    config.credential.userCredential.password = "password";
    config.credential.userCredential.eapType = EAPConstants.EAP_TTLS;
    config.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    PasspointProvider provider = createMockProvider(config);
    when(mClock.getWallClockMillis()).thenReturn(PROVIDER_ID);
    when(mObjectFactory.makePasspointProvider(config, mWifiKeyStore, PROVIDER_ID)).thenReturn(provider);
    assertTrue(mManager.addProvider(config));
    verifyInstalledConfig(config);
    // Remove the provider.
    assertTrue(mManager.removeProvider(TEST_FQDN));
    verify(provider).uninstallCertsAndKeys();
    assertEquals(null, mManager.getProviderConfigs());
}
#end_block

#method_before
@Test
public void addRemoveProviderWithValidSimCredential() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.simCredential = new Credential.SimCredential();
    config.credential.simCredential.imsi = TEST_IMSI;
    config.credential.simCredential.eapType = EAPConstants.EAP_SIM;
    when(mSimAccessor.getMatchingImsis(new IMSIParameter(TEST_IMSI))).thenReturn(new ArrayList<String>());
    PasspointProvider provider = createMockProvider(config);
    when(mWifiInjector.makePasspointProvider(config)).thenReturn(provider);
    assertTrue(mManager.addProvider(config));
    verifyInstalledConfig(config);
    // Remove the provider.
    assertTrue(mManager.removeProvider(TEST_FQDN));
    verify(provider).uninstallCertsAndKeys();
    assertEquals(null, mManager.getProviderConfigs());
}
#method_after
@Test
public void addRemoveProviderWithValidSimCredential() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.simCredential = new Credential.SimCredential();
    config.credential.simCredential.imsi = TEST_IMSI;
    config.credential.simCredential.eapType = EAPConstants.EAP_SIM;
    when(mSimAccessor.getMatchingImsis(new IMSIParameter(TEST_IMSI))).thenReturn(new ArrayList<String>());
    PasspointProvider provider = createMockProvider(config);
    when(mClock.getWallClockMillis()).thenReturn(PROVIDER_ID);
    when(mObjectFactory.makePasspointProvider(config, mWifiKeyStore, PROVIDER_ID)).thenReturn(provider);
    assertTrue(mManager.addProvider(config));
    verifyInstalledConfig(config);
    // Remove the provider.
    assertTrue(mManager.removeProvider(TEST_FQDN));
    verify(provider).uninstallCertsAndKeys();
    assertEquals(null, mManager.getProviderConfigs());
}
#end_block

#method_before
@Test
public void addProviderWithExistingConfig() throws Exception {
    // Add a provider with the original configuration.
    PasspointConfiguration origConfig = new PasspointConfiguration();
    origConfig.homeSp = new HomeSP();
    origConfig.homeSp.fqdn = TEST_FQDN;
    origConfig.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    origConfig.credential = new Credential();
    origConfig.credential.realm = TEST_REALM;
    origConfig.credential.simCredential = new Credential.SimCredential();
    origConfig.credential.simCredential.imsi = TEST_IMSI;
    origConfig.credential.simCredential.eapType = EAPConstants.EAP_SIM;
    when(mSimAccessor.getMatchingImsis(new IMSIParameter(TEST_IMSI))).thenReturn(new ArrayList<String>());
    PasspointProvider origProvider = createMockProvider(origConfig);
    when(mWifiInjector.makePasspointProvider(origConfig)).thenReturn(origProvider);
    assertTrue(mManager.addProvider(origConfig));
    verifyInstalledConfig(origConfig);
    // Add another provider with the same base domain as the existing provider.
    // This should replace the existing provider with the new configuration.
    PasspointConfiguration newConfig = new PasspointConfiguration();
    newConfig.homeSp = new HomeSP();
    newConfig.homeSp.fqdn = TEST_FQDN1;
    newConfig.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    newConfig.credential = new Credential();
    newConfig.credential.realm = TEST_REALM;
    newConfig.credential.caCertificate = FakeKeys.CA_CERT0;
    newConfig.credential.userCredential = new Credential.UserCredential();
    newConfig.credential.userCredential.username = "username";
    newConfig.credential.userCredential.password = "password";
    newConfig.credential.userCredential.eapType = EAPConstants.EAP_TTLS;
    newConfig.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    PasspointProvider newProvider = createMockProvider(newConfig);
    when(mWifiInjector.makePasspointProvider(newConfig)).thenReturn(newProvider);
    assertTrue(mManager.addProvider(newConfig));
    verifyInstalledConfig(newConfig);
}
#method_after
@Test
public void addProviderWithExistingConfig() throws Exception {
    // Add a provider with the original configuration.
    PasspointConfiguration origConfig = new PasspointConfiguration();
    origConfig.homeSp = new HomeSP();
    origConfig.homeSp.fqdn = TEST_FQDN;
    origConfig.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    origConfig.credential = new Credential();
    origConfig.credential.realm = TEST_REALM;
    origConfig.credential.simCredential = new Credential.SimCredential();
    origConfig.credential.simCredential.imsi = TEST_IMSI;
    origConfig.credential.simCredential.eapType = EAPConstants.EAP_SIM;
    when(mSimAccessor.getMatchingImsis(new IMSIParameter(TEST_IMSI))).thenReturn(new ArrayList<String>());
    PasspointProvider origProvider = createMockProvider(origConfig);
    when(mClock.getWallClockMillis()).thenReturn(PROVIDER_ID);
    when(mObjectFactory.makePasspointProvider(origConfig, mWifiKeyStore, PROVIDER_ID)).thenReturn(origProvider);
    assertTrue(mManager.addProvider(origConfig));
    verifyInstalledConfig(origConfig);
    // Add another provider with the same base domain as the existing provider.
    // This should replace the existing provider with the new configuration.
    PasspointConfiguration newConfig = new PasspointConfiguration();
    newConfig.homeSp = new HomeSP();
    newConfig.homeSp.fqdn = TEST_FQDN1;
    newConfig.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    newConfig.credential = new Credential();
    newConfig.credential.realm = TEST_REALM;
    newConfig.credential.caCertificate = FakeKeys.CA_CERT0;
    newConfig.credential.userCredential = new Credential.UserCredential();
    newConfig.credential.userCredential.username = "username";
    newConfig.credential.userCredential.password = "password";
    newConfig.credential.userCredential.eapType = EAPConstants.EAP_TTLS;
    newConfig.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    PasspointProvider newProvider = createMockProvider(newConfig);
    when(mClock.getWallClockMillis()).thenReturn(PROVIDER_ID);
    when(mObjectFactory.makePasspointProvider(newConfig, mWifiKeyStore, PROVIDER_ID)).thenReturn(newProvider);
    assertTrue(mManager.addProvider(newConfig));
    verifyInstalledConfig(newConfig);
}
#end_block

#method_before
@Test
public void addProviderOnKeyInstallationFailiure() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.caCertificate = FakeKeys.CA_CERT0;
    config.credential.userCredential = new Credential.UserCredential();
    config.credential.userCredential.username = "username";
    config.credential.userCredential.password = "password";
    config.credential.userCredential.eapType = EAPConstants.EAP_TTLS;
    config.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    PasspointProvider provider = mock(PasspointProvider.class);
    when(provider.installCertsAndKeys()).thenReturn(false);
    when(mWifiInjector.makePasspointProvider(config)).thenReturn(provider);
    assertFalse(mManager.addProvider(config));
}
#method_after
@Test
public void addProviderOnKeyInstallationFailiure() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.caCertificate = FakeKeys.CA_CERT0;
    config.credential.userCredential = new Credential.UserCredential();
    config.credential.userCredential.username = "username";
    config.credential.userCredential.password = "password";
    config.credential.userCredential.eapType = EAPConstants.EAP_TTLS;
    config.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    PasspointProvider provider = mock(PasspointProvider.class);
    when(provider.installCertsAndKeys()).thenReturn(false);
    when(mClock.getWallClockMillis()).thenReturn(PROVIDER_ID);
    when(mObjectFactory.makePasspointProvider(config, mWifiKeyStore, PROVIDER_ID)).thenReturn(provider);
    assertFalse(mManager.addProvider(config));
}
#end_block

#method_before
private PasspointProvider createProvider(PasspointConfiguration config) {
    return new PasspointProvider(config, mKeyStore, UID);
}
#method_after
private PasspointProvider createProvider(PasspointConfiguration config) {
    return new PasspointProvider(config, mKeyStore, PROVIDER_ID);
}
#end_block

#method_before
public static void setSSLParameters(SSLParameters params, SSLParametersImpl impl, OpenSSLSocketImpl socket) {
    try {
        Method m_getEndpointIdentificationAlgorithm = params.getClass().getMethod("getEndpointIdentificationAlgorithm");
        impl.setEndpointIdentificationAlgorithm((String) m_getEndpointIdentificationAlgorithm.invoke(params));
        Method m_getUseCipherSuitesOrder = params.getClass().getMethod("getUseCipherSuitesOrder");
        impl.setUseCipherSuitesOrder((boolean) m_getUseCipherSuitesOrder.invoke(params));
        Method m_getServerNames = params.getClass().getMethod("getServerNames");
        @SuppressWarnings("unchecked")
        List<SNIServerName> serverNames = (List<SNIServerName>) m_getServerNames.invoke(params);
        if (serverNames != null) {
            for (SNIServerName serverName : serverNames) {
                if (serverName.getType() == StandardConstants.SNI_HOST_NAME) {
                    socket.setHostname(((SNIHostName) serverName).getAsciiName());
                    break;
                }
            }
        }
    } catch (NoSuchMethodException ignored) {
    } catch (IllegalAccessException ignored) {
    } catch (InvocationTargetException e) {
        throw new RuntimeException(e.getCause());
    }
}
#method_after
public static void setSSLParameters(SSLParameters params, SSLParametersImpl impl, OpenSSLSocketImpl socket) {
    try {
        Method m_getEndpointIdentificationAlgorithm = params.getClass().getMethod("getEndpointIdentificationAlgorithm");
        impl.setEndpointIdentificationAlgorithm((String) m_getEndpointIdentificationAlgorithm.invoke(params));
        Method m_getUseCipherSuitesOrder = params.getClass().getMethod("getUseCipherSuitesOrder");
        impl.setUseCipherSuitesOrder((boolean) m_getUseCipherSuitesOrder.invoke(params));
        Method m_getServerNames = params.getClass().getMethod("getServerNames");
        @SuppressWarnings("unchecked")
        List<SNIServerName> serverNames = (List<SNIServerName>) m_getServerNames.invoke(params);
        if (serverNames != null) {
            for (SNIServerName serverName : serverNames) {
                if (serverName.getType() == StandardConstants.SNI_HOST_NAME) {
                    socket.setHostname(((SNIHostName) serverName).getAsciiName());
                    break;
                }
            }
        }
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        throw new RuntimeException(e.getCause());
    }
}
#end_block

#method_before
public static void getSSLParameters(SSLParameters params, SSLParametersImpl impl, OpenSSLSocketImpl socket) {
    try {
        Method m_setEndpointIdentificationAlgorithm = params.getClass().getMethod("setEndpointIdentificationAlgorithm", String.class);
        m_setEndpointIdentificationAlgorithm.invoke(params, impl.getEndpointIdentificationAlgorithm());
        Method m_setUseCipherSuitesOrder = params.getClass().getMethod("setUseCipherSuitesOrder", boolean.class);
        m_setUseCipherSuitesOrder.invoke(params, impl.getUseCipherSuitesOrder());
        if (impl.getUseSni() && AddressUtils.isValidSniHostname(socket.getHostname())) {
            Method m_setServerNames = params.getClass().getMethod("setServerNames", List.class);
            m_setServerNames.invoke(params, Collections.<SNIServerName>singletonList(new SNIHostName(socket.getHostname())));
        }
    } catch (NoSuchMethodException ignored) {
    } catch (IllegalAccessException ignored) {
    } catch (InvocationTargetException e) {
        throw new RuntimeException(e.getCause());
    }
}
#method_after
public static void getSSLParameters(SSLParameters params, SSLParametersImpl impl, OpenSSLSocketImpl socket) {
    try {
        Method m_setEndpointIdentificationAlgorithm = params.getClass().getMethod("setEndpointIdentificationAlgorithm", String.class);
        m_setEndpointIdentificationAlgorithm.invoke(params, impl.getEndpointIdentificationAlgorithm());
        Method m_setUseCipherSuitesOrder = params.getClass().getMethod("setUseCipherSuitesOrder", boolean.class);
        m_setUseCipherSuitesOrder.invoke(params, impl.getUseCipherSuitesOrder());
        if (impl.getUseSni() && AddressUtils.isValidSniHostname(socket.getHostname())) {
            Method m_setServerNames = params.getClass().getMethod("setServerNames", List.class);
            m_setServerNames.invoke(params, Collections.<SNIServerName>singletonList(new SNIHostName(socket.getHostname())));
        }
    } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
        throw new RuntimeException(e.getCause());
    }
}
#end_block

#method_before
private static boolean checkTrusted(String methodName, X509TrustManager tm, X509Certificate[] chain, String authType, Class<?> argumentClass, Object argumentInstance) throws CertificateException {
    // Use duck-typing to try and call the hostname-aware method if available.
    try {
        Method method = tm.getClass().getMethod(methodName, X509Certificate[].class, String.class, argumentClass);
        method.invoke(tm, chain, authType, argumentInstance);
        return true;
    } catch (NoSuchMethodException ignored) {
    } catch (IllegalAccessException ignored) {
    } catch (InvocationTargetException e) {
        if (e.getCause() instanceof CertificateException) {
            throw (CertificateException) e.getCause();
        }
        throw new RuntimeException(e.getCause());
    }
    return false;
}
#method_after
private static boolean checkTrusted(String methodName, X509TrustManager tm, X509Certificate[] chain, String authType, Class<?> argumentClass, Object argumentInstance) throws CertificateException {
    // Use duck-typing to try and call the hostname-aware method if available.
    try {
        Method method = tm.getClass().getMethod(methodName, X509Certificate[].class, String.class, argumentClass);
        method.invoke(tm, chain, authType, argumentInstance);
        return true;
    } catch (NoSuchMethodException | IllegalAccessException ignored) {
    } catch (InvocationTargetException e) {
        if (e.getCause() instanceof CertificateException) {
            throw (CertificateException) e.getCause();
        }
        throw new RuntimeException(e.getCause());
    }
    return false;
}
#end_block

#method_before
public static GCMParameters fromGCMParameterSpec(AlgorithmParameterSpec params) {
    Class<?> gcmSpecClass;
    try {
        gcmSpecClass = Class.forName("javax.crypto.spec.GCMParameterSpec");
    } catch (ClassNotFoundException e) {
        gcmSpecClass = null;
    }
    if (gcmSpecClass != null && gcmSpecClass.isAssignableFrom(params.getClass())) {
        try {
            int tLen;
            byte[] iv;
            Method getTLenMethod = gcmSpecClass.getMethod("getTLen");
            Method getIVMethod = gcmSpecClass.getMethod("getIV");
            tLen = (int) getTLenMethod.invoke(params);
            iv = (byte[]) getIVMethod.invoke(params);
            return new GCMParameters(tLen, iv);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("GCMParameterSpec lacks expected methods", e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException("GCMParameterSpec lacks expected methods", e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException("Could not fetch GCM parameters", e.getTargetException());
        }
    }
    return null;
}
#method_after
public static GCMParameters fromGCMParameterSpec(AlgorithmParameterSpec params) {
    Class<?> gcmSpecClass;
    try {
        gcmSpecClass = Class.forName("javax.crypto.spec.GCMParameterSpec");
    } catch (ClassNotFoundException e) {
        gcmSpecClass = null;
    }
    if (gcmSpecClass != null && gcmSpecClass.isAssignableFrom(params.getClass())) {
        try {
            int tLen;
            byte[] iv;
            Method getTLenMethod = gcmSpecClass.getMethod("getTLen");
            Method getIVMethod = gcmSpecClass.getMethod("getIV");
            tLen = (int) getTLenMethod.invoke(params);
            iv = (byte[]) getIVMethod.invoke(params);
            return new GCMParameters(tLen, iv);
        } catch (NoSuchMethodException | IllegalAccessException e) {
            throw new RuntimeException("GCMParameterSpec lacks expected methods", e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException("Could not fetch GCM parameters", e.getTargetException());
        }
    }
    return null;
}
#end_block

#method_before
public static AlgorithmParameterSpec toGCMParameterSpec(int tagLenInBits, byte[] iv) {
    Class<?> gcmSpecClass;
    try {
        gcmSpecClass = Class.forName("javax.crypto.spec.GCMParameterSpec");
    } catch (ClassNotFoundException e) {
        gcmSpecClass = null;
    }
    if (gcmSpecClass != null) {
        try {
            Constructor<?> constructor = gcmSpecClass.getConstructor(int.class, byte[].class);
            return (AlgorithmParameterSpec) constructor.newInstance(tagLenInBits, iv);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (IllegalArgumentException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.getCause().printStackTrace();
        }
    }
    return null;
}
#method_after
public static AlgorithmParameterSpec toGCMParameterSpec(int tagLenInBits, byte[] iv) {
    Class<?> gcmSpecClass;
    try {
        gcmSpecClass = Class.forName("javax.crypto.spec.GCMParameterSpec");
    } catch (ClassNotFoundException e) {
        gcmSpecClass = null;
    }
    if (gcmSpecClass != null) {
        try {
            Constructor<?> constructor = gcmSpecClass.getConstructor(int.class, byte[].class);
            return (AlgorithmParameterSpec) constructor.newInstance(tagLenInBits, iv);
        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | IllegalArgumentException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.getCause().printStackTrace();
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected void checkSupportedKeySize(int keyLength) throws InvalidKeyException {
    switch(keyLength) {
        // AES 128
        case 16:
        case // AES 256
        32:
            return;
        default:
            throw new InvalidKeyException("Unsupported key size: " + keyLength + " bytes (must be 16 or 32)");
    }
}
#method_after
@Override
protected void checkSupportedKeySize(int keyLength) throws InvalidKeyException {
    switch(keyLength) {
        // AES 128
        case 16:
        // AES 192
        case 24:
        case // AES 256
        32:
            return;
        default:
            throw new InvalidKeyException("Unsupported key size: " + keyLength + " bytes");
    }
}
#end_block

#method_before
@Override
public void onAdvertiserRegistered(int status, int advertiserId) {
    Log.d(TAG, "onAdvertiserRegistered() - status=" + status + " advertiserId=" + advertiserId);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mAdvertiserId == -2) {
                    // Registration succeeds after timeout, unregister advertiser.
                    mBluetoothGatt.unregisterAdvertiser(advertiserId);
                } else {
                    mAdvertiserId = advertiserId;
                    mBluetoothGatt.startMultiAdvertising(mAdvertiserId, mAdvertisement, mScanResponse, mSettings);
                }
                return;
            } catch (RemoteException e) {
                Log.e(TAG, "failed to start advertising", e);
            }
        }
        if (status == AdvertiseCallback.ADVERTISE_FAILED_TOO_MANY_ADVERTISERS) {
            registrationError = status;
        }
        // Registration failed.
        mAdvertiserId = -2;
        notifyAll();
    }
}
#method_after
@Override
public void onAdvertiserRegistered(int status, int advertiserId) {
    Log.d(TAG, "onAdvertiserRegistered() - status=" + status + " advertiserId=" + advertiserId);
    synchronized (this) {
        if (status == BluetoothGatt.GATT_SUCCESS) {
            try {
                if (mAdvertiserId == -2) {
                    // Registration succeeds after timeout, unregister advertiser.
                    mBluetoothGatt.unregisterAdvertiser(advertiserId);
                } else {
                    mAdvertiserId = advertiserId;
                    mBluetoothGatt.startMultiAdvertising(mAdvertiserId, mAdvertisement, mScanResponse, mSettings);
                }
                return;
            } catch (RemoteException e) {
                Log.e(TAG, "failed to start advertising", e);
            }
        } else if (status == AdvertiseCallback.ADVERTISE_FAILED_TOO_MANY_ADVERTISERS) {
            registrationError = status;
        }
        // Registration failed.
        mAdvertiserId = -2;
        notifyAll();
    }
}
#end_block

#method_before
private void write(ByteBuffer buffer) throws IOException {
    synchronized (stateLock) {
        try {
            init();
            // Need to loop through at least once to enable handshaking where no application bytes are
            // processed.
            int len = buffer.remaining();
            SSLEngineResult engineResult;
            do {
                target.clear();
                engineResult = engine.wrap(buffer, target);
                if (engineResult.getStatus() != OK) {
                    throw new SSLException("Unexpected engine result " + engineResult.getStatus());
                }
                if (target.position() != engineResult.bytesProduced()) {
                    throw new SSLException("Engine bytesProduced " + engineResult.bytesProduced() + " does not match bytes written " + target.position());
                }
                len -= engineResult.bytesConsumed();
                if (len != buffer.remaining()) {
                    throw new SSLException("Engine did not read the correct number of bytes");
                }
                target.flip();
                // Write the data to the socket.
                if (socketChannel != null) {
                    // so we won't really loop here.
                    while (target.hasRemaining()) {
                        socketChannel.write(target);
                    }
                } else {
                    // Target is a heap buffer.
                    socketOutputStream.write(target.array(), 0, target.position());
                }
                if (engineResult.getHandshakeStatus() == HandshakeStatus.FINISHED) {
                    completeHandshake();
                }
            } while (len > 0);
        } catch (IOException e) {
            e.printStackTrace();
            throw e;
        } catch (RuntimeException e) {
            e.printStackTrace();
            throw e;
        }
    }
}
#method_after
private void write(ByteBuffer buffer) throws IOException {
    synchronized (stateLock) {
        try {
            init();
            // Need to loop through at least once to enable handshaking where no application
            // bytes are
            // processed.
            int len = buffer.remaining();
            SSLEngineResult engineResult;
            do {
                target.clear();
                engineResult = engine.wrap(buffer, target);
                if (engineResult.getStatus() != OK) {
                    throw new SSLException("Unexpected engine result " + engineResult.getStatus());
                }
                if (target.position() != engineResult.bytesProduced()) {
                    throw new SSLException("Engine bytesProduced " + engineResult.bytesProduced() + " does not match bytes written " + target.position());
                }
                len -= engineResult.bytesConsumed();
                if (len != buffer.remaining()) {
                    throw new SSLException("Engine did not read the correct number of bytes");
                }
                target.flip();
                // Write the data to the socket.
                if (socketChannel != null) {
                    // so we won't really loop here.
                    while (target.hasRemaining()) {
                        socketChannel.write(target);
                    }
                } else {
                    // Target is a heap buffer.
                    socketOutputStream.write(target.array(), 0, target.position());
                }
                if (engineResult.getHandshakeStatus() == HandshakeStatus.FINISHED) {
                    completeHandshake();
                }
            } while (len > 0);
        } catch (IOException e) {
            e.printStackTrace();
            throw e;
        } catch (RuntimeException e) {
            e.printStackTrace();
            throw e;
        }
    }
}
#end_block

#method_before
@Override
public boolean isInboundDone() {
    if (sslNativePointer == 0) {
        synchronized (stateLock) {
            return engineState == EngineState.CLOSED || engineState == EngineState.CLOSED_INBOUND;
        }
    }
    return (NativeCrypto.SSL_get_shutdown(sslNativePointer) & NativeConstants.SSL_RECEIVED_SHUTDOWN) != 0;
}
#method_after
@Override
public boolean isInboundDone() {
    if (sslNativePointer == 0) {
        synchronized (stateLock) {
            return engineState == EngineState.CLOSED || engineState == EngineState.CLOSED_INBOUND;
        }
    }
    return (NativeCrypto.SSL_get_shutdown(sslNativePointer) & SSL_RECEIVED_SHUTDOWN) != 0;
}
#end_block

#method_before
@Override
public boolean isOutboundDone() {
    if (sslNativePointer == 0) {
        synchronized (stateLock) {
            return engineState == EngineState.CLOSED || engineState == EngineState.CLOSED_OUTBOUND;
        }
    }
    return (NativeCrypto.SSL_get_shutdown(sslNativePointer) & NativeConstants.SSL_SENT_SHUTDOWN) != 0;
}
#method_after
@Override
public boolean isOutboundDone() {
    if (sslNativePointer == 0) {
        synchronized (stateLock) {
            return engineState == EngineState.CLOSED || engineState == EngineState.CLOSED_OUTBOUND;
        }
    }
    return (NativeCrypto.SSL_get_shutdown(sslNativePointer) & SSL_SENT_SHUTDOWN) != 0;
}
#end_block

#method_before
public SSLEngineResult unwrap(final ByteBuffer[] srcs, final ByteBuffer[] dsts) throws SSLException {
    return unwrap(srcs, 0, srcs.length, dsts, 0, dsts.length);
}
#method_after
public SSLEngineResult unwrap(final ByteBuffer[] srcs, final ByteBuffer[] dsts) throws SSLException {
    checkNotNull(srcs, "srcs");
    checkNotNull(dsts, "dsts");
    return unwrap(srcs, 0, srcs.length, dsts, 0, dsts.length);
}
#end_block

#method_before
public SSLEngineResult unwrap(final ByteBuffer[] srcs, int srcsOffset, final int srcsLength, final ByteBuffer[] dsts, final int dstsOffset, final int dstsLength) throws SSLException {
    checkNotNull(srcs, "srcs");
    checkNotNull(dsts, "dsts");
    checkIndex(srcs.length, srcsOffset, srcsLength, "srcs");
    checkIndex(dsts.length, dstsOffset, dstsLength, "dsts");
    // Determine the output capacity.
    int capacity = 0;
    final int endOffset = dstsOffset + dstsLength;
    for (int i = 0; i < dsts.length; i++) {
        ByteBuffer dst = dsts[i];
        checkNotNull(dst, "one of the dst");
        if (dst.isReadOnly()) {
            throw new ReadOnlyBufferException();
        }
        if (i >= dstsOffset && i < dstsOffset + dstsLength) {
            capacity += dst.remaining();
        }
    }
    final int srcsEndOffset = srcsOffset + srcsLength;
    long len = 0;
    for (int i = srcsOffset; i < srcsEndOffset; i++) {
        ByteBuffer src = srcs[i];
        if (src == null) {
            throw new IllegalArgumentException("srcs[" + i + "] is null");
        }
        len += src.remaining();
    }
    // Protect against protocol overflow attack vector
    if (len > NativeConstants.SSL3_RT_MAX_PACKET_SIZE) {
        throw new SSLException("encrypted packet oversized");
    }
    synchronized (stateLock) {
        switch(engineState) {
            case MODE_SET:
                // Begin the handshake implicitly.
                beginHandshakeInternal();
                break;
            case CLOSED_INBOUND:
            case CLOSED:
                // If the inbound direction is closed. we can't send anymore.
                return new SSLEngineResult(Status.CLOSED, getHandshakeStatusInternal(), 0, 0);
            case NEW:
                throw new IllegalStateException("Client/server mode must be set before calling unwrap");
        }
        HandshakeStatus handshakeStatus = HandshakeStatus.NOT_HANDSHAKING;
        if (!handshakeFinished) {
            handshakeStatus = handshake();
            if (handshakeStatus == NEED_WRAP) {
                return NEED_WRAP_OK;
            }
            if (engineState == EngineState.CLOSED) {
                return NEED_WRAP_CLOSED;
            }
        // NEED_UNWRAP - just fall through to perform the unwrap.
        }
        if (len < SSLUtils.SSL_RECORD_HEADER_LENGTH) {
            return new SSLEngineResult(BUFFER_UNDERFLOW, getHandshakeStatus(), 0, 0);
        }
        int packetLength = SSLUtils.getEncryptedPacketLength(srcs, srcsOffset);
        if (packetLength - SSLUtils.SSL_RECORD_HEADER_LENGTH > capacity) {
            // that the buffer needs to be increased.
            return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);
        }
        if (len < packetLength) {
            // the whole packet.
            return new SSLEngineResult(BUFFER_UNDERFLOW, getHandshakeStatus(), 0, 0);
        }
        // Write all of the source data to the networkBio
        int bytesConsumed = 0;
        if (srcsOffset < srcsEndOffset) {
            int packetLengthRemaining = packetLength;
            do {
                ByteBuffer src = srcs[srcsOffset];
                int remaining = src.remaining();
                if (remaining == 0) {
                    // We must skip empty buffers as BIO_write will return 0 if asked to write something
                    // with length 0.
                    srcsOffset++;
                    continue;
                }
                // Write the source encrypted data to the networkBio.
                int written = writeEncryptedData(src, Math.min(packetLengthRemaining, src.remaining()));
                if (written > 0) {
                    packetLengthRemaining -= written;
                    if (packetLengthRemaining == 0) {
                        // A whole packet has been consumed.
                        break;
                    }
                    if (written == remaining) {
                        srcsOffset++;
                    } else {
                        // later.
                        break;
                    }
                } else {
                    // BIO_write returned a negative or zero number, this means we could not complete the write
                    // operation and should retry later.
                    // We ignore BIO_* errors here as we use in memory BIO anyway and will do another SSL_* call
                    // later on in which we will produce an exception in case of an error
                    NativeCrypto.SSL_clear_error();
                    break;
                }
            } while (srcsOffset < srcsEndOffset);
            bytesConsumed = packetLength - packetLengthRemaining;
        }
        // Now read any available plaintext data.
        int bytesProduced = 0;
        if (capacity > 0) {
            // Write decrypted data to dsts buffers
            for (int idx = dstsOffset; idx < endOffset; ++idx) {
                ByteBuffer dst = dsts[idx];
                if (!dst.hasRemaining()) {
                    continue;
                }
                int bytesRead = readPlaintextData(dst);
                if (bytesRead > 0) {
                    bytesProduced += bytesRead;
                    if (!dst.hasRemaining()) {
                        continue;
                    }
                    // We read everything return now.
                    return newResult(bytesConsumed, bytesProduced, handshakeStatus);
                }
                // Return an appropriate result based on the error code.
                int sslError = NativeCrypto.SSL_get_error(sslNativePointer, bytesRead);
                switch(sslError) {
                    case NativeConstants.SSL_ERROR_ZERO_RETURN:
                        // This means the connection was shutdown correctly, close inbound and outbound
                        closeAll();
                    // fall-trough!
                    case NativeConstants.SSL_ERROR_WANT_READ:
                    case NativeConstants.SSL_ERROR_WANT_WRITE:
                        return newResult(bytesConsumed, bytesProduced, handshakeStatus);
                    default:
                        return sslReadErrorResult(NativeCrypto.SSL_get_last_error_number(), bytesConsumed, bytesProduced);
                }
            }
        } else {
            // pendingInboundCleartextBytes() call.
            try {
                if (NativeCrypto.ENGINE_SSL_read_direct(sslNativePointer, EMPTY_ADDR, 0, this) <= 0) {
                    // We do not check SSL_get_error as we are not interested in any error that is not fatal.
                    int err = NativeCrypto.SSL_get_last_error_number();
                    if (err != NativeConstants.SSL_ERROR_NONE) {
                        return sslReadErrorResult(err, bytesConsumed, bytesProduced);
                    }
                }
            } catch (IOException e) {
                throw new SSLException(e);
            }
        }
        if (pendingInboundCleartextBytes(handshakeStatus) > 0) {
            // We filled all buffers but there is still some data pending in the BIO buffer, return BUFFER_OVERFLOW.
            return new SSLEngineResult(BUFFER_OVERFLOW, mayFinishHandshake(handshakeStatus == FINISHED ? handshakeStatus : getHandshakeStatusInternal()), bytesConsumed, bytesProduced);
        }
        return newResult(bytesConsumed, bytesProduced, handshakeStatus);
    }
}
#method_after
public SSLEngineResult unwrap(final ByteBuffer[] srcs, int srcsOffset, final int srcsLength, final ByteBuffer[] dsts, final int dstsOffset, final int dstsLength) throws SSLException {
    checkNotNull(srcs, "srcs");
    checkNotNull(dsts, "dsts");
    checkIndex(srcs.length, srcsOffset, srcsLength, "srcs");
    checkIndex(dsts.length, dstsOffset, dstsLength, "dsts");
    // Determine the output capacity.
    int capacity = 0;
    final int endOffset = dstsOffset + dstsLength;
    for (int i = 0; i < dsts.length; i++) {
        ByteBuffer dst = dsts[i];
        checkNotNull(dst, "one of the dst");
        if (dst.isReadOnly()) {
            throw new ReadOnlyBufferException();
        }
        if (i >= dstsOffset && i < dstsOffset + dstsLength) {
            capacity += dst.remaining();
        }
    }
    final int srcsEndOffset = srcsOffset + srcsLength;
    long len = 0;
    for (int i = srcsOffset; i < srcsEndOffset; i++) {
        ByteBuffer src = srcs[i];
        if (src == null) {
            throw new IllegalArgumentException("srcs[" + i + "] is null");
        }
        len += src.remaining();
    }
    // Protect against protocol overflow attack vector
    if (len > SSL3_RT_MAX_PACKET_SIZE) {
        throw new SSLException("encrypted packet oversized");
    }
    synchronized (stateLock) {
        switch(engineState) {
            case MODE_SET:
                // Begin the handshake implicitly.
                beginHandshakeInternal();
                break;
            case CLOSED_INBOUND:
            case CLOSED:
                // If the inbound direction is closed. we can't send anymore.
                return new SSLEngineResult(Status.CLOSED, getHandshakeStatusInternal(), 0, 0);
            case NEW:
                throw new IllegalStateException("Client/server mode must be set before calling unwrap");
        }
        HandshakeStatus handshakeStatus = HandshakeStatus.NOT_HANDSHAKING;
        if (!handshakeFinished) {
            handshakeStatus = handshake();
            if (handshakeStatus == NEED_WRAP) {
                return NEED_WRAP_OK;
            }
            if (engineState == EngineState.CLOSED) {
                return NEED_WRAP_CLOSED;
            }
        // NEED_UNWRAP - just fall through to perform the unwrap.
        }
        if (len < SSL3_RT_HEADER_LENGTH) {
            return new SSLEngineResult(BUFFER_UNDERFLOW, getHandshakeStatus(), 0, 0);
        }
        int packetLength = SSLUtils.getEncryptedPacketLength(srcs, srcsOffset);
        if (packetLength < 0) {
            throw new SSLException("Unable to parse TLS packet header");
        }
        if (packetLength - SSL3_RT_HEADER_LENGTH > capacity) {
            // that the buffer needs to be increased.
            return new SSLEngineResult(BUFFER_OVERFLOW, getHandshakeStatus(), 0, 0);
        }
        if (len < packetLength) {
            // the whole packet.
            return new SSLEngineResult(BUFFER_UNDERFLOW, getHandshakeStatus(), 0, 0);
        }
        // Write all of the source data to the networkBio
        int bytesConsumed = 0;
        if (srcsOffset < srcsEndOffset) {
            int packetLengthRemaining = packetLength;
            do {
                ByteBuffer src = srcs[srcsOffset];
                int remaining = src.remaining();
                if (remaining == 0) {
                    // We must skip empty buffers as BIO_write will return 0 if asked to write
                    // something
                    // with length 0.
                    srcsOffset++;
                    continue;
                }
                // Write the source encrypted data to the networkBio.
                int written = writeEncryptedData(src, Math.min(packetLengthRemaining, remaining));
                if (written > 0) {
                    packetLengthRemaining -= written;
                    if (packetLengthRemaining == 0) {
                        // A whole packet has been consumed.
                        break;
                    }
                    if (written == remaining) {
                        srcsOffset++;
                    } else {
                        // later.
                        break;
                    }
                } else {
                    // BIO_write returned a negative or zero number, this means we could not
                    // complete the write
                    // operation and should retry later.
                    // We ignore BIO_* errors here as we use in memory BIO anyway and will do
                    // another SSL_* call
                    // later on in which we will produce an exception in case of an error
                    NativeCrypto.SSL_clear_error();
                    break;
                }
            } while (srcsOffset < srcsEndOffset);
            bytesConsumed = packetLength - packetLengthRemaining;
        }
        // Now read any available plaintext data.
        int bytesProduced = 0;
        if (capacity > 0) {
            // Write decrypted data to dsts buffers
            for (int idx = dstsOffset; idx < endOffset; ++idx) {
                ByteBuffer dst = dsts[idx];
                if (!dst.hasRemaining()) {
                    continue;
                }
                int bytesRead = readPlaintextData(dst);
                if (bytesRead > 0) {
                    bytesProduced += bytesRead;
                    if (!dst.hasRemaining()) {
                        continue;
                    }
                    // We read everything return now.
                    return newResult(bytesConsumed, bytesProduced, handshakeStatus);
                }
                // Return an appropriate result based on the error code.
                int sslError = NativeCrypto.SSL_get_error(sslNativePointer, bytesRead);
                switch(sslError) {
                    case SSL_ERROR_ZERO_RETURN:
                        // This means the connection was shutdown correctly, close inbound and
                        // outbound
                        closeAll();
                    // fall-trough!
                    case SSL_ERROR_WANT_READ:
                    case SSL_ERROR_WANT_WRITE:
                        return newResult(bytesConsumed, bytesProduced, handshakeStatus);
                    default:
                        return sslReadErrorResult(NativeCrypto.SSL_get_last_error_number(), bytesConsumed, bytesProduced);
                }
            }
        } else {
            // pendingInboundCleartextBytes() call.
            try {
                if (NativeCrypto.ENGINE_SSL_read_direct(sslNativePointer, EMPTY_ADDR, 0, this) <= 0) {
                    // We do not check SSL_get_error as we are not interested in any error that
                    // is not fatal.
                    int err = NativeCrypto.SSL_get_last_error_number();
                    if (err != SSL_ERROR_NONE) {
                        return sslReadErrorResult(err, bytesConsumed, bytesProduced);
                    }
                }
            } catch (IOException e) {
                throw new SSLException(e);
            }
        }
        if (pendingInboundCleartextBytes(handshakeStatus) > 0) {
            // return BUFFER_OVERFLOW.
            return new SSLEngineResult(BUFFER_OVERFLOW, mayFinishHandshake(handshakeStatus == FINISHED ? handshakeStatus : getHandshakeStatusInternal()), bytesConsumed, bytesProduced);
        }
        return newResult(bytesConsumed, bytesProduced, handshakeStatus);
    }
}
#end_block

#method_before
private SSLEngineResult.HandshakeStatus handshake() throws SSLException {
    long sslSessionCtx = 0L;
    try {
        // Only actually perform the handshake if we haven't already just completed it
        // via BIO operations.
        int code = NativeCrypto.ENGINE_SSL_do_handshake(sslNativePointer, this);
        if (code <= 0) {
            int sslError = NativeCrypto.SSL_get_error(sslNativePointer, code);
            switch(sslError) {
                case NativeConstants.SSL_ERROR_WANT_READ:
                case NativeConstants.SSL_ERROR_WANT_WRITE:
                    return pendingStatus(pendingOutboundEncryptedBytes());
                default:
                    // Everything else is considered as error
                    throw shutdownWithError("SSL_do_handshake");
            }
        }
        // Handshake is finished!
        sslSessionCtx = NativeCrypto.SSL_get1_session(sslNativePointer);
        if (sslSessionCtx == 0) {
            // return pendingStatus(pendingOutboundBytes());
            throw shutdownWithError("Failed to obtain session after handshake completed");
        }
        sslSession = sslParameters.setupSession(sslSessionCtx, sslNativePointer, sslSession, getPeerHost(), getPeerPort(), true);
        if (sslSession != null && engineState == EngineState.HANDSHAKE_STARTED) {
            engineState = EngineState.READY_HANDSHAKE_CUT_THROUGH;
        } else {
            engineState = EngineState.READY;
        }
        handshakeSession = null;
        handshakeFinished = true;
        return FINISHED;
    } catch (Exception e) {
        throw (SSLHandshakeException) new SSLHandshakeException("Handshake failed").initCause(e);
    } finally {
        if (sslSession == null && sslSessionCtx != 0) {
            NativeCrypto.SSL_SESSION_free(sslSessionCtx);
        }
    }
}
#method_after
private SSLEngineResult.HandshakeStatus handshake() throws SSLException {
    long sslSessionCtx = 0L;
    try {
        // Only actually perform the handshake if we haven't already just completed it
        // via BIO operations.
        int code = NativeCrypto.ENGINE_SSL_do_handshake(sslNativePointer, this);
        if (code <= 0) {
            int sslError = NativeCrypto.SSL_get_error(sslNativePointer, code);
            switch(sslError) {
                case SSL_ERROR_WANT_READ:
                case SSL_ERROR_WANT_WRITE:
                    return pendingStatus(pendingOutboundEncryptedBytes());
                default:
                    // Everything else is considered as error
                    throw shutdownWithError("SSL_do_handshake");
            }
        }
        // Handshake is finished!
        sslSessionCtx = NativeCrypto.SSL_get1_session(sslNativePointer);
        if (sslSessionCtx == 0) {
            // return pendingStatus(pendingOutboundBytes());
            throw shutdownWithError("Failed to obtain session after handshake completed");
        }
        sslSession = sslParameters.setupSession(sslSessionCtx, sslNativePointer, sslSession, getPeerHost(), getPeerPort(), true);
        if (sslSession != null && engineState == EngineState.HANDSHAKE_STARTED) {
            engineState = EngineState.READY_HANDSHAKE_CUT_THROUGH;
        } else {
            engineState = EngineState.READY;
        }
        handshakeSession = null;
        handshakeFinished = true;
        return FINISHED;
    } catch (Exception e) {
        throw (SSLHandshakeException) new SSLHandshakeException("Handshake failed").initCause(e);
    } finally {
        if (sslSession == null && sslSessionCtx != 0) {
            NativeCrypto.SSL_SESSION_free(sslSessionCtx);
        }
    }
}
#end_block

#method_before
private int writePlaintextData(final ByteBuffer src) throws SSLException {
    try {
        final int pos = src.position();
        final int limit = src.limit();
        final int len = limit - pos;
        final int sslWrote;
        if (src.isDirect()) {
            long addr = NativeCrypto.getDirectBufferAddress(src) + pos;
            sslWrote = NativeCrypto.ENGINE_SSL_write_direct(sslNativePointer, addr, len, this);
        } else {
            sslWrote = NativeCrypto.ENGINE_SSL_write_heap(sslNativePointer, src.array(), src.arrayOffset() + pos, len, this);
        }
        if (sslWrote > 0) {
            src.position(pos + sslWrote);
        }
        return sslWrote;
    } catch (IOException e) {
        throw new SSLException(e);
    }
}
#method_after
private int writePlaintextData(final ByteBuffer src, int len) throws SSLException {
    try {
        final int pos = src.position();
        final int sslWrote;
        if (src.isDirect()) {
            long addr = NativeCrypto.getDirectBufferAddress(src) + pos;
            sslWrote = NativeCrypto.ENGINE_SSL_write_direct(sslNativePointer, addr, len, this);
        } else {
            ByteBuffer heapSrc = toHeapBuffer(src, len);
            sslWrote = NativeCrypto.ENGINE_SSL_write_heap(sslNativePointer, heapSrc.array(), heapSrc.arrayOffset() + heapSrc.position(), len, this);
        }
        if (sslWrote > 0) {
            src.position(pos + sslWrote);
        }
        return sslWrote;
    } catch (IOException e) {
        throw new SSLException(e);
    }
}
#end_block

#method_before
private int readPlaintextData(final ByteBuffer dst) throws SSLException {
    try {
        final int sslRead;
        final int pos = dst.position();
        final int limit = dst.limit();
        final int len = Math.min(NativeConstants.SSL3_RT_MAX_PACKET_SIZE, limit - pos);
        if (dst.isDirect()) {
            long addr = NativeCrypto.getDirectBufferAddress(dst) + pos;
            sslRead = NativeCrypto.ENGINE_SSL_read_direct(sslNativePointer, addr, len, this);
            if (sslRead > 0) {
                dst.position(pos + sslRead);
            }
        } else {
            sslRead = NativeCrypto.ENGINE_SSL_read_heap(sslNativePointer, dst.array(), dst.arrayOffset() + pos, len, this);
            if (sslRead > 0) {
                dst.position(pos + sslRead);
            }
        }
        return sslRead;
    } catch (IOException e) {
        throw new SSLException(e);
    }
}
#method_after
private int readPlaintextData(final ByteBuffer dst) throws SSLException {
    try {
        final int sslRead;
        final int pos = dst.position();
        final int limit = dst.limit();
        final int len = Math.min(SSL3_RT_MAX_PACKET_SIZE, limit - pos);
        if (dst.isDirect()) {
            long addr = NativeCrypto.getDirectBufferAddress(dst) + pos;
            sslRead = NativeCrypto.ENGINE_SSL_read_direct(sslNativePointer, addr, len, this);
            if (sslRead > 0) {
                dst.position(pos + sslRead);
            }
        } else if (dst.hasArray()) {
            sslRead = NativeCrypto.ENGINE_SSL_read_heap(sslNativePointer, dst.array(), dst.arrayOffset() + pos, len, this);
            if (sslRead > 0) {
                dst.position(pos + sslRead);
            }
        } else {
            byte[] data = new byte[len];
            sslRead = NativeCrypto.ENGINE_SSL_read_heap(sslNativePointer, data, 0, len, this);
            if (sslRead > 0) {
                dst.put(data, 0, sslRead);
            }
        }
        return sslRead;
    } catch (IOException e) {
        throw new SSLException(e);
    }
}
#end_block

#method_before
private int writeEncryptedData(final ByteBuffer src, int len) throws SSLException {
    try {
        final int pos = src.position();
        final int netWrote;
        if (src.isDirect()) {
            long addr = NativeCrypto.getDirectBufferAddress(src) + pos;
            netWrote = NativeCrypto.ENGINE_SSL_write_BIO_direct(sslNativePointer, networkBio, addr, len, this);
        } else {
            netWrote = NativeCrypto.ENGINE_SSL_write_BIO_heap(sslNativePointer, networkBio, src.array(), src.arrayOffset() + pos, len, this);
        }
        if (netWrote >= 0) {
            src.position(pos + netWrote);
        }
        return netWrote;
    } catch (IOException e) {
        throw new SSLException(e);
    }
}
#method_after
private int writeEncryptedData(final ByteBuffer src, int len) throws SSLException {
    try {
        final int pos = src.position();
        final int netWrote;
        if (src.isDirect()) {
            long addr = NativeCrypto.getDirectBufferAddress(src) + pos;
            netWrote = NativeCrypto.ENGINE_SSL_write_BIO_direct(sslNativePointer, networkBio, addr, len, this);
        } else {
            ByteBuffer heapSrc = toHeapBuffer(src, len);
            netWrote = NativeCrypto.ENGINE_SSL_write_BIO_heap(sslNativePointer, networkBio, heapSrc.array(), heapSrc.arrayOffset() + heapSrc.position(), len, this);
        }
        if (netWrote >= 0) {
            src.position(pos + netWrote);
        }
        return netWrote;
    } catch (IOException e) {
        throw new SSLException(e);
    }
}
#end_block

#method_before
private SSLEngineResult readPendingBytesFromBIO(ByteBuffer dst, int bytesConsumed, int bytesProduced, SSLEngineResult.HandshakeStatus status) throws SSLException {
    // Check to see if the engine wrote data into the network BIO
    int pendingNet = pendingOutboundEncryptedBytes();
    if (pendingNet > 0) {
        // Do we have enough room in dst to write encrypted data?
        int capacity = dst.remaining();
        if (capacity < pendingNet) {
            return new SSLEngineResult(BUFFER_OVERFLOW, mayFinishHandshake(status == FINISHED ? status : getHandshakeStatus(pendingNet)), bytesConsumed, bytesProduced);
        }
        // Write the pending data from the network BIO into the dst buffer
        int produced = readEncryptedData(dst, pendingNet);
        if (produced <= 0) {
            // We ignore BIO_* errors here as we use in memory BIO anyway and will do another SSL_* call later
            // on in which we will produce an exception in case of an error
            NativeCrypto.SSL_clear_error();
        } else {
            bytesProduced += produced;
            pendingNet -= produced;
        }
        return new SSLEngineResult(getEngineStatus(), mayFinishHandshake(status == FINISHED ? status : getHandshakeStatus(pendingNet)), bytesConsumed, bytesProduced);
    }
    return null;
}
#method_after
private SSLEngineResult readPendingBytesFromBIO(ByteBuffer dst, int bytesConsumed, int bytesProduced, SSLEngineResult.HandshakeStatus status) throws SSLException {
    // Check to see if the engine wrote data into the network BIO
    int pendingNet = pendingOutboundEncryptedBytes();
    if (pendingNet > 0) {
        // Do we have enough room in dst to write encrypted data?
        int capacity = dst.remaining();
        if (capacity < pendingNet) {
            return new SSLEngineResult(BUFFER_OVERFLOW, mayFinishHandshake(status == FINISHED ? status : getHandshakeStatus(pendingNet)), bytesConsumed, bytesProduced);
        }
        // Write the pending data from the network BIO into the dst buffer
        int produced = readEncryptedData(dst, pendingNet);
        if (produced <= 0) {
            // We ignore BIO_* errors here as we use in memory BIO anyway and will do another
            // SSL_* call later
            // on in which we will produce an exception in case of an error
            NativeCrypto.SSL_clear_error();
        } else {
            bytesProduced += produced;
            pendingNet -= produced;
        }
        return new SSLEngineResult(getEngineStatus(), mayFinishHandshake(status == FINISHED ? status : getHandshakeStatus(pendingNet)), bytesConsumed, bytesProduced);
    }
    return null;
}
#end_block

#method_before
private int readEncryptedData(final ByteBuffer dst, final int pending) throws SSLException {
    try {
        int bioRead = 0;
        if (dst.remaining() >= pending) {
            final int pos = dst.position();
            final int limit = dst.limit();
            final int len = Math.min(pending, limit - pos);
            if (dst.isDirect()) {
                long addr = NativeCrypto.getDirectBufferAddress(dst) + pos;
                bioRead = NativeCrypto.ENGINE_SSL_read_BIO_direct(sslNativePointer, networkBio, addr, len, this);
                if (bioRead > 0) {
                    dst.position(pos + bioRead);
                    return bioRead;
                }
            } else {
                bioRead = NativeCrypto.ENGINE_SSL_read_BIO_heap(sslNativePointer, networkBio, dst.array(), dst.arrayOffset() + pos, pending, this);
                if (bioRead > 0) {
                    dst.position(pos + bioRead);
                    return bioRead;
                }
            }
        }
        return bioRead;
    } catch (IOException e) {
        throw new SSLException(e);
    }
}
#method_after
private int readEncryptedData(final ByteBuffer dst, final int pending) throws SSLException {
    try {
        int bioRead = 0;
        if (dst.remaining() >= pending) {
            final int pos = dst.position();
            final int limit = dst.limit();
            final int len = Math.min(pending, limit - pos);
            if (dst.isDirect()) {
                long addr = NativeCrypto.getDirectBufferAddress(dst) + pos;
                bioRead = NativeCrypto.ENGINE_SSL_read_BIO_direct(sslNativePointer, networkBio, addr, len, this);
                if (bioRead > 0) {
                    dst.position(pos + bioRead);
                    return bioRead;
                }
            } else if (dst.hasArray()) {
                bioRead = NativeCrypto.ENGINE_SSL_read_BIO_heap(sslNativePointer, networkBio, dst.array(), dst.arrayOffset() + pos, pending, this);
                if (bioRead > 0) {
                    dst.position(pos + bioRead);
                    return bioRead;
                }
            } else {
                byte[] data = new byte[len];
                bioRead = NativeCrypto.ENGINE_SSL_read_BIO_heap(sslNativePointer, networkBio, data, 0, pending, this);
                if (bioRead > 0) {
                    dst.put(data, 0, bioRead);
                    return bioRead;
                }
            }
        }
        return bioRead;
    } catch (IOException e) {
        throw new SSLException(e);
    }
}
#end_block

#method_before
@Override
public SSLEngineResult wrap(ByteBuffer[] srcs, int offset, int length, ByteBuffer dst) throws SSLException {
    checkNotNull(srcs, "srcs");
    checkNotNull(dst, "dst");
    if (dst.isReadOnly()) {
        throw new ReadOnlyBufferException();
    }
    final int endOffset = offset + length;
    for (int i = offset; i < endOffset; ++i) {
        checkNotNull(srcs[i], "one of the src");
    }
    checkIndex(srcs.length, offset, length, "srcs");
    synchronized (stateLock) {
        switch(engineState) {
            case MODE_SET:
                // Begin the handshake implicitly.
                beginHandshakeInternal();
                break;
            case CLOSED_OUTBOUND:
            case CLOSED:
                return new SSLEngineResult(Status.CLOSED, getHandshakeStatusInternal(), 0, 0);
            case NEW:
                throw new IllegalStateException("Client/server mode must be set before calling wrap");
        }
        // If we haven't completed the handshake yet, just let the caller know.
        HandshakeStatus handshakeStatus = HandshakeStatus.NOT_HANDSHAKING;
        // Prepare OpenSSL to work in server mode and receive handshake
        if (!handshakeFinished) {
            handshakeStatus = handshake();
            if (handshakeStatus == NEED_UNWRAP) {
                return NEED_UNWRAP_OK;
            }
            if (engineState == EngineState.CLOSED) {
                return NEED_UNWRAP_CLOSED;
            }
        // NEED_WRAP - just fall through to perform the wrap.
        }
        if (dst.remaining() < NativeConstants.SSL3_RT_MAX_PACKET_SIZE) {
            return new SSLEngineResult(Status.BUFFER_OVERFLOW, getHandshakeStatusInternal(), 0, 0);
        }
        int bytesProduced = 0;
        int bytesConsumed = 0;
        for (int i = offset; i < endOffset; ++i) {
            final ByteBuffer src = srcs[i];
            checkNotNull(src, "srcs[%d] is null", i);
            while (src.hasRemaining()) {
                final SSLEngineResult pendingNetResult;
                // Write plaintext application data to the SSL engine
                int result = writePlaintextData(src);
                if (result > 0) {
                    bytesConsumed += result;
                    pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, handshakeStatus);
                    if (pendingNetResult != null) {
                        if (pendingNetResult.getStatus() != OK) {
                            return pendingNetResult;
                        }
                        bytesProduced = pendingNetResult.bytesProduced();
                    }
                } else {
                    int sslError = NativeCrypto.SSL_get_error(sslNativePointer, result);
                    switch(sslError) {
                        case NativeConstants.SSL_ERROR_ZERO_RETURN:
                            // This means the connection was shutdown correctly, close inbound and outbound
                            closeAll();
                            pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, handshakeStatus);
                            return pendingNetResult != null ? pendingNetResult : CLOSED_NOT_HANDSHAKING;
                        case NativeConstants.SSL_ERROR_WANT_READ:
                            // If there is no pending data to read from BIO we should go back to event loop and try
                            // to read more data [1]. It is also possible that event loop will detect the socket
                            // has been closed. [1] https://www.openssl.org/docs/manmaster/ssl/SSL_write.html
                            pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, handshakeStatus);
                            return pendingNetResult != null ? pendingNetResult : new SSLEngineResult(getEngineStatus(), NEED_UNWRAP, bytesConsumed, bytesProduced);
                        case NativeConstants.SSL_ERROR_WANT_WRITE:
                            // SSL_ERROR_WANT_WRITE typically means that the underlying transport is not writable
                            // and we should set the "want write" flag on the selector and try again when the
                            // underlying transport is writable [1]. However we are not directly writing to the
                            // underlying transport and instead writing to a BIO buffer. The OpenSsl documentation
                            // says we should do the following [1]:
                            // 
                            // "When using a buffering BIO, like a BIO pair, data must be written into or retrieved
                            // out of the BIO before being able to continue."
                            // 
                            // So we attempt to drain the BIO buffer below, but if there is no data this condition
                            // is undefined and we assume their is a fatal error with the openssl engine and close.
                            // [1] https://www.openssl.org/docs/manmaster/ssl/SSL_write.html
                            pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, handshakeStatus);
                            return pendingNetResult != null ? pendingNetResult : NEED_WRAP_CLOSED;
                        default:
                            // Everything else is considered as error
                            throw shutdownWithError("SSL_write");
                    }
                }
            }
        }
        // empty, or only contained empty buffers.
        if (bytesConsumed == 0) {
            SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, bytesProduced, handshakeStatus);
            if (pendingNetResult != null) {
                return pendingNetResult;
            }
        }
        // return new SSLEngineResult(OK, getHandshakeStatusInternal(), bytesConsumed, bytesProduced);
        return newResult(bytesConsumed, bytesProduced, handshakeStatus);
    }
}
#method_after
@Override
public SSLEngineResult wrap(ByteBuffer[] srcs, int offset, int length, ByteBuffer dst) throws SSLException {
    checkNotNull(srcs, "srcs");
    checkNotNull(dst, "dst");
    if (dst.isReadOnly()) {
        throw new ReadOnlyBufferException();
    }
    final int endOffset = offset + length;
    for (int i = offset; i < endOffset; ++i) {
        checkNotNull(srcs[i], "one of the src");
    }
    checkIndex(srcs.length, offset, length, "srcs");
    synchronized (stateLock) {
        switch(engineState) {
            case MODE_SET:
                // Begin the handshake implicitly.
                beginHandshakeInternal();
                break;
            case CLOSED_OUTBOUND:
            case CLOSED:
                return new SSLEngineResult(Status.CLOSED, getHandshakeStatusInternal(), 0, 0);
            case NEW:
                throw new IllegalStateException("Client/server mode must be set before calling wrap");
        }
        // If we haven't completed the handshake yet, just let the caller know.
        HandshakeStatus handshakeStatus = HandshakeStatus.NOT_HANDSHAKING;
        // Prepare OpenSSL to work in server mode and receive handshake
        if (!handshakeFinished) {
            handshakeStatus = handshake();
            if (handshakeStatus == NEED_UNWRAP) {
                return NEED_UNWRAP_OK;
            }
            if (engineState == EngineState.CLOSED) {
                return NEED_UNWRAP_CLOSED;
            }
        // NEED_WRAP - just fall through to perform the wrap.
        }
        if (dst.remaining() < SSL3_RT_MAX_PACKET_SIZE) {
            return new SSLEngineResult(Status.BUFFER_OVERFLOW, getHandshakeStatusInternal(), 0, 0);
        }
        int bytesProduced = 0;
        int bytesConsumed = 0;
        loop: for (int i = offset; i < endOffset; ++i) {
            final ByteBuffer src = srcs[i];
            checkNotNull(src, "srcs[%d] is null", i);
            while (src.hasRemaining()) {
                final SSLEngineResult pendingNetResult;
                // Write plaintext application data to the SSL engine
                int result = writePlaintextData(src, Math.min(src.remaining(), SSL3_RT_MAX_PLAIN_LENGTH - bytesConsumed));
                if (result > 0) {
                    bytesConsumed += result;
                    pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, handshakeStatus);
                    if (pendingNetResult != null) {
                        if (pendingNetResult.getStatus() != OK) {
                            return pendingNetResult;
                        }
                        bytesProduced = pendingNetResult.bytesProduced();
                    }
                    if (bytesConsumed == SSL3_RT_MAX_PLAIN_LENGTH) {
                        // break out of the loop and start to fill the dst buffer.
                        break loop;
                    }
                } else {
                    int sslError = NativeCrypto.SSL_get_error(sslNativePointer, result);
                    switch(sslError) {
                        case SSL_ERROR_ZERO_RETURN:
                            // This means the connection was shutdown correctly, close inbound
                            // and outbound
                            closeAll();
                            pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, handshakeStatus);
                            return pendingNetResult != null ? pendingNetResult : CLOSED_NOT_HANDSHAKING;
                        case SSL_ERROR_WANT_READ:
                            // If there is no pending data to read from BIO we should go back to
                            // event loop and try
                            // to read more data [1]. It is also possible that event loop will
                            // detect the socket
                            // has been closed. [1]
                            // https://www.openssl.org/docs/manmaster/ssl/SSL_write.html
                            pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, handshakeStatus);
                            return pendingNetResult != null ? pendingNetResult : new SSLEngineResult(getEngineStatus(), NEED_UNWRAP, bytesConsumed, bytesProduced);
                        case SSL_ERROR_WANT_WRITE:
                            // SSL_ERROR_WANT_WRITE typically means that the underlying
                            // transport is not writable
                            // and we should set the "want write" flag on the selector and try
                            // again when the
                            // underlying transport is writable [1]. However we are not directly
                            // writing to the
                            // underlying transport and instead writing to a BIO buffer. The
                            // OpenSsl documentation
                            // says we should do the following [1]:
                            // 
                            // "When using a buffering BIO, like a BIO pair, data must be
                            // written into or retrieved
                            // out of the BIO before being able to continue."
                            // 
                            // So we attempt to drain the BIO buffer below, but if there is no
                            // data this condition
                            // is undefined and we assume their is a fatal error with the
                            // openssl engine and close.
                            // [1] https://www.openssl.org/docs/manmaster/ssl/SSL_write.html
                            pendingNetResult = readPendingBytesFromBIO(dst, bytesConsumed, bytesProduced, handshakeStatus);
                            return pendingNetResult != null ? pendingNetResult : NEED_WRAP_CLOSED;
                        default:
                            // Everything else is considered as error
                            throw shutdownWithError("SSL_write");
                    }
                }
            }
        }
        // empty, or only contained empty buffers.
        if (bytesConsumed == 0) {
            SSLEngineResult pendingNetResult = readPendingBytesFromBIO(dst, 0, bytesProduced, handshakeStatus);
            if (pendingNetResult != null) {
                return pendingNetResult;
            }
        }
        // bytesProduced);
        return newResult(bytesConsumed, bytesProduced, handshakeStatus);
    }
}
#end_block

#method_before
@Override
public void onSSLStateChange(long sslSessionNativePtr, int type, int val) {
    synchronized (stateLock) {
        switch(type) {
            case NativeConstants.SSL_CB_HANDSHAKE_DONE:
                if (engineState != EngineState.HANDSHAKE_STARTED && engineState != EngineState.READY_HANDSHAKE_CUT_THROUGH) {
                    throw new IllegalStateException("Completed handshake while in mode " + engineState);
                }
                engineState = EngineState.HANDSHAKE_COMPLETED;
                break;
            case NativeConstants.SSL_CB_HANDSHAKE_START:
                // For clients, this will allow the NEED_UNWRAP status to be
                // returned.
                engineState = EngineState.HANDSHAKE_STARTED;
                break;
        }
    }
}
#method_after
@Override
public void onSSLStateChange(long sslSessionNativePtr, int type, int val) {
    synchronized (stateLock) {
        switch(type) {
            case SSL_CB_HANDSHAKE_DONE:
                if (engineState != EngineState.HANDSHAKE_STARTED && engineState != EngineState.READY_HANDSHAKE_CUT_THROUGH) {
                    throw new IllegalStateException("Completed handshake while in mode " + engineState);
                }
                engineState = EngineState.HANDSHAKE_COMPLETED;
                break;
            case SSL_CB_HANDSHAKE_START:
                // For clients, this will allow the NEED_UNWRAP status to be
                // returned.
                engineState = EngineState.HANDSHAKE_STARTED;
                break;
        }
    }
}
#end_block

#method_before
private static void checkIndex(int length, int offset, int count, String arrayName) {
    if (offset >= length || offset + count > length) {
        throw new IndexOutOfBoundsException("offset: " + offset + ", length: " + count + " (expected: offset <= offset + length <= srcs.length (" + length + "))");
    }
}
#method_after
private static void checkIndex(int arrayLength, int offset, int length, String arrayName) {
    if ((offset | length) < 0 || offset + length > arrayLength) {
        throw new IndexOutOfBoundsException("offset: " + offset + ", length: " + length + " (expected: offset <= offset + length <= " + arrayName + ".length (" + arrayLength + "))");
    }
}
#end_block

#method_before
private static <T> T checkNotNull(T obj, String fmt, Object... args) {
    if (obj == null) {
        throw new NullPointerException(String.format(fmt, args));
    }
    return obj;
}
#method_after
private static <T> T checkNotNull(T obj, String fmt, Object... args) {
    if (obj == null) {
        throw new IllegalArgumentException(String.format(fmt, args));
    }
    return obj;
}
#end_block

#method_before
@Override
public void startHandshake() throws IOException {
    checkOpen();
    synchronized (stateLock) {
        if (state == STATE_NEW) {
            state = STATE_HANDSHAKE_STARTED;
        } else {
            // Do nothing in both cases.
            return;
        }
    }
    final boolean client = sslParameters.getUseClientMode();
    sslNativePointer = 0;
    boolean releaseResources = true;
    try {
        final AbstractSessionContext sessionContext = sslParameters.getSessionContext();
        final long sslCtxNativePointer = sessionContext.sslCtxNativePointer;
        sslNativePointer = NativeCrypto.SSL_new(sslCtxNativePointer);
        Platform.closeGuardOpen(guard, "close");
        boolean enableSessionCreation = getEnableSessionCreation();
        if (!enableSessionCreation) {
            NativeCrypto.SSL_set_session_creation_enabled(sslNativePointer, enableSessionCreation);
        }
        // Allow servers to trigger renegotiation. Some inadvisable server
        // configurations cause them to attemcolpt to renegotiate during
        // certain protocols.
        NativeCrypto.SSL_accept_renegotiations(sslNativePointer);
        // Configure OCSP and CT extensions for client
        if (client) {
            NativeCrypto.SSL_enable_ocsp_stapling(sslNativePointer);
            if (sslParameters.isCTVerificationEnabled(getHostname())) {
                NativeCrypto.SSL_enable_signed_cert_timestamps(sslNativePointer);
            }
        }
        // Configure OCSP for server
        if (!client && sslParameters.getOCSPResponse() != null) {
            NativeCrypto.SSL_enable_ocsp_stapling(sslNativePointer);
        }
        final OpenSSLSessionImpl sessionToReuse = sslParameters.getSessionToReuse(sslNativePointer, getHostnameOrIP(), getPort());
        sslParameters.setSSLParameters(sslCtxNativePointer, sslNativePointer, this, this, getHostname());
        sslParameters.setCertificateValidation(sslNativePointer);
        sslParameters.setTlsChannelId(sslNativePointer, channelIdPrivateKey);
        // Temporarily use a different timeout for the handshake process
        int savedReadTimeoutMilliseconds = getSoTimeout();
        int savedWriteTimeoutMilliseconds = getSoWriteTimeout();
        if (handshakeTimeoutMilliseconds >= 0) {
            setSoTimeout(handshakeTimeoutMilliseconds);
            setSoWriteTimeout(handshakeTimeoutMilliseconds);
        }
        synchronized (stateLock) {
            if (state == STATE_CLOSED) {
                return;
            }
        }
        long sslSessionNativePointer;
        try {
            sslSessionNativePointer = NativeCrypto.SSL_do_handshake(sslNativePointer, Platform.getFileDescriptor(socket), this, getSoTimeout(), client);
        } catch (CertificateException e) {
            SSLHandshakeException wrapper = new SSLHandshakeException(e.getMessage());
            wrapper.initCause(e);
            throw wrapper;
        } catch (SSLException e) {
            // happens.
            synchronized (stateLock) {
                if (state == STATE_CLOSED) {
                    return;
                }
            }
            // Write CCS errors to EventLog
            String message = e.getMessage();
            // Must match error string of SSL_R_UNEXPECTED_CCS
            if (message.contains("unexpected CCS")) {
                String logMessage = String.format("ssl_unexpected_ccs: host=%s", getHostnameOrIP());
                Platform.logEvent(logMessage);
            }
            throw e;
        }
        boolean handshakeCompleted = false;
        synchronized (stateLock) {
            if (state == STATE_HANDSHAKE_COMPLETED) {
                handshakeCompleted = true;
            } else if (state == STATE_CLOSED) {
                return;
            }
        }
        sslSession = sslParameters.setupSession(sslSessionNativePointer, sslNativePointer, sessionToReuse, getHostnameOrIP(), getPort(), handshakeCompleted);
        // Restore the original timeout now that the handshake is complete
        if (handshakeTimeoutMilliseconds >= 0) {
            setSoTimeout(savedReadTimeoutMilliseconds);
            setSoWriteTimeout(savedWriteTimeoutMilliseconds);
        }
        // if not, notifyHandshakeCompletedListeners later in handshakeCompleted() callback
        if (handshakeCompleted) {
            notifyHandshakeCompletedListeners();
        }
        synchronized (stateLock) {
            releaseResources = (state == STATE_CLOSED);
            if (state == STATE_HANDSHAKE_STARTED) {
                state = STATE_READY_HANDSHAKE_CUT_THROUGH;
            } else if (state == STATE_HANDSHAKE_COMPLETED) {
                state = STATE_READY;
            }
            if (!releaseResources) {
                // Unblock threads that are waiting for our state to transition
                // into STATE_READY or STATE_READY_HANDSHAKE_CUT_THROUGH.
                stateLock.notifyAll();
            }
        }
    } catch (SSLProtocolException e) {
        throw (SSLHandshakeException) new SSLHandshakeException("Handshake failed").initCause(e);
    } finally {
        // on exceptional exit, treat the socket as closed
        if (releaseResources) {
            synchronized (stateLock) {
                // Mark the socket as closed since we might have reached this as
                // a result on an exception thrown by the handshake process.
                // 
                // The state will already be set to closed if we reach this as a result of
                // an early return or an interruption due to a concurrent call to close().
                state = STATE_CLOSED;
                stateLock.notifyAll();
            }
            try {
                shutdownAndFreeSslNative();
            } catch (IOException ignored) {
            }
        }
    }
}
#method_after
@Override
public void startHandshake() throws IOException {
    checkOpen();
    synchronized (stateLock) {
        if (state == STATE_NEW) {
            state = STATE_HANDSHAKE_STARTED;
        } else {
            // Do nothing in both cases.
            return;
        }
    }
    final boolean client = sslParameters.getUseClientMode();
    sslNativePointer = 0;
    boolean releaseResources = true;
    try {
        final AbstractSessionContext sessionContext = sslParameters.getSessionContext();
        final long sslCtxNativePointer = sessionContext.sslCtxNativePointer;
        sslNativePointer = NativeCrypto.SSL_new(sslCtxNativePointer);
        Platform.closeGuardOpen(guard, "close");
        boolean enableSessionCreation = getEnableSessionCreation();
        if (!enableSessionCreation) {
            NativeCrypto.SSL_set_session_creation_enabled(sslNativePointer, enableSessionCreation);
        }
        // Allow servers to trigger renegotiation. Some inadvisable server
        // configurations cause them to attempt to renegotiate during
        // certain protocols.
        NativeCrypto.SSL_accept_renegotiations(sslNativePointer);
        // Configure OCSP and CT extensions for client
        if (client) {
            NativeCrypto.SSL_enable_ocsp_stapling(sslNativePointer);
            if (sslParameters.isCTVerificationEnabled(getHostname())) {
                NativeCrypto.SSL_enable_signed_cert_timestamps(sslNativePointer);
            }
        }
        // Configure OCSP for server
        if (!client && sslParameters.getOCSPResponse() != null) {
            NativeCrypto.SSL_enable_ocsp_stapling(sslNativePointer);
        }
        final OpenSSLSessionImpl sessionToReuse = sslParameters.getSessionToReuse(sslNativePointer, getHostnameOrIP(), getPort());
        sslParameters.setSSLParameters(sslCtxNativePointer, sslNativePointer, this, this, getHostname());
        sslParameters.setCertificateValidation(sslNativePointer);
        sslParameters.setTlsChannelId(sslNativePointer, channelIdPrivateKey);
        // Temporarily use a different timeout for the handshake process
        int savedReadTimeoutMilliseconds = getSoTimeout();
        int savedWriteTimeoutMilliseconds = getSoWriteTimeout();
        if (handshakeTimeoutMilliseconds >= 0) {
            setSoTimeout(handshakeTimeoutMilliseconds);
            setSoWriteTimeout(handshakeTimeoutMilliseconds);
        }
        synchronized (stateLock) {
            if (state == STATE_CLOSED) {
                return;
            }
        }
        long sslSessionNativePointer;
        try {
            sslSessionNativePointer = NativeCrypto.SSL_do_handshake(sslNativePointer, Platform.getFileDescriptor(socket), this, getSoTimeout(), client);
        } catch (CertificateException e) {
            SSLHandshakeException wrapper = new SSLHandshakeException(e.getMessage());
            wrapper.initCause(e);
            throw wrapper;
        } catch (SSLException e) {
            // happens.
            synchronized (stateLock) {
                if (state == STATE_CLOSED) {
                    return;
                }
            }
            // Write CCS errors to EventLog
            String message = e.getMessage();
            // Must match error string of SSL_R_UNEXPECTED_CCS
            if (message.contains("unexpected CCS")) {
                String logMessage = String.format("ssl_unexpected_ccs: host=%s", getHostnameOrIP());
                Platform.logEvent(logMessage);
            }
            throw e;
        }
        boolean handshakeCompleted = false;
        synchronized (stateLock) {
            if (state == STATE_HANDSHAKE_COMPLETED) {
                handshakeCompleted = true;
            } else if (state == STATE_CLOSED) {
                return;
            }
        }
        sslSession = sslParameters.setupSession(sslSessionNativePointer, sslNativePointer, sessionToReuse, getHostnameOrIP(), getPort(), handshakeCompleted);
        // Restore the original timeout now that the handshake is complete
        if (handshakeTimeoutMilliseconds >= 0) {
            setSoTimeout(savedReadTimeoutMilliseconds);
            setSoWriteTimeout(savedWriteTimeoutMilliseconds);
        }
        // if not, notifyHandshakeCompletedListeners later in handshakeCompleted() callback
        if (handshakeCompleted) {
            notifyHandshakeCompletedListeners();
        }
        synchronized (stateLock) {
            releaseResources = (state == STATE_CLOSED);
            if (state == STATE_HANDSHAKE_STARTED) {
                state = STATE_READY_HANDSHAKE_CUT_THROUGH;
            } else if (state == STATE_HANDSHAKE_COMPLETED) {
                state = STATE_READY;
            }
            if (!releaseResources) {
                // Unblock threads that are waiting for our state to transition
                // into STATE_READY or STATE_READY_HANDSHAKE_CUT_THROUGH.
                stateLock.notifyAll();
            }
        }
    } catch (SSLProtocolException e) {
        throw (SSLHandshakeException) new SSLHandshakeException("Handshake failed").initCause(e);
    } finally {
        // on exceptional exit, treat the socket as closed
        if (releaseResources) {
            synchronized (stateLock) {
                // Mark the socket as closed since we might have reached this as
                // a result on an exception thrown by the handshake process.
                // 
                // The state will already be set to closed if we reach this as a result of
                // an early return or an interruption due to a concurrent call to close().
                state = STATE_CLOSED;
                stateLock.notifyAll();
            }
            try {
                shutdownAndFreeSslNative();
            } catch (IOException ignored) {
            }
        }
    }
}
#end_block

#method_before
void setSSLParameters(long sslCtxNativePointer, long sslNativePointer, AliasChooser chooser, PSKCallbacks pskCallbacks, String sniHostname) throws SSLException, IOException {
    NativeCrypto.SSL_configure_alpn(sslNativePointer, client_mode, alpnProtocols);
    NativeCrypto.setEnabledProtocols(sslNativePointer, enabledProtocols);
    NativeCrypto.setEnabledCipherSuites(sslNativePointer, enabledCipherSuites);
    // clients will receive a call back to request certificates.
    if (!client_mode) {
        Set<String> keyTypes = new HashSet<String>();
        for (long sslCipherNativePointer : NativeCrypto.SSL_get_ciphers(sslNativePointer)) {
            String keyType = getServerX509KeyType(sslCipherNativePointer);
            if (keyType != null) {
                keyTypes.add(keyType);
            }
        }
        X509KeyManager keyManager = getX509KeyManager();
        if (keyManager != null) {
            for (String keyType : keyTypes) {
                try {
                    setCertificate(sslNativePointer, chooser.chooseServerAlias(x509KeyManager, keyType));
                } catch (CertificateEncodingException e) {
                    throw new IOException(e);
                }
            }
        }
        if (sctExtension != null) {
            NativeCrypto.SSL_CTX_set_signed_cert_timestamp_list(sslCtxNativePointer, sctExtension);
        }
        if (ocspResponse != null) {
            NativeCrypto.SSL_CTX_set_ocsp_response(sslCtxNativePointer, ocspResponse);
        }
        NativeCrypto.SSL_set_options(sslNativePointer, NativeConstants.SSL_OP_CIPHER_SERVER_PREFERENCE);
    }
    // Enable Pre-Shared Key (PSK) key exchange if requested
    PSKKeyManager pskKeyManager = getPSKKeyManager();
    if (pskKeyManager != null) {
        boolean pskEnabled = false;
        for (String enabledCipherSuite : enabledCipherSuites) {
            if ((enabledCipherSuite != null) && (enabledCipherSuite.contains("PSK"))) {
                pskEnabled = true;
                break;
            }
        }
        if (pskEnabled) {
            if (client_mode) {
                NativeCrypto.set_SSL_psk_client_callback_enabled(sslNativePointer, true);
            } else {
                NativeCrypto.set_SSL_psk_server_callback_enabled(sslNativePointer, true);
                String identityHint = pskCallbacks.chooseServerPSKIdentityHint(pskKeyManager);
                NativeCrypto.SSL_use_psk_identity_hint(sslNativePointer, identityHint);
            }
        }
    }
    if (useSessionTickets) {
        NativeCrypto.SSL_clear_options(sslNativePointer, NativeConstants.SSL_OP_NO_TICKET);
    }
    if (getUseSni() && AddressUtils.isValidSniHostname(sniHostname)) {
        NativeCrypto.SSL_set_tlsext_host_name(sslNativePointer, sniHostname);
    }
    // BEAST attack mitigation (1/n-1 record splitting for CBC cipher suites
    // with TLSv1 and SSLv3).
    NativeCrypto.SSL_set_mode(sslNativePointer, NativeConstants.SSL_MODE_CBC_RECORD_SPLITTING);
    boolean enableSessionCreation = getEnableSessionCreation();
    if (!enableSessionCreation) {
        NativeCrypto.SSL_set_session_creation_enabled(sslNativePointer, enableSessionCreation);
    }
}
#method_after
void setSSLParameters(long sslCtxNativePointer, long sslNativePointer, AliasChooser chooser, PSKCallbacks pskCallbacks, String sniHostname) throws SSLException, IOException {
    if (enabledProtocols.length == 0 && isEnabledProtocolsFiltered) {
        throw new SSLHandshakeException("No enabled protocols; " + NativeCrypto.OBSOLETE_PROTOCOL_SSLV3 + " is no longer supported and was filtered from the list");
    }
    NativeCrypto.SSL_configure_alpn(sslNativePointer, client_mode, alpnProtocols);
    NativeCrypto.setEnabledProtocols(sslNativePointer, enabledProtocols);
    NativeCrypto.setEnabledCipherSuites(sslNativePointer, enabledCipherSuites);
    // clients will receive a call back to request certificates.
    if (!client_mode) {
        Set<String> keyTypes = new HashSet<String>();
        for (long sslCipherNativePointer : NativeCrypto.SSL_get_ciphers(sslNativePointer)) {
            String keyType = getServerX509KeyType(sslCipherNativePointer);
            if (keyType != null) {
                keyTypes.add(keyType);
            }
        }
        X509KeyManager keyManager = getX509KeyManager();
        if (keyManager != null) {
            for (String keyType : keyTypes) {
                try {
                    setCertificate(sslNativePointer, chooser.chooseServerAlias(x509KeyManager, keyType));
                } catch (CertificateEncodingException e) {
                    throw new IOException(e);
                }
            }
        }
        if (sctExtension != null) {
            NativeCrypto.SSL_CTX_set_signed_cert_timestamp_list(sslCtxNativePointer, sctExtension);
        }
        if (ocspResponse != null) {
            NativeCrypto.SSL_CTX_set_ocsp_response(sslCtxNativePointer, ocspResponse);
        }
        NativeCrypto.SSL_set_options(sslNativePointer, NativeConstants.SSL_OP_CIPHER_SERVER_PREFERENCE);
    }
    // Enable Pre-Shared Key (PSK) key exchange if requested
    PSKKeyManager pskKeyManager = getPSKKeyManager();
    if (pskKeyManager != null) {
        boolean pskEnabled = false;
        for (String enabledCipherSuite : enabledCipherSuites) {
            if ((enabledCipherSuite != null) && (enabledCipherSuite.contains("PSK"))) {
                pskEnabled = true;
                break;
            }
        }
        if (pskEnabled) {
            if (client_mode) {
                NativeCrypto.set_SSL_psk_client_callback_enabled(sslNativePointer, true);
            } else {
                NativeCrypto.set_SSL_psk_server_callback_enabled(sslNativePointer, true);
                String identityHint = pskCallbacks.chooseServerPSKIdentityHint(pskKeyManager);
                NativeCrypto.SSL_use_psk_identity_hint(sslNativePointer, identityHint);
            }
        }
    }
    if (useSessionTickets) {
        NativeCrypto.SSL_clear_options(sslNativePointer, NativeConstants.SSL_OP_NO_TICKET);
    }
    if (getUseSni() && AddressUtils.isValidSniHostname(sniHostname)) {
        NativeCrypto.SSL_set_tlsext_host_name(sslNativePointer, sniHostname);
    }
    // BEAST attack mitigation (1/n-1 record splitting for CBC cipher suites
    // with TLSv1 and SSLv3).
    NativeCrypto.SSL_set_mode(sslNativePointer, NativeConstants.SSL_MODE_CBC_RECORD_SPLITTING);
    boolean enableSessionCreation = getEnableSessionCreation();
    if (!enableSessionCreation) {
        NativeCrypto.SSL_set_session_creation_enabled(sslNativePointer, enableSessionCreation);
    }
}
#end_block

#method_before
@Override
public Socket createSocket(Socket s, String hostname, int port, boolean autoClose) throws IOException {
    boolean socketHasFd = false;
    try {
        // If socket has a file descriptor we can use OpenSSLSocketImplWrapper directly
        // otherwise we need to use the engine.
        socketHasFd = Platform.getFileDescriptor(s) != null;
    } catch (RuntimeException re) {
    // Ignore
    }
    if (socketHasFd && !ALWAYS_USE_ENGINE_SOCKET) {
        System.err.println("Creating OpenSSLSocketImplWrapper");
        return new OpenSSLSocketImplWrapper(s, hostname, port, autoClose, (SSLParametersImpl) sslParameters.clone());
    } else {
        System.err.println("Creating OpenSSLEngineSocketImpl");
        return new OpenSSLEngineSocketImpl(s, hostname, port, autoClose, (SSLParametersImpl) sslParameters.clone());
    }
}
#method_after
@Override
public Socket createSocket(Socket s, String hostname, int port, boolean autoClose) throws IOException {
    boolean socketHasFd = false;
    try {
        // If socket has a file descriptor we can use OpenSSLSocketImplWrapper directly
        // otherwise we need to use the engine.
        socketHasFd = Platform.getFileDescriptor(s) != null;
    } catch (RuntimeException re) {
    // Ignore
    }
    if (socketHasFd && !alwaysUseSocketEngine) {
        return new OpenSSLSocketImplWrapper(s, hostname, port, autoClose, (SSLParametersImpl) sslParameters.clone());
    } else {
        return new OpenSSLEngineSocketImpl(s, hostname, port, autoClose, (SSLParametersImpl) sslParameters.clone());
    }
}
#end_block

#method_before
static int getEncryptedPacketLength(ByteBuffer[] buffers, int offset) {
    ByteBuffer buffer = buffers[offset];
    // Check if everything we need is in one ByteBuffer. If so we can make use of the fast-path.
    if (buffer.remaining() >= SSL_RECORD_HEADER_LENGTH) {
        return getEncryptedPacketLength(buffer);
    }
    // We need to copy 5 bytes into a temporary buffer so we can parse out the packet length easily.
    ByteBuffer tmp = ByteBuffer.allocate(5);
    do {
        buffer = buffers[offset++].duplicate();
        if (buffer.remaining() > tmp.remaining()) {
            buffer.limit(buffer.position() + tmp.remaining());
        }
        tmp.put(buffer);
    } while (tmp.hasRemaining());
    // Done, flip the buffer so we can read from it.
    tmp.flip();
    return getEncryptedPacketLength(tmp);
}
#method_after
static int getEncryptedPacketLength(ByteBuffer[] buffers, int offset) {
    ByteBuffer buffer = buffers[offset];
    // Check if everything we need is in one ByteBuffer. If so we can make use of the fast-path.
    if (buffer.remaining() >= SSL3_RT_HEADER_LENGTH) {
        return getEncryptedPacketLength(buffer);
    }
    // We need to copy 5 bytes into a temporary buffer so we can parse out the packet length
    // easily.
    ByteBuffer tmp = ByteBuffer.allocate(SSL3_RT_HEADER_LENGTH);
    do {
        buffer = buffers[offset++];
        int pos = buffer.position();
        int limit = buffer.limit();
        if (buffer.remaining() > tmp.remaining()) {
            buffer.limit(pos + tmp.remaining());
        }
        try {
            tmp.put(buffer);
        } finally {
            // Restore the original indices.
            buffer.limit(limit);
            buffer.position(pos);
        }
    } while (tmp.hasRemaining());
    // Done, flip the buffer so we can read from it.
    tmp.flip();
    return getEncryptedPacketLength(tmp);
}
#end_block

#method_before
private static int getEncryptedPacketLength(ByteBuffer buffer) {
    int packetLength = 0;
    int pos = buffer.position();
    // SSLv3 or TLS - Check ContentType
    boolean tls;
    switch(unsignedByte(buffer.get(pos))) {
        case SSL_CONTENT_TYPE_CHANGE_CIPHER_SPEC:
        case SSL_CONTENT_TYPE_ALERT:
        case SSL_CONTENT_TYPE_HANDSHAKE:
        case SSL_CONTENT_TYPE_APPLICATION_DATA:
            tls = true;
            break;
        default:
            // SSLv2 or bad data
            tls = false;
    }
    if (tls) {
        // SSLv3 or TLS - Check ProtocolVersion
        int majorVersion = unsignedByte(buffer.get(pos + 1));
        if (majorVersion == 3) {
            // SSLv3 or TLS
            packetLength = unsignedShort(buffer.getShort(pos + 3)) + SSL_RECORD_HEADER_LENGTH;
            if (packetLength <= SSL_RECORD_HEADER_LENGTH) {
                // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)
                tls = false;
            }
        } else {
            // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)
            tls = false;
        }
    }
    if (!tls) {
        // SSLv2 or bad data - Check the version
        int headerLength = (unsignedByte(buffer.get(pos)) & 0x80) != 0 ? 2 : 3;
        int majorVersion = unsignedByte(buffer.get(pos + headerLength + 1));
        if (majorVersion == 2 || majorVersion == 3) {
            // SSLv2
            if (headerLength == 2) {
                packetLength = (buffer.getShort(pos) & 0x7FFF) + 2;
            } else {
                packetLength = (buffer.getShort(pos) & 0x3FFF) + 3;
            }
            if (packetLength <= headerLength) {
                return -1;
            }
        } else {
            return -1;
        }
    }
    return packetLength;
}
#method_after
private static int getEncryptedPacketLength(ByteBuffer buffer) {
    int packetLength = 0;
    int pos = buffer.position();
    // SSLv3 or TLS - Check ContentType
    switch(unsignedByte(buffer.get(pos))) {
        case SSL3_RT_CHANGE_CIPHER_SPEC:
        case SSL3_RT_ALERT:
        case SSL3_RT_HANDSHAKE:
        case SSL3_RT_APPLICATION_DATA:
            break;
        default:
            // SSLv2 or bad data
            return -1;
    }
    // SSLv3 or TLS - Check ProtocolVersion
    int majorVersion = unsignedByte(buffer.get(pos + 1));
    if (majorVersion != 3) {
        // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)
        return -1;
    }
    // SSLv3 or TLS
    packetLength = unsignedShort(buffer.getShort(pos + 3)) + SSL3_RT_HEADER_LENGTH;
    if (packetLength <= SSL3_RT_HEADER_LENGTH) {
        // Neither SSLv3 or TLSv1 (i.e. SSLv2 or bad data)
        return -1;
    }
    return packetLength;
}
#end_block

#method_before
public void checkAndStartWifi() {
    /* Check if wi-fi needs to be enabled */
    boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled();
    Slog.i(TAG, "WifiService starting up with Wi-Fi " + (wifiEnabled ? "enabled" : "disabled"));
    registerForScanModeChange();
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (mSettingsStore.handleAirplaneModeToggled()) {
                mWifiController.sendMessage(CMD_AIRPLANE_TOGGLED);
            }
            if (mSettingsStore.isAirplaneModeOn()) {
                Log.d(TAG, "resetting country code because Airplane mode is ON");
                mCountryCode.airplaneModeEnabled();
            }
        }
    }, new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
            if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was removed");
                mWifiStateMachine.resetSimAuthNetworks(false);
                Log.d(TAG, "resetting country code because SIM is removed");
                mCountryCode.simCardRemoved();
            } else if (IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was loaded");
                mWifiStateMachine.resetSimAuthNetworks(true);
            }
        }
    }, new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED));
    // Adding optimizations of only receiving broadcasts when wifi is enabled
    // can result in race conditions when apps toggle wifi in the background
    // without active user involvement. Always receive broadcasts.
    registerForBroadcasts();
    registerForPackageOrUserRemoval();
    mInIdleMode = mPowerManager.isDeviceIdleMode();
    mWifiController.start();
    // state here
    if (wifiEnabled)
        setWifiEnabled(wifiEnabled);
}
#method_after
public void checkAndStartWifi() {
    /* Check if wi-fi needs to be enabled */
    boolean wifiEnabled = mSettingsStore.isWifiToggleEnabled();
    Slog.i(TAG, "WifiService starting up with Wi-Fi " + (wifiEnabled ? "enabled" : "disabled"));
    registerForScanModeChange();
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (mSettingsStore.handleAirplaneModeToggled()) {
                mWifiController.sendMessage(CMD_AIRPLANE_TOGGLED);
            }
            if (mSettingsStore.isAirplaneModeOn()) {
                Log.d(TAG, "resetting country code because Airplane mode is ON");
                mCountryCode.airplaneModeEnabled();
            }
        }
    }, new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED));
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String state = intent.getStringExtra(IccCardConstants.INTENT_KEY_ICC_STATE);
            if (IccCardConstants.INTENT_VALUE_ICC_ABSENT.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was removed");
                mWifiStateMachine.resetSimAuthNetworks(false);
                Log.d(TAG, "resetting country code because SIM is removed");
                mCountryCode.simCardRemoved();
            } else if (IccCardConstants.INTENT_VALUE_ICC_LOADED.equals(state)) {
                Log.d(TAG, "resetting networks because SIM was loaded");
                mWifiStateMachine.resetSimAuthNetworks(true);
            }
        }
    }, new IntentFilter(TelephonyIntents.ACTION_SIM_STATE_CHANGED));
    // Adding optimizations of only receiving broadcasts when wifi is enabled
    // can result in race conditions when apps toggle wifi in the background
    // without active user involvement. Always receive broadcasts.
    registerForBroadcasts();
    registerForPackageOrUserRemoval();
    mInIdleMode = mPowerManager.isDeviceIdleMode();
    mWifiController.start();
    // state here
    if (wifiEnabled) {
        try {
            setWifiEnabled(mContext.getPackageName(), wifiEnabled);
        } catch (RemoteException e) {
        /* ignore - local call */
        }
    }
}
#end_block

#method_before
@Override
public synchronized boolean setWifiEnabled(boolean enable) {
    enforceChangePermission();
    Slog.d(TAG, "setWifiEnabled: " + enable + " pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
    /*
        * Caller might not have WRITE_SECURE_SETTINGS,
        * only CHANGE_WIFI_STATE is enforced
        */
    long ident = Binder.clearCallingIdentity();
    try {
        if (!mSettingsStore.handleWifiToggled(enable)) {
            // Nothing to do if wifi cannot be toggled
            return true;
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    mWifiController.sendMessage(CMD_WIFI_TOGGLED);
    return true;
}
#method_after
@Override
public synchronized boolean setWifiEnabled(String packageName, boolean enable) throws RemoteException {
    enforceChangePermission();
    Slog.d(TAG, "setWifiEnabled: " + enable + " pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
    /*
        * Caller might not have WRITE_SECURE_SETTINGS,
        * only CHANGE_WIFI_STATE is enforced
        */
    long ident = Binder.clearCallingIdentity();
    try {
        if (!mSettingsStore.handleWifiToggled(enable)) {
            // Nothing to do if wifi cannot be toggled
            return true;
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
    if (mPermissionReviewRequired) {
        final int wiFiEnabledState = getWifiEnabledState();
        if (enable) {
            if (wiFiEnabledState == WifiManager.WIFI_STATE_DISABLING || wiFiEnabledState == WifiManager.WIFI_STATE_DISABLED) {
                if (startConsentUiIfNeeded(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_ENABLE)) {
                    return true;
                }
            }
        } else if (wiFiEnabledState == WifiManager.WIFI_STATE_ENABLING || wiFiEnabledState == WifiManager.WIFI_STATE_ENABLED) {
            if (startConsentUiIfNeeded(packageName, Binder.getCallingUid(), WifiManager.ACTION_REQUEST_DISABLE)) {
                return true;
            }
        }
    }
    mWifiController.sendMessage(CMD_WIFI_TOGGLED);
    return true;
}
#end_block

#method_before
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Turn mobile hotspot off
        setWifiApEnabled(null, false);
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_WIFI)) {
        // Enable wifi
        setWifiEnabled(true);
        // Delete all Wifi SSIDs
        List<WifiConfiguration> networks = getConfiguredNetworks();
        if (networks != null) {
            for (WifiConfiguration config : networks) {
                removeNetwork(config.networkId);
            }
            saveConfiguration();
        }
    }
}
#method_after
@Override
public void factoryReset() {
    enforceConnectivityInternalPermission();
    if (mUserManager.hasUserRestriction(UserManager.DISALLOW_NETWORK_RESET)) {
        return;
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_TETHERING)) {
        // Turn mobile hotspot off
        setWifiApEnabled(null, false);
    }
    if (!mUserManager.hasUserRestriction(UserManager.DISALLOW_CONFIG_WIFI)) {
        // Enable wifi
        try {
            setWifiEnabled(mContext.getOpPackageName(), true);
        } catch (RemoteException e) {
        /* ignore - local call */
        }
        // Delete all Wifi SSIDs
        List<WifiConfiguration> networks = getConfiguredNetworks();
        if (networks != null) {
            for (WifiConfiguration config : networks) {
                removeNetwork(config.networkId);
            }
            saveConfiguration();
        }
    }
}
#end_block

#method_before
public boolean addProvider(PasspointConfiguration config) {
    if (config == null) {
        Log.e(TAG, "Configuration not provided");
        return false;
    }
    if (!config.validate()) {
        Log.e(TAG, "Invalid configuration");
        return false;
    }
    // Verify IMSI against the IMSI of the installed SIM cards for SIM credential.
    if (config.credential.simCredential != null) {
        try {
            if (mSimAccessor.getMatchingImsis(new IMSIParameter(config.credential.simCredential.imsi)) == null) {
                Log.e(TAG, "IMSI does not match any SIM card");
                return false;
            }
        } catch (IOException e) {
            return false;
        }
    }
    // Detect existing configuration in the same base domain.
    PasspointProvider existingProvider = findProviderInSameBaseDomain(config.homeSp.fqdn);
    if (existingProvider != null) {
        // TODO(zqiu): Remove existing key and certificates from the keystore.
        mProviders.remove(existingProvider.getConfig().homeSp.fqdn);
    }
    // TODO(zqiu): install new key and certificates to the keystore.
    // TODO(zqiu): create/use a copy of configuration to avoid others from modifying it,
    // since others might still have reference to it?
    mProviders.put(config.homeSp.fqdn, new PasspointProvider(config));
    return true;
}
#method_after
public boolean addProvider(PasspointConfiguration config) {
    if (config == null) {
        Log.e(TAG, "Configuration not provided");
        return false;
    }
    if (!config.validate()) {
        Log.e(TAG, "Invalid configuration");
        return false;
    }
    // Verify IMSI against the IMSI of the installed SIM cards for SIM credential.
    if (config.credential.simCredential != null) {
        try {
            if (mSimAccessor.getMatchingImsis(new IMSIParameter(config.credential.simCredential.imsi)) == null) {
                Log.e(TAG, "IMSI does not match any SIM card");
                return false;
            }
        } catch (IOException e) {
            return false;
        }
    }
    // TODO(b/32619189): install new key and certificates to the keystore.
    // Detect existing configuration in the same base domain.
    PasspointProvider existingProvider = findProviderInSameBaseDomain(config.homeSp.fqdn);
    if (existingProvider != null) {
        Log.d(TAG, "Replacing configuration for " + existingProvider.getConfig().homeSp.fqdn + " with " + config.homeSp.fqdn);
        // TODO(b/32619189): Remove existing key and certificates from the keystore.
        mProviders.remove(existingProvider.getConfig().homeSp.fqdn);
    }
    // TODO(b/32714562): create/use a copy of configuration to avoid others from modifying it,
    // since others might still have reference to it?
    mProviders.put(config.homeSp.fqdn, new PasspointProvider(config));
    return true;
}
#end_block

#method_before
public boolean removeProvider(String fqdn) {
    if (!mProviders.containsKey(fqdn)) {
        Log.e(TAG, "Config doesn't exist");
        return false;
    }
    // TODO(zqiu): Remove key and certificates from the keystore.
    mProviders.remove(fqdn);
    return true;
}
#method_after
public boolean removeProvider(String fqdn) {
    if (!mProviders.containsKey(fqdn)) {
        Log.e(TAG, "Config doesn't exist");
        return false;
    }
    // TODO(b/32619189): Remove key and certificates from the keystore.
    mProviders.remove(fqdn);
    return true;
}
#end_block

#method_before
@Test
public void addProviderWithInvalidCredential() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.userCredential = new Credential.UserCredential();
    config.credential.userCredential.username = "username";
    config.credential.userCredential.password = "password";
    // EAP-TLS not allowed for user credential.
    config.credential.userCredential.eapType = Credential.EAP_TLS;
    config.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    assertFalse(mManager.addProvider(config));
}
#method_after
@Test
public void addProviderWithInvalidCredential() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.caCertificate = FakeKeys.CA_CERT0;
    config.credential.userCredential = new Credential.UserCredential();
    config.credential.userCredential.username = "username";
    config.credential.userCredential.password = "password";
    // EAP-TLS not allowed for user credential.
    config.credential.userCredential.eapType = EAPConstants.EAP_TLS;
    config.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    assertFalse(mManager.addProvider(config));
}
#end_block

#method_before
@Test
public void addRemoveProviderWithValidUserCredential() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.userCredential = new Credential.UserCredential();
    config.credential.userCredential.username = "username";
    config.credential.userCredential.password = "password";
    config.credential.userCredential.eapType = Credential.EAP_TTLS;
    config.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    assertTrue(mManager.addProvider(config));
    verifyInstalledConfig(config);
    // Remove the provider.
    assertTrue(mManager.removeProvider(TEST_FQDN));
    assertEquals(null, mManager.getProviderConfigs());
}
#method_after
@Test
public void addRemoveProviderWithValidUserCredential() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.caCertificate = FakeKeys.CA_CERT0;
    config.credential.userCredential = new Credential.UserCredential();
    config.credential.userCredential.username = "username";
    config.credential.userCredential.password = "password";
    config.credential.userCredential.eapType = EAPConstants.EAP_TTLS;
    config.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    assertTrue(mManager.addProvider(config));
    verifyInstalledConfig(config);
    // Remove the provider.
    assertTrue(mManager.removeProvider(TEST_FQDN));
    assertEquals(null, mManager.getProviderConfigs());
}
#end_block

#method_before
@Test
public void addRemoveProviderWithValidSimCredential() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.simCredential = new Credential.SimCredential();
    config.credential.simCredential.imsi = TEST_IMSI;
    config.credential.simCredential.eapType = Credential.EAP_SIM;
    when(mSimAccessor.getMatchingImsis(new IMSIParameter(TEST_IMSI))).thenReturn(new ArrayList<String>());
    assertTrue(mManager.addProvider(config));
    verifyInstalledConfig(config);
    // Remove the provider.
    assertTrue(mManager.removeProvider(TEST_FQDN));
    assertEquals(null, mManager.getProviderConfigs());
}
#method_after
@Test
public void addRemoveProviderWithValidSimCredential() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.simCredential = new Credential.SimCredential();
    config.credential.simCredential.imsi = TEST_IMSI;
    config.credential.simCredential.eapType = EAPConstants.EAP_SIM;
    when(mSimAccessor.getMatchingImsis(new IMSIParameter(TEST_IMSI))).thenReturn(new ArrayList<String>());
    assertTrue(mManager.addProvider(config));
    verifyInstalledConfig(config);
    // Remove the provider.
    assertTrue(mManager.removeProvider(TEST_FQDN));
    assertEquals(null, mManager.getProviderConfigs());
}
#end_block

#method_before
@Test
public void addProviderWithValidSimCredentialWithInvalidIMSI() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.simCredential = new Credential.SimCredential();
    config.credential.simCredential.imsi = TEST_IMSI;
    config.credential.simCredential.eapType = Credential.EAP_SIM;
    when(mSimAccessor.getMatchingImsis(new IMSIParameter(TEST_IMSI))).thenReturn(null);
    assertFalse(mManager.addProvider(config));
}
#method_after
@Test
public void addProviderWithValidSimCredentialWithInvalidIMSI() throws Exception {
    PasspointConfiguration config = new PasspointConfiguration();
    config.homeSp = new HomeSP();
    config.homeSp.fqdn = TEST_FQDN;
    config.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    config.credential = new Credential();
    config.credential.realm = TEST_REALM;
    config.credential.simCredential = new Credential.SimCredential();
    config.credential.simCredential.imsi = TEST_IMSI;
    config.credential.simCredential.eapType = EAPConstants.EAP_SIM;
    when(mSimAccessor.getMatchingImsis(new IMSIParameter(TEST_IMSI))).thenReturn(null);
    assertFalse(mManager.addProvider(config));
}
#end_block

#method_before
@Test
public void addProviderWithExistingConfig() throws Exception {
    // Add a provider with the original configuration.
    PasspointConfiguration origConfig = new PasspointConfiguration();
    origConfig.homeSp = new HomeSP();
    origConfig.homeSp.fqdn = TEST_FQDN;
    origConfig.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    origConfig.credential = new Credential();
    origConfig.credential.realm = TEST_REALM;
    origConfig.credential.simCredential = new Credential.SimCredential();
    origConfig.credential.simCredential.imsi = TEST_IMSI;
    origConfig.credential.simCredential.eapType = Credential.EAP_SIM;
    when(mSimAccessor.getMatchingImsis(new IMSIParameter(TEST_IMSI))).thenReturn(new ArrayList<String>());
    assertTrue(mManager.addProvider(origConfig));
    verifyInstalledConfig(origConfig);
    // Add another provider with the same base domain as the existing provider.
    // This should replace the existing provider with the new configuration.
    PasspointConfiguration newConfig = new PasspointConfiguration();
    newConfig.homeSp = new HomeSP();
    newConfig.homeSp.fqdn = TEST_FQDN1;
    newConfig.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    newConfig.credential = new Credential();
    newConfig.credential.realm = TEST_REALM;
    newConfig.credential.userCredential = new Credential.UserCredential();
    newConfig.credential.userCredential.username = "username";
    newConfig.credential.userCredential.password = "password";
    newConfig.credential.userCredential.eapType = Credential.EAP_TTLS;
    newConfig.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    assertTrue(mManager.addProvider(newConfig));
    verifyInstalledConfig(newConfig);
}
#method_after
@Test
public void addProviderWithExistingConfig() throws Exception {
    // Add a provider with the original configuration.
    PasspointConfiguration origConfig = new PasspointConfiguration();
    origConfig.homeSp = new HomeSP();
    origConfig.homeSp.fqdn = TEST_FQDN;
    origConfig.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    origConfig.credential = new Credential();
    origConfig.credential.realm = TEST_REALM;
    origConfig.credential.simCredential = new Credential.SimCredential();
    origConfig.credential.simCredential.imsi = TEST_IMSI;
    origConfig.credential.simCredential.eapType = EAPConstants.EAP_SIM;
    when(mSimAccessor.getMatchingImsis(new IMSIParameter(TEST_IMSI))).thenReturn(new ArrayList<String>());
    assertTrue(mManager.addProvider(origConfig));
    verifyInstalledConfig(origConfig);
    // Add another provider with the same base domain as the existing provider.
    // This should replace the existing provider with the new configuration.
    PasspointConfiguration newConfig = new PasspointConfiguration();
    newConfig.homeSp = new HomeSP();
    newConfig.homeSp.fqdn = TEST_FQDN1;
    newConfig.homeSp.friendlyName = TEST_FRIENDLY_NAME;
    newConfig.credential = new Credential();
    newConfig.credential.realm = TEST_REALM;
    newConfig.credential.caCertificate = FakeKeys.CA_CERT0;
    newConfig.credential.userCredential = new Credential.UserCredential();
    newConfig.credential.userCredential.username = "username";
    newConfig.credential.userCredential.password = "password";
    newConfig.credential.userCredential.eapType = EAPConstants.EAP_TTLS;
    newConfig.credential.userCredential.nonEapInnerMethod = "MS-CHAP";
    assertTrue(mManager.addProvider(newConfig));
    verifyInstalledConfig(newConfig);
}
#end_block

#method_before
// DatagramSocket should ignore packets received from other sources prior to connect().
// CVE-2014-6512
public void testExplicitFilter() throws Exception {
    SocketAddress addr = new InetSocketAddress(0);
    try (DatagramSocket ds = new DatagramSocket();
        DatagramSocket socket = new DatagramSocket()) {
        byte[] data = new byte[100];
        DatagramPacket p = new DatagramPacket(data, data.length);
        socket.connect(ds.getLocalSocketAddress());
        socket.send(p);
        ds.setSoTimeout(100);
        ds.connect(addr);
        try {
            ds.receive(p);
            fail();
        } catch (SocketTimeoutException expected) {
        }
    }
}
#method_after
// DatagramSocket should ignore packets received from other sources prior to connect().
// CVE-2014-6512
public void testExplicitFilter() throws Exception {
    final byte[] data = new byte[] { 1, 2, 3, 4 };
    try (DatagramSocket dgramSocket = new DatagramSocket();
        DatagramSocket otherSocket = new DatagramSocket()) {
        otherSocket.connect(dgramSocket.getLocalSocketAddress());
        otherSocket.send(new DatagramPacket(data, data.length));
        dgramSocket.setSoTimeout(100);
        dgramSocket.connect(new InetSocketAddress(0));
        // from the buffer since it is not sent from the connected socket address.
        try {
            DatagramPacket recv = new DatagramPacket(new byte[data.length], data.length);
            dgramSocket.receive(recv);
            fail();
        } catch (SocketTimeoutException expected) {
        }
    }
    try (DatagramSocket dgramSocket = new DatagramSocket();
        DatagramSocket srcSocket = new DatagramSocket()) {
        srcSocket.connect(dgramSocket.getLocalSocketAddress());
        srcSocket.send(new DatagramPacket(data, data.length));
        dgramSocket.setSoTimeout(100);
        dgramSocket.connect(srcSocket.getLocalSocketAddress());
        // If the packet is sent from the connected address, even though that is before connect(), it
        // should not be dropped and receive() should succeed.
        DatagramPacket recv = new DatagramPacket(new byte[data.length], data.length);
        dgramSocket.receive(recv);
        assertTrue(Arrays.equals(recv.getData(), data));
    }
}
#end_block

#method_before
// http://b/31039416. openJdk cookies implementation is more
// strict about the "expires" field parsing and requires
public void testLenientExpiresParsing() throws Exception {
    CookieManager cm = new CookieManager(createCookieStore(), null);
    URI uri = URI.create("https://test.com");
    Map<String, List<String>> header = new HashMap<>();
    List<String> value = new ArrayList<>();
    value.add("cookie=1234567890test; domain=.test.com; path=/; " + "expires=Fri, 31 Dec 9999 04:01:25 -0000");
    header.put("Set-Cookie", value);
    cm.put(uri, header);
    List<HttpCookie> cookies = cm.getCookieStore().getCookies();
    assertEquals(1, cookies.size());
    HttpCookie cookie = cookies.get(0);
    assertEquals("1234567890test", cookie.getValue());
    // This should work till year 6830.
    assertTrue(cookie.getMaxAge() > 100000000000L);
}
#method_after
// http://b/31039416. Android supports cookie "expires" values without a
public void testLenientExpiresParsing() throws Exception {
    CookieManager cm = new CookieManager(createCookieStore(), null);
    URI uri = URI.create("https://test.com");
    Map<String, List<String>> header = new HashMap<>();
    List<String> value = new ArrayList<>();
    value.add("cookie=1234567890test; domain=.test.com; path=/; " + "expires=Fri, 31 Dec 9999 04:01:25 -0000");
    header.put("Set-Cookie", value);
    cm.put(uri, header);
    List<HttpCookie> cookies = cm.getCookieStore().getCookies();
    assertEquals(1, cookies.size());
    HttpCookie cookie = cookies.get(0);
    assertEquals("1234567890test", cookie.getValue());
    // This should work till year 6830 ((10000 - 6830) years ~= 10^11s)
    assertTrue(cookie.getMaxAge() > 100000000000L);
}
#end_block

#method_before
private static int guessCookieVersion(String header) {
    int version = 0;
    header = header.toLowerCase();
    if (header.indexOf("expires=") != -1) {
        // only netscape cookie using 'expires'
        version = 0;
    } else if (header.indexOf("version=") != -1) {
        // version is mandatory for rfc 2965/2109 cookie
        version = 1;
    } else if (header.indexOf("max-age") != -1) {
        // rfc 2965/2109 use 'max-age'
        version = 1;
    } else if (startsWithIgnoreCase(header, SET_COOKIE2)) {
        // only rfc 2965 cookie starts with 'set-cookie2'
        version = 1;
    }
    return version;
}
#method_after
/*
     * @param  dateString
     *         a date string in one of the formats defined in Netscape cookie spec
     *
     * @return  delta seconds between this cookie's creation time and the time
     *          specified by dateString
     */
// Android-changed: not used.
/*private long expiryDate2DeltaSeconds(String dateString) {
        Calendar cal = new GregorianCalendar(GMT);
        for (int i = 0; i < COOKIE_DATE_FORMATS.length; i++) {
            SimpleDateFormat df = new SimpleDateFormat(COOKIE_DATE_FORMATS[i],
                                                       Locale.US);
            cal.set(1970, 0, 1, 0, 0, 0);
            df.setTimeZone(GMT);
            df.setLenient(false);
            df.set2DigitYearStart(cal.getTime());
            try {
                cal.setTime(df.parse(dateString));
                if (!COOKIE_DATE_FORMATS[i].contains("yyyy")) {
                    // 2-digit years following the standard set
                    // out it rfc 6265
                    int year = cal.get(Calendar.YEAR);
                    year %= 100;
                    if (year < 70) {
                        year += 2000;
                    } else {
                        year += 1900;
                    }
                    cal.set(Calendar.YEAR, year);
                }
                return (cal.getTimeInMillis() - whenCreated) / 1000;
            } catch (Exception e) {
                // Ignore, try the next date format
            }
        }
        return 0;
    }*/
private static int guessCookieVersion(String header) {
    int version = 0;
    header = header.toLowerCase();
    if (header.indexOf("expires=") != -1) {
        // only netscape cookie using 'expires'
        version = 0;
    } else if (header.indexOf("version=") != -1) {
        // version is mandatory for rfc 2965/2109 cookie
        version = 1;
    } else if (header.indexOf("max-age") != -1) {
        // rfc 2965/2109 use 'max-age'
        version = 1;
    } else if (startsWithIgnoreCase(header, SET_COOKIE2)) {
        // only rfc 2965 cookie starts with 'set-cookie2'
        version = 1;
    }
    return version;
}
#end_block

#method_before
public void testCipherOutputSizeChange() throws Exception {
    /* from kroot@: "For AES transforms with padding up to a block is buffered (16 bytes) on
           the first "read" call because you have to check the padding on the doFinal call. For
           instance if you're decrypting 1020 bytes of plaintext, the ciphertext size will be 1024
           bytes because it adds 4 bytes of padding to make it up to a block worth of data. What
           happens when you have exactly a multiple of the block size of plaintext data is that an
           entire block of padding is added to the end to prevent ciphertext extension attacks.
           So the first read passing in 512 bytes of ciphertext to the Cipher instance will only
           return 496 bytes of plaintext and buffer the final 16 byte block since it doesn't know
           if that's the padding block. When you call doFinal with another 512 bytes of ciphertext,
           it may want to return more than 512 bytes because of that buffered block. */
    Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
    cipher.init(Cipher.DECRYPT_MODE, key, iv);
    try (InputStream is = new CipherInputStream(new ByteArrayInputStream(new byte[1024]), cipher)) {
        byte[] buffer = new byte[1024];
        assertEquals(496, is.read(buffer));
        assertEquals(512, is.read(buffer));
    }
}
#method_after
// http://b/32643789, check that CipherSpi.engineGetOutputSize is called and applied
public void testCipherOutputSizeChange() throws Exception {
    Provider mockProvider = new MockProvider();
    Cipher cipher = Cipher.getInstance("GrowingOutputSize", mockProvider);
    cipher.init(Cipher.DECRYPT_MODE, key, iv);
    InputStream mockEncryptedInputStream = new ByteArrayInputStream(new byte[1024]);
    try (InputStream is = new CipherInputStream(mockEncryptedInputStream, cipher)) {
        byte[] buffer = new byte[1024];
        // engineGetOutputSize returns 512+0, engineUpdate expects buf >= 512
        assertEquals(512, is.read(buffer));
        // engineGetOutputSize returns 512+1, engineUpdate expects buf >= 513
        // and will throw ShortBufferException buffer is smaller.
        assertEquals(513, is.read(buffer));
    }
}
#end_block

#method_before
private static Credential createCredential() {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = null;
    cred.certCredential = null;
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = Credential.EAP_SIM;
    cred.caCertificate = null;
    cred.clientCertificateChain = null;
    cred.clientPrivateKey = null;
    return cred;
}
#method_after
private static Credential createCredential() {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = null;
    cred.certCredential = null;
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = EAPConstants.EAP_SIM;
    cred.caCertificate = null;
    cred.clientCertificateChain = null;
    cred.clientPrivateKey = null;
    return cred;
}
#end_block

#method_before
public boolean validate() {
    if (TextUtils.isEmpty(username)) {
        Log.d(TAG, "Missing username");
        return false;
    }
    if (username.length() > MAX_USERNAME_LENGTH) {
        Log.d(TAG, "username exceeding maximum length: " + username.length());
        return false;
    }
    if (TextUtils.isEmpty(password)) {
        Log.d(TAG, "Missing password");
        return false;
    }
    if (password.length() > MAX_PASSWORD_LENGTH) {
        Log.d(TAG, "password exceeding maximum length: " + password.length());
        return false;
    }
    // Only supports EAP-TTLS for user credential.
    if (eapType != EAP_TTLS) {
        Log.d(TAG, "Invalid EAP Type for user credential: " + eapType);
        return false;
    }
    // Verify Non-EAP inner method for EAP-TTLS.
    if (!SUPPORTED_AUTH.contains(nonEapInnerMethod)) {
        Log.d(TAG, "Invalid non-EAP inner method for EAP-TTLS: " + nonEapInnerMethod);
        return false;
    }
    return true;
}
#method_after
public boolean validate() {
    if (TextUtils.isEmpty(username)) {
        Log.d(TAG, "Missing username");
        return false;
    }
    if (username.length() > MAX_USERNAME_LENGTH) {
        Log.d(TAG, "username exceeding maximum length: " + username.length());
        return false;
    }
    if (TextUtils.isEmpty(password)) {
        Log.d(TAG, "Missing password");
        return false;
    }
    if (password.length() > MAX_PASSWORD_LENGTH) {
        Log.d(TAG, "password exceeding maximum length: " + password.length());
        return false;
    }
    // Only supports EAP-TTLS for user credential.
    if (eapType != EAPConstants.EAP_TTLS) {
        Log.d(TAG, "Invalid EAP Type for user credential: " + eapType);
        return false;
    }
    // Verify Non-EAP inner method for EAP-TTLS.
    if (!SUPPORTED_AUTH.contains(nonEapInnerMethod)) {
        Log.d(TAG, "Invalid non-EAP inner method for EAP-TTLS: " + nonEapInnerMethod);
        return false;
    }
    return true;
}
#end_block

#method_before
public boolean validate() {
    // of the SIM card installed in the device.
    if (!verifyImsi()) {
        return false;
    }
    if (eapType != EAP_SIM && eapType != EAP_AKA && eapType != EAP_AKA_PRIME) {
        Log.d(TAG, "Invalid EAP Type for SIM credential: " + eapType);
        return false;
    }
    return true;
}
#method_after
public boolean validate() {
    // of the SIM card installed in the device.
    if (!verifyImsi()) {
        return false;
    }
    if (eapType != EAPConstants.EAP_SIM && eapType != EAPConstants.EAP_AKA && eapType != EAPConstants.EAP_AKA_PRIME) {
        Log.d(TAG, "Invalid EAP Type for SIM credential: " + eapType);
        return false;
    }
    return true;
}
#end_block

#method_before
private static Credential createCredentialWithSimCredential() {
    Credential.SimCredential simCred = new Credential.SimCredential();
    simCred.imsi = "1234*";
    simCred.eapType = Credential.EAP_SIM;
    return createCredential(null, null, simCred, null, null, null);
}
#method_after
private static Credential createCredentialWithSimCredential() {
    Credential.SimCredential simCred = new Credential.SimCredential();
    simCred.imsi = "1234*";
    simCred.eapType = EAPConstants.EAP_SIM;
    return createCredential(null, null, simCred, null, null, null);
}
#end_block

#method_before
private static Credential createCredentialWithUserCredential() {
    Credential.UserCredential userCred = new Credential.UserCredential();
    userCred.username = "username";
    userCred.password = "password";
    userCred.eapType = Credential.EAP_TTLS;
    userCred.nonEapInnerMethod = "MS-CHAP";
    return createCredential(userCred, null, null, FakeKeys.CA_CERT0, new X509Certificate[] { FakeKeys.CLIENT_CERT }, FakeKeys.RSA_KEY1);
}
#method_after
private static Credential createCredentialWithUserCredential() {
    Credential.UserCredential userCred = new Credential.UserCredential();
    userCred.username = "username";
    userCred.password = "password";
    userCred.eapType = EAPConstants.EAP_TTLS;
    userCred.nonEapInnerMethod = "MS-CHAP";
    return createCredential(userCred, null, null, FakeKeys.CA_CERT0, new X509Certificate[] { FakeKeys.CLIENT_CERT }, FakeKeys.RSA_KEY1);
}
#end_block

#method_before
@Test
public void validateUserCredential() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = Credential.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertTrue(cred.validate());
}
#method_after
@Test
public void validateUserCredential() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = EAPConstants.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertTrue(cred.validate());
}
#end_block

#method_before
@Test
public void validateUserCredentialWithoutCaCert() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = Credential.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    assertFalse(cred.validate());
}
#method_after
@Test
public void validateUserCredentialWithoutCaCert() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = EAPConstants.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    assertFalse(cred.validate());
}
#end_block

#method_before
@Test
public void validateUserCredentialWithEapTls() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = Credential.EAP_TLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertFalse(cred.validate());
}
#method_after
@Test
public void validateUserCredentialWithEapTls() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = EAPConstants.EAP_TLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertFalse(cred.validate());
}
#end_block

#method_before
@Test
public void validateUserCredentialWithoutRealm() throws Exception {
    Credential cred = new Credential();
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = Credential.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertFalse(cred.validate());
}
#method_after
@Test
public void validateUserCredentialWithoutRealm() throws Exception {
    Credential cred = new Credential();
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = EAPConstants.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertFalse(cred.validate());
}
#end_block

#method_before
@Test
public void validateUserCredentialWithoutUsername() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.password = "password";
    cred.userCredential.eapType = Credential.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertFalse(cred.validate());
}
#method_after
@Test
public void validateUserCredentialWithoutUsername() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.password = "password";
    cred.userCredential.eapType = EAPConstants.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertFalse(cred.validate());
}
#end_block

#method_before
@Test
public void validateUserCredentialWithoutPassword() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.eapType = Credential.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertFalse(cred.validate());
}
#method_after
@Test
public void validateUserCredentialWithoutPassword() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.eapType = EAPConstants.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertFalse(cred.validate());
}
#end_block

#method_before
@Test
public void validateUserCredentialWithoutAuthMethod() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = Credential.EAP_TTLS;
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertFalse(cred.validate());
}
#method_after
@Test
public void validateUserCredentialWithoutAuthMethod() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = EAPConstants.EAP_TTLS;
    cred.caCertificate = FakeKeys.CA_CERT0;
    assertFalse(cred.validate());
}
#end_block

#method_before
@Test
public void validateSimCredentialWithEapSim() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = Credential.EAP_SIM;
    assertTrue(cred.validate());
}
#method_after
@Test
public void validateSimCredentialWithEapSim() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = EAPConstants.EAP_SIM;
    assertTrue(cred.validate());
}
#end_block

#method_before
@Test
public void validateSimCredentialWithEapAka() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = Credential.EAP_AKA;
    assertTrue(cred.validate());
}
#method_after
@Test
public void validateSimCredentialWithEapAka() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = EAPConstants.EAP_AKA;
    assertTrue(cred.validate());
}
#end_block

#method_before
@Test
public void validateSimCredentialWithEapAkaPrime() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = Credential.EAP_AKA_PRIME;
    assertTrue(cred.validate());
}
#method_after
@Test
public void validateSimCredentialWithEapAkaPrime() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = EAPConstants.EAP_AKA_PRIME;
    assertTrue(cred.validate());
}
#end_block

#method_before
@Test
public void validateSimCredentialWithoutIMSI() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.eapType = Credential.EAP_SIM;
    assertFalse(cred.validate());
}
#method_after
@Test
public void validateSimCredentialWithoutIMSI() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.eapType = EAPConstants.EAP_SIM;
    assertFalse(cred.validate());
}
#end_block

#method_before
@Test
public void validateSimCredentialWithInvalidIMSI() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "dummy";
    cred.simCredential.eapType = Credential.EAP_SIM;
    assertFalse(cred.validate());
}
#method_after
@Test
public void validateSimCredentialWithInvalidIMSI() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "dummy";
    cred.simCredential.eapType = EAPConstants.EAP_SIM;
    assertFalse(cred.validate());
}
#end_block

#method_before
@Test
public void validateSimCredentialWithEapTls() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = Credential.EAP_TLS;
    assertFalse(cred.validate());
}
#method_after
@Test
public void validateSimCredentialWithEapTls() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = EAPConstants.EAP_TLS;
    assertFalse(cred.validate());
}
#end_block

#method_before
@Test
public void validateCredentialWithUserAndSimCredential() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup user credential with EAP-TTLS.
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = Credential.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = Credential.EAP_SIM;
    assertFalse(cred.validate());
}
#method_after
@Test
public void validateCredentialWithUserAndSimCredential() throws Exception {
    Credential cred = new Credential();
    cred.realm = "realm";
    // Setup user credential with EAP-TTLS.
    cred.userCredential = new Credential.UserCredential();
    cred.userCredential.username = "username";
    cred.userCredential.password = "password";
    cred.userCredential.eapType = EAPConstants.EAP_TTLS;
    cred.userCredential.nonEapInnerMethod = "MS-CHAP";
    cred.caCertificate = FakeKeys.CA_CERT0;
    // Setup SIM credential.
    cred.simCredential = new Credential.SimCredential();
    cred.simCredential.imsi = "1234*";
    cred.simCredential.eapType = EAPConstants.EAP_SIM;
    assertFalse(cred.validate());
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case SHOW_ERROR_MSG:
            {
                HashMap<String, Object> data = (HashMap<String, Object>) msg.obj;
                boolean showBackground = Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.ANR_SHOW_BACKGROUND, 0) != 0;
                synchronized (ActivityManagerService.this) {
                    ProcessRecord proc = (ProcessRecord) data.get("app");
                    AppErrorResult res = (AppErrorResult) data.get("result");
                    if (proc != null && proc.crashDialog != null) {
                        Slog.e(TAG, "App already has crash dialog: " + proc);
                        if (res != null) {
                            res.set(0);
                        }
                        return;
                    }
                    boolean isBackground = (UserHandle.getAppId(proc.uid) >= Process.FIRST_APPLICATION_UID && proc.pid != MY_PID);
                    for (int userId : mCurrentProfileIds) {
                        isBackground &= (proc.userId != userId);
                    }
                    if (isBackground && !showBackground) {
                        Slog.w(TAG, "Skipping crash dialog of " + proc + ": background");
                        if (res != null) {
                            res.set(0);
                        }
                        return;
                    }
                    if (mShowDialogs && !mSleeping && !mShuttingDown) {
                        Dialog d = new AppErrorDialog(mContext, ActivityManagerService.this, res, proc);
                        d.show();
                        proc.crashDialog = d;
                    } else {
                        // saw a crash dialog and hit "force quit".
                        if (res != null) {
                            res.set(0);
                        }
                    }
                }
                ensureBootCompleted();
            }
            break;
        case SHOW_NOT_RESPONDING_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    HashMap<String, Object> data = (HashMap<String, Object>) msg.obj;
                    ProcessRecord proc = (ProcessRecord) data.get("app");
                    if (proc != null && proc.anrDialog != null) {
                        Slog.e(TAG, "App already has anr dialog: " + proc);
                        return;
                    }
                    Intent intent = new Intent("android.intent.action.ANR");
                    if (!mProcessesReady) {
                        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
                    }
                    broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, 0);
                    if (mShowDialogs) {
                        Dialog d = new AppNotRespondingDialog(ActivityManagerService.this, mContext, proc, (ActivityRecord) data.get("activity"), msg.arg1 != 0);
                        d.show();
                        proc.anrDialog = d;
                    } else {
                        // Just kill the app if there is no dialog to be shown.
                        killAppAtUsersRequest(proc, null);
                    }
                }
                ensureBootCompleted();
            }
            break;
        case SHOW_STRICT_MODE_VIOLATION_MSG:
            {
                HashMap<String, Object> data = (HashMap<String, Object>) msg.obj;
                synchronized (ActivityManagerService.this) {
                    ProcessRecord proc = (ProcessRecord) data.get("app");
                    if (proc == null) {
                        Slog.e(TAG, "App not found when showing strict mode dialog.");
                        break;
                    }
                    if (proc.crashDialog != null) {
                        Slog.e(TAG, "App already has strict mode dialog: " + proc);
                        return;
                    }
                    AppErrorResult res = (AppErrorResult) data.get("result");
                    if (mShowDialogs && !mSleeping && !mShuttingDown) {
                        Dialog d = new StrictModeViolationDialog(mContext, ActivityManagerService.this, res, proc);
                        d.show();
                        proc.crashDialog = d;
                    } else {
                        // The device is asleep, so just pretend that the user
                        // saw a crash dialog and hit "force quit".
                        res.set(0);
                    }
                }
                ensureBootCompleted();
            }
            break;
        case SHOW_FACTORY_ERROR_MSG:
            {
                Dialog d = new FactoryErrorDialog(mContext, msg.getData().getCharSequence("msg"));
                d.show();
                ensureBootCompleted();
            }
            break;
        case WAIT_FOR_DEBUGGER_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ProcessRecord app = (ProcessRecord) msg.obj;
                    if (msg.arg1 != 0) {
                        if (!app.waitedForDebugger) {
                            Dialog d = new AppWaitingForDebuggerDialog(ActivityManagerService.this, mContext, app);
                            app.waitDialog = d;
                            app.waitedForDebugger = true;
                            d.show();
                        }
                    } else {
                        if (app.waitDialog != null) {
                            app.waitDialog.dismiss();
                            app.waitDialog = null;
                        }
                    }
                }
            }
            break;
        case SHOW_UID_ERROR_MSG:
            {
                if (mShowDialogs) {
                    AlertDialog d = new BaseErrorDialog(mContext);
                    d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
                    d.setCancelable(false);
                    d.setTitle(mContext.getText(R.string.android_system_label));
                    d.setMessage(mContext.getText(R.string.system_error_wipe_data));
                    d.setButton(DialogInterface.BUTTON_POSITIVE, mContext.getText(R.string.ok), obtainMessage(DISMISS_DIALOG_MSG, d));
                    d.show();
                }
            }
            break;
        case SHOW_FINGERPRINT_ERROR_MSG:
            {
                if (mShowDialogs) {
                    AlertDialog d = new BaseErrorDialog(mContext);
                    d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
                    d.setCancelable(false);
                    d.setTitle(mContext.getText(R.string.android_system_label));
                    d.setMessage(mContext.getText(R.string.system_error_manufacturer));
                    d.setButton(DialogInterface.BUTTON_POSITIVE, mContext.getText(R.string.ok), obtainMessage(DISMISS_DIALOG_MSG, d));
                    d.show();
                }
            }
            break;
        case SHOW_COMPAT_MODE_DIALOG_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord ar = (ActivityRecord) msg.obj;
                    if (mCompatModeDialog != null) {
                        if (mCompatModeDialog.mAppInfo.packageName.equals(ar.info.applicationInfo.packageName)) {
                            return;
                        }
                        mCompatModeDialog.dismiss();
                        mCompatModeDialog = null;
                    }
                    if (ar != null && false) {
                        if (mCompatModePackages.getPackageAskCompatModeLocked(ar.packageName)) {
                            int mode = mCompatModePackages.computeCompatModeLocked(ar.info.applicationInfo);
                            if (mode == ActivityManager.COMPAT_MODE_DISABLED || mode == ActivityManager.COMPAT_MODE_ENABLED) {
                                mCompatModeDialog = new CompatModeDialog(ActivityManagerService.this, mContext, ar.info.applicationInfo);
                                mCompatModeDialog.show();
                            }
                        }
                    }
                }
                break;
            }
        case START_USER_SWITCH_MSG:
            {
                showUserSwitchDialog(msg.arg1, (String) msg.obj);
                break;
            }
        case DISMISS_DIALOG_MSG:
            {
                final Dialog d = (Dialog) msg.obj;
                d.dismiss();
                break;
            }
        case DISPATCH_PROCESSES_CHANGED:
            {
                dispatchProcessesChanged();
                break;
            }
        case DISPATCH_PROCESS_DIED:
            {
                final int pid = msg.arg1;
                final int uid = msg.arg2;
                dispatchProcessDied(pid, uid);
                break;
            }
        case DISPATCH_UIDS_CHANGED_MSG:
            {
                dispatchUidsChanged();
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case SHOW_ERROR_UI_MSG:
            {
                mAppErrors.handleShowAppErrorUi(msg);
                ensureBootCompleted();
            }
            break;
        case SHOW_NOT_RESPONDING_UI_MSG:
            {
                mAppErrors.handleShowAnrUi(msg);
                ensureBootCompleted();
            }
            break;
        case SHOW_STRICT_MODE_VIOLATION_UI_MSG:
            {
                HashMap<String, Object> data = (HashMap<String, Object>) msg.obj;
                synchronized (ActivityManagerService.this) {
                    ProcessRecord proc = (ProcessRecord) data.get("app");
                    if (proc == null) {
                        Slog.e(TAG, "App not found when showing strict mode dialog.");
                        break;
                    }
                    if (proc.crashDialog != null) {
                        Slog.e(TAG, "App already has strict mode dialog: " + proc);
                        return;
                    }
                    AppErrorResult res = (AppErrorResult) data.get("result");
                    if (mShowDialogs && !mSleeping && !mShuttingDown) {
                        Dialog d = new StrictModeViolationDialog(mContext, ActivityManagerService.this, res, proc);
                        d.show();
                        proc.crashDialog = d;
                    } else {
                        // The device is asleep, so just pretend that the user
                        // saw a crash dialog and hit "force quit".
                        res.set(0);
                    }
                }
                ensureBootCompleted();
            }
            break;
        case SHOW_FACTORY_ERROR_UI_MSG:
            {
                Dialog d = new FactoryErrorDialog(mContext, msg.getData().getCharSequence("msg"));
                d.show();
                ensureBootCompleted();
            }
            break;
        case WAIT_FOR_DEBUGGER_UI_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ProcessRecord app = (ProcessRecord) msg.obj;
                    if (msg.arg1 != 0) {
                        if (!app.waitedForDebugger) {
                            Dialog d = new AppWaitingForDebuggerDialog(ActivityManagerService.this, mContext, app);
                            app.waitDialog = d;
                            app.waitedForDebugger = true;
                            d.show();
                        }
                    } else {
                        if (app.waitDialog != null) {
                            app.waitDialog.dismiss();
                            app.waitDialog = null;
                        }
                    }
                }
            }
            break;
        case SHOW_UID_ERROR_UI_MSG:
            {
                if (mShowDialogs) {
                    AlertDialog d = new BaseErrorDialog(mContext);
                    d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
                    d.setCancelable(false);
                    d.setTitle(mContext.getText(R.string.android_system_label));
                    d.setMessage(mContext.getText(R.string.system_error_wipe_data));
                    d.setButton(DialogInterface.BUTTON_POSITIVE, mContext.getText(R.string.ok), obtainMessage(DISMISS_DIALOG_UI_MSG, d));
                    d.show();
                }
            }
            break;
        case SHOW_FINGERPRINT_ERROR_UI_MSG:
            {
                if (mShowDialogs) {
                    AlertDialog d = new BaseErrorDialog(mContext);
                    d.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);
                    d.setCancelable(false);
                    d.setTitle(mContext.getText(R.string.android_system_label));
                    d.setMessage(mContext.getText(R.string.system_error_manufacturer));
                    d.setButton(DialogInterface.BUTTON_POSITIVE, mContext.getText(R.string.ok), obtainMessage(DISMISS_DIALOG_UI_MSG, d));
                    d.show();
                }
            }
            break;
        case SHOW_COMPAT_MODE_DIALOG_UI_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord ar = (ActivityRecord) msg.obj;
                    if (mCompatModeDialog != null) {
                        if (mCompatModeDialog.mAppInfo.packageName.equals(ar.info.applicationInfo.packageName)) {
                            return;
                        }
                        mCompatModeDialog.dismiss();
                        mCompatModeDialog = null;
                    }
                    if (ar != null && false) {
                        if (mCompatModePackages.getPackageAskCompatModeLocked(ar.packageName)) {
                            int mode = mCompatModePackages.computeCompatModeLocked(ar.info.applicationInfo);
                            if (mode == ActivityManager.COMPAT_MODE_DISABLED || mode == ActivityManager.COMPAT_MODE_ENABLED) {
                                mCompatModeDialog = new CompatModeDialog(ActivityManagerService.this, mContext, ar.info.applicationInfo);
                                mCompatModeDialog.show();
                            }
                        }
                    }
                }
                break;
            }
        case SHOW_UNSUPPORTED_DISPLAY_SIZE_DIALOG_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    final ActivityRecord ar = (ActivityRecord) msg.obj;
                    if (mUnsupportedDisplaySizeDialog != null) {
                        mUnsupportedDisplaySizeDialog.dismiss();
                        mUnsupportedDisplaySizeDialog = null;
                    }
                    if (ar != null && mCompatModePackages.getPackageNotifyUnsupportedZoomLocked(ar.packageName)) {
                        mUnsupportedDisplaySizeDialog = new UnsupportedDisplaySizeDialog(ActivityManagerService.this, mContext, ar.info.applicationInfo);
                        mUnsupportedDisplaySizeDialog.show();
                    }
                }
                break;
            }
        case START_USER_SWITCH_UI_MSG:
            {
                mUserController.showUserSwitchDialog((Pair<UserInfo, UserInfo>) msg.obj);
                break;
            }
        case DISMISS_DIALOG_UI_MSG:
            {
                final Dialog d = (Dialog) msg.obj;
                d.dismiss();
                break;
            }
        case DISPATCH_PROCESSES_CHANGED_UI_MSG:
            {
                dispatchProcessesChanged();
                break;
            }
        case DISPATCH_PROCESS_DIED_UI_MSG:
            {
                final int pid = msg.arg1;
                final int uid = msg.arg2;
                dispatchProcessDied(pid, uid);
                break;
            }
        case DISPATCH_UIDS_CHANGED_UI_MSG:
            {
                dispatchUidsChanged();
            }
            break;
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case UPDATE_CONFIGURATION_MSG:
            {
                final ContentResolver resolver = mContext.getContentResolver();
                Settings.System.putConfiguration(resolver, (Configuration) msg.obj);
            }
            break;
        case GC_BACKGROUND_PROCESSES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    performAppGcsIfAppropriateLocked();
                }
            }
            break;
        case SERVICE_TIMEOUT_MSG:
            {
                if (mDidDexOpt) {
                    mDidDexOpt = false;
                    Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
                    nmsg.obj = msg.obj;
                    mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT);
                    return;
                }
                mServices.serviceTimeout((ProcessRecord) msg.obj);
            }
            break;
        case UPDATE_TIME_ZONE:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimeZone();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update time zone for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case CLEAR_DNS_CACHE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.clearDnsCache();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to clear dns cache for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case UPDATE_HTTP_PROXY_MSG:
            {
                ProxyInfo proxy = (ProxyInfo) msg.obj;
                String host = "";
                String port = "";
                String exclList = "";
                Uri pacFileUrl = Uri.EMPTY;
                if (proxy != null) {
                    host = proxy.getHost();
                    port = Integer.toString(proxy.getPort());
                    exclList = proxy.getExclusionListAsString();
                    pacFileUrl = proxy.getPacFileUrl();
                }
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.setHttpProxy(host, port, exclList, pacFileUrl);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update http proxy for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case PROC_START_TIMEOUT_MSG:
            {
                if (mDidDexOpt) {
                    mDidDexOpt = false;
                    Message nmsg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                    nmsg.obj = msg.obj;
                    mHandler.sendMessageDelayed(nmsg, PROC_START_TIMEOUT);
                    return;
                }
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processStartTimedOutLocked(app);
                }
            }
            break;
        case CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processContentProviderPublishTimedOutLocked(app);
                }
            }
            break;
        case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    mStackSupervisor.doPendingActivityLaunchesLocked(true);
                }
            }
            break;
        case KILL_APPLICATION_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    int appid = msg.arg1;
                    boolean restart = (msg.arg2 == 1);
                    Bundle bundle = (Bundle) msg.obj;
                    String pkg = bundle.getString("pkg");
                    String reason = bundle.getString("reason");
                    forceStopPackageLocked(pkg, appid, restart, false, true, false, false, UserHandle.USER_ALL, reason);
                }
            }
            break;
        case FINALIZE_PENDING_INTENT_MSG:
            {
                ((PendingIntentRecord) msg.obj).completeFinalize();
            }
            break;
        case POST_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.heavy_weight_notification, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    Notification notification = new Notification.Builder(context).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, root.intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId))).build();
                    try {
                        int[] outId = new int[1];
                        inm.enqueueNotificationWithTag("android", "android", null, R.string.heavy_weight_notification, notification, outId, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for heavy notification", e);
                }
            }
            break;
        case CANCEL_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, R.string.heavy_weight_notification, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    checkExcessivePowerUsageLocked(true);
                    removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
                    Message nmsg = obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
                    sendMessageDelayed(nmsg, POWER_CHECK_DELAY);
                }
            }
            break;
        case REPORT_MEM_USAGE_MSG:
            {
                final ArrayList<ProcessMemInfo> memInfos = (ArrayList<ProcessMemInfo>) msg.obj;
                Thread thread = new Thread() {

                    @Override
                    public void run() {
                        reportMemUsage(memInfos);
                    }
                };
                thread.start();
                break;
            }
        case REPORT_USER_SWITCH_MSG:
            {
                dispatchUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case CONTINUE_USER_SWITCH_MSG:
            {
                continueUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case USER_SWITCH_TIMEOUT_MSG:
            {
                timeoutUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case IMMERSIVE_MODE_LOCK_MSG:
            {
                final boolean nextState = (msg.arg1 != 0);
                if (mUpdateLock.isHeld() != nextState) {
                    if (DEBUG_IMMERSIVE)
                        Slog.d(TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + (ActivityRecord) msg.obj);
                    if (nextState) {
                        mUpdateLock.acquire();
                    } else {
                        mUpdateLock.release();
                    }
                }
                break;
            }
        case PERSIST_URI_GRANTS_MSG:
            {
                writeGrantedUriPermissions();
                break;
            }
        case REQUEST_ALL_PSS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                }
                break;
            }
        case START_PROFILES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    startProfilesLocked();
                }
                break;
            }
        case UPDATE_TIME:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimePrefs(msg.arg1 == 0 ? false : true);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update preferences for: " + r.info.processName);
                            }
                        }
                    }
                }
                break;
            }
        case SYSTEM_USER_START_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.startUser(msg.arg1);
                break;
            }
        case SYSTEM_USER_CURRENT_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_FINISH, Integer.toString(msg.arg2), msg.arg2);
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.switchUser(msg.arg1);
                break;
            }
        case ENTER_ANIMATION_COMPLETE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord r = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                    if (r != null && r.app != null && r.app.thread != null) {
                        try {
                            r.app.thread.scheduleEnterAnimationComplete(r.appToken);
                        } catch (RemoteException e) {
                        }
                    }
                }
                break;
            }
        case FINISH_BOOTING_MSG:
            {
                if (msg.arg1 != 0) {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "FinishBooting");
                    finishBooting();
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                }
                if (msg.arg2 != 0) {
                    enableScreenAfterBoot();
                }
                break;
            }
        case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
            {
                try {
                    Locale l = (Locale) msg.obj;
                    IBinder service = ServiceManager.getService("mount");
                    IMountService mountService = IMountService.Stub.asInterface(service);
                    Log.d(TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                    mountService.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());
                } catch (RemoteException e) {
                    Log.e(TAG, "Error storing locale for decryption UI", e);
                }
                break;
            }
        case NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    int i = mTaskStackListeners.beginBroadcast();
                    while (i > 0) {
                        i--;
                        try {
                            // Make a one-way callback to the listener
                            mTaskStackListeners.getBroadcastItem(i).onTaskStackChanged();
                        } catch (RemoteException e) {
                        // Handled by the RemoteCallbackList
                        }
                    }
                    mTaskStackListeners.finishBroadcast();
                }
                break;
            }
        case NOTIFY_CLEARTEXT_NETWORK_MSG:
            {
                final int uid = msg.arg1;
                final byte[] firstPacket = (byte[]) msg.obj;
                synchronized (mPidsSelfLocked) {
                    for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                        final ProcessRecord p = mPidsSelfLocked.valueAt(i);
                        if (p.uid == uid) {
                            try {
                                p.thread.notifyCleartextNetwork(firstPacket);
                            } catch (RemoteException ignored) {
                            }
                        }
                    }
                }
                break;
            }
        case POST_DUMP_HEAP_NOTIFICATION_MSG:
            {
                final String procName;
                final int uid;
                final long memLimit;
                final String reportPackage;
                synchronized (ActivityManagerService.this) {
                    procName = mMemWatchDumpProcName;
                    uid = mMemWatchDumpUid;
                    Pair<Long, String> val = mMemWatchProcesses.get(procName, uid);
                    if (val == null) {
                        val = mMemWatchProcesses.get(procName, 0);
                    }
                    if (val != null) {
                        memLimit = val.first;
                        reportPackage = val.second;
                    } else {
                        memLimit = 0;
                        reportPackage = null;
                    }
                }
                if (procName == null) {
                    return;
                }
                if (DEBUG_PSS)
                    Slog.d(TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                String text = mContext.getString(R.string.dump_heap_notification, procName);
                Intent deleteIntent = new Intent();
                deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
                Intent intent = new Intent();
                intent.setClassName("android", DumpHeapActivity.class.getName());
                intent.putExtra(DumpHeapActivity.KEY_PROCESS, procName);
                intent.putExtra(DumpHeapActivity.KEY_SIZE, memLimit);
                if (reportPackage != null) {
                    intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH, reportPackage);
                }
                int userId = UserHandle.getUserId(uid);
                Notification notification = new Notification.Builder(mContext).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext, 0, deleteIntent, 0, UserHandle.OWNER)).build();
                try {
                    int[] outId = new int[1];
                    inm.enqueueNotificationWithTag("android", "android", null, R.string.dump_heap_notification, notification, outId, userId);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case DELETE_DUMPHEAP_MSG:
            {
                revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                synchronized (ActivityManagerService.this) {
                    mMemWatchDumpFile = null;
                    mMemWatchDumpProcName = null;
                    mMemWatchDumpPid = -1;
                    mMemWatchDumpUid = -1;
                }
            }
            break;
        case FOREGROUND_PROFILE_CHANGED_MSG:
            {
                dispatchForegroundProfileChanged(msg.arg1);
            }
            break;
        case REPORT_TIME_TRACKER_MSG:
            {
                AppTimeTracker tracker = (AppTimeTracker) msg.obj;
                tracker.deliverResult(mContext);
            }
            break;
        case REPORT_USER_SWITCH_COMPLETE_MSG:
            {
                dispatchUserSwitchComplete(msg.arg1);
            }
            break;
        case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
            {
                IUiAutomationConnection connection = (IUiAutomationConnection) msg.obj;
                try {
                    connection.shutdown();
                } catch (RemoteException e) {
                    Slog.w(TAG, "Error shutting down UiAutomationConnection");
                }
                // Only a UiAutomation can set this flag and now that
                // it is finished we make sure it is reset to its default.
                mUserIsMonkey = false;
            }
            break;
        case APP_BOOST_DEACTIVATE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    if (mIsBoosted) {
                        if (mBoostStartTime < (SystemClock.uptimeMillis() - APP_BOOST_TIMEOUT)) {
                            nativeMigrateFromBoost();
                            mIsBoosted = false;
                            mBoostStartTime = 0;
                        } else {
                            Message newmsg = mHandler.obtainMessage(APP_BOOST_DEACTIVATE_MSG);
                            mHandler.sendMessageDelayed(newmsg, APP_BOOST_TIMEOUT);
                        }
                    }
                }
            }
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case UPDATE_CONFIGURATION_MSG:
            {
                final ContentResolver resolver = mContext.getContentResolver();
                Settings.System.putConfigurationForUser(resolver, (Configuration) msg.obj, msg.arg1);
            }
            break;
        case GC_BACKGROUND_PROCESSES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    performAppGcsIfAppropriateLocked();
                }
            }
            break;
        case SERVICE_TIMEOUT_MSG:
            {
                if (mDidDexOpt) {
                    mDidDexOpt = false;
                    Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);
                    nmsg.obj = msg.obj;
                    mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT);
                    return;
                }
                mServices.serviceTimeout((ProcessRecord) msg.obj);
            }
            break;
        case UPDATE_TIME_ZONE:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimeZone();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update time zone for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case CLEAR_DNS_CACHE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.clearDnsCache();
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to clear dns cache for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case UPDATE_HTTP_PROXY_MSG:
            {
                ProxyInfo proxy = (ProxyInfo) msg.obj;
                String host = "";
                String port = "";
                String exclList = "";
                Uri pacFileUrl = Uri.EMPTY;
                if (proxy != null) {
                    host = proxy.getHost();
                    port = Integer.toString(proxy.getPort());
                    exclList = proxy.getExclusionListAsString();
                    pacFileUrl = proxy.getPacFileUrl();
                }
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.setHttpProxy(host, port, exclList, pacFileUrl);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update http proxy for: " + r.info.processName);
                            }
                        }
                    }
                }
            }
            break;
        case PROC_START_TIMEOUT_MSG:
            {
                if (mDidDexOpt) {
                    mDidDexOpt = false;
                    Message nmsg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                    nmsg.obj = msg.obj;
                    mHandler.sendMessageDelayed(nmsg, PROC_START_TIMEOUT);
                    return;
                }
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processStartTimedOutLocked(app);
                }
            }
            break;
        case CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG:
            {
                ProcessRecord app = (ProcessRecord) msg.obj;
                synchronized (ActivityManagerService.this) {
                    processContentProviderPublishTimedOutLocked(app);
                }
            }
            break;
        case DO_PENDING_ACTIVITY_LAUNCHES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    mActivityStarter.doPendingActivityLaunchesLocked(true);
                }
            }
            break;
        case KILL_APPLICATION_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    final int appId = msg.arg1;
                    final int userId = msg.arg2;
                    Bundle bundle = (Bundle) msg.obj;
                    String pkg = bundle.getString("pkg");
                    String reason = bundle.getString("reason");
                    forceStopPackageLocked(pkg, appId, false, false, true, false, false, userId, reason);
                }
            }
            break;
        case FINALIZE_PENDING_INTENT_MSG:
            {
                ((PendingIntentRecord) msg.obj).completeFinalize();
            }
            break;
        case POST_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                ActivityRecord root = (ActivityRecord) msg.obj;
                ProcessRecord process = root.app;
                if (process == null) {
                    return;
                }
                try {
                    Context context = mContext.createPackageContext(process.info.packageName, 0);
                    String text = mContext.getString(R.string.heavy_weight_notification, context.getApplicationInfo().loadLabel(context.getPackageManager()));
                    Notification notification = new Notification.Builder(context).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.heavy_weight_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, root.intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(root.userId))).build();
                    try {
                        int[] outId = new int[1];
                        inm.enqueueNotificationWithTag("android", "android", null, R.string.heavy_weight_notification, notification, outId, root.userId);
                    } catch (RuntimeException e) {
                        Slog.w(ActivityManagerService.TAG, "Error showing notification for heavy-weight app", e);
                    } catch (RemoteException e) {
                    }
                } catch (NameNotFoundException e) {
                    Slog.w(TAG, "Unable to create context for heavy notification", e);
                }
            }
            break;
        case CANCEL_HEAVY_NOTIFICATION_MSG:
            {
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                try {
                    inm.cancelNotificationWithTag("android", null, R.string.heavy_weight_notification, msg.arg1);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error canceling notification for service", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case CHECK_EXCESSIVE_WAKE_LOCKS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    checkExcessivePowerUsageLocked(true);
                    removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
                    Message nmsg = obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
                    sendMessageDelayed(nmsg, POWER_CHECK_DELAY);
                }
            }
            break;
        case REPORT_MEM_USAGE_MSG:
            {
                final ArrayList<ProcessMemInfo> memInfos = (ArrayList<ProcessMemInfo>) msg.obj;
                Thread thread = new Thread() {

                    @Override
                    public void run() {
                        reportMemUsage(memInfos);
                    }
                };
                thread.start();
                break;
            }
        case REPORT_USER_SWITCH_MSG:
            {
                mUserController.dispatchUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case CONTINUE_USER_SWITCH_MSG:
            {
                mUserController.continueUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case USER_SWITCH_TIMEOUT_MSG:
            {
                mUserController.timeoutUserSwitch((UserState) msg.obj, msg.arg1, msg.arg2);
                break;
            }
        case IMMERSIVE_MODE_LOCK_MSG:
            {
                final boolean nextState = (msg.arg1 != 0);
                if (mUpdateLock.isHeld() != nextState) {
                    if (DEBUG_IMMERSIVE)
                        Slog.d(TAG_IMMERSIVE, "Applying new update lock state '" + nextState + "' for " + (ActivityRecord) msg.obj);
                    if (nextState) {
                        mUpdateLock.acquire();
                    } else {
                        mUpdateLock.release();
                    }
                }
                break;
            }
        case PERSIST_URI_GRANTS_MSG:
            {
                writeGrantedUriPermissions();
                break;
            }
        case REQUEST_ALL_PSS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                }
                break;
            }
        case START_PROFILES_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    mUserController.startProfilesLocked();
                }
                break;
            }
        case UPDATE_TIME:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                        ProcessRecord r = mLruProcesses.get(i);
                        if (r.thread != null) {
                            try {
                                r.thread.updateTimePrefs(msg.arg1 == 0 ? false : true);
                            } catch (RemoteException ex) {
                                Slog.w(TAG, "Failed to update preferences for: " + r.info.processName);
                            }
                        }
                    }
                }
                break;
            }
        case SYSTEM_USER_START_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.startUser(msg.arg1);
                break;
            }
        case SYSTEM_USER_UNLOCK_MSG:
            {
                final int userId = msg.arg1;
                mSystemServiceManager.unlockUser(userId);
                synchronized (ActivityManagerService.this) {
                    mRecentTasks.loadUserRecentsLocked(userId);
                }
                if (userId == UserHandle.USER_SYSTEM) {
                    startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_UNAWARE);
                }
                installEncryptionUnawareProviders(userId);
                mUserController.finishUserUnlocked((UserState) msg.obj);
                break;
            }
        case SYSTEM_USER_CURRENT_MSG:
            {
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_FINISH, Integer.toString(msg.arg2), msg.arg2);
                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(msg.arg1), msg.arg1);
                mSystemServiceManager.switchUser(msg.arg1);
                break;
            }
        case ENTER_ANIMATION_COMPLETE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    ActivityRecord r = ActivityRecord.forTokenLocked((IBinder) msg.obj);
                    if (r != null && r.app != null && r.app.thread != null) {
                        try {
                            r.app.thread.scheduleEnterAnimationComplete(r.appToken);
                        } catch (RemoteException e) {
                        }
                    }
                }
                break;
            }
        case FINISH_BOOTING_MSG:
            {
                if (msg.arg1 != 0) {
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "FinishBooting");
                    finishBooting();
                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                }
                if (msg.arg2 != 0) {
                    enableScreenAfterBoot();
                }
                break;
            }
        case SEND_LOCALE_TO_MOUNT_DAEMON_MSG:
            {
                try {
                    Locale l = (Locale) msg.obj;
                    IBinder service = ServiceManager.getService("mount");
                    IMountService mountService = IMountService.Stub.asInterface(service);
                    Log.d(TAG, "Storing locale " + l.toLanguageTag() + " for decryption UI");
                    mountService.setField(StorageManager.SYSTEM_LOCALE_KEY, l.toLanguageTag());
                } catch (RemoteException e) {
                    Log.e(TAG, "Error storing locale for decryption UI", e);
                }
                break;
            }
        case NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                        try {
                            // Make a one-way callback to the listener
                            mTaskStackListeners.getBroadcastItem(i).onTaskStackChanged();
                        } catch (RemoteException e) {
                        // Handled by the RemoteCallbackList
                        }
                    }
                    mTaskStackListeners.finishBroadcast();
                }
                break;
            }
        case NOTIFY_ACTIVITY_PINNED_LISTENERS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                        try {
                            // Make a one-way callback to the listener
                            mTaskStackListeners.getBroadcastItem(i).onActivityPinned();
                        } catch (RemoteException e) {
                        // Handled by the RemoteCallbackList
                        }
                    }
                    mTaskStackListeners.finishBroadcast();
                }
                break;
            }
        case NOTIFY_PINNED_ACTIVITY_RESTART_ATTEMPT_LISTENERS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                        try {
                            // Make a one-way callback to the listener
                            mTaskStackListeners.getBroadcastItem(i).onPinnedActivityRestartAttempt();
                        } catch (RemoteException e) {
                        // Handled by the RemoteCallbackList
                        }
                    }
                    mTaskStackListeners.finishBroadcast();
                }
                break;
            }
        case NOTIFY_PINNED_STACK_ANIMATION_ENDED_LISTENERS_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                        try {
                            // Make a one-way callback to the listener
                            mTaskStackListeners.getBroadcastItem(i).onPinnedStackAnimationEnded();
                        } catch (RemoteException e) {
                        // Handled by the RemoteCallbackList
                        }
                    }
                    mTaskStackListeners.finishBroadcast();
                }
                break;
            }
        case NOTIFY_FORCED_RESIZABLE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                        try {
                            // Make a one-way callback to the listener
                            mTaskStackListeners.getBroadcastItem(i).onActivityForcedResizable((String) msg.obj, msg.arg1);
                        } catch (RemoteException e) {
                        // Handled by the RemoteCallbackList
                        }
                    }
                    mTaskStackListeners.finishBroadcast();
                }
                break;
            }
        case NOTIFY_ACTIVITY_DISMISSING_DOCKED_STACK_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    for (int i = mTaskStackListeners.beginBroadcast() - 1; i >= 0; i--) {
                        try {
                            // Make a one-way callback to the listener
                            mTaskStackListeners.getBroadcastItem(i).onActivityDismissingDockedStack();
                        } catch (RemoteException e) {
                        // Handled by the RemoteCallbackList
                        }
                    }
                    mTaskStackListeners.finishBroadcast();
                }
                break;
            }
        case NOTIFY_CLEARTEXT_NETWORK_MSG:
            {
                final int uid = msg.arg1;
                final byte[] firstPacket = (byte[]) msg.obj;
                synchronized (mPidsSelfLocked) {
                    for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                        final ProcessRecord p = mPidsSelfLocked.valueAt(i);
                        if (p.uid == uid) {
                            try {
                                p.thread.notifyCleartextNetwork(firstPacket);
                            } catch (RemoteException ignored) {
                            }
                        }
                    }
                }
                break;
            }
        case POST_DUMP_HEAP_NOTIFICATION_MSG:
            {
                final String procName;
                final int uid;
                final long memLimit;
                final String reportPackage;
                synchronized (ActivityManagerService.this) {
                    procName = mMemWatchDumpProcName;
                    uid = mMemWatchDumpUid;
                    Pair<Long, String> val = mMemWatchProcesses.get(procName, uid);
                    if (val == null) {
                        val = mMemWatchProcesses.get(procName, 0);
                    }
                    if (val != null) {
                        memLimit = val.first;
                        reportPackage = val.second;
                    } else {
                        memLimit = 0;
                        reportPackage = null;
                    }
                }
                if (procName == null) {
                    return;
                }
                if (DEBUG_PSS)
                    Slog.d(TAG_PSS, "Showing dump heap notification from " + procName + "/" + uid);
                INotificationManager inm = NotificationManager.getService();
                if (inm == null) {
                    return;
                }
                String text = mContext.getString(R.string.dump_heap_notification, procName);
                Intent deleteIntent = new Intent();
                deleteIntent.setAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
                Intent intent = new Intent();
                intent.setClassName("android", DumpHeapActivity.class.getName());
                intent.putExtra(DumpHeapActivity.KEY_PROCESS, procName);
                intent.putExtra(DumpHeapActivity.KEY_SIZE, memLimit);
                if (reportPackage != null) {
                    intent.putExtra(DumpHeapActivity.KEY_DIRECT_LAUNCH, reportPackage);
                }
                int userId = UserHandle.getUserId(uid);
                Notification notification = new Notification.Builder(mContext).setSmallIcon(com.android.internal.R.drawable.stat_sys_adb).setWhen(0).setOngoing(true).setAutoCancel(true).setTicker(text).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(text).setContentText(mContext.getText(R.string.dump_heap_notification_detail)).setContentIntent(PendingIntent.getActivityAsUser(mContext, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT, null, new UserHandle(userId))).setDeleteIntent(PendingIntent.getBroadcastAsUser(mContext, 0, deleteIntent, 0, UserHandle.SYSTEM)).build();
                try {
                    int[] outId = new int[1];
                    inm.enqueueNotificationWithTag("android", "android", null, R.string.dump_heap_notification, notification, outId, userId);
                } catch (RuntimeException e) {
                    Slog.w(ActivityManagerService.TAG, "Error showing notification for dump heap", e);
                } catch (RemoteException e) {
                }
            }
            break;
        case DELETE_DUMPHEAP_MSG:
            {
                revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                synchronized (ActivityManagerService.this) {
                    mMemWatchDumpFile = null;
                    mMemWatchDumpProcName = null;
                    mMemWatchDumpPid = -1;
                    mMemWatchDumpUid = -1;
                }
            }
            break;
        case FOREGROUND_PROFILE_CHANGED_MSG:
            {
                mUserController.dispatchForegroundProfileChanged(msg.arg1);
            }
            break;
        case REPORT_TIME_TRACKER_MSG:
            {
                AppTimeTracker tracker = (AppTimeTracker) msg.obj;
                tracker.deliverResult(mContext);
            }
            break;
        case REPORT_USER_SWITCH_COMPLETE_MSG:
            {
                mUserController.dispatchUserSwitchComplete(msg.arg1);
            }
            break;
        case SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG:
            {
                IUiAutomationConnection connection = (IUiAutomationConnection) msg.obj;
                try {
                    connection.shutdown();
                } catch (RemoteException e) {
                    Slog.w(TAG, "Error shutting down UiAutomationConnection");
                }
                // Only a UiAutomation can set this flag and now that
                // it is finished we make sure it is reset to its default.
                mUserIsMonkey = false;
            }
            break;
        case APP_BOOST_DEACTIVATE_MSG:
            {
                synchronized (ActivityManagerService.this) {
                    if (mIsBoosted) {
                        if (mBoostStartTime < (SystemClock.uptimeMillis() - APP_BOOST_TIMEOUT)) {
                            nativeMigrateFromBoost();
                            mIsBoosted = false;
                            mBoostStartTime = 0;
                        } else {
                            Message newmsg = mHandler.obtainMessage(APP_BOOST_DEACTIVATE_MSG);
                            mHandler.sendMessageDelayed(newmsg, APP_BOOST_TIMEOUT);
                        }
                    }
                }
            }
            break;
        case IDLE_UIDS_MSG:
            {
                idleUids();
            }
            break;
        case LOG_STACK_STATE:
            {
                synchronized (ActivityManagerService.this) {
                    mStackSupervisor.logStackState();
                }
            }
            break;
        case VR_MODE_CHANGE_MSG:
            {
                VrManagerInternal vrService = LocalServices.getService(VrManagerInternal.class);
                final ActivityRecord r = (ActivityRecord) msg.obj;
                boolean vrMode;
                ComponentName requestedPackage;
                ComponentName callingPackage;
                int userId;
                synchronized (ActivityManagerService.this) {
                    vrMode = r.requestedVrComponent != null;
                    requestedPackage = r.requestedVrComponent;
                    userId = r.userId;
                    callingPackage = r.info.getComponentName();
                    if (mInVrMode != vrMode) {
                        mInVrMode = vrMode;
                        mShowDialogs = shouldShowDialogs(mConfiguration, mInVrMode);
                    }
                }
                vrService.setVrMode(vrMode, requestedPackage, userId, callingPackage);
            }
            break;
        case VR_MODE_APPLY_IF_NEEDED_MSG:
            {
                final ActivityRecord r = (ActivityRecord) msg.obj;
                final boolean needsVrMode = r != null && r.requestedVrComponent != null;
                if (needsVrMode) {
                    applyVrMode(msg.arg1 == 1, r.requestedVrComponent, r.userId, r.info.getComponentName(), false);
                }
            }
            break;
    }
}
#end_block

#method_before
public void setSystemProcess() {
    try {
        ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);
        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);
        ServiceManager.addService("meminfo", new MemBinder(this));
        ServiceManager.addService("gfxinfo", new GraphicsBinder(this));
        ServiceManager.addService("dbinfo", new DbBinder(this));
        if (MONITOR_CPU_USAGE) {
            ServiceManager.addService("cpuinfo", new CpuBinder(this));
        }
        ServiceManager.addService("permission", new PermissionController(this));
        ServiceManager.addService("processinfo", new ProcessInfoService(this));
        ApplicationInfo info = mContext.getPackageManager().getApplicationInfo("android", STOCK_PM_FLAGS);
        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());
        synchronized (this) {
            ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);
            app.persistent = true;
            app.pid = MY_PID;
            app.maxAdj = ProcessList.SYSTEM_ADJ;
            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);
            synchronized (mPidsSelfLocked) {
                mPidsSelfLocked.put(app.pid, app);
            }
            updateLruProcessLocked(app, false, null);
            updateOomAdjLocked();
        }
    } catch (PackageManager.NameNotFoundException e) {
        throw new RuntimeException("Unable to find android system package", e);
    }
}
#method_after
public void setSystemProcess() {
    try {
        ServiceManager.addService(Context.ACTIVITY_SERVICE, this, true);
        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);
        ServiceManager.addService("meminfo", new MemBinder(this));
        ServiceManager.addService("gfxinfo", new GraphicsBinder(this));
        ServiceManager.addService("dbinfo", new DbBinder(this));
        if (MONITOR_CPU_USAGE) {
            ServiceManager.addService("cpuinfo", new CpuBinder(this));
        }
        ServiceManager.addService("permission", new PermissionController(this));
        ServiceManager.addService("processinfo", new ProcessInfoService(this));
        ApplicationInfo info = mContext.getPackageManager().getApplicationInfo("android", STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);
        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());
        synchronized (this) {
            ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0);
            app.persistent = true;
            app.pid = MY_PID;
            app.maxAdj = ProcessList.SYSTEM_ADJ;
            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);
            synchronized (mPidsSelfLocked) {
                mPidsSelfLocked.put(app.pid, app);
            }
            updateLruProcessLocked(app, false, null);
            updateOomAdjLocked();
        }
    } catch (PackageManager.NameNotFoundException e) {
        throw new RuntimeException("Unable to find android system package", e);
    }
}
#end_block

#method_before
public void setWindowManager(WindowManagerService wm) {
    mWindowManager = wm;
    mStackSupervisor.setWindowManager(wm);
}
#method_after
public void setWindowManager(WindowManagerService wm) {
    mWindowManager = wm;
    mStackSupervisor.setWindowManager(wm);
    mActivityStarter.setWindowManager(wm);
}
#end_block

#method_before
final void setFocusedActivityLocked(ActivityRecord r, String reason) {
    if (r != null && mFocusedActivity != r) {
        if (DEBUG_FOCUS)
            Slog.d(TAG_FOCUS, "setFocusedActivityLocked: r=" + r);
        ActivityRecord last = mFocusedActivity;
        mFocusedActivity = r;
        if (r.task.taskType != ActivityRecord.HOME_ACTIVITY_TYPE && r.task.taskType != ActivityRecord.RECENTS_ACTIVITY_TYPE) {
            if (mCurAppTimeTracker != r.appTimeTracker) {
                // We are switching app tracking.  Complete the current one.
                if (mCurAppTimeTracker != null) {
                    mCurAppTimeTracker.stop();
                    mHandler.obtainMessage(REPORT_TIME_TRACKER_MSG, mCurAppTimeTracker).sendToTarget();
                    mStackSupervisor.clearOtherAppTimeTrackers(r.appTimeTracker);
                    mCurAppTimeTracker = null;
                }
                if (r.appTimeTracker != null) {
                    mCurAppTimeTracker = r.appTimeTracker;
                    startTimeTrackingFocusedActivityLocked();
                }
            } else {
                startTimeTrackingFocusedActivityLocked();
            }
        } else {
            r.appTimeTracker = null;
        }
        if (r.task != null && r.task.voiceInteractor != null) {
            startRunningVoiceLocked(r.task.voiceSession, r.info.applicationInfo.uid);
        } else {
            finishRunningVoiceLocked();
            if (last != null && last.task.voiceSession != null) {
                // We had been in a voice interaction session, but now focused has
                // move to something different.  Just finish the session, we can't
                // return to it and retain the proper state and synchronization with
                // the voice interaction service.
                finishVoiceTask(last.task.voiceSession);
            }
        }
        if (mStackSupervisor.setFocusedStack(r, reason + " setFocusedActivity")) {
            mWindowManager.setFocusedApp(r.appToken, true);
        }
        applyUpdateLockStateLocked(r);
        if (mFocusedActivity.userId != mLastFocusedUserId) {
            mHandler.removeMessages(FOREGROUND_PROFILE_CHANGED_MSG);
            mHandler.sendMessage(mHandler.obtainMessage(FOREGROUND_PROFILE_CHANGED_MSG, mFocusedActivity.userId, 0));
            mLastFocusedUserId = mFocusedActivity.userId;
        }
    }
    EventLog.writeEvent(EventLogTags.AM_FOCUSED_ACTIVITY, mFocusedActivity == null ? -1 : mFocusedActivity.userId, mFocusedActivity == null ? "NULL" : mFocusedActivity.shortComponentName);
}
#method_after
boolean setFocusedActivityLocked(ActivityRecord r, String reason) {
    if (r == null || mFocusedActivity == r) {
        return false;
    }
    if (!r.isFocusable()) {
        if (DEBUG_FOCUS)
            Slog.d(TAG_FOCUS, "setFocusedActivityLocked: unfocusable r=" + r);
        return false;
    }
    if (DEBUG_FOCUS)
        Slog.d(TAG_FOCUS, "setFocusedActivityLocked: r=" + r);
    final boolean wasDoingSetFocusedActivity = mDoingSetFocusedActivity;
    if (wasDoingSetFocusedActivity)
        Slog.w(TAG, "setFocusedActivityLocked: called recursively, r=" + r + ", reason=" + reason);
    mDoingSetFocusedActivity = true;
    final ActivityRecord last = mFocusedActivity;
    mFocusedActivity = r;
    if (r.task.isApplicationTask()) {
        if (mCurAppTimeTracker != r.appTimeTracker) {
            // We are switching app tracking.  Complete the current one.
            if (mCurAppTimeTracker != null) {
                mCurAppTimeTracker.stop();
                mHandler.obtainMessage(REPORT_TIME_TRACKER_MSG, mCurAppTimeTracker).sendToTarget();
                mStackSupervisor.clearOtherAppTimeTrackers(r.appTimeTracker);
                mCurAppTimeTracker = null;
            }
            if (r.appTimeTracker != null) {
                mCurAppTimeTracker = r.appTimeTracker;
                startTimeTrackingFocusedActivityLocked();
            }
        } else {
            startTimeTrackingFocusedActivityLocked();
        }
    } else {
        r.appTimeTracker = null;
    }
    // back to this activity
    if (r.task.voiceInteractor != null) {
        startRunningVoiceLocked(r.task.voiceSession, r.info.applicationInfo.uid);
    } else {
        finishRunningVoiceLocked();
        IVoiceInteractionSession session;
        if (last != null && ((session = last.task.voiceSession) != null || (session = last.voiceSession) != null)) {
            // We had been in a voice interaction session, but now focused has
            // move to something different.  Just finish the session, we can't
            // return to it and retain the proper state and synchronization with
            // the voice interaction service.
            finishVoiceTask(session);
        }
    }
    if (mStackSupervisor.moveActivityStackToFront(r, reason + " setFocusedActivity")) {
        mWindowManager.setFocusedApp(r.appToken, true);
    }
    applyUpdateLockStateLocked(r);
    applyUpdateVrModeLocked(r);
    if (mFocusedActivity.userId != mLastFocusedUserId) {
        mHandler.removeMessages(FOREGROUND_PROFILE_CHANGED_MSG);
        mHandler.obtainMessage(FOREGROUND_PROFILE_CHANGED_MSG, mFocusedActivity.userId, 0).sendToTarget();
        mLastFocusedUserId = mFocusedActivity.userId;
    }
    // indicate a problem of the focus setting logic!
    if (mFocusedActivity != r)
        Slog.w(TAG, "setFocusedActivityLocked: r=" + r + " but focused to " + mFocusedActivity);
    mDoingSetFocusedActivity = wasDoingSetFocusedActivity;
    EventLogTags.writeAmFocusedActivity(mFocusedActivity == null ? -1 : mFocusedActivity.userId, mFocusedActivity == null ? "NULL" : mFocusedActivity.shortComponentName, reason);
    return true;
}
#end_block

#method_before
@Override
public void setFocusedStack(int stackId) {
    if (DEBUG_FOCUS)
        Slog.d(TAG_FOCUS, "setFocusedStack: stackId=" + stackId);
    synchronized (ActivityManagerService.this) {
        ActivityStack stack = mStackSupervisor.getStack(stackId);
        if (stack != null) {
            ActivityRecord r = stack.topRunningActivityLocked(null);
            if (r != null) {
                setFocusedActivityLocked(r, "setFocusedStack");
                mStackSupervisor.resumeTopActivitiesLocked(stack, null, null);
            }
        }
    }
}
#method_after
@Override
public void setFocusedStack(int stackId) {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "setFocusedStack()");
    if (DEBUG_FOCUS)
        Slog.d(TAG_FOCUS, "setFocusedStack: stackId=" + stackId);
    final long callingId = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            final ActivityStack stack = mStackSupervisor.getStack(stackId);
            if (stack == null) {
                return;
            }
            final ActivityRecord r = stack.topRunningActivityLocked();
            if (setFocusedActivityLocked(r, "setFocusedStack")) {
                mStackSupervisor.resumeFocusedStackTopActivityLocked();
            }
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#end_block

#method_before
@Override
public void registerTaskStackListener(ITaskStackListener listener) throws RemoteException {
    synchronized (ActivityManagerService.this) {
        if (listener != null) {
            mTaskStackListeners.register(listener);
        }
    }
}
#method_after
@Override
public void registerTaskStackListener(ITaskStackListener listener) throws RemoteException {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "registerTaskStackListener()");
    synchronized (this) {
        if (listener != null) {
            mTaskStackListeners.register(listener);
        }
    }
}
#end_block

#method_before
final void showAskCompatModeDialogLocked(ActivityRecord r) {
    Message msg = Message.obtain();
    msg.what = SHOW_COMPAT_MODE_DIALOG_MSG;
    msg.obj = r.task.askedCompatMode ? null : r;
    mUiHandler.sendMessage(msg);
}
#method_after
final void showAskCompatModeDialogLocked(ActivityRecord r) {
    Message msg = Message.obtain();
    msg.what = SHOW_COMPAT_MODE_DIALOG_UI_MSG;
    msg.obj = r.task.askedCompatMode ? null : r;
    mUiHandler.sendMessage(msg);
}
#end_block

#method_before
private static void killProcessGroup(int uid, int pid) {
    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "killProcessGroup");
    Process.killProcessGroup(uid, pid);
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
}
#method_after
static void killProcessGroup(int uid, int pid) {
    if (sKillHandler != null) {
        sKillHandler.sendMessage(sKillHandler.obtainMessage(KillHandler.KILL_PROCESS_GROUP_MSG, uid, pid));
    } else {
        Slog.w(TAG, "Asked to kill process group before system bringup!");
        Process.killProcessGroup(uid, pid);
    }
}
#end_block

#method_before
final void removeLruProcessLocked(ProcessRecord app) {
    int lrui = mLruProcesses.lastIndexOf(app);
    if (lrui >= 0) {
        if (!app.killed) {
            Slog.wtfStack(TAG, "Removing process that hasn't been killed: " + app);
            Process.killProcessQuiet(app.pid);
            killProcessGroup(app.info.uid, app.pid);
        }
        if (lrui <= mLruProcessActivityStart) {
            mLruProcessActivityStart--;
        }
        if (lrui <= mLruProcessServiceStart) {
            mLruProcessServiceStart--;
        }
        mLruProcesses.remove(lrui);
    }
}
#method_after
final void removeLruProcessLocked(ProcessRecord app) {
    int lrui = mLruProcesses.lastIndexOf(app);
    if (lrui >= 0) {
        if (!app.killed) {
            Slog.wtfStack(TAG, "Removing process that hasn't been killed: " + app);
            Process.killProcessQuiet(app.pid);
            killProcessGroup(app.uid, app.pid);
        }
        if (lrui <= mLruProcessActivityStart) {
            mLruProcessActivityStart--;
        }
        if (lrui <= mLruProcessServiceStart) {
            mLruProcessServiceStart--;
        }
        mLruProcesses.remove(lrui);
    }
}
#end_block

#method_before
boolean isNextTransitionForward() {
    int transit = mWindowManager.getPendingAppTransition();
    return transit == AppTransition.TRANSIT_ACTIVITY_OPEN || transit == AppTransition.TRANSIT_TASK_OPEN || transit == AppTransition.TRANSIT_TASK_TO_FRONT;
}
#method_after
boolean isNextTransitionForward() {
    int transit = mWindowManager.getPendingAppTransition();
    return transit == TRANSIT_ACTIVITY_OPEN || transit == TRANSIT_TASK_OPEN || transit == TRANSIT_TASK_TO_FRONT;
}
#end_block

#method_before
final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) {
    long startTime = SystemClock.elapsedRealtime();
    ProcessRecord app;
    if (!isolated) {
        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);
        checkTime(startTime, "startProcess: after getProcessRecord");
        if ((intentFlags & Intent.FLAG_FROM_BACKGROUND) != 0) {
            // is bad.  If so, we will just silently fail.
            if (mBadProcesses.get(info.processName, info.uid) != null) {
                if (DEBUG_PROCESSES)
                    Slog.v(TAG, "Bad process: " + info.uid + "/" + info.processName);
                return null;
            }
        } else {
            // if it had been bad.
            if (DEBUG_PROCESSES)
                Slog.v(TAG, "Clearing bad process: " + info.uid + "/" + info.processName);
            mProcessCrashTimes.remove(info.processName, info.uid);
            if (mBadProcesses.get(info.processName, info.uid) != null) {
                EventLog.writeEvent(EventLogTags.AM_PROC_GOOD, UserHandle.getUserId(info.uid), info.uid, info.processName);
                mBadProcesses.remove(info.processName, info.uid);
                if (app != null) {
                    app.bad = false;
                }
            }
        }
    } else {
        // If this is an isolated process, it can't re-use an existing process.
        app = null;
    }
    // use cpusets to migrate freshly launched tasks to big cores
    synchronized (ActivityManagerService.this) {
        nativeMigrateToBoost();
        mIsBoosted = true;
        mBoostStartTime = SystemClock.uptimeMillis();
        Message msg = mHandler.obtainMessage(APP_BOOST_DEACTIVATE_MSG);
        mHandler.sendMessageDelayed(msg, APP_BOOST_MESSAGE_DELAY);
    }
    // already running.
    if (DEBUG_PROCESSES)
        Slog.v(TAG_PROCESSES, "startProcess: name=" + processName + " app=" + app + " knownToBeDead=" + knownToBeDead + " thread=" + (app != null ? app.thread : null) + " pid=" + (app != null ? app.pid : -1));
    if (app != null && app.pid > 0) {
        if (!knownToBeDead || app.thread == null) {
            // come up (we have a pid but not yet its thread), so keep it.
            if (DEBUG_PROCESSES)
                Slog.v(TAG_PROCESSES, "App already running: " + app);
            // If this is a new package in the process, add the package to the list
            app.addPackage(info.packageName, info.versionCode, mProcessStats);
            checkTime(startTime, "startProcess: done, added package to proc");
            return app;
        }
        // clean it up now.
        if (DEBUG_PROCESSES || DEBUG_CLEANUP)
            Slog.v(TAG_PROCESSES, "App died: " + app);
        checkTime(startTime, "startProcess: bad proc running, killing");
        killProcessGroup(app.info.uid, app.pid);
        handleAppDiedLocked(app, true, true);
        checkTime(startTime, "startProcess: done killing old proc");
    }
    String hostingNameStr = hostingName != null ? hostingName.flattenToShortString() : null;
    if (app == null) {
        checkTime(startTime, "startProcess: creating new process record");
        app = newProcessRecordLocked(info, processName, isolated, isolatedUid);
        if (app == null) {
            Slog.w(TAG, "Failed making new process record for " + processName + "/" + info.uid + " isolated=" + isolated);
            return null;
        }
        app.crashHandler = crashHandler;
        checkTime(startTime, "startProcess: done creating new process record");
    } else {
        // If this is a new package in the process, add the package to the list
        app.addPackage(info.packageName, info.versionCode, mProcessStats);
        checkTime(startTime, "startProcess: added package to existing proc");
    }
    // process until it is.
    if (!mProcessesReady && !isAllowedWhileBooting(info) && !allowWhileBooting) {
        if (!mProcessesOnHold.contains(app)) {
            mProcessesOnHold.add(app);
        }
        if (DEBUG_PROCESSES)
            Slog.v(TAG_PROCESSES, "System not ready, putting on hold: " + app);
        checkTime(startTime, "startProcess: returning with proc on hold");
        return app;
    }
    checkTime(startTime, "startProcess: stepping in to startProcess");
    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
    checkTime(startTime, "startProcess: done starting proc!");
    return (app.pid != 0) ? app : null;
}
#method_after
final ProcessRecord startProcessLocked(String processName, ApplicationInfo info, boolean knownToBeDead, int intentFlags, String hostingType, ComponentName hostingName, boolean allowWhileBooting, boolean isolated, int isolatedUid, boolean keepIfLarge, String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler) {
    long startTime = SystemClock.elapsedRealtime();
    ProcessRecord app;
    if (!isolated) {
        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);
        checkTime(startTime, "startProcess: after getProcessRecord");
        if ((intentFlags & Intent.FLAG_FROM_BACKGROUND) != 0) {
            // is bad.  If so, we will just silently fail.
            if (mAppErrors.isBadProcessLocked(info)) {
                if (DEBUG_PROCESSES)
                    Slog.v(TAG, "Bad process: " + info.uid + "/" + info.processName);
                return null;
            }
        } else {
            // if it had been bad.
            if (DEBUG_PROCESSES)
                Slog.v(TAG, "Clearing bad process: " + info.uid + "/" + info.processName);
            mAppErrors.resetProcessCrashTimeLocked(info);
            if (mAppErrors.isBadProcessLocked(info)) {
                EventLog.writeEvent(EventLogTags.AM_PROC_GOOD, UserHandle.getUserId(info.uid), info.uid, info.processName);
                mAppErrors.clearBadProcessLocked(info);
                if (app != null) {
                    app.bad = false;
                }
            }
        }
    } else {
        // If this is an isolated process, it can't re-use an existing process.
        app = null;
    }
    // app launch boost for big.little configurations
    // use cpusets to migrate freshly launched tasks to big cores
    nativeMigrateToBoost();
    mIsBoosted = true;
    mBoostStartTime = SystemClock.uptimeMillis();
    Message msg = mHandler.obtainMessage(APP_BOOST_DEACTIVATE_MSG);
    mHandler.sendMessageDelayed(msg, APP_BOOST_MESSAGE_DELAY);
    // already running.
    if (DEBUG_PROCESSES)
        Slog.v(TAG_PROCESSES, "startProcess: name=" + processName + " app=" + app + " knownToBeDead=" + knownToBeDead + " thread=" + (app != null ? app.thread : null) + " pid=" + (app != null ? app.pid : -1));
    if (app != null && app.pid > 0) {
        if ((!knownToBeDead && !app.killed) || app.thread == null) {
            // come up (we have a pid but not yet its thread), so keep it.
            if (DEBUG_PROCESSES)
                Slog.v(TAG_PROCESSES, "App already running: " + app);
            // If this is a new package in the process, add the package to the list
            app.addPackage(info.packageName, info.versionCode, mProcessStats);
            checkTime(startTime, "startProcess: done, added package to proc");
            return app;
        }
        // clean it up now.
        if (DEBUG_PROCESSES || DEBUG_CLEANUP)
            Slog.v(TAG_PROCESSES, "App died: " + app);
        checkTime(startTime, "startProcess: bad proc running, killing");
        killProcessGroup(app.uid, app.pid);
        handleAppDiedLocked(app, true, true);
        checkTime(startTime, "startProcess: done killing old proc");
    }
    String hostingNameStr = hostingName != null ? hostingName.flattenToShortString() : null;
    if (app == null) {
        checkTime(startTime, "startProcess: creating new process record");
        app = newProcessRecordLocked(info, processName, isolated, isolatedUid);
        if (app == null) {
            Slog.w(TAG, "Failed making new process record for " + processName + "/" + info.uid + " isolated=" + isolated);
            return null;
        }
        app.crashHandler = crashHandler;
        checkTime(startTime, "startProcess: done creating new process record");
    } else {
        // If this is a new package in the process, add the package to the list
        app.addPackage(info.packageName, info.versionCode, mProcessStats);
        checkTime(startTime, "startProcess: added package to existing proc");
    }
    // process until it is.
    if (!mProcessesReady && !isAllowedWhileBooting(info) && !allowWhileBooting) {
        if (!mProcessesOnHold.contains(app)) {
            mProcessesOnHold.add(app);
        }
        if (DEBUG_PROCESSES)
            Slog.v(TAG_PROCESSES, "System not ready, putting on hold: " + app);
        checkTime(startTime, "startProcess: returning with proc on hold");
        return app;
    }
    checkTime(startTime, "startProcess: stepping in to startProcess");
    startProcessLocked(app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);
    checkTime(startTime, "startProcess: done starting proc!");
    return (app.pid != 0) ? app : null;
}
#end_block

#method_before
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    if (app.pid > 0 && app.pid != MY_PID) {
        checkTime(startTime, "startProcess: removing from pids map");
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        checkTime(startTime, "startProcess: done removing from pids map");
        app.setPid(0);
    }
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    checkTime(startTime, "startProcess: starting to update cpu stats");
    updateCpuStats();
    checkTime(startTime, "startProcess: done updating cpu stats");
    try {
        try {
            if (AppGlobals.getPackageManager().isPackageFrozen(app.info.packageName)) {
                // This is caught below as if we had failed to fork zygote
                throw new RuntimeException("Package " + app.info.packageName + " is frozen!");
            }
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                checkTime(startTime, "startProcess: getting gids from package manager");
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, app.userId);
                MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);
                mountExternal = mountServiceInternal.getExternalStorageMountMode(uid, app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[2];
            } else {
                gids = new int[permGids.length + 2];
                System.arraycopy(permGids, 0, gids, 2, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getUserGid(UserHandle.getUserId(uid));
        }
        checkTime(startTime, "startProcess: building args");
        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopComponent != null && app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL && (app.info.flags & ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int debugFlags = 0;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;
            // Also turn on CheckJNI for debuggable apps. It's quite
            // awkward to turn on otherwise.
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // system is booted in safe mode.
        if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if ("1".equals(SystemProperties.get("debug.checkjni"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String genDebugInfoProperty = SystemProperties.get("debug.generate-debug-info");
        if ("true".equals(genDebugInfoProperty)) {
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if ("1".equals(SystemProperties.get("debug.jni.logging"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if ("1".equals(SystemProperties.get("debug.assert"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
            // Enable all debug flags required by the native debugger.
            // Don't interpret anything
            debugFlags |= Zygote.DEBUG_ALWAYS_JIT;
            // Generate debug info
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            // Disbale optimizations
            debugFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;
            mNativeDebuggingApp = null;
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null)
            entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs);
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        if (app.isolated) {
            mBatteryStatsService.addIsolatedUid(app.uid, app.info.uid);
        }
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(startTime, "startProcess: done updating battery stats");
        EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : "");
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }
        checkTime(startTime, "startProcess: building log message");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(startResult.pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, uid);
        if (!isActivityProcess) {
            buf.append(" [");
            buf.append(entryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(hostingType);
        if (hostingNameStr != null) {
            buf.append(" ");
            buf.append(hostingNameStr);
        }
        Slog.i(TAG, buf.toString());
        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        checkTime(startTime, "startProcess: starting to update pids map");
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(startTime, "startProcess: done updating pids map");
    } catch (RuntimeException e) {
        // XXX do better error recovery.
        app.setPid(0);
        mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
        if (app.isolated) {
            mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
        }
        Slog.e(TAG, "Failure starting process " + app.processName, e);
    }
}
#method_after
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    long startTime = SystemClock.elapsedRealtime();
    if (app.pid > 0 && app.pid != MY_PID) {
        checkTime(startTime, "startProcess: removing from pids map");
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        checkTime(startTime, "startProcess: done removing from pids map");
        app.setPid(0);
    }
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "startProcessLocked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    checkTime(startTime, "startProcess: starting to update cpu stats");
    updateCpuStats();
    checkTime(startTime, "startProcess: done updating cpu stats");
    try {
        try {
            final int userId = UserHandle.getUserId(app.uid);
            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);
        } catch (RemoteException e) {
            throw e.rethrowAsRuntimeException();
        }
        int uid = app.uid;
        int[] gids = null;
        int mountExternal = Zygote.MOUNT_EXTERNAL_NONE;
        if (!app.isolated) {
            int[] permGids = null;
            try {
                checkTime(startTime, "startProcess: getting gids from package manager");
                final IPackageManager pm = AppGlobals.getPackageManager();
                permGids = pm.getPackageGids(app.info.packageName, MATCH_DEBUG_TRIAGED_MISSING, app.userId);
                MountServiceInternal mountServiceInternal = LocalServices.getService(MountServiceInternal.class);
                mountExternal = mountServiceInternal.getExternalStorageMountMode(uid, app.info.packageName);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            /*
                 * Add shared application and profile GIDs so applications can share some
                 * resources like shared libraries and access user-wide resources
                 */
            if (ArrayUtils.isEmpty(permGids)) {
                gids = new int[2];
            } else {
                gids = new int[permGids.length + 2];
                System.arraycopy(permGids, 0, gids, 2, permGids.length);
            }
            gids[0] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));
            gids[1] = UserHandle.getUserGid(UserHandle.getUserId(uid));
        }
        checkTime(startTime, "startProcess: building args");
        if (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) {
            if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopComponent != null && app.processName.equals(mTopComponent.getPackageName())) {
                uid = 0;
            }
            if (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL && (app.info.flags & ApplicationInfo.FLAG_FACTORY_TEST) != 0) {
                uid = 0;
            }
        }
        int debugFlags = 0;
        if ((app.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
            debugFlags |= Zygote.DEBUG_ENABLE_DEBUGGER;
            // Also turn on CheckJNI for debuggable apps. It's quite
            // awkward to turn on otherwise.
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        // system is booted in safe mode.
        if ((app.info.flags & ApplicationInfo.FLAG_VM_SAFE_MODE) != 0 || mSafeMode == true) {
            debugFlags |= Zygote.DEBUG_ENABLE_SAFEMODE;
        }
        if ("1".equals(SystemProperties.get("debug.checkjni"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_CHECKJNI;
        }
        String genDebugInfoProperty = SystemProperties.get("debug.generate-debug-info");
        if ("true".equals(genDebugInfoProperty)) {
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
        }
        if ("1".equals(SystemProperties.get("debug.jni.logging"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_JNI_LOGGING;
        }
        if ("1".equals(SystemProperties.get("debug.assert"))) {
            debugFlags |= Zygote.DEBUG_ENABLE_ASSERT;
        }
        if (mNativeDebuggingApp != null && mNativeDebuggingApp.equals(app.processName)) {
            // Enable all debug flags required by the native debugger.
            // Don't interpret anything
            debugFlags |= Zygote.DEBUG_ALWAYS_JIT;
            // Generate debug info
            debugFlags |= Zygote.DEBUG_GENERATE_DEBUG_INFO;
            // Disbale optimizations
            debugFlags |= Zygote.DEBUG_NATIVE_DEBUGGABLE;
            mNativeDebuggingApp = null;
        }
        String requiredAbi = (abiOverride != null) ? abiOverride : app.info.primaryCpuAbi;
        if (requiredAbi == null) {
            requiredAbi = Build.SUPPORTED_ABIS[0];
        }
        String instructionSet = null;
        if (app.info.primaryCpuAbi != null) {
            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);
        }
        app.gids = gids;
        app.requiredAbi = requiredAbi;
        app.instructionSet = instructionSet;
        // Start the process.  It will either succeed and return a result containing
        // the PID of the new process, or else throw a RuntimeException.
        boolean isActivityProcess = (entryPoint == null);
        if (entryPoint == null)
            entryPoint = "android.app.ActivityThread";
        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "Start proc: " + app.processName);
        checkTime(startTime, "startProcess: asking zygote to start proc");
        Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs);
        checkTime(startTime, "startProcess: returned from zygote!");
        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
        if (app.isolated) {
            mBatteryStatsService.addIsolatedUid(app.uid, app.info.uid);
        }
        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);
        checkTime(startTime, "startProcess: done updating battery stats");
        EventLog.writeEvent(EventLogTags.AM_PROC_START, UserHandle.getUserId(uid), startResult.pid, uid, app.processName, hostingType, hostingNameStr != null ? hostingNameStr : "");
        try {
            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid, app.info.seinfo, app.info.sourceDir, startResult.pid);
        } catch (RemoteException ex) {
        // Ignore
        }
        if (app.persistent) {
            Watchdog.getInstance().processStarted(app.processName, startResult.pid);
        }
        checkTime(startTime, "startProcess: building log message");
        StringBuilder buf = mStringBuilder;
        buf.setLength(0);
        buf.append("Start proc ");
        buf.append(startResult.pid);
        buf.append(':');
        buf.append(app.processName);
        buf.append('/');
        UserHandle.formatUid(buf, uid);
        if (!isActivityProcess) {
            buf.append(" [");
            buf.append(entryPoint);
            buf.append("]");
        }
        buf.append(" for ");
        buf.append(hostingType);
        if (hostingNameStr != null) {
            buf.append(" ");
            buf.append(hostingNameStr);
        }
        Slog.i(TAG, buf.toString());
        app.setPid(startResult.pid);
        app.usingWrapper = startResult.usingWrapper;
        app.removed = false;
        app.killed = false;
        app.killedByAm = false;
        checkTime(startTime, "startProcess: starting to update pids map");
        synchronized (mPidsSelfLocked) {
            this.mPidsSelfLocked.put(startResult.pid, app);
            if (isActivityProcess) {
                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);
                msg.obj = app;
                mHandler.sendMessageDelayed(msg, startResult.usingWrapper ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);
            }
        }
        checkTime(startTime, "startProcess: done updating pids map");
    } catch (RuntimeException e) {
        Slog.e(TAG, "Failure starting process " + app.processName, e);
        // Something went very wrong while trying to start this process; one
        // common case is when the package is frozen due to an active
        // upgrade. To recover, clean up any active bookkeeping related to
        // starting this process. (We already invoked this method once when
        // the package was initially frozen through KILL_APPLICATION_MSG, so
        // it doesn't hurt to use it again.)
        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), false, false, true, false, false, UserHandle.getUserId(app.userId), "start failure");
    }
}
#end_block

#method_before
Intent getHomeIntent() {
    Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        intent.addCategory(Intent.CATEGORY_HOME);
    }
    return intent;
}
#method_after
Intent getHomeIntent() {
    Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);
    intent.setComponent(mTopComponent);
    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
        intent.addCategory(Intent.CATEGORY_HOME);
    }
    return intent;
}
#end_block

#method_before
boolean startHomeActivityLocked(int userId, String reason) {
    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopAction == null) {
        // error message and don't try to start anything.
        return false;
    }
    Intent intent = getHomeIntent();
    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);
    if (aInfo != null) {
        intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
        // Don't do this if the home app is currently being
        // instrumented.
        aInfo = new ActivityInfo(aInfo);
        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);
        ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true);
        if (app == null || app.instrumentationClass == null) {
            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
            mStackSupervisor.startHomeActivity(intent, aInfo, reason);
        }
    }
    return true;
}
#method_after
boolean startHomeActivityLocked(int userId, String reason) {
    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL && mTopAction == null) {
        // error message and don't try to start anything.
        return false;
    }
    Intent intent = getHomeIntent();
    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);
    if (aInfo != null) {
        intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
        // Don't do this if the home app is currently being
        // instrumented.
        aInfo = new ActivityInfo(aInfo);
        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);
        ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true);
        if (app == null || app.instrumentationClass == null) {
            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);
            mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);
        }
    } else {
        Slog.wtf(TAG, "No home screen found for " + intent, new Throwable());
    }
    return true;
}
#end_block

#method_before
void startSetupActivityLocked() {
    // Only do this once per boot.
    if (mCheckedForSetup) {
        return;
    }
    // We will show this screen if the current one is a different
    // version than the last one shown, and we are not running in
    // low-level factory test mode.
    final ContentResolver resolver = mContext.getContentResolver();
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL && Settings.Global.getInt(resolver, Settings.Global.DEVICE_PROVISIONED, 0) != 0) {
        mCheckedForSetup = true;
        // See if we should be showing the platform update setup UI.
        Intent intent = new Intent(Intent.ACTION_UPGRADE_SETUP);
        List<ResolveInfo> ris = mContext.getPackageManager().queryIntentActivities(intent, PackageManager.GET_META_DATA);
        // We don't allow third party apps to replace this.
        ResolveInfo ri = null;
        for (int i = 0; ris != null && i < ris.size(); i++) {
            if ((ris.get(i).activityInfo.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
                ri = ris.get(i);
                break;
            }
        }
        if (ri != null) {
            String vers = ri.activityInfo.metaData != null ? ri.activityInfo.metaData.getString(Intent.METADATA_SETUP_VERSION) : null;
            if (vers == null && ri.activityInfo.applicationInfo.metaData != null) {
                vers = ri.activityInfo.applicationInfo.metaData.getString(Intent.METADATA_SETUP_VERSION);
            }
            String lastVers = Settings.Secure.getString(resolver, Settings.Secure.LAST_SETUP_SHOWN);
            if (vers != null && !vers.equals(lastVers)) {
                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                intent.setComponent(new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name));
                mStackSupervisor.startActivityLocked(null, intent, null, ri.activityInfo, null, null, null, null, 0, 0, 0, null, 0, 0, 0, null, false, false, null, null, null);
            }
        }
    }
}
#method_after
void startSetupActivityLocked() {
    // Only do this once per boot.
    if (mCheckedForSetup) {
        return;
    }
    // We will show this screen if the current one is a different
    // version than the last one shown, and we are not running in
    // low-level factory test mode.
    final ContentResolver resolver = mContext.getContentResolver();
    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL && Settings.Global.getInt(resolver, Settings.Global.DEVICE_PROVISIONED, 0) != 0) {
        mCheckedForSetup = true;
        // See if we should be showing the platform update setup UI.
        final Intent intent = new Intent(Intent.ACTION_UPGRADE_SETUP);
        final List<ResolveInfo> ris = mContext.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_SYSTEM_ONLY | PackageManager.GET_META_DATA);
        if (!ris.isEmpty()) {
            final ResolveInfo ri = ris.get(0);
            String vers = ri.activityInfo.metaData != null ? ri.activityInfo.metaData.getString(Intent.METADATA_SETUP_VERSION) : null;
            if (vers == null && ri.activityInfo.applicationInfo.metaData != null) {
                vers = ri.activityInfo.applicationInfo.metaData.getString(Intent.METADATA_SETUP_VERSION);
            }
            String lastVers = Settings.Secure.getString(resolver, Settings.Secure.LAST_SETUP_SHOWN);
            if (vers != null && !vers.equals(lastVers)) {
                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                intent.setComponent(new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name));
                mActivityStarter.startActivityLocked(null, intent, null, /*ephemeralIntent*/
                null, ri.activityInfo, null, /*rInfo*/
                null, null, null, null, 0, 0, 0, null, 0, 0, 0, null, false, false, null, null, null);
            }
        }
    }
}
#end_block

#method_before
void enforceShellRestriction(String restriction, int userHandle) {
    if (Binder.getCallingUid() == Process.SHELL_UID) {
        if (userHandle < 0 || mUserManager.hasUserRestriction(restriction, userHandle)) {
            throw new SecurityException("Shell does not have permission to access user " + userHandle);
        }
    }
}
#method_after
void enforceShellRestriction(String restriction, int userHandle) {
    if (Binder.getCallingUid() == Process.SHELL_UID) {
        if (userHandle < 0 || mUserController.hasUserRestriction(restriction, userHandle)) {
            throw new SecurityException("Shell does not have permission to access user " + userHandle);
        }
    }
}
#end_block

#method_before
private void dispatchUidsChanged() {
    int N;
    synchronized (this) {
        N = mPendingUidChanges.size();
        if (mActiveUidChanges.length < N) {
            mActiveUidChanges = new UidRecord.ChangeItem[N];
        }
        for (int i = 0; i < N; i++) {
            final UidRecord.ChangeItem change = mPendingUidChanges.get(i);
            mActiveUidChanges[i] = change;
            change.uidRecord.pendingChange = null;
            change.uidRecord = null;
        }
        mPendingUidChanges.clear();
        if (DEBUG_UID_OBSERVERS)
            Slog.i(TAG_UID_OBSERVERS, "*** Delivering " + N + " uid changes");
    }
    if (mLocalPowerManager != null) {
        for (int j = 0; j < N; j++) {
            UidRecord.ChangeItem item = mActiveUidChanges[j];
            if (item.gone) {
                mLocalPowerManager.uidGone(item.uid);
            } else {
                mLocalPowerManager.updateUidProcState(item.uid, item.processState);
            }
        }
    }
    int i = mUidObservers.beginBroadcast();
    while (i > 0) {
        i--;
        final IUidObserver observer = mUidObservers.getBroadcastItem(i);
        if (observer != null) {
            try {
                for (int j = 0; j < N; j++) {
                    UidRecord.ChangeItem item = mActiveUidChanges[j];
                    if (item.gone) {
                        if (DEBUG_UID_OBSERVERS)
                            Slog.i(TAG_UID_OBSERVERS, "UID gone uid=" + item.uid);
                        observer.onUidGone(item.uid);
                    } else {
                        if (DEBUG_UID_OBSERVERS)
                            Slog.i(TAG_UID_OBSERVERS, "UID CHANGED uid=" + item.uid + ": " + item.processState);
                        observer.onUidStateChanged(item.uid, item.processState);
                    }
                }
            } catch (RemoteException e) {
            }
        }
    }
    mUidObservers.finishBroadcast();
    synchronized (this) {
        for (int j = 0; j < N; j++) {
            mAvailUidChanges.add(mActiveUidChanges[j]);
        }
    }
}
#method_after
private void dispatchUidsChanged() {
    int N;
    synchronized (this) {
        N = mPendingUidChanges.size();
        if (mActiveUidChanges.length < N) {
            mActiveUidChanges = new UidRecord.ChangeItem[N];
        }
        for (int i = 0; i < N; i++) {
            final UidRecord.ChangeItem change = mPendingUidChanges.get(i);
            mActiveUidChanges[i] = change;
            if (change.uidRecord != null) {
                change.uidRecord.pendingChange = null;
                change.uidRecord = null;
            }
        }
        mPendingUidChanges.clear();
        if (DEBUG_UID_OBSERVERS)
            Slog.i(TAG_UID_OBSERVERS, "*** Delivering " + N + " uid changes");
    }
    if (mLocalPowerManager != null) {
        for (int j = 0; j < N; j++) {
            UidRecord.ChangeItem item = mActiveUidChanges[j];
            if (item.change == UidRecord.CHANGE_GONE || item.change == UidRecord.CHANGE_GONE_IDLE) {
                mLocalPowerManager.uidGone(item.uid);
            } else {
                mLocalPowerManager.updateUidProcState(item.uid, item.processState);
            }
        }
    }
    int i = mUidObservers.beginBroadcast();
    while (i > 0) {
        i--;
        final IUidObserver observer = mUidObservers.getBroadcastItem(i);
        final int which = (Integer) mUidObservers.getBroadcastCookie(i);
        if (observer != null) {
            try {
                for (int j = 0; j < N; j++) {
                    UidRecord.ChangeItem item = mActiveUidChanges[j];
                    final int change = item.change;
                    UidRecord validateUid = null;
                    if (VALIDATE_UID_STATES && i == 0) {
                        validateUid = mValidateUids.get(item.uid);
                        if (validateUid == null && change != UidRecord.CHANGE_GONE && change != UidRecord.CHANGE_GONE_IDLE) {
                            validateUid = new UidRecord(item.uid);
                            mValidateUids.put(item.uid, validateUid);
                        }
                    }
                    if (change == UidRecord.CHANGE_IDLE || change == UidRecord.CHANGE_GONE_IDLE) {
                        if ((which & ActivityManager.UID_OBSERVER_IDLE) != 0) {
                            if (DEBUG_UID_OBSERVERS)
                                Slog.i(TAG_UID_OBSERVERS, "UID idle uid=" + item.uid);
                            observer.onUidIdle(item.uid);
                        }
                        if (VALIDATE_UID_STATES && i == 0) {
                            if (validateUid != null) {
                                validateUid.idle = true;
                            }
                        }
                    } else if (change == UidRecord.CHANGE_ACTIVE) {
                        if ((which & ActivityManager.UID_OBSERVER_ACTIVE) != 0) {
                            if (DEBUG_UID_OBSERVERS)
                                Slog.i(TAG_UID_OBSERVERS, "UID active uid=" + item.uid);
                            observer.onUidActive(item.uid);
                        }
                        if (VALIDATE_UID_STATES && i == 0) {
                            validateUid.idle = false;
                        }
                    }
                    if (change == UidRecord.CHANGE_GONE || change == UidRecord.CHANGE_GONE_IDLE) {
                        if ((which & ActivityManager.UID_OBSERVER_GONE) != 0) {
                            if (DEBUG_UID_OBSERVERS)
                                Slog.i(TAG_UID_OBSERVERS, "UID gone uid=" + item.uid);
                            observer.onUidGone(item.uid);
                        }
                        if (VALIDATE_UID_STATES && i == 0) {
                            if (validateUid != null) {
                                mValidateUids.remove(item.uid);
                            }
                        }
                    } else {
                        if ((which & ActivityManager.UID_OBSERVER_PROCSTATE) != 0) {
                            if (DEBUG_UID_OBSERVERS)
                                Slog.i(TAG_UID_OBSERVERS, "UID CHANGED uid=" + item.uid + ": " + item.processState);
                            observer.onUidStateChanged(item.uid, item.processState);
                        }
                        if (VALIDATE_UID_STATES && i == 0) {
                            validateUid.curProcState = validateUid.setProcState = item.processState;
                        }
                    }
                }
            } catch (RemoteException e) {
            }
        }
    }
    mUidObservers.finishBroadcast();
    synchronized (this) {
        for (int j = 0; j < N; j++) {
            mAvailUidChanges.add(mActiveUidChanges[j]);
        }
    }
}
#end_block

#method_before
@Override
public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) {
    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());
}
#method_after
@Override
public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions) {
    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions, UserHandle.getCallingUserId());
}
#end_block

#method_before
@Override
public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) {
    return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());
}
#method_after
final int startActivity(Intent intent, ActivityStackSupervisor.ActivityContainer container) {
    enforceNotIsolatedCaller("ActivityContainer.startActivity");
    final int userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), mStackSupervisor.mCurrentUser, false, ActivityManagerService.ALLOW_FULL_ONLY, "ActivityContainer", null);
    // TODO: Switch to user app stacks here.
    String mimeType = intent.getType();
    final Uri data = intent.getData();
    if (mimeType == null && data != null && "content".equals(data.getScheme())) {
        mimeType = getProviderMimeType(data, userId);
    }
    container.checkEmbeddedAllowedInner(userId, intent, mimeType);
    intent.addFlags(FORCE_NEW_TASK_FLAGS);
    return mActivityStarter.startActivityMayWait(null, -1, null, intent, mimeType, null, null, null, null, 0, 0, null, null, null, null, false, userId, container, null);
}
#end_block

#method_before
@Override
public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
    enforceNotIsolatedCaller("startActivity");
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null);
    // TODO: Switch to user app stacks here.
    return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null);
}
#method_after
@Override
public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
    enforceNotIsolatedCaller("startActivity");
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null);
    // TODO: Switch to user app stacks here.
    return mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null);
}
#end_block

#method_before
@Override
public final int startActivityAsCaller(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, boolean ignoreTargetSecurity, int userId) {
    // This is very dangerous -- it allows you to perform a start activity (including
    // permission grants) as any app that may launch one of your own activities.  So
    // we will only allow this to be done from activities that are part of the core framework,
    // and then only when they are running as the system.
    final ActivityRecord sourceRecord;
    final int targetUid;
    final String targetPackage;
    synchronized (this) {
        if (resultTo == null) {
            throw new SecurityException("Must be called from an activity");
        }
        sourceRecord = mStackSupervisor.isInAnyStackLocked(resultTo);
        if (sourceRecord == null) {
            throw new SecurityException("Called with bad activity token: " + resultTo);
        }
        if (!sourceRecord.info.packageName.equals("android")) {
            throw new SecurityException("Must be called from an activity that is declared in the android package");
        }
        if (sourceRecord.app == null) {
            throw new SecurityException("Called without a process attached to activity");
        }
        if (UserHandle.getAppId(sourceRecord.app.uid) != Process.SYSTEM_UID) {
            // uid of the original calling activity.
            if (sourceRecord.app.uid != sourceRecord.launchedFromUid) {
                throw new SecurityException("Calling activity in uid " + sourceRecord.app.uid + " must be system uid or original calling uid " + sourceRecord.launchedFromUid);
            }
        }
        if (ignoreTargetSecurity) {
            if (intent.getComponent() == null) {
                throw new SecurityException("Component must be specified with ignoreTargetSecurity");
            }
            if (intent.getSelector() != null) {
                throw new SecurityException("Selector not allowed with ignoreTargetSecurity");
            }
        }
        targetUid = sourceRecord.launchedFromUid;
        targetPackage = sourceRecord.launchedFromPackage;
    }
    if (userId == UserHandle.USER_NULL) {
        userId = UserHandle.getUserId(sourceRecord.app.uid);
    }
    // TODO: Switch to user app stacks here.
    try {
        int ret = mStackSupervisor.startActivityMayWait(null, targetUid, targetPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, null, options, ignoreTargetSecurity, userId, null, null);
        return ret;
    } catch (SecurityException e) {
        /*
            StringBuilder msg = new StringBuilder();
            msg.append("While launching");
            msg.append(intent.toString());
            msg.append(": ");
            msg.append(e.getMessage());
            */
        throw e;
    }
}
#method_after
@Override
public final int startActivityAsCaller(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, boolean ignoreTargetSecurity, int userId) {
    // This is very dangerous -- it allows you to perform a start activity (including
    // permission grants) as any app that may launch one of your own activities.  So
    // we will only allow this to be done from activities that are part of the core framework,
    // and then only when they are running as the system.
    final ActivityRecord sourceRecord;
    final int targetUid;
    final String targetPackage;
    synchronized (this) {
        if (resultTo == null) {
            throw new SecurityException("Must be called from an activity");
        }
        sourceRecord = mStackSupervisor.isInAnyStackLocked(resultTo);
        if (sourceRecord == null) {
            throw new SecurityException("Called with bad activity token: " + resultTo);
        }
        if (!sourceRecord.info.packageName.equals("android")) {
            throw new SecurityException("Must be called from an activity that is declared in the android package");
        }
        if (sourceRecord.app == null) {
            throw new SecurityException("Called without a process attached to activity");
        }
        if (UserHandle.getAppId(sourceRecord.app.uid) != Process.SYSTEM_UID) {
            // uid of the original calling activity.
            if (sourceRecord.app.uid != sourceRecord.launchedFromUid) {
                throw new SecurityException("Calling activity in uid " + sourceRecord.app.uid + " must be system uid or original calling uid " + sourceRecord.launchedFromUid);
            }
        }
        if (ignoreTargetSecurity) {
            if (intent.getComponent() == null) {
                throw new SecurityException("Component must be specified with ignoreTargetSecurity");
            }
            if (intent.getSelector() != null) {
                throw new SecurityException("Selector not allowed with ignoreTargetSecurity");
            }
        }
        targetUid = sourceRecord.launchedFromUid;
        targetPackage = sourceRecord.launchedFromPackage;
    }
    if (userId == UserHandle.USER_NULL) {
        userId = UserHandle.getUserId(sourceRecord.app.uid);
    }
    // TODO: Switch to user app stacks here.
    try {
        int ret = mActivityStarter.startActivityMayWait(null, targetUid, targetPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, null, bOptions, ignoreTargetSecurity, userId, null, null);
        return ret;
    } catch (SecurityException e) {
        /*
            StringBuilder msg = new StringBuilder();
            msg.append("While launching");
            msg.append(intent.toString());
            msg.append(": ");
            msg.append(e.getMessage());
            */
        throw e;
    }
}
#end_block

#method_before
@Override
public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
    enforceNotIsolatedCaller("startActivityAndWait");
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivityAndWait", null);
    WaitResult res = new WaitResult();
    // TODO: Switch to user app stacks here.
    mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, res, null, options, false, userId, null, null);
    return res;
}
#method_after
@Override
public final WaitResult startActivityAndWait(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
    enforceNotIsolatedCaller("startActivityAndWait");
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivityAndWait", null);
    WaitResult res = new WaitResult();
    // TODO: Switch to user app stacks here.
    mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, res, null, bOptions, false, userId, null, null);
    return res;
}
#end_block

#method_before
@Override
public final int startActivityWithConfig(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, Configuration config, Bundle options, int userId) {
    enforceNotIsolatedCaller("startActivityWithConfig");
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivityWithConfig", null);
    // TODO: Switch to user app stacks here.
    int ret = mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, config, options, false, userId, null, null);
    return ret;
}
#method_after
@Override
public final int startActivityWithConfig(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, Configuration config, Bundle bOptions, int userId) {
    enforceNotIsolatedCaller("startActivityWithConfig");
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivityWithConfig", null);
    // TODO: Switch to user app stacks here.
    int ret = mActivityStarter.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, config, bOptions, false, userId, null, null);
    return ret;
}
#end_block

#method_before
@Override
public int startActivityIntentSender(IApplicationThread caller, IntentSender intent, Intent fillInIntent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) throws TransactionTooLargeException {
    enforceNotIsolatedCaller("startActivityIntentSender");
    // Refuse possible leaked file descriptors
    if (fillInIntent != null && fillInIntent.hasFileDescriptors()) {
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }
    IIntentSender sender = intent.getTarget();
    if (!(sender instanceof PendingIntentRecord)) {
        throw new IllegalArgumentException("Bad PendingIntent object");
    }
    PendingIntentRecord pir = (PendingIntentRecord) sender;
    synchronized (this) {
        // If this is coming from the currently resumed activity, it is
        // effectively saying that app switches are allowed at this point.
        final ActivityStack stack = getFocusedStack();
        if (stack.mResumedActivity != null && stack.mResumedActivity.info.applicationInfo.uid == Binder.getCallingUid()) {
            mAppSwitchesAllowedTime = 0;
        }
    }
    int ret = pir.sendInner(0, fillInIntent, resolvedType, null, null, resultTo, resultWho, requestCode, flagsMask, flagsValues, options, null);
    return ret;
}
#method_after
@Override
public int startActivityIntentSender(IApplicationThread caller, IntentSender intent, Intent fillInIntent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle bOptions) throws TransactionTooLargeException {
    enforceNotIsolatedCaller("startActivityIntentSender");
    // Refuse possible leaked file descriptors
    if (fillInIntent != null && fillInIntent.hasFileDescriptors()) {
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }
    IIntentSender sender = intent.getTarget();
    if (!(sender instanceof PendingIntentRecord)) {
        throw new IllegalArgumentException("Bad PendingIntent object");
    }
    PendingIntentRecord pir = (PendingIntentRecord) sender;
    synchronized (this) {
        // If this is coming from the currently resumed activity, it is
        // effectively saying that app switches are allowed at this point.
        final ActivityStack stack = getFocusedStack();
        if (stack.mResumedActivity != null && stack.mResumedActivity.info.applicationInfo.uid == Binder.getCallingUid()) {
            mAppSwitchesAllowedTime = 0;
        }
    }
    int ret = pir.sendInner(0, fillInIntent, resolvedType, null, null, resultTo, resultWho, requestCode, flagsMask, flagsValues, bOptions, null);
    return ret;
}
#end_block

#method_before
@Override
public int startVoiceActivity(String callingPackage, int callingPid, int callingUid, Intent intent, String resolvedType, IVoiceInteractionSession session, IVoiceInteractor interactor, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) {
    if (checkCallingPermission(Manifest.permission.BIND_VOICE_INTERACTION) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: startVoiceActivity() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.BIND_VOICE_INTERACTION;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    if (session == null || interactor == null) {
        throw new NullPointerException("null session or interactor");
    }
    userId = handleIncomingUser(callingPid, callingUid, userId, false, ALLOW_FULL_ONLY, "startVoiceActivity", null);
    // TODO: Switch to user app stacks here.
    return mStackSupervisor.startActivityMayWait(null, callingUid, callingPackage, intent, resolvedType, session, interactor, null, null, 0, startFlags, profilerInfo, null, null, options, false, userId, null, null);
}
#method_after
@Override
public int startVoiceActivity(String callingPackage, int callingPid, int callingUid, Intent intent, String resolvedType, IVoiceInteractionSession session, IVoiceInteractor interactor, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId) {
    if (checkCallingPermission(Manifest.permission.BIND_VOICE_INTERACTION) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: startVoiceActivity() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.BIND_VOICE_INTERACTION;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    if (session == null || interactor == null) {
        throw new NullPointerException("null session or interactor");
    }
    userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, false, ALLOW_FULL_ONLY, "startVoiceActivity", null);
    // TODO: Switch to user app stacks here.
    return mActivityStarter.startActivityMayWait(null, callingUid, callingPackage, intent, resolvedType, session, interactor, null, null, 0, startFlags, profilerInfo, null, null, bOptions, false, userId, null, null);
}
#end_block

#method_before
@Override
public boolean startNextMatchingActivity(IBinder callingActivity, Intent intent, Bundle options) {
    // Refuse possible leaked file descriptors
    if (intent != null && intent.hasFileDescriptors() == true) {
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }
    synchronized (this) {
        final ActivityRecord r = ActivityRecord.isInStackLocked(callingActivity);
        if (r == null) {
            ActivityOptions.abort(options);
            return false;
        }
        if (r.app == null || r.app.thread == null) {
            // The caller is not running...  d'oh!
            ActivityOptions.abort(options);
            return false;
        }
        intent = new Intent(intent);
        // The caller is not allowed to change the data.
        intent.setDataAndType(r.intent.getData(), r.intent.getType());
        // And we are resetting to find the next component...
        intent.setComponent(null);
        final boolean debug = ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);
        ActivityInfo aInfo = null;
        try {
            List<ResolveInfo> resolves = AppGlobals.getPackageManager().queryIntentActivities(intent, r.resolvedType, PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS, UserHandle.getCallingUserId());
            // Look for the original activity in the list...
            final int N = resolves != null ? resolves.size() : 0;
            for (int i = 0; i < N; i++) {
                ResolveInfo rInfo = resolves.get(i);
                if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
                    // We found the current one...  the next matching is
                    // after it.
                    i++;
                    if (i < N) {
                        aInfo = resolves.get(i).activityInfo;
                    }
                    if (debug) {
                        Slog.v(TAG, "Next matching activity: found current " + r.packageName + "/" + r.info.name);
                        Slog.v(TAG, "Next matching activity: next is " + ((aInfo == null) ? "null" : aInfo.packageName + "/" + aInfo.name));
                    }
                    break;
                }
            }
        } catch (RemoteException e) {
        }
        if (aInfo == null) {
            // Nobody who is next!
            ActivityOptions.abort(options);
            if (debug)
                Slog.d(TAG, "Next matching activity: nothing found");
            return false;
        }
        intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
        intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK | Intent.FLAG_ACTIVITY_NEW_TASK));
        // Okay now we need to start the new activity, replacing the
        // currently running activity.  This is a little tricky because
        // we want to start the new one as if the current one is finished,
        // but not finish the current one first so that there is no flicker.
        // And thus...
        final boolean wasFinishing = r.finishing;
        r.finishing = true;
        // Propagate reply information over to the new activity.
        final ActivityRecord resultTo = r.resultTo;
        final String resultWho = r.resultWho;
        final int requestCode = r.requestCode;
        r.resultTo = null;
        if (resultTo != null) {
            resultTo.removeResultsLocked(r, resultWho, requestCode);
        }
        final long origId = Binder.clearCallingIdentity();
        int res = mStackSupervisor.startActivityLocked(r.app.thread, intent, r.resolvedType, aInfo, null, null, resultTo != null ? resultTo.appToken : null, resultWho, requestCode, -1, r.launchedFromUid, r.launchedFromPackage, -1, r.launchedFromUid, 0, options, false, false, null, null, null);
        Binder.restoreCallingIdentity(origId);
        r.finishing = wasFinishing;
        if (res != ActivityManager.START_SUCCESS) {
            return false;
        }
        return true;
    }
}
#method_after
@Override
public boolean startNextMatchingActivity(IBinder callingActivity, Intent intent, Bundle bOptions) {
    // Refuse possible leaked file descriptors
    if (intent != null && intent.hasFileDescriptors() == true) {
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }
    ActivityOptions options = ActivityOptions.fromBundle(bOptions);
    synchronized (this) {
        final ActivityRecord r = ActivityRecord.isInStackLocked(callingActivity);
        if (r == null) {
            ActivityOptions.abort(options);
            return false;
        }
        if (r.app == null || r.app.thread == null) {
            // The caller is not running...  d'oh!
            ActivityOptions.abort(options);
            return false;
        }
        intent = new Intent(intent);
        // The caller is not allowed to change the data.
        intent.setDataAndType(r.intent.getData(), r.intent.getType());
        // And we are resetting to find the next component...
        intent.setComponent(null);
        final boolean debug = ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);
        ActivityInfo aInfo = null;
        try {
            List<ResolveInfo> resolves = AppGlobals.getPackageManager().queryIntentActivities(intent, r.resolvedType, PackageManager.MATCH_DEFAULT_ONLY | STOCK_PM_FLAGS, UserHandle.getCallingUserId()).getList();
            // Look for the original activity in the list...
            final int N = resolves != null ? resolves.size() : 0;
            for (int i = 0; i < N; i++) {
                ResolveInfo rInfo = resolves.get(i);
                if (rInfo.activityInfo.packageName.equals(r.packageName) && rInfo.activityInfo.name.equals(r.info.name)) {
                    // We found the current one...  the next matching is
                    // after it.
                    i++;
                    if (i < N) {
                        aInfo = resolves.get(i).activityInfo;
                    }
                    if (debug) {
                        Slog.v(TAG, "Next matching activity: found current " + r.packageName + "/" + r.info.name);
                        Slog.v(TAG, "Next matching activity: next is " + ((aInfo == null) ? "null" : aInfo.packageName + "/" + aInfo.name));
                    }
                    break;
                }
            }
        } catch (RemoteException e) {
        }
        if (aInfo == null) {
            // Nobody who is next!
            ActivityOptions.abort(options);
            if (debug)
                Slog.d(TAG, "Next matching activity: nothing found");
            return false;
        }
        intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));
        intent.setFlags(intent.getFlags() & ~(Intent.FLAG_ACTIVITY_FORWARD_RESULT | Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_MULTIPLE_TASK | Intent.FLAG_ACTIVITY_NEW_TASK));
        // Okay now we need to start the new activity, replacing the
        // currently running activity.  This is a little tricky because
        // we want to start the new one as if the current one is finished,
        // but not finish the current one first so that there is no flicker.
        // And thus...
        final boolean wasFinishing = r.finishing;
        r.finishing = true;
        // Propagate reply information over to the new activity.
        final ActivityRecord resultTo = r.resultTo;
        final String resultWho = r.resultWho;
        final int requestCode = r.requestCode;
        r.resultTo = null;
        if (resultTo != null) {
            resultTo.removeResultsLocked(r, resultWho, requestCode);
        }
        final long origId = Binder.clearCallingIdentity();
        int res = mActivityStarter.startActivityLocked(r.app.thread, intent, null, /*ephemeralIntent*/
        r.resolvedType, aInfo, null, /*rInfo*/
        null, null, resultTo != null ? resultTo.appToken : null, resultWho, requestCode, -1, r.launchedFromUid, r.launchedFromPackage, -1, r.launchedFromUid, 0, options, false, false, null, null, null);
        Binder.restoreCallingIdentity(origId);
        r.finishing = wasFinishing;
        if (res != ActivityManager.START_SUCCESS) {
            return false;
        }
        return true;
    }
}
#end_block

#method_before
@Override
public final int startActivityFromRecents(int taskId, Bundle options) {
    if (checkCallingPermission(START_TASKS_FROM_RECENTS) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: startActivityFromRecents called without " + START_TASKS_FROM_RECENTS;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    return startActivityFromRecentsInner(taskId, options);
}
#method_after
@Override
public final int startActivityFromRecents(int taskId, Bundle bOptions) {
    if (checkCallingPermission(START_TASKS_FROM_RECENTS) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: startActivityFromRecents called without " + START_TASKS_FROM_RECENTS;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    final long origId = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            return mStackSupervisor.startActivityFromRecentsInner(taskId, bOptions);
        }
    } finally {
        Binder.restoreCallingIdentity(origId);
    }
}
#end_block

#method_before
final int startActivityInPackage(int uid, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, Bundle options, int userId, IActivityContainer container, TaskRecord inTask) {
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivityInPackage", null);
    // TODO: Switch to user app stacks here.
    int ret = mStackSupervisor.startActivityMayWait(null, uid, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, null, options, false, userId, container, inTask);
    return ret;
}
#method_after
final int startActivityInPackage(int uid, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, Bundle bOptions, int userId, IActivityContainer container, TaskRecord inTask) {
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivityInPackage", null);
    // TODO: Switch to user app stacks here.
    int ret = mActivityStarter.startActivityMayWait(null, uid, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, null, null, null, bOptions, false, userId, container, inTask);
    return ret;
}
#end_block

#method_before
@Override
public final int startActivities(IApplicationThread caller, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle options, int userId) {
    enforceNotIsolatedCaller("startActivities");
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null);
    // TODO: Switch to user app stacks here.
    int ret = mStackSupervisor.startActivities(caller, -1, callingPackage, intents, resolvedTypes, resultTo, options, userId);
    return ret;
}
#method_after
@Override
public final int startActivities(IApplicationThread caller, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) {
    enforceNotIsolatedCaller("startActivities");
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null);
    // TODO: Switch to user app stacks here.
    int ret = mActivityStarter.startActivities(caller, -1, callingPackage, intents, resolvedTypes, resultTo, bOptions, userId);
    return ret;
}
#end_block

#method_before
final int startActivitiesInPackage(int uid, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle options, int userId) {
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivityInPackage", null);
    // TODO: Switch to user app stacks here.
    int ret = mStackSupervisor.startActivities(null, uid, callingPackage, intents, resolvedTypes, resultTo, options, userId);
    return ret;
}
#method_after
final int startActivitiesInPackage(int uid, String callingPackage, Intent[] intents, String[] resolvedTypes, IBinder resultTo, Bundle bOptions, int userId) {
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivityInPackage", null);
    // TODO: Switch to user app stacks here.
    int ret = mActivityStarter.startActivities(null, uid, callingPackage, intents, resolvedTypes, resultTo, bOptions, userId);
    return ret;
}
#end_block

#method_before
@Override
public void setRequestedOrientation(IBinder token, int requestedOrientation) {
    synchronized (this) {
        ActivityRecord r = ActivityRecord.isInStackLocked(token);
        if (r == null) {
            return;
        }
        if (r.task != null && r.task.mResizeable) {
            // Fixed screen orientation isn't supported with resizeable activities.
            return;
        }
        final long origId = Binder.clearCallingIdentity();
        mWindowManager.setAppOrientation(r.appToken, requestedOrientation);
        Configuration config = mWindowManager.updateOrientationFromAppTokens(mConfiguration, r.mayFreezeScreenLocked(r.app) ? r.appToken : null);
        if (config != null) {
            r.frozenBeforeDestroy = true;
            if (!updateConfigurationLocked(config, r, false, false)) {
                mStackSupervisor.resumeTopActivitiesLocked();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }
}
#method_after
@Override
public void setRequestedOrientation(IBinder token, int requestedOrientation) {
    synchronized (this) {
        ActivityRecord r = ActivityRecord.isInStackLocked(token);
        if (r == null) {
            return;
        }
        TaskRecord task = r.task;
        if (task != null && (!task.mFullscreen || !task.stack.mFullscreen)) {
            // mode.
            return;
        }
        final long origId = Binder.clearCallingIdentity();
        mWindowManager.setAppOrientation(r.appToken, requestedOrientation);
        Configuration config = mWindowManager.updateOrientationFromAppTokens(mConfiguration, r.mayFreezeScreenLocked(r.app) ? r.appToken : null);
        if (config != null) {
            r.frozenBeforeDestroy = true;
            if (!updateConfigurationLocked(config, r, false)) {
                mStackSupervisor.resumeFocusedStackTopActivityLocked();
            }
        }
        Binder.restoreCallingIdentity(origId);
    }
}
#end_block

#method_before
@Override
public final boolean finishActivity(IBinder token, int resultCode, Intent resultData, boolean finishTask) {
    // Refuse possible leaked file descriptors
    if (resultData != null && resultData.hasFileDescriptors() == true) {
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }
    synchronized (this) {
        ActivityRecord r = ActivityRecord.isInStackLocked(token);
        if (r == null) {
            return true;
        }
        // Keep track of the root activity of the task before we finish it
        TaskRecord tr = r.task;
        ActivityRecord rootR = tr.getRootActivity();
        if (rootR == null) {
            Slog.w(TAG, "Finishing task with all activities already finished");
        }
        // finish.
        if (tr.mLockTaskAuth != LOCK_TASK_AUTH_LAUNCHABLE_PRIV && rootR == r && mStackSupervisor.isLastLockedTask(tr)) {
            Slog.i(TAG, "Not finishing task in lock task mode");
            mStackSupervisor.showLockTaskToast();
            return false;
        }
        if (mController != null) {
            // Find the first activity that is not finishing.
            ActivityRecord next = r.task.stack.topRunningActivityLocked(token, 0);
            if (next != null) {
                // ask watcher if this is allowed
                boolean resumeOK = true;
                try {
                    resumeOK = mController.activityResuming(next.packageName);
                } catch (RemoteException e) {
                    mController = null;
                    Watchdog.getInstance().setActivityController(null);
                }
                if (!resumeOK) {
                    Slog.i(TAG, "Not finishing activity because controller resumed");
                    return false;
                }
            }
        }
        final long origId = Binder.clearCallingIdentity();
        try {
            boolean res;
            if (finishTask && r == rootR) {
                // If requested, remove the task that is associated to this activity only if it
                // was the root activity in the task. The result code and data is ignored
                // because we don't support returning them across task boundaries.
                res = removeTaskByIdLocked(tr.taskId, false);
                if (!res) {
                    Slog.i(TAG, "Removing task failed to finish activity");
                }
            } else {
                res = tr.stack.requestFinishActivityLocked(token, resultCode, resultData, "app-request", true);
                if (!res) {
                    Slog.i(TAG, "Failed to finish by app-request");
                }
            }
            return res;
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }
}
#method_after
@Override
public final boolean finishActivity(IBinder token, int resultCode, Intent resultData, int finishTask) {
    // Refuse possible leaked file descriptors
    if (resultData != null && resultData.hasFileDescriptors() == true) {
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }
    synchronized (this) {
        ActivityRecord r = ActivityRecord.isInStackLocked(token);
        if (r == null) {
            return true;
        }
        // Keep track of the root activity of the task before we finish it
        TaskRecord tr = r.task;
        ActivityRecord rootR = tr.getRootActivity();
        if (rootR == null) {
            Slog.w(TAG, "Finishing task with all activities already finished");
        }
        // finish.
        if (tr.mLockTaskAuth != LOCK_TASK_AUTH_LAUNCHABLE_PRIV && rootR == r && mStackSupervisor.isLastLockedTask(tr)) {
            Slog.i(TAG, "Not finishing task in lock task mode");
            mStackSupervisor.showLockTaskToast();
            return false;
        }
        if (mController != null) {
            // Find the first activity that is not finishing.
            ActivityRecord next = r.task.stack.topRunningActivityLocked(token, 0);
            if (next != null) {
                // ask watcher if this is allowed
                boolean resumeOK = true;
                try {
                    resumeOK = mController.activityResuming(next.packageName);
                } catch (RemoteException e) {
                    mController = null;
                    Watchdog.getInstance().setActivityController(null);
                }
                if (!resumeOK) {
                    Slog.i(TAG, "Not finishing activity because controller resumed");
                    return false;
                }
            }
        }
        final long origId = Binder.clearCallingIdentity();
        try {
            boolean res;
            final boolean finishWithRootActivity = finishTask == Activity.FINISH_TASK_WITH_ROOT_ACTIVITY;
            if (finishTask == Activity.FINISH_TASK_WITH_ACTIVITY || (finishWithRootActivity && r == rootR)) {
                // If requested, remove the task that is associated to this activity only if it
                // was the root activity in the task. The result code and data is ignored
                // because we don't support returning them across task boundaries. Also, to
                // keep backwards compatibility we remove the task from recents when finishing
                // task with root activity.
                res = removeTaskByIdLocked(tr.taskId, false, finishWithRootActivity);
                if (!res) {
                    Slog.i(TAG, "Removing task failed to finish activity");
                }
            } else {
                res = tr.stack.requestFinishActivityLocked(token, resultCode, resultData, "app-request", true);
                if (!res) {
                    Slog.i(TAG, "Failed to finish by app-request");
                }
            }
            return res;
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }
}
#end_block

#method_before
@Override
public void crashApplication(int uid, int initialPid, String packageName, String message) {
    if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: crashApplication() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.FORCE_STOP_PACKAGES;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    synchronized (this) {
        ProcessRecord proc = null;
        // list.
        synchronized (mPidsSelfLocked) {
            for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                ProcessRecord p = mPidsSelfLocked.valueAt(i);
                if (p.uid != uid) {
                    continue;
                }
                if (p.pid == initialPid) {
                    proc = p;
                    break;
                }
                if (p.pkgList.containsKey(packageName)) {
                    proc = p;
                }
            }
        }
        if (proc == null) {
            Slog.w(TAG, "crashApplication: nothing for uid=" + uid + " initialPid=" + initialPid + " packageName=" + packageName);
            return;
        }
        if (proc.thread != null) {
            if (proc.pid == Process.myPid()) {
                Log.w(TAG, "crashApplication: trying to crash self!");
                return;
            }
            long ident = Binder.clearCallingIdentity();
            try {
                proc.thread.scheduleCrash(message);
            } catch (RemoteException e) {
            }
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#method_after
@Override
public void crashApplication(int uid, int initialPid, String packageName, String message) {
    if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: crashApplication() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.FORCE_STOP_PACKAGES;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    synchronized (this) {
        mAppErrors.scheduleAppCrashLocked(uid, initialPid, packageName, message);
    }
}
#end_block

#method_before
@Override
public void finishVoiceTask(IVoiceInteractionSession session) {
    synchronized (this) {
        final long origId = Binder.clearCallingIdentity();
        try {
            mStackSupervisor.finishVoiceTask(session);
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }
}
#method_after
@Override
public void finishVoiceTask(IVoiceInteractionSession session) {
    synchronized (this) {
        final long origId = Binder.clearCallingIdentity();
        try {
            // TODO: VI Consider treating local voice interactions and voice tasks
            // differently here
            mStackSupervisor.finishVoiceTask(session);
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }
}
#end_block

#method_before
private final void handleAppDiedLocked(ProcessRecord app, boolean restarting, boolean allowRestart) {
    int pid = app.pid;
    boolean kept = cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1);
    if (!kept && !restarting) {
        removeLruProcessLocked(app);
        if (pid > 0) {
            ProcessList.remove(pid);
        }
    }
    if (mProfileProc == app) {
        clearProfilerLocked();
    }
    // Remove this application's activities from active lists.
    boolean hasVisibleActivities = mStackSupervisor.handleAppDiedLocked(app);
    app.activities.clear();
    if (app.instrumentationClass != null) {
        Slog.w(TAG, "Crash of app " + app.processName + " running instrumentation " + app.instrumentationClass);
        Bundle info = new Bundle();
        info.putString("shortMsg", "Process crashed.");
        finishInstrumentationLocked(app, Activity.RESULT_CANCELED, info);
    }
    if (!restarting && hasVisibleActivities && !mStackSupervisor.resumeTopActivitiesLocked()) {
        // If there was nothing to resume, and we are not already
        // restarting this process, but there is a visible activity that
        // is hosted by the process...  then make sure all visible
        // activities are running, taking care of restarting this
        // process.
        mStackSupervisor.ensureActivitiesVisibleLocked(null, 0);
    }
}
#method_after
private final void handleAppDiedLocked(ProcessRecord app, boolean restarting, boolean allowRestart) {
    int pid = app.pid;
    boolean kept = cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1);
    if (!kept && !restarting) {
        removeLruProcessLocked(app);
        if (pid > 0) {
            ProcessList.remove(pid);
        }
    }
    if (mProfileProc == app) {
        clearProfilerLocked();
    }
    // Remove this application's activities from active lists.
    boolean hasVisibleActivities = mStackSupervisor.handleAppDiedLocked(app);
    app.activities.clear();
    if (app.instrumentationClass != null) {
        Slog.w(TAG, "Crash of app " + app.processName + " running instrumentation " + app.instrumentationClass);
        Bundle info = new Bundle();
        info.putString("shortMsg", "Process crashed.");
        finishInstrumentationLocked(app, Activity.RESULT_CANCELED, info);
    }
    if (!restarting && hasVisibleActivities && !mStackSupervisor.resumeFocusedStackTopActivityLocked()) {
        // If there was nothing to resume, and we are not already restarting this process, but
        // there is a visible activity that is hosted by the process...  then make sure all
        // visible activities are running, taking care of restarting this process.
        mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
    }
}
#end_block

#method_before
final void appDiedLocked(ProcessRecord app, int pid, IApplicationThread thread, boolean fromBinderDied) {
    // First check if this ProcessRecord is actually active for the pid.
    synchronized (mPidsSelfLocked) {
        ProcessRecord curProc = mPidsSelfLocked.get(pid);
        if (curProc != app) {
            Slog.w(TAG, "Spurious death for " + app + ", curProc for " + pid + ": " + curProc);
            return;
        }
    }
    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    synchronized (stats) {
        stats.noteProcessDiedLocked(app.info.uid, pid);
    }
    if (!app.killed) {
        if (!fromBinderDied) {
            Process.killProcessQuiet(pid);
        }
        killProcessGroup(app.info.uid, pid);
        app.killed = true;
    }
    // Clean up already done if the process has been re-started.
    if (app.pid == pid && app.thread != null && app.thread.asBinder() == thread.asBinder()) {
        boolean doLowMem = app.instrumentationClass == null;
        boolean doOomAdj = doLowMem;
        if (!app.killedByAm) {
            Slog.i(TAG, "Process " + app.processName + " (pid " + pid + ") has died");
            mAllowLowerMemLevel = true;
        } else {
            // Note that we always want to do oom adj to update our state with the
            // new number of procs.
            mAllowLowerMemLevel = false;
            doLowMem = false;
        }
        EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);
        if (DEBUG_CLEANUP)
            Slog.v(TAG_CLEANUP, "Dying app: " + app + ", pid: " + pid + ", thread: " + thread.asBinder());
        handleAppDiedLocked(app, false, true);
        if (doOomAdj) {
            updateOomAdjLocked();
        }
        if (doLowMem) {
            doLowMemReportIfNeededLocked(app);
        }
    } else if (app.pid != pid) {
        // A new process has already been started.
        Slog.i(TAG, "Process " + app.processName + " (pid " + pid + ") has died and restarted (pid " + app.pid + ").");
        EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);
    } else if (DEBUG_PROCESSES) {
        Slog.d(TAG_PROCESSES, "Received spurious death notification for thread " + thread.asBinder());
    }
}
#method_after
final void appDiedLocked(ProcessRecord app, int pid, IApplicationThread thread, boolean fromBinderDied) {
    // First check if this ProcessRecord is actually active for the pid.
    synchronized (mPidsSelfLocked) {
        ProcessRecord curProc = mPidsSelfLocked.get(pid);
        if (curProc != app) {
            Slog.w(TAG, "Spurious death for " + app + ", curProc for " + pid + ": " + curProc);
            return;
        }
    }
    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    synchronized (stats) {
        stats.noteProcessDiedLocked(app.info.uid, pid);
    }
    if (!app.killed) {
        if (!fromBinderDied) {
            Process.killProcessQuiet(pid);
        }
        killProcessGroup(app.uid, pid);
        app.killed = true;
    }
    // Clean up already done if the process has been re-started.
    if (app.pid == pid && app.thread != null && app.thread.asBinder() == thread.asBinder()) {
        boolean doLowMem = app.instrumentationClass == null;
        boolean doOomAdj = doLowMem;
        if (!app.killedByAm) {
            Slog.i(TAG, "Process " + app.processName + " (pid " + pid + ") has died");
            mAllowLowerMemLevel = true;
        } else {
            // Note that we always want to do oom adj to update our state with the
            // new number of procs.
            mAllowLowerMemLevel = false;
            doLowMem = false;
        }
        EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);
        if (DEBUG_CLEANUP)
            Slog.v(TAG_CLEANUP, "Dying app: " + app + ", pid: " + pid + ", thread: " + thread.asBinder());
        handleAppDiedLocked(app, false, true);
        if (doOomAdj) {
            updateOomAdjLocked();
        }
        if (doLowMem) {
            doLowMemReportIfNeededLocked(app);
        }
    } else if (app.pid != pid) {
        // A new process has already been started.
        Slog.i(TAG, "Process " + app.processName + " (pid " + pid + ") has died and restarted (pid " + app.pid + ").");
        EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);
    } else if (DEBUG_PROCESSES) {
        Slog.d(TAG_PROCESSES, "Received spurious death notification for thread " + thread.asBinder());
    }
}
#end_block

#method_before
private static void dumpStackTraces(String tracesPath, ArrayList<Integer> firstPids, ProcessCpuTracker processCpuTracker, SparseArray<Boolean> lastPids, String[] nativeProcs) {
    // Use a FileObserver to detect when traces finish writing.
    // The order of traces is considered important to maintain for legibility.
    FileObserver observer = new FileObserver(tracesPath, FileObserver.CLOSE_WRITE) {

        @Override
        public synchronized void onEvent(int event, String path) {
            notify();
        }
    };
    try {
        observer.startWatching();
        // First collect all of the stacks of the most important pids.
        if (firstPids != null) {
            try {
                int num = firstPids.size();
                for (int i = 0; i < num; i++) {
                    synchronized (observer) {
                        Process.sendSignal(firstPids.get(i), Process.SIGNAL_QUIT);
                        // Wait for write-close, give up after 200msec
                        observer.wait(200);
                    }
                }
            } catch (InterruptedException e) {
                Slog.wtf(TAG, e);
            }
        }
        // Next collect the stacks of the native pids
        if (nativeProcs != null) {
            int[] pids = Process.getPidsForCommands(nativeProcs);
            if (pids != null) {
                for (int pid : pids) {
                    Debug.dumpNativeBacktraceToFile(pid, tracesPath);
                }
            }
        }
        // Lastly, measure CPU usage.
        if (processCpuTracker != null) {
            processCpuTracker.init();
            System.gc();
            processCpuTracker.update();
            try {
                synchronized (processCpuTracker) {
                    // measure over 1/2 second.
                    processCpuTracker.wait(500);
                }
            } catch (InterruptedException e) {
            }
            processCpuTracker.update();
            // We'll take the stack crawls of just the top apps using CPU.
            final int N = processCpuTracker.countWorkingStats();
            int numProcs = 0;
            for (int i = 0; i < N && numProcs < 5; i++) {
                ProcessCpuTracker.Stats stats = processCpuTracker.getWorkingStats(i);
                if (lastPids.indexOfKey(stats.pid) >= 0) {
                    numProcs++;
                    try {
                        synchronized (observer) {
                            Process.sendSignal(stats.pid, Process.SIGNAL_QUIT);
                            // Wait for write-close, give up after 200msec
                            observer.wait(200);
                        }
                    } catch (InterruptedException e) {
                        Slog.wtf(TAG, e);
                    }
                }
            }
        }
    } finally {
        observer.stopWatching();
    }
}
#method_after
private static void dumpStackTraces(String tracesPath, ArrayList<Integer> firstPids, ProcessCpuTracker processCpuTracker, SparseArray<Boolean> lastPids, String[] nativeProcs) {
    // Use a FileObserver to detect when traces finish writing.
    // The order of traces is considered important to maintain for legibility.
    FileObserver observer = new FileObserver(tracesPath, FileObserver.CLOSE_WRITE) {

        @Override
        public synchronized void onEvent(int event, String path) {
            notify();
        }
    };
    try {
        observer.startWatching();
        // First collect all of the stacks of the most important pids.
        if (firstPids != null) {
            try {
                int num = firstPids.size();
                for (int i = 0; i < num; i++) {
                    synchronized (observer) {
                        if (DEBUG_ANR)
                            Slog.d(TAG, "Collecting stacks for pid " + firstPids.get(i));
                        final long sime = SystemClock.elapsedRealtime();
                        Process.sendSignal(firstPids.get(i), Process.SIGNAL_QUIT);
                        // Wait for write-close, give up after 1 sec
                        observer.wait(1000);
                        if (DEBUG_ANR)
                            Slog.d(TAG, "Done with pid " + firstPids.get(i) + " in " + (SystemClock.elapsedRealtime() - sime) + "ms");
                    }
                }
            } catch (InterruptedException e) {
                Slog.wtf(TAG, e);
            }
        }
        // Next collect the stacks of the native pids
        if (nativeProcs != null) {
            int[] pids = Process.getPidsForCommands(nativeProcs);
            if (pids != null) {
                for (int pid : pids) {
                    if (DEBUG_ANR)
                        Slog.d(TAG, "Collecting stacks for native pid " + pid);
                    final long sime = SystemClock.elapsedRealtime();
                    Debug.dumpNativeBacktraceToFile(pid, tracesPath);
                    if (DEBUG_ANR)
                        Slog.d(TAG, "Done with native pid " + pid + " in " + (SystemClock.elapsedRealtime() - sime) + "ms");
                }
            }
        }
        // Lastly, measure CPU usage.
        if (processCpuTracker != null) {
            processCpuTracker.init();
            System.gc();
            processCpuTracker.update();
            try {
                synchronized (processCpuTracker) {
                    // measure over 1/2 second.
                    processCpuTracker.wait(500);
                }
            } catch (InterruptedException e) {
            }
            processCpuTracker.update();
            // We'll take the stack crawls of just the top apps using CPU.
            final int N = processCpuTracker.countWorkingStats();
            int numProcs = 0;
            for (int i = 0; i < N && numProcs < 5; i++) {
                ProcessCpuTracker.Stats stats = processCpuTracker.getWorkingStats(i);
                if (lastPids.indexOfKey(stats.pid) >= 0) {
                    numProcs++;
                    try {
                        synchronized (observer) {
                            if (DEBUG_ANR)
                                Slog.d(TAG, "Collecting stacks for extra pid " + stats.pid);
                            final long stime = SystemClock.elapsedRealtime();
                            Process.sendSignal(stats.pid, Process.SIGNAL_QUIT);
                            // Wait for write-close, give up after 1 sec
                            observer.wait(1000);
                            if (DEBUG_ANR)
                                Slog.d(TAG, "Done with extra pid " + stats.pid + " in " + (SystemClock.elapsedRealtime() - stime) + "ms");
                        }
                    } catch (InterruptedException e) {
                        Slog.wtf(TAG, e);
                    }
                } else if (DEBUG_ANR) {
                    Slog.d(TAG, "Skipping next CPU consuming process, not a java proc: " + stats.pid);
                }
            }
        }
    } finally {
        observer.stopWatching();
    }
}
#end_block

#method_before
@Override
public boolean clearApplicationUserData(final String packageName, final IPackageDataObserver observer, int userId) {
    enforceNotIsolatedCaller("clearApplicationUserData");
    if (packageName != null && packageName.equals(mDeviceOwnerName)) {
        throw new SecurityException("Clearing DeviceOwner data is forbidden.");
    }
    int uid = Binder.getCallingUid();
    int pid = Binder.getCallingPid();
    userId = handleIncomingUser(pid, uid, userId, false, ALLOW_FULL_ONLY, "clearApplicationUserData", null);
    long callingId = Binder.clearCallingIdentity();
    try {
        IPackageManager pm = AppGlobals.getPackageManager();
        int pkgUid = -1;
        synchronized (this) {
            try {
                pkgUid = pm.getPackageUid(packageName, userId);
            } catch (RemoteException e) {
            }
            if (pkgUid == -1) {
                Slog.w(TAG, "Invalid packageName: " + packageName);
                if (observer != null) {
                    try {
                        observer.onRemoveCompleted(packageName, false);
                    } catch (RemoteException e) {
                        Slog.i(TAG, "Observer no longer exists.");
                    }
                }
                return false;
            }
            if (uid == pkgUid || checkComponentPermission(android.Manifest.permission.CLEAR_APP_USER_DATA, pid, uid, -1, true) == PackageManager.PERMISSION_GRANTED) {
                forceStopPackageLocked(packageName, pkgUid, "clear data");
            } else {
                throw new SecurityException("PID " + pid + " does not have permission " + android.Manifest.permission.CLEAR_APP_USER_DATA + " to clear data" + " of package " + packageName);
            }
            // Remove all tasks match the cleared application package and user
            for (int i = mRecentTasks.size() - 1; i >= 0; i--) {
                final TaskRecord tr = mRecentTasks.get(i);
                final String taskPackageName = tr.getBaseIntent().getComponent().getPackageName();
                if (tr.userId != userId)
                    continue;
                if (!taskPackageName.equals(packageName))
                    continue;
                removeTaskByIdLocked(tr.taskId, false);
            }
        }
        try {
            // Clear application user data
            pm.clearApplicationUserData(packageName, observer, userId);
            synchronized (this) {
                // Remove all permissions granted from/to this package
                removeUriPermissionsForPackageLocked(packageName, userId, true);
            }
            Intent intent = new Intent(Intent.ACTION_PACKAGE_DATA_CLEARED, Uri.fromParts("package", packageName, null));
            intent.putExtra(Intent.EXTRA_UID, pkgUid);
            broadcastIntentInPackage("android", Process.SYSTEM_UID, intent, null, null, 0, null, null, null, null, false, false, userId);
        } catch (RemoteException e) {
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
    return true;
}
#method_after
@Override
public boolean clearApplicationUserData(final String packageName, final IPackageDataObserver observer, int userId) {
    enforceNotIsolatedCaller("clearApplicationUserData");
    int uid = Binder.getCallingUid();
    int pid = Binder.getCallingPid();
    userId = mUserController.handleIncomingUser(pid, uid, userId, false, ALLOW_FULL_ONLY, "clearApplicationUserData", null);
    long callingId = Binder.clearCallingIdentity();
    try {
        IPackageManager pm = AppGlobals.getPackageManager();
        int pkgUid = -1;
        synchronized (this) {
            if (getPackageManagerInternalLocked().canPackageBeWiped(userId, packageName)) {
                throw new SecurityException("Cannot clear data for a device owner or a profile owner");
            }
            try {
                pkgUid = pm.getPackageUid(packageName, MATCH_UNINSTALLED_PACKAGES, userId);
            } catch (RemoteException e) {
            }
            if (pkgUid == -1) {
                Slog.w(TAG, "Invalid packageName: " + packageName);
                if (observer != null) {
                    try {
                        observer.onRemoveCompleted(packageName, false);
                    } catch (RemoteException e) {
                        Slog.i(TAG, "Observer no longer exists.");
                    }
                }
                return false;
            }
            if (uid == pkgUid || checkComponentPermission(android.Manifest.permission.CLEAR_APP_USER_DATA, pid, uid, -1, true) == PackageManager.PERMISSION_GRANTED) {
                forceStopPackageLocked(packageName, pkgUid, "clear data");
            } else {
                throw new SecurityException("PID " + pid + " does not have permission " + android.Manifest.permission.CLEAR_APP_USER_DATA + " to clear data" + " of package " + packageName);
            }
            // Remove all tasks match the cleared application package and user
            for (int i = mRecentTasks.size() - 1; i >= 0; i--) {
                final TaskRecord tr = mRecentTasks.get(i);
                final String taskPackageName = tr.getBaseIntent().getComponent().getPackageName();
                if (tr.userId != userId)
                    continue;
                if (!taskPackageName.equals(packageName))
                    continue;
                removeTaskByIdLocked(tr.taskId, false, REMOVE_FROM_RECENTS);
            }
        }
        final int pkgUidF = pkgUid;
        final int userIdF = userId;
        final IPackageDataObserver localObserver = new IPackageDataObserver.Stub() {

            @Override
            public void onRemoveCompleted(String packageName, boolean succeeded) throws RemoteException {
                synchronized (ActivityManagerService.this) {
                    finishForceStopPackageLocked(packageName, pkgUidF);
                }
                final Intent intent = new Intent(Intent.ACTION_PACKAGE_DATA_CLEARED, Uri.fromParts("package", packageName, null));
                intent.putExtra(Intent.EXTRA_UID, pkgUidF);
                intent.putExtra(Intent.EXTRA_USER_HANDLE, UserHandle.getUserId(pkgUidF));
                broadcastIntentInPackage("android", Process.SYSTEM_UID, intent, null, null, 0, null, null, null, null, false, false, userIdF);
                if (observer != null) {
                    observer.onRemoveCompleted(packageName, succeeded);
                }
            }
        };
        try {
            // Clear application user data
            pm.clearApplicationUserData(packageName, localObserver, userId);
            synchronized (this) {
                // Remove all permissions granted from/to this package
                removeUriPermissionsForPackageLocked(packageName, userId, true);
            }
            // Remove all zen rules created by this package; revoke it's zen access.
            INotificationManager inm = NotificationManager.getService();
            inm.removeAutomaticZenRules(packageName);
            inm.setNotificationPolicyAccessGranted(packageName, false);
        } catch (RemoteException e) {
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
    return true;
}
#end_block

#method_before
@Override
public void killBackgroundProcesses(final String packageName, int userId) {
    if (checkCallingPermission(android.Manifest.permission.KILL_BACKGROUND_PROCESSES) != PackageManager.PERMISSION_GRANTED && checkCallingPermission(android.Manifest.permission.RESTART_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: killBackgroundProcesses() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.KILL_BACKGROUND_PROCESSES;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, ALLOW_FULL_ONLY, "killBackgroundProcesses", null);
    long callingId = Binder.clearCallingIdentity();
    try {
        IPackageManager pm = AppGlobals.getPackageManager();
        synchronized (this) {
            int appId = -1;
            try {
                appId = UserHandle.getAppId(pm.getPackageUid(packageName, 0));
            } catch (RemoteException e) {
            }
            if (appId == -1) {
                Slog.w(TAG, "Invalid packageName: " + packageName);
                return;
            }
            killPackageProcessesLocked(packageName, appId, userId, ProcessList.SERVICE_ADJ, false, true, true, false, "kill background");
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#method_after
@Override
public void killBackgroundProcesses(final String packageName, int userId) {
    if (checkCallingPermission(android.Manifest.permission.KILL_BACKGROUND_PROCESSES) != PackageManager.PERMISSION_GRANTED && checkCallingPermission(android.Manifest.permission.RESTART_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: killBackgroundProcesses() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.KILL_BACKGROUND_PROCESSES;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, ALLOW_FULL_ONLY, "killBackgroundProcesses", null);
    long callingId = Binder.clearCallingIdentity();
    try {
        IPackageManager pm = AppGlobals.getPackageManager();
        synchronized (this) {
            int appId = -1;
            try {
                appId = UserHandle.getAppId(pm.getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING, userId));
            } catch (RemoteException e) {
            }
            if (appId == -1) {
                Slog.w(TAG, "Invalid packageName: " + packageName);
                return;
            }
            killPackageProcessesLocked(packageName, appId, userId, ProcessList.SERVICE_ADJ, false, true, true, false, "kill background");
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#end_block

#method_before
@Override
public void killAllBackgroundProcesses() {
    if (checkCallingPermission(android.Manifest.permission.KILL_BACKGROUND_PROCESSES) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: killAllBackgroundProcesses() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.KILL_BACKGROUND_PROCESSES;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    long callingId = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            ArrayList<ProcessRecord> procs = new ArrayList<ProcessRecord>();
            final int NP = mProcessNames.getMap().size();
            for (int ip = 0; ip < NP; ip++) {
                SparseArray<ProcessRecord> apps = mProcessNames.getMap().valueAt(ip);
                final int NA = apps.size();
                for (int ia = 0; ia < NA; ia++) {
                    ProcessRecord app = apps.valueAt(ia);
                    if (app.persistent) {
                        // we don't kill persistent processes
                        continue;
                    }
                    if (app.removed) {
                        procs.add(app);
                    } else if (app.setAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
                        app.removed = true;
                        procs.add(app);
                    }
                }
            }
            int N = procs.size();
            for (int i = 0; i < N; i++) {
                removeProcessLocked(procs.get(i), false, true, "kill all background");
            }
            mAllowLowerMemLevel = true;
            updateOomAdjLocked();
            doLowMemReportIfNeededLocked(null);
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#method_after
@Override
public void killAllBackgroundProcesses() {
    if (checkCallingPermission(android.Manifest.permission.KILL_BACKGROUND_PROCESSES) != PackageManager.PERMISSION_GRANTED) {
        final String msg = "Permission Denial: killAllBackgroundProcesses() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.KILL_BACKGROUND_PROCESSES;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    final long callingId = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            final ArrayList<ProcessRecord> procs = new ArrayList<>();
            final int NP = mProcessNames.getMap().size();
            for (int ip = 0; ip < NP; ip++) {
                final SparseArray<ProcessRecord> apps = mProcessNames.getMap().valueAt(ip);
                final int NA = apps.size();
                for (int ia = 0; ia < NA; ia++) {
                    final ProcessRecord app = apps.valueAt(ia);
                    if (app.persistent) {
                        // We don't kill persistent processes.
                        continue;
                    }
                    if (app.removed) {
                        procs.add(app);
                    } else if (app.setAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
                        app.removed = true;
                        procs.add(app);
                    }
                }
            }
            final int N = procs.size();
            for (int i = 0; i < N; i++) {
                removeProcessLocked(procs.get(i), false, true, "kill all background");
            }
            mAllowLowerMemLevel = true;
            updateOomAdjLocked();
            doLowMemReportIfNeededLocked(null);
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#end_block

#method_before
@Override
public void forceStopPackage(final String packageName, int userId) {
    if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: forceStopPackage() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.FORCE_STOP_PACKAGES;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    final int callingPid = Binder.getCallingPid();
    userId = handleIncomingUser(callingPid, Binder.getCallingUid(), userId, true, ALLOW_FULL_ONLY, "forceStopPackage", null);
    long callingId = Binder.clearCallingIdentity();
    try {
        IPackageManager pm = AppGlobals.getPackageManager();
        synchronized (this) {
            int[] users = userId == UserHandle.USER_ALL ? getUsersLocked() : new int[] { userId };
            for (int user : users) {
                int pkgUid = -1;
                try {
                    pkgUid = pm.getPackageUid(packageName, user);
                } catch (RemoteException e) {
                }
                if (pkgUid == -1) {
                    Slog.w(TAG, "Invalid packageName: " + packageName);
                    continue;
                }
                try {
                    pm.setPackageStoppedState(packageName, true, user);
                } catch (RemoteException e) {
                } catch (IllegalArgumentException e) {
                    Slog.w(TAG, "Failed trying to unstop package " + packageName + ": " + e);
                }
                if (isUserRunningLocked(user, false)) {
                    forceStopPackageLocked(packageName, pkgUid, "from pid " + callingPid);
                }
            }
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#method_after
@Override
public void forceStopPackage(final String packageName, int userId) {
    if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: forceStopPackage() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.FORCE_STOP_PACKAGES;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    final int callingPid = Binder.getCallingPid();
    userId = mUserController.handleIncomingUser(callingPid, Binder.getCallingUid(), userId, true, ALLOW_FULL_ONLY, "forceStopPackage", null);
    long callingId = Binder.clearCallingIdentity();
    try {
        IPackageManager pm = AppGlobals.getPackageManager();
        synchronized (this) {
            int[] users = userId == UserHandle.USER_ALL ? mUserController.getUsers() : new int[] { userId };
            for (int user : users) {
                int pkgUid = -1;
                try {
                    pkgUid = pm.getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING, user);
                } catch (RemoteException e) {
                }
                if (pkgUid == -1) {
                    Slog.w(TAG, "Invalid packageName: " + packageName);
                    continue;
                }
                try {
                    pm.setPackageStoppedState(packageName, true, user);
                } catch (RemoteException e) {
                } catch (IllegalArgumentException e) {
                    Slog.w(TAG, "Failed trying to unstop package " + packageName + ": " + e);
                }
                if (mUserController.isUserRunningLocked(user, 0)) {
                    forceStopPackageLocked(packageName, pkgUid, "from pid " + callingPid);
                    finishForceStopPackageLocked(packageName, pkgUid);
                }
            }
        }
    } finally {
        Binder.restoreCallingIdentity(callingId);
    }
}
#end_block

#method_before
private void forceStopPackageLocked(final String packageName, int uid, String reason) {
    forceStopPackageLocked(packageName, UserHandle.getAppId(uid), false, false, true, false, false, UserHandle.getUserId(uid), reason);
    Intent intent = new Intent(Intent.ACTION_PACKAGE_RESTARTED, Uri.fromParts("package", packageName, null));
    if (!mProcessesReady) {
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
    }
    intent.putExtra(Intent.EXTRA_UID, uid);
    intent.putExtra(Intent.EXTRA_USER_HANDLE, UserHandle.getUserId(uid));
    broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, UserHandle.getUserId(uid));
}
#method_after
private void forceStopPackageLocked(final String packageName, int uid, String reason) {
    forceStopPackageLocked(packageName, UserHandle.getAppId(uid), false, false, true, false, false, UserHandle.getUserId(uid), reason);
}
#end_block

#method_before
private void cleanupDisabledPackageComponentsLocked(String packageName, int userId, boolean killProcess, String[] changedClasses) {
    Set<String> disabledClasses = null;
    boolean packageDisabled = false;
    IPackageManager pm = AppGlobals.getPackageManager();
    if (changedClasses == null) {
        // Nothing changed...
        return;
    }
    // Determine enable/disable state of the package and its components.
    int enabled = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
    for (int i = changedClasses.length - 1; i >= 0; i--) {
        final String changedClass = changedClasses[i];
        if (changedClass.equals(packageName)) {
            try {
                // Entire package setting changed
                enabled = pm.getApplicationEnabledSetting(packageName, (userId != UserHandle.USER_ALL) ? userId : UserHandle.USER_OWNER);
            } catch (Exception e) {
                // event it means we have nothing further to do here.
                return;
            }
            packageDisabled = enabled != PackageManager.COMPONENT_ENABLED_STATE_ENABLED && enabled != PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
            if (packageDisabled) {
                // Entire package is disabled.
                // No need to continue to check component states.
                disabledClasses = null;
                break;
            }
        } else {
            try {
                enabled = pm.getComponentEnabledSetting(new ComponentName(packageName, changedClass), (userId != UserHandle.USER_ALL) ? userId : UserHandle.USER_OWNER);
            } catch (Exception e) {
                // As above, probably racing with uninstall.
                return;
            }
            if (enabled != PackageManager.COMPONENT_ENABLED_STATE_ENABLED && enabled != PackageManager.COMPONENT_ENABLED_STATE_DEFAULT) {
                if (disabledClasses == null) {
                    disabledClasses = new ArraySet<>(changedClasses.length);
                }
                disabledClasses.add(changedClass);
            }
        }
    }
    if (!packageDisabled && disabledClasses == null) {
        // Nothing to do here...
        return;
    }
    // Clean-up disabled activities.
    if (mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, disabledClasses, true, false, userId) && mBooted) {
        mStackSupervisor.resumeTopActivitiesLocked();
        mStackSupervisor.scheduleIdleLocked();
    }
    // Clean-up disabled tasks
    cleanupDisabledPackageTasksLocked(packageName, disabledClasses, userId);
    // Clean-up disabled services.
    mServices.bringDownDisabledPackageServicesLocked(packageName, disabledClasses, userId, false, killProcess, true);
    // Clean-up disabled providers.
    ArrayList<ContentProviderRecord> providers = new ArrayList<>();
    mProviderMap.collectPackageProvidersLocked(packageName, disabledClasses, true, false, userId, providers);
    for (int i = providers.size() - 1; i >= 0; i--) {
        removeDyingProviderLocked(null, providers.get(i), true);
    }
    // Clean-up disabled broadcast receivers.
    for (int i = mBroadcastQueues.length - 1; i >= 0; i--) {
        mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(packageName, disabledClasses, userId, true);
    }
}
#method_after
private void cleanupDisabledPackageComponentsLocked(String packageName, int userId, boolean killProcess, String[] changedClasses) {
    Set<String> disabledClasses = null;
    boolean packageDisabled = false;
    IPackageManager pm = AppGlobals.getPackageManager();
    if (changedClasses == null) {
        // Nothing changed...
        return;
    }
    // Determine enable/disable state of the package and its components.
    int enabled = PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
    for (int i = changedClasses.length - 1; i >= 0; i--) {
        final String changedClass = changedClasses[i];
        if (changedClass.equals(packageName)) {
            try {
                // Entire package setting changed
                enabled = pm.getApplicationEnabledSetting(packageName, (userId != UserHandle.USER_ALL) ? userId : UserHandle.USER_SYSTEM);
            } catch (Exception e) {
                // event it means we have nothing further to do here.
                return;
            }
            packageDisabled = enabled != PackageManager.COMPONENT_ENABLED_STATE_ENABLED && enabled != PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
            if (packageDisabled) {
                // Entire package is disabled.
                // No need to continue to check component states.
                disabledClasses = null;
                break;
            }
        } else {
            try {
                enabled = pm.getComponentEnabledSetting(new ComponentName(packageName, changedClass), (userId != UserHandle.USER_ALL) ? userId : UserHandle.USER_SYSTEM);
            } catch (Exception e) {
                // As above, probably racing with uninstall.
                return;
            }
            if (enabled != PackageManager.COMPONENT_ENABLED_STATE_ENABLED && enabled != PackageManager.COMPONENT_ENABLED_STATE_DEFAULT) {
                if (disabledClasses == null) {
                    disabledClasses = new ArraySet<>(changedClasses.length);
                }
                disabledClasses.add(changedClass);
            }
        }
    }
    if (!packageDisabled && disabledClasses == null) {
        // Nothing to do here...
        return;
    }
    // Clean-up disabled activities.
    if (mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, disabledClasses, true, false, userId) && mBooted) {
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
        mStackSupervisor.scheduleIdleLocked();
    }
    // Clean-up disabled tasks
    cleanupDisabledPackageTasksLocked(packageName, disabledClasses, userId);
    // Clean-up disabled services.
    mServices.bringDownDisabledPackageServicesLocked(packageName, disabledClasses, userId, false, killProcess, true);
    // Clean-up disabled providers.
    ArrayList<ContentProviderRecord> providers = new ArrayList<>();
    mProviderMap.collectPackageProvidersLocked(packageName, disabledClasses, true, false, userId, providers);
    for (int i = providers.size() - 1; i >= 0; i--) {
        removeDyingProviderLocked(null, providers.get(i), true);
    }
    // Clean-up disabled broadcast receivers.
    for (int i = mBroadcastQueues.length - 1; i >= 0; i--) {
        mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(packageName, disabledClasses, userId, true);
    }
}
#end_block

#method_before
private final boolean forceStopPackageLocked(String packageName, int appId, boolean callerWillRestart, boolean purgeCache, boolean doit, boolean evenPersistent, boolean uninstalling, int userId, String reason) {
    int i;
    if (userId == UserHandle.USER_ALL && packageName == null) {
        Slog.w(TAG, "Can't force stop all processes of all users, that is insane!");
    }
    if (appId < 0 && packageName != null) {
        try {
            appId = UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(packageName, 0));
        } catch (RemoteException e) {
        }
    }
    if (doit) {
        if (packageName != null) {
            Slog.i(TAG, "Force stopping " + packageName + " appid=" + appId + " user=" + userId + ": " + reason);
        } else {
            Slog.i(TAG, "Force stopping u" + userId + ": " + reason);
        }
        final ArrayMap<String, SparseArray<Long>> pmap = mProcessCrashTimes.getMap();
        for (int ip = pmap.size() - 1; ip >= 0; ip--) {
            SparseArray<Long> ba = pmap.valueAt(ip);
            for (i = ba.size() - 1; i >= 0; i--) {
                boolean remove = false;
                final int entUid = ba.keyAt(i);
                if (packageName != null) {
                    if (userId == UserHandle.USER_ALL) {
                        if (UserHandle.getAppId(entUid) == appId) {
                            remove = true;
                        }
                    } else {
                        if (entUid == UserHandle.getUid(userId, appId)) {
                            remove = true;
                        }
                    }
                } else if (UserHandle.getUserId(entUid) == userId) {
                    remove = true;
                }
                if (remove) {
                    ba.removeAt(i);
                }
            }
            if (ba.size() == 0) {
                pmap.removeAt(ip);
            }
        }
    }
    boolean didSomething = killPackageProcessesLocked(packageName, appId, userId, -100, callerWillRestart, true, doit, evenPersistent, packageName == null ? ("stop user " + userId) : ("stop " + packageName));
    if (mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, null, doit, evenPersistent, userId)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    if (mServices.bringDownDisabledPackageServicesLocked(packageName, null, userId, evenPersistent, true, doit)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    if (packageName == null) {
        // Remove all sticky broadcasts from this user.
        mStickyBroadcasts.remove(userId);
    }
    ArrayList<ContentProviderRecord> providers = new ArrayList<>();
    if (mProviderMap.collectPackageProvidersLocked(packageName, null, doit, evenPersistent, userId, providers)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    for (i = providers.size() - 1; i >= 0; i--) {
        removeDyingProviderLocked(null, providers.get(i), true);
    }
    // Remove transient permissions granted from/to this package/user
    removeUriPermissionsForPackageLocked(packageName, userId, false);
    if (doit) {
        for (i = mBroadcastQueues.length - 1; i >= 0; i--) {
            didSomething |= mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(packageName, null, userId, doit);
        }
    }
    if (packageName == null || uninstalling) {
        // such packages, so they can be left with bad pending intents.
        if (mIntentSenderRecords.size() > 0) {
            Iterator<WeakReference<PendingIntentRecord>> it = mIntentSenderRecords.values().iterator();
            while (it.hasNext()) {
                WeakReference<PendingIntentRecord> wpir = it.next();
                if (wpir == null) {
                    it.remove();
                    continue;
                }
                PendingIntentRecord pir = wpir.get();
                if (pir == null) {
                    it.remove();
                    continue;
                }
                if (packageName == null) {
                    // Stopping user, remove all objects for the user.
                    if (pir.key.userId != userId) {
                        // Not the same user, skip it.
                        continue;
                    }
                } else {
                    if (UserHandle.getAppId(pir.uid) != appId) {
                        // Different app id, skip it.
                        continue;
                    }
                    if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
                        // Different user, skip it.
                        continue;
                    }
                    if (!pir.key.packageName.equals(packageName)) {
                        // Different package, skip it.
                        continue;
                    }
                }
                if (!doit) {
                    return true;
                }
                didSomething = true;
                it.remove();
                pir.canceled = true;
                if (pir.key.activity != null && pir.key.activity.pendingResults != null) {
                    pir.key.activity.pendingResults.remove(pir.ref);
                }
            }
        }
    }
    if (doit) {
        if (purgeCache && packageName != null) {
            AttributeCache ac = AttributeCache.instance();
            if (ac != null) {
                ac.removePackage(packageName);
            }
        }
        if (mBooted) {
            mStackSupervisor.resumeTopActivitiesLocked();
            mStackSupervisor.scheduleIdleLocked();
        }
    }
    return didSomething;
}
#method_after
final boolean forceStopPackageLocked(String packageName, int appId, boolean callerWillRestart, boolean purgeCache, boolean doit, boolean evenPersistent, boolean uninstalling, int userId, String reason) {
    int i;
    if (userId == UserHandle.USER_ALL && packageName == null) {
        Slog.w(TAG, "Can't force stop all processes of all users, that is insane!");
    }
    if (appId < 0 && packageName != null) {
        try {
            appId = UserHandle.getAppId(AppGlobals.getPackageManager().getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING, 0));
        } catch (RemoteException e) {
        }
    }
    if (doit) {
        if (packageName != null) {
            Slog.i(TAG, "Force stopping " + packageName + " appid=" + appId + " user=" + userId + ": " + reason);
        } else {
            Slog.i(TAG, "Force stopping u" + userId + ": " + reason);
        }
        mAppErrors.resetProcessCrashTimeLocked(packageName == null, appId, userId);
    }
    boolean didSomething = killPackageProcessesLocked(packageName, appId, userId, ProcessList.INVALID_ADJ, callerWillRestart, true, doit, evenPersistent, packageName == null ? ("stop user " + userId) : ("stop " + packageName));
    didSomething |= mActivityStarter.clearPendingActivityLaunchesLocked(packageName);
    if (mStackSupervisor.finishDisabledPackageActivitiesLocked(packageName, null, doit, evenPersistent, userId)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    if (mServices.bringDownDisabledPackageServicesLocked(packageName, null, userId, evenPersistent, true, doit)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    if (packageName == null) {
        // Remove all sticky broadcasts from this user.
        mStickyBroadcasts.remove(userId);
    }
    ArrayList<ContentProviderRecord> providers = new ArrayList<>();
    if (mProviderMap.collectPackageProvidersLocked(packageName, null, doit, evenPersistent, userId, providers)) {
        if (!doit) {
            return true;
        }
        didSomething = true;
    }
    for (i = providers.size() - 1; i >= 0; i--) {
        removeDyingProviderLocked(null, providers.get(i), true);
    }
    // Remove transient permissions granted from/to this package/user
    removeUriPermissionsForPackageLocked(packageName, userId, false);
    if (doit) {
        for (i = mBroadcastQueues.length - 1; i >= 0; i--) {
            didSomething |= mBroadcastQueues[i].cleanupDisabledPackageReceiversLocked(packageName, null, userId, doit);
        }
    }
    if (packageName == null || uninstalling) {
        // such packages, so they can be left with bad pending intents.
        if (mIntentSenderRecords.size() > 0) {
            Iterator<WeakReference<PendingIntentRecord>> it = mIntentSenderRecords.values().iterator();
            while (it.hasNext()) {
                WeakReference<PendingIntentRecord> wpir = it.next();
                if (wpir == null) {
                    it.remove();
                    continue;
                }
                PendingIntentRecord pir = wpir.get();
                if (pir == null) {
                    it.remove();
                    continue;
                }
                if (packageName == null) {
                    // Stopping user, remove all objects for the user.
                    if (pir.key.userId != userId) {
                        // Not the same user, skip it.
                        continue;
                    }
                } else {
                    if (UserHandle.getAppId(pir.uid) != appId) {
                        // Different app id, skip it.
                        continue;
                    }
                    if (userId != UserHandle.USER_ALL && pir.key.userId != userId) {
                        // Different user, skip it.
                        continue;
                    }
                    if (!pir.key.packageName.equals(packageName)) {
                        // Different package, skip it.
                        continue;
                    }
                }
                if (!doit) {
                    return true;
                }
                didSomething = true;
                it.remove();
                pir.canceled = true;
                if (pir.key.activity != null && pir.key.activity.pendingResults != null) {
                    pir.key.activity.pendingResults.remove(pir.ref);
                }
            }
        }
    }
    if (doit) {
        if (purgeCache && packageName != null) {
            AttributeCache ac = AttributeCache.instance();
            if (ac != null) {
                ac.removePackage(packageName);
            }
        }
        if (mBooted) {
            mStackSupervisor.resumeFocusedStackTopActivityLocked();
            mStackSupervisor.scheduleIdleLocked();
        }
    }
    return didSomething;
}
#end_block

#method_before
private final ProcessRecord removeProcessNameLocked(final String name, final int uid) {
    ProcessRecord old = mProcessNames.remove(name, uid);
    if (old != null) {
        old.uidRecord.numProcs--;
        if (old.uidRecord.numProcs == 0) {
            // No more processes using this uid, tell clients it is gone.
            if (DEBUG_UID_OBSERVERS)
                Slog.i(TAG_UID_OBSERVERS, "No more processes in " + old.uidRecord);
            enqueueUidChangeLocked(old.uidRecord, true);
            mActiveUids.remove(uid);
        }
        old.uidRecord = null;
    }
    mIsolatedProcesses.remove(uid);
    return old;
}
#method_after
private final ProcessRecord removeProcessNameLocked(final String name, final int uid) {
    ProcessRecord old = mProcessNames.remove(name, uid);
    if (old != null) {
        old.uidRecord.numProcs--;
        if (old.uidRecord.numProcs == 0) {
            // No more processes using this uid, tell clients it is gone.
            if (DEBUG_UID_OBSERVERS)
                Slog.i(TAG_UID_OBSERVERS, "No more processes in " + old.uidRecord);
            enqueueUidChangeLocked(old.uidRecord, -1, UidRecord.CHANGE_GONE);
            mActiveUids.remove(uid);
            noteUidProcessState(uid, ActivityManager.PROCESS_STATE_NONEXISTENT);
        }
        old.uidRecord = null;
    }
    mIsolatedProcesses.remove(uid);
    return old;
}
#end_block

#method_before
private final void addProcessNameLocked(ProcessRecord proc) {
    // We shouldn't already have a process under this name, but just in case we
    // need to clean up whatever may be there now.
    ProcessRecord old = removeProcessNameLocked(proc.processName, proc.uid);
    if (old == proc && proc.persistent) {
        // We are re-adding a persistent process.  Whatevs!  Just leave it there.
        Slog.w(TAG, "Re-adding persistent process " + proc);
    } else if (old != null) {
        Slog.wtf(TAG, "Already have existing proc " + old + " when adding " + proc);
    }
    UidRecord uidRec = mActiveUids.get(proc.uid);
    if (uidRec == null) {
        uidRec = new UidRecord(proc.uid);
        // This is the first appearance of the uid, report it now!
        if (DEBUG_UID_OBSERVERS)
            Slog.i(TAG_UID_OBSERVERS, "Creating new process uid: " + uidRec);
        mActiveUids.put(proc.uid, uidRec);
        enqueueUidChangeLocked(uidRec, false);
    }
    proc.uidRecord = uidRec;
    uidRec.numProcs++;
    mProcessNames.put(proc.processName, proc.uid, proc);
    if (proc.isolated) {
        mIsolatedProcesses.put(proc.uid, proc);
    }
}
#method_after
private final void addProcessNameLocked(ProcessRecord proc) {
    // We shouldn't already have a process under this name, but just in case we
    // need to clean up whatever may be there now.
    ProcessRecord old = removeProcessNameLocked(proc.processName, proc.uid);
    if (old == proc && proc.persistent) {
        // We are re-adding a persistent process.  Whatevs!  Just leave it there.
        Slog.w(TAG, "Re-adding persistent process " + proc);
    } else if (old != null) {
        Slog.wtf(TAG, "Already have existing proc " + old + " when adding " + proc);
    }
    UidRecord uidRec = mActiveUids.get(proc.uid);
    if (uidRec == null) {
        uidRec = new UidRecord(proc.uid);
        // This is the first appearance of the uid, report it now!
        if (DEBUG_UID_OBSERVERS)
            Slog.i(TAG_UID_OBSERVERS, "Creating new process uid: " + uidRec);
        mActiveUids.put(proc.uid, uidRec);
        noteUidProcessState(uidRec.uid, uidRec.curProcState);
        enqueueUidChangeLocked(uidRec, -1, UidRecord.CHANGE_ACTIVE);
    }
    proc.uidRecord = uidRec;
    uidRec.numProcs++;
    mProcessNames.put(proc.processName, proc.uid, proc);
    if (proc.isolated) {
        mIsolatedProcesses.put(proc.uid, proc);
    }
}
#end_block

#method_before
private final boolean removeProcessLocked(ProcessRecord app, boolean callerWillRestart, boolean allowRestart, String reason) {
    final String name = app.processName;
    final int uid = app.uid;
    if (DEBUG_PROCESSES)
        Slog.d(TAG_PROCESSES, "Force removing proc " + app.toShortString() + " (" + name + "/" + uid + ")");
    removeProcessNameLocked(name, uid);
    if (mHeavyWeightProcess == app) {
        mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG, mHeavyWeightProcess.userId, 0));
        mHeavyWeightProcess = null;
    }
    boolean needRestart = false;
    if (app.pid > 0 && app.pid != MY_PID) {
        int pid = app.pid;
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
        if (app.isolated) {
            mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
        }
        boolean willRestart = false;
        if (app.persistent && !app.isolated) {
            if (!callerWillRestart) {
                willRestart = true;
            } else {
                needRestart = true;
            }
        }
        app.kill(reason, true);
        handleAppDiedLocked(app, willRestart, allowRestart);
        if (willRestart) {
            removeLruProcessLocked(app);
            addAppLocked(app.info, false, null);
        }
    } else {
        mRemovedProcesses.add(app);
    }
    return needRestart;
}
#method_after
boolean removeProcessLocked(ProcessRecord app, boolean callerWillRestart, boolean allowRestart, String reason) {
    final String name = app.processName;
    final int uid = app.uid;
    if (DEBUG_PROCESSES)
        Slog.d(TAG_PROCESSES, "Force removing proc " + app.toShortString() + " (" + name + "/" + uid + ")");
    ProcessRecord old = mProcessNames.get(name, uid);
    if (old != app) {
        // This process is no longer active, so nothing to do.
        Slog.w(TAG, "Ignoring remove of inactive process: " + app);
        return false;
    }
    removeProcessNameLocked(name, uid);
    if (mHeavyWeightProcess == app) {
        mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG, mHeavyWeightProcess.userId, 0));
        mHeavyWeightProcess = null;
    }
    boolean needRestart = false;
    if (app.pid > 0 && app.pid != MY_PID) {
        int pid = app.pid;
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
        if (app.isolated) {
            mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
        }
        boolean willRestart = false;
        if (app.persistent && !app.isolated) {
            if (!callerWillRestart) {
                willRestart = true;
            } else {
                needRestart = true;
            }
        }
        app.kill(reason, true);
        handleAppDiedLocked(app, willRestart, allowRestart);
        if (willRestart) {
            removeLruProcessLocked(app);
            addAppLocked(app.info, false, null);
        }
    } else {
        mRemovedProcesses.add(app);
    }
    return needRestart;
}
#end_block

#method_before
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }
    if (app == null) {
        Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
        if (pid > 0 && pid != MY_PID) {
            Process.killProcessQuiet(pid);
        // TODO: killProcessGroup(app.info.uid, pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
            // Ignore exceptions.
            }
        }
        return false;
    }
    // process, clean it up now.
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, "link fail", processName);
        return false;
    }
    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = -100;
    app.curSchedGroup = app.setSchedGroup = Process.THREAD_GROUP_DEFAULT;
    app.forcingToForeground = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }
    if (!normalMode) {
        Slog.i(TAG, "Launching preboot mode app: " + app);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
    try {
        int testMode = IApplicationThread.DEBUG_OFF;
        if (mDebugApp != null && mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        String profileFile = app.instrumentationProfileFile;
        ParcelFileDescriptor profileFd = null;
        int samplingInterval = 0;
        boolean profileAutoStop = false;
        if (mProfileApp != null && mProfileApp.equals(processName)) {
            mProfileProc = app;
            profileFile = mProfileFile;
            profileFd = mProfileFd;
            samplingInterval = mSamplingInterval;
            profileAutoStop = mAutoStopProfiler;
        }
        boolean enableOpenGlTrace = false;
        if (mOpenGlTraceApp != null && mOpenGlTraceApp.equals(processName)) {
            enableOpenGlTrace = true;
            mOpenGlTraceApp = null;
        }
        boolean enableTrackAllocation = false;
        if (mTrackAllocationApp != null && mTrackAllocationApp.equals(processName)) {
            enableTrackAllocation = true;
            mTrackAllocationApp = null;
        }
        // If the app is being launched for restore or full backup, set it up specially
        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null && mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = (mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL);
        }
        ensurePackageDexOpt(app.instrumentationInfo != null ? app.instrumentationInfo.packageName : app.info.packageName);
        if (app.instrumentationClass != null) {
            ensurePackageDexOpt(app.instrumentationClass.getPackageName());
        }
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + mConfiguration);
        ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        if (profileFd != null) {
            profileFd = profileFd.dup();
        }
        ProfilerInfo profilerInfo = profileFile == null ? null : new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop);
        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, enableOpenGlTrace, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked());
        updateLruProcessLocked(app, false, null);
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        // todo: Yikes!  What should we do?  For now we will try to
        // start another process, but that could easily get us in
        // an infinite loop of restarting processes...
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, "bind fail", processName);
        return false;
    }
    // Remove this record from the list of starting applications.
    mPersistentStartingProcesses.remove(app);
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    // See if the top visible activity is waiting to run in this process...
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    // Find any services that should be running in this process...
    if (!badApp) {
        try {
            didSomething |= mServices.attachApplicationLocked(app, processName);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
            badApp = true;
        }
    }
    // Check if a next-broadcast receiver is in this process...
    if (!badApp && isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
        } catch (Exception e) {
            // If the app died trying to launch the receiver we declare it 'bad'
            Slog.wtf(TAG, "Exception thrown dispatching broadcasts in " + app, e);
            badApp = true;
        }
    }
    // Check whether the next backup agent is in this process...
    if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.uid) {
        if (DEBUG_BACKUP)
            Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
        ensurePackageDexOpt(mBackupTarget.appInfo.packageName);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e);
            badApp = true;
        }
    }
    if (badApp) {
        app.kill("error during init", true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked();
    }
    return true;
}
#method_after
private final boolean attachApplicationLocked(IApplicationThread thread, int pid) {
    // Find the application record that is being attached...  either via
    // the pid if we are running in multiple processes, or just pull the
    // next app record if we are emulating process with anonymous threads.
    ProcessRecord app;
    if (pid != MY_PID && pid >= 0) {
        synchronized (mPidsSelfLocked) {
            app = mPidsSelfLocked.get(pid);
        }
    } else {
        app = null;
    }
    if (app == null) {
        Slog.w(TAG, "No pending application record for pid " + pid + " (IApplicationThread " + thread + "); dropping process");
        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);
        if (pid > 0 && pid != MY_PID) {
            Process.killProcessQuiet(pid);
        // TODO: killProcessGroup(app.info.uid, pid);
        } else {
            try {
                thread.scheduleExit();
            } catch (Exception e) {
            // Ignore exceptions.
            }
        }
        return false;
    }
    // process, clean it up now.
    if (app.thread != null) {
        handleAppDiedLocked(app, true, true);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "Binding process pid " + pid + " to record " + app);
    final String processName = app.processName;
    try {
        AppDeathRecipient adr = new AppDeathRecipient(app, pid, thread);
        thread.asBinder().linkToDeath(adr, 0);
        app.deathRecipient = adr;
    } catch (RemoteException e) {
        app.resetPackageList(mProcessStats);
        startProcessLocked(app, "link fail", processName);
        return false;
    }
    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);
    app.makeActive(thread, mProcessStats);
    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;
    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
    app.forcingToForeground = null;
    updateProcessForegroundLocked(app, false, false);
    app.hasShownUi = false;
    app.debugging = false;
    app.cached = false;
    app.killedByAm = false;
    app.killed = false;
    // We carefully use the same state that PackageManager uses for
    // filtering, since we use this flag to decide if we need to install
    // providers when user is unlocked later
    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);
    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
    boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
    List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
    if (providers != null && checkAppInLaunchingProvidersLocked(app)) {
        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
        msg.obj = app;
        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
    }
    if (!normalMode) {
        Slog.i(TAG, "Launching preboot mode app: " + app);
    }
    if (DEBUG_ALL)
        Slog.v(TAG, "New app record " + app + " thread=" + thread.asBinder() + " pid=" + pid);
    try {
        int testMode = IApplicationThread.DEBUG_OFF;
        if (mDebugApp != null && mDebugApp.equals(processName)) {
            testMode = mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON;
            app.debugging = true;
            if (mDebugTransient) {
                mDebugApp = mOrigDebugApp;
                mWaitForDebugger = mOrigWaitForDebugger;
            }
        }
        String profileFile = app.instrumentationProfileFile;
        ParcelFileDescriptor profileFd = null;
        int samplingInterval = 0;
        boolean profileAutoStop = false;
        if (mProfileApp != null && mProfileApp.equals(processName)) {
            mProfileProc = app;
            profileFile = mProfileFile;
            profileFd = mProfileFd;
            samplingInterval = mSamplingInterval;
            profileAutoStop = mAutoStopProfiler;
        }
        boolean enableTrackAllocation = false;
        if (mTrackAllocationApp != null && mTrackAllocationApp.equals(processName)) {
            enableTrackAllocation = true;
            mTrackAllocationApp = null;
        }
        // If the app is being launched for restore or full backup, set it up specially
        boolean isRestrictedBackupMode = false;
        if (mBackupTarget != null && mBackupAppName.equals(processName)) {
            isRestrictedBackupMode = mBackupTarget.appInfo.uid >= Process.FIRST_APPLICATION_UID && ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL));
        }
        if (app.instrumentationClass != null) {
            notifyPackageUse(app.instrumentationClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);
        }
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Binding proc " + processName + " with config " + mConfiguration);
        ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info;
        app.compat = compatibilityInfoForPackageLocked(appInfo);
        if (profileFd != null) {
            profileFd = profileFd.dup();
        }
        ProfilerInfo profilerInfo = profileFile == null ? null : new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop);
        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked());
        updateLruProcessLocked(app, false, null);
        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();
    } catch (Exception e) {
        // todo: Yikes!  What should we do?  For now we will try to
        // start another process, but that could easily get us in
        // an infinite loop of restarting processes...
        Slog.wtf(TAG, "Exception thrown during bind of " + app, e);
        app.resetPackageList(mProcessStats);
        app.unlinkDeathRecipient();
        startProcessLocked(app, "bind fail", processName);
        return false;
    }
    // Remove this record from the list of starting applications.
    mPersistentStartingProcesses.remove(app);
    if (DEBUG_PROCESSES && mProcessesOnHold.contains(app))
        Slog.v(TAG_PROCESSES, "Attach application locked removing on hold: " + app);
    mProcessesOnHold.remove(app);
    boolean badApp = false;
    boolean didSomething = false;
    // See if the top visible activity is waiting to run in this process...
    if (normalMode) {
        try {
            if (mStackSupervisor.attachApplicationLocked(app)) {
                didSomething = true;
            }
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown launching activities in " + app, e);
            badApp = true;
        }
    }
    // Find any services that should be running in this process...
    if (!badApp) {
        try {
            didSomething |= mServices.attachApplicationLocked(app, processName);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown starting services in " + app, e);
            badApp = true;
        }
    }
    // Check if a next-broadcast receiver is in this process...
    if (!badApp && isPendingBroadcastProcessLocked(pid)) {
        try {
            didSomething |= sendPendingBroadcastsLocked(app);
        } catch (Exception e) {
            // If the app died trying to launch the receiver we declare it 'bad'
            Slog.wtf(TAG, "Exception thrown dispatching broadcasts in " + app, e);
            badApp = true;
        }
    }
    // Check whether the next backup agent is in this process...
    if (!badApp && mBackupTarget != null && mBackupTarget.appInfo.uid == app.uid) {
        if (DEBUG_BACKUP)
            Slog.v(TAG_BACKUP, "New app is backup target, launching agent for " + app);
        notifyPackageUse(mBackupTarget.appInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_BACKUP);
        try {
            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo, compatibilityInfoForPackageLocked(mBackupTarget.appInfo), mBackupTarget.backupMode);
        } catch (Exception e) {
            Slog.wtf(TAG, "Exception thrown creating backup agent in " + app, e);
            badApp = true;
        }
    }
    if (badApp) {
        app.kill("error during init", true);
        handleAppDiedLocked(app, false, true);
        return false;
    }
    if (!didSomething) {
        updateOomAdjLocked();
    }
    return true;
}
#end_block

#method_before
@Override
public void keyguardGoingAway(boolean disableWindowAnimations, boolean keyguardGoingToNotificationShade) {
    enforceNotIsolatedCaller("keyguardGoingAway");
    final long token = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            if (DEBUG_LOCKSCREEN)
                logLockScreen("");
            mWindowManager.keyguardGoingAway(disableWindowAnimations, keyguardGoingToNotificationShade);
            if (mLockScreenShown == LOCK_SCREEN_SHOWN) {
                mLockScreenShown = LOCK_SCREEN_HIDDEN;
                updateSleepIfNeededLocked();
            }
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public void keyguardGoingAway(int flags) {
    enforceNotIsolatedCaller("keyguardGoingAway");
    final long token = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            if (DEBUG_LOCKSCREEN)
                logLockScreen("");
            mWindowManager.keyguardGoingAway(flags);
            if (mLockScreenShown == LOCK_SCREEN_SHOWN) {
                mLockScreenShown = LOCK_SCREEN_HIDDEN;
                updateSleepIfNeededLocked();
                // Some stack visibility might change (e.g. docked stack)
                mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
                applyVrModeIfNeededLocked(mFocusedActivity, true);
            }
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#end_block

#method_before
final void finishBooting() {
    synchronized (this) {
        if (!mBootAnimationComplete) {
            mCallFinishBooting = true;
            return;
        }
        mCallFinishBooting = false;
    }
    ArraySet<String> completedIsas = new ArraySet<String>();
    for (String abi : Build.SUPPORTED_ABIS) {
        Process.establishZygoteConnectionForAbi(abi);
        final String instructionSet = VMRuntime.getInstructionSet(abi);
        if (!completedIsas.contains(instructionSet)) {
            if (mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi)) != 0) {
                Slog.e(TAG, "Unable to mark boot complete for abi: " + abi);
            }
            completedIsas.add(instructionSet);
        }
    }
    IntentFilter pkgFilter = new IntentFilter();
    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
    pkgFilter.addDataScheme("package");
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
            if (pkgs != null) {
                for (String pkg : pkgs) {
                    synchronized (ActivityManagerService.this) {
                        if (forceStopPackageLocked(pkg, -1, false, false, false, false, false, 0, "query restart")) {
                            setResultCode(Activity.RESULT_OK);
                            return;
                        }
                    }
                }
            }
        }
    }, pkgFilter);
    IntentFilter dumpheapFilter = new IntentFilter();
    dumpheapFilter.addAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getBooleanExtra(DumpHeapActivity.EXTRA_DELAY_DELETE, false)) {
                mHandler.sendEmptyMessageDelayed(POST_DUMP_HEAP_NOTIFICATION_MSG, 5 * 60 * 1000);
            } else {
                mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);
            }
        }
    }, dumpheapFilter);
    // Let system services know.
    mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);
    synchronized (this) {
        // Ensure that any processes we had put on hold are now started
        // up.
        final int NP = mProcessesOnHold.size();
        if (NP > 0) {
            ArrayList<ProcessRecord> procs = new ArrayList<ProcessRecord>(mProcessesOnHold);
            for (int ip = 0; ip < NP; ip++) {
                if (DEBUG_PROCESSES)
                    Slog.v(TAG_PROCESSES, "Starting process on hold: " + procs.get(ip));
                startProcessLocked(procs.get(ip), "on-hold", null);
            }
        }
        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            // Start looking for apps that are abusing wake locks.
            Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
            mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY);
            // Tell anyone interested that we are done booting!
            SystemProperties.set("sys.boot_completed", "1");
            // And trigger dev.bootcomplete if we are not showing encryption progress
            if (!"trigger_restart_min_framework".equals(SystemProperties.get("vold.decrypt")) || "".equals(SystemProperties.get("vold.encrypt_progress"))) {
                SystemProperties.set("dev.bootcomplete", "1");
            }
            for (int i = 0; i < mStartedUsers.size(); i++) {
                UserState uss = mStartedUsers.valueAt(i);
                if (uss.mState == UserState.STATE_BOOTING) {
                    uss.mState = UserState.STATE_RUNNING;
                    final int userId = mStartedUsers.keyAt(i);
                    Intent intent = new Intent(Intent.ACTION_BOOT_COMPLETED, null);
                    intent.putExtra(Intent.EXTRA_USER_HANDLE, userId);
                    intent.addFlags(Intent.FLAG_RECEIVER_NO_ABORT);
                    broadcastIntentLocked(null, null, intent, null, new IIntentReceiver.Stub() {

                        @Override
                        public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
                            synchronized (ActivityManagerService.this) {
                                requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                            }
                        }
                    }, 0, null, null, new String[] { android.Manifest.permission.RECEIVE_BOOT_COMPLETED }, AppOpsManager.OP_NONE, null, true, false, MY_PID, Process.SYSTEM_UID, userId);
                }
            }
            scheduleStartProfilesLocked();
        }
    }
}
#method_after
final void finishBooting() {
    synchronized (this) {
        if (!mBootAnimationComplete) {
            mCallFinishBooting = true;
            return;
        }
        mCallFinishBooting = false;
    }
    ArraySet<String> completedIsas = new ArraySet<String>();
    for (String abi : Build.SUPPORTED_ABIS) {
        Process.zygoteProcess.establishZygoteConnectionForAbi(abi);
        final String instructionSet = VMRuntime.getInstructionSet(abi);
        if (!completedIsas.contains(instructionSet)) {
            try {
                mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi));
            } catch (InstallerException e) {
                Slog.w(TAG, "Unable to mark boot complete for abi: " + abi + " (" + e.getMessage() + ")");
            }
            completedIsas.add(instructionSet);
        }
    }
    IntentFilter pkgFilter = new IntentFilter();
    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);
    pkgFilter.addDataScheme("package");
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);
            if (pkgs != null) {
                for (String pkg : pkgs) {
                    synchronized (ActivityManagerService.this) {
                        if (forceStopPackageLocked(pkg, -1, false, false, false, false, false, 0, "query restart")) {
                            setResultCode(Activity.RESULT_OK);
                            return;
                        }
                    }
                }
            }
        }
    }, pkgFilter);
    IntentFilter dumpheapFilter = new IntentFilter();
    dumpheapFilter.addAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);
    mContext.registerReceiver(new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            if (intent.getBooleanExtra(DumpHeapActivity.EXTRA_DELAY_DELETE, false)) {
                mHandler.sendEmptyMessageDelayed(POST_DUMP_HEAP_NOTIFICATION_MSG, 5 * 60 * 1000);
            } else {
                mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);
            }
        }
    }, dumpheapFilter);
    // Let system services know.
    mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);
    synchronized (this) {
        // Ensure that any processes we had put on hold are now started
        // up.
        final int NP = mProcessesOnHold.size();
        if (NP > 0) {
            ArrayList<ProcessRecord> procs = new ArrayList<ProcessRecord>(mProcessesOnHold);
            for (int ip = 0; ip < NP; ip++) {
                if (DEBUG_PROCESSES)
                    Slog.v(TAG_PROCESSES, "Starting process on hold: " + procs.get(ip));
                startProcessLocked(procs.get(ip), "on-hold", null);
            }
        }
        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            // Start looking for apps that are abusing wake locks.
            Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);
            mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY);
            // Tell anyone interested that we are done booting!
            SystemProperties.set("sys.boot_completed", "1");
            // And trigger dev.bootcomplete if we are not showing encryption progress
            if (!"trigger_restart_min_framework".equals(SystemProperties.get("vold.decrypt")) || "".equals(SystemProperties.get("vold.encrypt_progress"))) {
                SystemProperties.set("dev.bootcomplete", "1");
            }
            mUserController.sendBootCompletedLocked(new IIntentReceiver.Stub() {

                @Override
                public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
                    synchronized (ActivityManagerService.this) {
                        requestPssAllProcsLocked(SystemClock.uptimeMillis(), true, false);
                    }
                }
            });
            scheduleStartProfilesLocked();
        }
    }
}
#end_block

#method_before
@Override
public final void activityResumed(IBinder token) {
    final long origId = Binder.clearCallingIdentity();
    synchronized (this) {
        ActivityStack stack = ActivityRecord.getStackLocked(token);
        if (stack != null) {
            ActivityRecord.activityResumedLocked(token);
        }
    }
    Binder.restoreCallingIdentity(origId);
}
#method_after
@Override
public final void activityResumed(IBinder token) {
    final long origId = Binder.clearCallingIdentity();
    synchronized (this) {
        ActivityStack stack = ActivityRecord.getStackLocked(token);
        if (stack != null) {
            stack.activityResumedLocked(token);
        }
    }
    Binder.restoreCallingIdentity(origId);
}
#end_block

#method_before
@Override
public IIntentSender getIntentSender(int type, String packageName, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle options, int userId) {
    enforceNotIsolatedCaller("getIntentSender");
    // Refuse possible leaked file descriptors
    if (intents != null) {
        if (intents.length < 1) {
            throw new IllegalArgumentException("Intents array length must be >= 1");
        }
        for (int i = 0; i < intents.length; i++) {
            Intent intent = intents[i];
            if (intent != null) {
                if (intent.hasFileDescriptors()) {
                    throw new IllegalArgumentException("File descriptors passed in Intent");
                }
                if (type == ActivityManager.INTENT_SENDER_BROADCAST && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0) {
                    throw new IllegalArgumentException("Can't use FLAG_RECEIVER_BOOT_UPGRADE here");
                }
                intents[i] = new Intent(intent);
            }
        }
        if (resolvedTypes != null && resolvedTypes.length != intents.length) {
            throw new IllegalArgumentException("Intent array length does not match resolvedTypes length");
        }
    }
    if (options != null) {
        if (options.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in options");
        }
    }
    synchronized (this) {
        int callingUid = Binder.getCallingUid();
        int origUserId = userId;
        userId = handleIncomingUser(Binder.getCallingPid(), callingUid, userId, type == ActivityManager.INTENT_SENDER_BROADCAST, ALLOW_NON_FULL, "getIntentSender", null);
        if (origUserId == UserHandle.USER_CURRENT) {
            // We don't want to evaluate this until the pending intent is
            // actually executed.  However, we do want to always do the
            // security checking for it above.
            userId = UserHandle.USER_CURRENT;
        }
        try {
            if (callingUid != 0 && callingUid != Process.SYSTEM_UID) {
                int uid = AppGlobals.getPackageManager().getPackageUid(packageName, UserHandle.getUserId(callingUid));
                if (!UserHandle.isSameApp(callingUid, uid)) {
                    String msg = "Permission Denial: getIntentSender() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + ", (need uid=" + uid + ")" + " is not allowed to send as package " + packageName;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
            }
            return getIntentSenderLocked(type, packageName, callingUid, userId, token, resultWho, requestCode, intents, resolvedTypes, flags, options);
        } catch (RemoteException e) {
            throw new SecurityException(e);
        }
    }
}
#method_after
@Override
public IIntentSender getIntentSender(int type, String packageName, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions, int userId) {
    enforceNotIsolatedCaller("getIntentSender");
    // Refuse possible leaked file descriptors
    if (intents != null) {
        if (intents.length < 1) {
            throw new IllegalArgumentException("Intents array length must be >= 1");
        }
        for (int i = 0; i < intents.length; i++) {
            Intent intent = intents[i];
            if (intent != null) {
                if (intent.hasFileDescriptors()) {
                    throw new IllegalArgumentException("File descriptors passed in Intent");
                }
                if (type == ActivityManager.INTENT_SENDER_BROADCAST && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) != 0) {
                    throw new IllegalArgumentException("Can't use FLAG_RECEIVER_BOOT_UPGRADE here");
                }
                intents[i] = new Intent(intent);
            }
        }
        if (resolvedTypes != null && resolvedTypes.length != intents.length) {
            throw new IllegalArgumentException("Intent array length does not match resolvedTypes length");
        }
    }
    if (bOptions != null) {
        if (bOptions.hasFileDescriptors()) {
            throw new IllegalArgumentException("File descriptors passed in options");
        }
    }
    synchronized (this) {
        int callingUid = Binder.getCallingUid();
        int origUserId = userId;
        userId = mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid, userId, type == ActivityManager.INTENT_SENDER_BROADCAST, ALLOW_NON_FULL, "getIntentSender", null);
        if (origUserId == UserHandle.USER_CURRENT) {
            // We don't want to evaluate this until the pending intent is
            // actually executed.  However, we do want to always do the
            // security checking for it above.
            userId = UserHandle.USER_CURRENT;
        }
        try {
            if (callingUid != 0 && callingUid != Process.SYSTEM_UID) {
                final int uid = AppGlobals.getPackageManager().getPackageUid(packageName, MATCH_DEBUG_TRIAGED_MISSING, UserHandle.getUserId(callingUid));
                if (!UserHandle.isSameApp(callingUid, uid)) {
                    String msg = "Permission Denial: getIntentSender() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + ", (need uid=" + uid + ")" + " is not allowed to send as package " + packageName;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
            }
            return getIntentSenderLocked(type, packageName, callingUid, userId, token, resultWho, requestCode, intents, resolvedTypes, flags, bOptions);
        } catch (RemoteException e) {
            throw new SecurityException(e);
        }
    }
}
#end_block

#method_before
IIntentSender getIntentSenderLocked(int type, String packageName, int callingUid, int userId, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle options) {
    if (DEBUG_MU)
        Slog.v(TAG_MU, "getIntentSenderLocked(): uid=" + callingUid);
    ActivityRecord activity = null;
    if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {
        activity = ActivityRecord.isInStackLocked(token);
        if (activity == null) {
            return null;
        }
        if (activity.finishing) {
            return null;
        }
    }
    final boolean noCreate = (flags & PendingIntent.FLAG_NO_CREATE) != 0;
    final boolean cancelCurrent = (flags & PendingIntent.FLAG_CANCEL_CURRENT) != 0;
    final boolean updateCurrent = (flags & PendingIntent.FLAG_UPDATE_CURRENT) != 0;
    flags &= ~(PendingIntent.FLAG_NO_CREATE | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_UPDATE_CURRENT);
    PendingIntentRecord.Key key = new PendingIntentRecord.Key(type, packageName, activity, resultWho, requestCode, intents, resolvedTypes, flags, options, userId);
    WeakReference<PendingIntentRecord> ref;
    ref = mIntentSenderRecords.get(key);
    PendingIntentRecord rec = ref != null ? ref.get() : null;
    if (rec != null) {
        if (!cancelCurrent) {
            if (updateCurrent) {
                if (rec.key.requestIntent != null) {
                    rec.key.requestIntent.replaceExtras(intents != null ? intents[intents.length - 1] : null);
                }
                if (intents != null) {
                    intents[intents.length - 1] = rec.key.requestIntent;
                    rec.key.allIntents = intents;
                    rec.key.allResolvedTypes = resolvedTypes;
                } else {
                    rec.key.allIntents = null;
                    rec.key.allResolvedTypes = null;
                }
            }
            return rec;
        }
        rec.canceled = true;
        mIntentSenderRecords.remove(key);
    }
    if (noCreate) {
        return rec;
    }
    rec = new PendingIntentRecord(this, key, callingUid);
    mIntentSenderRecords.put(key, rec.ref);
    if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {
        if (activity.pendingResults == null) {
            activity.pendingResults = new HashSet<WeakReference<PendingIntentRecord>>();
        }
        activity.pendingResults.add(rec.ref);
    }
    return rec;
}
#method_after
IIntentSender getIntentSenderLocked(int type, String packageName, int callingUid, int userId, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle bOptions) {
    if (DEBUG_MU)
        Slog.v(TAG_MU, "getIntentSenderLocked(): uid=" + callingUid);
    ActivityRecord activity = null;
    if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {
        activity = ActivityRecord.isInStackLocked(token);
        if (activity == null) {
            Slog.w(TAG, "Failed createPendingResult: activity " + token + " not in any stack");
            return null;
        }
        if (activity.finishing) {
            Slog.w(TAG, "Failed createPendingResult: activity " + activity + " is finishing");
            return null;
        }
    }
    // okay poking into any contained extras.
    if (intents != null) {
        for (int i = 0; i < intents.length; i++) {
            intents[i].setDefusable(true);
        }
    }
    Bundle.setDefusable(bOptions, true);
    final boolean noCreate = (flags & PendingIntent.FLAG_NO_CREATE) != 0;
    final boolean cancelCurrent = (flags & PendingIntent.FLAG_CANCEL_CURRENT) != 0;
    final boolean updateCurrent = (flags & PendingIntent.FLAG_UPDATE_CURRENT) != 0;
    flags &= ~(PendingIntent.FLAG_NO_CREATE | PendingIntent.FLAG_CANCEL_CURRENT | PendingIntent.FLAG_UPDATE_CURRENT);
    PendingIntentRecord.Key key = new PendingIntentRecord.Key(type, packageName, activity, resultWho, requestCode, intents, resolvedTypes, flags, bOptions, userId);
    WeakReference<PendingIntentRecord> ref;
    ref = mIntentSenderRecords.get(key);
    PendingIntentRecord rec = ref != null ? ref.get() : null;
    if (rec != null) {
        if (!cancelCurrent) {
            if (updateCurrent) {
                if (rec.key.requestIntent != null) {
                    rec.key.requestIntent.replaceExtras(intents != null ? intents[intents.length - 1] : null);
                }
                if (intents != null) {
                    intents[intents.length - 1] = rec.key.requestIntent;
                    rec.key.allIntents = intents;
                    rec.key.allResolvedTypes = resolvedTypes;
                } else {
                    rec.key.allIntents = null;
                    rec.key.allResolvedTypes = null;
                }
            }
            return rec;
        }
        rec.canceled = true;
        mIntentSenderRecords.remove(key);
    }
    if (noCreate) {
        return rec;
    }
    rec = new PendingIntentRecord(this, key, callingUid);
    mIntentSenderRecords.put(key, rec.ref);
    if (type == ActivityManager.INTENT_SENDER_ACTIVITY_RESULT) {
        if (activity.pendingResults == null) {
            activity.pendingResults = new HashSet<WeakReference<PendingIntentRecord>>();
        }
        activity.pendingResults.add(rec.ref);
    }
    return rec;
}
#end_block

#method_before
@Override
public void cancelIntentSender(IIntentSender sender) {
    if (!(sender instanceof PendingIntentRecord)) {
        return;
    }
    synchronized (this) {
        PendingIntentRecord rec = (PendingIntentRecord) sender;
        try {
            int uid = AppGlobals.getPackageManager().getPackageUid(rec.key.packageName, UserHandle.getCallingUserId());
            if (!UserHandle.isSameApp(uid, Binder.getCallingUid())) {
                String msg = "Permission Denial: cancelIntentSender() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " is not allowed to cancel packges " + rec.key.packageName;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            }
        } catch (RemoteException e) {
            throw new SecurityException(e);
        }
        cancelIntentSenderLocked(rec, true);
    }
}
#method_after
@Override
public void cancelIntentSender(IIntentSender sender) {
    if (!(sender instanceof PendingIntentRecord)) {
        return;
    }
    synchronized (this) {
        PendingIntentRecord rec = (PendingIntentRecord) sender;
        try {
            final int uid = AppGlobals.getPackageManager().getPackageUid(rec.key.packageName, MATCH_DEBUG_TRIAGED_MISSING, UserHandle.getCallingUserId());
            if (!UserHandle.isSameApp(uid, Binder.getCallingUid())) {
                String msg = "Permission Denial: cancelIntentSender() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " is not allowed to cancel packges " + rec.key.packageName;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            }
        } catch (RemoteException e) {
            throw new SecurityException(e);
        }
        cancelIntentSenderLocked(rec, true);
    }
}
#end_block

#method_before
@Override
public Intent getIntentForIntentSender(IIntentSender pendingResult) {
    if (!(pendingResult instanceof PendingIntentRecord)) {
        return null;
    }
    try {
        PendingIntentRecord res = (PendingIntentRecord) pendingResult;
        return res.key.requestIntent != null ? new Intent(res.key.requestIntent) : null;
    } catch (ClassCastException e) {
    }
    return null;
}
#method_after
@Override
public Intent getIntentForIntentSender(IIntentSender pendingResult) {
    enforceCallingPermission(Manifest.permission.GET_INTENT_SENDER_INTENT, "getIntentForIntentSender()");
    if (!(pendingResult instanceof PendingIntentRecord)) {
        return null;
    }
    try {
        PendingIntentRecord res = (PendingIntentRecord) pendingResult;
        return res.key.requestIntent != null ? new Intent(res.key.requestIntent) : null;
    } catch (ClassCastException e) {
    }
    return null;
}
#end_block

#method_before
@Override
public void getProcessStatesFromPids(/*in*/
int[] pids, /*out*/
int[] states) {
    mActivityManagerService.getProcessStatesForPIDs(/*in*/
    pids, /*out*/
    states);
}
#method_after
@Override
public void getProcessStatesFromPids(/*in*/
int[] pids, /*out*/
int[] states) {
    mActivityManagerService.getProcessStatesAndOomScoresForPIDs(/*in*/
    pids, /*out*/
    states, null);
}
#end_block

#method_before
private ProviderInfo getProviderInfoLocked(String authority, int userHandle) {
    ProviderInfo pi = null;
    ContentProviderRecord cpr = mProviderMap.getProviderByName(authority, userHandle);
    if (cpr != null) {
        pi = cpr.info;
    } else {
        try {
            pi = AppGlobals.getPackageManager().resolveContentProvider(authority, PackageManager.GET_URI_PERMISSION_PATTERNS, userHandle);
        } catch (RemoteException ex) {
        }
    }
    return pi;
}
#method_after
private ProviderInfo getProviderInfoLocked(String authority, int userHandle, int pmFlags) {
    ProviderInfo pi = null;
    ContentProviderRecord cpr = mProviderMap.getProviderByName(authority, userHandle);
    if (cpr != null) {
        pi = cpr.info;
    } else {
        try {
            pi = AppGlobals.getPackageManager().resolveContentProvider(authority, PackageManager.GET_URI_PERMISSION_PATTERNS | pmFlags, userHandle);
        } catch (RemoteException ex) {
        }
    }
    return pi;
}
#end_block

#method_before
int checkGrantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, final int modeFlags, int lastTargetUid) {
    if (!Intent.isAccessUriMode(modeFlags)) {
        return -1;
    }
    if (targetPkg != null) {
        if (DEBUG_URI_PERMISSION)
            Slog.v(TAG_URI_PERMISSION, "Checking grant " + targetPkg + " permission to " + grantUri);
    }
    final IPackageManager pm = AppGlobals.getPackageManager();
    // If this is not a content: uri, we can't do anything with it.
    if (!ContentResolver.SCHEME_CONTENT.equals(grantUri.uri.getScheme())) {
        if (DEBUG_URI_PERMISSION)
            Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission for non-content URI: " + grantUri);
        return -1;
    }
    final String authority = grantUri.uri.getAuthority();
    final ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId);
    if (pi == null) {
        Slog.w(TAG, "No content provider found for permission check: " + grantUri.uri.toSafeString());
        return -1;
    }
    int targetUid = lastTargetUid;
    if (targetUid < 0 && targetPkg != null) {
        try {
            targetUid = pm.getPackageUid(targetPkg, UserHandle.getUserId(callingUid));
            if (targetUid < 0) {
                if (DEBUG_URI_PERMISSION)
                    Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission no uid for: " + targetPkg);
                return -1;
            }
        } catch (RemoteException ex) {
            return -1;
        }
    }
    if (targetUid >= 0) {
        // First...  does the target actually need this permission?
        if (checkHoldingPermissionsLocked(pm, pi, grantUri, targetUid, modeFlags)) {
            // No need to grant the target this permission.
            if (DEBUG_URI_PERMISSION)
                Slog.v(TAG_URI_PERMISSION, "Target " + targetPkg + " already has full permission to " + grantUri);
            return -1;
        }
    } else {
        // First...  there is no target package, so can anyone access it?
        boolean allowed = pi.exported;
        if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
            if (pi.readPermission != null) {
                allowed = false;
            }
        }
        if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
            if (pi.writePermission != null) {
                allowed = false;
            }
        }
        if (allowed) {
            return -1;
        }
    }
    /* There is a special cross user grant if:
         * - The target is on another user.
         * - Apps on the current user can access the uri without any uid permissions.
         * In this case, we grant a uri permission, even if the ContentProvider does not normally
         * grant uri permissions.
         */
    boolean specialCrossUserGrant = UserHandle.getUserId(targetUid) != grantUri.sourceUserId && checkHoldingPermissionsInternalLocked(pm, pi, grantUri, callingUid, modeFlags, false);
    // Second...  is the provider allowing granting of URI permissions?
    if (!specialCrossUserGrant) {
        if (!pi.grantUriPermissions) {
            throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of Uri permissions (uri " + grantUri + ")");
        }
        if (pi.uriPermissionPatterns != null) {
            final int N = pi.uriPermissionPatterns.length;
            boolean allowed = false;
            for (int i = 0; i < N; i++) {
                if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(grantUri.uri.getPath())) {
                    allowed = true;
                    break;
                }
            }
            if (!allowed) {
                throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of permission to path of Uri " + grantUri);
            }
        }
    }
    // this uri?
    if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {
        if (!checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags)) {
            // Require they hold a strong enough Uri permission
            if (!checkUriPermissionLocked(grantUri, callingUid, modeFlags)) {
                throw new SecurityException("Uid " + callingUid + " does not have permission to uri " + grantUri);
            }
        }
    }
    return targetUid;
}
#method_after
int checkGrantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, final int modeFlags, int lastTargetUid) {
    if (!Intent.isAccessUriMode(modeFlags)) {
        return -1;
    }
    if (targetPkg != null) {
        if (DEBUG_URI_PERMISSION)
            Slog.v(TAG_URI_PERMISSION, "Checking grant " + targetPkg + " permission to " + grantUri);
    }
    final IPackageManager pm = AppGlobals.getPackageManager();
    // If this is not a content: uri, we can't do anything with it.
    if (!ContentResolver.SCHEME_CONTENT.equals(grantUri.uri.getScheme())) {
        if (DEBUG_URI_PERMISSION)
            Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission for non-content URI: " + grantUri);
        return -1;
    }
    final String authority = grantUri.uri.getAuthority();
    final ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId, MATCH_DEBUG_TRIAGED_MISSING);
    if (pi == null) {
        Slog.w(TAG, "No content provider found for permission check: " + grantUri.uri.toSafeString());
        return -1;
    }
    int targetUid = lastTargetUid;
    if (targetUid < 0 && targetPkg != null) {
        try {
            targetUid = pm.getPackageUid(targetPkg, MATCH_DEBUG_TRIAGED_MISSING, UserHandle.getUserId(callingUid));
            if (targetUid < 0) {
                if (DEBUG_URI_PERMISSION)
                    Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission no uid for: " + targetPkg);
                return -1;
            }
        } catch (RemoteException ex) {
            return -1;
        }
    }
    if (targetUid >= 0) {
        // First...  does the target actually need this permission?
        if (checkHoldingPermissionsLocked(pm, pi, grantUri, targetUid, modeFlags)) {
            // No need to grant the target this permission.
            if (DEBUG_URI_PERMISSION)
                Slog.v(TAG_URI_PERMISSION, "Target " + targetPkg + " already has full permission to " + grantUri);
            return -1;
        }
    } else {
        // First...  there is no target package, so can anyone access it?
        boolean allowed = pi.exported;
        if ((modeFlags & Intent.FLAG_GRANT_READ_URI_PERMISSION) != 0) {
            if (pi.readPermission != null) {
                allowed = false;
            }
        }
        if ((modeFlags & Intent.FLAG_GRANT_WRITE_URI_PERMISSION) != 0) {
            if (pi.writePermission != null) {
                allowed = false;
            }
        }
        if (allowed) {
            return -1;
        }
    }
    /* There is a special cross user grant if:
         * - The target is on another user.
         * - Apps on the current user can access the uri without any uid permissions.
         * In this case, we grant a uri permission, even if the ContentProvider does not normally
         * grant uri permissions.
         */
    boolean specialCrossUserGrant = UserHandle.getUserId(targetUid) != grantUri.sourceUserId && checkHoldingPermissionsInternalLocked(pm, pi, grantUri, callingUid, modeFlags, false);
    // Second...  is the provider allowing granting of URI permissions?
    if (!specialCrossUserGrant) {
        if (!pi.grantUriPermissions) {
            throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of Uri permissions (uri " + grantUri + ")");
        }
        if (pi.uriPermissionPatterns != null) {
            final int N = pi.uriPermissionPatterns.length;
            boolean allowed = false;
            for (int i = 0; i < N; i++) {
                if (pi.uriPermissionPatterns[i] != null && pi.uriPermissionPatterns[i].match(grantUri.uri.getPath())) {
                    allowed = true;
                    break;
                }
            }
            if (!allowed) {
                throw new SecurityException("Provider " + pi.packageName + "/" + pi.name + " does not allow granting of permission to path of Uri " + grantUri);
            }
        }
    }
    // this uri?
    if (UserHandle.getAppId(callingUid) != Process.SYSTEM_UID) {
        if (!checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags)) {
            // Require they hold a strong enough Uri permission
            if (!checkUriPermissionLocked(grantUri, callingUid, modeFlags)) {
                throw new SecurityException("Uid " + callingUid + " does not have permission to uri " + grantUri);
            }
        }
    }
    return targetUid;
}
#end_block

#method_before
void grantUriPermissionUncheckedLocked(int targetUid, String targetPkg, GrantUri grantUri, final int modeFlags, UriPermissionOwner owner) {
    if (!Intent.isAccessUriMode(modeFlags)) {
        return;
    }
    if (DEBUG_URI_PERMISSION)
        Slog.v(TAG_URI_PERMISSION, "Granting " + targetPkg + "/" + targetUid + " permission to " + grantUri);
    final String authority = grantUri.uri.getAuthority();
    final ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId);
    if (pi == null) {
        Slog.w(TAG, "No content provider found for grant: " + grantUri.toSafeString());
        return;
    }
    if ((modeFlags & Intent.FLAG_GRANT_PREFIX_URI_PERMISSION) != 0) {
        grantUri.prefix = true;
    }
    final UriPermission perm = findOrCreateUriPermissionLocked(pi.packageName, targetPkg, targetUid, grantUri);
    perm.grantModes(modeFlags, owner);
}
#method_after
void grantUriPermissionUncheckedLocked(int targetUid, String targetPkg, GrantUri grantUri, final int modeFlags, UriPermissionOwner owner) {
    if (!Intent.isAccessUriMode(modeFlags)) {
        return;
    }
    if (DEBUG_URI_PERMISSION)
        Slog.v(TAG_URI_PERMISSION, "Granting " + targetPkg + "/" + targetUid + " permission to " + grantUri);
    final String authority = grantUri.uri.getAuthority();
    final ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId, MATCH_DEBUG_TRIAGED_MISSING);
    if (pi == null) {
        Slog.w(TAG, "No content provider found for grant: " + grantUri.toSafeString());
        return;
    }
    if ((modeFlags & Intent.FLAG_GRANT_PREFIX_URI_PERMISSION) != 0) {
        grantUri.prefix = true;
    }
    final UriPermission perm = findOrCreateUriPermissionLocked(pi.packageName, targetPkg, targetUid, grantUri);
    perm.grantModes(modeFlags, owner);
}
#end_block

#method_before
void grantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, final int modeFlags, UriPermissionOwner owner, int targetUserId) {
    if (targetPkg == null) {
        throw new NullPointerException("targetPkg");
    }
    int targetUid;
    final IPackageManager pm = AppGlobals.getPackageManager();
    try {
        targetUid = pm.getPackageUid(targetPkg, targetUserId);
    } catch (RemoteException ex) {
        return;
    }
    targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, modeFlags, targetUid);
    if (targetUid < 0) {
        return;
    }
    grantUriPermissionUncheckedLocked(targetUid, targetPkg, grantUri, modeFlags, owner);
}
#method_after
void grantUriPermissionLocked(int callingUid, String targetPkg, GrantUri grantUri, final int modeFlags, UriPermissionOwner owner, int targetUserId) {
    if (targetPkg == null) {
        throw new NullPointerException("targetPkg");
    }
    int targetUid;
    final IPackageManager pm = AppGlobals.getPackageManager();
    try {
        targetUid = pm.getPackageUid(targetPkg, MATCH_DEBUG_TRIAGED_MISSING, targetUserId);
    } catch (RemoteException ex) {
        return;
    }
    targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, modeFlags, targetUid);
    if (targetUid < 0) {
        return;
    }
    grantUriPermissionUncheckedLocked(targetUid, targetPkg, grantUri, modeFlags, owner);
}
#end_block

#method_before
NeededUriGrants checkGrantUriPermissionFromIntentLocked(int callingUid, String targetPkg, Intent intent, int mode, NeededUriGrants needed, int targetUserId) {
    if (DEBUG_URI_PERMISSION)
        Slog.v(TAG_URI_PERMISSION, "Checking URI perm to data=" + (intent != null ? intent.getData() : null) + " clip=" + (intent != null ? intent.getClipData() : null) + " from " + intent + "; flags=0x" + Integer.toHexString(intent != null ? intent.getFlags() : 0));
    if (targetPkg == null) {
        throw new NullPointerException("targetPkg");
    }
    if (intent == null) {
        return null;
    }
    Uri data = intent.getData();
    ClipData clip = intent.getClipData();
    if (data == null && clip == null) {
        return null;
    }
    // Default userId for uris in the intent (if they don't specify it themselves)
    int contentUserHint = intent.getContentUserHint();
    if (contentUserHint == UserHandle.USER_CURRENT) {
        contentUserHint = UserHandle.getUserId(callingUid);
    }
    final IPackageManager pm = AppGlobals.getPackageManager();
    int targetUid;
    if (needed != null) {
        targetUid = needed.targetUid;
    } else {
        try {
            targetUid = pm.getPackageUid(targetPkg, targetUserId);
        } catch (RemoteException ex) {
            return null;
        }
        if (targetUid < 0) {
            if (DEBUG_URI_PERMISSION)
                Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission no uid for: " + targetPkg + " on user " + targetUserId);
            return null;
        }
    }
    if (data != null) {
        GrantUri grantUri = GrantUri.resolve(contentUserHint, data);
        targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, mode, targetUid);
        if (targetUid > 0) {
            if (needed == null) {
                needed = new NeededUriGrants(targetPkg, targetUid, mode);
            }
            needed.add(grantUri);
        }
    }
    if (clip != null) {
        for (int i = 0; i < clip.getItemCount(); i++) {
            Uri uri = clip.getItemAt(i).getUri();
            if (uri != null) {
                GrantUri grantUri = GrantUri.resolve(contentUserHint, uri);
                targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, mode, targetUid);
                if (targetUid > 0) {
                    if (needed == null) {
                        needed = new NeededUriGrants(targetPkg, targetUid, mode);
                    }
                    needed.add(grantUri);
                }
            } else {
                Intent clipIntent = clip.getItemAt(i).getIntent();
                if (clipIntent != null) {
                    NeededUriGrants newNeeded = checkGrantUriPermissionFromIntentLocked(callingUid, targetPkg, clipIntent, mode, needed, targetUserId);
                    if (newNeeded != null) {
                        needed = newNeeded;
                    }
                }
            }
        }
    }
    return needed;
}
#method_after
NeededUriGrants checkGrantUriPermissionFromIntentLocked(int callingUid, String targetPkg, Intent intent, int mode, NeededUriGrants needed, int targetUserId) {
    if (DEBUG_URI_PERMISSION)
        Slog.v(TAG_URI_PERMISSION, "Checking URI perm to data=" + (intent != null ? intent.getData() : null) + " clip=" + (intent != null ? intent.getClipData() : null) + " from " + intent + "; flags=0x" + Integer.toHexString(intent != null ? intent.getFlags() : 0));
    if (targetPkg == null) {
        throw new NullPointerException("targetPkg");
    }
    if (intent == null) {
        return null;
    }
    Uri data = intent.getData();
    ClipData clip = intent.getClipData();
    if (data == null && clip == null) {
        return null;
    }
    // Default userId for uris in the intent (if they don't specify it themselves)
    int contentUserHint = intent.getContentUserHint();
    if (contentUserHint == UserHandle.USER_CURRENT) {
        contentUserHint = UserHandle.getUserId(callingUid);
    }
    final IPackageManager pm = AppGlobals.getPackageManager();
    int targetUid;
    if (needed != null) {
        targetUid = needed.targetUid;
    } else {
        try {
            targetUid = pm.getPackageUid(targetPkg, MATCH_DEBUG_TRIAGED_MISSING, targetUserId);
        } catch (RemoteException ex) {
            return null;
        }
        if (targetUid < 0) {
            if (DEBUG_URI_PERMISSION)
                Slog.v(TAG_URI_PERMISSION, "Can't grant URI permission no uid for: " + targetPkg + " on user " + targetUserId);
            return null;
        }
    }
    if (data != null) {
        GrantUri grantUri = GrantUri.resolve(contentUserHint, data);
        targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, mode, targetUid);
        if (targetUid > 0) {
            if (needed == null) {
                needed = new NeededUriGrants(targetPkg, targetUid, mode);
            }
            needed.add(grantUri);
        }
    }
    if (clip != null) {
        for (int i = 0; i < clip.getItemCount(); i++) {
            Uri uri = clip.getItemAt(i).getUri();
            if (uri != null) {
                GrantUri grantUri = GrantUri.resolve(contentUserHint, uri);
                targetUid = checkGrantUriPermissionLocked(callingUid, targetPkg, grantUri, mode, targetUid);
                if (targetUid > 0) {
                    if (needed == null) {
                        needed = new NeededUriGrants(targetPkg, targetUid, mode);
                    }
                    needed.add(grantUri);
                }
            } else {
                Intent clipIntent = clip.getItemAt(i).getIntent();
                if (clipIntent != null) {
                    NeededUriGrants newNeeded = checkGrantUriPermissionFromIntentLocked(callingUid, targetPkg, clipIntent, mode, needed, targetUserId);
                    if (newNeeded != null) {
                        needed = newNeeded;
                    }
                }
            }
        }
    }
    return needed;
}
#end_block

#method_before
private void revokeUriPermissionLocked(int callingUid, GrantUri grantUri, final int modeFlags) {
    if (DEBUG_URI_PERMISSION)
        Slog.v(TAG_URI_PERMISSION, "Revoking all granted permissions to " + grantUri);
    final IPackageManager pm = AppGlobals.getPackageManager();
    final String authority = grantUri.uri.getAuthority();
    final ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId);
    if (pi == null) {
        Slog.w(TAG, "No content provider found for permission revoke: " + grantUri.toSafeString());
        return;
    }
    // Does the caller have this permission on the URI?
    if (!checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags)) {
        // If they don't have direct access to the URI, then revoke any
        // ownerless URI permissions that have been granted to them.
        final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.get(callingUid);
        if (perms != null) {
            boolean persistChanged = false;
            for (Iterator<UriPermission> it = perms.values().iterator(); it.hasNext(); ) {
                final UriPermission perm = it.next();
                if (perm.uri.sourceUserId == grantUri.sourceUserId && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                    if (DEBUG_URI_PERMISSION)
                        Slog.v(TAG_URI_PERMISSION, "Revoking non-owned " + perm.targetUid + " permission to " + perm.uri);
                    persistChanged |= perm.revokeModes(modeFlags | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION, false);
                    if (perm.modeFlags == 0) {
                        it.remove();
                    }
                }
            }
            if (perms.isEmpty()) {
                mGrantedUriPermissions.remove(callingUid);
            }
            if (persistChanged) {
                schedulePersistUriGrants();
            }
        }
        return;
    }
    boolean persistChanged = false;
    // Go through all of the permissions and remove any that match.
    int N = mGrantedUriPermissions.size();
    for (int i = 0; i < N; i++) {
        final int targetUid = mGrantedUriPermissions.keyAt(i);
        final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.valueAt(i);
        for (Iterator<UriPermission> it = perms.values().iterator(); it.hasNext(); ) {
            final UriPermission perm = it.next();
            if (perm.uri.sourceUserId == grantUri.sourceUserId && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                if (DEBUG_URI_PERMISSION)
                    Slog.v(TAG_URI_PERMISSION, "Revoking " + perm.targetUid + " permission to " + perm.uri);
                persistChanged |= perm.revokeModes(modeFlags | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION, true);
                if (perm.modeFlags == 0) {
                    it.remove();
                }
            }
        }
        if (perms.isEmpty()) {
            mGrantedUriPermissions.remove(targetUid);
            N--;
            i--;
        }
    }
    if (persistChanged) {
        schedulePersistUriGrants();
    }
}
#method_after
private void revokeUriPermissionLocked(int callingUid, GrantUri grantUri, final int modeFlags) {
    if (DEBUG_URI_PERMISSION)
        Slog.v(TAG_URI_PERMISSION, "Revoking all granted permissions to " + grantUri);
    final IPackageManager pm = AppGlobals.getPackageManager();
    final String authority = grantUri.uri.getAuthority();
    final ProviderInfo pi = getProviderInfoLocked(authority, grantUri.sourceUserId, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE);
    if (pi == null) {
        Slog.w(TAG, "No content provider found for permission revoke: " + grantUri.toSafeString());
        return;
    }
    // Does the caller have this permission on the URI?
    if (!checkHoldingPermissionsLocked(pm, pi, grantUri, callingUid, modeFlags)) {
        // If they don't have direct access to the URI, then revoke any
        // ownerless URI permissions that have been granted to them.
        final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.get(callingUid);
        if (perms != null) {
            boolean persistChanged = false;
            for (Iterator<UriPermission> it = perms.values().iterator(); it.hasNext(); ) {
                final UriPermission perm = it.next();
                if (perm.uri.sourceUserId == grantUri.sourceUserId && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                    if (DEBUG_URI_PERMISSION)
                        Slog.v(TAG_URI_PERMISSION, "Revoking non-owned " + perm.targetUid + " permission to " + perm.uri);
                    persistChanged |= perm.revokeModes(modeFlags | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION, false);
                    if (perm.modeFlags == 0) {
                        it.remove();
                    }
                }
            }
            if (perms.isEmpty()) {
                mGrantedUriPermissions.remove(callingUid);
            }
            if (persistChanged) {
                schedulePersistUriGrants();
            }
        }
        return;
    }
    boolean persistChanged = false;
    // Go through all of the permissions and remove any that match.
    int N = mGrantedUriPermissions.size();
    for (int i = 0; i < N; i++) {
        final int targetUid = mGrantedUriPermissions.keyAt(i);
        final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.valueAt(i);
        for (Iterator<UriPermission> it = perms.values().iterator(); it.hasNext(); ) {
            final UriPermission perm = it.next();
            if (perm.uri.sourceUserId == grantUri.sourceUserId && perm.uri.uri.isPathPrefixMatch(grantUri.uri)) {
                if (DEBUG_URI_PERMISSION)
                    Slog.v(TAG_URI_PERMISSION, "Revoking " + perm.targetUid + " permission to " + perm.uri);
                persistChanged |= perm.revokeModes(modeFlags | Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION, true);
                if (perm.modeFlags == 0) {
                    it.remove();
                }
            }
        }
        if (perms.isEmpty()) {
            mGrantedUriPermissions.remove(targetUid);
            N--;
            i--;
        }
    }
    if (persistChanged) {
        schedulePersistUriGrants();
    }
}
#end_block

#method_before
@Override
public void revokeUriPermission(IApplicationThread caller, Uri uri, final int modeFlags, int userId) {
    enforceNotIsolatedCaller("revokeUriPermission");
    synchronized (this) {
        final ProcessRecord r = getRecordForAppLocked(caller);
        if (r == null) {
            throw new SecurityException("Unable to find app for caller " + caller + " when revoking permission to uri " + uri);
        }
        if (uri == null) {
            Slog.w(TAG, "revokeUriPermission: null uri");
            return;
        }
        if (!Intent.isAccessUriMode(modeFlags)) {
            return;
        }
        final String authority = uri.getAuthority();
        final ProviderInfo pi = getProviderInfoLocked(authority, userId);
        if (pi == null) {
            Slog.w(TAG, "No content provider found for permission revoke: " + uri.toSafeString());
            return;
        }
        revokeUriPermissionLocked(r.uid, new GrantUri(userId, uri, false), modeFlags);
    }
}
#method_after
@Override
public void revokeUriPermission(IApplicationThread caller, Uri uri, final int modeFlags, int userId) {
    enforceNotIsolatedCaller("revokeUriPermission");
    synchronized (this) {
        final ProcessRecord r = getRecordForAppLocked(caller);
        if (r == null) {
            throw new SecurityException("Unable to find app for caller " + caller + " when revoking permission to uri " + uri);
        }
        if (uri == null) {
            Slog.w(TAG, "revokeUriPermission: null uri");
            return;
        }
        if (!Intent.isAccessUriMode(modeFlags)) {
            return;
        }
        final String authority = uri.getAuthority();
        final ProviderInfo pi = getProviderInfoLocked(authority, userId, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE);
        if (pi == null) {
            Slog.w(TAG, "No content provider found for permission revoke: " + uri.toSafeString());
            return;
        }
        revokeUriPermissionLocked(r.uid, new GrantUri(userId, uri, false), modeFlags);
    }
}
#end_block

#method_before
@Override
public void grantUriPermissionFromOwner(IBinder token, int fromUid, String targetPkg, Uri uri, final int modeFlags, int sourceUserId, int targetUserId) {
    targetUserId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), targetUserId, false, ALLOW_FULL_ONLY, "grantUriPermissionFromOwner", null);
    synchronized (this) {
        UriPermissionOwner owner = UriPermissionOwner.fromExternalToken(token);
        if (owner == null) {
            throw new IllegalArgumentException("Unknown owner: " + token);
        }
        if (fromUid != Binder.getCallingUid()) {
            if (Binder.getCallingUid() != Process.myUid()) {
                // of other users.
                throw new SecurityException("nice try");
            }
        }
        if (targetPkg == null) {
            throw new IllegalArgumentException("null target");
        }
        if (uri == null) {
            throw new IllegalArgumentException("null uri");
        }
        grantUriPermissionLocked(fromUid, targetPkg, new GrantUri(sourceUserId, uri, false), modeFlags, owner, targetUserId);
    }
}
#method_after
@Override
public void grantUriPermissionFromOwner(IBinder token, int fromUid, String targetPkg, Uri uri, final int modeFlags, int sourceUserId, int targetUserId) {
    targetUserId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), targetUserId, false, ALLOW_FULL_ONLY, "grantUriPermissionFromOwner", null);
    synchronized (this) {
        UriPermissionOwner owner = UriPermissionOwner.fromExternalToken(token);
        if (owner == null) {
            throw new IllegalArgumentException("Unknown owner: " + token);
        }
        if (fromUid != Binder.getCallingUid()) {
            if (Binder.getCallingUid() != Process.myUid()) {
                // of other users.
                throw new SecurityException("nice try");
            }
        }
        if (targetPkg == null) {
            throw new IllegalArgumentException("null target");
        }
        if (uri == null) {
            throw new IllegalArgumentException("null uri");
        }
        grantUriPermissionLocked(fromUid, targetPkg, new GrantUri(sourceUserId, uri, false), modeFlags, owner, targetUserId);
    }
}
#end_block

#method_before
private void readGrantedUriPermissionsLocked() {
    if (DEBUG_URI_PERMISSION)
        Slog.v(TAG_URI_PERMISSION, "readGrantedUriPermissions()");
    final long now = System.currentTimeMillis();
    FileInputStream fis = null;
    try {
        fis = mGrantFile.openRead();
        final XmlPullParser in = Xml.newPullParser();
        in.setInput(fis, StandardCharsets.UTF_8.name());
        int type;
        while ((type = in.next()) != END_DOCUMENT) {
            final String tag = in.getName();
            if (type == START_TAG) {
                if (TAG_URI_GRANT.equals(tag)) {
                    final int sourceUserId;
                    final int targetUserId;
                    final int userHandle = readIntAttribute(in, ATTR_USER_HANDLE, UserHandle.USER_NULL);
                    if (userHandle != UserHandle.USER_NULL) {
                        // For backwards compatibility.
                        sourceUserId = userHandle;
                        targetUserId = userHandle;
                    } else {
                        sourceUserId = readIntAttribute(in, ATTR_SOURCE_USER_ID);
                        targetUserId = readIntAttribute(in, ATTR_TARGET_USER_ID);
                    }
                    final String sourcePkg = in.getAttributeValue(null, ATTR_SOURCE_PKG);
                    final String targetPkg = in.getAttributeValue(null, ATTR_TARGET_PKG);
                    final Uri uri = Uri.parse(in.getAttributeValue(null, ATTR_URI));
                    final boolean prefix = readBooleanAttribute(in, ATTR_PREFIX);
                    final int modeFlags = readIntAttribute(in, ATTR_MODE_FLAGS);
                    final long createdTime = readLongAttribute(in, ATTR_CREATED_TIME, now);
                    // Sanity check that provider still belongs to source package
                    final ProviderInfo pi = getProviderInfoLocked(uri.getAuthority(), sourceUserId);
                    if (pi != null && sourcePkg.equals(pi.packageName)) {
                        int targetUid = -1;
                        try {
                            targetUid = AppGlobals.getPackageManager().getPackageUid(targetPkg, targetUserId);
                        } catch (RemoteException e) {
                        }
                        if (targetUid != -1) {
                            final UriPermission perm = findOrCreateUriPermissionLocked(sourcePkg, targetPkg, targetUid, new GrantUri(sourceUserId, uri, prefix));
                            perm.initPersistedModes(modeFlags, createdTime);
                        }
                    } else {
                        Slog.w(TAG, "Persisted grant for " + uri + " had source " + sourcePkg + " but instead found " + pi);
                    }
                }
            }
        }
    } catch (FileNotFoundException e) {
    // Missing grants is okay
    } catch (IOException e) {
        Slog.wtf(TAG, "Failed reading Uri grants", e);
    } catch (XmlPullParserException e) {
        Slog.wtf(TAG, "Failed reading Uri grants", e);
    } finally {
        IoUtils.closeQuietly(fis);
    }
}
#method_after
private void readGrantedUriPermissionsLocked() {
    if (DEBUG_URI_PERMISSION)
        Slog.v(TAG_URI_PERMISSION, "readGrantedUriPermissions()");
    final long now = System.currentTimeMillis();
    FileInputStream fis = null;
    try {
        fis = mGrantFile.openRead();
        final XmlPullParser in = Xml.newPullParser();
        in.setInput(fis, StandardCharsets.UTF_8.name());
        int type;
        while ((type = in.next()) != END_DOCUMENT) {
            final String tag = in.getName();
            if (type == START_TAG) {
                if (TAG_URI_GRANT.equals(tag)) {
                    final int sourceUserId;
                    final int targetUserId;
                    final int userHandle = readIntAttribute(in, ATTR_USER_HANDLE, UserHandle.USER_NULL);
                    if (userHandle != UserHandle.USER_NULL) {
                        // For backwards compatibility.
                        sourceUserId = userHandle;
                        targetUserId = userHandle;
                    } else {
                        sourceUserId = readIntAttribute(in, ATTR_SOURCE_USER_ID);
                        targetUserId = readIntAttribute(in, ATTR_TARGET_USER_ID);
                    }
                    final String sourcePkg = in.getAttributeValue(null, ATTR_SOURCE_PKG);
                    final String targetPkg = in.getAttributeValue(null, ATTR_TARGET_PKG);
                    final Uri uri = Uri.parse(in.getAttributeValue(null, ATTR_URI));
                    final boolean prefix = readBooleanAttribute(in, ATTR_PREFIX);
                    final int modeFlags = readIntAttribute(in, ATTR_MODE_FLAGS);
                    final long createdTime = readLongAttribute(in, ATTR_CREATED_TIME, now);
                    // Sanity check that provider still belongs to source package
                    // Both direct boot aware and unaware packages are fine as we
                    // will do filtering at query time to avoid multiple parsing.
                    final ProviderInfo pi = getProviderInfoLocked(uri.getAuthority(), sourceUserId, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE);
                    if (pi != null && sourcePkg.equals(pi.packageName)) {
                        int targetUid = -1;
                        try {
                            targetUid = AppGlobals.getPackageManager().getPackageUid(targetPkg, MATCH_UNINSTALLED_PACKAGES, targetUserId);
                        } catch (RemoteException e) {
                        }
                        if (targetUid != -1) {
                            final UriPermission perm = findOrCreateUriPermissionLocked(sourcePkg, targetPkg, targetUid, new GrantUri(sourceUserId, uri, prefix));
                            perm.initPersistedModes(modeFlags, createdTime);
                        }
                    } else {
                        Slog.w(TAG, "Persisted grant for " + uri + " had source " + sourcePkg + " but instead found " + pi);
                    }
                }
            }
        }
    } catch (FileNotFoundException e) {
    // Missing grants is okay
    } catch (IOException e) {
        Slog.wtf(TAG, "Failed reading Uri grants", e);
    } catch (XmlPullParserException e) {
        Slog.wtf(TAG, "Failed reading Uri grants", e);
    } finally {
        IoUtils.closeQuietly(fis);
    }
}
#end_block

#method_before
@Override
public ParceledListSlice<android.content.UriPermission> getPersistedUriPermissions(String packageName, boolean incoming) {
    enforceNotIsolatedCaller("getPersistedUriPermissions");
    Preconditions.checkNotNull(packageName, "packageName");
    final int callingUid = Binder.getCallingUid();
    final IPackageManager pm = AppGlobals.getPackageManager();
    try {
        final int packageUid = pm.getPackageUid(packageName, UserHandle.getUserId(callingUid));
        if (packageUid != callingUid) {
            throw new SecurityException("Package " + packageName + " does not belong to calling UID " + callingUid);
        }
    } catch (RemoteException e) {
        throw new SecurityException("Failed to verify package name ownership");
    }
    final ArrayList<android.content.UriPermission> result = Lists.newArrayList();
    synchronized (this) {
        if (incoming) {
            final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.get(callingUid);
            if (perms == null) {
                Slog.w(TAG, "No permission grants found for " + packageName);
            } else {
                for (UriPermission perm : perms.values()) {
                    if (packageName.equals(perm.targetPkg) && perm.persistedModeFlags != 0) {
                        result.add(perm.buildPersistedPublicApiObject());
                    }
                }
            }
        } else {
            final int size = mGrantedUriPermissions.size();
            for (int i = 0; i < size; i++) {
                final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.valueAt(i);
                for (UriPermission perm : perms.values()) {
                    if (packageName.equals(perm.sourcePkg) && perm.persistedModeFlags != 0) {
                        result.add(perm.buildPersistedPublicApiObject());
                    }
                }
            }
        }
    }
    return new ParceledListSlice<android.content.UriPermission>(result);
}
#method_after
@Override
public ParceledListSlice<android.content.UriPermission> getPersistedUriPermissions(String packageName, boolean incoming) {
    enforceNotIsolatedCaller("getPersistedUriPermissions");
    Preconditions.checkNotNull(packageName, "packageName");
    final int callingUid = Binder.getCallingUid();
    final int callingUserId = UserHandle.getUserId(callingUid);
    final IPackageManager pm = AppGlobals.getPackageManager();
    try {
        final int packageUid = pm.getPackageUid(packageName, MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE, callingUserId);
        if (packageUid != callingUid) {
            throw new SecurityException("Package " + packageName + " does not belong to calling UID " + callingUid);
        }
    } catch (RemoteException e) {
        throw new SecurityException("Failed to verify package name ownership");
    }
    final ArrayList<android.content.UriPermission> result = Lists.newArrayList();
    synchronized (this) {
        if (incoming) {
            final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.get(callingUid);
            if (perms == null) {
                Slog.w(TAG, "No permission grants found for " + packageName);
            } else {
                for (UriPermission perm : perms.values()) {
                    if (packageName.equals(perm.targetPkg) && perm.persistedModeFlags != 0) {
                        result.add(perm.buildPersistedPublicApiObject());
                    }
                }
            }
        } else {
            final int size = mGrantedUriPermissions.size();
            for (int i = 0; i < size; i++) {
                final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.valueAt(i);
                for (UriPermission perm : perms.values()) {
                    if (packageName.equals(perm.sourcePkg) && perm.persistedModeFlags != 0) {
                        result.add(perm.buildPersistedPublicApiObject());
                    }
                }
            }
        }
    }
    return new ParceledListSlice<android.content.UriPermission>(result);
}
#end_block

#method_before
@Override
public void showWaitingForDebugger(IApplicationThread who, boolean waiting) {
    synchronized (this) {
        ProcessRecord app = who != null ? getRecordForAppLocked(who) : null;
        if (app == null)
            return;
        Message msg = Message.obtain();
        msg.what = WAIT_FOR_DEBUGGER_MSG;
        msg.obj = app;
        msg.arg1 = waiting ? 1 : 0;
        mUiHandler.sendMessage(msg);
    }
}
#method_after
@Override
public void showWaitingForDebugger(IApplicationThread who, boolean waiting) {
    synchronized (this) {
        ProcessRecord app = who != null ? getRecordForAppLocked(who) : null;
        if (app == null)
            return;
        Message msg = Message.obtain();
        msg.what = WAIT_FOR_DEBUGGER_UI_MSG;
        msg.obj = app;
        msg.arg1 = waiting ? 1 : 0;
        mUiHandler.sendMessage(msg);
    }
}
#end_block

#method_before
private ActivityManager.RecentTaskInfo createRecentTaskInfoFromTaskRecord(TaskRecord tr) {
    // Update the task description to reflect any changes in the task stack
    tr.updateTaskDescription();
    // Compose the recent task info
    ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();
    rti.id = tr.getTopActivity() == null ? INVALID_TASK_ID : tr.taskId;
    rti.persistentId = tr.taskId;
    rti.baseIntent = new Intent(tr.getBaseIntent());
    rti.origActivity = tr.origActivity;
    rti.description = tr.lastDescription;
    rti.stackId = tr.stack != null ? tr.stack.mStackId : -1;
    rti.userId = tr.userId;
    rti.taskDescription = new ActivityManager.TaskDescription(tr.lastTaskDescription);
    rti.firstActiveTime = tr.firstActiveTime;
    rti.lastActiveTime = tr.lastActiveTime;
    rti.affiliatedTaskId = tr.mAffiliatedTaskId;
    rti.affiliatedTaskColor = tr.mAffiliatedTaskColor;
    rti.numActivities = 0;
    ActivityRecord base = null;
    ActivityRecord top = null;
    ActivityRecord tmp;
    for (int i = tr.mActivities.size() - 1; i >= 0; --i) {
        tmp = tr.mActivities.get(i);
        if (tmp.finishing) {
            continue;
        }
        base = tmp;
        if (top == null || (top.state == ActivityState.INITIALIZING)) {
            top = base;
        }
        rti.numActivities++;
    }
    rti.baseActivity = (base != null) ? base.intent.getComponent() : null;
    rti.topActivity = (top != null) ? top.intent.getComponent() : null;
    return rti;
}
#method_after
private ActivityManager.RecentTaskInfo createRecentTaskInfoFromTaskRecord(TaskRecord tr) {
    // Update the task description to reflect any changes in the task stack
    tr.updateTaskDescription();
    // Compose the recent task info
    ActivityManager.RecentTaskInfo rti = new ActivityManager.RecentTaskInfo();
    rti.id = tr.getTopActivity() == null ? INVALID_TASK_ID : tr.taskId;
    rti.persistentId = tr.taskId;
    rti.baseIntent = new Intent(tr.getBaseIntent());
    rti.origActivity = tr.origActivity;
    rti.realActivity = tr.realActivity;
    rti.description = tr.lastDescription;
    rti.stackId = tr.stack != null ? tr.stack.mStackId : -1;
    rti.userId = tr.userId;
    rti.taskDescription = new ActivityManager.TaskDescription(tr.lastTaskDescription);
    rti.firstActiveTime = tr.firstActiveTime;
    rti.lastActiveTime = tr.lastActiveTime;
    rti.affiliatedTaskId = tr.mAffiliatedTaskId;
    rti.affiliatedTaskColor = tr.mAffiliatedTaskColor;
    rti.numActivities = 0;
    if (tr.mBounds != null) {
        rti.bounds = new Rect(tr.mBounds);
    }
    rti.isDockable = tr.canGoInDockedStack();
    rti.resizeMode = tr.mResizeMode;
    ActivityRecord base = null;
    ActivityRecord top = null;
    ActivityRecord tmp;
    for (int i = tr.mActivities.size() - 1; i >= 0; --i) {
        tmp = tr.mActivities.get(i);
        if (tmp.finishing) {
            continue;
        }
        base = tmp;
        if (top == null || (top.state == ActivityState.INITIALIZING)) {
            top = base;
        }
        rti.numActivities++;
    }
    rti.baseActivity = (base != null) ? base.intent.getComponent() : null;
    rti.topActivity = (top != null) ? top.intent.getComponent() : null;
    return rti;
}
#end_block

#method_before
@Override
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags, int userId) {
    final int callingUid = Binder.getCallingUid();
    userId = handleIncomingUser(Binder.getCallingPid(), callingUid, userId, false, ALLOW_FULL_ONLY, "getRecentTasks", null);
    final boolean includeProfiles = (flags & ActivityManager.RECENT_INCLUDE_PROFILES) != 0;
    final boolean withExcluded = (flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0;
    synchronized (this) {
        final boolean allowed = isGetTasksAllowed("getRecentTasks", Binder.getCallingPid(), callingUid);
        final boolean detailed = checkCallingPermission(android.Manifest.permission.GET_DETAILED_TASKS) == PackageManager.PERMISSION_GRANTED;
        final int recentsCount = mRecentTasks.size();
        ArrayList<ActivityManager.RecentTaskInfo> res = new ArrayList<>(maxNum < recentsCount ? maxNum : recentsCount);
        final Set<Integer> includedUsers;
        if (includeProfiles) {
            includedUsers = getProfileIdsLocked(userId);
        } else {
            includedUsers = new HashSet<>();
        }
        includedUsers.add(Integer.valueOf(userId));
        for (int i = 0; i < recentsCount && maxNum > 0; i++) {
            TaskRecord tr = mRecentTasks.get(i);
            // Only add calling user or related users recent tasks
            if (!includedUsers.contains(Integer.valueOf(tr.userId))) {
                if (DEBUG_RECENTS)
                    Slog.d(TAG_RECENTS, "Skipping, not user: " + tr);
                continue;
            }
            if (i == 0 || withExcluded || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
                if (!allowed) {
                    // allow them to see a small subset of tasks -- their own and home.
                    if (!tr.isHomeTask() && tr.effectiveUid != callingUid) {
                        if (DEBUG_RECENTS)
                            Slog.d(TAG_RECENTS, "Skipping, not allowed: " + tr);
                        continue;
                    }
                }
                if ((flags & ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS) != 0) {
                    if (tr.stack != null && tr.stack.isHomeStack()) {
                        if (DEBUG_RECENTS)
                            Slog.d(TAG_RECENTS, "Skipping, home stack task: " + tr);
                        continue;
                    }
                }
                if (tr.autoRemoveRecents && tr.getTopActivity() == null) {
                    // Don't include auto remove tasks that are finished or finishing.
                    if (DEBUG_RECENTS)
                        Slog.d(TAG_RECENTS, "Skipping, auto-remove without activity: " + tr);
                    continue;
                }
                if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0 && !tr.isAvailable) {
                    if (DEBUG_RECENTS)
                        Slog.d(TAG_RECENTS, "Skipping, unavail real act: " + tr);
                    continue;
                }
                ActivityManager.RecentTaskInfo rti = createRecentTaskInfoFromTaskRecord(tr);
                if (!detailed) {
                    rti.baseIntent.replaceExtras((Bundle) null);
                }
                res.add(rti);
                maxNum--;
            }
        }
        return res;
    }
}
#method_after
@Override
public List<ActivityManager.RecentTaskInfo> getRecentTasks(int maxNum, int flags, int userId) {
    final int callingUid = Binder.getCallingUid();
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), callingUid, userId, false, ALLOW_FULL_ONLY, "getRecentTasks", null);
    final boolean includeProfiles = (flags & ActivityManager.RECENT_INCLUDE_PROFILES) != 0;
    final boolean withExcluded = (flags & ActivityManager.RECENT_WITH_EXCLUDED) != 0;
    synchronized (this) {
        final boolean allowed = isGetTasksAllowed("getRecentTasks", Binder.getCallingPid(), callingUid);
        final boolean detailed = checkCallingPermission(android.Manifest.permission.GET_DETAILED_TASKS) == PackageManager.PERMISSION_GRANTED;
        if (!isUserRunning(userId, ActivityManager.FLAG_AND_UNLOCKED)) {
            Slog.i(TAG, "user " + userId + " is still locked. Cannot load recents");
            return Collections.emptyList();
        }
        mRecentTasks.loadUserRecentsLocked(userId);
        final int recentsCount = mRecentTasks.size();
        ArrayList<ActivityManager.RecentTaskInfo> res = new ArrayList<>(maxNum < recentsCount ? maxNum : recentsCount);
        final Set<Integer> includedUsers;
        if (includeProfiles) {
            includedUsers = mUserController.getProfileIds(userId);
        } else {
            includedUsers = new HashSet<>();
        }
        includedUsers.add(Integer.valueOf(userId));
        for (int i = 0; i < recentsCount && maxNum > 0; i++) {
            TaskRecord tr = mRecentTasks.get(i);
            // Only add calling user or related users recent tasks
            if (!includedUsers.contains(Integer.valueOf(tr.userId))) {
                if (DEBUG_RECENTS)
                    Slog.d(TAG_RECENTS, "Skipping, not user: " + tr);
                continue;
            }
            if (tr.realActivitySuspended) {
                if (DEBUG_RECENTS)
                    Slog.d(TAG_RECENTS, "Skipping, activity suspended: " + tr);
                continue;
            }
            if (i == 0 || withExcluded || (tr.intent == null) || ((tr.intent.getFlags() & Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS) == 0)) {
                if (!allowed) {
                    // allow them to see a small subset of tasks -- their own and home.
                    if (!tr.isHomeTask() && tr.effectiveUid != callingUid) {
                        if (DEBUG_RECENTS)
                            Slog.d(TAG_RECENTS, "Skipping, not allowed: " + tr);
                        continue;
                    }
                }
                if ((flags & ActivityManager.RECENT_IGNORE_HOME_STACK_TASKS) != 0) {
                    if (tr.stack != null && tr.stack.isHomeStack()) {
                        if (DEBUG_RECENTS)
                            Slog.d(TAG_RECENTS, "Skipping, home stack task: " + tr);
                        continue;
                    }
                }
                if ((flags & ActivityManager.RECENT_INGORE_DOCKED_STACK_TOP_TASK) != 0) {
                    final ActivityStack stack = tr.stack;
                    if (stack != null && stack.isDockedStack() && stack.topTask() == tr) {
                        if (DEBUG_RECENTS)
                            Slog.d(TAG_RECENTS, "Skipping, top task in docked stack: " + tr);
                        continue;
                    }
                }
                if ((flags & ActivityManager.RECENT_INGORE_PINNED_STACK_TASKS) != 0) {
                    if (tr.stack != null && tr.stack.isPinnedStack()) {
                        if (DEBUG_RECENTS)
                            Slog.d(TAG_RECENTS, "Skipping, pinned stack task: " + tr);
                        continue;
                    }
                }
                if (tr.autoRemoveRecents && tr.getTopActivity() == null) {
                    // Don't include auto remove tasks that are finished or finishing.
                    if (DEBUG_RECENTS)
                        Slog.d(TAG_RECENTS, "Skipping, auto-remove without activity: " + tr);
                    continue;
                }
                if ((flags & ActivityManager.RECENT_IGNORE_UNAVAILABLE) != 0 && !tr.isAvailable) {
                    if (DEBUG_RECENTS)
                        Slog.d(TAG_RECENTS, "Skipping, unavail real act: " + tr);
                    continue;
                }
                if (!tr.mUserSetupComplete) {
                    // Don't include task launched while user is not done setting-up.
                    if (DEBUG_RECENTS)
                        Slog.d(TAG_RECENTS, "Skipping, user setup not complete: " + tr);
                    continue;
                }
                ActivityManager.RecentTaskInfo rti = createRecentTaskInfoFromTaskRecord(tr);
                if (!detailed) {
                    rti.baseIntent.replaceExtras((Bundle) null);
                }
                res.add(rti);
                maxNum--;
            }
        }
        return res;
    }
}
#end_block

#method_before
@Override
public ActivityManager.TaskThumbnail getTaskThumbnail(int id) {
    synchronized (this) {
        enforceCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER, "getTaskThumbnail()");
        TaskRecord tr = mStackSupervisor.anyTaskForIdLocked(id, false);
        if (tr != null) {
            return tr.getTaskThumbnailLocked();
        }
    }
    return null;
}
#method_after
@Override
public ActivityManager.TaskThumbnail getTaskThumbnail(int id) {
    synchronized (this) {
        enforceCallingPermission(android.Manifest.permission.READ_FRAME_BUFFER, "getTaskThumbnail()");
        final TaskRecord tr = mStackSupervisor.anyTaskForIdLocked(id, !RESTORE_FROM_RECENTS, INVALID_STACK_ID);
        if (tr != null) {
            return tr.getTaskThumbnailLocked();
        }
    }
    return null;
}
#end_block

#method_before
@Override
public int addAppTask(IBinder activityToken, Intent intent, ActivityManager.TaskDescription description, Bitmap thumbnail) throws RemoteException {
    final int callingUid = Binder.getCallingUid();
    final long callingIdent = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);
            if (r == null) {
                throw new IllegalArgumentException("Activity does not exist; token=" + activityToken);
            }
            ComponentName comp = intent.getComponent();
            if (comp == null) {
                throw new IllegalArgumentException("Intent " + intent + " must specify explicit component");
            }
            if (thumbnail.getWidth() != mThumbnailWidth || thumbnail.getHeight() != mThumbnailHeight) {
                throw new IllegalArgumentException("Bad thumbnail size: got " + thumbnail.getWidth() + "x" + thumbnail.getHeight() + ", require " + mThumbnailWidth + "x" + mThumbnailHeight);
            }
            if (intent.getSelector() != null) {
                intent.setSelector(null);
            }
            if (intent.getSourceBounds() != null) {
                intent.setSourceBounds(null);
            }
            if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0) {
                if ((intent.getFlags() & Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS) == 0) {
                    // The caller has added this as an auto-remove task...  that makes no
                    // sense, so turn off auto-remove.
                    intent.addFlags(Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS);
                }
            } else if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
                // Must be a new task.
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            }
            if (!comp.equals(mLastAddedTaskComponent) || callingUid != mLastAddedTaskUid) {
                mLastAddedTaskActivity = null;
            }
            ActivityInfo ainfo = mLastAddedTaskActivity;
            if (ainfo == null) {
                ainfo = mLastAddedTaskActivity = AppGlobals.getPackageManager().getActivityInfo(comp, 0, UserHandle.getUserId(callingUid));
                if (ainfo.applicationInfo.uid != callingUid) {
                    throw new SecurityException("Can't add task for another application: target uid=" + ainfo.applicationInfo.uid + ", calling uid=" + callingUid);
                }
            }
            TaskRecord task = new TaskRecord(this, mStackSupervisor.getNextTaskId(), ainfo, intent, description);
            int trimIdx = mRecentTasks.trimForTaskLocked(task, false);
            if (trimIdx >= 0) {
                // means it would be added at the end of the list but then just removed.
                return INVALID_TASK_ID;
            }
            final int N = mRecentTasks.size();
            if (N >= (ActivityManager.getMaxRecentTasksStatic() - 1)) {
                final TaskRecord tr = mRecentTasks.remove(N - 1);
                tr.removedFromRecents();
            }
            task.inRecents = true;
            mRecentTasks.add(task);
            r.task.stack.addTask(task, false, false);
            task.setLastThumbnail(thumbnail);
            task.freeLastThumbnail();
            return task.taskId;
        }
    } finally {
        Binder.restoreCallingIdentity(callingIdent);
    }
}
#method_after
@Override
public int addAppTask(IBinder activityToken, Intent intent, ActivityManager.TaskDescription description, Bitmap thumbnail) throws RemoteException {
    final int callingUid = Binder.getCallingUid();
    final long callingIdent = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            ActivityRecord r = ActivityRecord.isInStackLocked(activityToken);
            if (r == null) {
                throw new IllegalArgumentException("Activity does not exist; token=" + activityToken);
            }
            ComponentName comp = intent.getComponent();
            if (comp == null) {
                throw new IllegalArgumentException("Intent " + intent + " must specify explicit component");
            }
            if (thumbnail.getWidth() != mThumbnailWidth || thumbnail.getHeight() != mThumbnailHeight) {
                throw new IllegalArgumentException("Bad thumbnail size: got " + thumbnail.getWidth() + "x" + thumbnail.getHeight() + ", require " + mThumbnailWidth + "x" + mThumbnailHeight);
            }
            if (intent.getSelector() != null) {
                intent.setSelector(null);
            }
            if (intent.getSourceBounds() != null) {
                intent.setSourceBounds(null);
            }
            if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0) {
                if ((intent.getFlags() & Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS) == 0) {
                    // The caller has added this as an auto-remove task...  that makes no
                    // sense, so turn off auto-remove.
                    intent.addFlags(Intent.FLAG_ACTIVITY_RETAIN_IN_RECENTS);
                }
            } else if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) != 0) {
                // Must be a new task.
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            }
            if (!comp.equals(mLastAddedTaskComponent) || callingUid != mLastAddedTaskUid) {
                mLastAddedTaskActivity = null;
            }
            ActivityInfo ainfo = mLastAddedTaskActivity;
            if (ainfo == null) {
                ainfo = mLastAddedTaskActivity = AppGlobals.getPackageManager().getActivityInfo(comp, 0, UserHandle.getUserId(callingUid));
                if (ainfo.applicationInfo.uid != callingUid) {
                    throw new SecurityException("Can't add task for another application: target uid=" + ainfo.applicationInfo.uid + ", calling uid=" + callingUid);
                }
            }
            // Use the full screen as the context for the task thumbnail
            final Point displaySize = new Point();
            final TaskThumbnailInfo thumbnailInfo = new TaskThumbnailInfo();
            r.task.stack.getDisplaySize(displaySize);
            thumbnailInfo.taskWidth = displaySize.x;
            thumbnailInfo.taskHeight = displaySize.y;
            thumbnailInfo.screenOrientation = mConfiguration.orientation;
            TaskRecord task = new TaskRecord(this, mStackSupervisor.getNextTaskIdForUserLocked(r.userId), ainfo, intent, description, thumbnailInfo);
            int trimIdx = mRecentTasks.trimForTaskLocked(task, false);
            if (trimIdx >= 0) {
                // means it would be added at the end of the list but then just removed.
                return INVALID_TASK_ID;
            }
            final int N = mRecentTasks.size();
            if (N >= (ActivityManager.getMaxRecentTasksStatic() - 1)) {
                final TaskRecord tr = mRecentTasks.remove(N - 1);
                tr.removedFromRecents();
            }
            task.inRecents = true;
            mRecentTasks.add(task);
            r.task.stack.addTask(task, false, "addAppTask");
            task.setLastThumbnailLocked(thumbnail);
            task.freeLastThumbnail();
            return task.taskId;
        }
    } finally {
        Binder.restoreCallingIdentity(callingIdent);
    }
}
#end_block

#method_before
@Override
public void setTaskResizeable(int taskId, boolean resizeable) {
    synchronized (this) {
        TaskRecord task = mStackSupervisor.anyTaskForIdLocked(taskId, false);
        if (task == null) {
            Slog.w(TAG, "setTaskResizeable: taskId=" + taskId + " not found");
            return;
        }
        if (task.mResizeable != resizeable) {
            task.mResizeable = resizeable;
            mStackSupervisor.ensureActivitiesVisibleLocked(null, 0);
            mStackSupervisor.resumeTopActivitiesLocked();
        }
    }
}
#method_after
@Override
public void setTaskResizeable(int taskId, int resizeableMode) {
    synchronized (this) {
        final TaskRecord task = mStackSupervisor.anyTaskForIdLocked(taskId, !RESTORE_FROM_RECENTS, INVALID_STACK_ID);
        if (task == null) {
            Slog.w(TAG, "setTaskResizeable: taskId=" + taskId + " not found");
            return;
        }
        if (task.mResizeMode != resizeableMode) {
            task.mResizeMode = resizeableMode;
            mWindowManager.setTaskResizeable(taskId, resizeableMode);
            mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
            mStackSupervisor.resumeFocusedStackTopActivityLocked();
        }
    }
}
#end_block

#method_before
@Override
public void resizeTask(int taskId, Rect bounds) {
    enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, "resizeTask()");
    long ident = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            TaskRecord task = mStackSupervisor.anyTaskForIdLocked(taskId);
            if (task == null) {
                Slog.w(TAG, "resizeTask: taskId=" + taskId + " not found");
                return;
            }
            mStackSupervisor.resizeTaskLocked(task, bounds);
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
@Override
public void resizeTask(int taskId, Rect bounds, int resizeMode) {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "resizeTask()");
    long ident = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            TaskRecord task = mStackSupervisor.anyTaskForIdLocked(taskId);
            if (task == null) {
                Slog.w(TAG, "resizeTask: taskId=" + taskId + " not found");
                return;
            }
            int stackId = task.stack.mStackId;
            // changing size. No need to update configuration.
            if (bounds != null && task.inCropWindowsResizeMode() && mStackSupervisor.isStackDockedInEffect(stackId)) {
                mWindowManager.scrollTask(task.taskId, bounds);
                return;
            }
            // - otherwise the task is not moved
            if (!StackId.isTaskResizeAllowed(stackId)) {
                throw new IllegalArgumentException("resizeTask not allowed on task=" + task);
            }
            if (bounds == null && stackId == FREEFORM_WORKSPACE_STACK_ID) {
                stackId = FULLSCREEN_WORKSPACE_STACK_ID;
            } else if (bounds != null && stackId != FREEFORM_WORKSPACE_STACK_ID) {
                stackId = FREEFORM_WORKSPACE_STACK_ID;
            }
            boolean preserveWindow = (resizeMode & RESIZE_MODE_PRESERVE_WINDOW) != 0;
            if (stackId != task.stack.mStackId) {
                mStackSupervisor.moveTaskToStackUncheckedLocked(task, stackId, ON_TOP, !FORCE_FOCUS, "resizeTask");
                preserveWindow = false;
            }
            mStackSupervisor.resizeTaskLocked(task, bounds, resizeMode, preserveWindow, false);
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Override
public Bitmap getTaskDescriptionIcon(String filename) {
    if (!FileUtils.isValidExtFilename(filename) || !filename.contains(ActivityRecord.ACTIVITY_ICON_SUFFIX)) {
        throw new IllegalArgumentException("Bad filename: " + filename);
    }
    return mTaskPersister.getTaskDescriptionIcon(filename);
}
#method_after
@Override
public Bitmap getTaskDescriptionIcon(String filePath, int userId) {
    if (userId != UserHandle.getCallingUserId()) {
        enforceCallingPermission(android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, "getTaskDescriptionIcon");
    }
    final File passedIconFile = new File(filePath);
    final File legitIconFile = new File(TaskPersister.getUserImagesDir(userId), passedIconFile.getName());
    if (!legitIconFile.getPath().equals(filePath) || !filePath.contains(ActivityRecord.ACTIVITY_ICON_SUFFIX)) {
        throw new IllegalArgumentException("Bad file path: " + filePath + " passed for userId " + userId);
    }
    return mRecentTasks.getTaskDescriptionIcon(filePath);
}
#end_block

#method_before
@Override
public void startInPlaceAnimationOnFrontMostApplication(ActivityOptions opts) throws RemoteException {
    if (opts.getAnimationType() != ActivityOptions.ANIM_CUSTOM_IN_PLACE || opts.getCustomInPlaceResId() == 0) {
        throw new IllegalArgumentException("Expected in-place ActivityOption " + "with valid animation");
    }
    mWindowManager.prepareAppTransition(AppTransition.TRANSIT_TASK_IN_PLACE, false);
    mWindowManager.overridePendingAppTransitionInPlace(opts.getPackageName(), opts.getCustomInPlaceResId());
    mWindowManager.executeAppTransition();
}
#method_after
@Override
public void startInPlaceAnimationOnFrontMostApplication(ActivityOptions opts) throws RemoteException {
    if (opts.getAnimationType() != ActivityOptions.ANIM_CUSTOM_IN_PLACE || opts.getCustomInPlaceResId() == 0) {
        throw new IllegalArgumentException("Expected in-place ActivityOption " + "with valid animation");
    }
    mWindowManager.prepareAppTransition(TRANSIT_TASK_IN_PLACE, false);
    mWindowManager.overridePendingAppTransitionInPlace(opts.getPackageName(), opts.getCustomInPlaceResId());
    mWindowManager.executeAppTransition();
}
#end_block

#method_before
private void cleanUpRemovedTaskLocked(TaskRecord tr, boolean killProcess) {
    mRecentTasks.remove(tr);
    tr.removedFromRecents();
    ComponentName component = tr.getBaseIntent().getComponent();
    if (component == null) {
        Slog.w(TAG, "No component for base intent of task: " + tr);
        return;
    }
    // Find any running services associated with this app and stop if needed.
    mServices.cleanUpRemovedTaskLocked(tr, component, new Intent(tr.getBaseIntent()));
    if (!killProcess) {
        return;
    }
    // Determine if the process(es) for this task should be killed.
    final String pkg = component.getPackageName();
    ArrayList<ProcessRecord> procsToKill = new ArrayList<>();
    ArrayMap<String, SparseArray<ProcessRecord>> pmap = mProcessNames.getMap();
    for (int i = 0; i < pmap.size(); i++) {
        SparseArray<ProcessRecord> uids = pmap.valueAt(i);
        for (int j = 0; j < uids.size(); j++) {
            ProcessRecord proc = uids.valueAt(j);
            if (proc.userId != tr.userId) {
                // Don't kill process for a different user.
                continue;
            }
            if (proc == mHomeProcess) {
                // Don't kill the home process along with tasks from the same package.
                continue;
            }
            if (!proc.pkgList.containsKey(pkg)) {
                // Don't kill process that is not associated with this task.
                continue;
            }
            for (int k = 0; k < proc.activities.size(); k++) {
                TaskRecord otherTask = proc.activities.get(k).task;
                if (tr.taskId != otherTask.taskId && otherTask.inRecents) {
                    // also in recents.
                    return;
                }
            }
            if (proc.foregroundServices) {
                // Don't kill process(es) with foreground service.
                return;
            }
            // Add process to kill list.
            procsToKill.add(proc);
        }
    }
    // Kill the running processes.
    for (int i = 0; i < procsToKill.size(); i++) {
        ProcessRecord pr = procsToKill.get(i);
        if (pr.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE && pr.curReceiver == null) {
            pr.kill("remove task", true);
        } else {
            // We delay killing processes that are not in the background or running a receiver.
            pr.waitingToKill = "remove task";
        }
    }
}
#method_after
private void cleanUpRemovedTaskLocked(TaskRecord tr, boolean killProcess, boolean removeFromRecents) {
    if (removeFromRecents) {
        mRecentTasks.remove(tr);
        tr.removedFromRecents();
    }
    ComponentName component = tr.getBaseIntent().getComponent();
    if (component == null) {
        Slog.w(TAG, "No component for base intent of task: " + tr);
        return;
    }
    // Find any running services associated with this app and stop if needed.
    mServices.cleanUpRemovedTaskLocked(tr, component, new Intent(tr.getBaseIntent()));
    if (!killProcess) {
        return;
    }
    // Determine if the process(es) for this task should be killed.
    final String pkg = component.getPackageName();
    ArrayList<ProcessRecord> procsToKill = new ArrayList<>();
    ArrayMap<String, SparseArray<ProcessRecord>> pmap = mProcessNames.getMap();
    for (int i = 0; i < pmap.size(); i++) {
        SparseArray<ProcessRecord> uids = pmap.valueAt(i);
        for (int j = 0; j < uids.size(); j++) {
            ProcessRecord proc = uids.valueAt(j);
            if (proc.userId != tr.userId) {
                // Don't kill process for a different user.
                continue;
            }
            if (proc == mHomeProcess) {
                // Don't kill the home process along with tasks from the same package.
                continue;
            }
            if (!proc.pkgList.containsKey(pkg)) {
                // Don't kill process that is not associated with this task.
                continue;
            }
            for (int k = 0; k < proc.activities.size(); k++) {
                TaskRecord otherTask = proc.activities.get(k).task;
                if (tr.taskId != otherTask.taskId && otherTask.inRecents) {
                    // also in recents.
                    return;
                }
            }
            if (proc.foregroundServices) {
                // Don't kill process(es) with foreground service.
                return;
            }
            // Add process to kill list.
            procsToKill.add(proc);
        }
    }
    // Kill the running processes.
    for (int i = 0; i < procsToKill.size(); i++) {
        ProcessRecord pr = procsToKill.get(i);
        if (pr.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND && pr.curReceivers.isEmpty()) {
            pr.kill("remove task", true);
        } else {
            // We delay killing processes that are not in the background or running a receiver.
            pr.waitingToKill = "remove task";
        }
    }
}
#end_block

#method_before
private void removeTasksByPackageNameLocked(String packageName, int userId) {
    // Remove all tasks with activities in the specified package from the list of recent tasks
    for (int i = mRecentTasks.size() - 1; i >= 0; i--) {
        TaskRecord tr = mRecentTasks.get(i);
        if (tr.userId != userId)
            continue;
        ComponentName cn = tr.intent.getComponent();
        if (cn != null && cn.getPackageName().equals(packageName)) {
            // If the package name matches, remove the task.
            removeTaskByIdLocked(tr.taskId, true);
        }
    }
}
#method_after
private void removeTasksByPackageNameLocked(String packageName, int userId) {
    // Remove all tasks with activities in the specified package from the list of recent tasks
    for (int i = mRecentTasks.size() - 1; i >= 0; i--) {
        TaskRecord tr = mRecentTasks.get(i);
        if (tr.userId != userId)
            continue;
        ComponentName cn = tr.intent.getComponent();
        if (cn != null && cn.getPackageName().equals(packageName)) {
            // If the package name matches, remove the task.
            removeTaskByIdLocked(tr.taskId, true, REMOVE_FROM_RECENTS);
        }
    }
}
#end_block

#method_before
private void cleanupDisabledPackageTasksLocked(String packageName, Set<String> filterByClasses, int userId) {
    for (int i = mRecentTasks.size() - 1; i >= 0; i--) {
        TaskRecord tr = mRecentTasks.get(i);
        if (userId != UserHandle.USER_ALL && tr.userId != userId) {
            continue;
        }
        ComponentName cn = tr.intent.getComponent();
        final boolean sameComponent = cn != null && cn.getPackageName().equals(packageName) && (filterByClasses == null || filterByClasses.contains(cn.getClassName()));
        if (sameComponent) {
            removeTaskByIdLocked(tr.taskId, false);
        }
    }
}
#method_after
private void cleanupDisabledPackageTasksLocked(String packageName, Set<String> filterByClasses, int userId) {
    for (int i = mRecentTasks.size() - 1; i >= 0; i--) {
        TaskRecord tr = mRecentTasks.get(i);
        if (userId != UserHandle.USER_ALL && tr.userId != userId) {
            continue;
        }
        ComponentName cn = tr.intent.getComponent();
        final boolean sameComponent = cn != null && cn.getPackageName().equals(packageName) && (filterByClasses == null || filterByClasses.contains(cn.getClassName()));
        if (sameComponent) {
            removeTaskByIdLocked(tr.taskId, false, REMOVE_FROM_RECENTS);
        }
    }
}
#end_block

#method_before
private boolean removeTaskByIdLocked(int taskId, boolean killProcess) {
    TaskRecord tr = mStackSupervisor.anyTaskForIdLocked(taskId, false);
    if (tr != null) {
        tr.removeTaskActivitiesLocked();
        cleanUpRemovedTaskLocked(tr, killProcess);
        if (tr.isPersistable) {
            notifyTaskPersisterLocked(null, true);
        }
        return true;
    }
    Slog.w(TAG, "Request to remove task ignored for non-existent task " + taskId);
    return false;
}
#method_after
private boolean removeTaskByIdLocked(int taskId, boolean killProcess, boolean removeFromRecents) {
    final TaskRecord tr = mStackSupervisor.anyTaskForIdLocked(taskId, !RESTORE_FROM_RECENTS, INVALID_STACK_ID);
    if (tr != null) {
        tr.removeTaskActivitiesLocked();
        cleanUpRemovedTaskLocked(tr, killProcess, removeFromRecents);
        if (tr.isPersistable) {
            notifyTaskPersisterLocked(null, true);
        }
        return true;
    }
    Slog.w(TAG, "Request to remove task ignored for non-existent task " + taskId);
    return false;
}
#end_block

#method_before
@Override
public boolean removeTask(int taskId) {
    synchronized (this) {
        enforceCallingPermission(android.Manifest.permission.REMOVE_TASKS, "removeTask()");
        long ident = Binder.clearCallingIdentity();
        try {
            return removeTaskByIdLocked(taskId, true);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#method_after
@Override
public boolean removeTask(int taskId) {
    enforceCallingPermission(android.Manifest.permission.REMOVE_TASKS, "removeTask()");
    synchronized (this) {
        final long ident = Binder.clearCallingIdentity();
        try {
            return removeTaskByIdLocked(taskId, true, REMOVE_FROM_RECENTS);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#end_block

#method_before
@Override
public void moveTaskToFront(int taskId, int flags, Bundle options) {
    enforceCallingPermission(android.Manifest.permission.REORDER_TASKS, "moveTaskToFront()");
    if (DEBUG_STACK)
        Slog.d(TAG_STACK, "moveTaskToFront: moving taskId=" + taskId);
    synchronized (this) {
        moveTaskToFrontLocked(taskId, flags, options);
    }
}
#method_after
@Override
public void moveTaskToFront(int taskId, int flags, Bundle bOptions) {
    enforceCallingPermission(android.Manifest.permission.REORDER_TASKS, "moveTaskToFront()");
    if (DEBUG_STACK)
        Slog.d(TAG_STACK, "moveTaskToFront: moving taskId=" + taskId);
    synchronized (this) {
        moveTaskToFrontLocked(taskId, flags, bOptions);
    }
}
#end_block

#method_before
void moveTaskToFrontLocked(int taskId, int flags, Bundle options) {
    if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(), Binder.getCallingUid(), -1, -1, "Task to front")) {
        ActivityOptions.abort(options);
        return;
    }
    final long origId = Binder.clearCallingIdentity();
    try {
        final TaskRecord task = mStackSupervisor.anyTaskForIdLocked(taskId);
        if (task == null) {
            Slog.d(TAG, "Could not find task for id: " + taskId);
            return;
        }
        if (mStackSupervisor.isLockTaskModeViolation(task)) {
            mStackSupervisor.showLockTaskToast();
            Slog.e(TAG, "moveTaskToFront: Attempt to violate Lock Task Mode");
            return;
        }
        final ActivityRecord prev = mStackSupervisor.topRunningActivityLocked();
        if (prev != null && prev.isRecentsActivity()) {
            task.setTaskToReturnTo(ActivityRecord.RECENTS_ACTIVITY_TYPE);
        }
        mStackSupervisor.findTaskToMoveToFrontLocked(task, flags, options, "moveTaskToFront");
    } finally {
        Binder.restoreCallingIdentity(origId);
    }
    ActivityOptions.abort(options);
}
#method_after
void moveTaskToFrontLocked(int taskId, int flags, Bundle bOptions) {
    ActivityOptions options = ActivityOptions.fromBundle(bOptions);
    if (!checkAppSwitchAllowedLocked(Binder.getCallingPid(), Binder.getCallingUid(), -1, -1, "Task to front")) {
        ActivityOptions.abort(options);
        return;
    }
    final long origId = Binder.clearCallingIdentity();
    try {
        final TaskRecord task = mStackSupervisor.anyTaskForIdLocked(taskId);
        if (task == null) {
            Slog.d(TAG, "Could not find task for id: " + taskId);
            return;
        }
        if (mStackSupervisor.isLockTaskModeViolation(task)) {
            mStackSupervisor.showLockTaskToast();
            Slog.e(TAG, "moveTaskToFront: Attempt to violate Lock Task Mode");
            return;
        }
        final ActivityRecord prev = mStackSupervisor.topRunningActivityLocked();
        if (prev != null && prev.isRecentsActivity()) {
            task.setTaskToReturnTo(ActivityRecord.RECENTS_ACTIVITY_TYPE);
        }
        mStackSupervisor.findTaskToMoveToFrontLocked(task, flags, options, "moveTaskToFront", false);
    } finally {
        Binder.restoreCallingIdentity(origId);
    }
    ActivityOptions.abort(options);
}
#end_block

#method_before
@Override
public IActivityContainer createVirtualActivityContainer(IBinder parentActivityToken, IActivityContainerCallback callback) throws RemoteException {
    enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, "createActivityContainer()");
    synchronized (this) {
        if (parentActivityToken == null) {
            throw new IllegalArgumentException("parent token must not be null");
        }
        ActivityRecord r = ActivityRecord.forTokenLocked(parentActivityToken);
        if (r == null) {
            return null;
        }
        if (callback == null) {
            throw new IllegalArgumentException("callback must not be null");
        }
        return mStackSupervisor.createVirtualActivityContainer(r, callback);
    }
}
#method_after
@Override
public IActivityContainer createVirtualActivityContainer(IBinder parentActivityToken, IActivityContainerCallback callback) throws RemoteException {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "createActivityContainer()");
    synchronized (this) {
        if (parentActivityToken == null) {
            throw new IllegalArgumentException("parent token must not be null");
        }
        ActivityRecord r = ActivityRecord.forTokenLocked(parentActivityToken);
        if (r == null) {
            return null;
        }
        if (callback == null) {
            throw new IllegalArgumentException("callback must not be null");
        }
        return mStackSupervisor.createVirtualActivityContainer(r, callback);
    }
}
#end_block

#method_before
@Override
public void deleteActivityContainer(IActivityContainer container) throws RemoteException {
    enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, "deleteActivityContainer()");
    synchronized (this) {
        mStackSupervisor.deleteActivityContainer(container);
    }
}
#method_after
@Override
public void deleteActivityContainer(IActivityContainer container) throws RemoteException {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "deleteActivityContainer()");
    synchronized (this) {
        mStackSupervisor.deleteActivityContainer(container);
    }
}
#end_block

#method_before
@Override
public IActivityContainer createStackOnDisplay(int displayId) throws RemoteException {
    enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, "createStackOnDisplay()");
    synchronized (this) {
        final int stackId = mStackSupervisor.getNextStackId();
        final ActivityStack stack = mStackSupervisor.createStackOnDisplay(stackId, displayId);
        if (stack == null) {
            return null;
        }
        return stack.mActivityContainer;
    }
}
#method_after
@Override
public IActivityContainer createStackOnDisplay(int displayId) throws RemoteException {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "createStackOnDisplay()");
    synchronized (this) {
        final int stackId = mStackSupervisor.getNextStackId();
        final ActivityStack stack = mStackSupervisor.createStackOnDisplay(stackId, displayId, true);
        if (stack == null) {
            return null;
        }
        return stack.mActivityContainer;
    }
}
#end_block

#method_before
@Override
public void moveTaskToStack(int taskId, int stackId, boolean toTop) {
    enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, "moveTaskToStack()");
    if (stackId == HOME_STACK_ID) {
        Slog.e(TAG, "moveTaskToStack: Attempt to move task " + taskId + " to home stack", new RuntimeException("here").fillInStackTrace());
    }
    synchronized (this) {
        long ident = Binder.clearCallingIdentity();
        try {
            if (DEBUG_STACK)
                Slog.d(TAG_STACK, "moveTaskToStack: moving task=" + taskId + " to stackId=" + stackId + " toTop=" + toTop);
            mStackSupervisor.moveTaskToStackLocked(taskId, stackId, toTop);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#method_after
@Override
public void moveTaskToStack(int taskId, int stackId, boolean toTop) {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "moveTaskToStack()");
    if (stackId == HOME_STACK_ID) {
        throw new IllegalArgumentException("moveTaskToStack: Attempt to move task " + taskId + " to home stack");
    }
    synchronized (this) {
        long ident = Binder.clearCallingIdentity();
        try {
            if (DEBUG_STACK)
                Slog.d(TAG_STACK, "moveTaskToStack: moving task=" + taskId + " to stackId=" + stackId + " toTop=" + toTop);
            if (stackId == DOCKED_STACK_ID) {
                mWindowManager.setDockedStackCreateState(DOCKED_STACK_CREATE_MODE_TOP_OR_LEFT, null);
            }
            boolean result = mStackSupervisor.moveTaskToStackLocked(taskId, stackId, toTop, !FORCE_FOCUS, "moveTaskToStack", ANIMATE);
            if (result && stackId == DOCKED_STACK_ID) {
                // If task moved to docked stack - show recents if needed.
                mStackSupervisor.moveHomeStackTaskToTop(RECENTS_ACTIVITY_TYPE, "moveTaskToDockedStack");
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#end_block

#method_before
@Override
public void resizeStack(int stackId, Rect bounds) {
    enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, "resizeStack()");
    long ident = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            mStackSupervisor.resizeStackLocked(stackId, bounds);
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
@Override
public void resizeStack(int stackId, Rect bounds, boolean allowResizeInDockedMode, boolean preserveWindows, boolean animate, int animationDuration) {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "resizeStack()");
    long ident = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            if (animate) {
                if (stackId == PINNED_STACK_ID) {
                    mWindowManager.animateResizePinnedStack(bounds, animationDuration);
                } else {
                    throw new IllegalArgumentException("Stack: " + stackId + " doesn't support animated resize.");
                }
            } else {
                mStackSupervisor.resizeStackLocked(stackId, bounds, null, /* tempTaskBounds */
                null, /* tempTaskInsetBounds */
                preserveWindows, allowResizeInDockedMode, !DEFER_RESUME);
            }
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Override
public List<StackInfo> getAllStackInfos() {
    enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, "getAllStackInfos()");
    long ident = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            return mStackSupervisor.getAllStackInfosLocked();
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
@Override
public List<StackInfo> getAllStackInfos() {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "getAllStackInfos()");
    long ident = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            return mStackSupervisor.getAllStackInfosLocked();
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Override
public StackInfo getStackInfo(int stackId) {
    enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, "getStackInfo()");
    long ident = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            return mStackSupervisor.getStackInfoLocked(stackId);
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
@Override
public StackInfo getStackInfo(int stackId) {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "getStackInfo()");
    long ident = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            return mStackSupervisor.getStackInfoLocked(stackId);
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Override
public boolean isInHomeStack(int taskId) {
    enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS, "getStackInfo()");
    long ident = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            TaskRecord tr = mStackSupervisor.anyTaskForIdLocked(taskId, false);
            return tr != null && tr.stack != null && tr.stack.isHomeStack();
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
@Override
public boolean isInHomeStack(int taskId) {
    enforceCallingPermission(MANAGE_ACTIVITY_STACKS, "getStackInfo()");
    long ident = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            final TaskRecord tr = mStackSupervisor.anyTaskForIdLocked(taskId, !RESTORE_FROM_RECENTS, INVALID_STACK_ID);
            return tr != null && tr.stack != null && tr.stack.isHomeStack();
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Override
public void updateLockTaskPackages(int userId, String[] packages) {
    final int callingUid = Binder.getCallingUid();
    if (callingUid != 0 && callingUid != Process.SYSTEM_UID) {
        throw new SecurityException("updateLockTaskPackage called from non-system process");
    }
    synchronized (this) {
        if (DEBUG_LOCKTASK)
            Slog.w(TAG_LOCKTASK, "Whitelisting " + userId + ":" + Arrays.toString(packages));
        mLockTaskPackages.put(userId, packages);
        mStackSupervisor.onLockTaskPackagesUpdatedLocked();
    }
}
#method_after
@Override
public void updateLockTaskPackages(int userId, String[] packages) {
    final int callingUid = Binder.getCallingUid();
    if (callingUid != 0 && callingUid != Process.SYSTEM_UID) {
        enforceCallingPermission(android.Manifest.permission.UPDATE_LOCK_TASK_PACKAGES, "updateLockTaskPackages()");
    }
    synchronized (this) {
        if (DEBUG_LOCKTASK)
            Slog.w(TAG_LOCKTASK, "Whitelisting " + userId + ":" + Arrays.toString(packages));
        mLockTaskPackages.put(userId, packages);
        mStackSupervisor.onLockTaskPackagesUpdatedLocked();
    }
}
#end_block

#method_before
void startLockTaskModeLocked(TaskRecord task) {
    if (DEBUG_LOCKTASK)
        Slog.w(TAG_LOCKTASK, "startLockTaskModeLocked: " + task);
    if (task.mLockTaskAuth == LOCK_TASK_AUTH_DONT_LOCK) {
        return;
    }
    // isSystemInitiated is used to distinguish between locked and pinned mode, as pinned mode
    // is initiated by system after the pinning request was shown and locked mode is initiated
    // by an authorized app directly
    final int callingUid = Binder.getCallingUid();
    boolean isSystemInitiated = callingUid == Process.SYSTEM_UID;
    long ident = Binder.clearCallingIdentity();
    try {
        final ActivityStack stack = mStackSupervisor.getFocusedStack();
        if (!isSystemInitiated) {
            task.mLockTaskUid = callingUid;
            if (task.mLockTaskAuth == LOCK_TASK_AUTH_PINNABLE) {
                // startLockTask() called by app and task mode is lockTaskModeDefault.
                if (DEBUG_LOCKTASK)
                    Slog.w(TAG_LOCKTASK, "Mode default, asking user");
                StatusBarManagerInternal statusBarManager = LocalServices.getService(StatusBarManagerInternal.class);
                if (statusBarManager != null) {
                    statusBarManager.showScreenPinningRequest();
                }
                return;
            }
            if (stack == null || task != stack.topTask()) {
                throw new IllegalArgumentException("Invalid task, not in foreground");
            }
        }
        if (DEBUG_LOCKTASK)
            Slog.w(TAG_LOCKTASK, isSystemInitiated ? "Locking pinned" : "Locking fully");
        mStackSupervisor.setLockTaskModeLocked(task, isSystemInitiated ? ActivityManager.LOCK_TASK_MODE_PINNED : ActivityManager.LOCK_TASK_MODE_LOCKED, "startLockTask", true);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
void startLockTaskModeLocked(TaskRecord task) {
    if (DEBUG_LOCKTASK)
        Slog.w(TAG_LOCKTASK, "startLockTaskModeLocked: " + task);
    if (task.mLockTaskAuth == LOCK_TASK_AUTH_DONT_LOCK) {
        return;
    }
    // isSystemInitiated is used to distinguish between locked and pinned mode, as pinned mode
    // is initiated by system after the pinning request was shown and locked mode is initiated
    // by an authorized app directly
    final int callingUid = Binder.getCallingUid();
    boolean isSystemInitiated = callingUid == Process.SYSTEM_UID;
    long ident = Binder.clearCallingIdentity();
    try {
        if (!isSystemInitiated) {
            task.mLockTaskUid = callingUid;
            if (task.mLockTaskAuth == LOCK_TASK_AUTH_PINNABLE) {
                // startLockTask() called by app and task mode is lockTaskModeDefault.
                if (DEBUG_LOCKTASK)
                    Slog.w(TAG_LOCKTASK, "Mode default, asking user");
                StatusBarManagerInternal statusBarManager = LocalServices.getService(StatusBarManagerInternal.class);
                if (statusBarManager != null) {
                    statusBarManager.showScreenPinningRequest(task.taskId);
                }
                return;
            }
            final ActivityStack stack = mStackSupervisor.getFocusedStack();
            if (stack == null || task != stack.topTask()) {
                throw new IllegalArgumentException("Invalid task, not in foreground");
            }
        }
        if (DEBUG_LOCKTASK)
            Slog.w(TAG_LOCKTASK, isSystemInitiated ? "Locking pinned" : "Locking fully");
        mStackSupervisor.setLockTaskModeLocked(task, isSystemInitiated ? ActivityManager.LOCK_TASK_MODE_PINNED : ActivityManager.LOCK_TASK_MODE_LOCKED, "startLockTask", true);
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Override
public void stopLockTaskMode() {
    final TaskRecord lockTask = mStackSupervisor.getLockedTaskLocked();
    if (lockTask == null) {
        // Our work here is done.
        return;
    }
    final int callingUid = Binder.getCallingUid();
    final int lockTaskUid = lockTask.mLockTaskUid;
    // be 0, so we compare the callingUid to the {@link TaskRecord.effectiveUid} instead.
    if (getLockTaskModeState() == ActivityManager.LOCK_TASK_MODE_LOCKED && callingUid != lockTaskUid && (lockTaskUid != 0 || (lockTaskUid == 0 && callingUid != lockTask.effectiveUid))) {
        throw new SecurityException("Invalid uid, expected " + lockTaskUid + " callingUid=" + callingUid + " effectiveUid=" + lockTask.effectiveUid);
    }
    long ident = Binder.clearCallingIdentity();
    try {
        Log.d(TAG, "stopLockTaskMode");
        // Stop lock task
        synchronized (this) {
            mStackSupervisor.setLockTaskModeLocked(null, ActivityManager.LOCK_TASK_MODE_NONE, "stopLockTask", true);
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
@Override
public void stopLockTaskMode() {
    final TaskRecord lockTask = mStackSupervisor.getLockedTaskLocked();
    if (lockTask == null) {
        // Our work here is done.
        return;
    }
    final int callingUid = Binder.getCallingUid();
    final int lockTaskUid = lockTask.mLockTaskUid;
    final int lockTaskModeState = mStackSupervisor.getLockTaskModeState();
    if (lockTaskModeState == ActivityManager.LOCK_TASK_MODE_NONE) {
        // Done.
        return;
    } else {
        // {@link MANAGE_ACTIVITY_STACKS} can stop any lock task.
        if (checkCallingPermission(MANAGE_ACTIVITY_STACKS) != PERMISSION_GRANTED && callingUid != lockTaskUid && (lockTaskUid != 0 || callingUid != lockTask.effectiveUid)) {
            throw new SecurityException("Invalid uid, expected " + lockTaskUid + " callingUid=" + callingUid + " effectiveUid=" + lockTask.effectiveUid);
        }
    }
    long ident = Binder.clearCallingIdentity();
    try {
        Log.d(TAG, "stopLockTaskMode");
        // Stop lock task
        synchronized (this) {
            mStackSupervisor.setLockTaskModeLocked(null, ActivityManager.LOCK_TASK_MODE_NONE, "stopLockTask", true);
        }
        TelecomManager tm = (TelecomManager) mContext.getSystemService(Context.TELECOM_SERVICE);
        if (tm != null) {
            tm.showInCallScreen(false);
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
// =========================================================
// CONTENT PROVIDERS
// =========================================================
private final List<ProviderInfo> generateApplicationProvidersLocked(ProcessRecord app) {
    List<ProviderInfo> providers = null;
    try {
        ParceledListSlice<ProviderInfo> slice = AppGlobals.getPackageManager().queryContentProviders(app.processName, app.uid, STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS);
        providers = slice != null ? slice.getList() : null;
    } catch (RemoteException ex) {
    }
    if (DEBUG_MU)
        Slog.v(TAG_MU, "generateApplicationProvidersLocked, app.info.uid = " + app.uid);
    int userId = app.userId;
    if (providers != null) {
        int N = providers.size();
        app.pubProviders.ensureCapacity(N + app.pubProviders.size());
        for (int i = 0; i < N; i++) {
            ProviderInfo cpi = (ProviderInfo) providers.get(i);
            boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags);
            if (singleton && UserHandle.getUserId(app.uid) != UserHandle.USER_OWNER) {
                // This is a singleton provider, but a user besides the
                // default user is asking to initialize a process it runs
                // in...  well, no, it doesn't actually run in this process,
                // it runs in the process of the default user.  Get rid of it.
                providers.remove(i);
                N--;
                i--;
                continue;
            }
            ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
            ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId);
            if (cpr == null) {
                cpr = new ContentProviderRecord(this, cpi, app.info, comp, singleton);
                mProviderMap.putProviderByClass(comp, cpr);
            }
            if (DEBUG_MU)
                Slog.v(TAG_MU, "generateApplicationProvidersLocked, cpi.uid = " + cpr.uid);
            app.pubProviders.put(cpi.name, cpr);
            if (!cpi.multiprocess || !"android".equals(cpi.packageName)) {
                // Don't add this if it is a platform component that is marked
                // to run in multiple processes, because this is actually
                // part of the framework so doesn't make sense to track as a
                // separate apk in the process.
                app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.versionCode, mProcessStats);
            }
            ensurePackageDexOpt(cpi.applicationInfo.packageName);
        }
    }
    return providers;
}
#method_after
// =========================================================
// CONTENT PROVIDERS
// =========================================================
private final List<ProviderInfo> generateApplicationProvidersLocked(ProcessRecord app) {
    List<ProviderInfo> providers = null;
    try {
        providers = AppGlobals.getPackageManager().queryContentProviders(app.processName, app.uid, STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS | MATCH_DEBUG_TRIAGED_MISSING).getList();
    } catch (RemoteException ex) {
    }
    if (DEBUG_MU)
        Slog.v(TAG_MU, "generateApplicationProvidersLocked, app.info.uid = " + app.uid);
    int userId = app.userId;
    if (providers != null) {
        int N = providers.size();
        app.pubProviders.ensureCapacity(N + app.pubProviders.size());
        for (int i = 0; i < N; i++) {
            // TODO: keep logic in sync with installEncryptionUnawareProviders
            ProviderInfo cpi = (ProviderInfo) providers.get(i);
            boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags);
            if (singleton && UserHandle.getUserId(app.uid) != UserHandle.USER_SYSTEM) {
                // This is a singleton provider, but a user besides the
                // default user is asking to initialize a process it runs
                // in...  well, no, it doesn't actually run in this process,
                // it runs in the process of the default user.  Get rid of it.
                providers.remove(i);
                N--;
                i--;
                continue;
            }
            ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
            ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId);
            if (cpr == null) {
                cpr = new ContentProviderRecord(this, cpi, app.info, comp, singleton);
                mProviderMap.putProviderByClass(comp, cpr);
            }
            if (DEBUG_MU)
                Slog.v(TAG_MU, "generateApplicationProvidersLocked, cpi.uid = " + cpr.uid);
            app.pubProviders.put(cpi.name, cpr);
            if (!cpi.multiprocess || !"android".equals(cpi.packageName)) {
                // Don't add this if it is a platform component that is marked
                // to run in multiple processes, because this is actually
                // part of the framework so doesn't make sense to track as a
                // separate apk in the process.
                app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.versionCode, mProcessStats);
            }
            notifyPackageUse(cpi.applicationInfo.packageName, PackageManager.NOTIFY_PACKAGE_USE_CONTENT_PROVIDER);
        }
    }
    return providers;
}
#end_block

#method_before
private final String checkContentProviderPermissionLocked(ProviderInfo cpi, ProcessRecord r, int userId, boolean checkUser) {
    final int callingPid = (r != null) ? r.pid : Binder.getCallingPid();
    final int callingUid = (r != null) ? r.uid : Binder.getCallingUid();
    boolean checkedGrants = false;
    if (checkUser) {
        // Looking for cross-user grants before enforcing the typical cross-users permissions
        int tmpTargetUserId = unsafeConvertIncomingUser(userId);
        if (tmpTargetUserId != UserHandle.getUserId(callingUid)) {
            if (checkAuthorityGrants(callingUid, cpi, tmpTargetUserId, checkUser)) {
                return null;
            }
            checkedGrants = true;
        }
        userId = handleIncomingUser(callingPid, callingUid, userId, false, ALLOW_NON_FULL, "checkContentProviderPermissionLocked " + cpi.authority, null);
        if (userId != tmpTargetUserId) {
            // When we actually went to determine the final targer user ID, this ended
            // up different than our initial check for the authority.  This is because
            // they had asked for USER_CURRENT_OR_SELF and we ended up switching to
            // SELF.  So we need to re-check the grants again.
            checkedGrants = false;
        }
    }
    if (checkComponentPermission(cpi.readPermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) {
        return null;
    }
    if (checkComponentPermission(cpi.writePermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) {
        return null;
    }
    PathPermission[] pps = cpi.pathPermissions;
    if (pps != null) {
        int i = pps.length;
        while (i > 0) {
            i--;
            PathPermission pp = pps[i];
            String pprperm = pp.getReadPermission();
            if (pprperm != null && checkComponentPermission(pprperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) {
                return null;
            }
            String ppwperm = pp.getWritePermission();
            if (ppwperm != null && checkComponentPermission(ppwperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) {
                return null;
            }
        }
    }
    if (!checkedGrants && checkAuthorityGrants(callingUid, cpi, userId, checkUser)) {
        return null;
    }
    String msg;
    if (!cpi.exported) {
        msg = "Permission Denial: opening provider " + cpi.name + " from " + (r != null ? r : "(null)") + " (pid=" + callingPid + ", uid=" + callingUid + ") that is not exported from uid " + cpi.applicationInfo.uid;
    } else {
        msg = "Permission Denial: opening provider " + cpi.name + " from " + (r != null ? r : "(null)") + " (pid=" + callingPid + ", uid=" + callingUid + ") requires " + cpi.readPermission + " or " + cpi.writePermission;
    }
    Slog.w(TAG, msg);
    return msg;
}
#method_after
private final String checkContentProviderPermissionLocked(ProviderInfo cpi, ProcessRecord r, int userId, boolean checkUser) {
    final int callingPid = (r != null) ? r.pid : Binder.getCallingPid();
    final int callingUid = (r != null) ? r.uid : Binder.getCallingUid();
    boolean checkedGrants = false;
    if (checkUser) {
        // Looking for cross-user grants before enforcing the typical cross-users permissions
        int tmpTargetUserId = mUserController.unsafeConvertIncomingUserLocked(userId);
        if (tmpTargetUserId != UserHandle.getUserId(callingUid)) {
            if (checkAuthorityGrants(callingUid, cpi, tmpTargetUserId, checkUser)) {
                return null;
            }
            checkedGrants = true;
        }
        userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, false, ALLOW_NON_FULL, "checkContentProviderPermissionLocked " + cpi.authority, null);
        if (userId != tmpTargetUserId) {
            // When we actually went to determine the final targer user ID, this ended
            // up different than our initial check for the authority.  This is because
            // they had asked for USER_CURRENT_OR_SELF and we ended up switching to
            // SELF.  So we need to re-check the grants again.
            checkedGrants = false;
        }
    }
    if (checkComponentPermission(cpi.readPermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) {
        return null;
    }
    if (checkComponentPermission(cpi.writePermission, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) {
        return null;
    }
    PathPermission[] pps = cpi.pathPermissions;
    if (pps != null) {
        int i = pps.length;
        while (i > 0) {
            i--;
            PathPermission pp = pps[i];
            String pprperm = pp.getReadPermission();
            if (pprperm != null && checkComponentPermission(pprperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) {
                return null;
            }
            String ppwperm = pp.getWritePermission();
            if (ppwperm != null && checkComponentPermission(ppwperm, callingPid, callingUid, cpi.applicationInfo.uid, cpi.exported) == PackageManager.PERMISSION_GRANTED) {
                return null;
            }
        }
    }
    if (!checkedGrants && checkAuthorityGrants(callingUid, cpi, userId, checkUser)) {
        return null;
    }
    String msg;
    if (!cpi.exported) {
        msg = "Permission Denial: opening provider " + cpi.name + " from " + (r != null ? r : "(null)") + " (pid=" + callingPid + ", uid=" + callingUid + ") that is not exported from uid " + cpi.applicationInfo.uid;
    } else {
        msg = "Permission Denial: opening provider " + cpi.name + " from " + (r != null ? r : "(null)") + " (pid=" + callingPid + ", uid=" + callingUid + ") requires " + cpi.readPermission + " or " + cpi.writePermission;
    }
    Slog.w(TAG, msg);
    return msg;
}
#end_block

#method_before
ContentProviderConnection incProviderCountLocked(ProcessRecord r, final ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) {
    if (r != null) {
        for (int i = 0; i < r.conProviders.size(); i++) {
            ContentProviderConnection conn = r.conProviders.get(i);
            if (conn.provider == cpr) {
                if (DEBUG_PROVIDER)
                    Slog.v(TAG_PROVIDER, "Adding provider requested by " + r.processName + " from process " + cpr.info.processName + ": " + cpr.name.flattenToShortString() + " scnt=" + conn.stableCount + " uscnt=" + conn.unstableCount);
                if (stable) {
                    conn.stableCount++;
                    conn.numStableIncs++;
                } else {
                    conn.unstableCount++;
                    conn.numUnstableIncs++;
                }
                return conn;
            }
        }
        ContentProviderConnection conn = new ContentProviderConnection(cpr, r);
        if (stable) {
            conn.stableCount = 1;
            conn.numStableIncs = 1;
        } else {
            conn.unstableCount = 1;
            conn.numUnstableIncs = 1;
        }
        cpr.connections.add(conn);
        r.conProviders.add(conn);
        startAssociationLocked(r.uid, r.processName, cpr.uid, cpr.name, cpr.info.processName);
        return conn;
    }
    cpr.addExternalProcessHandleLocked(externalProcessToken);
    return null;
}
#method_after
ContentProviderConnection incProviderCountLocked(ProcessRecord r, final ContentProviderRecord cpr, IBinder externalProcessToken, boolean stable) {
    if (r != null) {
        for (int i = 0; i < r.conProviders.size(); i++) {
            ContentProviderConnection conn = r.conProviders.get(i);
            if (conn.provider == cpr) {
                if (DEBUG_PROVIDER)
                    Slog.v(TAG_PROVIDER, "Adding provider requested by " + r.processName + " from process " + cpr.info.processName + ": " + cpr.name.flattenToShortString() + " scnt=" + conn.stableCount + " uscnt=" + conn.unstableCount);
                if (stable) {
                    conn.stableCount++;
                    conn.numStableIncs++;
                } else {
                    conn.unstableCount++;
                    conn.numUnstableIncs++;
                }
                return conn;
            }
        }
        ContentProviderConnection conn = new ContentProviderConnection(cpr, r);
        if (stable) {
            conn.stableCount = 1;
            conn.numStableIncs = 1;
        } else {
            conn.unstableCount = 1;
            conn.numUnstableIncs = 1;
        }
        cpr.connections.add(conn);
        r.conProviders.add(conn);
        startAssociationLocked(r.uid, r.processName, r.curProcState, cpr.uid, cpr.name, cpr.info.processName);
        return conn;
    }
    cpr.addExternalProcessHandleLocked(externalProcessToken);
    return null;
}
#end_block

#method_before
private void checkTime(long startTime, String where) {
    long now = SystemClock.elapsedRealtime();
    if ((now - startTime) > 1000) {
        // If we are taking more than a second, log about it.
        Slog.w(TAG, "Slow operation: " + (now - startTime) + "ms so far, now at " + where);
    }
}
#method_after
private void checkTime(long startTime, String where) {
    long now = SystemClock.uptimeMillis();
    if ((now - startTime) > 50) {
        // If we are taking more than 50ms, log about it.
        Slog.w(TAG, "Slow operation: " + (now - startTime) + "ms so far, now at " + where);
    }
}
#end_block

#method_before
private final ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) {
    ContentProviderRecord cpr;
    ContentProviderConnection conn = null;
    ProviderInfo cpi = null;
    synchronized (this) {
        long startTime = SystemClock.elapsedRealtime();
        ProcessRecord r = null;
        if (caller != null) {
            r = getRecordForAppLocked(caller);
            if (r == null) {
                throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when getting content provider " + name);
            }
        }
        boolean checkCrossUser = true;
        checkTime(startTime, "getContentProviderImpl: getProviderByName");
        // First check if this content provider has been published...
        cpr = mProviderMap.getProviderByName(name, userId);
        // verify that it's a singleton provider before using it.
        if (cpr == null && userId != UserHandle.USER_OWNER) {
            cpr = mProviderMap.getProviderByName(name, UserHandle.USER_OWNER);
            if (cpr != null) {
                cpi = cpr.info;
                if (isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags) && isValidSingletonCall(r.uid, cpi.applicationInfo.uid)) {
                    userId = UserHandle.USER_OWNER;
                    checkCrossUser = false;
                } else {
                    cpr = null;
                    cpi = null;
                }
            }
        }
        boolean providerRunning = cpr != null;
        if (providerRunning) {
            cpi = cpr.info;
            String msg;
            checkTime(startTime, "getContentProviderImpl: before checkContentProviderPermission");
            if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, checkCrossUser)) != null) {
                throw new SecurityException(msg);
            }
            checkTime(startTime, "getContentProviderImpl: after checkContentProviderPermission");
            if (r != null && cpr.canRunHere(r)) {
                // This provider has been published or is in the process
                // of being published...  but it is also allowed to run
                // in the caller's process, so don't make a connection
                // and just let the caller instantiate its own instance.
                ContentProviderHolder holder = cpr.newHolder(null);
                // don't give caller the provider object, it needs
                // to make its own.
                holder.provider = null;
                return holder;
            }
            final long origId = Binder.clearCallingIdentity();
            checkTime(startTime, "getContentProviderImpl: incProviderCountLocked");
            // In this case the provider instance already exists, so we can
            // return it right away.
            conn = incProviderCountLocked(r, cpr, token, stable);
            if (conn != null && (conn.stableCount + conn.unstableCount) == 1) {
                if (cpr.proc != null && r.setAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
                    // If this is a perceptible app accessing the provider,
                    // make sure to count it as being accessed and thus
                    // back up on the LRU list.  This is good because
                    // content providers are often expensive to start.
                    checkTime(startTime, "getContentProviderImpl: before updateLruProcess");
                    updateLruProcessLocked(cpr.proc, false, null);
                    checkTime(startTime, "getContentProviderImpl: after updateLruProcess");
                }
            }
            if (cpr.proc != null) {
                if (false) {
                    if (cpr.name.flattenToShortString().equals("com.android.providers.calendar/.CalendarProvider2")) {
                        Slog.v(TAG, "****************** KILLING " + cpr.name.flattenToShortString());
                        Process.killProcess(cpr.proc.pid);
                    }
                }
                checkTime(startTime, "getContentProviderImpl: before updateOomAdj");
                boolean success = updateOomAdjLocked(cpr.proc);
                maybeUpdateProviderUsageStatsLocked(r, cpr.info.packageName, name);
                checkTime(startTime, "getContentProviderImpl: after updateOomAdj");
                if (DEBUG_PROVIDER)
                    Slog.i(TAG_PROVIDER, "Adjust success: " + success);
                // the race is now smaller.
                if (!success) {
                    // Uh oh...  it looks like the provider's process
                    // has been killed on us.  We need to wait for a new
                    // process to be started, and make sure its death
                    // doesn't kill our process.
                    Slog.i(TAG, "Existing provider " + cpr.name.flattenToShortString() + " is crashing; detaching " + r);
                    boolean lastRef = decProviderCountLocked(conn, cpr, token, stable);
                    checkTime(startTime, "getContentProviderImpl: before appDied");
                    appDiedLocked(cpr.proc);
                    checkTime(startTime, "getContentProviderImpl: after appDied");
                    if (!lastRef) {
                        // the provider...  we have now been killed, bail.
                        return null;
                    }
                    providerRunning = false;
                    conn = null;
                }
            }
            Binder.restoreCallingIdentity(origId);
        }
        boolean singleton;
        if (!providerRunning) {
            try {
                checkTime(startTime, "getContentProviderImpl: before resolveContentProvider");
                cpi = AppGlobals.getPackageManager().resolveContentProvider(name, STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId);
                checkTime(startTime, "getContentProviderImpl: after resolveContentProvider");
            } catch (RemoteException ex) {
            }
            if (cpi == null) {
                return null;
            }
            // If the provider is a singleton AND
            // (it's a call within the same user || the provider is a
            // privileged app)
            // Then allow connecting to the singleton provider
            singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags) && isValidSingletonCall(r.uid, cpi.applicationInfo.uid);
            if (singleton) {
                userId = UserHandle.USER_OWNER;
            }
            cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId);
            checkTime(startTime, "getContentProviderImpl: got app info for user");
            String msg;
            checkTime(startTime, "getContentProviderImpl: before checkContentProviderPermission");
            if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, !singleton)) != null) {
                throw new SecurityException(msg);
            }
            checkTime(startTime, "getContentProviderImpl: after checkContentProviderPermission");
            if (!mProcessesReady && !mDidUpdate && !mWaitingUpdate && !cpi.processName.equals("system")) {
                // processes, then fail fast instead of hanging.
                throw new IllegalArgumentException("Attempt to launch content provider before system ready");
            }
            // we don't want to allow it to run.
            if (!isUserRunningLocked(userId, false)) {
                Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": user " + userId + " is stopped");
                return null;
            }
            ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
            checkTime(startTime, "getContentProviderImpl: before getProviderByClass");
            cpr = mProviderMap.getProviderByClass(comp, userId);
            checkTime(startTime, "getContentProviderImpl: after getProviderByClass");
            final boolean firstClass = cpr == null;
            if (firstClass) {
                final long ident = Binder.clearCallingIdentity();
                try {
                    checkTime(startTime, "getContentProviderImpl: before getApplicationInfo");
                    ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName, STOCK_PM_FLAGS, userId);
                    checkTime(startTime, "getContentProviderImpl: after getApplicationInfo");
                    if (ai == null) {
                        Slog.w(TAG, "No package info for content provider " + cpi.name);
                        return null;
                    }
                    ai = getAppInfoForUser(ai, userId);
                    cpr = new ContentProviderRecord(this, cpi, ai, comp, singleton);
                } catch (RemoteException ex) {
                // pm is in same process, this will never happen.
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
            }
            checkTime(startTime, "getContentProviderImpl: now have ContentProviderRecord");
            if (r != null && cpr.canRunHere(r)) {
                // process, or can run as root (so can be in any process).
                return cpr.newHolder(null);
            }
            if (DEBUG_PROVIDER)
                Slog.w(TAG_PROVIDER, "LAUNCHING REMOTE PROVIDER (myuid " + (r != null ? r.uid : null) + " pruid " + cpr.appInfo.uid + "): " + cpr.info.name + " callers=" + Debug.getCallers(6));
            // This is single process, and our app is now connecting to it.
            // See if we are already in the process of launching this
            // provider.
            final int N = mLaunchingProviders.size();
            int i;
            for (i = 0; i < N; i++) {
                if (mLaunchingProviders.get(i) == cpr) {
                    break;
                }
            }
            // started.
            if (i >= N) {
                final long origId = Binder.clearCallingIdentity();
                try {
                    // Content provider is now in use, its package can't be stopped.
                    try {
                        checkTime(startTime, "getContentProviderImpl: before set stopped state");
                        AppGlobals.getPackageManager().setPackageStoppedState(cpr.appInfo.packageName, false, userId);
                        checkTime(startTime, "getContentProviderImpl: after set stopped state");
                    } catch (RemoteException e) {
                    } catch (IllegalArgumentException e) {
                        Slog.w(TAG, "Failed trying to unstop package " + cpr.appInfo.packageName + ": " + e);
                    }
                    // Use existing process if already started
                    checkTime(startTime, "getContentProviderImpl: looking for process record");
                    ProcessRecord proc = getProcessRecordLocked(cpi.processName, cpr.appInfo.uid, false);
                    if (proc != null && proc.thread != null) {
                        if (DEBUG_PROVIDER)
                            Slog.d(TAG_PROVIDER, "Installing in existing process " + proc);
                        if (!proc.pubProviders.containsKey(cpi.name)) {
                            checkTime(startTime, "getContentProviderImpl: scheduling install");
                            proc.pubProviders.put(cpi.name, cpr);
                            try {
                                proc.thread.scheduleInstallProvider(cpi);
                            } catch (RemoteException e) {
                            }
                        }
                    } else {
                        checkTime(startTime, "getContentProviderImpl: before start process");
                        proc = startProcessLocked(cpi.processName, cpr.appInfo, false, 0, "content provider", new ComponentName(cpi.applicationInfo.packageName, cpi.name), false, false, false);
                        checkTime(startTime, "getContentProviderImpl: after start process");
                        if (proc == null) {
                            Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": process is bad");
                            return null;
                        }
                    }
                    cpr.launchingApp = proc;
                    mLaunchingProviders.add(cpr);
                } finally {
                    Binder.restoreCallingIdentity(origId);
                }
            }
            checkTime(startTime, "getContentProviderImpl: updating data structures");
            // may be published under multiple names).
            if (firstClass) {
                mProviderMap.putProviderByClass(comp, cpr);
            }
            mProviderMap.putProviderByName(name, cpr);
            conn = incProviderCountLocked(r, cpr, token, stable);
            if (conn != null) {
                conn.waiting = true;
            }
        }
        checkTime(startTime, "getContentProviderImpl: done!");
    }
    // Wait for the provider to be published...
    synchronized (cpr) {
        while (cpr.provider == null) {
            if (cpr.launchingApp == null) {
                Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": launching app became null");
                EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS, UserHandle.getUserId(cpi.applicationInfo.uid), cpi.applicationInfo.packageName, cpi.applicationInfo.uid, name);
                return null;
            }
            try {
                if (DEBUG_MU)
                    Slog.v(TAG_MU, "Waiting to start provider " + cpr + " launchingApp=" + cpr.launchingApp);
                if (conn != null) {
                    conn.waiting = true;
                }
                cpr.wait();
            } catch (InterruptedException ex) {
            } finally {
                if (conn != null) {
                    conn.waiting = false;
                }
            }
        }
    }
    return cpr != null ? cpr.newHolder(conn) : null;
}
#method_after
private ContentProviderHolder getContentProviderImpl(IApplicationThread caller, String name, IBinder token, boolean stable, int userId) {
    ContentProviderRecord cpr;
    ContentProviderConnection conn = null;
    ProviderInfo cpi = null;
    synchronized (this) {
        long startTime = SystemClock.uptimeMillis();
        ProcessRecord r = null;
        if (caller != null) {
            r = getRecordForAppLocked(caller);
            if (r == null) {
                throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when getting content provider " + name);
            }
        }
        boolean checkCrossUser = true;
        checkTime(startTime, "getContentProviderImpl: getProviderByName");
        // First check if this content provider has been published...
        cpr = mProviderMap.getProviderByName(name, userId);
        // verify that it's a singleton provider before using it.
        if (cpr == null && userId != UserHandle.USER_SYSTEM) {
            cpr = mProviderMap.getProviderByName(name, UserHandle.USER_SYSTEM);
            if (cpr != null) {
                cpi = cpr.info;
                if (isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags) && isValidSingletonCall(r.uid, cpi.applicationInfo.uid)) {
                    userId = UserHandle.USER_SYSTEM;
                    checkCrossUser = false;
                } else {
                    cpr = null;
                    cpi = null;
                }
            }
        }
        boolean providerRunning = cpr != null && cpr.proc != null && !cpr.proc.killed;
        if (providerRunning) {
            cpi = cpr.info;
            String msg;
            checkTime(startTime, "getContentProviderImpl: before checkContentProviderPermission");
            if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, checkCrossUser)) != null) {
                throw new SecurityException(msg);
            }
            checkTime(startTime, "getContentProviderImpl: after checkContentProviderPermission");
            if (r != null && cpr.canRunHere(r)) {
                // This provider has been published or is in the process
                // of being published...  but it is also allowed to run
                // in the caller's process, so don't make a connection
                // and just let the caller instantiate its own instance.
                ContentProviderHolder holder = cpr.newHolder(null);
                // don't give caller the provider object, it needs
                // to make its own.
                holder.provider = null;
                return holder;
            }
            final long origId = Binder.clearCallingIdentity();
            checkTime(startTime, "getContentProviderImpl: incProviderCountLocked");
            // In this case the provider instance already exists, so we can
            // return it right away.
            conn = incProviderCountLocked(r, cpr, token, stable);
            if (conn != null && (conn.stableCount + conn.unstableCount) == 1) {
                if (cpr.proc != null && r.setAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
                    // If this is a perceptible app accessing the provider,
                    // make sure to count it as being accessed and thus
                    // back up on the LRU list.  This is good because
                    // content providers are often expensive to start.
                    checkTime(startTime, "getContentProviderImpl: before updateLruProcess");
                    updateLruProcessLocked(cpr.proc, false, null);
                    checkTime(startTime, "getContentProviderImpl: after updateLruProcess");
                }
            }
            checkTime(startTime, "getContentProviderImpl: before updateOomAdj");
            final int verifiedAdj = cpr.proc.verifiedAdj;
            boolean success = updateOomAdjLocked(cpr.proc);
            // them much smaller.
            if (success && verifiedAdj != cpr.proc.setAdj && !isProcessAliveLocked(cpr.proc)) {
                success = false;
            }
            maybeUpdateProviderUsageStatsLocked(r, cpr.info.packageName, name);
            checkTime(startTime, "getContentProviderImpl: after updateOomAdj");
            if (DEBUG_PROVIDER)
                Slog.i(TAG_PROVIDER, "Adjust success: " + success);
            // the race is now smaller.
            if (!success) {
                // Uh oh...  it looks like the provider's process
                // has been killed on us.  We need to wait for a new
                // process to be started, and make sure its death
                // doesn't kill our process.
                Slog.i(TAG, "Existing provider " + cpr.name.flattenToShortString() + " is crashing; detaching " + r);
                boolean lastRef = decProviderCountLocked(conn, cpr, token, stable);
                checkTime(startTime, "getContentProviderImpl: before appDied");
                appDiedLocked(cpr.proc);
                checkTime(startTime, "getContentProviderImpl: after appDied");
                if (!lastRef) {
                    // the provider...  we have now been killed, bail.
                    return null;
                }
                providerRunning = false;
                conn = null;
            } else {
                cpr.proc.verifiedAdj = cpr.proc.setAdj;
            }
            Binder.restoreCallingIdentity(origId);
        }
        if (!providerRunning) {
            try {
                checkTime(startTime, "getContentProviderImpl: before resolveContentProvider");
                cpi = AppGlobals.getPackageManager().resolveContentProvider(name, STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId);
                checkTime(startTime, "getContentProviderImpl: after resolveContentProvider");
            } catch (RemoteException ex) {
            }
            if (cpi == null) {
                return null;
            }
            // If the provider is a singleton AND
            // (it's a call within the same user || the provider is a
            // privileged app)
            // Then allow connecting to the singleton provider
            boolean singleton = isSingleton(cpi.processName, cpi.applicationInfo, cpi.name, cpi.flags) && isValidSingletonCall(r.uid, cpi.applicationInfo.uid);
            if (singleton) {
                userId = UserHandle.USER_SYSTEM;
            }
            cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId);
            checkTime(startTime, "getContentProviderImpl: got app info for user");
            String msg;
            checkTime(startTime, "getContentProviderImpl: before checkContentProviderPermission");
            if ((msg = checkContentProviderPermissionLocked(cpi, r, userId, !singleton)) != null) {
                throw new SecurityException(msg);
            }
            checkTime(startTime, "getContentProviderImpl: after checkContentProviderPermission");
            if (!mProcessesReady && !cpi.processName.equals("system")) {
                // processes, then fail fast instead of hanging.
                throw new IllegalArgumentException("Attempt to launch content provider before system ready");
            }
            // we don't want to allow it to run.
            if (!mUserController.isUserRunningLocked(userId, 0)) {
                Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": user " + userId + " is stopped");
                return null;
            }
            ComponentName comp = new ComponentName(cpi.packageName, cpi.name);
            checkTime(startTime, "getContentProviderImpl: before getProviderByClass");
            cpr = mProviderMap.getProviderByClass(comp, userId);
            checkTime(startTime, "getContentProviderImpl: after getProviderByClass");
            final boolean firstClass = cpr == null;
            if (firstClass) {
                final long ident = Binder.clearCallingIdentity();
                // is in the foreground.
                if (Build.PERMISSIONS_REVIEW_REQUIRED) {
                    if (!requestTargetProviderPermissionsReviewIfNeededLocked(cpi, r, userId)) {
                        return null;
                    }
                }
                try {
                    checkTime(startTime, "getContentProviderImpl: before getApplicationInfo");
                    ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(cpi.applicationInfo.packageName, STOCK_PM_FLAGS, userId);
                    checkTime(startTime, "getContentProviderImpl: after getApplicationInfo");
                    if (ai == null) {
                        Slog.w(TAG, "No package info for content provider " + cpi.name);
                        return null;
                    }
                    ai = getAppInfoForUser(ai, userId);
                    cpr = new ContentProviderRecord(this, cpi, ai, comp, singleton);
                } catch (RemoteException ex) {
                // pm is in same process, this will never happen.
                } finally {
                    Binder.restoreCallingIdentity(ident);
                }
            }
            checkTime(startTime, "getContentProviderImpl: now have ContentProviderRecord");
            if (r != null && cpr.canRunHere(r)) {
                // process, or can run as root (so can be in any process).
                return cpr.newHolder(null);
            }
            if (DEBUG_PROVIDER)
                Slog.w(TAG_PROVIDER, "LAUNCHING REMOTE PROVIDER (myuid " + (r != null ? r.uid : null) + " pruid " + cpr.appInfo.uid + "): " + cpr.info.name + " callers=" + Debug.getCallers(6));
            // This is single process, and our app is now connecting to it.
            // See if we are already in the process of launching this
            // provider.
            final int N = mLaunchingProviders.size();
            int i;
            for (i = 0; i < N; i++) {
                if (mLaunchingProviders.get(i) == cpr) {
                    break;
                }
            }
            // started.
            if (i >= N) {
                final long origId = Binder.clearCallingIdentity();
                try {
                    // Content provider is now in use, its package can't be stopped.
                    try {
                        checkTime(startTime, "getContentProviderImpl: before set stopped state");
                        AppGlobals.getPackageManager().setPackageStoppedState(cpr.appInfo.packageName, false, userId);
                        checkTime(startTime, "getContentProviderImpl: after set stopped state");
                    } catch (RemoteException e) {
                    } catch (IllegalArgumentException e) {
                        Slog.w(TAG, "Failed trying to unstop package " + cpr.appInfo.packageName + ": " + e);
                    }
                    // Use existing process if already started
                    checkTime(startTime, "getContentProviderImpl: looking for process record");
                    ProcessRecord proc = getProcessRecordLocked(cpi.processName, cpr.appInfo.uid, false);
                    if (proc != null && proc.thread != null && !proc.killed) {
                        if (DEBUG_PROVIDER)
                            Slog.d(TAG_PROVIDER, "Installing in existing process " + proc);
                        if (!proc.pubProviders.containsKey(cpi.name)) {
                            checkTime(startTime, "getContentProviderImpl: scheduling install");
                            proc.pubProviders.put(cpi.name, cpr);
                            try {
                                proc.thread.scheduleInstallProvider(cpi);
                            } catch (RemoteException e) {
                            }
                        }
                    } else {
                        checkTime(startTime, "getContentProviderImpl: before start process");
                        proc = startProcessLocked(cpi.processName, cpr.appInfo, false, 0, "content provider", new ComponentName(cpi.applicationInfo.packageName, cpi.name), false, false, false);
                        checkTime(startTime, "getContentProviderImpl: after start process");
                        if (proc == null) {
                            Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": process is bad");
                            return null;
                        }
                    }
                    cpr.launchingApp = proc;
                    mLaunchingProviders.add(cpr);
                } finally {
                    Binder.restoreCallingIdentity(origId);
                }
            }
            checkTime(startTime, "getContentProviderImpl: updating data structures");
            // may be published under multiple names).
            if (firstClass) {
                mProviderMap.putProviderByClass(comp, cpr);
            }
            mProviderMap.putProviderByName(name, cpr);
            conn = incProviderCountLocked(r, cpr, token, stable);
            if (conn != null) {
                conn.waiting = true;
            }
        }
        checkTime(startTime, "getContentProviderImpl: done!");
    }
    // Wait for the provider to be published...
    synchronized (cpr) {
        while (cpr.provider == null) {
            if (cpr.launchingApp == null) {
                Slog.w(TAG, "Unable to launch app " + cpi.applicationInfo.packageName + "/" + cpi.applicationInfo.uid + " for provider " + name + ": launching app became null");
                EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS, UserHandle.getUserId(cpi.applicationInfo.uid), cpi.applicationInfo.packageName, cpi.applicationInfo.uid, name);
                return null;
            }
            try {
                if (DEBUG_MU)
                    Slog.v(TAG_MU, "Waiting to start provider " + cpr + " launchingApp=" + cpr.launchingApp);
                if (conn != null) {
                    conn.waiting = true;
                }
                cpr.wait();
            } catch (InterruptedException ex) {
            } finally {
                if (conn != null) {
                    conn.waiting = false;
                }
            }
        }
    }
    return cpr != null ? cpr.newHolder(conn) : null;
}
#end_block

#method_before
public ContentProviderHolder getContentProviderExternal(String name, int userId, IBinder token) {
    enforceCallingPermission(android.Manifest.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY, "Do not have permission in call getContentProviderExternal()");
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "getContentProvider", null);
    return getContentProviderExternalUnchecked(name, token, userId);
}
#method_after
public ContentProviderHolder getContentProviderExternal(String name, int userId, IBinder token) {
    enforceCallingPermission(android.Manifest.permission.ACCESS_CONTENT_PROVIDERS_EXTERNALLY, "Do not have permission in call getContentProviderExternal()");
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "getContentProvider", null);
    return getContentProviderExternalUnchecked(name, token, userId);
}
#end_block

#method_before
@Override
public void appNotRespondingViaProvider(IBinder connection) {
    enforceCallingPermission(android.Manifest.permission.REMOVE_TASKS, "appNotRespondingViaProvider()");
    final ContentProviderConnection conn = (ContentProviderConnection) connection;
    if (conn == null) {
        Slog.w(TAG, "ContentProviderConnection is null");
        return;
    }
    final ProcessRecord host = conn.provider.proc;
    if (host == null) {
        Slog.w(TAG, "Failed to find hosting ProcessRecord");
        return;
    }
    final long token = Binder.clearCallingIdentity();
    try {
        appNotResponding(host, null, null, false, "ContentProvider not responding");
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}
#method_after
@Override
public void appNotRespondingViaProvider(IBinder connection) {
    enforceCallingPermission(android.Manifest.permission.REMOVE_TASKS, "appNotRespondingViaProvider()");
    final ContentProviderConnection conn = (ContentProviderConnection) connection;
    if (conn == null) {
        Slog.w(TAG, "ContentProviderConnection is null");
        return;
    }
    final ProcessRecord host = conn.provider.proc;
    if (host == null) {
        Slog.w(TAG, "Failed to find hosting ProcessRecord");
        return;
    }
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            mAppErrors.appNotResponding(host, null, null, false, "ContentProvider not responding");
        }
    });
}
#end_block

#method_before
public final void installSystemProviders() {
    List<ProviderInfo> providers;
    synchronized (this) {
        ProcessRecord app = mProcessNames.get("system", Process.SYSTEM_UID);
        providers = generateApplicationProvidersLocked(app);
        if (providers != null) {
            for (int i = providers.size() - 1; i >= 0; i--) {
                ProviderInfo pi = (ProviderInfo) providers.get(i);
                if ((pi.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
                    Slog.w(TAG, "Not installing system proc provider " + pi.name + ": not system .apk");
                    providers.remove(i);
                }
            }
        }
    }
    if (providers != null) {
        mSystemThread.installSystemProviders(providers);
    }
    mCoreSettingsObserver = new CoreSettingsObserver(this);
// mUsageStatsService.monitorPackages();
}
#method_after
public final void installSystemProviders() {
    List<ProviderInfo> providers;
    synchronized (this) {
        ProcessRecord app = mProcessNames.get("system", Process.SYSTEM_UID);
        providers = generateApplicationProvidersLocked(app);
        if (providers != null) {
            for (int i = providers.size() - 1; i >= 0; i--) {
                ProviderInfo pi = (ProviderInfo) providers.get(i);
                if ((pi.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
                    Slog.w(TAG, "Not installing system proc provider " + pi.name + ": not system .apk");
                    providers.remove(i);
                }
            }
        }
    }
    if (providers != null) {
        mSystemThread.installSystemProviders(providers);
    }
    mCoreSettingsObserver = new CoreSettingsObserver(this);
    mFontScaleSettingObserver = new FontScaleSettingObserver();
// mUsageStatsService.monitorPackages();
}
#end_block

#method_before
public String getProviderMimeType(Uri uri, int userId) {
    enforceNotIsolatedCaller("getProviderMimeType");
    final String name = uri.getAuthority();
    int callingUid = Binder.getCallingUid();
    int callingPid = Binder.getCallingPid();
    long ident = 0;
    boolean clearedIdentity = false;
    userId = unsafeConvertIncomingUser(userId);
    if (canClearIdentity(callingPid, callingUid, userId)) {
        clearedIdentity = true;
        ident = Binder.clearCallingIdentity();
    }
    ContentProviderHolder holder = null;
    try {
        holder = getContentProviderExternalUnchecked(name, null, userId);
        if (holder != null) {
            return holder.provider.getType(uri);
        }
    } catch (RemoteException e) {
        Log.w(TAG, "Content provider dead retrieving " + uri, e);
        return null;
    } finally {
        // We need to clear the identity to call removeContentProviderExternalUnchecked
        if (!clearedIdentity) {
            ident = Binder.clearCallingIdentity();
        }
        try {
            if (holder != null) {
                removeContentProviderExternalUnchecked(name, null, userId);
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
    return null;
}
#method_after
public String getProviderMimeType(Uri uri, int userId) {
    enforceNotIsolatedCaller("getProviderMimeType");
    final String name = uri.getAuthority();
    int callingUid = Binder.getCallingUid();
    int callingPid = Binder.getCallingPid();
    long ident = 0;
    boolean clearedIdentity = false;
    synchronized (this) {
        userId = mUserController.unsafeConvertIncomingUserLocked(userId);
    }
    if (canClearIdentity(callingPid, callingUid, userId)) {
        clearedIdentity = true;
        ident = Binder.clearCallingIdentity();
    }
    ContentProviderHolder holder = null;
    try {
        holder = getContentProviderExternalUnchecked(name, null, userId);
        if (holder != null) {
            return holder.provider.getType(uri);
        }
    } catch (RemoteException e) {
        Log.w(TAG, "Content provider dead retrieving " + uri, e);
        return null;
    } catch (Exception e) {
        Log.w(TAG, "Exception while determining type of " + uri, e);
        return null;
    } finally {
        // We need to clear the identity to call removeContentProviderExternalUnchecked
        if (!clearedIdentity) {
            ident = Binder.clearCallingIdentity();
        }
        try {
            if (holder != null) {
                removeContentProviderExternalUnchecked(name, null, userId);
            }
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
    return null;
}
#end_block

#method_before
// =========================================================
// GLOBAL MANAGEMENT
// =========================================================
final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) {
    String proc = customProcess != null ? customProcess : info.processName;
    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    final int userId = UserHandle.getUserId(info.uid);
    int uid = info.uid;
    if (isolated) {
        if (isolatedUid == 0) {
            int stepsLeft = Process.LAST_ISOLATED_UID - Process.FIRST_ISOLATED_UID + 1;
            while (true) {
                if (mNextIsolatedProcessUid < Process.FIRST_ISOLATED_UID || mNextIsolatedProcessUid > Process.LAST_ISOLATED_UID) {
                    mNextIsolatedProcessUid = Process.FIRST_ISOLATED_UID;
                }
                uid = UserHandle.getUid(userId, mNextIsolatedProcessUid);
                mNextIsolatedProcessUid++;
                if (mIsolatedProcesses.indexOfKey(uid) < 0) {
                    // No process for this uid, use it.
                    break;
                }
                stepsLeft--;
                if (stepsLeft <= 0) {
                    return null;
                }
            }
        } else {
            // Special case for startIsolatedProcess (internal only), where
            // the uid of the isolated process is specified by the caller.
            uid = isolatedUid;
        }
    }
    final ProcessRecord r = new ProcessRecord(stats, info, proc, uid);
    if (!mBooted && !mBooting && userId == UserHandle.USER_OWNER && (info.flags & PERSISTENT_MASK) == PERSISTENT_MASK) {
        r.persistent = true;
    }
    addProcessNameLocked(r);
    return r;
}
#method_after
// =========================================================
// GLOBAL MANAGEMENT
// =========================================================
final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) {
    String proc = customProcess != null ? customProcess : info.processName;
    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    final int userId = UserHandle.getUserId(info.uid);
    int uid = info.uid;
    if (isolated) {
        if (isolatedUid == 0) {
            int stepsLeft = Process.LAST_ISOLATED_UID - Process.FIRST_ISOLATED_UID + 1;
            while (true) {
                if (mNextIsolatedProcessUid < Process.FIRST_ISOLATED_UID || mNextIsolatedProcessUid > Process.LAST_ISOLATED_UID) {
                    mNextIsolatedProcessUid = Process.FIRST_ISOLATED_UID;
                }
                uid = UserHandle.getUid(userId, mNextIsolatedProcessUid);
                mNextIsolatedProcessUid++;
                if (mIsolatedProcesses.indexOfKey(uid) < 0) {
                    // No process for this uid, use it.
                    break;
                }
                stepsLeft--;
                if (stepsLeft <= 0) {
                    return null;
                }
            }
        } else {
            // Special case for startIsolatedProcess (internal only), where
            // the uid of the isolated process is specified by the caller.
            uid = isolatedUid;
        }
    }
    final ProcessRecord r = new ProcessRecord(stats, info, proc, uid);
    if (!mBooted && !mBooting && userId == UserHandle.USER_SYSTEM && (info.flags & PERSISTENT_MASK) == PERSISTENT_MASK) {
        r.persistent = true;
        r.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;
    }
    addProcessNameLocked(r);
    return r;
}
#end_block

#method_before
void notifyTaskPersisterLocked(TaskRecord task, boolean flush) {
    if (task != null && task.stack != null && task.stack.isHomeStack()) {
        // Never persist the home stack.
        return;
    }
    mTaskPersister.wakeup(task, flush);
}
#method_after
void notifyTaskPersisterLocked(TaskRecord task, boolean flush) {
    mRecentTasks.notifyTaskPersisterLocked(task, flush);
}
#end_block

#method_before
void notifyTaskStackChangedLocked() {
    mHandler.removeMessages(NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG);
    Message nmsg = mHandler.obtainMessage(NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG);
    mHandler.sendMessageDelayed(nmsg, NOTIFY_TASK_STACK_CHANGE_LISTENERS_DELAY);
}
#method_after
void notifyTaskStackChangedLocked() {
    mHandler.sendEmptyMessage(LOG_STACK_STATE);
    mHandler.removeMessages(NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG);
    Message nmsg = mHandler.obtainMessage(NOTIFY_TASK_STACK_CHANGE_LISTENERS_MSG);
    mHandler.sendMessageDelayed(nmsg, NOTIFY_TASK_STACK_CHANGE_LISTENERS_DELAY);
}
#end_block

#method_before
void startRunningVoiceLocked(IVoiceInteractionSession session, int targetUid) {
    mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
    if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
        boolean wasRunningVoice = mRunningVoice != null;
        mRunningVoice = session;
        if (!wasRunningVoice) {
            mVoiceWakeLock.acquire();
            updateSleepIfNeededLocked();
        }
    }
}
#method_after
void startRunningVoiceLocked(IVoiceInteractionSession session, int targetUid) {
    Slog.d(TAG, "<<<  startRunningVoiceLocked()");
    mVoiceWakeLock.setWorkSource(new WorkSource(targetUid));
    if (mRunningVoice == null || mRunningVoice.asBinder() != session.asBinder()) {
        boolean wasRunningVoice = mRunningVoice != null;
        mRunningVoice = session;
        if (!wasRunningVoice) {
            mVoiceWakeLock.acquire();
            updateSleepIfNeededLocked();
        }
    }
}
#end_block

#method_before
public void setLockScreenShown(boolean shown) {
    if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException("Requires permission " + android.Manifest.permission.DEVICE_POWER);
    }
    synchronized (this) {
        long ident = Binder.clearCallingIdentity();
        try {
            if (DEBUG_LOCKSCREEN)
                logLockScreen(" shown=" + shown);
            mLockScreenShown = shown ? LOCK_SCREEN_SHOWN : LOCK_SCREEN_HIDDEN;
            updateSleepIfNeededLocked();
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#method_after
public void setLockScreenShown(boolean showing, boolean occluded) {
    if (checkCallingPermission(android.Manifest.permission.DEVICE_POWER) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException("Requires permission " + android.Manifest.permission.DEVICE_POWER);
    }
    synchronized (this) {
        long ident = Binder.clearCallingIdentity();
        try {
            if (DEBUG_LOCKSCREEN)
                logLockScreen(" showing=" + showing + " occluded=" + occluded);
            mLockScreenShown = (showing && !occluded) ? LOCK_SCREEN_SHOWN : LOCK_SCREEN_HIDDEN;
            if (showing && occluded) {
                // The lock screen is currently showing, but is occluded by a window that can
                // show on top of the lock screen. In this can we want to dismiss the docked
                // stack since it will be complicated/risky to try to put the activity on top
                // of the lock screen in the right fullscreen configuration.
                mStackSupervisor.moveTasksToFullscreenStackLocked(DOCKED_STACK_ID, mStackSupervisor.mFocusedStack.getStackId() == DOCKED_STACK_ID);
            }
            updateSleepIfNeededLocked();
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
    }
}
#end_block

#method_before
@Override
public void stopAppSwitches() {
    if (checkCallingPermission(android.Manifest.permission.STOP_APP_SWITCHES) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException("Requires permission " + android.Manifest.permission.STOP_APP_SWITCHES);
    }
    synchronized (this) {
        mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME;
        mDidAppSwitch = false;
        mHandler.removeMessages(DO_PENDING_ACTIVITY_LAUNCHES_MSG);
        Message msg = mHandler.obtainMessage(DO_PENDING_ACTIVITY_LAUNCHES_MSG);
        mHandler.sendMessageDelayed(msg, APP_SWITCH_DELAY_TIME);
    }
}
#method_after
@Override
public void stopAppSwitches() {
    if (checkCallingPermission(android.Manifest.permission.STOP_APP_SWITCHES) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException("viewquires permission " + android.Manifest.permission.STOP_APP_SWITCHES);
    }
    synchronized (this) {
        mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME;
        mDidAppSwitch = false;
        mHandler.removeMessages(DO_PENDING_ACTIVITY_LAUNCHES_MSG);
        Message msg = mHandler.obtainMessage(DO_PENDING_ACTIVITY_LAUNCHES_MSG);
        mHandler.sendMessageDelayed(msg, APP_SWITCH_DELAY_TIME);
    }
}
#end_block

#method_before
@Override
public void setAlwaysFinish(boolean enabled) {
    enforceCallingPermission(android.Manifest.permission.SET_ALWAYS_FINISH, "setAlwaysFinish()");
    Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.ALWAYS_FINISH_ACTIVITIES, enabled ? 1 : 0);
    synchronized (this) {
        mAlwaysFinishActivities = enabled;
    }
}
#method_after
@Override
public void setAlwaysFinish(boolean enabled) {
    enforceCallingPermission(android.Manifest.permission.SET_ALWAYS_FINISH, "setAlwaysFinish()");
    long ident = Binder.clearCallingIdentity();
    try {
        Settings.Global.putInt(mContext.getContentResolver(), Settings.Global.ALWAYS_FINISH_ACTIVITIES, enabled ? 1 : 0);
        synchronized (this) {
            mAlwaysFinishActivities = enabled;
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
@Override
public void setActivityController(IActivityController controller) {
    enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER, "setActivityController()");
    synchronized (this) {
        mController = controller;
        Watchdog.getInstance().setActivityController(controller);
    }
}
#method_after
@Override
public void setActivityController(IActivityController controller, boolean imAMonkey) {
    enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER, "setActivityController()");
    synchronized (this) {
        mController = controller;
        mControllerIsAMonkey = imAMonkey;
        Watchdog.getInstance().setActivityController(controller);
    }
}
#end_block

#method_before
@Override
public boolean isUserAMonkey() {
    synchronized (this) {
        // If there is a controller also implies the user is a monkey.
        return (mUserIsMonkey || mController != null);
    }
}
#method_after
@Override
public boolean isUserAMonkey() {
    synchronized (this) {
        // If there is a controller also implies the user is a monkey.
        return (mUserIsMonkey || (mController != null && mControllerIsAMonkey));
    }
}
#end_block

#method_before
public void requestBugReport() {
    enforceCallingPermission(android.Manifest.permission.DUMP, "requestBugReport");
    SystemProperties.set("ctl.start", "bugreport");
}
#method_after
public void requestBugReport(int bugreportType) {
    String service = null;
    switch(bugreportType) {
        case ActivityManager.BUGREPORT_OPTION_FULL:
            service = "bugreport";
            break;
        case ActivityManager.BUGREPORT_OPTION_INTERACTIVE:
            service = "bugreportplus";
            break;
        case ActivityManager.BUGREPORT_OPTION_REMOTE:
            service = "bugreportremote";
            break;
    }
    if (service == null) {
        throw new IllegalArgumentException("Provided bugreport type is not correct, value: " + bugreportType);
    }
    enforceCallingPermission(android.Manifest.permission.DUMP, "requestBugReport");
    SystemProperties.set("ctl.start", service);
}
#end_block

#method_before
public boolean inputDispatchingTimedOut(final ProcessRecord proc, final ActivityRecord activity, final ActivityRecord parent, final boolean aboveSystem, String reason) {
    if (checkCallingPermission(android.Manifest.permission.FILTER_EVENTS) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException("Requires permission " + android.Manifest.permission.FILTER_EVENTS);
    }
    final String annotation;
    if (reason == null) {
        annotation = "Input dispatching timed out";
    } else {
        annotation = "Input dispatching timed out (" + reason + ")";
    }
    if (proc != null) {
        synchronized (this) {
            if (proc.debugging) {
                return false;
            }
            if (mDidDexOpt) {
                // Give more time since we were dexopting.
                mDidDexOpt = false;
                return false;
            }
            if (proc.instrumentationClass != null) {
                Bundle info = new Bundle();
                info.putString("shortMsg", "keyDispatchingTimedOut");
                info.putString("longMsg", annotation);
                finishInstrumentationLocked(proc, Activity.RESULT_CANCELED, info);
                return true;
            }
        }
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                appNotResponding(proc, activity, parent, aboveSystem, annotation);
            }
        });
    }
    return true;
}
#method_after
public boolean inputDispatchingTimedOut(final ProcessRecord proc, final ActivityRecord activity, final ActivityRecord parent, final boolean aboveSystem, String reason) {
    if (checkCallingPermission(android.Manifest.permission.FILTER_EVENTS) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException("Requires permission " + android.Manifest.permission.FILTER_EVENTS);
    }
    final String annotation;
    if (reason == null) {
        annotation = "Input dispatching timed out";
    } else {
        annotation = "Input dispatching timed out (" + reason + ")";
    }
    if (proc != null) {
        synchronized (this) {
            if (proc.debugging) {
                return false;
            }
            if (mDidDexOpt) {
                // Give more time since we were dexopting.
                mDidDexOpt = false;
                return false;
            }
            if (proc.instrumentationClass != null) {
                Bundle info = new Bundle();
                info.putString("shortMsg", "keyDispatchingTimedOut");
                info.putString("longMsg", annotation);
                finishInstrumentationLocked(proc, Activity.RESULT_CANCELED, info);
                return true;
            }
        }
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                mAppErrors.appNotResponding(proc, activity, parent, aboveSystem, annotation);
            }
        });
    }
    return true;
}
#end_block

#method_before
@Override
public Bundle getAssistContextExtras(int requestType) {
    PendingAssistExtras pae = enqueueAssistContext(requestType, null, null, null, null, UserHandle.getCallingUserId(), null, PENDING_ASSIST_EXTRAS_TIMEOUT);
    if (pae == null) {
        return null;
    }
    synchronized (pae) {
        while (!pae.haveResult) {
            try {
                pae.wait();
            } catch (InterruptedException e) {
            }
        }
    }
    synchronized (this) {
        buildAssistBundleLocked(pae, pae.result);
        mPendingAssistExtras.remove(pae);
        mUiHandler.removeCallbacks(pae);
    }
    return pae.extras;
}
#method_after
@Override
public Bundle getAssistContextExtras(int requestType) {
    PendingAssistExtras pae = enqueueAssistContext(requestType, null, null, null, null, null, true, /* focused */
    true, /* newSessionId */
    UserHandle.getCallingUserId(), null, PENDING_ASSIST_EXTRAS_TIMEOUT);
    if (pae == null) {
        return null;
    }
    synchronized (pae) {
        while (!pae.haveResult) {
            try {
                pae.wait();
            } catch (InterruptedException e) {
            }
        }
    }
    synchronized (this) {
        buildAssistBundleLocked(pae, pae.result);
        mPendingAssistExtras.remove(pae);
        mUiHandler.removeCallbacks(pae);
    }
    return pae.extras;
}
#end_block

#method_before
@Override
public boolean isAssistDataAllowedOnCurrentActivity() {
    int userId = mCurrentUserId;
    synchronized (this) {
        ActivityRecord activity = getFocusedStack().topActivity();
        if (activity == null) {
            return false;
        }
        userId = activity.userId;
    }
    DevicePolicyManager dpm = (DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
    return (dpm == null) || (!dpm.getScreenCaptureDisabled(null, userId));
}
#method_after
@Override
public boolean isAssistDataAllowedOnCurrentActivity() {
    int userId;
    synchronized (this) {
        userId = mUserController.getCurrentUserIdLocked();
        ActivityRecord activity = getFocusedStack().topActivity();
        if (activity == null) {
            return false;
        }
        userId = activity.userId;
    }
    DevicePolicyManager dpm = (DevicePolicyManager) mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
    return (dpm == null) || (!dpm.getScreenCaptureDisabled(null, userId));
}
#end_block

#method_before
@Override
public boolean requestAssistContextExtras(int requestType, IResultReceiver receiver, IBinder activityToken) {
    return enqueueAssistContext(requestType, null, null, receiver, activityToken, UserHandle.getCallingUserId(), null, PENDING_ASSIST_EXTRAS_LONG_TIMEOUT) != null;
}
#method_after
@Override
public boolean requestAssistContextExtras(int requestType, IResultReceiver receiver, Bundle receiverExtras, IBinder activityToken, boolean focused, boolean newSessionId) {
    return enqueueAssistContext(requestType, null, null, receiver, receiverExtras, activityToken, focused, newSessionId, UserHandle.getCallingUserId(), null, PENDING_ASSIST_EXTRAS_LONG_TIMEOUT) != null;
}
#end_block

#method_before
private PendingAssistExtras enqueueAssistContext(int requestType, Intent intent, String hint, IResultReceiver receiver, IBinder activityToken, int userHandle, Bundle args, long timeout) {
    enforceCallingPermission(android.Manifest.permission.GET_TOP_ACTIVITY_INFO, "enqueueAssistContext()");
    synchronized (this) {
        ActivityRecord activity = getFocusedStack().topActivity();
        if (activity == null) {
            Slog.w(TAG, "getAssistContextExtras failed: no top activity");
            return null;
        }
        if (activity.app == null || activity.app.thread == null) {
            Slog.w(TAG, "getAssistContextExtras failed: no process for " + activity);
            return null;
        }
        if (activityToken != null) {
            ActivityRecord caller = ActivityRecord.forTokenLocked(activityToken);
            if (activity != caller) {
                Slog.w(TAG, "enqueueAssistContext failed: caller " + caller + " is not current top " + activity);
                return null;
            }
        }
        PendingAssistExtras pae;
        Bundle extras = new Bundle();
        if (args != null) {
            extras.putAll(args);
        }
        extras.putString(Intent.EXTRA_ASSIST_PACKAGE, activity.packageName);
        extras.putInt(Intent.EXTRA_ASSIST_UID, activity.app.uid);
        pae = new PendingAssistExtras(activity, extras, intent, hint, receiver, userHandle);
        try {
            activity.app.thread.requestAssistContextExtras(activity.appToken, pae, requestType);
            mPendingAssistExtras.add(pae);
            mUiHandler.postDelayed(pae, timeout);
        } catch (RemoteException e) {
            Slog.w(TAG, "getAssistContextExtras failed: crash calling " + activity);
            return null;
        }
        return pae;
    }
}
#method_after
private PendingAssistExtras enqueueAssistContext(int requestType, Intent intent, String hint, IResultReceiver receiver, Bundle receiverExtras, IBinder activityToken, boolean focused, boolean newSessionId, int userHandle, Bundle args, long timeout) {
    enforceCallingPermission(android.Manifest.permission.GET_TOP_ACTIVITY_INFO, "enqueueAssistContext()");
    synchronized (this) {
        ActivityRecord activity = getFocusedStack().topActivity();
        if (activity == null) {
            Slog.w(TAG, "getAssistContextExtras failed: no top activity");
            return null;
        }
        if (activity.app == null || activity.app.thread == null) {
            Slog.w(TAG, "getAssistContextExtras failed: no process for " + activity);
            return null;
        }
        if (focused) {
            if (activityToken != null) {
                ActivityRecord caller = ActivityRecord.forTokenLocked(activityToken);
                if (activity != caller) {
                    Slog.w(TAG, "enqueueAssistContext failed: caller " + caller + " is not current top " + activity);
                    return null;
                }
            }
        } else {
            activity = ActivityRecord.forTokenLocked(activityToken);
            if (activity == null) {
                Slog.w(TAG, "enqueueAssistContext failed: activity for token=" + activityToken + " couldn't be found");
                return null;
            }
        }
        PendingAssistExtras pae;
        Bundle extras = new Bundle();
        if (args != null) {
            extras.putAll(args);
        }
        extras.putString(Intent.EXTRA_ASSIST_PACKAGE, activity.packageName);
        extras.putInt(Intent.EXTRA_ASSIST_UID, activity.app.uid);
        pae = new PendingAssistExtras(activity, extras, intent, hint, receiver, receiverExtras, userHandle);
        // Increment the sessionId if necessary
        if (newSessionId) {
            mViSessionId++;
        }
        try {
            activity.app.thread.requestAssistContextExtras(activity.appToken, pae, requestType, mViSessionId);
            mPendingAssistExtras.add(pae);
            mUiHandler.postDelayed(pae, timeout);
        } catch (RemoteException e) {
            Slog.w(TAG, "getAssistContextExtras failed: crash calling " + activity);
            return null;
        }
        return pae;
    }
}
#end_block

#method_before
void pendingAssistExtrasTimedOut(PendingAssistExtras pae) {
    IResultReceiver receiver;
    synchronized (this) {
        mPendingAssistExtras.remove(pae);
        receiver = pae.receiver;
    }
    if (receiver != null) {
        // Caller wants result sent back to them.
        try {
            pae.receiver.send(0, null);
        } catch (RemoteException e) {
        }
    }
}
#method_after
void pendingAssistExtrasTimedOut(PendingAssistExtras pae) {
    IResultReceiver receiver;
    synchronized (this) {
        mPendingAssistExtras.remove(pae);
        receiver = pae.receiver;
    }
    if (receiver != null) {
        // Caller wants result sent back to them.
        Bundle sendBundle = new Bundle();
        // At least return the receiver extras
        sendBundle.putBundle(VoiceInteractionSession.KEY_RECEIVER_EXTRAS, pae.receiverExtras);
        try {
            pae.receiver.send(0, sendBundle);
        } catch (RemoteException e) {
        }
    }
}
#end_block

#method_before
public void reportAssistContextExtras(IBinder token, Bundle extras, AssistStructure structure, AssistContent content, Uri referrer) {
    PendingAssistExtras pae = (PendingAssistExtras) token;
    synchronized (pae) {
        pae.result = extras;
        pae.structure = structure;
        pae.content = content;
        if (referrer != null) {
            pae.extras.putParcelable(Intent.EXTRA_REFERRER, referrer);
        }
        pae.haveResult = true;
        pae.notifyAll();
        if (pae.intent == null && pae.receiver == null) {
            // Caller is just waiting for the result.
            return;
        }
    }
    // We are now ready to launch the assist activity.
    IResultReceiver sendReceiver = null;
    Bundle sendBundle = null;
    synchronized (this) {
        buildAssistBundleLocked(pae, extras);
        boolean exists = mPendingAssistExtras.remove(pae);
        mUiHandler.removeCallbacks(pae);
        if (!exists) {
            // Timed out.
            return;
        }
        if ((sendReceiver = pae.receiver) != null) {
            // Caller wants result sent back to them.
            sendBundle = new Bundle();
            sendBundle.putBundle("data", pae.extras);
            sendBundle.putParcelable("structure", pae.structure);
            sendBundle.putParcelable("content", pae.content);
        }
    }
    if (sendReceiver != null) {
        try {
            sendReceiver.send(0, sendBundle);
        } catch (RemoteException e) {
        }
        return;
    }
    long ident = Binder.clearCallingIdentity();
    try {
        pae.intent.replaceExtras(pae.extras);
        pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        closeSystemDialogs("assist");
        try {
            mContext.startActivityAsUser(pae.intent, new UserHandle(pae.userHandle));
        } catch (ActivityNotFoundException e) {
            Slog.w(TAG, "No activity to handle assist action.", e);
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#method_after
public void reportAssistContextExtras(IBinder token, Bundle extras, AssistStructure structure, AssistContent content, Uri referrer) {
    PendingAssistExtras pae = (PendingAssistExtras) token;
    synchronized (pae) {
        pae.result = extras;
        pae.structure = structure;
        pae.content = content;
        if (referrer != null) {
            pae.extras.putParcelable(Intent.EXTRA_REFERRER, referrer);
        }
        pae.haveResult = true;
        pae.notifyAll();
        if (pae.intent == null && pae.receiver == null) {
            // Caller is just waiting for the result.
            return;
        }
    }
    // We are now ready to launch the assist activity.
    IResultReceiver sendReceiver = null;
    Bundle sendBundle = null;
    synchronized (this) {
        buildAssistBundleLocked(pae, extras);
        boolean exists = mPendingAssistExtras.remove(pae);
        mUiHandler.removeCallbacks(pae);
        if (!exists) {
            // Timed out.
            return;
        }
        if ((sendReceiver = pae.receiver) != null) {
            // Caller wants result sent back to them.
            sendBundle = new Bundle();
            sendBundle.putBundle(VoiceInteractionSession.KEY_DATA, pae.extras);
            sendBundle.putParcelable(VoiceInteractionSession.KEY_STRUCTURE, pae.structure);
            sendBundle.putParcelable(VoiceInteractionSession.KEY_CONTENT, pae.content);
            sendBundle.putBundle(VoiceInteractionSession.KEY_RECEIVER_EXTRAS, pae.receiverExtras);
        }
    }
    if (sendReceiver != null) {
        try {
            sendReceiver.send(0, sendBundle);
        } catch (RemoteException e) {
        }
        return;
    }
    long ident = Binder.clearCallingIdentity();
    try {
        pae.intent.replaceExtras(pae.extras);
        pae.intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
        closeSystemDialogs("assist");
        try {
            mContext.startActivityAsUser(pae.intent, new UserHandle(pae.userHandle));
        } catch (ActivityNotFoundException e) {
            Slog.w(TAG, "No activity to handle assist action.", e);
        }
    } finally {
        Binder.restoreCallingIdentity(ident);
    }
}
#end_block

#method_before
public boolean launchAssistIntent(Intent intent, int requestType, String hint, int userHandle, Bundle args) {
    return enqueueAssistContext(requestType, intent, hint, null, null, userHandle, args, PENDING_ASSIST_EXTRAS_TIMEOUT) != null;
}
#method_after
public boolean launchAssistIntent(Intent intent, int requestType, String hint, int userHandle, Bundle args) {
    return enqueueAssistContext(requestType, intent, hint, null, null, null, true, /* focused */
    true, /* newSessionId */
    userHandle, args, PENDING_ASSIST_EXTRAS_TIMEOUT) != null;
}
#end_block

#method_before
public void registerUidObserver(IUidObserver observer) {
    enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER, "registerUidObserver()");
    synchronized (this) {
        mUidObservers.register(observer);
    }
}
#method_after
@Override
public void registerUidObserver(IUidObserver observer, int which) {
    enforceCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER, "registerUidObserver()");
    synchronized (this) {
        mUidObservers.register(observer, which);
    }
}
#end_block

#method_before
@Override
public boolean convertFromTranslucent(IBinder token) {
    final long origId = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            final ActivityRecord r = ActivityRecord.isInStackLocked(token);
            if (r == null) {
                return false;
            }
            final boolean translucentChanged = r.changeWindowTranslucency(true);
            if (translucentChanged) {
                r.task.stack.releaseBackgroundResources(r);
                mStackSupervisor.ensureActivitiesVisibleLocked(null, 0);
            }
            mWindowManager.setAppFullscreen(token, true);
            return translucentChanged;
        }
    } finally {
        Binder.restoreCallingIdentity(origId);
    }
}
#method_after
@Override
public boolean convertFromTranslucent(IBinder token) {
    final long origId = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            final ActivityRecord r = ActivityRecord.isInStackLocked(token);
            if (r == null) {
                return false;
            }
            final boolean translucentChanged = r.changeWindowTranslucency(true);
            if (translucentChanged) {
                r.task.stack.releaseBackgroundResources(r);
                mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
            }
            mWindowManager.setAppFullscreen(token, true);
            return translucentChanged;
        }
    } finally {
        Binder.restoreCallingIdentity(origId);
    }
}
#end_block

#method_before
@Override
public boolean convertToTranslucent(IBinder token, ActivityOptions options) {
    final long origId = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            final ActivityRecord r = ActivityRecord.isInStackLocked(token);
            if (r == null) {
                return false;
            }
            int index = r.task.mActivities.lastIndexOf(r);
            if (index > 0) {
                ActivityRecord under = r.task.mActivities.get(index - 1);
                under.returningOptions = options;
            }
            final boolean translucentChanged = r.changeWindowTranslucency(false);
            if (translucentChanged) {
                r.task.stack.convertActivityToTranslucent(r);
            }
            mStackSupervisor.ensureActivitiesVisibleLocked(null, 0);
            mWindowManager.setAppFullscreen(token, false);
            return translucentChanged;
        }
    } finally {
        Binder.restoreCallingIdentity(origId);
    }
}
#method_after
@Override
public boolean convertToTranslucent(IBinder token, ActivityOptions options) {
    final long origId = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            final ActivityRecord r = ActivityRecord.isInStackLocked(token);
            if (r == null) {
                return false;
            }
            int index = r.task.mActivities.lastIndexOf(r);
            if (index > 0) {
                ActivityRecord under = r.task.mActivities.get(index - 1);
                under.returningOptions = options;
            }
            final boolean translucentChanged = r.changeWindowTranslucency(false);
            if (translucentChanged) {
                r.task.stack.convertActivityToTranslucent(r);
            }
            mStackSupervisor.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS);
            mWindowManager.setAppFullscreen(token, false);
            return translucentChanged;
        }
    } finally {
        Binder.restoreCallingIdentity(origId);
    }
}
#end_block

#method_before
public boolean isTopActivityImmersive() {
    enforceNotIsolatedCaller("startActivity");
    synchronized (this) {
        ActivityRecord r = getFocusedStack().topRunningActivityLocked(null);
        return (r != null) ? r.immersive : false;
    }
}
#method_after
public boolean isTopActivityImmersive() {
    enforceNotIsolatedCaller("startActivity");
    synchronized (this) {
        ActivityRecord r = getFocusedStack().topRunningActivityLocked();
        return (r != null) ? r.immersive : false;
    }
}
#end_block

#method_before
public void noteWakeupAlarm(IIntentSender sender, int sourceUid, String sourcePkg, String tag) {
    if (!(sender instanceof PendingIntentRecord)) {
        return;
    }
    final PendingIntentRecord rec = (PendingIntentRecord) sender;
    final BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    synchronized (stats) {
        if (mBatteryStatsService.isOnBattery()) {
            mBatteryStatsService.enforceCallingPermission();
            int MY_UID = Binder.getCallingUid();
            int uid = rec.uid == MY_UID ? Process.SYSTEM_UID : rec.uid;
            BatteryStatsImpl.Uid.Pkg pkg = stats.getPackageStatsLocked(sourceUid >= 0 ? sourceUid : uid, sourcePkg != null ? sourcePkg : rec.key.packageName);
            pkg.noteWakeupAlarmLocked(tag);
        }
    }
}
#method_after
public void noteWakeupAlarm(IIntentSender sender, int sourceUid, String sourcePkg, String tag) {
    if (sender != null && !(sender instanceof PendingIntentRecord)) {
        return;
    }
    final PendingIntentRecord rec = (PendingIntentRecord) sender;
    final BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    synchronized (stats) {
        if (mBatteryStatsService.isOnBattery()) {
            mBatteryStatsService.enforceCallingPermission();
            int MY_UID = Binder.getCallingUid();
            final int uid;
            if (sender == null) {
                uid = sourceUid;
            } else {
                uid = rec.uid == MY_UID ? Process.SYSTEM_UID : rec.uid;
            }
            BatteryStatsImpl.Uid.Pkg pkg = stats.getPackageStatsLocked(sourceUid >= 0 ? sourceUid : uid, sourcePkg != null ? sourcePkg : rec.key.packageName);
            pkg.noteWakeupAlarmLocked(tag);
        }
    }
}
#end_block

#method_before
public void noteAlarmStart(IIntentSender sender, int sourceUid, String tag) {
    if (!(sender instanceof PendingIntentRecord)) {
        return;
    }
    final PendingIntentRecord rec = (PendingIntentRecord) sender;
    final BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    synchronized (stats) {
        mBatteryStatsService.enforceCallingPermission();
        int MY_UID = Binder.getCallingUid();
        int uid = rec.uid == MY_UID ? Process.SYSTEM_UID : rec.uid;
        mBatteryStatsService.noteAlarmStart(tag, sourceUid >= 0 ? sourceUid : uid);
    }
}
#method_after
public void noteAlarmStart(IIntentSender sender, int sourceUid, String tag) {
    if (sender != null && !(sender instanceof PendingIntentRecord)) {
        return;
    }
    final PendingIntentRecord rec = (PendingIntentRecord) sender;
    final BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    synchronized (stats) {
        mBatteryStatsService.enforceCallingPermission();
        int MY_UID = Binder.getCallingUid();
        final int uid;
        if (sender == null) {
            uid = sourceUid;
        } else {
            uid = rec.uid == MY_UID ? Process.SYSTEM_UID : rec.uid;
        }
        mBatteryStatsService.noteAlarmStart(tag, sourceUid >= 0 ? sourceUid : uid);
    }
}
#end_block

#method_before
public void noteAlarmFinish(IIntentSender sender, int sourceUid, String tag) {
    if (!(sender instanceof PendingIntentRecord)) {
        return;
    }
    final PendingIntentRecord rec = (PendingIntentRecord) sender;
    final BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    synchronized (stats) {
        mBatteryStatsService.enforceCallingPermission();
        int MY_UID = Binder.getCallingUid();
        int uid = rec.uid == MY_UID ? Process.SYSTEM_UID : rec.uid;
        mBatteryStatsService.noteAlarmFinish(tag, sourceUid >= 0 ? sourceUid : uid);
    }
}
#method_after
public void noteAlarmFinish(IIntentSender sender, int sourceUid, String tag) {
    if (sender != null && !(sender instanceof PendingIntentRecord)) {
        return;
    }
    final PendingIntentRecord rec = (PendingIntentRecord) sender;
    final BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
    synchronized (stats) {
        mBatteryStatsService.enforceCallingPermission();
        int MY_UID = Binder.getCallingUid();
        final int uid;
        if (sender == null) {
            uid = sourceUid;
        } else {
            uid = rec.uid == MY_UID ? Process.SYSTEM_UID : rec.uid;
        }
        mBatteryStatsService.noteAlarmFinish(tag, sourceUid >= 0 ? sourceUid : uid);
    }
}
#end_block

#method_before
public boolean killPids(int[] pids, String pReason, boolean secure) {
    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
        throw new SecurityException("killPids only available to the system");
    }
    String reason = (pReason == null) ? "Unknown" : pReason;
    // XXX Note: don't acquire main activity lock here, because the window
    // manager calls in with its locks held.
    boolean killed = false;
    synchronized (mPidsSelfLocked) {
        int[] types = new int[pids.length];
        int worstType = 0;
        for (int i = 0; i < pids.length; i++) {
            ProcessRecord proc = mPidsSelfLocked.get(pids[i]);
            if (proc != null) {
                int type = proc.setAdj;
                types[i] = type;
                if (type > worstType) {
                    worstType = type;
                }
            }
        }
        // then constrain it so we will kill all cached procs.
        if (worstType < ProcessList.CACHED_APP_MAX_ADJ && worstType > ProcessList.CACHED_APP_MIN_ADJ) {
            worstType = ProcessList.CACHED_APP_MIN_ADJ;
        }
        // are important.
        if (!secure && worstType < ProcessList.SERVICE_ADJ) {
            worstType = ProcessList.SERVICE_ADJ;
        }
        Slog.w(TAG, "Killing processes " + reason + " at adjustment " + worstType);
        for (int i = 0; i < pids.length; i++) {
            ProcessRecord proc = mPidsSelfLocked.get(pids[i]);
            if (proc == null) {
                continue;
            }
            int adj = proc.setAdj;
            if (adj >= worstType && !proc.killedByAm) {
                proc.kill(reason, true);
                killed = true;
            }
        }
    }
    return killed;
}
#method_after
public boolean killPids(int[] pids, String pReason, boolean secure) {
    if (Binder.getCallingUid() != Process.SYSTEM_UID) {
        throw new SecurityException("killPids only available to the system");
    }
    String reason = (pReason == null) ? "Unknown" : pReason;
    // XXX Note: don't acquire main activity lock here, because the window
    // manager calls in with its locks held.
    boolean killed = false;
    synchronized (mPidsSelfLocked) {
        int worstType = 0;
        for (int i = 0; i < pids.length; i++) {
            ProcessRecord proc = mPidsSelfLocked.get(pids[i]);
            if (proc != null) {
                int type = proc.setAdj;
                if (type > worstType) {
                    worstType = type;
                }
            }
        }
        // then constrain it so we will kill all cached procs.
        if (worstType < ProcessList.CACHED_APP_MAX_ADJ && worstType > ProcessList.CACHED_APP_MIN_ADJ) {
            worstType = ProcessList.CACHED_APP_MIN_ADJ;
        }
        // are important.
        if (!secure && worstType < ProcessList.SERVICE_ADJ) {
            worstType = ProcessList.SERVICE_ADJ;
        }
        Slog.w(TAG, "Killing processes " + reason + " at adjustment " + worstType);
        for (int i = 0; i < pids.length; i++) {
            ProcessRecord proc = mPidsSelfLocked.get(pids[i]);
            if (proc == null) {
                continue;
            }
            int adj = proc.setAdj;
            if (adj >= worstType && !proc.killedByAm) {
                proc.kill(reason, true);
                killed = true;
            }
        }
    }
    return killed;
}
#end_block

#method_before
@Override
public void performIdleMaintenance() {
    if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException("Requires permission " + android.Manifest.permission.SET_ACTIVITY_WATCHER);
    }
    synchronized (this) {
        final long now = SystemClock.uptimeMillis();
        final long timeSinceLastIdle = now - mLastIdleTime;
        final long lowRamSinceLastIdle = getLowRamTimeSinceIdle(now);
        mLastIdleTime = now;
        mLowRamTimeSinceLastIdle = 0;
        if (mLowRamStartTime != 0) {
            mLowRamStartTime = now;
        }
        StringBuilder sb = new StringBuilder(128);
        sb.append("Idle maintenance over ");
        TimeUtils.formatDuration(timeSinceLastIdle, sb);
        sb.append(" low RAM for ");
        TimeUtils.formatDuration(lowRamSinceLastIdle, sb);
        Slog.i(TAG, sb.toString());
        // If at least 1/3 of our time since the last idle period has been spent
        // with RAM low, then we want to kill processes.
        boolean doKilling = lowRamSinceLastIdle > (timeSinceLastIdle / 3);
        for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord proc = mLruProcesses.get(i);
            if (proc.notCachedSinceIdle) {
                if (proc.setProcState != ActivityManager.PROCESS_STATE_TOP_SLEEPING && proc.setProcState >= ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE && proc.setProcState <= ActivityManager.PROCESS_STATE_SERVICE) {
                    if (doKilling && proc.initialIdlePss != 0 && proc.lastPss > ((proc.initialIdlePss * 3) / 2)) {
                        sb = new StringBuilder(128);
                        sb.append("Kill");
                        sb.append(proc.processName);
                        sb.append(" in idle maint: pss=");
                        sb.append(proc.lastPss);
                        sb.append(", initialPss=");
                        sb.append(proc.initialIdlePss);
                        sb.append(", period=");
                        TimeUtils.formatDuration(timeSinceLastIdle, sb);
                        sb.append(", lowRamPeriod=");
                        TimeUtils.formatDuration(lowRamSinceLastIdle, sb);
                        Slog.wtfQuiet(TAG, sb.toString());
                        proc.kill("idle maint (pss " + proc.lastPss + " from " + proc.initialIdlePss + ")", true);
                    }
                }
            } else if (proc.setProcState < ActivityManager.PROCESS_STATE_HOME) {
                proc.notCachedSinceIdle = true;
                proc.initialIdlePss = 0;
                proc.nextPssTime = ProcessList.computeNextPssTime(proc.curProcState, true, mTestPssMode, isSleeping(), now);
            }
        }
        mHandler.removeMessages(REQUEST_ALL_PSS_MSG);
        mHandler.sendEmptyMessageDelayed(REQUEST_ALL_PSS_MSG, 2 * 60 * 1000);
    }
}
#method_after
@Override
public void performIdleMaintenance() {
    if (checkCallingPermission(android.Manifest.permission.SET_ACTIVITY_WATCHER) != PackageManager.PERMISSION_GRANTED) {
        throw new SecurityException("Requires permission " + android.Manifest.permission.SET_ACTIVITY_WATCHER);
    }
    synchronized (this) {
        final long now = SystemClock.uptimeMillis();
        final long timeSinceLastIdle = now - mLastIdleTime;
        final long lowRamSinceLastIdle = getLowRamTimeSinceIdle(now);
        mLastIdleTime = now;
        mLowRamTimeSinceLastIdle = 0;
        if (mLowRamStartTime != 0) {
            mLowRamStartTime = now;
        }
        StringBuilder sb = new StringBuilder(128);
        sb.append("Idle maintenance over ");
        TimeUtils.formatDuration(timeSinceLastIdle, sb);
        sb.append(" low RAM for ");
        TimeUtils.formatDuration(lowRamSinceLastIdle, sb);
        Slog.i(TAG, sb.toString());
        // If at least 1/3 of our time since the last idle period has been spent
        // with RAM low, then we want to kill processes.
        boolean doKilling = lowRamSinceLastIdle > (timeSinceLastIdle / 3);
        for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord proc = mLruProcesses.get(i);
            if (proc.notCachedSinceIdle) {
                if (proc.setProcState != ActivityManager.PROCESS_STATE_TOP_SLEEPING && proc.setProcState >= ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE && proc.setProcState <= ActivityManager.PROCESS_STATE_SERVICE) {
                    if (doKilling && proc.initialIdlePss != 0 && proc.lastPss > ((proc.initialIdlePss * 3) / 2)) {
                        sb = new StringBuilder(128);
                        sb.append("Kill");
                        sb.append(proc.processName);
                        sb.append(" in idle maint: pss=");
                        sb.append(proc.lastPss);
                        sb.append(", swapPss=");
                        sb.append(proc.lastSwapPss);
                        sb.append(", initialPss=");
                        sb.append(proc.initialIdlePss);
                        sb.append(", period=");
                        TimeUtils.formatDuration(timeSinceLastIdle, sb);
                        sb.append(", lowRamPeriod=");
                        TimeUtils.formatDuration(lowRamSinceLastIdle, sb);
                        Slog.wtfQuiet(TAG, sb.toString());
                        proc.kill("idle maint (pss " + proc.lastPss + " from " + proc.initialIdlePss + ")", true);
                    }
                }
            } else if (proc.setProcState < ActivityManager.PROCESS_STATE_HOME && proc.setProcState > ActivityManager.PROCESS_STATE_NONEXISTENT) {
                proc.notCachedSinceIdle = true;
                proc.initialIdlePss = 0;
                proc.nextPssTime = ProcessList.computeNextPssTime(proc.setProcState, true, mTestPssMode, isSleepingLocked(), now);
            }
        }
        mHandler.removeMessages(REQUEST_ALL_PSS_MSG);
        mHandler.sendEmptyMessageDelayed(REQUEST_ALL_PSS_MSG, 2 * 60 * 1000);
    }
}
#end_block

#method_before
private void retrieveSettings() {
    final ContentResolver resolver = mContext.getContentResolver();
    String debugApp = Settings.Global.getString(resolver, Settings.Global.DEBUG_APP);
    boolean waitForDebugger = Settings.Global.getInt(resolver, Settings.Global.WAIT_FOR_DEBUGGER, 0) != 0;
    boolean alwaysFinishActivities = Settings.Global.getInt(resolver, Settings.Global.ALWAYS_FINISH_ACTIVITIES, 0) != 0;
    boolean forceRtl = Settings.Global.getInt(resolver, Settings.Global.DEVELOPMENT_FORCE_RTL, 0) != 0;
    // Transfer any global setting for forcing RTL layout, into a System Property
    SystemProperties.set(Settings.Global.DEVELOPMENT_FORCE_RTL, forceRtl ? "1" : "0");
    Configuration configuration = new Configuration();
    Settings.System.getConfiguration(resolver, configuration);
    if (forceRtl) {
        // This will take care of setting the correct layout direction flags
        configuration.setLayoutDirection(configuration.locale);
    }
    synchronized (this) {
        mDebugApp = mOrigDebugApp = debugApp;
        mWaitForDebugger = mOrigWaitForDebugger = waitForDebugger;
        mAlwaysFinishActivities = alwaysFinishActivities;
        // This happens before any activities are started, so we can
        // change mConfiguration in-place.
        updateConfigurationLocked(configuration, null, false, true);
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Initial config: " + mConfiguration);
    }
}
#method_after
private void retrieveSettings() {
    final ContentResolver resolver = mContext.getContentResolver();
    final boolean freeformWindowManagement = mContext.getPackageManager().hasSystemFeature(FEATURE_FREEFORM_WINDOW_MANAGEMENT) || Settings.Global.getInt(resolver, DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT, 0) != 0;
    final boolean supportsPictureInPicture = mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE);
    final boolean supportsMultiWindow = ActivityManager.supportsMultiWindow();
    final String debugApp = Settings.Global.getString(resolver, DEBUG_APP);
    final boolean waitForDebugger = Settings.Global.getInt(resolver, WAIT_FOR_DEBUGGER, 0) != 0;
    final boolean alwaysFinishActivities = Settings.Global.getInt(resolver, ALWAYS_FINISH_ACTIVITIES, 0) != 0;
    final boolean lenientBackgroundCheck = Settings.Global.getInt(resolver, LENIENT_BACKGROUND_CHECK, 0) != 0;
    final boolean forceRtl = Settings.Global.getInt(resolver, DEVELOPMENT_FORCE_RTL, 0) != 0;
    final boolean forceResizable = Settings.Global.getInt(resolver, DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, 0) != 0;
    final boolean supportsLeanbackOnly = mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK_ONLY);
    // Transfer any global setting for forcing RTL layout, into a System Property
    SystemProperties.set(DEVELOPMENT_FORCE_RTL, forceRtl ? "1" : "0");
    final Configuration configuration = new Configuration();
    Settings.System.getConfiguration(resolver, configuration);
    if (forceRtl) {
        // This will take care of setting the correct layout direction flags
        configuration.setLayoutDirection(configuration.locale);
    }
    synchronized (this) {
        mDebugApp = mOrigDebugApp = debugApp;
        mWaitForDebugger = mOrigWaitForDebugger = waitForDebugger;
        mAlwaysFinishActivities = alwaysFinishActivities;
        mLenientBackgroundCheck = lenientBackgroundCheck;
        mSupportsLeanbackOnly = supportsLeanbackOnly;
        mForceResizableActivities = forceResizable;
        mWindowManager.setForceResizableTasks(mForceResizableActivities);
        if (supportsMultiWindow || forceResizable) {
            mSupportsMultiWindow = true;
            mSupportsFreeformWindowManagement = freeformWindowManagement || forceResizable;
            mSupportsPictureInPicture = supportsPictureInPicture || forceResizable;
        } else {
            mSupportsMultiWindow = false;
            mSupportsFreeformWindowManagement = false;
            mSupportsPictureInPicture = false;
        }
        // This happens before any activities are started, so we can
        // change mConfiguration in-place.
        updateConfigurationLocked(configuration, null, true);
        if (DEBUG_CONFIGURATION)
            Slog.v(TAG_CONFIGURATION, "Initial config: " + mConfiguration);
        // Load resources only after the current configuration has been set.
        final Resources res = mContext.getResources();
        mHasRecents = res.getBoolean(com.android.internal.R.bool.config_hasRecents);
        mThumbnailWidth = res.getDimensionPixelSize(com.android.internal.R.dimen.thumbnail_width);
        mThumbnailHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.thumbnail_height);
        mDefaultPinnedStackBounds = Rect.unflattenFromString(res.getString(com.android.internal.R.string.config_defaultPictureInPictureBounds));
        mAppErrors.loadAppsNotReportingCrashesFromConfigLocked(res.getString(com.android.internal.R.string.config_appsNotReportingCrashes));
        if ((mConfiguration.uiMode & UI_MODE_TYPE_TELEVISION) == UI_MODE_TYPE_TELEVISION) {
            mFullscreenThumbnailScale = (float) res.getInteger(com.android.internal.R.integer.thumbnail_width_tv) / (float) mConfiguration.screenWidthDp;
        } else {
            mFullscreenThumbnailScale = res.getFraction(com.android.internal.R.fraction.thumbnail_fullscreen_scale, 1, 1);
        }
    }
}
#end_block

#method_before
public void systemReady(final Runnable goingCallback) {
    synchronized (this) {
        if (mSystemReady) {
            // by the SystemServer
            if (goingCallback != null) {
                goingCallback.run();
            }
            return;
        }
        mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class);
        // Make sure we have the current profile info, since it is needed for
        // security checks.
        updateCurrentProfileIdsLocked();
        mRecentTasks.clear();
        mRecentTasks.addAll(mTaskPersister.restoreTasksLocked());
        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
        mTaskPersister.startPersisting();
        // Check to see if there are any update receivers to run.
        if (!mDidUpdate) {
            if (mWaitingUpdate) {
                return;
            }
            final ArrayList<ComponentName> doneReceivers = new ArrayList<ComponentName>();
            mWaitingUpdate = deliverPreBootCompleted(new Runnable() {

                public void run() {
                    synchronized (ActivityManagerService.this) {
                        mDidUpdate = true;
                    }
                    showBootMessage(mContext.getText(R.string.android_upgrading_complete), false);
                    writeLastDonePreBootReceivers(doneReceivers);
                    systemReady(goingCallback);
                }
            }, doneReceivers, UserHandle.USER_OWNER);
            if (mWaitingUpdate) {
                return;
            }
            mDidUpdate = true;
        }
        mAppOpsService.systemReady();
        mSystemReady = true;
    }
    ArrayList<ProcessRecord> procsToKill = null;
    synchronized (mPidsSelfLocked) {
        for (int i = mPidsSelfLocked.size() - 1; i >= 0; i--) {
            ProcessRecord proc = mPidsSelfLocked.valueAt(i);
            if (!isAllowedWhileBooting(proc.info)) {
                if (procsToKill == null) {
                    procsToKill = new ArrayList<ProcessRecord>();
                }
                procsToKill.add(proc);
            }
        }
    }
    synchronized (this) {
        if (procsToKill != null) {
            for (int i = procsToKill.size() - 1; i >= 0; i--) {
                ProcessRecord proc = procsToKill.get(i);
                Slog.i(TAG, "Removing system update proc: " + proc);
                removeProcessLocked(proc, true, false, "system update done");
            }
        }
        // Now that we have cleaned up any update processes, we
        // are ready to start launching real processes and know that
        // we won't trample on them any more.
        mProcessesReady = true;
    }
    Slog.i(TAG, "System now ready");
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY, SystemClock.uptimeMillis());
    synchronized (this) {
        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            ResolveInfo ri = mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST), STOCK_PM_FLAGS);
            CharSequence errorMsg = null;
            if (ri != null) {
                ActivityInfo ai = ri.activityInfo;
                ApplicationInfo app = ai.applicationInfo;
                if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
                    mTopAction = Intent.ACTION_FACTORY_TEST;
                    mTopData = null;
                    mTopComponent = new ComponentName(app.packageName, ai.name);
                } else {
                    errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
                }
            } else {
                errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
            }
            if (errorMsg != null) {
                mTopAction = null;
                mTopData = null;
                mTopComponent = null;
                Message msg = Message.obtain();
                msg.what = SHOW_FACTORY_ERROR_MSG;
                msg.getData().putCharSequence("msg", errorMsg);
                mUiHandler.sendMessage(msg);
            }
        }
    }
    retrieveSettings();
    loadResourcesOnSystemReady();
    synchronized (this) {
        readGrantedUriPermissionsLocked();
    }
    if (goingCallback != null)
        goingCallback.run();
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(mCurrentUserId), mCurrentUserId);
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(mCurrentUserId), mCurrentUserId);
    mSystemServiceManager.startUser(mCurrentUserId);
    synchronized (this) {
        if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            try {
                List apps = AppGlobals.getPackageManager().getPersistentApplications(STOCK_PM_FLAGS);
                if (apps != null) {
                    int N = apps.size();
                    int i;
                    for (i = 0; i < N; i++) {
                        ApplicationInfo info = (ApplicationInfo) apps.get(i);
                        if (info != null && !info.packageName.equals("android")) {
                            addAppLocked(info, false, null);
                        }
                    }
                }
            } catch (RemoteException ex) {
            // pm is in same process, this will never happen.
            }
        }
        // Start up initial activity.
        mBooting = true;
        startHomeActivityLocked(mCurrentUserId, "systemReady");
        try {
            if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
                Slog.e(TAG, "UIDs on the system are inconsistent, you need to wipe your" + " data partition or your device will be unstable.");
                mUiHandler.obtainMessage(SHOW_UID_ERROR_MSG).sendToTarget();
            }
        } catch (RemoteException e) {
        }
        if (!Build.isBuildConsistent()) {
            Slog.e(TAG, "Build fingerprint is not consistent, warning user");
            mUiHandler.obtainMessage(SHOW_FINGERPRINT_ERROR_MSG).sendToTarget();
        }
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent(Intent.ACTION_USER_STARTED);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);
            broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, mCurrentUserId);
            intent = new Intent(Intent.ACTION_USER_STARTING);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, mCurrentUserId);
            broadcastIntentLocked(null, null, intent, null, new IIntentReceiver.Stub() {

                @Override
                public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                }
            }, 0, null, null, new String[] { INTERACT_ACROSS_USERS }, AppOpsManager.OP_NONE, null, true, false, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);
        } catch (Throwable t) {
            Slog.wtf(TAG, "Failed sending first user broadcasts", t);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        mStackSupervisor.resumeTopActivitiesLocked();
        sendUserSwitchBroadcastsLocked(-1, mCurrentUserId);
    }
}
#method_after
public void systemReady(final Runnable goingCallback) {
    synchronized (this) {
        if (mSystemReady) {
            // by the SystemServer
            if (goingCallback != null) {
                goingCallback.run();
            }
            return;
        }
        mLocalDeviceIdleController = LocalServices.getService(DeviceIdleController.LocalService.class);
        // Make sure we have the current profile info, since it is needed for security checks.
        mUserController.onSystemReady();
        mRecentTasks.onSystemReadyLocked();
        mAppOpsService.systemReady();
        mSystemReady = true;
    }
    ArrayList<ProcessRecord> procsToKill = null;
    synchronized (mPidsSelfLocked) {
        for (int i = mPidsSelfLocked.size() - 1; i >= 0; i--) {
            ProcessRecord proc = mPidsSelfLocked.valueAt(i);
            if (!isAllowedWhileBooting(proc.info)) {
                if (procsToKill == null) {
                    procsToKill = new ArrayList<ProcessRecord>();
                }
                procsToKill.add(proc);
            }
        }
    }
    synchronized (this) {
        if (procsToKill != null) {
            for (int i = procsToKill.size() - 1; i >= 0; i--) {
                ProcessRecord proc = procsToKill.get(i);
                Slog.i(TAG, "Removing system update proc: " + proc);
                removeProcessLocked(proc, true, false, "system update done");
            }
        }
        // Now that we have cleaned up any update processes, we
        // are ready to start launching real processes and know that
        // we won't trample on them any more.
        mProcessesReady = true;
    }
    Slog.i(TAG, "System now ready");
    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY, SystemClock.uptimeMillis());
    synchronized (this) {
        if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) {
            ResolveInfo ri = mContext.getPackageManager().resolveActivity(new Intent(Intent.ACTION_FACTORY_TEST), STOCK_PM_FLAGS);
            CharSequence errorMsg = null;
            if (ri != null) {
                ActivityInfo ai = ri.activityInfo;
                ApplicationInfo app = ai.applicationInfo;
                if ((app.flags & ApplicationInfo.FLAG_SYSTEM) != 0) {
                    mTopAction = Intent.ACTION_FACTORY_TEST;
                    mTopData = null;
                    mTopComponent = new ComponentName(app.packageName, ai.name);
                } else {
                    errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_not_system);
                }
            } else {
                errorMsg = mContext.getResources().getText(com.android.internal.R.string.factorytest_no_action);
            }
            if (errorMsg != null) {
                mTopAction = null;
                mTopData = null;
                mTopComponent = null;
                Message msg = Message.obtain();
                msg.what = SHOW_FACTORY_ERROR_UI_MSG;
                msg.getData().putCharSequence("msg", errorMsg);
                mUiHandler.sendMessage(msg);
            }
        }
    }
    retrieveSettings();
    final int currentUserId;
    synchronized (this) {
        currentUserId = mUserController.getCurrentUserIdLocked();
        readGrantedUriPermissionsLocked();
    }
    if (goingCallback != null)
        goingCallback.run();
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(currentUserId), currentUserId);
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(currentUserId), currentUserId);
    mSystemServiceManager.startUser(currentUserId);
    synchronized (this) {
        // Only start up encryption-aware persistent apps; once user is
        // unlocked we'll come back around and start unaware apps
        startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);
        // Start up initial activity.
        mBooting = true;
        // Enable home activity for system user, so that the system can always boot
        if (UserManager.isSplitSystemUser()) {
            ComponentName cName = new ComponentName(mContext, SystemUserHomeActivity.class);
            try {
                AppGlobals.getPackageManager().setComponentEnabledSetting(cName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0, UserHandle.USER_SYSTEM);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
        }
        startHomeActivityLocked(currentUserId, "systemReady");
        try {
            if (AppGlobals.getPackageManager().hasSystemUidErrors()) {
                Slog.e(TAG, "UIDs on the system are inconsistent, you need to wipe your" + " data partition or your device will be unstable.");
                mUiHandler.obtainMessage(SHOW_UID_ERROR_UI_MSG).sendToTarget();
            }
        } catch (RemoteException e) {
        }
        if (!Build.isBuildConsistent()) {
            Slog.e(TAG, "Build fingerprint is not consistent, warning user");
            mUiHandler.obtainMessage(SHOW_FINGERPRINT_ERROR_UI_MSG).sendToTarget();
        }
        long ident = Binder.clearCallingIdentity();
        try {
            Intent intent = new Intent(Intent.ACTION_USER_STARTED);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);
            broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, currentUserId);
            intent = new Intent(Intent.ACTION_USER_STARTING);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
            intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);
            broadcastIntentLocked(null, null, intent, null, new IIntentReceiver.Stub() {

                @Override
                public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException {
                }
            }, 0, null, null, new String[] { INTERACT_ACROSS_USERS }, AppOpsManager.OP_NONE, null, true, false, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);
        } catch (Throwable t) {
            Slog.wtf(TAG, "Failed sending first user broadcasts", t);
        } finally {
            Binder.restoreCallingIdentity(ident);
        }
        mStackSupervisor.resumeFocusedStackTopActivityLocked();
        mUserController.sendUserSwitchBroadcastsLocked(-1, currentUserId);
    }
}
#end_block

#method_before
void killAppAtUsersRequest(ProcessRecord app, Dialog fromDialog) {
    synchronized (this) {
        app.crashing = false;
        app.crashingReport = null;
        app.notResponding = false;
        app.notRespondingReport = null;
        if (app.anrDialog == fromDialog) {
            app.anrDialog = null;
        }
        if (app.waitDialog == fromDialog) {
            app.waitDialog = null;
        }
        if (app.pid > 0 && app.pid != MY_PID) {
            handleAppCrashLocked(app, "user-terminated", /*reason*/
            null, /*shortMsg*/
            null, /*longMsg*/
            null);
            app.kill("user request after error", true);
        }
    }
}
#method_after
void killAppAtUsersRequest(ProcessRecord app, Dialog fromDialog) {
    synchronized (this) {
        mAppErrors.killAppAtUserRequestLocked(app, fromDialog);
    }
}
#end_block

#method_before
void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, ApplicationErrorReport.CrashInfo crashInfo) {
    EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(), UserHandle.getUserId(Binder.getCallingUid()), processName, r == null ? -1 : r.info.flags, crashInfo.exceptionClassName, crashInfo.exceptionMessage, crashInfo.throwFileName, crashInfo.throwLineNumber);
    addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo);
    crashApplication(r, crashInfo);
}
#method_after
void handleApplicationCrashInner(String eventType, ProcessRecord r, String processName, ApplicationErrorReport.CrashInfo crashInfo) {
    EventLog.writeEvent(EventLogTags.AM_CRASH, Binder.getCallingPid(), UserHandle.getUserId(Binder.getCallingUid()), processName, r == null ? -1 : r.info.flags, crashInfo.exceptionClassName, crashInfo.exceptionMessage, crashInfo.throwFileName, crashInfo.throwLineNumber);
    addErrorToDropBox(eventType, r, processName, null, null, null, null, null, crashInfo);
    mAppErrors.crashApplication(r, crashInfo);
}
#end_block

#method_before
public void handleApplicationStrictModeViolation(IBinder app, int violationMask, StrictMode.ViolationInfo info) {
    ProcessRecord r = findAppProcess(app, "StrictMode");
    if (r == null) {
        return;
    }
    if ((violationMask & StrictMode.PENALTY_DROPBOX) != 0) {
        Integer stackFingerprint = info.hashCode();
        boolean logIt = true;
        synchronized (mAlreadyLoggedViolatedStacks) {
            if (mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
                logIt = false;
            // TODO: sub-sample into EventLog for these, with
            // the info.durationMillis?  Then we'd get
            // the relative pain numbers, without logging all
            // the stack traces repeatedly.  We'd want to do
            // likewise in the client code, which also does
            // dup suppression, before the Binder call.
            } else {
                if (mAlreadyLoggedViolatedStacks.size() >= MAX_DUP_SUPPRESSED_STACKS) {
                    mAlreadyLoggedViolatedStacks.clear();
                }
                mAlreadyLoggedViolatedStacks.add(stackFingerprint);
            }
        }
        if (logIt) {
            logStrictModeViolationToDropBox(r, info);
        }
    }
    if ((violationMask & StrictMode.PENALTY_DIALOG) != 0) {
        AppErrorResult result = new AppErrorResult();
        synchronized (this) {
            final long origId = Binder.clearCallingIdentity();
            Message msg = Message.obtain();
            msg.what = SHOW_STRICT_MODE_VIOLATION_MSG;
            HashMap<String, Object> data = new HashMap<String, Object>();
            data.put("result", result);
            data.put("app", r);
            data.put("violationMask", violationMask);
            data.put("info", info);
            msg.obj = data;
            mUiHandler.sendMessage(msg);
            Binder.restoreCallingIdentity(origId);
        }
        int res = result.get();
        Slog.w(TAG, "handleApplicationStrictModeViolation; res=" + res);
    }
}
#method_after
public void handleApplicationStrictModeViolation(IBinder app, int violationMask, StrictMode.ViolationInfo info) {
    ProcessRecord r = findAppProcess(app, "StrictMode");
    if (r == null) {
        return;
    }
    if ((violationMask & StrictMode.PENALTY_DROPBOX) != 0) {
        Integer stackFingerprint = info.hashCode();
        boolean logIt = true;
        synchronized (mAlreadyLoggedViolatedStacks) {
            if (mAlreadyLoggedViolatedStacks.contains(stackFingerprint)) {
                logIt = false;
            // TODO: sub-sample into EventLog for these, with
            // the info.durationMillis?  Then we'd get
            // the relative pain numbers, without logging all
            // the stack traces repeatedly.  We'd want to do
            // likewise in the client code, which also does
            // dup suppression, before the Binder call.
            } else {
                if (mAlreadyLoggedViolatedStacks.size() >= MAX_DUP_SUPPRESSED_STACKS) {
                    mAlreadyLoggedViolatedStacks.clear();
                }
                mAlreadyLoggedViolatedStacks.add(stackFingerprint);
            }
        }
        if (logIt) {
            logStrictModeViolationToDropBox(r, info);
        }
    }
    if ((violationMask & StrictMode.PENALTY_DIALOG) != 0) {
        AppErrorResult result = new AppErrorResult();
        synchronized (this) {
            final long origId = Binder.clearCallingIdentity();
            Message msg = Message.obtain();
            msg.what = SHOW_STRICT_MODE_VIOLATION_UI_MSG;
            HashMap<String, Object> data = new HashMap<String, Object>();
            data.put("result", result);
            data.put("app", r);
            data.put("violationMask", violationMask);
            data.put("info", info);
            msg.obj = data;
            mUiHandler.sendMessage(msg);
            Binder.restoreCallingIdentity(origId);
        }
        int res = result.get();
        Slog.w(TAG, "handleApplicationStrictModeViolation; res=" + res);
    }
}
#end_block

#method_before
public boolean handleApplicationWtf(final IBinder app, final String tag, boolean system, final ApplicationErrorReport.CrashInfo crashInfo) {
    final int callingUid = Binder.getCallingUid();
    final int callingPid = Binder.getCallingPid();
    if (system) {
        // If this is coming from the system, we could very well have low-level
        // system locks held, so we want to do this all asynchronously.  And we
        // never want this to become fatal, so there is that too.
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                handleApplicationWtfInner(callingUid, callingPid, app, tag, crashInfo);
            }
        });
        return false;
    }
    final ProcessRecord r = handleApplicationWtfInner(callingUid, callingPid, app, tag, crashInfo);
    if (r != null && r.pid != Process.myPid() && Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.WTF_IS_FATAL, 0) != 0) {
        crashApplication(r, crashInfo);
        return true;
    } else {
        return false;
    }
}
#method_after
public boolean handleApplicationWtf(final IBinder app, final String tag, boolean system, final ApplicationErrorReport.CrashInfo crashInfo) {
    final int callingUid = Binder.getCallingUid();
    final int callingPid = Binder.getCallingPid();
    if (system) {
        // If this is coming from the system, we could very well have low-level
        // system locks held, so we want to do this all asynchronously.  And we
        // never want this to become fatal, so there is that too.
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                handleApplicationWtfInner(callingUid, callingPid, app, tag, crashInfo);
            }
        });
        return false;
    }
    final ProcessRecord r = handleApplicationWtfInner(callingUid, callingPid, app, tag, crashInfo);
    if (r != null && r.pid != Process.myPid() && Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.WTF_IS_FATAL, 0) != 0) {
        mAppErrors.crashApplication(r, crashInfo);
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
public void addErrorToDropBox(String eventType, ProcessRecord process, String processName, ActivityRecord activity, ActivityRecord parent, String subject, final String report, final File logFile, final ApplicationErrorReport.CrashInfo crashInfo) {
    // NOTE -- this must never acquire the ActivityManagerService lock,
    // otherwise the watchdog may be prevented from resetting the system.
    final String dropboxTag = processClass(process) + "_" + eventType;
    final DropBoxManager dbox = (DropBoxManager) mContext.getSystemService(Context.DROPBOX_SERVICE);
    // Exit early if the dropbox isn't configured to accept this report type.
    if (dbox == null || !dbox.isTagEnabled(dropboxTag))
        return;
    final StringBuilder sb = new StringBuilder(1024);
    appendDropBoxProcessHeaders(process, processName, sb);
    if (activity != null) {
        sb.append("Activity: ").append(activity.shortComponentName).append("\n");
    }
    if (parent != null && parent.app != null && parent.app.pid != process.pid) {
        sb.append("Parent-Process: ").append(parent.app.processName).append("\n");
    }
    if (parent != null && parent != activity) {
        sb.append("Parent-Activity: ").append(parent.shortComponentName).append("\n");
    }
    if (subject != null) {
        sb.append("Subject: ").append(subject).append("\n");
    }
    sb.append("Build: ").append(Build.FINGERPRINT).append("\n");
    if (Debug.isDebuggerConnected()) {
        sb.append("Debugger: Connected\n");
    }
    sb.append("\n");
    // Do the rest in a worker thread to avoid blocking the caller on I/O
    // (After this point, we shouldn't access AMS internal data structures.)
    Thread worker = new Thread("Error dump: " + dropboxTag) {

        @Override
        public void run() {
            if (report != null) {
                sb.append(report);
            }
            if (logFile != null) {
                try {
                    sb.append(FileUtils.readTextFile(logFile, DROPBOX_MAX_SIZE, "\n\n[[TRUNCATED]]"));
                } catch (IOException e) {
                    Slog.e(TAG, "Error reading " + logFile, e);
                }
            }
            if (crashInfo != null && crashInfo.stackTrace != null) {
                sb.append(crashInfo.stackTrace);
            }
            String setting = Settings.Global.ERROR_LOGCAT_PREFIX + dropboxTag;
            int lines = Settings.Global.getInt(mContext.getContentResolver(), setting, 0);
            if (lines > 0) {
                sb.append("\n");
                // Merge several logcat streams, and take the last N lines
                InputStreamReader input = null;
                try {
                    java.lang.Process logcat = new ProcessBuilder("/system/bin/logcat", "-v", "time", "-b", "events", "-b", "system", "-b", "main", "-b", "crash", "-t", String.valueOf(lines)).redirectErrorStream(true).start();
                    try {
                        logcat.getOutputStream().close();
                    } catch (IOException e) {
                    }
                    try {
                        logcat.getErrorStream().close();
                    } catch (IOException e) {
                    }
                    input = new InputStreamReader(logcat.getInputStream());
                    int num;
                    char[] buf = new char[8192];
                    while ((num = input.read(buf)) > 0) sb.append(buf, 0, num);
                } catch (IOException e) {
                    Slog.e(TAG, "Error running logcat", e);
                } finally {
                    if (input != null)
                        try {
                            input.close();
                        } catch (IOException e) {
                        }
                }
            }
            dbox.addText(dropboxTag, sb.toString());
        }
    };
    if (process == null) {
        // If process is null, we are being called from some internal code
        // and may be about to die -- run this synchronously.
        worker.run();
    } else {
        worker.start();
    }
}
#method_after
public void addErrorToDropBox(String eventType, ProcessRecord process, String processName, ActivityRecord activity, ActivityRecord parent, String subject, final String report, final File dataFile, final ApplicationErrorReport.CrashInfo crashInfo) {
    // NOTE -- this must never acquire the ActivityManagerService lock,
    // otherwise the watchdog may be prevented from resetting the system.
    final String dropboxTag = processClass(process) + "_" + eventType;
    final DropBoxManager dbox = (DropBoxManager) mContext.getSystemService(Context.DROPBOX_SERVICE);
    // Exit early if the dropbox isn't configured to accept this report type.
    if (dbox == null || !dbox.isTagEnabled(dropboxTag))
        return;
    // Rate-limit how often we're willing to do the heavy lifting below to
    // collect and record logs; currently 5 logs per 10 second period.
    final long now = SystemClock.elapsedRealtime();
    if (now - mWtfClusterStart > 10 * DateUtils.SECOND_IN_MILLIS) {
        mWtfClusterStart = now;
        mWtfClusterCount = 1;
    } else {
        if (mWtfClusterCount++ >= 5)
            return;
    }
    final StringBuilder sb = new StringBuilder(1024);
    appendDropBoxProcessHeaders(process, processName, sb);
    if (process != null) {
        sb.append("Foreground: ").append(process.isInterestingToUserLocked() ? "Yes" : "No").append("\n");
    }
    if (activity != null) {
        sb.append("Activity: ").append(activity.shortComponentName).append("\n");
    }
    if (parent != null && parent.app != null && parent.app.pid != process.pid) {
        sb.append("Parent-Process: ").append(parent.app.processName).append("\n");
    }
    if (parent != null && parent != activity) {
        sb.append("Parent-Activity: ").append(parent.shortComponentName).append("\n");
    }
    if (subject != null) {
        sb.append("Subject: ").append(subject).append("\n");
    }
    sb.append("Build: ").append(Build.FINGERPRINT).append("\n");
    if (Debug.isDebuggerConnected()) {
        sb.append("Debugger: Connected\n");
    }
    sb.append("\n");
    // Do the rest in a worker thread to avoid blocking the caller on I/O
    // (After this point, we shouldn't access AMS internal data structures.)
    Thread worker = new Thread("Error dump: " + dropboxTag) {

        @Override
        public void run() {
            if (report != null) {
                sb.append(report);
            }
            String setting = Settings.Global.ERROR_LOGCAT_PREFIX + dropboxTag;
            int lines = Settings.Global.getInt(mContext.getContentResolver(), setting, 0);
            int maxDataFileSize = DROPBOX_MAX_SIZE - sb.length() - lines * RESERVED_BYTES_PER_LOGCAT_LINE;
            if (dataFile != null && maxDataFileSize > 0) {
                try {
                    sb.append(FileUtils.readTextFile(dataFile, maxDataFileSize, "\n\n[[TRUNCATED]]"));
                } catch (IOException e) {
                    Slog.e(TAG, "Error reading " + dataFile, e);
                }
            }
            if (crashInfo != null && crashInfo.stackTrace != null) {
                sb.append(crashInfo.stackTrace);
            }
            if (lines > 0) {
                sb.append("\n");
                // Merge several logcat streams, and take the last N lines
                InputStreamReader input = null;
                try {
                    java.lang.Process logcat = new ProcessBuilder("/system/bin/timeout", "-k", "15s", "10s", "/system/bin/logcat", "-v", "time", "-b", "events", "-b", "system", "-b", "main", "-b", "crash", "-t", String.valueOf(lines)).redirectErrorStream(true).start();
                    try {
                        logcat.getOutputStream().close();
                    } catch (IOException e) {
                    }
                    try {
                        logcat.getErrorStream().close();
                    } catch (IOException e) {
                    }
                    input = new InputStreamReader(logcat.getInputStream());
                    int num;
                    char[] buf = new char[8192];
                    while ((num = input.read(buf)) > 0) sb.append(buf, 0, num);
                } catch (IOException e) {
                    Slog.e(TAG, "Error running logcat", e);
                } finally {
                    if (input != null)
                        try {
                            input.close();
                        } catch (IOException e) {
                        }
                }
            }
            dbox.addText(dropboxTag, sb.toString());
        }
    };
    if (process == null) {
        // If process is null, we are being called from some internal code
        // and may be about to die -- run this synchronously.
        worker.run();
    } else {
        worker.start();
    }
}
#end_block

#method_before
public List<ActivityManager.ProcessErrorStateInfo> getProcessesInErrorState() {
    enforceNotIsolatedCaller("getProcessesInErrorState");
    // assume our apps are happy - lazy create the list
    List<ActivityManager.ProcessErrorStateInfo> errList = null;
    final boolean allUsers = ActivityManager.checkUidPermission(INTERACT_ACROSS_USERS_FULL, Binder.getCallingUid()) == PackageManager.PERMISSION_GRANTED;
    int userId = UserHandle.getUserId(Binder.getCallingUid());
    synchronized (this) {
        // iterate across all processes
        for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = mLruProcesses.get(i);
            if (!allUsers && app.userId != userId) {
                continue;
            }
            if ((app.thread != null) && (app.crashing || app.notResponding)) {
                // This one's in trouble, so we'll generate a report for it
                // crashes are higher priority (in case there's a crash *and* an anr)
                ActivityManager.ProcessErrorStateInfo report = null;
                if (app.crashing) {
                    report = app.crashingReport;
                } else if (app.notResponding) {
                    report = app.notRespondingReport;
                }
                if (report != null) {
                    if (errList == null) {
                        errList = new ArrayList<ActivityManager.ProcessErrorStateInfo>(1);
                    }
                    errList.add(report);
                } else {
                    Slog.w(TAG, "Missing app error report, app = " + app.processName + " crashing = " + app.crashing + " notResponding = " + app.notResponding);
                }
            }
        }
    }
    return errList;
}
#method_after
@Override
public List<ActivityManager.ProcessErrorStateInfo> getProcessesInErrorState() {
    enforceNotIsolatedCaller("getProcessesInErrorState");
    // assume our apps are happy - lazy create the list
    List<ActivityManager.ProcessErrorStateInfo> errList = null;
    final boolean allUsers = ActivityManager.checkUidPermission(INTERACT_ACROSS_USERS_FULL, Binder.getCallingUid()) == PackageManager.PERMISSION_GRANTED;
    int userId = UserHandle.getUserId(Binder.getCallingUid());
    synchronized (this) {
        // iterate across all processes
        for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = mLruProcesses.get(i);
            if (!allUsers && app.userId != userId) {
                continue;
            }
            if ((app.thread != null) && (app.crashing || app.notResponding)) {
                // This one's in trouble, so we'll generate a report for it
                // crashes are higher priority (in case there's a crash *and* an anr)
                ActivityManager.ProcessErrorStateInfo report = null;
                if (app.crashing) {
                    report = app.crashingReport;
                } else if (app.notResponding) {
                    report = app.notRespondingReport;
                }
                if (report != null) {
                    if (errList == null) {
                        errList = new ArrayList<ActivityManager.ProcessErrorStateInfo>(1);
                    }
                    errList.add(report);
                } else {
                    Slog.w(TAG, "Missing app error report, app = " + app.processName + " crashing = " + app.crashing + " notResponding = " + app.notResponding);
                }
            }
        }
    }
    return errList;
}
#end_block

#method_before
public List<ActivityManager.RunningAppProcessInfo> getRunningAppProcesses() {
    enforceNotIsolatedCaller("getRunningAppProcesses");
    final int callingUid = Binder.getCallingUid();
    // Lazy instantiation of list
    List<ActivityManager.RunningAppProcessInfo> runList = null;
    final boolean allUsers = ActivityManager.checkUidPermission(INTERACT_ACROSS_USERS_FULL, callingUid) == PackageManager.PERMISSION_GRANTED;
    final int userId = UserHandle.getUserId(callingUid);
    final boolean allUids = isGetTasksAllowed("getRunningAppProcesses", Binder.getCallingPid(), callingUid);
    synchronized (this) {
        // Iterate across all processes
        for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = mLruProcesses.get(i);
            if ((!allUsers && app.userId != userId) || (!allUids && app.uid != callingUid)) {
                continue;
            }
            if ((app.thread != null) && (!app.crashing && !app.notResponding)) {
                // Generate process state info for running application
                ActivityManager.RunningAppProcessInfo currApp = new ActivityManager.RunningAppProcessInfo(app.processName, app.pid, app.getPackageList());
                fillInProcMemInfo(app, currApp);
                if (app.adjSource instanceof ProcessRecord) {
                    currApp.importanceReasonPid = ((ProcessRecord) app.adjSource).pid;
                    currApp.importanceReasonImportance = ActivityManager.RunningAppProcessInfo.procStateToImportance(app.adjSourceProcState);
                } else if (app.adjSource instanceof ActivityRecord) {
                    ActivityRecord r = (ActivityRecord) app.adjSource;
                    if (r.app != null)
                        currApp.importanceReasonPid = r.app.pid;
                }
                if (app.adjTarget instanceof ComponentName) {
                    currApp.importanceReasonComponent = (ComponentName) app.adjTarget;
                }
                // + " lru=" + currApp.lru);
                if (runList == null) {
                    runList = new ArrayList<>();
                }
                runList.add(currApp);
            }
        }
    }
    return runList;
}
#method_after
@Override
public List<ActivityManager.RunningAppProcessInfo> getRunningAppProcesses() {
    enforceNotIsolatedCaller("getRunningAppProcesses");
    final int callingUid = Binder.getCallingUid();
    // Lazy instantiation of list
    List<ActivityManager.RunningAppProcessInfo> runList = null;
    final boolean allUsers = ActivityManager.checkUidPermission(INTERACT_ACROSS_USERS_FULL, callingUid) == PackageManager.PERMISSION_GRANTED;
    final int userId = UserHandle.getUserId(callingUid);
    final boolean allUids = isGetTasksAllowed("getRunningAppProcesses", Binder.getCallingPid(), callingUid);
    synchronized (this) {
        // Iterate across all processes
        for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
            ProcessRecord app = mLruProcesses.get(i);
            if ((!allUsers && app.userId != userId) || (!allUids && app.uid != callingUid)) {
                continue;
            }
            if ((app.thread != null) && (!app.crashing && !app.notResponding)) {
                // Generate process state info for running application
                ActivityManager.RunningAppProcessInfo currApp = new ActivityManager.RunningAppProcessInfo(app.processName, app.pid, app.getPackageList());
                fillInProcMemInfo(app, currApp);
                if (app.adjSource instanceof ProcessRecord) {
                    currApp.importanceReasonPid = ((ProcessRecord) app.adjSource).pid;
                    currApp.importanceReasonImportance = ActivityManager.RunningAppProcessInfo.procStateToImportance(app.adjSourceProcState);
                } else if (app.adjSource instanceof ActivityRecord) {
                    ActivityRecord r = (ActivityRecord) app.adjSource;
                    if (r.app != null)
                        currApp.importanceReasonPid = r.app.pid;
                }
                if (app.adjTarget instanceof ComponentName) {
                    currApp.importanceReasonComponent = (ComponentName) app.adjTarget;
                }
                // + " lru=" + currApp.lru);
                if (runList == null) {
                    runList = new ArrayList<>();
                }
                runList.add(currApp);
            }
        }
    }
    return runList;
}
#end_block

#method_before
public List<ApplicationInfo> getRunningExternalApplications() {
    enforceNotIsolatedCaller("getRunningExternalApplications");
    List<ActivityManager.RunningAppProcessInfo> runningApps = getRunningAppProcesses();
    List<ApplicationInfo> retList = new ArrayList<ApplicationInfo>();
    if (runningApps != null && runningApps.size() > 0) {
        Set<String> extList = new HashSet<String>();
        for (ActivityManager.RunningAppProcessInfo app : runningApps) {
            if (app.pkgList != null) {
                for (String pkg : app.pkgList) {
                    extList.add(pkg);
                }
            }
        }
        IPackageManager pm = AppGlobals.getPackageManager();
        for (String pkg : extList) {
            try {
                ApplicationInfo info = pm.getApplicationInfo(pkg, 0, UserHandle.getCallingUserId());
                if ((info.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {
                    retList.add(info);
                }
            } catch (RemoteException e) {
            }
        }
    }
    return retList;
}
#method_after
@Override
public List<ApplicationInfo> getRunningExternalApplications() {
    enforceNotIsolatedCaller("getRunningExternalApplications");
    List<ActivityManager.RunningAppProcessInfo> runningApps = getRunningAppProcesses();
    List<ApplicationInfo> retList = new ArrayList<ApplicationInfo>();
    if (runningApps != null && runningApps.size() > 0) {
        Set<String> extList = new HashSet<String>();
        for (ActivityManager.RunningAppProcessInfo app : runningApps) {
            if (app.pkgList != null) {
                for (String pkg : app.pkgList) {
                    extList.add(pkg);
                }
            }
        }
        IPackageManager pm = AppGlobals.getPackageManager();
        for (String pkg : extList) {
            try {
                ApplicationInfo info = pm.getApplicationInfo(pkg, 0, UserHandle.getCallingUserId());
                if ((info.flags & ApplicationInfo.FLAG_EXTERNAL_STORAGE) != 0) {
                    retList.add(info);
                }
            } catch (RemoteException e) {
            }
        }
    }
    return retList;
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ActivityManager from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " without permission " + android.Manifest.permission.DUMP);
        return;
    }
    boolean dumpAll = false;
    boolean dumpClient = false;
    String dumpPackage = null;
    int opti = 0;
    while (opti < args.length) {
        String opt = args[opti];
        if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
            break;
        }
        opti++;
        if ("-a".equals(opt)) {
            dumpAll = true;
        } else if ("-c".equals(opt)) {
            dumpClient = true;
        } else if ("-p".equals(opt)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            } else {
                pw.println("Error: -p option requires package argument");
                return;
            }
            dumpClient = true;
        } else if ("-h".equals(opt)) {
            pw.println("Activity manager dump options:");
            pw.println("  [-a] [-c] [-p package] [-h] [cmd] ...");
            pw.println("  cmd may be one of:");
            pw.println("    a[ctivities]: activity stack state");
            pw.println("    r[recents]: recent activities state");
            pw.println("    b[roadcasts] [PACKAGE_NAME] [history [-s]]: broadcast state");
            pw.println("    i[ntents] [PACKAGE_NAME]: pending intent state");
            pw.println("    p[rocesses] [PACKAGE_NAME]: process state");
            pw.println("    o[om]: out of memory management");
            pw.println("    perm[issions]: URI permission grant state");
            pw.println("    prov[iders] [COMP_SPEC ...]: content provider state");
            pw.println("    provider [COMP_SPEC]: provider client-side state");
            pw.println("    s[ervices] [COMP_SPEC ...]: service state");
            pw.println("    as[sociations]: tracked app associations");
            pw.println("    service [COMP_SPEC]: service client-side state");
            pw.println("    package [PACKAGE_NAME]: all state related to given package");
            pw.println("    all: dump all activities");
            pw.println("    top: dump the top activity");
            pw.println("    write: write all pending state to storage");
            pw.println("    track-associations: enable association tracking");
            pw.println("    untrack-associations: disable and clear association tracking");
            pw.println("  cmd may also be a COMP_SPEC to dump activities.");
            pw.println("  COMP_SPEC may be a component name (com.foo/.myApp),");
            pw.println("    a partial substring in a component name, a");
            pw.println("    hex object identifier.");
            pw.println("  -a: include all available server state.");
            pw.println("  -c: include client state.");
            pw.println("  -p: limit output to given package.");
            return;
        } else {
            pw.println("Unknown argument: " + opt + "; use -h for help");
        }
    }
    long origId = Binder.clearCallingIdentity();
    boolean more = false;
    // Is the caller requesting to dump a particular piece of data?
    if (opti < args.length) {
        String cmd = args[opti];
        opti++;
        if ("activities".equals(cmd) || "a".equals(cmd)) {
            synchronized (this) {
                dumpActivitiesLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
            }
        } else if ("recents".equals(cmd) || "r".equals(cmd)) {
            synchronized (this) {
                dumpRecentsLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("broadcasts".equals(cmd) || "b".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            synchronized (this) {
                dumpBroadcastsLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("intents".equals(cmd) || "i".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            synchronized (this) {
                dumpPendingIntentsLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("processes".equals(cmd) || "p".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            synchronized (this) {
                dumpProcessesLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("oom".equals(cmd) || "o".equals(cmd)) {
            synchronized (this) {
                dumpOomLocked(fd, pw, args, opti, true);
            }
        } else if ("permissions".equals(cmd) || "perm".equals(cmd)) {
            synchronized (this) {
                dumpPermissionsLocked(fd, pw, args, opti, true, null);
            }
        } else if ("provider".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                name = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            if (!dumpProvider(fd, pw, name, newArgs, 0, dumpAll)) {
                pw.println("No providers match: " + name);
                pw.println("Use -h for help.");
            }
        } else if ("providers".equals(cmd) || "prov".equals(cmd)) {
            synchronized (this) {
                dumpProvidersLocked(fd, pw, args, opti, true, null);
            }
        } else if ("service".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                name = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            if (!mServices.dumpService(fd, pw, name, newArgs, 0, dumpAll)) {
                pw.println("No services match: " + name);
                pw.println("Use -h for help.");
            }
        } else if ("package".equals(cmd)) {
            String[] newArgs;
            if (opti >= args.length) {
                pw.println("package: no package name specified");
                pw.println("Use -h for help.");
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
                args = newArgs;
                opti = 0;
                more = true;
            }
        } else if ("associations".equals(cmd) || "as".equals(cmd)) {
            synchronized (this) {
                dumpAssociationsLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
            }
        } else if ("services".equals(cmd) || "s".equals(cmd)) {
            synchronized (this) {
                mServices.dumpServicesLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
            }
        } else if ("write".equals(cmd)) {
            mTaskPersister.flush();
            pw.println("All tasks persisted.");
            return;
        } else if ("track-associations".equals(cmd)) {
            synchronized (this) {
                if (!mTrackingAssociations) {
                    mTrackingAssociations = true;
                    pw.println("Association tracking started.");
                } else {
                    pw.println("Association tracking already enabled.");
                }
            }
            return;
        } else if ("untrack-associations".equals(cmd)) {
            synchronized (this) {
                if (mTrackingAssociations) {
                    mTrackingAssociations = false;
                    mAssociations.clear();
                    pw.println("Association tracking stopped.");
                } else {
                    pw.println("Association tracking not running.");
                }
            }
            return;
        } else {
            // Dumping a single activity?
            if (!dumpActivity(fd, pw, cmd, args, opti, dumpAll)) {
                pw.println("Bad activity command, or no activities match: " + cmd);
                pw.println("Use -h for help.");
            }
        }
        if (!more) {
            Binder.restoreCallingIdentity(origId);
            return;
        }
    }
    // No piece of data specified, dump everything.
    synchronized (this) {
        dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
        pw.println();
        if (dumpAll) {
            pw.println("-------------------------------------------------------------------------------");
        }
        dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
        pw.println();
        if (dumpAll) {
            pw.println("-------------------------------------------------------------------------------");
        }
        dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
        pw.println();
        if (dumpAll) {
            pw.println("-------------------------------------------------------------------------------");
        }
        dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
        pw.println();
        if (dumpAll) {
            pw.println("-------------------------------------------------------------------------------");
        }
        mServices.dumpServicesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
        pw.println();
        if (dumpAll) {
            pw.println("-------------------------------------------------------------------------------");
        }
        dumpRecentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
        pw.println();
        if (dumpAll) {
            pw.println("-------------------------------------------------------------------------------");
        }
        dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
        if (mAssociations.size() > 0) {
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
        }
        pw.println();
        if (dumpAll) {
            pw.println("-------------------------------------------------------------------------------");
        }
        dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage);
    }
    Binder.restoreCallingIdentity(origId);
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (checkCallingPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ActivityManager from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " without permission " + android.Manifest.permission.DUMP);
        return;
    }
    boolean dumpAll = false;
    boolean dumpClient = false;
    boolean dumpCheckin = false;
    boolean dumpCheckinFormat = false;
    String dumpPackage = null;
    int opti = 0;
    while (opti < args.length) {
        String opt = args[opti];
        if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
            break;
        }
        opti++;
        if ("-a".equals(opt)) {
            dumpAll = true;
        } else if ("-c".equals(opt)) {
            dumpClient = true;
        } else if ("-p".equals(opt)) {
            if (opti < args.length) {
                dumpPackage = args[opti];
                opti++;
            } else {
                pw.println("Error: -p option requires package argument");
                return;
            }
            dumpClient = true;
        } else if ("--checkin".equals(opt)) {
            dumpCheckin = dumpCheckinFormat = true;
        } else if ("-C".equals(opt)) {
            dumpCheckinFormat = true;
        } else if ("-h".equals(opt)) {
            ActivityManagerShellCommand.dumpHelp(pw, true);
            return;
        } else {
            pw.println("Unknown argument: " + opt + "; use -h for help");
        }
    }
    long origId = Binder.clearCallingIdentity();
    boolean more = false;
    // Is the caller requesting to dump a particular piece of data?
    if (opti < args.length) {
        String cmd = args[opti];
        opti++;
        if ("activities".equals(cmd) || "a".equals(cmd)) {
            synchronized (this) {
                dumpActivitiesLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
            }
        } else if ("recents".equals(cmd) || "r".equals(cmd)) {
            synchronized (this) {
                dumpRecentsLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("broadcasts".equals(cmd) || "b".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            synchronized (this) {
                dumpBroadcastsLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("broadcast-stats".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            synchronized (this) {
                if (dumpCheckinFormat) {
                    dumpBroadcastStatsCheckinLocked(fd, pw, args, opti, dumpCheckin, dumpPackage);
                } else {
                    dumpBroadcastStatsLocked(fd, pw, args, opti, true, dumpPackage);
                }
            }
        } else if ("intents".equals(cmd) || "i".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            synchronized (this) {
                dumpPendingIntentsLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("processes".equals(cmd) || "p".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            synchronized (this) {
                dumpProcessesLocked(fd, pw, args, opti, true, dumpPackage);
            }
        } else if ("oom".equals(cmd) || "o".equals(cmd)) {
            synchronized (this) {
                dumpOomLocked(fd, pw, args, opti, true);
            }
        } else if ("permissions".equals(cmd) || "perm".equals(cmd)) {
            synchronized (this) {
                dumpPermissionsLocked(fd, pw, args, opti, true, null);
            }
        } else if ("provider".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                name = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            if (!dumpProvider(fd, pw, name, newArgs, 0, dumpAll)) {
                pw.println("No providers match: " + name);
                pw.println("Use -h for help.");
            }
        } else if ("providers".equals(cmd) || "prov".equals(cmd)) {
            synchronized (this) {
                dumpProvidersLocked(fd, pw, args, opti, true, null);
            }
        } else if ("service".equals(cmd)) {
            String[] newArgs;
            String name;
            if (opti >= args.length) {
                name = null;
                newArgs = EMPTY_STRING_ARRAY;
            } else {
                name = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
            }
            if (!mServices.dumpService(fd, pw, name, newArgs, 0, dumpAll)) {
                pw.println("No services match: " + name);
                pw.println("Use -h for help.");
            }
        } else if ("package".equals(cmd)) {
            String[] newArgs;
            if (opti >= args.length) {
                pw.println("package: no package name specified");
                pw.println("Use -h for help.");
            } else {
                dumpPackage = args[opti];
                opti++;
                newArgs = new String[args.length - opti];
                if (args.length > 2)
                    System.arraycopy(args, opti, newArgs, 0, args.length - opti);
                args = newArgs;
                opti = 0;
                more = true;
            }
        } else if ("associations".equals(cmd) || "as".equals(cmd)) {
            synchronized (this) {
                dumpAssociationsLocked(fd, pw, args, opti, true, dumpClient, dumpPackage);
            }
        } else if ("services".equals(cmd) || "s".equals(cmd)) {
            if (dumpClient) {
                ActiveServices.ServiceDumper dumper;
                synchronized (this) {
                    dumper = mServices.newServiceDumperLocked(fd, pw, args, opti, true, dumpPackage);
                }
                dumper.dumpWithClient();
            } else {
                synchronized (this) {
                    mServices.newServiceDumperLocked(fd, pw, args, opti, true, dumpPackage).dumpLocked();
                }
            }
        } else if ("locks".equals(cmd)) {
            LockGuard.dump(fd, pw, args);
        } else {
            // Dumping a single activity?
            if (!dumpActivity(fd, pw, cmd, args, opti, dumpAll)) {
                ActivityManagerShellCommand shell = new ActivityManagerShellCommand(this, true);
                int res = shell.exec(this, null, fd, null, args, new ResultReceiver(null));
                if (res < 0) {
                    pw.println("Bad activity command, or no activities match: " + cmd);
                    pw.println("Use -h for help.");
                }
            }
        }
        if (!more) {
            Binder.restoreCallingIdentity(origId);
            return;
        }
    }
    // No piece of data specified, dump everything.
    if (dumpCheckinFormat) {
        dumpBroadcastStatsCheckinLocked(fd, pw, args, opti, dumpCheckin, dumpPackage);
    } else if (dumpClient) {
        ActiveServices.ServiceDumper sdumper;
        synchronized (this) {
            dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            if (dumpAll || dumpPackage != null) {
                dumpBroadcastStatsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
            }
            dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            sdumper = mServices.newServiceDumperLocked(fd, pw, args, opti, dumpAll, dumpPackage);
        }
        sdumper.dumpWithClient();
        pw.println();
        synchronized (this) {
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpRecentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            if (mAssociations.size() > 0) {
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
                dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            }
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage);
        }
    } else {
        synchronized (this) {
            dumpPendingIntentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpBroadcastsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            if (dumpAll || dumpPackage != null) {
                dumpBroadcastStatsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
            }
            dumpProvidersLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpPermissionsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            mServices.newServiceDumperLocked(fd, pw, args, opti, dumpAll, dumpPackage).dumpLocked();
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpRecentsLocked(fd, pw, args, opti, dumpAll, dumpPackage);
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpActivitiesLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            if (mAssociations.size() > 0) {
                pw.println();
                if (dumpAll) {
                    pw.println("-------------------------------------------------------------------------------");
                }
                dumpAssociationsLocked(fd, pw, args, opti, dumpAll, dumpClient, dumpPackage);
            }
            pw.println();
            if (dumpAll) {
                pw.println("-------------------------------------------------------------------------------");
            }
            dumpProcessesLocked(fd, pw, args, opti, dumpAll, dumpPackage);
        }
    }
    Binder.restoreCallingIdentity(origId);
}
#end_block

#method_before
void dumpAssociationsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {
    pw.println("ACTIVITY MANAGER ASSOCIATIONS (dumpsys activity associations)");
    int dumpUid = 0;
    if (dumpPackage != null) {
        IPackageManager pm = AppGlobals.getPackageManager();
        try {
            dumpUid = pm.getPackageUid(dumpPackage, 0);
        } catch (RemoteException e) {
        }
    }
    boolean printedAnything = false;
    final long now = SystemClock.uptimeMillis();
    for (int i1 = 0, N1 = mAssociations.size(); i1 < N1; i1++) {
        ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> targetComponents = mAssociations.valueAt(i1);
        for (int i2 = 0, N2 = targetComponents.size(); i2 < N2; i2++) {
            SparseArray<ArrayMap<String, Association>> sourceUids = targetComponents.valueAt(i2);
            for (int i3 = 0, N3 = sourceUids.size(); i3 < N3; i3++) {
                ArrayMap<String, Association> sourceProcesses = sourceUids.valueAt(i3);
                for (int i4 = 0, N4 = sourceProcesses.size(); i4 < N4; i4++) {
                    Association ass = sourceProcesses.valueAt(i4);
                    if (dumpPackage != null) {
                        if (!ass.mTargetComponent.getPackageName().equals(dumpPackage) && UserHandle.getAppId(ass.mSourceUid) != dumpUid) {
                            continue;
                        }
                    }
                    printedAnything = true;
                    pw.print("  ");
                    pw.print(ass.mTargetProcess);
                    pw.print("/");
                    UserHandle.formatUid(pw, ass.mTargetUid);
                    pw.print(" <- ");
                    pw.print(ass.mSourceProcess);
                    pw.print("/");
                    UserHandle.formatUid(pw, ass.mSourceUid);
                    pw.println();
                    pw.print("    via ");
                    pw.print(ass.mTargetComponent.flattenToShortString());
                    pw.println();
                    pw.print("    ");
                    long dur = ass.mTime;
                    if (ass.mNesting > 0) {
                        dur += now - ass.mStartTime;
                    }
                    TimeUtils.formatDuration(dur, pw);
                    pw.print(" (");
                    pw.print(ass.mCount);
                    pw.println(" times)");
                    if (ass.mNesting > 0) {
                        pw.print("    ");
                        pw.print(" Currently active: ");
                        TimeUtils.formatDuration(now - ass.mStartTime, pw);
                        pw.println();
                    }
                }
            }
        }
    }
    if (!printedAnything) {
        pw.println("  (nothing)");
    }
}
#method_after
void dumpAssociationsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, boolean dumpClient, String dumpPackage) {
    pw.println("ACTIVITY MANAGER ASSOCIATIONS (dumpsys activity associations)");
    int dumpUid = 0;
    if (dumpPackage != null) {
        IPackageManager pm = AppGlobals.getPackageManager();
        try {
            dumpUid = pm.getPackageUid(dumpPackage, MATCH_UNINSTALLED_PACKAGES, 0);
        } catch (RemoteException e) {
        }
    }
    boolean printedAnything = false;
    final long now = SystemClock.uptimeMillis();
    for (int i1 = 0, N1 = mAssociations.size(); i1 < N1; i1++) {
        ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> targetComponents = mAssociations.valueAt(i1);
        for (int i2 = 0, N2 = targetComponents.size(); i2 < N2; i2++) {
            SparseArray<ArrayMap<String, Association>> sourceUids = targetComponents.valueAt(i2);
            for (int i3 = 0, N3 = sourceUids.size(); i3 < N3; i3++) {
                ArrayMap<String, Association> sourceProcesses = sourceUids.valueAt(i3);
                for (int i4 = 0, N4 = sourceProcesses.size(); i4 < N4; i4++) {
                    Association ass = sourceProcesses.valueAt(i4);
                    if (dumpPackage != null) {
                        if (!ass.mTargetComponent.getPackageName().equals(dumpPackage) && UserHandle.getAppId(ass.mSourceUid) != dumpUid) {
                            continue;
                        }
                    }
                    printedAnything = true;
                    pw.print("  ");
                    pw.print(ass.mTargetProcess);
                    pw.print("/");
                    UserHandle.formatUid(pw, ass.mTargetUid);
                    pw.print(" <- ");
                    pw.print(ass.mSourceProcess);
                    pw.print("/");
                    UserHandle.formatUid(pw, ass.mSourceUid);
                    pw.println();
                    pw.print("    via ");
                    pw.print(ass.mTargetComponent.flattenToShortString());
                    pw.println();
                    pw.print("    ");
                    long dur = ass.mTime;
                    if (ass.mNesting > 0) {
                        dur += now - ass.mStartTime;
                    }
                    TimeUtils.formatDuration(dur, pw);
                    pw.print(" (");
                    pw.print(ass.mCount);
                    pw.print(" times)");
                    pw.print("  ");
                    for (int i = 0; i < ass.mStateTimes.length; i++) {
                        long amt = ass.mStateTimes[i];
                        if (ass.mLastState - ActivityManager.MIN_PROCESS_STATE == i) {
                            amt += now - ass.mLastStateUptime;
                        }
                        if (amt != 0) {
                            pw.print(" ");
                            pw.print(ProcessList.makeProcStateString(i + ActivityManager.MIN_PROCESS_STATE));
                            pw.print("=");
                            TimeUtils.formatDuration(amt, pw);
                            if (ass.mLastState - ActivityManager.MIN_PROCESS_STATE == i) {
                                pw.print("*");
                            }
                        }
                    }
                    pw.println();
                    if (ass.mNesting > 0) {
                        pw.print("    Currently active: ");
                        TimeUtils.formatDuration(now - ass.mStartTime, pw);
                        pw.println();
                    }
                }
            }
        }
    }
    if (!printedAnything) {
        pw.println("  (nothing)");
    }
}
#end_block

#method_before
void dumpProcessesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
    boolean needSep = false;
    boolean printedAnything = false;
    int numPers = 0;
    pw.println("ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)");
    if (dumpAll) {
        final int NP = mProcessNames.getMap().size();
        for (int ip = 0; ip < NP; ip++) {
            SparseArray<ProcessRecord> procs = mProcessNames.getMap().valueAt(ip);
            final int NA = procs.size();
            for (int ia = 0; ia < NA; ia++) {
                ProcessRecord r = procs.valueAt(ia);
                if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                    continue;
                }
                if (!needSep) {
                    pw.println("  All known processes:");
                    needSep = true;
                    printedAnything = true;
                }
                pw.print(r.persistent ? "  *PERS*" : "  *APP*");
                pw.print(" UID ");
                pw.print(procs.keyAt(ia));
                pw.print(" ");
                pw.println(r);
                r.dump(pw, "    ");
                if (r.persistent) {
                    numPers++;
                }
            }
        }
    }
    if (mIsolatedProcesses.size() > 0) {
        boolean printed = false;
        for (int i = 0; i < mIsolatedProcesses.size(); i++) {
            ProcessRecord r = mIsolatedProcesses.valueAt(i);
            if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                continue;
            }
            if (!printed) {
                if (needSep) {
                    pw.println();
                }
                pw.println("  Isolated process list (sorted by uid):");
                printedAnything = true;
                printed = true;
                needSep = true;
            }
            pw.println(String.format("%sIsolated #%2d: %s", "    ", i, r.toString()));
        }
    }
    if (mActiveUids.size() > 0) {
        if (needSep) {
            pw.println();
        }
        pw.println("  UID states:");
        for (int i = 0; i < mActiveUids.size(); i++) {
            UidRecord uidRec = mActiveUids.valueAt(i);
            pw.print("    UID ");
            UserHandle.formatUid(pw, uidRec.uid);
            pw.print(": ");
            pw.println(uidRec);
        }
        needSep = true;
        printedAnything = true;
    }
    if (mLruProcesses.size() > 0) {
        if (needSep) {
            pw.println();
        }
        pw.print("  Process LRU list (sorted by oom_adj, ");
        pw.print(mLruProcesses.size());
        pw.print(" total, non-act at ");
        pw.print(mLruProcesses.size() - mLruProcessActivityStart);
        pw.print(", non-svc at ");
        pw.print(mLruProcesses.size() - mLruProcessServiceStart);
        pw.println("):");
        dumpProcessOomList(pw, this, mLruProcesses, "    ", "Proc", "PERS", false, dumpPackage);
        needSep = true;
        printedAnything = true;
    }
    if (dumpAll || dumpPackage != null) {
        synchronized (mPidsSelfLocked) {
            boolean printed = false;
            for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                ProcessRecord r = mPidsSelfLocked.valueAt(i);
                if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                    continue;
                }
                if (!printed) {
                    if (needSep)
                        pw.println();
                    needSep = true;
                    pw.println("  PID mappings:");
                    printed = true;
                    printedAnything = true;
                }
                pw.print("    PID #");
                pw.print(mPidsSelfLocked.keyAt(i));
                pw.print(": ");
                pw.println(mPidsSelfLocked.valueAt(i));
            }
        }
    }
    if (mForegroundProcesses.size() > 0) {
        synchronized (mPidsSelfLocked) {
            boolean printed = false;
            for (int i = 0; i < mForegroundProcesses.size(); i++) {
                ProcessRecord r = mPidsSelfLocked.get(mForegroundProcesses.valueAt(i).pid);
                if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
                    continue;
                }
                if (!printed) {
                    if (needSep)
                        pw.println();
                    needSep = true;
                    pw.println("  Foreground Processes:");
                    printed = true;
                    printedAnything = true;
                }
                pw.print("    PID #");
                pw.print(mForegroundProcesses.keyAt(i));
                pw.print(": ");
                pw.println(mForegroundProcesses.valueAt(i));
            }
        }
    }
    if (mPersistentStartingProcesses.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Persisent processes that are starting:");
        dumpProcessList(pw, this, mPersistentStartingProcesses, "    ", "Starting Norm", "Restarting PERS", dumpPackage);
    }
    if (mRemovedProcesses.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Processes that are being removed:");
        dumpProcessList(pw, this, mRemovedProcesses, "    ", "Removed Norm", "Removed PERS", dumpPackage);
    }
    if (mProcessesOnHold.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Processes that are on old until the system is ready:");
        dumpProcessList(pw, this, mProcessesOnHold, "    ", "OnHold Norm", "OnHold PERS", dumpPackage);
    }
    needSep = dumpProcessesToGc(fd, pw, args, opti, needSep, dumpAll, dumpPackage);
    if (mProcessCrashTimes.getMap().size() > 0) {
        boolean printed = false;
        long now = SystemClock.uptimeMillis();
        final ArrayMap<String, SparseArray<Long>> pmap = mProcessCrashTimes.getMap();
        final int NP = pmap.size();
        for (int ip = 0; ip < NP; ip++) {
            String pname = pmap.keyAt(ip);
            SparseArray<Long> uids = pmap.valueAt(ip);
            final int N = uids.size();
            for (int i = 0; i < N; i++) {
                int puid = uids.keyAt(i);
                ProcessRecord r = mProcessNames.get(pname, puid);
                if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
                    continue;
                }
                if (!printed) {
                    if (needSep)
                        pw.println();
                    needSep = true;
                    pw.println("  Time since processes crashed:");
                    printed = true;
                    printedAnything = true;
                }
                pw.print("    Process ");
                pw.print(pname);
                pw.print(" uid ");
                pw.print(puid);
                pw.print(": last crashed ");
                TimeUtils.formatDuration(now - uids.valueAt(i), pw);
                pw.println(" ago");
            }
        }
    }
    if (mBadProcesses.getMap().size() > 0) {
        boolean printed = false;
        final ArrayMap<String, SparseArray<BadProcessInfo>> pmap = mBadProcesses.getMap();
        final int NP = pmap.size();
        for (int ip = 0; ip < NP; ip++) {
            String pname = pmap.keyAt(ip);
            SparseArray<BadProcessInfo> uids = pmap.valueAt(ip);
            final int N = uids.size();
            for (int i = 0; i < N; i++) {
                int puid = uids.keyAt(i);
                ProcessRecord r = mProcessNames.get(pname, puid);
                if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
                    continue;
                }
                if (!printed) {
                    if (needSep)
                        pw.println();
                    needSep = true;
                    pw.println("  Bad processes:");
                    printedAnything = true;
                }
                BadProcessInfo info = uids.valueAt(i);
                pw.print("    Bad process ");
                pw.print(pname);
                pw.print(" uid ");
                pw.print(puid);
                pw.print(": crashed at time ");
                pw.println(info.time);
                if (info.shortMsg != null) {
                    pw.print("      Short msg: ");
                    pw.println(info.shortMsg);
                }
                if (info.longMsg != null) {
                    pw.print("      Long msg: ");
                    pw.println(info.longMsg);
                }
                if (info.stack != null) {
                    pw.println("      Stack:");
                    int lastPos = 0;
                    for (int pos = 0; pos < info.stack.length(); pos++) {
                        if (info.stack.charAt(pos) == '\n') {
                            pw.print("        ");
                            pw.write(info.stack, lastPos, pos - lastPos);
                            pw.println();
                            lastPos = pos + 1;
                        }
                    }
                    if (lastPos < info.stack.length()) {
                        pw.print("        ");
                        pw.write(info.stack, lastPos, info.stack.length() - lastPos);
                        pw.println();
                    }
                }
            }
        }
    }
    if (dumpPackage == null) {
        pw.println();
        needSep = false;
        pw.println("  mStartedUsers:");
        for (int i = 0; i < mStartedUsers.size(); i++) {
            UserState uss = mStartedUsers.valueAt(i);
            pw.print("    User #");
            pw.print(uss.mHandle.getIdentifier());
            pw.print(": ");
            uss.dump("", pw);
        }
        pw.print("  mStartedUserArray: [");
        for (int i = 0; i < mStartedUserArray.length; i++) {
            if (i > 0)
                pw.print(", ");
            pw.print(mStartedUserArray[i]);
        }
        pw.println("]");
        pw.print("  mUserLru: [");
        for (int i = 0; i < mUserLru.size(); i++) {
            if (i > 0)
                pw.print(", ");
            pw.print(mUserLru.get(i));
        }
        pw.println("]");
        if (dumpAll) {
            pw.print("  mStartedUserArray: ");
            pw.println(Arrays.toString(mStartedUserArray));
        }
        synchronized (mUserProfileGroupIdsSelfLocked) {
            if (mUserProfileGroupIdsSelfLocked.size() > 0) {
                pw.println("  mUserProfileGroupIds:");
                for (int i = 0; i < mUserProfileGroupIdsSelfLocked.size(); i++) {
                    pw.print("    User #");
                    pw.print(mUserProfileGroupIdsSelfLocked.keyAt(i));
                    pw.print(" -> profile #");
                    pw.println(mUserProfileGroupIdsSelfLocked.valueAt(i));
                }
            }
        }
    }
    if (mHomeProcess != null && (dumpPackage == null || mHomeProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mHomeProcess: " + mHomeProcess);
    }
    if (mPreviousProcess != null && (dumpPackage == null || mPreviousProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mPreviousProcess: " + mPreviousProcess);
    }
    if (dumpAll) {
        StringBuilder sb = new StringBuilder(128);
        sb.append("  mPreviousProcessVisibleTime: ");
        TimeUtils.formatDuration(mPreviousProcessVisibleTime, sb);
        pw.println(sb);
    }
    if (mHeavyWeightProcess != null && (dumpPackage == null || mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mHeavyWeightProcess: " + mHeavyWeightProcess);
    }
    if (dumpPackage == null) {
        pw.println("  mConfiguration: " + mConfiguration);
    }
    if (dumpAll) {
        pw.println("  mConfigWillChange: " + getFocusedStack().mConfigWillChange);
        if (mCompatModePackages.getPackages().size() > 0) {
            boolean printed = false;
            for (Map.Entry<String, Integer> entry : mCompatModePackages.getPackages().entrySet()) {
                String pkg = entry.getKey();
                int mode = entry.getValue();
                if (dumpPackage != null && !dumpPackage.equals(pkg)) {
                    continue;
                }
                if (!printed) {
                    pw.println("  mScreenCompatPackages:");
                    printed = true;
                }
                pw.print("    ");
                pw.print(pkg);
                pw.print(": ");
                pw.print(mode);
                pw.println();
            }
        }
    }
    if (dumpPackage == null) {
        pw.println("  mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness));
        pw.println("  mSleepTokens=" + mSleepTokens);
        pw.println("  mSleeping=" + mSleeping + " mLockScreenShown=" + lockScreenShownToString());
        pw.println("  mShuttingDown=" + mShuttingDown + " mTestPssMode=" + mTestPssMode);
        if (mRunningVoice != null) {
            pw.println("  mRunningVoice=" + mRunningVoice);
            pw.println("  mVoiceWakeLock" + mVoiceWakeLock);
        }
    }
    if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
        if (dumpPackage == null || dumpPackage.equals(mDebugApp) || dumpPackage.equals(mOrigDebugApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mDebugApp=" + mDebugApp + "/orig=" + mOrigDebugApp + " mDebugTransient=" + mDebugTransient + " mOrigWaitForDebugger=" + mOrigWaitForDebugger);
        }
    }
    if (mCurAppTimeTracker != null) {
        mCurAppTimeTracker.dumpWithHeader(pw, "  ", true);
    }
    if (mMemWatchProcesses.getMap().size() > 0) {
        pw.println("  Mem watch processes:");
        final ArrayMap<String, SparseArray<Pair<Long, String>>> procs = mMemWatchProcesses.getMap();
        for (int i = 0; i < procs.size(); i++) {
            final String proc = procs.keyAt(i);
            final SparseArray<Pair<Long, String>> uids = procs.valueAt(i);
            for (int j = 0; j < uids.size(); j++) {
                if (needSep) {
                    pw.println();
                    needSep = false;
                }
                StringBuilder sb = new StringBuilder();
                sb.append("    ").append(proc).append('/');
                UserHandle.formatUid(sb, uids.keyAt(j));
                Pair<Long, String> val = uids.valueAt(j);
                sb.append(": ");
                DebugUtils.sizeValueToString(val.first, sb);
                if (val.second != null) {
                    sb.append(", report to ").append(val.second);
                }
                pw.println(sb.toString());
            }
        }
        pw.print("  mMemWatchDumpProcName=");
        pw.println(mMemWatchDumpProcName);
        pw.print("  mMemWatchDumpFile=");
        pw.println(mMemWatchDumpFile);
        pw.print("  mMemWatchDumpPid=");
        pw.print(mMemWatchDumpPid);
        pw.print(" mMemWatchDumpUid=");
        pw.println(mMemWatchDumpUid);
    }
    if (mOpenGlTraceApp != null) {
        if (dumpPackage == null || dumpPackage.equals(mOpenGlTraceApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mOpenGlTraceApp=" + mOpenGlTraceApp);
        }
    }
    if (mTrackAllocationApp != null) {
        if (dumpPackage == null || dumpPackage.equals(mTrackAllocationApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mTrackAllocationApp=" + mTrackAllocationApp);
        }
    }
    if (mProfileApp != null || mProfileProc != null || mProfileFile != null || mProfileFd != null) {
        if (dumpPackage == null || dumpPackage.equals(mProfileApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mProfileApp=" + mProfileApp + " mProfileProc=" + mProfileProc);
            pw.println("  mProfileFile=" + mProfileFile + " mProfileFd=" + mProfileFd);
            pw.println("  mSamplingInterval=" + mSamplingInterval + " mAutoStopProfiler=" + mAutoStopProfiler);
            pw.println("  mProfileType=" + mProfileType);
        }
    }
    if (mNativeDebuggingApp != null) {
        if (dumpPackage == null || dumpPackage.equals(mNativeDebuggingApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mNativeDebuggingApp=" + mNativeDebuggingApp);
        }
    }
    if (dumpPackage == null) {
        if (mAlwaysFinishActivities || mController != null) {
            pw.println("  mAlwaysFinishActivities=" + mAlwaysFinishActivities + " mController=" + mController);
        }
        if (dumpAll) {
            pw.println("  Total persistent processes: " + numPers);
            pw.println("  mProcessesReady=" + mProcessesReady + " mSystemReady=" + mSystemReady + " mBooted=" + mBooted + " mFactoryTest=" + mFactoryTest);
            pw.println("  mBooting=" + mBooting + " mCallFinishBooting=" + mCallFinishBooting + " mBootAnimationComplete=" + mBootAnimationComplete);
            pw.print("  mLastPowerCheckRealtime=");
            TimeUtils.formatDuration(mLastPowerCheckRealtime, pw);
            pw.println("");
            pw.print("  mLastPowerCheckUptime=");
            TimeUtils.formatDuration(mLastPowerCheckUptime, pw);
            pw.println("");
            pw.println("  mGoingToSleep=" + mStackSupervisor.mGoingToSleep);
            pw.println("  mLaunchingActivity=" + mStackSupervisor.mLaunchingActivity);
            pw.println("  mAdjSeq=" + mAdjSeq + " mLruSeq=" + mLruSeq);
            pw.println("  mNumNonCachedProcs=" + mNumNonCachedProcs + " (" + mLruProcesses.size() + " total)" + " mNumCachedHiddenProcs=" + mNumCachedHiddenProcs + " mNumServiceProcs=" + mNumServiceProcs + " mNewNumServiceProcs=" + mNewNumServiceProcs);
            pw.println("  mAllowLowerMemLevel=" + mAllowLowerMemLevel + " mLastMemoryLevel" + mLastMemoryLevel + " mLastNumProcesses" + mLastNumProcesses);
            long now = SystemClock.uptimeMillis();
            pw.print("  mLastIdleTime=");
            TimeUtils.formatDuration(now, mLastIdleTime, pw);
            pw.print(" mLowRamSinceLastIdle=");
            TimeUtils.formatDuration(getLowRamTimeSinceIdle(now), pw);
            pw.println();
        }
    }
    if (!printedAnything) {
        pw.println("  (nothing)");
    }
}
#method_after
void dumpProcessesLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
    boolean needSep = false;
    boolean printedAnything = false;
    int numPers = 0;
    pw.println("ACTIVITY MANAGER RUNNING PROCESSES (dumpsys activity processes)");
    if (dumpAll) {
        final int NP = mProcessNames.getMap().size();
        for (int ip = 0; ip < NP; ip++) {
            SparseArray<ProcessRecord> procs = mProcessNames.getMap().valueAt(ip);
            final int NA = procs.size();
            for (int ia = 0; ia < NA; ia++) {
                ProcessRecord r = procs.valueAt(ia);
                if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                    continue;
                }
                if (!needSep) {
                    pw.println("  All known processes:");
                    needSep = true;
                    printedAnything = true;
                }
                pw.print(r.persistent ? "  *PERS*" : "  *APP*");
                pw.print(" UID ");
                pw.print(procs.keyAt(ia));
                pw.print(" ");
                pw.println(r);
                r.dump(pw, "    ");
                if (r.persistent) {
                    numPers++;
                }
            }
        }
    }
    if (mIsolatedProcesses.size() > 0) {
        boolean printed = false;
        for (int i = 0; i < mIsolatedProcesses.size(); i++) {
            ProcessRecord r = mIsolatedProcesses.valueAt(i);
            if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                continue;
            }
            if (!printed) {
                if (needSep) {
                    pw.println();
                }
                pw.println("  Isolated process list (sorted by uid):");
                printedAnything = true;
                printed = true;
                needSep = true;
            }
            pw.println(String.format("%sIsolated #%2d: %s", "    ", i, r.toString()));
        }
    }
    if (mActiveUids.size() > 0) {
        if (dumpUids(pw, dumpPackage, mActiveUids, "UID states:", needSep)) {
            printedAnything = needSep = true;
        }
    }
    if (mValidateUids.size() > 0) {
        if (dumpUids(pw, dumpPackage, mValidateUids, "UID validation:", needSep)) {
            printedAnything = needSep = true;
        }
    }
    if (mLruProcesses.size() > 0) {
        if (needSep) {
            pw.println();
        }
        pw.print("  Process LRU list (sorted by oom_adj, ");
        pw.print(mLruProcesses.size());
        pw.print(" total, non-act at ");
        pw.print(mLruProcesses.size() - mLruProcessActivityStart);
        pw.print(", non-svc at ");
        pw.print(mLruProcesses.size() - mLruProcessServiceStart);
        pw.println("):");
        dumpProcessOomList(pw, this, mLruProcesses, "    ", "Proc", "PERS", false, dumpPackage);
        needSep = true;
        printedAnything = true;
    }
    if (dumpAll || dumpPackage != null) {
        synchronized (mPidsSelfLocked) {
            boolean printed = false;
            for (int i = 0; i < mPidsSelfLocked.size(); i++) {
                ProcessRecord r = mPidsSelfLocked.valueAt(i);
                if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
                    continue;
                }
                if (!printed) {
                    if (needSep)
                        pw.println();
                    needSep = true;
                    pw.println("  PID mappings:");
                    printed = true;
                    printedAnything = true;
                }
                pw.print("    PID #");
                pw.print(mPidsSelfLocked.keyAt(i));
                pw.print(": ");
                pw.println(mPidsSelfLocked.valueAt(i));
            }
        }
    }
    if (mForegroundProcesses.size() > 0) {
        synchronized (mPidsSelfLocked) {
            boolean printed = false;
            for (int i = 0; i < mForegroundProcesses.size(); i++) {
                ProcessRecord r = mPidsSelfLocked.get(mForegroundProcesses.valueAt(i).pid);
                if (dumpPackage != null && (r == null || !r.pkgList.containsKey(dumpPackage))) {
                    continue;
                }
                if (!printed) {
                    if (needSep)
                        pw.println();
                    needSep = true;
                    pw.println("  Foreground Processes:");
                    printed = true;
                    printedAnything = true;
                }
                pw.print("    PID #");
                pw.print(mForegroundProcesses.keyAt(i));
                pw.print(": ");
                pw.println(mForegroundProcesses.valueAt(i));
            }
        }
    }
    if (mPersistentStartingProcesses.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Persisent processes that are starting:");
        dumpProcessList(pw, this, mPersistentStartingProcesses, "    ", "Starting Norm", "Restarting PERS", dumpPackage);
    }
    if (mRemovedProcesses.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Processes that are being removed:");
        dumpProcessList(pw, this, mRemovedProcesses, "    ", "Removed Norm", "Removed PERS", dumpPackage);
    }
    if (mProcessesOnHold.size() > 0) {
        if (needSep)
            pw.println();
        needSep = true;
        printedAnything = true;
        pw.println("  Processes that are on old until the system is ready:");
        dumpProcessList(pw, this, mProcessesOnHold, "    ", "OnHold Norm", "OnHold PERS", dumpPackage);
    }
    needSep = dumpProcessesToGc(fd, pw, args, opti, needSep, dumpAll, dumpPackage);
    needSep = mAppErrors.dumpLocked(fd, pw, needSep, dumpPackage);
    if (needSep) {
        printedAnything = true;
    }
    if (dumpPackage == null) {
        pw.println();
        needSep = false;
        mUserController.dump(pw, dumpAll);
    }
    if (mHomeProcess != null && (dumpPackage == null || mHomeProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mHomeProcess: " + mHomeProcess);
    }
    if (mPreviousProcess != null && (dumpPackage == null || mPreviousProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mPreviousProcess: " + mPreviousProcess);
    }
    if (dumpAll) {
        StringBuilder sb = new StringBuilder(128);
        sb.append("  mPreviousProcessVisibleTime: ");
        TimeUtils.formatDuration(mPreviousProcessVisibleTime, sb);
        pw.println(sb);
    }
    if (mHeavyWeightProcess != null && (dumpPackage == null || mHeavyWeightProcess.pkgList.containsKey(dumpPackage))) {
        if (needSep) {
            pw.println();
            needSep = false;
        }
        pw.println("  mHeavyWeightProcess: " + mHeavyWeightProcess);
    }
    if (dumpPackage == null) {
        pw.println("  mConfiguration: " + mConfiguration);
    }
    if (dumpAll) {
        pw.println("  mConfigWillChange: " + getFocusedStack().mConfigWillChange);
        if (mCompatModePackages.getPackages().size() > 0) {
            boolean printed = false;
            for (Map.Entry<String, Integer> entry : mCompatModePackages.getPackages().entrySet()) {
                String pkg = entry.getKey();
                int mode = entry.getValue();
                if (dumpPackage != null && !dumpPackage.equals(pkg)) {
                    continue;
                }
                if (!printed) {
                    pw.println("  mScreenCompatPackages:");
                    printed = true;
                }
                pw.print("    ");
                pw.print(pkg);
                pw.print(": ");
                pw.print(mode);
                pw.println();
            }
        }
    }
    if (dumpPackage == null) {
        pw.println("  mWakefulness=" + PowerManagerInternal.wakefulnessToString(mWakefulness));
        pw.println("  mSleepTokens=" + mSleepTokens);
        pw.println("  mSleeping=" + mSleeping + " mLockScreenShown=" + lockScreenShownToString());
        pw.println("  mShuttingDown=" + mShuttingDown + " mTestPssMode=" + mTestPssMode);
        if (mRunningVoice != null) {
            pw.println("  mRunningVoice=" + mRunningVoice);
            pw.println("  mVoiceWakeLock" + mVoiceWakeLock);
        }
    }
    if (mDebugApp != null || mOrigDebugApp != null || mDebugTransient || mOrigWaitForDebugger) {
        if (dumpPackage == null || dumpPackage.equals(mDebugApp) || dumpPackage.equals(mOrigDebugApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mDebugApp=" + mDebugApp + "/orig=" + mOrigDebugApp + " mDebugTransient=" + mDebugTransient + " mOrigWaitForDebugger=" + mOrigWaitForDebugger);
        }
    }
    if (mCurAppTimeTracker != null) {
        mCurAppTimeTracker.dumpWithHeader(pw, "  ", true);
    }
    if (mMemWatchProcesses.getMap().size() > 0) {
        pw.println("  Mem watch processes:");
        final ArrayMap<String, SparseArray<Pair<Long, String>>> procs = mMemWatchProcesses.getMap();
        for (int i = 0; i < procs.size(); i++) {
            final String proc = procs.keyAt(i);
            final SparseArray<Pair<Long, String>> uids = procs.valueAt(i);
            for (int j = 0; j < uids.size(); j++) {
                if (needSep) {
                    pw.println();
                    needSep = false;
                }
                StringBuilder sb = new StringBuilder();
                sb.append("    ").append(proc).append('/');
                UserHandle.formatUid(sb, uids.keyAt(j));
                Pair<Long, String> val = uids.valueAt(j);
                sb.append(": ");
                DebugUtils.sizeValueToString(val.first, sb);
                if (val.second != null) {
                    sb.append(", report to ").append(val.second);
                }
                pw.println(sb.toString());
            }
        }
        pw.print("  mMemWatchDumpProcName=");
        pw.println(mMemWatchDumpProcName);
        pw.print("  mMemWatchDumpFile=");
        pw.println(mMemWatchDumpFile);
        pw.print("  mMemWatchDumpPid=");
        pw.print(mMemWatchDumpPid);
        pw.print(" mMemWatchDumpUid=");
        pw.println(mMemWatchDumpUid);
    }
    if (mTrackAllocationApp != null) {
        if (dumpPackage == null || dumpPackage.equals(mTrackAllocationApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mTrackAllocationApp=" + mTrackAllocationApp);
        }
    }
    if (mProfileApp != null || mProfileProc != null || mProfileFile != null || mProfileFd != null) {
        if (dumpPackage == null || dumpPackage.equals(mProfileApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mProfileApp=" + mProfileApp + " mProfileProc=" + mProfileProc);
            pw.println("  mProfileFile=" + mProfileFile + " mProfileFd=" + mProfileFd);
            pw.println("  mSamplingInterval=" + mSamplingInterval + " mAutoStopProfiler=" + mAutoStopProfiler);
            pw.println("  mProfileType=" + mProfileType);
        }
    }
    if (mNativeDebuggingApp != null) {
        if (dumpPackage == null || dumpPackage.equals(mNativeDebuggingApp)) {
            if (needSep) {
                pw.println();
                needSep = false;
            }
            pw.println("  mNativeDebuggingApp=" + mNativeDebuggingApp);
        }
    }
    if (dumpPackage == null) {
        if (mAlwaysFinishActivities || mLenientBackgroundCheck) {
            pw.println("  mAlwaysFinishActivities=" + mAlwaysFinishActivities + " mLenientBackgroundCheck=" + mLenientBackgroundCheck);
        }
        if (mController != null) {
            pw.println("  mController=" + mController + " mControllerIsAMonkey=" + mControllerIsAMonkey);
        }
        if (dumpAll) {
            pw.println("  Total persistent processes: " + numPers);
            pw.println("  mProcessesReady=" + mProcessesReady + " mSystemReady=" + mSystemReady + " mBooted=" + mBooted + " mFactoryTest=" + mFactoryTest);
            pw.println("  mBooting=" + mBooting + " mCallFinishBooting=" + mCallFinishBooting + " mBootAnimationComplete=" + mBootAnimationComplete);
            pw.print("  mLastPowerCheckRealtime=");
            TimeUtils.formatDuration(mLastPowerCheckRealtime, pw);
            pw.println("");
            pw.print("  mLastPowerCheckUptime=");
            TimeUtils.formatDuration(mLastPowerCheckUptime, pw);
            pw.println("");
            pw.println("  mGoingToSleep=" + mStackSupervisor.mGoingToSleep);
            pw.println("  mLaunchingActivity=" + mStackSupervisor.mLaunchingActivity);
            pw.println("  mAdjSeq=" + mAdjSeq + " mLruSeq=" + mLruSeq);
            pw.println("  mNumNonCachedProcs=" + mNumNonCachedProcs + " (" + mLruProcesses.size() + " total)" + " mNumCachedHiddenProcs=" + mNumCachedHiddenProcs + " mNumServiceProcs=" + mNumServiceProcs + " mNewNumServiceProcs=" + mNewNumServiceProcs);
            pw.println("  mAllowLowerMemLevel=" + mAllowLowerMemLevel + " mLastMemoryLevel=" + mLastMemoryLevel + " mLastNumProcesses=" + mLastNumProcesses);
            long now = SystemClock.uptimeMillis();
            pw.print("  mLastIdleTime=");
            TimeUtils.formatDuration(now, mLastIdleTime, pw);
            pw.print(" mLowRamSinceLastIdle=");
            TimeUtils.formatDuration(getLowRamTimeSinceIdle(now), pw);
            pw.println();
        }
    }
    if (!printedAnything) {
        pw.println("  (nothing)");
    }
}
#end_block

#method_before
void printOomLevel(PrintWriter pw, String name, int adj) {
    pw.print("    ");
    if (adj >= 0) {
        pw.print(' ');
        if (adj < 10)
            pw.print(' ');
    } else {
        if (adj > -10)
            pw.print(' ');
    }
    pw.print(adj);
    pw.print(": ");
    pw.print(name);
    pw.print(" (");
    pw.print(mProcessList.getMemLevel(adj) / 1024);
    pw.println(" kB)");
}
#method_after
void printOomLevel(PrintWriter pw, String name, int adj) {
    pw.print("    ");
    if (adj >= 0) {
        pw.print(' ');
        if (adj < 10)
            pw.print(' ');
    } else {
        if (adj > -10)
            pw.print(' ');
    }
    pw.print(adj);
    pw.print(": ");
    pw.print(name);
    pw.print(" (");
    pw.print(stringifySize(mProcessList.getMemLevel(adj), 1024));
    pw.println(")");
}
#end_block

#method_before
void dumpPermissionsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
    boolean needSep = false;
    boolean printedAnything = false;
    pw.println("ACTIVITY MANAGER URI PERMISSIONS (dumpsys activity permissions)");
    if (mGrantedUriPermissions.size() > 0) {
        boolean printed = false;
        int dumpUid = -2;
        if (dumpPackage != null) {
            try {
                dumpUid = mContext.getPackageManager().getPackageUid(dumpPackage, 0);
            } catch (NameNotFoundException e) {
                dumpUid = -1;
            }
        }
        for (int i = 0; i < mGrantedUriPermissions.size(); i++) {
            int uid = mGrantedUriPermissions.keyAt(i);
            if (dumpUid >= -1 && UserHandle.getAppId(uid) != dumpUid) {
                continue;
            }
            final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.valueAt(i);
            if (!printed) {
                if (needSep)
                    pw.println();
                needSep = true;
                pw.println("  Granted Uri Permissions:");
                printed = true;
                printedAnything = true;
            }
            pw.print("  * UID ");
            pw.print(uid);
            pw.println(" holds:");
            for (UriPermission perm : perms.values()) {
                pw.print("    ");
                pw.println(perm);
                if (dumpAll) {
                    perm.dump(pw, "      ");
                }
            }
        }
    }
    if (!printedAnything) {
        pw.println("  (nothing)");
    }
}
#method_after
void dumpPermissionsLocked(FileDescriptor fd, PrintWriter pw, String[] args, int opti, boolean dumpAll, String dumpPackage) {
    boolean needSep = false;
    boolean printedAnything = false;
    pw.println("ACTIVITY MANAGER URI PERMISSIONS (dumpsys activity permissions)");
    if (mGrantedUriPermissions.size() > 0) {
        boolean printed = false;
        int dumpUid = -2;
        if (dumpPackage != null) {
            try {
                dumpUid = mContext.getPackageManager().getPackageUidAsUser(dumpPackage, MATCH_UNINSTALLED_PACKAGES, 0);
            } catch (NameNotFoundException e) {
                dumpUid = -1;
            }
        }
        for (int i = 0; i < mGrantedUriPermissions.size(); i++) {
            int uid = mGrantedUriPermissions.keyAt(i);
            if (dumpUid >= -1 && UserHandle.getAppId(uid) != dumpUid) {
                continue;
            }
            final ArrayMap<GrantUri, UriPermission> perms = mGrantedUriPermissions.valueAt(i);
            if (!printed) {
                if (needSep)
                    pw.println();
                needSep = true;
                pw.println("  Granted Uri Permissions:");
                printed = true;
                printedAnything = true;
            }
            pw.print("  * UID ");
            pw.print(uid);
            pw.println(" holds:");
            for (UriPermission perm : perms.values()) {
                pw.print("    ");
                pw.println(perm);
                if (dumpAll) {
                    perm.dump(pw, "      ");
                }
            }
        }
    }
    if (!printedAnything) {
        pw.println("  (nothing)");
    }
}
#end_block

#method_before
private static final boolean dumpProcessOomList(PrintWriter pw, ActivityManagerService service, List<ProcessRecord> origList, String prefix, String normalLabel, String persistentLabel, boolean inclDetails, String dumpPackage) {
    ArrayList<Pair<ProcessRecord, Integer>> list = new ArrayList<Pair<ProcessRecord, Integer>>(origList.size());
    for (int i = 0; i < origList.size(); i++) {
        ProcessRecord r = origList.get(i);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
            continue;
        }
        list.add(new Pair<ProcessRecord, Integer>(origList.get(i), i));
    }
    if (list.size() <= 0) {
        return false;
    }
    Comparator<Pair<ProcessRecord, Integer>> comparator = new Comparator<Pair<ProcessRecord, Integer>>() {

        @Override
        public int compare(Pair<ProcessRecord, Integer> object1, Pair<ProcessRecord, Integer> object2) {
            if (object1.first.setAdj != object2.first.setAdj) {
                return object1.first.setAdj > object2.first.setAdj ? -1 : 1;
            }
            if (object1.second.intValue() != object2.second.intValue()) {
                return object1.second.intValue() > object2.second.intValue() ? -1 : 1;
            }
            return 0;
        }
    };
    Collections.sort(list, comparator);
    final long curRealtime = SystemClock.elapsedRealtime();
    final long realtimeSince = curRealtime - service.mLastPowerCheckRealtime;
    final long curUptime = SystemClock.uptimeMillis();
    final long uptimeSince = curUptime - service.mLastPowerCheckUptime;
    for (int i = list.size() - 1; i >= 0; i--) {
        ProcessRecord r = list.get(i).first;
        String oomAdj = ProcessList.makeOomAdjString(r.setAdj);
        char schedGroup;
        switch(r.setSchedGroup) {
            case Process.THREAD_GROUP_BG_NONINTERACTIVE:
                schedGroup = 'B';
                break;
            case Process.THREAD_GROUP_DEFAULT:
                schedGroup = 'F';
                break;
            default:
                schedGroup = '?';
                break;
        }
        char foreground;
        if (r.foregroundActivities) {
            foreground = 'A';
        } else if (r.foregroundServices) {
            foreground = 'S';
        } else {
            foreground = ' ';
        }
        String procState = ProcessList.makeProcStateString(r.curProcState);
        pw.print(prefix);
        pw.print(r.persistent ? persistentLabel : normalLabel);
        pw.print(" #");
        int num = (origList.size() - 1) - list.get(i).second;
        if (num < 10)
            pw.print(' ');
        pw.print(num);
        pw.print(": ");
        pw.print(oomAdj);
        pw.print(' ');
        pw.print(schedGroup);
        pw.print('/');
        pw.print(foreground);
        pw.print('/');
        pw.print(procState);
        pw.print(" trm:");
        if (r.trimMemoryLevel < 10)
            pw.print(' ');
        pw.print(r.trimMemoryLevel);
        pw.print(' ');
        pw.print(r.toShortString());
        pw.print(" (");
        pw.print(r.adjType);
        pw.println(')');
        if (r.adjSource != null || r.adjTarget != null) {
            pw.print(prefix);
            pw.print("    ");
            if (r.adjTarget instanceof ComponentName) {
                pw.print(((ComponentName) r.adjTarget).flattenToShortString());
            } else if (r.adjTarget != null) {
                pw.print(r.adjTarget.toString());
            } else {
                pw.print("{null}");
            }
            pw.print("<=");
            if (r.adjSource instanceof ProcessRecord) {
                pw.print("Proc{");
                pw.print(((ProcessRecord) r.adjSource).toShortString());
                pw.println("}");
            } else if (r.adjSource != null) {
                pw.println(r.adjSource.toString());
            } else {
                pw.println("{null}");
            }
        }
        if (inclDetails) {
            pw.print(prefix);
            pw.print("    ");
            pw.print("oom: max=");
            pw.print(r.maxAdj);
            pw.print(" curRaw=");
            pw.print(r.curRawAdj);
            pw.print(" setRaw=");
            pw.print(r.setRawAdj);
            pw.print(" cur=");
            pw.print(r.curAdj);
            pw.print(" set=");
            pw.println(r.setAdj);
            pw.print(prefix);
            pw.print("    ");
            pw.print("state: cur=");
            pw.print(ProcessList.makeProcStateString(r.curProcState));
            pw.print(" set=");
            pw.print(ProcessList.makeProcStateString(r.setProcState));
            pw.print(" lastPss=");
            DebugUtils.printSizeValue(pw, r.lastPss * 1024);
            pw.print(" lastCachedPss=");
            DebugUtils.printSizeValue(pw, r.lastCachedPss * 1024);
            pw.println();
            pw.print(prefix);
            pw.print("    ");
            pw.print("cached=");
            pw.print(r.cached);
            pw.print(" empty=");
            pw.print(r.empty);
            pw.print(" hasAboveClient=");
            pw.println(r.hasAboveClient);
            if (r.setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
                if (r.lastWakeTime != 0) {
                    long wtime;
                    BatteryStatsImpl stats = service.mBatteryStatsService.getActiveStatistics();
                    synchronized (stats) {
                        wtime = stats.getProcessWakeTime(r.info.uid, r.pid, curRealtime);
                    }
                    long timeUsed = wtime - r.lastWakeTime;
                    pw.print(prefix);
                    pw.print("    ");
                    pw.print("keep awake over ");
                    TimeUtils.formatDuration(realtimeSince, pw);
                    pw.print(" used ");
                    TimeUtils.formatDuration(timeUsed, pw);
                    pw.print(" (");
                    pw.print((timeUsed * 100) / realtimeSince);
                    pw.println("%)");
                }
                if (r.lastCpuTime != 0) {
                    long timeUsed = r.curCpuTime - r.lastCpuTime;
                    pw.print(prefix);
                    pw.print("    ");
                    pw.print("run cpu over ");
                    TimeUtils.formatDuration(uptimeSince, pw);
                    pw.print(" used ");
                    TimeUtils.formatDuration(timeUsed, pw);
                    pw.print(" (");
                    pw.print((timeUsed * 100) / uptimeSince);
                    pw.println("%)");
                }
            }
        }
    }
    return true;
}
#method_after
private static final boolean dumpProcessOomList(PrintWriter pw, ActivityManagerService service, List<ProcessRecord> origList, String prefix, String normalLabel, String persistentLabel, boolean inclDetails, String dumpPackage) {
    ArrayList<Pair<ProcessRecord, Integer>> list = new ArrayList<Pair<ProcessRecord, Integer>>(origList.size());
    for (int i = 0; i < origList.size(); i++) {
        ProcessRecord r = origList.get(i);
        if (dumpPackage != null && !r.pkgList.containsKey(dumpPackage)) {
            continue;
        }
        list.add(new Pair<ProcessRecord, Integer>(origList.get(i), i));
    }
    if (list.size() <= 0) {
        return false;
    }
    Comparator<Pair<ProcessRecord, Integer>> comparator = new Comparator<Pair<ProcessRecord, Integer>>() {

        @Override
        public int compare(Pair<ProcessRecord, Integer> object1, Pair<ProcessRecord, Integer> object2) {
            if (object1.first.setAdj != object2.first.setAdj) {
                return object1.first.setAdj > object2.first.setAdj ? -1 : 1;
            }
            if (object1.first.setProcState != object2.first.setProcState) {
                return object1.first.setProcState > object2.first.setProcState ? -1 : 1;
            }
            if (object1.second.intValue() != object2.second.intValue()) {
                return object1.second.intValue() > object2.second.intValue() ? -1 : 1;
            }
            return 0;
        }
    };
    Collections.sort(list, comparator);
    final long curRealtime = SystemClock.elapsedRealtime();
    final long realtimeSince = curRealtime - service.mLastPowerCheckRealtime;
    final long curUptime = SystemClock.uptimeMillis();
    final long uptimeSince = curUptime - service.mLastPowerCheckUptime;
    for (int i = list.size() - 1; i >= 0; i--) {
        ProcessRecord r = list.get(i).first;
        String oomAdj = ProcessList.makeOomAdjString(r.setAdj);
        char schedGroup;
        switch(r.setSchedGroup) {
            case ProcessList.SCHED_GROUP_BACKGROUND:
                schedGroup = 'B';
                break;
            case ProcessList.SCHED_GROUP_DEFAULT:
                schedGroup = 'F';
                break;
            case ProcessList.SCHED_GROUP_TOP_APP:
                schedGroup = 'T';
                break;
            default:
                schedGroup = '?';
                break;
        }
        char foreground;
        if (r.foregroundActivities) {
            foreground = 'A';
        } else if (r.foregroundServices) {
            foreground = 'S';
        } else {
            foreground = ' ';
        }
        String procState = ProcessList.makeProcStateString(r.curProcState);
        pw.print(prefix);
        pw.print(r.persistent ? persistentLabel : normalLabel);
        pw.print(" #");
        int num = (origList.size() - 1) - list.get(i).second;
        if (num < 10)
            pw.print(' ');
        pw.print(num);
        pw.print(": ");
        pw.print(oomAdj);
        pw.print(' ');
        pw.print(schedGroup);
        pw.print('/');
        pw.print(foreground);
        pw.print('/');
        pw.print(procState);
        pw.print(" trm:");
        if (r.trimMemoryLevel < 10)
            pw.print(' ');
        pw.print(r.trimMemoryLevel);
        pw.print(' ');
        pw.print(r.toShortString());
        pw.print(" (");
        pw.print(r.adjType);
        pw.println(')');
        if (r.adjSource != null || r.adjTarget != null) {
            pw.print(prefix);
            pw.print("    ");
            if (r.adjTarget instanceof ComponentName) {
                pw.print(((ComponentName) r.adjTarget).flattenToShortString());
            } else if (r.adjTarget != null) {
                pw.print(r.adjTarget.toString());
            } else {
                pw.print("{null}");
            }
            pw.print("<=");
            if (r.adjSource instanceof ProcessRecord) {
                pw.print("Proc{");
                pw.print(((ProcessRecord) r.adjSource).toShortString());
                pw.println("}");
            } else if (r.adjSource != null) {
                pw.println(r.adjSource.toString());
            } else {
                pw.println("{null}");
            }
        }
        if (inclDetails) {
            pw.print(prefix);
            pw.print("    ");
            pw.print("oom: max=");
            pw.print(r.maxAdj);
            pw.print(" curRaw=");
            pw.print(r.curRawAdj);
            pw.print(" setRaw=");
            pw.print(r.setRawAdj);
            pw.print(" cur=");
            pw.print(r.curAdj);
            pw.print(" set=");
            pw.println(r.setAdj);
            pw.print(prefix);
            pw.print("    ");
            pw.print("state: cur=");
            pw.print(ProcessList.makeProcStateString(r.curProcState));
            pw.print(" set=");
            pw.print(ProcessList.makeProcStateString(r.setProcState));
            pw.print(" lastPss=");
            DebugUtils.printSizeValue(pw, r.lastPss * 1024);
            pw.print(" lastSwapPss=");
            DebugUtils.printSizeValue(pw, r.lastSwapPss * 1024);
            pw.print(" lastCachedPss=");
            DebugUtils.printSizeValue(pw, r.lastCachedPss * 1024);
            pw.println();
            pw.print(prefix);
            pw.print("    ");
            pw.print("cached=");
            pw.print(r.cached);
            pw.print(" empty=");
            pw.print(r.empty);
            pw.print(" hasAboveClient=");
            pw.println(r.hasAboveClient);
            if (r.setProcState >= ActivityManager.PROCESS_STATE_SERVICE) {
                if (r.lastWakeTime != 0) {
                    long wtime;
                    BatteryStatsImpl stats = service.mBatteryStatsService.getActiveStatistics();
                    synchronized (stats) {
                        wtime = stats.getProcessWakeTime(r.info.uid, r.pid, curRealtime);
                    }
                    long timeUsed = wtime - r.lastWakeTime;
                    pw.print(prefix);
                    pw.print("    ");
                    pw.print("keep awake over ");
                    TimeUtils.formatDuration(realtimeSince, pw);
                    pw.print(" used ");
                    TimeUtils.formatDuration(timeUsed, pw);
                    pw.print(" (");
                    pw.print((timeUsed * 100) / realtimeSince);
                    pw.println("%)");
                }
                if (r.lastCpuTime != 0) {
                    long timeUsed = r.curCpuTime - r.lastCpuTime;
                    pw.print(prefix);
                    pw.print("    ");
                    pw.print("run cpu over ");
                    TimeUtils.formatDuration(uptimeSince, pw);
                    pw.print(" used ");
                    TimeUtils.formatDuration(timeUsed, pw);
                    pw.print(" (");
                    pw.print((timeUsed * 100) / uptimeSince);
                    pw.println("%)");
                }
            }
        }
    }
    return true;
}
#end_block

#method_before
static final void dumpMemItems(PrintWriter pw, String prefix, String tag, ArrayList<MemItem> items, boolean sort, boolean isCompact) {
    if (sort && !isCompact) {
        Collections.sort(items, new Comparator<MemItem>() {

            @Override
            public int compare(MemItem lhs, MemItem rhs) {
                if (lhs.pss < rhs.pss) {
                    return 1;
                } else if (lhs.pss > rhs.pss) {
                    return -1;
                }
                return 0;
            }
        });
    }
    for (int i = 0; i < items.size(); i++) {
        MemItem mi = items.get(i);
        if (!isCompact) {
            pw.print(prefix);
            pw.printf("%7d kB: ", mi.pss);
            pw.println(mi.label);
        } else if (mi.isProc) {
            pw.print("proc,");
            pw.print(tag);
            pw.print(",");
            pw.print(mi.shortLabel);
            pw.print(",");
            pw.print(mi.id);
            pw.print(",");
            pw.print(mi.pss);
            pw.println(mi.hasActivities ? ",a" : ",e");
        } else {
            pw.print(tag);
            pw.print(",");
            pw.print(mi.shortLabel);
            pw.print(",");
            pw.println(mi.pss);
        }
        if (mi.subitems != null) {
            dumpMemItems(pw, prefix + "           ", mi.shortLabel, mi.subitems, true, isCompact);
        }
    }
}
#method_after
static final void dumpMemItems(PrintWriter pw, String prefix, String tag, ArrayList<MemItem> items, boolean sort, boolean isCompact, boolean dumpSwapPss) {
    if (sort && !isCompact) {
        Collections.sort(items, new Comparator<MemItem>() {

            @Override
            public int compare(MemItem lhs, MemItem rhs) {
                if (lhs.pss < rhs.pss) {
                    return 1;
                } else if (lhs.pss > rhs.pss) {
                    return -1;
                }
                return 0;
            }
        });
    }
    for (int i = 0; i < items.size(); i++) {
        MemItem mi = items.get(i);
        if (!isCompact) {
            if (dumpSwapPss) {
                pw.printf("%s%s: %-60s (%s in swap)\n", prefix, stringifyKBSize(mi.pss), mi.label, stringifyKBSize(mi.swapPss));
            } else {
                pw.printf("%s%s: %s\n", prefix, stringifyKBSize(mi.pss), mi.label);
            }
        } else if (mi.isProc) {
            pw.print("proc,");
            pw.print(tag);
            pw.print(",");
            pw.print(mi.shortLabel);
            pw.print(",");
            pw.print(mi.id);
            pw.print(",");
            pw.print(mi.pss);
            pw.print(",");
            pw.print(dumpSwapPss ? mi.swapPss : "N/A");
            pw.println(mi.hasActivities ? ",a" : ",e");
        } else {
            pw.print(tag);
            pw.print(",");
            pw.print(mi.shortLabel);
            pw.print(",");
            pw.print(mi.pss);
            pw.print(",");
            pw.println(dumpSwapPss ? mi.swapPss : "N/A");
        }
        if (mi.subitems != null) {
            dumpMemItems(pw, prefix + "    ", mi.shortLabel, mi.subitems, true, isCompact, dumpSwapPss);
        }
    }
}
#end_block

#method_before
private final void dumpApplicationMemoryUsageHeader(PrintWriter pw, long uptime, long realtime, boolean isCheckinRequest, boolean isCompact) {
    if (isCheckinRequest || isCompact) {
        // short checkin version
        pw.print("time,");
        pw.print(uptime);
        pw.print(",");
        pw.println(realtime);
    } else {
        pw.println("Applications Memory Usage (kB):");
        pw.println("Uptime: " + uptime + " Realtime: " + realtime);
    }
}
#method_after
private final void dumpApplicationMemoryUsageHeader(PrintWriter pw, long uptime, long realtime, boolean isCheckinRequest, boolean isCompact) {
    if (isCompact) {
        pw.print("version,");
        pw.println(MEMINFO_COMPACT_VERSION);
    }
    if (isCheckinRequest || isCompact) {
        // short checkin version
        pw.print("time,");
        pw.print(uptime);
        pw.print(",");
        pw.println(realtime);
    } else {
        pw.println("Applications Memory Usage (in Kilobytes):");
        pw.println("Uptime: " + uptime + " Realtime: " + realtime);
    }
}
#end_block

#method_before
final void dumpApplicationMemoryUsage(FileDescriptor fd, PrintWriter pw, String prefix, String[] args, boolean brief, PrintWriter categoryPw) {
    boolean dumpDetails = false;
    boolean dumpFullDetails = false;
    boolean dumpDalvik = false;
    boolean dumpSummaryOnly = false;
    boolean dumpUnreachable = false;
    boolean oomOnly = false;
    boolean isCompact = false;
    boolean localOnly = false;
    boolean packages = false;
    int opti = 0;
    while (opti < args.length) {
        String opt = args[opti];
        if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
            break;
        }
        opti++;
        if ("-a".equals(opt)) {
            dumpDetails = true;
            dumpFullDetails = true;
            dumpDalvik = true;
        } else if ("-d".equals(opt)) {
            dumpDalvik = true;
        } else if ("-c".equals(opt)) {
            isCompact = true;
        } else if ("-s".equals(opt)) {
            dumpDetails = true;
            dumpSummaryOnly = true;
        } else if ("--unreachable".equals(opt)) {
            dumpUnreachable = true;
        } else if ("--oom".equals(opt)) {
            oomOnly = true;
        } else if ("--local".equals(opt)) {
            localOnly = true;
        } else if ("--package".equals(opt)) {
            packages = true;
        } else if ("-h".equals(opt)) {
            pw.println("meminfo dump options: [-a] [-d] [-c] [-s] [--oom] [process]");
            pw.println("  -a: include all available information for each process.");
            pw.println("  -d: include dalvik details.");
            pw.println("  -c: dump in a compact machine-parseable representation.");
            pw.println("  -s: dump only summary of application memory usage.");
            pw.println("  --oom: only show processes organized by oom adj.");
            pw.println("  --local: only collect details locally, don't call process.");
            pw.println("  --package: interpret process arg as package, dumping all");
            pw.println("             processes that have loaded that package.");
            pw.println("If [process] is specified it can be the name or ");
            pw.println("pid of a specific process to dump.");
            return;
        } else {
            pw.println("Unknown argument: " + opt + "; use -h for help");
        }
    }
    final boolean isCheckinRequest = scanArgs(args, "--checkin");
    long uptime = SystemClock.uptimeMillis();
    long realtime = SystemClock.elapsedRealtime();
    final long[] tmpLong = new long[1];
    ArrayList<ProcessRecord> procs = collectProcesses(pw, opti, packages, args);
    if (procs == null) {
        // No Java processes.  Maybe they want to print a native process.
        if (args != null && args.length > opti && args[opti].charAt(0) != '-') {
            ArrayList<ProcessCpuTracker.Stats> nativeProcs = new ArrayList<ProcessCpuTracker.Stats>();
            updateCpuStatsNow();
            int findPid = -1;
            try {
                findPid = Integer.parseInt(args[opti]);
            } catch (NumberFormatException e) {
            }
            synchronized (mProcessCpuTracker) {
                final int N = mProcessCpuTracker.countStats();
                for (int i = 0; i < N; i++) {
                    ProcessCpuTracker.Stats st = mProcessCpuTracker.getStats(i);
                    if (st.pid == findPid || (st.baseName != null && st.baseName.equals(args[opti]))) {
                        nativeProcs.add(st);
                    }
                }
            }
            if (nativeProcs.size() > 0) {
                dumpApplicationMemoryUsageHeader(pw, uptime, realtime, isCheckinRequest, isCompact);
                Debug.MemoryInfo mi = null;
                for (int i = nativeProcs.size() - 1; i >= 0; i--) {
                    final ProcessCpuTracker.Stats r = nativeProcs.get(i);
                    final int pid = r.pid;
                    if (!isCheckinRequest && dumpDetails) {
                        pw.println("\n** MEMINFO in pid " + pid + " [" + r.baseName + "] **");
                    }
                    if (mi == null) {
                        mi = new Debug.MemoryInfo();
                    }
                    if (dumpDetails || (!brief && !oomOnly)) {
                        Debug.getMemoryInfo(pid, mi);
                    } else {
                        mi.dalvikPss = (int) Debug.getPss(pid, tmpLong, null);
                        mi.dalvikPrivateDirty = (int) tmpLong[0];
                    }
                    ActivityThread.dumpMemInfoTable(pw, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, pid, r.baseName, 0, 0, 0, 0, 0, 0);
                    if (isCheckinRequest) {
                        pw.println();
                    }
                }
                return;
            }
        }
        pw.println("No process found for: " + args[opti]);
        return;
    }
    if (!brief && !oomOnly && (procs.size() == 1 || isCheckinRequest || packages)) {
        dumpDetails = true;
    }
    dumpApplicationMemoryUsageHeader(pw, uptime, realtime, isCheckinRequest, isCompact);
    String[] innerArgs = new String[args.length - opti];
    System.arraycopy(args, opti, innerArgs, 0, args.length - opti);
    ArrayList<MemItem> procMems = new ArrayList<MemItem>();
    final SparseArray<MemItem> procMemsMap = new SparseArray<MemItem>();
    long nativePss = 0;
    long dalvikPss = 0;
    long[] dalvikSubitemPss = dumpDalvik ? new long[Debug.MemoryInfo.NUM_DVK_STATS] : EmptyArray.LONG;
    long otherPss = 0;
    long[] miscPss = new long[Debug.MemoryInfo.NUM_OTHER_STATS];
    long[] oomPss = new long[DUMP_MEM_OOM_LABEL.length];
    ArrayList<MemItem>[] oomProcs = (ArrayList<MemItem>[]) new ArrayList[DUMP_MEM_OOM_LABEL.length];
    long totalPss = 0;
    long cachedPss = 0;
    Debug.MemoryInfo mi = null;
    for (int i = procs.size() - 1; i >= 0; i--) {
        final ProcessRecord r = procs.get(i);
        final IApplicationThread thread;
        final int pid;
        final int oomAdj;
        final boolean hasActivities;
        synchronized (this) {
            thread = r.thread;
            pid = r.pid;
            oomAdj = r.getSetAdjWithServices();
            hasActivities = r.activities.size() > 0;
        }
        if (thread != null) {
            if (!isCheckinRequest && dumpDetails) {
                pw.println("\n** MEMINFO in pid " + pid + " [" + r.processName + "] **");
            }
            if (mi == null) {
                mi = new Debug.MemoryInfo();
            }
            if (dumpDetails || (!brief && !oomOnly)) {
                Debug.getMemoryInfo(pid, mi);
            } else {
                mi.dalvikPss = (int) Debug.getPss(pid, tmpLong, null);
                mi.dalvikPrivateDirty = (int) tmpLong[0];
            }
            if (dumpDetails) {
                if (localOnly) {
                    ActivityThread.dumpMemInfoTable(pw, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, pid, r.processName, 0, 0, 0, 0, 0, 0);
                    if (isCheckinRequest) {
                        pw.println();
                    }
                } else {
                    try {
                        pw.flush();
                        thread.dumpMemInfo(fd, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, dumpUnreachable, innerArgs);
                    } catch (RemoteException e) {
                        if (!isCheckinRequest) {
                            pw.println("Got RemoteException!");
                            pw.flush();
                        }
                    }
                }
            }
            final long myTotalPss = mi.getTotalPss();
            final long myTotalUss = mi.getTotalUss();
            synchronized (this) {
                if (r.thread != null && oomAdj == r.getSetAdjWithServices()) {
                    // Record this for posterity if the process has been stable.
                    r.baseProcessTracker.addPss(myTotalPss, myTotalUss, true, r.pkgList);
                }
            }
            if (!isCheckinRequest && mi != null) {
                totalPss += myTotalPss;
                MemItem pssItem = new MemItem(r.processName + " (pid " + pid + (hasActivities ? " / activities)" : ")"), r.processName, myTotalPss, pid, hasActivities);
                procMems.add(pssItem);
                procMemsMap.put(pid, pssItem);
                nativePss += mi.nativePss;
                dalvikPss += mi.dalvikPss;
                for (int j = 0; j < dalvikSubitemPss.length; j++) {
                    dalvikSubitemPss[j] += mi.getOtherPss(Debug.MemoryInfo.NUM_OTHER_STATS + j);
                }
                otherPss += mi.otherPss;
                for (int j = 0; j < Debug.MemoryInfo.NUM_OTHER_STATS; j++) {
                    long mem = mi.getOtherPss(j);
                    miscPss[j] += mem;
                    otherPss -= mem;
                }
                if (oomAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
                    cachedPss += myTotalPss;
                }
                for (int oomIndex = 0; oomIndex < oomPss.length; oomIndex++) {
                    if (oomAdj <= DUMP_MEM_OOM_ADJ[oomIndex] || oomIndex == (oomPss.length - 1)) {
                        oomPss[oomIndex] += myTotalPss;
                        if (oomProcs[oomIndex] == null) {
                            oomProcs[oomIndex] = new ArrayList<MemItem>();
                        }
                        oomProcs[oomIndex].add(pssItem);
                        break;
                    }
                }
            }
        }
    }
    long nativeProcTotalPss = 0;
    if (!isCheckinRequest && procs.size() > 1 && !packages) {
        // If we are showing aggregations, also look for native processes to
        // include so that our aggregations are more accurate.
        updateCpuStatsNow();
        mi = null;
        synchronized (mProcessCpuTracker) {
            final int N = mProcessCpuTracker.countStats();
            for (int i = 0; i < N; i++) {
                ProcessCpuTracker.Stats st = mProcessCpuTracker.getStats(i);
                if (st.vsize > 0 && procMemsMap.indexOfKey(st.pid) < 0) {
                    if (mi == null) {
                        mi = new Debug.MemoryInfo();
                    }
                    if (!brief && !oomOnly) {
                        Debug.getMemoryInfo(st.pid, mi);
                    } else {
                        mi.nativePss = (int) Debug.getPss(st.pid, tmpLong, null);
                        mi.nativePrivateDirty = (int) tmpLong[0];
                    }
                    final long myTotalPss = mi.getTotalPss();
                    totalPss += myTotalPss;
                    nativeProcTotalPss += myTotalPss;
                    MemItem pssItem = new MemItem(st.name + " (pid " + st.pid + ")", st.name, myTotalPss, st.pid, false);
                    procMems.add(pssItem);
                    nativePss += mi.nativePss;
                    dalvikPss += mi.dalvikPss;
                    for (int j = 0; j < dalvikSubitemPss.length; j++) {
                        dalvikSubitemPss[j] += mi.getOtherPss(Debug.MemoryInfo.NUM_OTHER_STATS + j);
                    }
                    otherPss += mi.otherPss;
                    for (int j = 0; j < Debug.MemoryInfo.NUM_OTHER_STATS; j++) {
                        long mem = mi.getOtherPss(j);
                        miscPss[j] += mem;
                        otherPss -= mem;
                    }
                    oomPss[0] += myTotalPss;
                    if (oomProcs[0] == null) {
                        oomProcs[0] = new ArrayList<MemItem>();
                    }
                    oomProcs[0].add(pssItem);
                }
            }
        }
        ArrayList<MemItem> catMems = new ArrayList<MemItem>();
        catMems.add(new MemItem("Native", "Native", nativePss, -1));
        final MemItem dalvikItem = new MemItem("Dalvik", "Dalvik", dalvikPss, -2);
        if (dalvikSubitemPss.length > 0) {
            dalvikItem.subitems = new ArrayList<MemItem>();
            for (int j = 0; j < dalvikSubitemPss.length; j++) {
                final String name = Debug.MemoryInfo.getOtherLabel(Debug.MemoryInfo.NUM_OTHER_STATS + j);
                dalvikItem.subitems.add(new MemItem(name, name, dalvikSubitemPss[j], j));
            }
        }
        catMems.add(dalvikItem);
        catMems.add(new MemItem("Unknown", "Unknown", otherPss, -3));
        for (int j = 0; j < Debug.MemoryInfo.NUM_OTHER_STATS; j++) {
            String label = Debug.MemoryInfo.getOtherLabel(j);
            catMems.add(new MemItem(label, label, miscPss[j], j));
        }
        ArrayList<MemItem> oomMems = new ArrayList<MemItem>();
        for (int j = 0; j < oomPss.length; j++) {
            if (oomPss[j] != 0) {
                String label = isCompact ? DUMP_MEM_OOM_COMPACT_LABEL[j] : DUMP_MEM_OOM_LABEL[j];
                MemItem item = new MemItem(label, label, oomPss[j], DUMP_MEM_OOM_ADJ[j]);
                item.subitems = oomProcs[j];
                oomMems.add(item);
            }
        }
        if (!brief && !oomOnly && !isCompact) {
            pw.println();
            pw.println("Total PSS by process:");
            dumpMemItems(pw, "  ", "proc", procMems, true, isCompact);
            pw.println();
        }
        if (!isCompact) {
            pw.println("Total PSS by OOM adjustment:");
        }
        dumpMemItems(pw, "  ", "oom", oomMems, false, isCompact);
        if (!brief && !oomOnly) {
            PrintWriter out = categoryPw != null ? categoryPw : pw;
            if (!isCompact) {
                out.println();
                out.println("Total PSS by category:");
            }
            dumpMemItems(out, "  ", "cat", catMems, true, isCompact);
        }
        if (!isCompact) {
            pw.println();
        }
        MemInfoReader memInfo = new MemInfoReader();
        memInfo.readMemInfo();
        if (nativeProcTotalPss > 0) {
            synchronized (this) {
                final long cachedKb = memInfo.getCachedSizeKb();
                final long freeKb = memInfo.getFreeSizeKb();
                final long zramKb = memInfo.getZramTotalSizeKb();
                final long kernelKb = memInfo.getKernelUsedSizeKb();
                EventLogTags.writeAmMeminfo(cachedKb * 1024, freeKb * 1024, zramKb * 1024, kernelKb * 1024, nativeProcTotalPss * 1024);
                mProcessStats.addSysMemUsageLocked(cachedKb, freeKb, zramKb, kernelKb, nativeProcTotalPss);
            }
        }
        if (!brief) {
            if (!isCompact) {
                pw.print("Total RAM: ");
                pw.print(memInfo.getTotalSizeKb());
                pw.print(" kB (status ");
                switch(mLastMemoryLevel) {
                    case ProcessStats.ADJ_MEM_FACTOR_NORMAL:
                        pw.println("normal)");
                        break;
                    case ProcessStats.ADJ_MEM_FACTOR_MODERATE:
                        pw.println("moderate)");
                        break;
                    case ProcessStats.ADJ_MEM_FACTOR_LOW:
                        pw.println("low)");
                        break;
                    case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
                        pw.println("critical)");
                        break;
                    default:
                        pw.print(mLastMemoryLevel);
                        pw.println(")");
                        break;
                }
                pw.print(" Free RAM: ");
                pw.print(cachedPss + memInfo.getCachedSizeKb() + memInfo.getFreeSizeKb());
                pw.print(" kB (");
                pw.print(cachedPss);
                pw.print(" cached pss + ");
                pw.print(memInfo.getCachedSizeKb());
                pw.print(" cached kernel + ");
                pw.print(memInfo.getFreeSizeKb());
                pw.println(" free)");
            } else {
                pw.print("ram,");
                pw.print(memInfo.getTotalSizeKb());
                pw.print(",");
                pw.print(cachedPss + memInfo.getCachedSizeKb() + memInfo.getFreeSizeKb());
                pw.print(",");
                pw.println(totalPss - cachedPss);
            }
        }
        if (!isCompact) {
            pw.print(" Used RAM: ");
            pw.print(totalPss - cachedPss + memInfo.getKernelUsedSizeKb());
            pw.print(" kB (");
            pw.print(totalPss - cachedPss);
            pw.print(" used pss + ");
            pw.print(memInfo.getKernelUsedSizeKb());
            pw.print(" kernel)\n");
            pw.print(" Lost RAM: ");
            pw.print(memInfo.getTotalSizeKb() - totalPss - memInfo.getFreeSizeKb() - memInfo.getCachedSizeKb() - memInfo.getKernelUsedSizeKb());
            pw.println(" kB");
        } else {
            pw.print("lostram,");
            pw.println(memInfo.getTotalSizeKb() - totalPss - memInfo.getFreeSizeKb() - memInfo.getCachedSizeKb() - memInfo.getKernelUsedSizeKb());
        }
        if (!brief) {
            if (memInfo.getZramTotalSizeKb() != 0) {
                if (!isCompact) {
                    pw.print("     ZRAM: ");
                    pw.print(memInfo.getZramTotalSizeKb());
                    pw.print(" kB physical used for ");
                    pw.print(memInfo.getSwapTotalSizeKb() - memInfo.getSwapFreeSizeKb());
                    pw.print(" kB in swap (");
                    pw.print(memInfo.getSwapTotalSizeKb());
                    pw.println(" kB total swap)");
                } else {
                    pw.print("zram,");
                    pw.print(memInfo.getZramTotalSizeKb());
                    pw.print(",");
                    pw.print(memInfo.getSwapTotalSizeKb());
                    pw.print(",");
                    pw.println(memInfo.getSwapFreeSizeKb());
                }
            }
            final long[] ksm = getKsmInfo();
            if (!isCompact) {
                if (ksm[KSM_SHARING] != 0 || ksm[KSM_SHARED] != 0 || ksm[KSM_UNSHARED] != 0 || ksm[KSM_VOLATILE] != 0) {
                    pw.print("      KSM: ");
                    pw.print(ksm[KSM_SHARING]);
                    pw.print(" kB saved from shared ");
                    pw.print(ksm[KSM_SHARED]);
                    pw.println(" kB");
                    pw.print("           ");
                    pw.print(ksm[KSM_UNSHARED]);
                    pw.print(" kB unshared; ");
                    pw.print(ksm[KSM_VOLATILE]);
                    pw.println(" kB volatile");
                }
                pw.print("   Tuning: ");
                pw.print(ActivityManager.staticGetMemoryClass());
                pw.print(" (large ");
                pw.print(ActivityManager.staticGetLargeMemoryClass());
                pw.print("), oom ");
                pw.print(mProcessList.getMemLevel(ProcessList.CACHED_APP_MAX_ADJ) / 1024);
                pw.print(" kB");
                pw.print(", restore limit ");
                pw.print(mProcessList.getCachedRestoreThresholdKb());
                pw.print(" kB");
                if (ActivityManager.isLowRamDeviceStatic()) {
                    pw.print(" (low-ram)");
                }
                if (ActivityManager.isHighEndGfx()) {
                    pw.print(" (high-end-gfx)");
                }
                pw.println();
            } else {
                pw.print("ksm,");
                pw.print(ksm[KSM_SHARING]);
                pw.print(",");
                pw.print(ksm[KSM_SHARED]);
                pw.print(",");
                pw.print(ksm[KSM_UNSHARED]);
                pw.print(",");
                pw.println(ksm[KSM_VOLATILE]);
                pw.print("tuning,");
                pw.print(ActivityManager.staticGetMemoryClass());
                pw.print(',');
                pw.print(ActivityManager.staticGetLargeMemoryClass());
                pw.print(',');
                pw.print(mProcessList.getMemLevel(ProcessList.CACHED_APP_MAX_ADJ) / 1024);
                if (ActivityManager.isLowRamDeviceStatic()) {
                    pw.print(",low-ram");
                }
                if (ActivityManager.isHighEndGfx()) {
                    pw.print(",high-end-gfx");
                }
                pw.println();
            }
        }
    }
}
#method_after
final void dumpApplicationMemoryUsage(FileDescriptor fd, PrintWriter pw, String prefix, String[] args, boolean brief, PrintWriter categoryPw) {
    boolean dumpDetails = false;
    boolean dumpFullDetails = false;
    boolean dumpDalvik = false;
    boolean dumpSummaryOnly = false;
    boolean dumpUnreachable = false;
    boolean oomOnly = false;
    boolean isCompact = false;
    boolean localOnly = false;
    boolean packages = false;
    boolean isCheckinRequest = false;
    boolean dumpSwapPss = false;
    int opti = 0;
    while (opti < args.length) {
        String opt = args[opti];
        if (opt == null || opt.length() <= 0 || opt.charAt(0) != '-') {
            break;
        }
        opti++;
        if ("-a".equals(opt)) {
            dumpDetails = true;
            dumpFullDetails = true;
            dumpDalvik = true;
            dumpSwapPss = true;
        } else if ("-d".equals(opt)) {
            dumpDalvik = true;
        } else if ("-c".equals(opt)) {
            isCompact = true;
        } else if ("-s".equals(opt)) {
            dumpDetails = true;
            dumpSummaryOnly = true;
        } else if ("-S".equals(opt)) {
            dumpSwapPss = true;
        } else if ("--unreachable".equals(opt)) {
            dumpUnreachable = true;
        } else if ("--oom".equals(opt)) {
            oomOnly = true;
        } else if ("--local".equals(opt)) {
            localOnly = true;
        } else if ("--package".equals(opt)) {
            packages = true;
        } else if ("--checkin".equals(opt)) {
            isCheckinRequest = true;
        } else if ("-h".equals(opt)) {
            pw.println("meminfo dump options: [-a] [-d] [-c] [-s] [--oom] [process]");
            pw.println("  -a: include all available information for each process.");
            pw.println("  -d: include dalvik details.");
            pw.println("  -c: dump in a compact machine-parseable representation.");
            pw.println("  -s: dump only summary of application memory usage.");
            pw.println("  -S: dump also SwapPss.");
            pw.println("  --oom: only show processes organized by oom adj.");
            pw.println("  --local: only collect details locally, don't call process.");
            pw.println("  --package: interpret process arg as package, dumping all");
            pw.println("             processes that have loaded that package.");
            pw.println("  --checkin: dump data for a checkin");
            pw.println("If [process] is specified it can be the name or ");
            pw.println("pid of a specific process to dump.");
            return;
        } else {
            pw.println("Unknown argument: " + opt + "; use -h for help");
        }
    }
    long uptime = SystemClock.uptimeMillis();
    long realtime = SystemClock.elapsedRealtime();
    final long[] tmpLong = new long[1];
    ArrayList<ProcessRecord> procs = collectProcesses(pw, opti, packages, args);
    if (procs == null) {
        // No Java processes.  Maybe they want to print a native process.
        if (args != null && args.length > opti && args[opti].charAt(0) != '-') {
            ArrayList<ProcessCpuTracker.Stats> nativeProcs = new ArrayList<ProcessCpuTracker.Stats>();
            updateCpuStatsNow();
            int findPid = -1;
            try {
                findPid = Integer.parseInt(args[opti]);
            } catch (NumberFormatException e) {
            }
            synchronized (mProcessCpuTracker) {
                final int N = mProcessCpuTracker.countStats();
                for (int i = 0; i < N; i++) {
                    ProcessCpuTracker.Stats st = mProcessCpuTracker.getStats(i);
                    if (st.pid == findPid || (st.baseName != null && st.baseName.equals(args[opti]))) {
                        nativeProcs.add(st);
                    }
                }
            }
            if (nativeProcs.size() > 0) {
                dumpApplicationMemoryUsageHeader(pw, uptime, realtime, isCheckinRequest, isCompact);
                Debug.MemoryInfo mi = null;
                for (int i = nativeProcs.size() - 1; i >= 0; i--) {
                    final ProcessCpuTracker.Stats r = nativeProcs.get(i);
                    final int pid = r.pid;
                    if (!isCheckinRequest && dumpDetails) {
                        pw.println("\n** MEMINFO in pid " + pid + " [" + r.baseName + "] **");
                    }
                    if (mi == null) {
                        mi = new Debug.MemoryInfo();
                    }
                    if (dumpDetails || (!brief && !oomOnly)) {
                        Debug.getMemoryInfo(pid, mi);
                    } else {
                        mi.dalvikPss = (int) Debug.getPss(pid, tmpLong, null);
                        mi.dalvikPrivateDirty = (int) tmpLong[0];
                    }
                    ActivityThread.dumpMemInfoTable(pw, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, pid, r.baseName, 0, 0, 0, 0, 0, 0);
                    if (isCheckinRequest) {
                        pw.println();
                    }
                }
                return;
            }
        }
        pw.println("No process found for: " + args[opti]);
        return;
    }
    if (!brief && !oomOnly && (procs.size() == 1 || isCheckinRequest || packages)) {
        dumpDetails = true;
    }
    dumpApplicationMemoryUsageHeader(pw, uptime, realtime, isCheckinRequest, isCompact);
    String[] innerArgs = new String[args.length - opti];
    System.arraycopy(args, opti, innerArgs, 0, args.length - opti);
    ArrayList<MemItem> procMems = new ArrayList<MemItem>();
    final SparseArray<MemItem> procMemsMap = new SparseArray<MemItem>();
    long nativePss = 0;
    long nativeSwapPss = 0;
    long dalvikPss = 0;
    long dalvikSwapPss = 0;
    long[] dalvikSubitemPss = dumpDalvik ? new long[Debug.MemoryInfo.NUM_DVK_STATS] : EmptyArray.LONG;
    long[] dalvikSubitemSwapPss = dumpDalvik ? new long[Debug.MemoryInfo.NUM_DVK_STATS] : EmptyArray.LONG;
    long otherPss = 0;
    long otherSwapPss = 0;
    long[] miscPss = new long[Debug.MemoryInfo.NUM_OTHER_STATS];
    long[] miscSwapPss = new long[Debug.MemoryInfo.NUM_OTHER_STATS];
    long[] oomPss = new long[DUMP_MEM_OOM_LABEL.length];
    long[] oomSwapPss = new long[DUMP_MEM_OOM_LABEL.length];
    ArrayList<MemItem>[] oomProcs = (ArrayList<MemItem>[]) new ArrayList[DUMP_MEM_OOM_LABEL.length];
    long totalPss = 0;
    long totalSwapPss = 0;
    long cachedPss = 0;
    long cachedSwapPss = 0;
    boolean hasSwapPss = false;
    Debug.MemoryInfo mi = null;
    for (int i = procs.size() - 1; i >= 0; i--) {
        final ProcessRecord r = procs.get(i);
        final IApplicationThread thread;
        final int pid;
        final int oomAdj;
        final boolean hasActivities;
        synchronized (this) {
            thread = r.thread;
            pid = r.pid;
            oomAdj = r.getSetAdjWithServices();
            hasActivities = r.activities.size() > 0;
        }
        if (thread != null) {
            if (!isCheckinRequest && dumpDetails) {
                pw.println("\n** MEMINFO in pid " + pid + " [" + r.processName + "] **");
            }
            if (mi == null) {
                mi = new Debug.MemoryInfo();
            }
            if (dumpDetails || (!brief && !oomOnly)) {
                Debug.getMemoryInfo(pid, mi);
                hasSwapPss = mi.hasSwappedOutPss;
            } else {
                mi.dalvikPss = (int) Debug.getPss(pid, tmpLong, null);
                mi.dalvikPrivateDirty = (int) tmpLong[0];
            }
            if (dumpDetails) {
                if (localOnly) {
                    ActivityThread.dumpMemInfoTable(pw, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, pid, r.processName, 0, 0, 0, 0, 0, 0);
                    if (isCheckinRequest) {
                        pw.println();
                    }
                } else {
                    try {
                        pw.flush();
                        thread.dumpMemInfo(fd, mi, isCheckinRequest, dumpFullDetails, dumpDalvik, dumpSummaryOnly, dumpUnreachable, innerArgs);
                    } catch (RemoteException e) {
                        if (!isCheckinRequest) {
                            pw.println("Got RemoteException!");
                            pw.flush();
                        }
                    }
                }
            }
            final long myTotalPss = mi.getTotalPss();
            final long myTotalUss = mi.getTotalUss();
            final long myTotalSwapPss = mi.getTotalSwappedOutPss();
            synchronized (this) {
                if (r.thread != null && oomAdj == r.getSetAdjWithServices()) {
                    // Record this for posterity if the process has been stable.
                    r.baseProcessTracker.addPss(myTotalPss, myTotalUss, true, r.pkgList);
                }
            }
            if (!isCheckinRequest && mi != null) {
                totalPss += myTotalPss;
                totalSwapPss += myTotalSwapPss;
                MemItem pssItem = new MemItem(r.processName + " (pid " + pid + (hasActivities ? " / activities)" : ")"), r.processName, myTotalPss, myTotalSwapPss, pid, hasActivities);
                procMems.add(pssItem);
                procMemsMap.put(pid, pssItem);
                nativePss += mi.nativePss;
                nativeSwapPss += mi.nativeSwappedOutPss;
                dalvikPss += mi.dalvikPss;
                dalvikSwapPss += mi.dalvikSwappedOutPss;
                for (int j = 0; j < dalvikSubitemPss.length; j++) {
                    dalvikSubitemPss[j] += mi.getOtherPss(Debug.MemoryInfo.NUM_OTHER_STATS + j);
                    dalvikSubitemSwapPss[j] += mi.getOtherSwappedOutPss(Debug.MemoryInfo.NUM_OTHER_STATS + j);
                }
                otherPss += mi.otherPss;
                otherSwapPss += mi.otherSwappedOutPss;
                for (int j = 0; j < Debug.MemoryInfo.NUM_OTHER_STATS; j++) {
                    long mem = mi.getOtherPss(j);
                    miscPss[j] += mem;
                    otherPss -= mem;
                    mem = mi.getOtherSwappedOutPss(j);
                    miscSwapPss[j] += mem;
                    otherSwapPss -= mem;
                }
                if (oomAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
                    cachedPss += myTotalPss;
                    cachedSwapPss += myTotalSwapPss;
                }
                for (int oomIndex = 0; oomIndex < oomPss.length; oomIndex++) {
                    if (oomIndex == (oomPss.length - 1) || (oomAdj >= DUMP_MEM_OOM_ADJ[oomIndex] && oomAdj < DUMP_MEM_OOM_ADJ[oomIndex + 1])) {
                        oomPss[oomIndex] += myTotalPss;
                        oomSwapPss[oomIndex] += myTotalSwapPss;
                        if (oomProcs[oomIndex] == null) {
                            oomProcs[oomIndex] = new ArrayList<MemItem>();
                        }
                        oomProcs[oomIndex].add(pssItem);
                        break;
                    }
                }
            }
        }
    }
    long nativeProcTotalPss = 0;
    if (!isCheckinRequest && procs.size() > 1 && !packages) {
        // If we are showing aggregations, also look for native processes to
        // include so that our aggregations are more accurate.
        updateCpuStatsNow();
        mi = null;
        synchronized (mProcessCpuTracker) {
            final int N = mProcessCpuTracker.countStats();
            for (int i = 0; i < N; i++) {
                ProcessCpuTracker.Stats st = mProcessCpuTracker.getStats(i);
                if (st.vsize > 0 && procMemsMap.indexOfKey(st.pid) < 0) {
                    if (mi == null) {
                        mi = new Debug.MemoryInfo();
                    }
                    if (!brief && !oomOnly) {
                        Debug.getMemoryInfo(st.pid, mi);
                    } else {
                        mi.nativePss = (int) Debug.getPss(st.pid, tmpLong, null);
                        mi.nativePrivateDirty = (int) tmpLong[0];
                    }
                    final long myTotalPss = mi.getTotalPss();
                    final long myTotalSwapPss = mi.getTotalSwappedOutPss();
                    totalPss += myTotalPss;
                    nativeProcTotalPss += myTotalPss;
                    MemItem pssItem = new MemItem(st.name + " (pid " + st.pid + ")", st.name, myTotalPss, mi.getSummaryTotalSwapPss(), st.pid, false);
                    procMems.add(pssItem);
                    nativePss += mi.nativePss;
                    nativeSwapPss += mi.nativeSwappedOutPss;
                    dalvikPss += mi.dalvikPss;
                    dalvikSwapPss += mi.dalvikSwappedOutPss;
                    for (int j = 0; j < dalvikSubitemPss.length; j++) {
                        dalvikSubitemPss[j] += mi.getOtherPss(Debug.MemoryInfo.NUM_OTHER_STATS + j);
                        dalvikSubitemSwapPss[j] += mi.getOtherSwappedOutPss(Debug.MemoryInfo.NUM_OTHER_STATS + j);
                    }
                    otherPss += mi.otherPss;
                    otherSwapPss += mi.otherSwappedOutPss;
                    for (int j = 0; j < Debug.MemoryInfo.NUM_OTHER_STATS; j++) {
                        long mem = mi.getOtherPss(j);
                        miscPss[j] += mem;
                        otherPss -= mem;
                        mem = mi.getOtherSwappedOutPss(j);
                        miscSwapPss[j] += mem;
                        otherSwapPss -= mem;
                    }
                    oomPss[0] += myTotalPss;
                    oomSwapPss[0] += myTotalSwapPss;
                    if (oomProcs[0] == null) {
                        oomProcs[0] = new ArrayList<MemItem>();
                    }
                    oomProcs[0].add(pssItem);
                }
            }
        }
        ArrayList<MemItem> catMems = new ArrayList<MemItem>();
        catMems.add(new MemItem("Native", "Native", nativePss, nativeSwapPss, -1));
        final MemItem dalvikItem = new MemItem("Dalvik", "Dalvik", dalvikPss, dalvikSwapPss, -2);
        if (dalvikSubitemPss.length > 0) {
            dalvikItem.subitems = new ArrayList<MemItem>();
            for (int j = 0; j < dalvikSubitemPss.length; j++) {
                final String name = Debug.MemoryInfo.getOtherLabel(Debug.MemoryInfo.NUM_OTHER_STATS + j);
                dalvikItem.subitems.add(new MemItem(name, name, dalvikSubitemPss[j], dalvikSubitemSwapPss[j], j));
            }
        }
        catMems.add(dalvikItem);
        catMems.add(new MemItem("Unknown", "Unknown", otherPss, otherSwapPss, -3));
        for (int j = 0; j < Debug.MemoryInfo.NUM_OTHER_STATS; j++) {
            String label = Debug.MemoryInfo.getOtherLabel(j);
            catMems.add(new MemItem(label, label, miscPss[j], miscSwapPss[j], j));
        }
        ArrayList<MemItem> oomMems = new ArrayList<MemItem>();
        for (int j = 0; j < oomPss.length; j++) {
            if (oomPss[j] != 0) {
                String label = isCompact ? DUMP_MEM_OOM_COMPACT_LABEL[j] : DUMP_MEM_OOM_LABEL[j];
                MemItem item = new MemItem(label, label, oomPss[j], oomSwapPss[j], DUMP_MEM_OOM_ADJ[j]);
                item.subitems = oomProcs[j];
                oomMems.add(item);
            }
        }
        dumpSwapPss = dumpSwapPss && hasSwapPss && totalSwapPss != 0;
        if (!brief && !oomOnly && !isCompact) {
            pw.println();
            pw.println("Total PSS by process:");
            dumpMemItems(pw, "  ", "proc", procMems, true, isCompact, dumpSwapPss);
            pw.println();
        }
        if (!isCompact) {
            pw.println("Total PSS by OOM adjustment:");
        }
        dumpMemItems(pw, "  ", "oom", oomMems, false, isCompact, dumpSwapPss);
        if (!brief && !oomOnly) {
            PrintWriter out = categoryPw != null ? categoryPw : pw;
            if (!isCompact) {
                out.println();
                out.println("Total PSS by category:");
            }
            dumpMemItems(out, "  ", "cat", catMems, true, isCompact, dumpSwapPss);
        }
        if (!isCompact) {
            pw.println();
        }
        MemInfoReader memInfo = new MemInfoReader();
        memInfo.readMemInfo();
        if (nativeProcTotalPss > 0) {
            synchronized (this) {
                final long cachedKb = memInfo.getCachedSizeKb();
                final long freeKb = memInfo.getFreeSizeKb();
                final long zramKb = memInfo.getZramTotalSizeKb();
                final long kernelKb = memInfo.getKernelUsedSizeKb();
                EventLogTags.writeAmMeminfo(cachedKb * 1024, freeKb * 1024, zramKb * 1024, kernelKb * 1024, nativeProcTotalPss * 1024);
                mProcessStats.addSysMemUsageLocked(cachedKb, freeKb, zramKb, kernelKb, nativeProcTotalPss);
            }
        }
        if (!brief) {
            if (!isCompact) {
                pw.print("Total RAM: ");
                pw.print(stringifyKBSize(memInfo.getTotalSizeKb()));
                pw.print(" (status ");
                switch(mLastMemoryLevel) {
                    case ProcessStats.ADJ_MEM_FACTOR_NORMAL:
                        pw.println("normal)");
                        break;
                    case ProcessStats.ADJ_MEM_FACTOR_MODERATE:
                        pw.println("moderate)");
                        break;
                    case ProcessStats.ADJ_MEM_FACTOR_LOW:
                        pw.println("low)");
                        break;
                    case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
                        pw.println("critical)");
                        break;
                    default:
                        pw.print(mLastMemoryLevel);
                        pw.println(")");
                        break;
                }
                pw.print(" Free RAM: ");
                pw.print(stringifyKBSize(cachedPss + memInfo.getCachedSizeKb() + memInfo.getFreeSizeKb()));
                pw.print(" (");
                pw.print(stringifyKBSize(cachedPss));
                pw.print(" cached pss + ");
                pw.print(stringifyKBSize(memInfo.getCachedSizeKb()));
                pw.print(" cached kernel + ");
                pw.print(stringifyKBSize(memInfo.getFreeSizeKb()));
                pw.println(" free)");
            } else {
                pw.print("ram,");
                pw.print(memInfo.getTotalSizeKb());
                pw.print(",");
                pw.print(cachedPss + memInfo.getCachedSizeKb() + memInfo.getFreeSizeKb());
                pw.print(",");
                pw.println(totalPss - cachedPss);
            }
        }
        long lostRAM = memInfo.getTotalSizeKb() - (totalPss - totalSwapPss) - memInfo.getFreeSizeKb() - memInfo.getCachedSizeKb() - memInfo.getKernelUsedSizeKb() - memInfo.getZramTotalSizeKb();
        if (!isCompact) {
            pw.print(" Used RAM: ");
            pw.print(stringifyKBSize(totalPss - cachedPss + memInfo.getKernelUsedSizeKb()));
            pw.print(" (");
            pw.print(stringifyKBSize(totalPss - cachedPss));
            pw.print(" used pss + ");
            pw.print(stringifyKBSize(memInfo.getKernelUsedSizeKb()));
            pw.print(" kernel)\n");
            pw.print(" Lost RAM: ");
            pw.println(stringifyKBSize(lostRAM));
        } else {
            pw.print("lostram,");
            pw.println(lostRAM);
        }
        if (!brief) {
            if (memInfo.getZramTotalSizeKb() != 0) {
                if (!isCompact) {
                    pw.print("     ZRAM: ");
                    pw.print(stringifyKBSize(memInfo.getZramTotalSizeKb()));
                    pw.print(" physical used for ");
                    pw.print(stringifyKBSize(memInfo.getSwapTotalSizeKb() - memInfo.getSwapFreeSizeKb()));
                    pw.print(" in swap (");
                    pw.print(stringifyKBSize(memInfo.getSwapTotalSizeKb()));
                    pw.println(" total swap)");
                } else {
                    pw.print("zram,");
                    pw.print(memInfo.getZramTotalSizeKb());
                    pw.print(",");
                    pw.print(memInfo.getSwapTotalSizeKb());
                    pw.print(",");
                    pw.println(memInfo.getSwapFreeSizeKb());
                }
            }
            final long[] ksm = getKsmInfo();
            if (!isCompact) {
                if (ksm[KSM_SHARING] != 0 || ksm[KSM_SHARED] != 0 || ksm[KSM_UNSHARED] != 0 || ksm[KSM_VOLATILE] != 0) {
                    pw.print("      KSM: ");
                    pw.print(stringifyKBSize(ksm[KSM_SHARING]));
                    pw.print(" saved from shared ");
                    pw.print(stringifyKBSize(ksm[KSM_SHARED]));
                    pw.print("           ");
                    pw.print(stringifyKBSize(ksm[KSM_UNSHARED]));
                    pw.print(" unshared; ");
                    pw.print(stringifyKBSize(ksm[KSM_VOLATILE]));
                    pw.println(" volatile");
                }
                pw.print("   Tuning: ");
                pw.print(ActivityManager.staticGetMemoryClass());
                pw.print(" (large ");
                pw.print(ActivityManager.staticGetLargeMemoryClass());
                pw.print("), oom ");
                pw.print(stringifySize(mProcessList.getMemLevel(ProcessList.CACHED_APP_MAX_ADJ), 1024));
                pw.print(", restore limit ");
                pw.print(stringifyKBSize(mProcessList.getCachedRestoreThresholdKb()));
                if (ActivityManager.isLowRamDeviceStatic()) {
                    pw.print(" (low-ram)");
                }
                if (ActivityManager.isHighEndGfx()) {
                    pw.print(" (high-end-gfx)");
                }
                pw.println();
            } else {
                pw.print("ksm,");
                pw.print(ksm[KSM_SHARING]);
                pw.print(",");
                pw.print(ksm[KSM_SHARED]);
                pw.print(",");
                pw.print(ksm[KSM_UNSHARED]);
                pw.print(",");
                pw.println(ksm[KSM_VOLATILE]);
                pw.print("tuning,");
                pw.print(ActivityManager.staticGetMemoryClass());
                pw.print(',');
                pw.print(ActivityManager.staticGetLargeMemoryClass());
                pw.print(',');
                pw.print(mProcessList.getMemLevel(ProcessList.CACHED_APP_MAX_ADJ) / 1024);
                if (ActivityManager.isLowRamDeviceStatic()) {
                    pw.print(",low-ram");
                }
                if (ActivityManager.isHighEndGfx()) {
                    pw.print(",high-end-gfx");
                }
                pw.println();
            }
        }
    }
}
#end_block

#method_before
private void appendBasicMemEntry(StringBuilder sb, int oomAdj, int procState, long pss, long memtrack, String name) {
    sb.append("  ");
    sb.append(ProcessList.makeOomAdjString(oomAdj));
    sb.append(' ');
    sb.append(ProcessList.makeProcStateString(procState));
    sb.append(' ');
    ProcessList.appendRamKb(sb, pss);
    sb.append(" kB: ");
    sb.append(name);
    if (memtrack > 0) {
        sb.append(" (");
        sb.append(memtrack);
        sb.append(" kB memtrack)");
    }
}
#method_after
private void appendBasicMemEntry(StringBuilder sb, int oomAdj, int procState, long pss, long memtrack, String name) {
    sb.append("  ");
    sb.append(ProcessList.makeOomAdjString(oomAdj));
    sb.append(' ');
    sb.append(ProcessList.makeProcStateString(procState));
    sb.append(' ');
    ProcessList.appendRamKb(sb, pss);
    sb.append(": ");
    sb.append(name);
    if (memtrack > 0) {
        sb.append(" (");
        sb.append(stringifyKBSize(memtrack));
        sb.append(" memtrack)");
    }
}
#end_block

#method_before
void reportMemUsage(ArrayList<ProcessMemInfo> memInfos) {
    final SparseArray<ProcessMemInfo> infoMap = new SparseArray<>(memInfos.size());
    for (int i = 0, N = memInfos.size(); i < N; i++) {
        ProcessMemInfo mi = memInfos.get(i);
        infoMap.put(mi.pid, mi);
    }
    updateCpuStatsNow();
    long[] memtrackTmp = new long[1];
    synchronized (mProcessCpuTracker) {
        final int N = mProcessCpuTracker.countStats();
        for (int i = 0; i < N; i++) {
            ProcessCpuTracker.Stats st = mProcessCpuTracker.getStats(i);
            if (st.vsize > 0) {
                long pss = Debug.getPss(st.pid, null, memtrackTmp);
                if (pss > 0) {
                    if (infoMap.indexOfKey(st.pid) < 0) {
                        ProcessMemInfo mi = new ProcessMemInfo(st.name, st.pid, ProcessList.NATIVE_ADJ, -1, "native", null);
                        mi.pss = pss;
                        mi.memtrack = memtrackTmp[0];
                        memInfos.add(mi);
                    }
                }
            }
        }
    }
    long totalPss = 0;
    long totalMemtrack = 0;
    for (int i = 0, N = memInfos.size(); i < N; i++) {
        ProcessMemInfo mi = memInfos.get(i);
        if (mi.pss == 0) {
            mi.pss = Debug.getPss(mi.pid, null, memtrackTmp);
            mi.memtrack = memtrackTmp[0];
        }
        totalPss += mi.pss;
        totalMemtrack += mi.memtrack;
    }
    Collections.sort(memInfos, new Comparator<ProcessMemInfo>() {

        @Override
        public int compare(ProcessMemInfo lhs, ProcessMemInfo rhs) {
            if (lhs.oomAdj != rhs.oomAdj) {
                return lhs.oomAdj < rhs.oomAdj ? -1 : 1;
            }
            if (lhs.pss != rhs.pss) {
                return lhs.pss < rhs.pss ? 1 : -1;
            }
            return 0;
        }
    });
    StringBuilder tag = new StringBuilder(128);
    StringBuilder stack = new StringBuilder(128);
    tag.append("Low on memory -- ");
    appendMemBucket(tag, totalPss, "total", false);
    appendMemBucket(stack, totalPss, "total", true);
    StringBuilder fullNativeBuilder = new StringBuilder(1024);
    StringBuilder shortNativeBuilder = new StringBuilder(1024);
    StringBuilder fullJavaBuilder = new StringBuilder(1024);
    boolean firstLine = true;
    int lastOomAdj = Integer.MIN_VALUE;
    long extraNativeRam = 0;
    long extraNativeMemtrack = 0;
    long cachedPss = 0;
    for (int i = 0, N = memInfos.size(); i < N; i++) {
        ProcessMemInfo mi = memInfos.get(i);
        if (mi.oomAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
            cachedPss += mi.pss;
        }
        if (mi.oomAdj != ProcessList.NATIVE_ADJ && (mi.oomAdj < ProcessList.SERVICE_ADJ || mi.oomAdj == ProcessList.HOME_APP_ADJ || mi.oomAdj == ProcessList.PREVIOUS_APP_ADJ)) {
            if (lastOomAdj != mi.oomAdj) {
                lastOomAdj = mi.oomAdj;
                if (mi.oomAdj <= ProcessList.FOREGROUND_APP_ADJ) {
                    tag.append(" / ");
                }
                if (mi.oomAdj >= ProcessList.FOREGROUND_APP_ADJ) {
                    if (firstLine) {
                        stack.append(":");
                        firstLine = false;
                    }
                    stack.append("\n\t at ");
                } else {
                    stack.append("$");
                }
            } else {
                tag.append(" ");
                stack.append("$");
            }
            if (mi.oomAdj <= ProcessList.FOREGROUND_APP_ADJ) {
                appendMemBucket(tag, mi.pss, mi.name, false);
            }
            appendMemBucket(stack, mi.pss, mi.name, true);
            if (mi.oomAdj >= ProcessList.FOREGROUND_APP_ADJ && ((i + 1) >= N || memInfos.get(i + 1).oomAdj != lastOomAdj)) {
                stack.append("(");
                for (int k = 0; k < DUMP_MEM_OOM_ADJ.length; k++) {
                    if (DUMP_MEM_OOM_ADJ[k] == mi.oomAdj) {
                        stack.append(DUMP_MEM_OOM_LABEL[k]);
                        stack.append(":");
                        stack.append(DUMP_MEM_OOM_ADJ[k]);
                    }
                }
                stack.append(")");
            }
        }
        appendMemInfo(fullNativeBuilder, mi);
        if (mi.oomAdj == ProcessList.NATIVE_ADJ) {
            // The short form only has native processes that are >= 512K.
            if (mi.pss >= 512) {
                appendMemInfo(shortNativeBuilder, mi);
            } else {
                extraNativeRam += mi.pss;
                extraNativeMemtrack += mi.memtrack;
            }
        } else {
            // from smaller native processes let's dump a summary of that.
            if (extraNativeRam > 0) {
                appendBasicMemEntry(shortNativeBuilder, ProcessList.NATIVE_ADJ, -1, extraNativeRam, extraNativeMemtrack, "(Other native)");
                shortNativeBuilder.append('\n');
                extraNativeRam = 0;
            }
            appendMemInfo(fullJavaBuilder, mi);
        }
    }
    fullJavaBuilder.append("           ");
    ProcessList.appendRamKb(fullJavaBuilder, totalPss);
    fullJavaBuilder.append(" kB: TOTAL");
    if (totalMemtrack > 0) {
        fullJavaBuilder.append(" (");
        fullJavaBuilder.append(totalMemtrack);
        fullJavaBuilder.append(" kB memtrack)");
    } else {
    }
    fullJavaBuilder.append("\n");
    MemInfoReader memInfo = new MemInfoReader();
    memInfo.readMemInfo();
    final long[] infos = memInfo.getRawInfo();
    StringBuilder memInfoBuilder = new StringBuilder(1024);
    Debug.getMemInfo(infos);
    memInfoBuilder.append("  MemInfo: ");
    memInfoBuilder.append(infos[Debug.MEMINFO_SLAB]).append(" kB slab, ");
    memInfoBuilder.append(infos[Debug.MEMINFO_SHMEM]).append(" kB shmem, ");
    memInfoBuilder.append(infos[Debug.MEMINFO_VM_ALLOC_USED]).append(" kB vm alloc, ");
    memInfoBuilder.append(infos[Debug.MEMINFO_PAGE_TABLES]).append(" kB page tables ");
    memInfoBuilder.append(infos[Debug.MEMINFO_KERNEL_STACK]).append(" kB kernel stack\n");
    memInfoBuilder.append("           ");
    memInfoBuilder.append(infos[Debug.MEMINFO_BUFFERS]).append(" kB buffers, ");
    memInfoBuilder.append(infos[Debug.MEMINFO_CACHED]).append(" kB cached, ");
    memInfoBuilder.append(infos[Debug.MEMINFO_MAPPED]).append(" kB mapped, ");
    memInfoBuilder.append(infos[Debug.MEMINFO_FREE]).append(" kB free\n");
    if (infos[Debug.MEMINFO_ZRAM_TOTAL] != 0) {
        memInfoBuilder.append("  ZRAM: ");
        memInfoBuilder.append(infos[Debug.MEMINFO_ZRAM_TOTAL]);
        memInfoBuilder.append(" kB RAM, ");
        memInfoBuilder.append(infos[Debug.MEMINFO_SWAP_TOTAL]);
        memInfoBuilder.append(" kB swap total, ");
        memInfoBuilder.append(infos[Debug.MEMINFO_SWAP_FREE]);
        memInfoBuilder.append(" kB swap free\n");
    }
    final long[] ksm = getKsmInfo();
    if (ksm[KSM_SHARING] != 0 || ksm[KSM_SHARED] != 0 || ksm[KSM_UNSHARED] != 0 || ksm[KSM_VOLATILE] != 0) {
        memInfoBuilder.append("  KSM: ");
        memInfoBuilder.append(ksm[KSM_SHARING]);
        memInfoBuilder.append(" kB saved from shared ");
        memInfoBuilder.append(ksm[KSM_SHARED]);
        memInfoBuilder.append(" kB\n");
        memInfoBuilder.append("       ");
        memInfoBuilder.append(ksm[KSM_UNSHARED]);
        memInfoBuilder.append(" kB unshared; ");
        memInfoBuilder.append(ksm[KSM_VOLATILE]);
        memInfoBuilder.append(" kB volatile\n");
    }
    memInfoBuilder.append("  Free RAM: ");
    memInfoBuilder.append(cachedPss + memInfo.getCachedSizeKb() + memInfo.getFreeSizeKb());
    memInfoBuilder.append(" kB\n");
    memInfoBuilder.append("  Used RAM: ");
    memInfoBuilder.append(totalPss - cachedPss + memInfo.getKernelUsedSizeKb());
    memInfoBuilder.append(" kB\n");
    memInfoBuilder.append("  Lost RAM: ");
    memInfoBuilder.append(memInfo.getTotalSizeKb() - totalPss - memInfo.getFreeSizeKb() - memInfo.getCachedSizeKb() - memInfo.getKernelUsedSizeKb());
    memInfoBuilder.append(" kB\n");
    Slog.i(TAG, "Low on memory:");
    Slog.i(TAG, shortNativeBuilder.toString());
    Slog.i(TAG, fullJavaBuilder.toString());
    Slog.i(TAG, memInfoBuilder.toString());
    StringBuilder dropBuilder = new StringBuilder(1024);
    /*
        StringWriter oomSw = new StringWriter();
        PrintWriter oomPw = new FastPrintWriter(oomSw, false, 256);
        StringWriter catSw = new StringWriter();
        PrintWriter catPw = new FastPrintWriter(catSw, false, 256);
        String[] emptyArgs = new String[] { };
        dumpApplicationMemoryUsage(null, oomPw, "  ", emptyArgs, true, catPw);
        oomPw.flush();
        String oomString = oomSw.toString();
        */
    dropBuilder.append("Low on memory:");
    dropBuilder.append(stack);
    dropBuilder.append('\n');
    dropBuilder.append(fullNativeBuilder);
    dropBuilder.append(fullJavaBuilder);
    dropBuilder.append('\n');
    dropBuilder.append(memInfoBuilder);
    dropBuilder.append('\n');
    /*
        dropBuilder.append(oomString);
        dropBuilder.append('\n');
        */
    StringWriter catSw = new StringWriter();
    synchronized (ActivityManagerService.this) {
        PrintWriter catPw = new FastPrintWriter(catSw, false, 256);
        String[] emptyArgs = new String[] {};
        catPw.println();
        dumpProcessesLocked(null, catPw, emptyArgs, 0, false, null);
        catPw.println();
        mServices.dumpServicesLocked(null, catPw, emptyArgs, 0, false, false, null);
        catPw.println();
        dumpActivitiesLocked(null, catPw, emptyArgs, 0, false, false, null);
        catPw.flush();
    }
    dropBuilder.append(catSw.toString());
    addErrorToDropBox("lowmem", null, "system_server", null, null, tag.toString(), dropBuilder.toString(), null, null);
    // Slog.i(TAG, dropBuilder.toString());
    synchronized (ActivityManagerService.this) {
        long now = SystemClock.uptimeMillis();
        if (mLastMemUsageReportTime < now) {
            mLastMemUsageReportTime = now;
        }
    }
}
#method_after
void reportMemUsage(ArrayList<ProcessMemInfo> memInfos) {
    final SparseArray<ProcessMemInfo> infoMap = new SparseArray<>(memInfos.size());
    for (int i = 0, N = memInfos.size(); i < N; i++) {
        ProcessMemInfo mi = memInfos.get(i);
        infoMap.put(mi.pid, mi);
    }
    updateCpuStatsNow();
    long[] memtrackTmp = new long[1];
    synchronized (mProcessCpuTracker) {
        final int N = mProcessCpuTracker.countStats();
        for (int i = 0; i < N; i++) {
            ProcessCpuTracker.Stats st = mProcessCpuTracker.getStats(i);
            if (st.vsize > 0) {
                long pss = Debug.getPss(st.pid, null, memtrackTmp);
                if (pss > 0) {
                    if (infoMap.indexOfKey(st.pid) < 0) {
                        ProcessMemInfo mi = new ProcessMemInfo(st.name, st.pid, ProcessList.NATIVE_ADJ, -1, "native", null);
                        mi.pss = pss;
                        mi.memtrack = memtrackTmp[0];
                        memInfos.add(mi);
                    }
                }
            }
        }
    }
    long totalPss = 0;
    long totalMemtrack = 0;
    for (int i = 0, N = memInfos.size(); i < N; i++) {
        ProcessMemInfo mi = memInfos.get(i);
        if (mi.pss == 0) {
            mi.pss = Debug.getPss(mi.pid, null, memtrackTmp);
            mi.memtrack = memtrackTmp[0];
        }
        totalPss += mi.pss;
        totalMemtrack += mi.memtrack;
    }
    Collections.sort(memInfos, new Comparator<ProcessMemInfo>() {

        @Override
        public int compare(ProcessMemInfo lhs, ProcessMemInfo rhs) {
            if (lhs.oomAdj != rhs.oomAdj) {
                return lhs.oomAdj < rhs.oomAdj ? -1 : 1;
            }
            if (lhs.pss != rhs.pss) {
                return lhs.pss < rhs.pss ? 1 : -1;
            }
            return 0;
        }
    });
    StringBuilder tag = new StringBuilder(128);
    StringBuilder stack = new StringBuilder(128);
    tag.append("Low on memory -- ");
    appendMemBucket(tag, totalPss, "total", false);
    appendMemBucket(stack, totalPss, "total", true);
    StringBuilder fullNativeBuilder = new StringBuilder(1024);
    StringBuilder shortNativeBuilder = new StringBuilder(1024);
    StringBuilder fullJavaBuilder = new StringBuilder(1024);
    boolean firstLine = true;
    int lastOomAdj = Integer.MIN_VALUE;
    long extraNativeRam = 0;
    long extraNativeMemtrack = 0;
    long cachedPss = 0;
    for (int i = 0, N = memInfos.size(); i < N; i++) {
        ProcessMemInfo mi = memInfos.get(i);
        if (mi.oomAdj >= ProcessList.CACHED_APP_MIN_ADJ) {
            cachedPss += mi.pss;
        }
        if (mi.oomAdj != ProcessList.NATIVE_ADJ && (mi.oomAdj < ProcessList.SERVICE_ADJ || mi.oomAdj == ProcessList.HOME_APP_ADJ || mi.oomAdj == ProcessList.PREVIOUS_APP_ADJ)) {
            if (lastOomAdj != mi.oomAdj) {
                lastOomAdj = mi.oomAdj;
                if (mi.oomAdj <= ProcessList.FOREGROUND_APP_ADJ) {
                    tag.append(" / ");
                }
                if (mi.oomAdj >= ProcessList.FOREGROUND_APP_ADJ) {
                    if (firstLine) {
                        stack.append(":");
                        firstLine = false;
                    }
                    stack.append("\n\t at ");
                } else {
                    stack.append("$");
                }
            } else {
                tag.append(" ");
                stack.append("$");
            }
            if (mi.oomAdj <= ProcessList.FOREGROUND_APP_ADJ) {
                appendMemBucket(tag, mi.pss, mi.name, false);
            }
            appendMemBucket(stack, mi.pss, mi.name, true);
            if (mi.oomAdj >= ProcessList.FOREGROUND_APP_ADJ && ((i + 1) >= N || memInfos.get(i + 1).oomAdj != lastOomAdj)) {
                stack.append("(");
                for (int k = 0; k < DUMP_MEM_OOM_ADJ.length; k++) {
                    if (DUMP_MEM_OOM_ADJ[k] == mi.oomAdj) {
                        stack.append(DUMP_MEM_OOM_LABEL[k]);
                        stack.append(":");
                        stack.append(DUMP_MEM_OOM_ADJ[k]);
                    }
                }
                stack.append(")");
            }
        }
        appendMemInfo(fullNativeBuilder, mi);
        if (mi.oomAdj == ProcessList.NATIVE_ADJ) {
            // The short form only has native processes that are >= 512K.
            if (mi.pss >= 512) {
                appendMemInfo(shortNativeBuilder, mi);
            } else {
                extraNativeRam += mi.pss;
                extraNativeMemtrack += mi.memtrack;
            }
        } else {
            // from smaller native processes let's dump a summary of that.
            if (extraNativeRam > 0) {
                appendBasicMemEntry(shortNativeBuilder, ProcessList.NATIVE_ADJ, -1, extraNativeRam, extraNativeMemtrack, "(Other native)");
                shortNativeBuilder.append('\n');
                extraNativeRam = 0;
            }
            appendMemInfo(fullJavaBuilder, mi);
        }
    }
    fullJavaBuilder.append("           ");
    ProcessList.appendRamKb(fullJavaBuilder, totalPss);
    fullJavaBuilder.append(": TOTAL");
    if (totalMemtrack > 0) {
        fullJavaBuilder.append(" (");
        fullJavaBuilder.append(stringifyKBSize(totalMemtrack));
        fullJavaBuilder.append(" memtrack)");
    } else {
    }
    fullJavaBuilder.append("\n");
    MemInfoReader memInfo = new MemInfoReader();
    memInfo.readMemInfo();
    final long[] infos = memInfo.getRawInfo();
    StringBuilder memInfoBuilder = new StringBuilder(1024);
    Debug.getMemInfo(infos);
    memInfoBuilder.append("  MemInfo: ");
    memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_SLAB])).append(" slab, ");
    memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_SHMEM])).append(" shmem, ");
    memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_VM_ALLOC_USED])).append(" vm alloc, ");
    memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_PAGE_TABLES])).append(" page tables ");
    memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_KERNEL_STACK])).append(" kernel stack\n");
    memInfoBuilder.append("           ");
    memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_BUFFERS])).append(" buffers, ");
    memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_CACHED])).append(" cached, ");
    memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_MAPPED])).append(" mapped, ");
    memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_FREE])).append(" free\n");
    if (infos[Debug.MEMINFO_ZRAM_TOTAL] != 0) {
        memInfoBuilder.append("  ZRAM: ");
        memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_ZRAM_TOTAL]));
        memInfoBuilder.append(" RAM, ");
        memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_SWAP_TOTAL]));
        memInfoBuilder.append(" swap total, ");
        memInfoBuilder.append(stringifyKBSize(infos[Debug.MEMINFO_SWAP_FREE]));
        memInfoBuilder.append(" swap free\n");
    }
    final long[] ksm = getKsmInfo();
    if (ksm[KSM_SHARING] != 0 || ksm[KSM_SHARED] != 0 || ksm[KSM_UNSHARED] != 0 || ksm[KSM_VOLATILE] != 0) {
        memInfoBuilder.append("  KSM: ");
        memInfoBuilder.append(stringifyKBSize(ksm[KSM_SHARING]));
        memInfoBuilder.append(" saved from shared ");
        memInfoBuilder.append(stringifyKBSize(ksm[KSM_SHARED]));
        memInfoBuilder.append("\n       ");
        memInfoBuilder.append(stringifyKBSize(ksm[KSM_UNSHARED]));
        memInfoBuilder.append(" unshared; ");
        memInfoBuilder.append(stringifyKBSize(ksm[KSM_VOLATILE]));
        memInfoBuilder.append(" volatile\n");
    }
    memInfoBuilder.append("  Free RAM: ");
    memInfoBuilder.append(stringifyKBSize(cachedPss + memInfo.getCachedSizeKb() + memInfo.getFreeSizeKb()));
    memInfoBuilder.append("\n");
    memInfoBuilder.append("  Used RAM: ");
    memInfoBuilder.append(stringifyKBSize(totalPss - cachedPss + memInfo.getKernelUsedSizeKb()));
    memInfoBuilder.append("\n");
    memInfoBuilder.append("  Lost RAM: ");
    memInfoBuilder.append(stringifyKBSize(memInfo.getTotalSizeKb() - totalPss - memInfo.getFreeSizeKb() - memInfo.getCachedSizeKb() - memInfo.getKernelUsedSizeKb() - memInfo.getZramTotalSizeKb()));
    memInfoBuilder.append("\n");
    Slog.i(TAG, "Low on memory:");
    Slog.i(TAG, shortNativeBuilder.toString());
    Slog.i(TAG, fullJavaBuilder.toString());
    Slog.i(TAG, memInfoBuilder.toString());
    StringBuilder dropBuilder = new StringBuilder(1024);
    /*
        StringWriter oomSw = new StringWriter();
        PrintWriter oomPw = new FastPrintWriter(oomSw, false, 256);
        StringWriter catSw = new StringWriter();
        PrintWriter catPw = new FastPrintWriter(catSw, false, 256);
        String[] emptyArgs = new String[] { };
        dumpApplicationMemoryUsage(null, oomPw, "  ", emptyArgs, true, catPw);
        oomPw.flush();
        String oomString = oomSw.toString();
        */
    dropBuilder.append("Low on memory:");
    dropBuilder.append(stack);
    dropBuilder.append('\n');
    dropBuilder.append(fullNativeBuilder);
    dropBuilder.append(fullJavaBuilder);
    dropBuilder.append('\n');
    dropBuilder.append(memInfoBuilder);
    dropBuilder.append('\n');
    /*
        dropBuilder.append(oomString);
        dropBuilder.append('\n');
        */
    StringWriter catSw = new StringWriter();
    synchronized (ActivityManagerService.this) {
        PrintWriter catPw = new FastPrintWriter(catSw, false, 256);
        String[] emptyArgs = new String[] {};
        catPw.println();
        dumpProcessesLocked(null, catPw, emptyArgs, 0, false, null);
        catPw.println();
        mServices.newServiceDumperLocked(null, catPw, emptyArgs, 0, false, null).dumpLocked();
        catPw.println();
        dumpActivitiesLocked(null, catPw, emptyArgs, 0, false, false, null);
        catPw.flush();
    }
    dropBuilder.append(catSw.toString());
    addErrorToDropBox("lowmem", null, "system_server", null, null, tag.toString(), dropBuilder.toString(), null, null);
    // Slog.i(TAG, dropBuilder.toString());
    synchronized (ActivityManagerService.this) {
        long now = SystemClock.uptimeMillis();
        if (mLastMemUsageReportTime < now) {
            mLastMemUsageReportTime = now;
        }
    }
}
#end_block

#method_before
private final boolean removeDyingProviderLocked(ProcessRecord proc, ContentProviderRecord cpr, boolean always) {
    final boolean inLaunching = mLaunchingProviders.contains(cpr);
    if (!inLaunching || always) {
        synchronized (cpr) {
            cpr.launchingApp = null;
            cpr.notifyAll();
        }
        mProviderMap.removeProviderByClass(cpr.name, UserHandle.getUserId(cpr.uid));
        String[] names = cpr.info.authority.split(";");
        for (int j = 0; j < names.length; j++) {
            mProviderMap.removeProviderByName(names[j], UserHandle.getUserId(cpr.uid));
        }
    }
    for (int i = cpr.connections.size() - 1; i >= 0; i--) {
        ContentProviderConnection conn = cpr.connections.get(i);
        if (conn.waiting) {
            // or for some reason the provider is not currently launching.
            if (inLaunching && !always) {
                continue;
            }
        }
        ProcessRecord capp = conn.client;
        conn.dead = true;
        if (conn.stableCount > 0) {
            if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
                capp.kill("depends on provider " + cpr.name.flattenToShortString() + " in dying proc " + (proc != null ? proc.processName : "??"), true);
            }
        } else if (capp.thread != null && conn.provider.provider != null) {
            try {
                capp.thread.unstableProviderDied(conn.provider.provider.asBinder());
            } catch (RemoteException e) {
            }
            // In the protocol here, we don't expect the client to correctly
            // clean up this connection, we'll just remove it.
            cpr.connections.remove(i);
            if (conn.client.conProviders.remove(conn)) {
                stopAssociationLocked(capp.uid, capp.processName, cpr.uid, cpr.name);
            }
        }
    }
    if (inLaunching && always) {
        mLaunchingProviders.remove(cpr);
    }
    return inLaunching;
}
#method_after
private final boolean removeDyingProviderLocked(ProcessRecord proc, ContentProviderRecord cpr, boolean always) {
    final boolean inLaunching = mLaunchingProviders.contains(cpr);
    if (!inLaunching || always) {
        synchronized (cpr) {
            cpr.launchingApp = null;
            cpr.notifyAll();
        }
        mProviderMap.removeProviderByClass(cpr.name, UserHandle.getUserId(cpr.uid));
        String[] names = cpr.info.authority.split(";");
        for (int j = 0; j < names.length; j++) {
            mProviderMap.removeProviderByName(names[j], UserHandle.getUserId(cpr.uid));
        }
    }
    for (int i = cpr.connections.size() - 1; i >= 0; i--) {
        ContentProviderConnection conn = cpr.connections.get(i);
        if (conn.waiting) {
            // or for some reason the provider is not currently launching.
            if (inLaunching && !always) {
                continue;
            }
        }
        ProcessRecord capp = conn.client;
        conn.dead = true;
        if (conn.stableCount > 0) {
            if (!capp.persistent && capp.thread != null && capp.pid != 0 && capp.pid != MY_PID) {
                capp.kill("depends on provider " + cpr.name.flattenToShortString() + " in dying proc " + (proc != null ? proc.processName : "??") + " (adj " + (proc != null ? proc.setAdj : "??") + ")", true);
            }
        } else if (capp.thread != null && conn.provider.provider != null) {
            try {
                capp.thread.unstableProviderDied(conn.provider.provider.asBinder());
            } catch (RemoteException e) {
            }
            // In the protocol here, we don't expect the client to correctly
            // clean up this connection, we'll just remove it.
            cpr.connections.remove(i);
            if (conn.client.conProviders.remove(conn)) {
                stopAssociationLocked(capp.uid, capp.processName, cpr.uid, cpr.name);
            }
        }
    }
    if (inLaunching && always) {
        mLaunchingProviders.remove(cpr);
    }
    return inLaunching;
}
#end_block

#method_before
private final boolean cleanUpApplicationRecordLocked(ProcessRecord app, boolean restarting, boolean allowRestart, int index) {
    if (index >= 0) {
        removeLruProcessLocked(app);
        ProcessList.remove(app.pid);
    }
    mProcessesToGc.remove(app);
    mPendingPssProcesses.remove(app);
    // Dismiss any open dialogs.
    if (app.crashDialog != null && !app.forceCrashReport) {
        app.crashDialog.dismiss();
        app.crashDialog = null;
    }
    if (app.anrDialog != null) {
        app.anrDialog.dismiss();
        app.anrDialog = null;
    }
    if (app.waitDialog != null) {
        app.waitDialog.dismiss();
        app.waitDialog = null;
    }
    app.crashing = false;
    app.notResponding = false;
    app.resetPackageList(mProcessStats);
    app.unlinkDeathRecipient();
    app.makeInactive(mProcessStats);
    app.waitingToKill = null;
    app.forcingToForeground = null;
    updateProcessForegroundLocked(app, false, false);
    app.foregroundActivities = false;
    app.hasShownUi = false;
    app.treatLikeActivity = false;
    app.hasAboveClient = false;
    app.hasClientActivities = false;
    mServices.killServicesLocked(app, allowRestart);
    boolean restart = false;
    // Remove published content providers.
    for (int i = app.pubProviders.size() - 1; i >= 0; i--) {
        ContentProviderRecord cpr = app.pubProviders.valueAt(i);
        final boolean always = app.bad || !allowRestart;
        boolean inLaunching = removeDyingProviderLocked(app, cpr, always);
        if ((inLaunching || always) && cpr.hasConnectionOrHandle()) {
            // We left the provider in the launching list, need to
            // restart it.
            restart = true;
        }
        cpr.provider = null;
        cpr.proc = null;
    }
    app.pubProviders.clear();
    // Take care of any launching providers waiting for this process.
    if (cleanupAppInLaunchingProvidersLocked(app, false)) {
        restart = true;
    }
    // Unregister from connected content providers.
    if (!app.conProviders.isEmpty()) {
        for (int i = app.conProviders.size() - 1; i >= 0; i--) {
            ContentProviderConnection conn = app.conProviders.get(i);
            conn.provider.connections.remove(conn);
            stopAssociationLocked(app.uid, app.processName, conn.provider.uid, conn.provider.name);
        }
        app.conProviders.clear();
    }
    // the actual situation to identify what is actually going on.
    if (false) {
        for (int i = mLaunchingProviders.size() - 1; i >= 0; i--) {
            ContentProviderRecord cpr = mLaunchingProviders.get(i);
            if (cpr.connections.size() <= 0 && !cpr.hasExternalProcessHandles()) {
                synchronized (cpr) {
                    cpr.launchingApp = null;
                    cpr.notifyAll();
                }
            }
        }
    }
    skipCurrentReceiverLocked(app);
    // Unregister any receivers.
    for (int i = app.receivers.size() - 1; i >= 0; i--) {
        removeReceiverLocked(app.receivers.valueAt(i));
    }
    app.receivers.clear();
    mHandler.post(new Runnable() {

        @Override
        public void run() {
            // If the app is undergoing backup, tell the backup manager about it
            if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
                if (DEBUG_BACKUP || DEBUG_CLEANUP)
                    Slog.d(TAG_CLEANUP, "App " + mBackupTarget.appInfo + " died during backup");
                try {
                    IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
                    bm.agentDisconnected(app.info.packageName);
                } catch (RemoteException e) {
                // can't happen; backup manager is local
                }
            }
        }
    });
    for (int i = mPendingProcessChanges.size() - 1; i >= 0; i--) {
        ProcessChangeItem item = mPendingProcessChanges.get(i);
        if (item.pid == app.pid) {
            mPendingProcessChanges.remove(i);
            mAvailProcessChanges.add(item);
        }
    }
    mUiHandler.obtainMessage(DISPATCH_PROCESS_DIED, app.pid, app.info.uid, null).sendToTarget();
    // current lists and let the caller take care of it.
    if (restarting) {
        return false;
    }
    if (!app.persistent || app.isolated) {
        if (DEBUG_PROCESSES || DEBUG_CLEANUP)
            Slog.v(TAG_CLEANUP, "Removing non-persistent process during cleanup: " + app);
        removeProcessNameLocked(app.processName, app.uid);
        if (mHeavyWeightProcess == app) {
            mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG, mHeavyWeightProcess.userId, 0));
            mHeavyWeightProcess = null;
        }
    } else if (!app.removed) {
        // and start a new process for it.
        if (mPersistentStartingProcesses.indexOf(app) < 0) {
            mPersistentStartingProcesses.add(app);
            restart = true;
        }
    }
    if ((DEBUG_PROCESSES || DEBUG_CLEANUP) && mProcessesOnHold.contains(app))
        Slog.v(TAG_CLEANUP, "Clean-up removing on hold: " + app);
    mProcessesOnHold.remove(app);
    if (app == mHomeProcess) {
        mHomeProcess = null;
    }
    if (app == mPreviousProcess) {
        mPreviousProcess = null;
    }
    if (restart && !app.isolated) {
        // process, so re-launch it.
        if (index < 0) {
            ProcessList.remove(app.pid);
        }
        addProcessNameLocked(app);
        startProcessLocked(app, "restart", app.processName);
        return true;
    } else if (app.pid > 0 && app.pid != MY_PID) {
        // Goodbye!
        boolean removed;
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
        if (app.isolated) {
            mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
        }
        app.setPid(0);
    }
    return false;
}
#method_after
private final boolean cleanUpApplicationRecordLocked(ProcessRecord app, boolean restarting, boolean allowRestart, int index) {
    if (index >= 0) {
        removeLruProcessLocked(app);
        ProcessList.remove(app.pid);
    }
    mProcessesToGc.remove(app);
    mPendingPssProcesses.remove(app);
    // Dismiss any open dialogs.
    if (app.crashDialog != null && !app.forceCrashReport) {
        app.crashDialog.dismiss();
        app.crashDialog = null;
    }
    if (app.anrDialog != null) {
        app.anrDialog.dismiss();
        app.anrDialog = null;
    }
    if (app.waitDialog != null) {
        app.waitDialog.dismiss();
        app.waitDialog = null;
    }
    app.crashing = false;
    app.notResponding = false;
    app.resetPackageList(mProcessStats);
    app.unlinkDeathRecipient();
    app.makeInactive(mProcessStats);
    app.waitingToKill = null;
    app.forcingToForeground = null;
    updateProcessForegroundLocked(app, false, false);
    app.foregroundActivities = false;
    app.hasShownUi = false;
    app.treatLikeActivity = false;
    app.hasAboveClient = false;
    app.hasClientActivities = false;
    mServices.killServicesLocked(app, allowRestart);
    boolean restart = false;
    // Remove published content providers.
    for (int i = app.pubProviders.size() - 1; i >= 0; i--) {
        ContentProviderRecord cpr = app.pubProviders.valueAt(i);
        final boolean always = app.bad || !allowRestart;
        boolean inLaunching = removeDyingProviderLocked(app, cpr, always);
        if ((inLaunching || always) && cpr.hasConnectionOrHandle()) {
            // We left the provider in the launching list, need to
            // restart it.
            restart = true;
        }
        cpr.provider = null;
        cpr.proc = null;
    }
    app.pubProviders.clear();
    // Take care of any launching providers waiting for this process.
    if (cleanupAppInLaunchingProvidersLocked(app, false)) {
        restart = true;
    }
    // Unregister from connected content providers.
    if (!app.conProviders.isEmpty()) {
        for (int i = app.conProviders.size() - 1; i >= 0; i--) {
            ContentProviderConnection conn = app.conProviders.get(i);
            conn.provider.connections.remove(conn);
            stopAssociationLocked(app.uid, app.processName, conn.provider.uid, conn.provider.name);
        }
        app.conProviders.clear();
    }
    // the actual situation to identify what is actually going on.
    if (false) {
        for (int i = mLaunchingProviders.size() - 1; i >= 0; i--) {
            ContentProviderRecord cpr = mLaunchingProviders.get(i);
            if (cpr.connections.size() <= 0 && !cpr.hasExternalProcessHandles()) {
                synchronized (cpr) {
                    cpr.launchingApp = null;
                    cpr.notifyAll();
                }
            }
        }
    }
    skipCurrentReceiverLocked(app);
    // Unregister any receivers.
    for (int i = app.receivers.size() - 1; i >= 0; i--) {
        removeReceiverLocked(app.receivers.valueAt(i));
    }
    app.receivers.clear();
    // If the app is undergoing backup, tell the backup manager about it
    if (mBackupTarget != null && app.pid == mBackupTarget.app.pid) {
        if (DEBUG_BACKUP || DEBUG_CLEANUP)
            Slog.d(TAG_CLEANUP, "App " + mBackupTarget.appInfo + " died during backup");
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                try {
                    IBackupManager bm = IBackupManager.Stub.asInterface(ServiceManager.getService(Context.BACKUP_SERVICE));
                    bm.agentDisconnected(app.info.packageName);
                } catch (RemoteException e) {
                // can't happen; backup manager is local
                }
            }
        });
    }
    for (int i = mPendingProcessChanges.size() - 1; i >= 0; i--) {
        ProcessChangeItem item = mPendingProcessChanges.get(i);
        if (item.pid == app.pid) {
            mPendingProcessChanges.remove(i);
            mAvailProcessChanges.add(item);
        }
    }
    mUiHandler.obtainMessage(DISPATCH_PROCESS_DIED_UI_MSG, app.pid, app.info.uid, null).sendToTarget();
    // current lists and let the caller take care of it.
    if (restarting) {
        return false;
    }
    if (!app.persistent || app.isolated) {
        if (DEBUG_PROCESSES || DEBUG_CLEANUP)
            Slog.v(TAG_CLEANUP, "Removing non-persistent process during cleanup: " + app);
        removeProcessNameLocked(app.processName, app.uid);
        if (mHeavyWeightProcess == app) {
            mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG, mHeavyWeightProcess.userId, 0));
            mHeavyWeightProcess = null;
        }
    } else if (!app.removed) {
        // and start a new process for it.
        if (mPersistentStartingProcesses.indexOf(app) < 0) {
            mPersistentStartingProcesses.add(app);
            restart = true;
        }
    }
    if ((DEBUG_PROCESSES || DEBUG_CLEANUP) && mProcessesOnHold.contains(app))
        Slog.v(TAG_CLEANUP, "Clean-up removing on hold: " + app);
    mProcessesOnHold.remove(app);
    if (app == mHomeProcess) {
        mHomeProcess = null;
    }
    if (app == mPreviousProcess) {
        mPreviousProcess = null;
    }
    if (restart && !app.isolated) {
        // process, so re-launch it.
        if (index < 0) {
            ProcessList.remove(app.pid);
        }
        addProcessNameLocked(app);
        startProcessLocked(app, "restart", app.processName);
        return true;
    } else if (app.pid > 0 && app.pid != MY_PID) {
        // Goodbye!
        boolean removed;
        synchronized (mPidsSelfLocked) {
            mPidsSelfLocked.remove(app.pid);
            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
        }
        mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);
        if (app.isolated) {
            mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);
        }
        app.setPid(0);
    }
    return false;
}
#end_block

#method_before
@Override
public void setServiceForeground(ComponentName className, IBinder token, int id, Notification notification, boolean removeNotification) {
    synchronized (this) {
        mServices.setServiceForegroundLocked(className, token, id, notification, removeNotification);
    }
}
#method_after
@Override
public void setServiceForeground(ComponentName className, IBinder token, int id, Notification notification, int flags) {
    synchronized (this) {
        mServices.setServiceForegroundLocked(className, token, id, notification, flags);
    }
}
#end_block

#method_before
@Override
public int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll, boolean requireFull, String name, String callerPackage) {
    return handleIncomingUser(callingPid, callingUid, userId, allowAll, requireFull ? ALLOW_FULL_ONLY : ALLOW_NON_FULL, name, callerPackage);
}
#method_after
@Override
public int handleIncomingUser(int callingPid, int callingUid, int userId, boolean allowAll, boolean requireFull, String name, String callerPackage) {
    return mUserController.handleIncomingUser(callingPid, callingUid, userId, allowAll, requireFull ? ALLOW_FULL_ONLY : ALLOW_NON_FULL, name, callerPackage);
}
#end_block

#method_before
// =========================================================
// BACKUP AND RESTORE
// =========================================================
// Cause the target app to be launched if necessary and its backup agent
// instantiated.  The backup agent will invoke backupAgentCreated() on the
public boolean bindBackupAgent(ApplicationInfo app, int backupMode) {
    if (DEBUG_BACKUP)
        Slog.v(TAG_BACKUP, "bindBackupAgent: app=" + app + " mode=" + backupMode);
    enforceCallingPermission("android.permission.CONFIRM_FULL_BACKUP", "bindBackupAgent");
    synchronized (this) {
        // !!! TODO: currently no check here that we're already bound
        BatteryStatsImpl.Uid.Pkg.Serv ss = null;
        BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
        synchronized (stats) {
            ss = stats.getServiceStatsLocked(app.uid, app.packageName, app.name);
        }
        // Backup agent is now in use, its package can't be stopped.
        try {
            AppGlobals.getPackageManager().setPackageStoppedState(app.packageName, false, UserHandle.getUserId(app.uid));
        } catch (RemoteException e) {
        } catch (IllegalArgumentException e) {
            Slog.w(TAG, "Failed trying to unstop package " + app.packageName + ": " + e);
        }
        BackupRecord r = new BackupRecord(ss, app, backupMode);
        ComponentName hostingName = (backupMode == IApplicationThread.BACKUP_MODE_INCREMENTAL) ? new ComponentName(app.packageName, app.backupAgentName) : new ComponentName("android", "FullBackupAgent");
        // startProcessLocked() returns existing proc's record if it's already running
        ProcessRecord proc = startProcessLocked(app.processName, app, false, 0, "backup", hostingName, false, false, false);
        if (proc == null) {
            Slog.e(TAG, "Unable to start backup agent process " + r);
            return false;
        }
        r.app = proc;
        mBackupTarget = r;
        mBackupAppName = app.packageName;
        // Try not to kill the process during backup
        updateOomAdjLocked(proc);
        // If it is not yet live, this will be done when it attaches to the framework.
        if (proc.thread != null) {
            if (DEBUG_BACKUP)
                Slog.v(TAG_BACKUP, "Agent proc already running: " + proc);
            try {
                proc.thread.scheduleCreateBackupAgent(app, compatibilityInfoForPackageLocked(app), backupMode);
            } catch (RemoteException e) {
            // Will time out on the backup manager side
            }
        } else {
            if (DEBUG_BACKUP)
                Slog.v(TAG_BACKUP, "Agent proc not running, waiting for attach");
        }
    // Invariants: at this point, the target app process exists and the application
    // is either already running or in the process of coming up.  mBackupTarget and
    // mBackupAppName describe the app, so that when it binds back to the AM we
    // know that it's scheduled for a backup-agent operation.
    }
    return true;
}
#method_after
// =========================================================
// BACKUP AND RESTORE
// =========================================================
// Cause the target app to be launched if necessary and its backup agent
// instantiated.  The backup agent will invoke backupAgentCreated() on the
public boolean bindBackupAgent(String packageName, int backupMode, int userId) {
    if (DEBUG_BACKUP)
        Slog.v(TAG, "bindBackupAgent: app=" + packageName + " mode=" + backupMode);
    enforceCallingPermission("android.permission.CONFIRM_FULL_BACKUP", "bindBackupAgent");
    IPackageManager pm = AppGlobals.getPackageManager();
    ApplicationInfo app = null;
    try {
        app = pm.getApplicationInfo(packageName, 0, userId);
    } catch (RemoteException e) {
    // can't happen; package manager is process-local
    }
    if (app == null) {
        Slog.w(TAG, "Unable to bind backup agent for " + packageName);
        return false;
    }
    synchronized (this) {
        // !!! TODO: currently no check here that we're already bound
        BatteryStatsImpl.Uid.Pkg.Serv ss = null;
        BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
        synchronized (stats) {
            ss = stats.getServiceStatsLocked(app.uid, app.packageName, app.name);
        }
        // Backup agent is now in use, its package can't be stopped.
        try {
            AppGlobals.getPackageManager().setPackageStoppedState(app.packageName, false, UserHandle.getUserId(app.uid));
        } catch (RemoteException e) {
        } catch (IllegalArgumentException e) {
            Slog.w(TAG, "Failed trying to unstop package " + app.packageName + ": " + e);
        }
        BackupRecord r = new BackupRecord(ss, app, backupMode);
        ComponentName hostingName = (backupMode == IApplicationThread.BACKUP_MODE_INCREMENTAL) ? new ComponentName(app.packageName, app.backupAgentName) : new ComponentName("android", "FullBackupAgent");
        // startProcessLocked() returns existing proc's record if it's already running
        ProcessRecord proc = startProcessLocked(app.processName, app, false, 0, "backup", hostingName, false, false, false);
        if (proc == null) {
            Slog.e(TAG, "Unable to start backup agent process " + r);
            return false;
        }
        // process after the full backup is done and the ProcessRecord will vaporize anyway.
        if (UserHandle.isApp(app.uid) && backupMode == IApplicationThread.BACKUP_MODE_FULL) {
            proc.inFullBackup = true;
        }
        r.app = proc;
        mBackupTarget = r;
        mBackupAppName = app.packageName;
        // Try not to kill the process during backup
        updateOomAdjLocked(proc);
        // If it is not yet live, this will be done when it attaches to the framework.
        if (proc.thread != null) {
            if (DEBUG_BACKUP)
                Slog.v(TAG_BACKUP, "Agent proc already running: " + proc);
            try {
                proc.thread.scheduleCreateBackupAgent(app, compatibilityInfoForPackageLocked(app), backupMode);
            } catch (RemoteException e) {
            // Will time out on the backup manager side
            }
        } else {
            if (DEBUG_BACKUP)
                Slog.v(TAG_BACKUP, "Agent proc not running, waiting for attach");
        }
    // Invariants: at this point, the target app process exists and the application
    // is either already running or in the process of coming up.  mBackupTarget and
    // mBackupAppName describe the app, so that when it binds back to the AM we
    // know that it's scheduled for a backup-agent operation.
    }
    return true;
}
#end_block

#method_before
public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) {
    enforceNotIsolatedCaller("registerReceiver");
    ArrayList<Intent> stickyIntents = null;
    ProcessRecord callerApp = null;
    int callingUid;
    int callingPid;
    synchronized (this) {
        if (caller != null) {
            callerApp = getRecordForAppLocked(caller);
            if (callerApp == null) {
                throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when registering receiver " + receiver);
            }
            if (callerApp.info.uid != Process.SYSTEM_UID && !callerApp.pkgList.containsKey(callerPackage) && !"android".equals(callerPackage)) {
                throw new SecurityException("Given caller package " + callerPackage + " is not running in process " + callerApp);
            }
            callingUid = callerApp.info.uid;
            callingPid = callerApp.pid;
        } else {
            callerPackage = null;
            callingUid = Binder.getCallingUid();
            callingPid = Binder.getCallingPid();
        }
        userId = handleIncomingUser(callingPid, callingUid, userId, true, ALLOW_FULL_ONLY, "registerReceiver", callerPackage);
        Iterator<String> actions = filter.actionsIterator();
        if (actions == null) {
            ArrayList<String> noAction = new ArrayList<String>(1);
            noAction.add(null);
            actions = noAction.iterator();
        }
        // Collect stickies of users
        int[] userIds = { UserHandle.USER_ALL, UserHandle.getUserId(callingUid) };
        while (actions.hasNext()) {
            String action = actions.next();
            for (int id : userIds) {
                ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(id);
                if (stickies != null) {
                    ArrayList<Intent> intents = stickies.get(action);
                    if (intents != null) {
                        if (stickyIntents == null) {
                            stickyIntents = new ArrayList<Intent>();
                        }
                        stickyIntents.addAll(intents);
                    }
                }
            }
        }
    }
    ArrayList<Intent> allSticky = null;
    if (stickyIntents != null) {
        final ContentResolver resolver = mContext.getContentResolver();
        // Look for any matching sticky broadcasts...
        for (int i = 0, N = stickyIntents.size(); i < N; i++) {
            Intent intent = stickyIntents.get(i);
            // cannot lock ActivityManagerService here.
            if (filter.match(resolver, intent, true, TAG) >= 0) {
                if (allSticky == null) {
                    allSticky = new ArrayList<Intent>();
                }
                allSticky.add(intent);
            }
        }
    }
    // The first sticky in the list is returned directly back to the client.
    Intent sticky = allSticky != null ? allSticky.get(0) : null;
    if (DEBUG_BROADCAST)
        Slog.v(TAG_BROADCAST, "Register receiver " + filter + ": " + sticky);
    if (receiver == null) {
        return sticky;
    }
    synchronized (this) {
        if (callerApp != null && (callerApp.thread == null || callerApp.thread.asBinder() != caller.asBinder())) {
            // Original caller already died
            return null;
        }
        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());
        if (rl == null) {
            rl = new ReceiverList(this, callerApp, callingPid, callingUid, userId, receiver);
            if (rl.app != null) {
                rl.app.receivers.add(rl);
            } else {
                try {
                    receiver.asBinder().linkToDeath(rl, 0);
                } catch (RemoteException e) {
                    return sticky;
                }
                rl.linkedToDeath = true;
            }
            mRegisteredReceivers.put(receiver.asBinder(), rl);
        } else if (rl.uid != callingUid) {
            throw new IllegalArgumentException("Receiver requested to register for uid " + callingUid + " was previously registered for uid " + rl.uid);
        } else if (rl.pid != callingPid) {
            throw new IllegalArgumentException("Receiver requested to register for pid " + callingPid + " was previously registered for pid " + rl.pid);
        } else if (rl.userId != userId) {
            throw new IllegalArgumentException("Receiver requested to register for user " + userId + " was previously registered for user " + rl.userId);
        }
        BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId);
        rl.add(bf);
        if (!bf.debugCheck()) {
            Slog.w(TAG, "==> For Dynamic broadcast");
        }
        mReceiverResolver.addFilter(bf);
        // this filter.
        if (allSticky != null) {
            ArrayList receivers = new ArrayList();
            receivers.add(bf);
            final int stickyCount = allSticky.size();
            for (int i = 0; i < stickyCount; i++) {
                Intent intent = allSticky.get(i);
                BroadcastQueue queue = broadcastQueueForIntent(intent);
                BroadcastRecord r = new BroadcastRecord(queue, intent, null, null, -1, -1, null, null, AppOpsManager.OP_NONE, null, receivers, null, 0, null, null, false, true, true, -1);
                queue.enqueueParallelBroadcastLocked(r);
                queue.scheduleBroadcastsLocked();
            }
        }
        return sticky;
    }
}
#method_after
public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) {
    enforceNotIsolatedCaller("registerReceiver");
    ArrayList<Intent> stickyIntents = null;
    ProcessRecord callerApp = null;
    int callingUid;
    int callingPid;
    synchronized (this) {
        if (caller != null) {
            callerApp = getRecordForAppLocked(caller);
            if (callerApp == null) {
                throw new SecurityException("Unable to find app for caller " + caller + " (pid=" + Binder.getCallingPid() + ") when registering receiver " + receiver);
            }
            if (callerApp.info.uid != Process.SYSTEM_UID && !callerApp.pkgList.containsKey(callerPackage) && !"android".equals(callerPackage)) {
                throw new SecurityException("Given caller package " + callerPackage + " is not running in process " + callerApp);
            }
            callingUid = callerApp.info.uid;
            callingPid = callerApp.pid;
        } else {
            callerPackage = null;
            callingUid = Binder.getCallingUid();
            callingPid = Binder.getCallingPid();
        }
        userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, true, ALLOW_FULL_ONLY, "registerReceiver", callerPackage);
        Iterator<String> actions = filter.actionsIterator();
        if (actions == null) {
            ArrayList<String> noAction = new ArrayList<String>(1);
            noAction.add(null);
            actions = noAction.iterator();
        }
        // Collect stickies of users
        int[] userIds = { UserHandle.USER_ALL, UserHandle.getUserId(callingUid) };
        while (actions.hasNext()) {
            String action = actions.next();
            for (int id : userIds) {
                ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(id);
                if (stickies != null) {
                    ArrayList<Intent> intents = stickies.get(action);
                    if (intents != null) {
                        if (stickyIntents == null) {
                            stickyIntents = new ArrayList<Intent>();
                        }
                        stickyIntents.addAll(intents);
                    }
                }
            }
        }
    }
    ArrayList<Intent> allSticky = null;
    if (stickyIntents != null) {
        final ContentResolver resolver = mContext.getContentResolver();
        // Look for any matching sticky broadcasts...
        for (int i = 0, N = stickyIntents.size(); i < N; i++) {
            Intent intent = stickyIntents.get(i);
            // cannot lock ActivityManagerService here.
            if (filter.match(resolver, intent, true, TAG) >= 0) {
                if (allSticky == null) {
                    allSticky = new ArrayList<Intent>();
                }
                allSticky.add(intent);
            }
        }
    }
    // The first sticky in the list is returned directly back to the client.
    Intent sticky = allSticky != null ? allSticky.get(0) : null;
    if (DEBUG_BROADCAST)
        Slog.v(TAG_BROADCAST, "Register receiver " + filter + ": " + sticky);
    if (receiver == null) {
        return sticky;
    }
    synchronized (this) {
        if (callerApp != null && (callerApp.thread == null || callerApp.thread.asBinder() != caller.asBinder())) {
            // Original caller already died
            return null;
        }
        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());
        if (rl == null) {
            rl = new ReceiverList(this, callerApp, callingPid, callingUid, userId, receiver);
            if (rl.app != null) {
                rl.app.receivers.add(rl);
            } else {
                try {
                    receiver.asBinder().linkToDeath(rl, 0);
                } catch (RemoteException e) {
                    return sticky;
                }
                rl.linkedToDeath = true;
            }
            mRegisteredReceivers.put(receiver.asBinder(), rl);
        } else if (rl.uid != callingUid) {
            throw new IllegalArgumentException("Receiver requested to register for uid " + callingUid + " was previously registered for uid " + rl.uid);
        } else if (rl.pid != callingPid) {
            throw new IllegalArgumentException("Receiver requested to register for pid " + callingPid + " was previously registered for pid " + rl.pid);
        } else if (rl.userId != userId) {
            throw new IllegalArgumentException("Receiver requested to register for user " + userId + " was previously registered for user " + rl.userId);
        }
        BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage, permission, callingUid, userId);
        rl.add(bf);
        if (!bf.debugCheck()) {
            Slog.w(TAG, "==> For Dynamic broadcast");
        }
        mReceiverResolver.addFilter(bf);
        // this filter.
        if (allSticky != null) {
            ArrayList receivers = new ArrayList();
            receivers.add(bf);
            final int stickyCount = allSticky.size();
            for (int i = 0; i < stickyCount; i++) {
                Intent intent = allSticky.get(i);
                BroadcastQueue queue = broadcastQueueForIntent(intent);
                BroadcastRecord r = new BroadcastRecord(queue, intent, null, null, -1, -1, null, null, AppOpsManager.OP_NONE, null, receivers, null, 0, null, null, false, true, true, -1);
                queue.enqueueParallelBroadcastLocked(r);
                queue.scheduleBroadcastsLocked();
            }
        }
        return sticky;
    }
}
#end_block

#method_before
private List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType, int callingUid, int[] users) {
    List<ResolveInfo> receivers = null;
    try {
        HashSet<ComponentName> singleUserReceivers = null;
        boolean scannedFirstReceivers = false;
        for (int user : users) {
            // Skip users that have Shell restrictions
            if (callingUid == Process.SHELL_UID && getUserManagerLocked().hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, user)) {
                continue;
            }
            List<ResolveInfo> newReceivers = AppGlobals.getPackageManager().queryIntentReceivers(intent, resolvedType, STOCK_PM_FLAGS, user);
            if (user != UserHandle.USER_OWNER && newReceivers != null) {
                // any receivers that should be filtered out.
                for (int i = 0; i < newReceivers.size(); i++) {
                    ResolveInfo ri = newReceivers.get(i);
                    if ((ri.activityInfo.flags & ActivityInfo.FLAG_PRIMARY_USER_ONLY) != 0) {
                        newReceivers.remove(i);
                        i--;
                    }
                }
            }
            if (newReceivers != null && newReceivers.size() == 0) {
                newReceivers = null;
            }
            if (receivers == null) {
                receivers = newReceivers;
            } else if (newReceivers != null) {
                // singleUser.
                if (!scannedFirstReceivers) {
                    // Collect any single user receivers we had already retrieved.
                    scannedFirstReceivers = true;
                    for (int i = 0; i < receivers.size(); i++) {
                        ResolveInfo ri = receivers.get(i);
                        if ((ri.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
                            ComponentName cn = new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name);
                            if (singleUserReceivers == null) {
                                singleUserReceivers = new HashSet<ComponentName>();
                            }
                            singleUserReceivers.add(cn);
                        }
                    }
                }
                // and de-dupping single user receivers.
                for (int i = 0; i < newReceivers.size(); i++) {
                    ResolveInfo ri = newReceivers.get(i);
                    if ((ri.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
                        ComponentName cn = new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name);
                        if (singleUserReceivers == null) {
                            singleUserReceivers = new HashSet<ComponentName>();
                        }
                        if (!singleUserReceivers.contains(cn)) {
                            singleUserReceivers.add(cn);
                            receivers.add(ri);
                        }
                    } else {
                        receivers.add(ri);
                    }
                }
            }
        }
    } catch (RemoteException ex) {
    // pm is in same process, this will never happen.
    }
    return receivers;
}
#method_after
private List<ResolveInfo> collectReceiverComponents(Intent intent, String resolvedType, int callingUid, int[] users) {
    // TODO: come back and remove this assumption to triage all broadcasts
    int pmFlags = STOCK_PM_FLAGS | MATCH_DEBUG_TRIAGED_MISSING;
    List<ResolveInfo> receivers = null;
    try {
        HashSet<ComponentName> singleUserReceivers = null;
        boolean scannedFirstReceivers = false;
        for (int user : users) {
            // Shell broadcasts
            if (callingUid == Process.SHELL_UID && mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, user) && !isPermittedShellBroadcast(intent)) {
                continue;
            }
            List<ResolveInfo> newReceivers = AppGlobals.getPackageManager().queryIntentReceivers(intent, resolvedType, pmFlags, user).getList();
            if (user != UserHandle.USER_SYSTEM && newReceivers != null) {
                // any receivers that should be filtered out.
                for (int i = 0; i < newReceivers.size(); i++) {
                    ResolveInfo ri = newReceivers.get(i);
                    if ((ri.activityInfo.flags & ActivityInfo.FLAG_SYSTEM_USER_ONLY) != 0) {
                        newReceivers.remove(i);
                        i--;
                    }
                }
            }
            if (newReceivers != null && newReceivers.size() == 0) {
                newReceivers = null;
            }
            if (receivers == null) {
                receivers = newReceivers;
            } else if (newReceivers != null) {
                // singleUser.
                if (!scannedFirstReceivers) {
                    // Collect any single user receivers we had already retrieved.
                    scannedFirstReceivers = true;
                    for (int i = 0; i < receivers.size(); i++) {
                        ResolveInfo ri = receivers.get(i);
                        if ((ri.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
                            ComponentName cn = new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name);
                            if (singleUserReceivers == null) {
                                singleUserReceivers = new HashSet<ComponentName>();
                            }
                            singleUserReceivers.add(cn);
                        }
                    }
                }
                // and de-dupping single user receivers.
                for (int i = 0; i < newReceivers.size(); i++) {
                    ResolveInfo ri = newReceivers.get(i);
                    if ((ri.activityInfo.flags & ActivityInfo.FLAG_SINGLE_USER) != 0) {
                        ComponentName cn = new ComponentName(ri.activityInfo.packageName, ri.activityInfo.name);
                        if (singleUserReceivers == null) {
                            singleUserReceivers = new HashSet<ComponentName>();
                        }
                        if (!singleUserReceivers.contains(cn)) {
                            singleUserReceivers.add(cn);
                            receivers.add(ri);
                        }
                    } else {
                        receivers.add(ri);
                    }
                }
            }
        }
    } catch (RemoteException ex) {
    // pm is in same process, this will never happen.
    }
    return receivers;
}
#end_block

#method_before
private final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) {
    intent = new Intent(intent);
    // By default broadcasts do not go to stopped apps.
    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
    // If we have not finished booting, don't allow this to launch new processes.
    if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
    if (DEBUG_BROADCAST_LIGHT)
        Slog.v(TAG_BROADCAST, (sticky ? "Broadcast sticky: " : "Broadcast: ") + intent + " ordered=" + ordered + " userid=" + userId);
    if ((resultTo != null) && !ordered) {
        Slog.w(TAG, "Broadcast " + intent + " not ordered but result callback requested!");
    }
    userId = handleIncomingUser(callingPid, callingUid, userId, true, ALLOW_NON_FULL, "broadcast", callerPackage);
    if (userId != UserHandle.USER_ALL && !isUserRunningLocked(userId, false)) {
        if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
            Slog.w(TAG, "Skipping broadcast of " + intent + ": user " + userId + " is stopped");
            return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
        }
    }
    BroadcastOptions brOptions = null;
    if (options != null) {
        brOptions = new BroadcastOptions(options);
        if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
            // PendingIntent), because that who is actually supplied the arguments.
            if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST, Binder.getCallingPid(), Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {
                String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            }
        }
    }
    /*
         * Prevent non-system code (defined here to be non-persistent
         * processes) from sending protected broadcasts.
         */
    int callingAppId = UserHandle.getAppId(callingUid);
    if (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID || callingAppId == Process.NFC_UID || callingUid == 0) {
    // Always okay.
    } else if (callerApp == null || !callerApp.persistent) {
        try {
            if (AppGlobals.getPackageManager().isProtectedBroadcast(intent.getAction())) {
                String msg = "Permission Denial: not allowed to send broadcast " + intent.getAction() + " from pid=" + callingPid + ", uid=" + callingUid;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            } else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) {
                // just limit it to the caller.
                if (callerApp == null) {
                    String msg = "Permission Denial: not allowed to send broadcast " + intent.getAction() + " from unknown caller.";
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                } else if (intent.getComponent() != null) {
                    // it is being sent to the calling app.
                    if (!intent.getComponent().getPackageName().equals(callerApp.info.packageName)) {
                        String msg = "Permission Denial: not allowed to send broadcast " + intent.getAction() + " to " + intent.getComponent().getPackageName() + " from " + callerApp.info.packageName;
                        Slog.w(TAG, msg);
                        throw new SecurityException(msg);
                    }
                } else {
                    // Limit broadcast to their own package.
                    intent.setPackage(callerApp.info.packageName);
                }
            }
        } catch (RemoteException e) {
            Slog.w(TAG, "Remote exception", e);
            return ActivityManager.BROADCAST_SUCCESS;
        }
    }
    final String action = intent.getAction();
    if (action != null) {
        switch(action) {
            case Intent.ACTION_UID_REMOVED:
            case Intent.ACTION_PACKAGE_REMOVED:
            case Intent.ACTION_PACKAGE_CHANGED:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
                // its activities from the history stack.
                if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED, callingPid, callingUid, -1, true) != PackageManager.PERMISSION_GRANTED) {
                    String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
                switch(action) {
                    case Intent.ACTION_UID_REMOVED:
                        final Bundle intentExtras = intent.getExtras();
                        final int uid = intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
                        if (uid >= 0) {
                            mBatteryStatsService.removeUid(uid);
                            mAppOpsService.uidRemoved(uid);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
                        // If resources are unavailable just force stop all those packages
                        // and flush the attribute cache as well.
                        String[] list = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
                        if (list != null && list.length > 0) {
                            for (int i = 0; i < list.length; i++) {
                                forceStopPackageLocked(list[i], -1, false, true, true, false, false, userId, "storage unmount");
                            }
                            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list, userId);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
                        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                        break;
                    case Intent.ACTION_PACKAGE_REMOVED:
                    case Intent.ACTION_PACKAGE_CHANGED:
                        Uri data = intent.getData();
                        String ssp;
                        if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                            boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);
                            boolean fullUninstall = removed && !intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                            final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);
                            if (killProcess) {
                                forceStopPackageLocked(ssp, UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID, -1)), false, true, true, false, fullUninstall, userId, removed ? "pkg removed" : "pkg changed");
                            }
                            if (removed) {
                                sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED, new String[] { ssp }, userId);
                                if (fullUninstall) {
                                    mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);
                                    // Remove all permissions granted from/to this package
                                    removeUriPermissionsForPackageLocked(ssp, userId, true);
                                    removeTasksByPackageNameLocked(ssp, userId);
                                    mBatteryStatsService.notePackageUninstalled(ssp);
                                }
                            } else {
                                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess, intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
                            }
                        }
                        break;
                }
                break;
            case Intent.ACTION_PACKAGE_ADDED:
                // Special case for adding a package: by default turn on compatibility mode.
                Uri data = intent.getData();
                String ssp;
                if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                    final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                    mCompatModePackages.handlePackageAddedLocked(ssp, replacing);
                    try {
                        ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, 0, 0);
                        mBatteryStatsService.notePackageInstalled(ssp, ai != null ? ai.versionCode : 0);
                    } catch (RemoteException e) {
                    }
                }
                break;
            case Intent.ACTION_TIMEZONE_CHANGED:
                // If this is the time zone changed action, queue up a message that will reset
                // the timezone of all currently running processes. This message will get
                // queued up before the broadcast happens.
                mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
                break;
            case Intent.ACTION_TIME_CHANGED:
                // If the user set the time, let all running processes know.
                final int is24Hour = intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, false) ? 1 : 0;
                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, 0));
                BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
                synchronized (stats) {
                    stats.noteCurrentTimeChangedLocked();
                }
                break;
            case Intent.ACTION_CLEAR_DNS_CACHE:
                mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
                break;
            case Proxy.PROXY_CHANGE_ACTION:
                ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));
                break;
        }
    }
    // Add to the sticky list if requested.
    if (sticky) {
        if (checkPermission(android.Manifest.permission.BROADCAST_STICKY, callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) {
            String msg = "Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=" + callingPid + ", uid=" + callingUid + " requires " + android.Manifest.permission.BROADCAST_STICKY;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        if (requiredPermissions != null && requiredPermissions.length > 0) {
            Slog.w(TAG, "Can't broadcast sticky intent " + intent + " and enforce permissions " + Arrays.toString(requiredPermissions));
            return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
        }
        if (intent.getComponent() != null) {
            throw new SecurityException("Sticky broadcasts can't target a specific component");
        }
        // as a separate set of sticky broadcasts.
        if (userId != UserHandle.USER_ALL) {
            // But first, if this is not a broadcast to all users, then
            // make sure it doesn't conflict with an existing broadcast to
            // all users.
            ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(UserHandle.USER_ALL);
            if (stickies != null) {
                ArrayList<Intent> list = stickies.get(intent.getAction());
                if (list != null) {
                    int N = list.size();
                    int i;
                    for (i = 0; i < N; i++) {
                        if (intent.filterEquals(list.get(i))) {
                            throw new IllegalArgumentException("Sticky broadcast " + intent + " for user " + userId + " conflicts with existing global broadcast");
                        }
                    }
                }
            }
        }
        ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);
        if (stickies == null) {
            stickies = new ArrayMap<>();
            mStickyBroadcasts.put(userId, stickies);
        }
        ArrayList<Intent> list = stickies.get(intent.getAction());
        if (list == null) {
            list = new ArrayList<>();
            stickies.put(intent.getAction(), list);
        }
        final int stickiesCount = list.size();
        int i;
        for (i = 0; i < stickiesCount; i++) {
            if (intent.filterEquals(list.get(i))) {
                // This sticky already exists, replace it.
                list.set(i, new Intent(intent));
                break;
            }
        }
        if (i >= stickiesCount) {
            list.add(new Intent(intent));
        }
    }
    int[] users;
    if (userId == UserHandle.USER_ALL) {
        // Caller wants broadcast to go to all started users.
        users = mStartedUserArray;
    } else {
        // Caller wants broadcast to go to one specific user.
        users = new int[] { userId };
    }
    // Figure out who all will receive this broadcast.
    List receivers = null;
    List<BroadcastFilter> registeredReceivers = null;
    // Need to resolve the intent to interested receivers...
    if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
    }
    if (intent.getComponent() == null) {
        if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
            // Query one target user at a time, excluding shell-restricted users
            UserManagerService ums = getUserManagerLocked();
            for (int i = 0; i < users.length; i++) {
                if (ums.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) {
                    continue;
                }
                List<BroadcastFilter> registeredReceiversForUser = mReceiverResolver.queryIntent(intent, resolvedType, false, users[i]);
                if (registeredReceivers == null) {
                    registeredReceivers = registeredReceiversForUser;
                } else if (registeredReceiversForUser != null) {
                    registeredReceivers.addAll(registeredReceiversForUser);
                }
            }
        } else {
            registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, false, userId);
        }
    }
    final boolean replacePending = (intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
    if (DEBUG_BROADCAST)
        Slog.v(TAG_BROADCAST, "Enqueing broadcast: " + intent.getAction() + " replacePending=" + replacePending);
    int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
    if (!ordered && NR > 0) {
        // If we are not serializing this broadcast, then send the
        // registered receivers separately so they don't wait for the
        // components to be launched.
        final BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing parallel broadcast " + r);
        final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);
        if (!replaced) {
            queue.enqueueParallelBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
        registeredReceivers = null;
        NR = 0;
    }
    // Merge into one list.
    int ir = 0;
    if (receivers != null) {
        // A special case for PACKAGE_ADDED: do not allow the package
        // being added to see this broadcast.  This prevents them from
        // using this as a back door to get run as soon as they are
        // installed.  Maybe in the future we want to have a special install
        // broadcast or such for apps, but we'd like to deliberately make
        // this decision.
        String[] skipPackages = null;
        if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
            Uri data = intent.getData();
            if (data != null) {
                String pkgName = data.getSchemeSpecificPart();
                if (pkgName != null) {
                    skipPackages = new String[] { pkgName };
                }
            }
        } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
            skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
        }
        if (skipPackages != null && (skipPackages.length > 0)) {
            for (String skipPackage : skipPackages) {
                if (skipPackage != null) {
                    int NT = receivers.size();
                    for (int it = 0; it < NT; it++) {
                        ResolveInfo curt = (ResolveInfo) receivers.get(it);
                        if (curt.activityInfo.packageName.equals(skipPackage)) {
                            receivers.remove(it);
                            it--;
                            NT--;
                        }
                    }
                }
            }
        }
        int NT = receivers != null ? receivers.size() : 0;
        int it = 0;
        ResolveInfo curt = null;
        BroadcastFilter curr = null;
        while (it < NT && ir < NR) {
            if (curt == null) {
                curt = (ResolveInfo) receivers.get(it);
            }
            if (curr == null) {
                curr = registeredReceivers.get(ir);
            }
            if (curr.getPriority() >= curt.priority) {
                // Insert this broadcast record into the final list.
                receivers.add(it, curr);
                ir++;
                curr = null;
                it++;
                NT++;
            } else {
                // Skip to the next ResolveInfo in the final list.
                it++;
                curt = null;
            }
        }
    }
    while (ir < NR) {
        if (receivers == null) {
            receivers = new ArrayList();
        }
        receivers.add(registeredReceivers.get(ir));
        ir++;
    }
    if ((receivers != null && receivers.size() > 0) || resultTo != null) {
        BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + r + ": prev had " + queue.mOrderedBroadcasts.size());
        if (DEBUG_BROADCAST)
            Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + r.intent.getAction());
        boolean replaced = replacePending && queue.replaceOrderedBroadcastLocked(r);
        if (!replaced) {
            queue.enqueueOrderedBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
    }
    return ActivityManager.BROADCAST_SUCCESS;
}
#method_after
final int broadcastIntentLocked(ProcessRecord callerApp, String callerPackage, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean ordered, boolean sticky, int callingPid, int callingUid, int userId) {
    intent = new Intent(intent);
    // By default broadcasts do not go to stopped apps.
    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);
    // If we have not finished booting, don't allow this to launch new processes.
    if (!mProcessesReady && (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) {
        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
    }
    if (DEBUG_BROADCAST_LIGHT)
        Slog.v(TAG_BROADCAST, (sticky ? "Broadcast sticky: " : "Broadcast: ") + intent + " ordered=" + ordered + " userid=" + userId);
    if ((resultTo != null) && !ordered) {
        Slog.w(TAG, "Broadcast " + intent + " not ordered but result callback requested!");
    }
    userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, true, ALLOW_NON_FULL, "broadcast", callerPackage);
    if (userId != UserHandle.USER_ALL && !mUserController.isUserRunningLocked(userId, 0)) {
        if ((callingUid != Process.SYSTEM_UID || (intent.getFlags() & Intent.FLAG_RECEIVER_BOOT_UPGRADE) == 0) && !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) {
            Slog.w(TAG, "Skipping broadcast of " + intent + ": user " + userId + " is stopped");
            return ActivityManager.BROADCAST_FAILED_USER_STOPPED;
        }
    }
    BroadcastOptions brOptions = null;
    if (bOptions != null) {
        brOptions = new BroadcastOptions(bOptions);
        if (brOptions.getTemporaryAppWhitelistDuration() > 0) {
            // PendingIntent), because that who is actually supplied the arguments.
            if (checkComponentPermission(android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST, Binder.getCallingPid(), Binder.getCallingUid(), -1, true) != PackageManager.PERMISSION_GRANTED) {
                String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            }
        }
    }
    // Verify that protected broadcasts are only being sent by system code,
    // and that system code is only sending protected broadcasts.
    final String action = intent.getAction();
    final boolean isProtectedBroadcast;
    try {
        isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);
    } catch (RemoteException e) {
        Slog.w(TAG, "Remote exception", e);
        return ActivityManager.BROADCAST_SUCCESS;
    }
    final boolean isCallerSystem;
    switch(UserHandle.getAppId(callingUid)) {
        case Process.ROOT_UID:
        case Process.SYSTEM_UID:
        case Process.PHONE_UID:
        case Process.BLUETOOTH_UID:
        case Process.NFC_UID:
            isCallerSystem = true;
            break;
        default:
            isCallerSystem = (callerApp != null) && callerApp.persistent;
            break;
    }
    if (isCallerSystem) {
        if (isProtectedBroadcast || Intent.ACTION_CLOSE_SYSTEM_DIALOGS.equals(action) || Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS.equals(action) || Intent.ACTION_MEDIA_BUTTON.equals(action) || Intent.ACTION_MEDIA_SCANNER_SCAN_FILE.equals(action) || Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS.equals(action) || AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action) || LocationManager.HIGH_POWER_REQUEST_CHANGE_ACTION.equals(action) || TelephonyIntents.ACTION_REQUEST_OMADM_CONFIGURATION_UPDATE.equals(action) || SuggestionSpan.ACTION_SUGGESTION_PICKED.equals(action)) {
        // Broadcast is either protected, or it's a public action that
        // we've relaxed, so it's fine for system internals to send.
        } else {
            // to ensure we examine these cases.
            if (callerApp != null) {
                Log.wtf(TAG, "Sending non-protected broadcast " + action + " from system " + callerApp.toShortString() + " pkg " + callerPackage, new Throwable());
            } else {
                Log.wtf(TAG, "Sending non-protected broadcast " + action + " from system uid " + UserHandle.formatUid(callingUid) + " pkg " + callerPackage, new Throwable());
            }
        }
    } else {
        if (isProtectedBroadcast) {
            String msg = "Permission Denial: not allowed to send broadcast " + action + " from pid=" + callingPid + ", uid=" + callingUid;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        } else if (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action) || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) {
            // just limit it to the caller.
            if (callerPackage == null) {
                String msg = "Permission Denial: not allowed to send broadcast " + action + " from unknown caller.";
                Slog.w(TAG, msg);
                throw new SecurityException(msg);
            } else if (intent.getComponent() != null) {
                // it is being sent to the calling app.
                if (!intent.getComponent().getPackageName().equals(callerPackage)) {
                    String msg = "Permission Denial: not allowed to send broadcast " + action + " to " + intent.getComponent().getPackageName() + " from " + callerPackage;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
            } else {
                // Limit broadcast to their own package.
                intent.setPackage(callerPackage);
            }
        }
    }
    if (action != null) {
        switch(action) {
            case Intent.ACTION_UID_REMOVED:
            case Intent.ACTION_PACKAGE_REMOVED:
            case Intent.ACTION_PACKAGE_CHANGED:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
            case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
            case Intent.ACTION_PACKAGES_SUSPENDED:
            case Intent.ACTION_PACKAGES_UNSUSPENDED:
                // its activities from the history stack.
                if (checkComponentPermission(android.Manifest.permission.BROADCAST_PACKAGE_REMOVED, callingPid, callingUid, -1, true) != PackageManager.PERMISSION_GRANTED) {
                    String msg = "Permission Denial: " + intent.getAction() + " broadcast from " + callerPackage + " (pid=" + callingPid + ", uid=" + callingUid + ")" + " requires " + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;
                    Slog.w(TAG, msg);
                    throw new SecurityException(msg);
                }
                switch(action) {
                    case Intent.ACTION_UID_REMOVED:
                        final Bundle intentExtras = intent.getExtras();
                        final int uid = intentExtras != null ? intentExtras.getInt(Intent.EXTRA_UID) : -1;
                        if (uid >= 0) {
                            mBatteryStatsService.removeUid(uid);
                            mAppOpsService.uidRemoved(uid);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:
                        // If resources are unavailable just force stop all those packages
                        // and flush the attribute cache as well.
                        String[] list = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
                        if (list != null && list.length > 0) {
                            for (int i = 0; i < list.length; i++) {
                                forceStopPackageLocked(list[i], -1, false, true, true, false, false, userId, "storage unmount");
                            }
                            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                            sendPackageBroadcastLocked(IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list, userId);
                        }
                        break;
                    case Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:
                        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);
                        break;
                    case Intent.ACTION_PACKAGE_REMOVED:
                    case Intent.ACTION_PACKAGE_CHANGED:
                        Uri data = intent.getData();
                        String ssp;
                        if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                            boolean removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);
                            final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                            final boolean killProcess = !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, false);
                            final boolean fullUninstall = removed && !replacing;
                            if (removed) {
                                if (killProcess) {
                                    forceStopPackageLocked(ssp, UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID, -1)), false, true, true, false, fullUninstall, userId, removed ? "pkg removed" : "pkg changed");
                                }
                                final int cmd = killProcess ? IApplicationThread.PACKAGE_REMOVED : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;
                                sendPackageBroadcastLocked(cmd, new String[] { ssp }, userId);
                                if (fullUninstall) {
                                    mAppOpsService.packageRemoved(intent.getIntExtra(Intent.EXTRA_UID, -1), ssp);
                                    // Remove all permissions granted from/to this package
                                    removeUriPermissionsForPackageLocked(ssp, userId, true);
                                    removeTasksByPackageNameLocked(ssp, userId);
                                    // Hide the "unsupported display" dialog if necessary.
                                    if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
                                        mUnsupportedDisplaySizeDialog.dismiss();
                                        mUnsupportedDisplaySizeDialog = null;
                                    }
                                    mCompatModePackages.handlePackageUninstalledLocked(ssp);
                                    mBatteryStatsService.notePackageUninstalled(ssp);
                                }
                            } else {
                                if (killProcess) {
                                    killPackageProcessesLocked(ssp, UserHandle.getAppId(intent.getIntExtra(Intent.EXTRA_UID, -1)), userId, ProcessList.INVALID_ADJ, false, true, true, false, "change " + ssp);
                                }
                                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess, intent.getStringArrayExtra(Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));
                            }
                        }
                        break;
                    case Intent.ACTION_PACKAGES_SUSPENDED:
                    case Intent.ACTION_PACKAGES_UNSUSPENDED:
                        final boolean suspended = Intent.ACTION_PACKAGES_SUSPENDED.equals(intent.getAction());
                        final String[] packageNames = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
                        final int userHandle = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);
                        synchronized (ActivityManagerService.this) {
                            mRecentTasks.onPackagesSuspendedChanged(packageNames, suspended, userHandle);
                        }
                        break;
                }
                break;
            case Intent.ACTION_PACKAGE_REPLACED:
                {
                    final Uri data = intent.getData();
                    final String ssp;
                    if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                        final ApplicationInfo aInfo = getPackageManagerInternalLocked().getApplicationInfo(ssp, userId);
                        if (aInfo == null) {
                            Slog.w(TAG, "Dropping ACTION_PACKAGE_REPLACED for non-existent pkg:" + " ssp=" + ssp + " data=" + data);
                            return ActivityManager.BROADCAST_SUCCESS;
                        }
                        mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);
                        sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED, new String[] { ssp }, userId);
                    }
                    break;
                }
            case Intent.ACTION_PACKAGE_ADDED:
                {
                    // Special case for adding a package: by default turn on compatibility mode.
                    Uri data = intent.getData();
                    String ssp;
                    if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                        final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);
                        mCompatModePackages.handlePackageAddedLocked(ssp, replacing);
                        try {
                            ApplicationInfo ai = AppGlobals.getPackageManager().getApplicationInfo(ssp, 0, 0);
                            mBatteryStatsService.notePackageInstalled(ssp, ai != null ? ai.versionCode : 0);
                        } catch (RemoteException e) {
                        }
                    }
                    break;
                }
            case Intent.ACTION_PACKAGE_DATA_CLEARED:
                {
                    Uri data = intent.getData();
                    String ssp;
                    if (data != null && (ssp = data.getSchemeSpecificPart()) != null) {
                        // Hide the "unsupported display" dialog if necessary.
                        if (mUnsupportedDisplaySizeDialog != null && ssp.equals(mUnsupportedDisplaySizeDialog.getPackageName())) {
                            mUnsupportedDisplaySizeDialog.dismiss();
                            mUnsupportedDisplaySizeDialog = null;
                        }
                        mCompatModePackages.handlePackageDataClearedLocked(ssp);
                    }
                    break;
                }
            case Intent.ACTION_TIMEZONE_CHANGED:
                // If this is the time zone changed action, queue up a message that will reset
                // the timezone of all currently running processes. This message will get
                // queued up before the broadcast happens.
                mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);
                break;
            case Intent.ACTION_TIME_CHANGED:
                // If the user set the time, let all running processes know.
                final int is24Hour = intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, false) ? 1 : 0;
                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, 0));
                BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
                synchronized (stats) {
                    stats.noteCurrentTimeChangedLocked();
                }
                break;
            case Intent.ACTION_CLEAR_DNS_CACHE:
                mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);
                break;
            case Proxy.PROXY_CHANGE_ACTION:
                ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);
                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));
                break;
            case android.hardware.Camera.ACTION_NEW_PICTURE:
            case android.hardware.Camera.ACTION_NEW_VIDEO:
                // These broadcasts are no longer allowed by the system, since they can
                // cause significant thrashing at a crictical point (using the camera).
                // Apps should use JobScehduler to monitor for media provider changes.
                Slog.w(TAG, action + " no longer allowed; dropping from " + UserHandle.formatUid(callingUid));
                if (resultTo != null) {
                    final BroadcastQueue queue = broadcastQueueForIntent(intent);
                    try {
                        queue.performReceiveLocked(callerApp, resultTo, intent, Activity.RESULT_CANCELED, null, null, false, false, userId);
                    } catch (RemoteException e) {
                        Slog.w(TAG, "Failure [" + queue.mQueueName + "] sending broadcast result of " + intent, e);
                    }
                }
                // Lie; we don't want to crash the app.
                return ActivityManager.BROADCAST_SUCCESS;
        }
    }
    // Add to the sticky list if requested.
    if (sticky) {
        if (checkPermission(android.Manifest.permission.BROADCAST_STICKY, callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) {
            String msg = "Permission Denial: broadcastIntent() requesting a sticky broadcast from pid=" + callingPid + ", uid=" + callingUid + " requires " + android.Manifest.permission.BROADCAST_STICKY;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        if (requiredPermissions != null && requiredPermissions.length > 0) {
            Slog.w(TAG, "Can't broadcast sticky intent " + intent + " and enforce permissions " + Arrays.toString(requiredPermissions));
            return ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;
        }
        if (intent.getComponent() != null) {
            throw new SecurityException("Sticky broadcasts can't target a specific component");
        }
        // as a separate set of sticky broadcasts.
        if (userId != UserHandle.USER_ALL) {
            // But first, if this is not a broadcast to all users, then
            // make sure it doesn't conflict with an existing broadcast to
            // all users.
            ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(UserHandle.USER_ALL);
            if (stickies != null) {
                ArrayList<Intent> list = stickies.get(intent.getAction());
                if (list != null) {
                    int N = list.size();
                    int i;
                    for (i = 0; i < N; i++) {
                        if (intent.filterEquals(list.get(i))) {
                            throw new IllegalArgumentException("Sticky broadcast " + intent + " for user " + userId + " conflicts with existing global broadcast");
                        }
                    }
                }
            }
        }
        ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);
        if (stickies == null) {
            stickies = new ArrayMap<>();
            mStickyBroadcasts.put(userId, stickies);
        }
        ArrayList<Intent> list = stickies.get(intent.getAction());
        if (list == null) {
            list = new ArrayList<>();
            stickies.put(intent.getAction(), list);
        }
        final int stickiesCount = list.size();
        int i;
        for (i = 0; i < stickiesCount; i++) {
            if (intent.filterEquals(list.get(i))) {
                // This sticky already exists, replace it.
                list.set(i, new Intent(intent));
                break;
            }
        }
        if (i >= stickiesCount) {
            list.add(new Intent(intent));
        }
    }
    int[] users;
    if (userId == UserHandle.USER_ALL) {
        // Caller wants broadcast to go to all started users.
        users = mUserController.getStartedUserArrayLocked();
    } else {
        // Caller wants broadcast to go to one specific user.
        users = new int[] { userId };
    }
    // Figure out who all will receive this broadcast.
    List receivers = null;
    List<BroadcastFilter> registeredReceivers = null;
    // Need to resolve the intent to interested receivers...
    if ((intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);
    }
    if (intent.getComponent() == null) {
        if (userId == UserHandle.USER_ALL && callingUid == Process.SHELL_UID) {
            // Query one target user at a time, excluding shell-restricted users
            for (int i = 0; i < users.length; i++) {
                if (mUserController.hasUserRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) {
                    continue;
                }
                List<BroadcastFilter> registeredReceiversForUser = mReceiverResolver.queryIntent(intent, resolvedType, false, users[i]);
                if (registeredReceivers == null) {
                    registeredReceivers = registeredReceiversForUser;
                } else if (registeredReceiversForUser != null) {
                    registeredReceivers.addAll(registeredReceiversForUser);
                }
            }
        } else {
            registeredReceivers = mReceiverResolver.queryIntent(intent, resolvedType, false, userId);
        }
    }
    final boolean replacePending = (intent.getFlags() & Intent.FLAG_RECEIVER_REPLACE_PENDING) != 0;
    if (DEBUG_BROADCAST)
        Slog.v(TAG_BROADCAST, "Enqueing broadcast: " + intent.getAction() + " replacePending=" + replacePending);
    int NR = registeredReceivers != null ? registeredReceivers.size() : 0;
    if (!ordered && NR > 0) {
        // If we are not serializing this broadcast, then send the
        // registered receivers separately so they don't wait for the
        // components to be launched.
        final BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing parallel broadcast " + r);
        final boolean replaced = replacePending && queue.replaceParallelBroadcastLocked(r);
        if (!replaced) {
            queue.enqueueParallelBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
        registeredReceivers = null;
        NR = 0;
    }
    // Merge into one list.
    int ir = 0;
    if (receivers != null) {
        // A special case for PACKAGE_ADDED: do not allow the package
        // being added to see this broadcast.  This prevents them from
        // using this as a back door to get run as soon as they are
        // installed.  Maybe in the future we want to have a special install
        // broadcast or such for apps, but we'd like to deliberately make
        // this decision.
        String[] skipPackages = null;
        if (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction()) || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) {
            Uri data = intent.getData();
            if (data != null) {
                String pkgName = data.getSchemeSpecificPart();
                if (pkgName != null) {
                    skipPackages = new String[] { pkgName };
                }
            }
        } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) {
            skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);
        }
        if (skipPackages != null && (skipPackages.length > 0)) {
            for (String skipPackage : skipPackages) {
                if (skipPackage != null) {
                    int NT = receivers.size();
                    for (int it = 0; it < NT; it++) {
                        ResolveInfo curt = (ResolveInfo) receivers.get(it);
                        if (curt.activityInfo.packageName.equals(skipPackage)) {
                            receivers.remove(it);
                            it--;
                            NT--;
                        }
                    }
                }
            }
        }
        int NT = receivers != null ? receivers.size() : 0;
        int it = 0;
        ResolveInfo curt = null;
        BroadcastFilter curr = null;
        while (it < NT && ir < NR) {
            if (curt == null) {
                curt = (ResolveInfo) receivers.get(it);
            }
            if (curr == null) {
                curr = registeredReceivers.get(ir);
            }
            if (curr.getPriority() >= curt.priority) {
                // Insert this broadcast record into the final list.
                receivers.add(it, curr);
                ir++;
                curr = null;
                it++;
                NT++;
            } else {
                // Skip to the next ResolveInfo in the final list.
                it++;
                curt = null;
            }
        }
    }
    while (ir < NR) {
        if (receivers == null) {
            receivers = new ArrayList();
        }
        receivers.add(registeredReceivers.get(ir));
        ir++;
    }
    if ((receivers != null && receivers.size() > 0) || resultTo != null) {
        BroadcastQueue queue = broadcastQueueForIntent(intent);
        BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId);
        if (DEBUG_BROADCAST)
            Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + r + ": prev had " + queue.mOrderedBroadcasts.size());
        if (DEBUG_BROADCAST)
            Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + r.intent.getAction());
        boolean replaced = replacePending && queue.replaceOrderedBroadcastLocked(r);
        if (!replaced) {
            queue.enqueueOrderedBroadcastLocked(r);
            queue.scheduleBroadcastsLocked();
        }
    } else {
        // that it happened.
        if (intent.getComponent() == null && intent.getPackage() == null && (intent.getFlags() & Intent.FLAG_RECEIVER_REGISTERED_ONLY) == 0) {
            // This was an implicit broadcast... let's record it for posterity.
            addBroadcastStatLocked(intent.getAction(), callerPackage, 0, 0, 0);
        }
    }
    return ActivityManager.BROADCAST_SUCCESS;
}
#end_block

#method_before
public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options, boolean serialized, boolean sticky, int userId) {
    enforceNotIsolatedCaller("broadcastIntent");
    synchronized (this) {
        intent = verifyBroadcastLocked(intent);
        final ProcessRecord callerApp = getRecordForAppLocked(caller);
        final int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, null, serialized, sticky, callingPid, callingUid, userId);
        Binder.restoreCallingIdentity(origId);
        return res;
    }
}
#method_after
public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle bOptions, boolean serialized, boolean sticky, int userId) {
    enforceNotIsolatedCaller("broadcastIntent");
    synchronized (this) {
        intent = verifyBroadcastLocked(intent);
        final ProcessRecord callerApp = getRecordForAppLocked(caller);
        final int callingPid = Binder.getCallingPid();
        final int callingUid = Binder.getCallingUid();
        final long origId = Binder.clearCallingIdentity();
        int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, bOptions, serialized, sticky, callingPid, callingUid, userId);
        Binder.restoreCallingIdentity(origId);
        return res;
    }
}
#end_block

#method_before
int broadcastIntentInPackage(String packageName, int uid, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String requiredPermission, Bundle options, boolean serialized, boolean sticky, int userId) {
    synchronized (this) {
        intent = verifyBroadcastLocked(intent);
        final long origId = Binder.clearCallingIdentity();
        String[] requiredPermissions = requiredPermission == null ? null : new String[] { requiredPermission };
        int res = broadcastIntentLocked(null, packageName, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, AppOpsManager.OP_NONE, options, serialized, sticky, -1, uid, userId);
        Binder.restoreCallingIdentity(origId);
        return res;
    }
}
#method_after
int broadcastIntentInPackage(String packageName, int uid, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String requiredPermission, Bundle bOptions, boolean serialized, boolean sticky, int userId) {
    synchronized (this) {
        intent = verifyBroadcastLocked(intent);
        final long origId = Binder.clearCallingIdentity();
        String[] requiredPermissions = requiredPermission == null ? null : new String[] { requiredPermission };
        int res = broadcastIntentLocked(null, packageName, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, AppOpsManager.OP_NONE, bOptions, serialized, sticky, -1, uid, userId);
        Binder.restoreCallingIdentity(origId);
        return res;
    }
}
#end_block

#method_before
public final void unbroadcastIntent(IApplicationThread caller, Intent intent, int userId) {
    // Refuse possible leaked file descriptors
    if (intent != null && intent.hasFileDescriptors() == true) {
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, ALLOW_NON_FULL, "removeStickyBroadcast", null);
    synchronized (this) {
        if (checkCallingPermission(android.Manifest.permission.BROADCAST_STICKY) != PackageManager.PERMISSION_GRANTED) {
            String msg = "Permission Denial: unbroadcastIntent() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.BROADCAST_STICKY;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);
        if (stickies != null) {
            ArrayList<Intent> list = stickies.get(intent.getAction());
            if (list != null) {
                int N = list.size();
                int i;
                for (i = 0; i < N; i++) {
                    if (intent.filterEquals(list.get(i))) {
                        list.remove(i);
                        break;
                    }
                }
                if (list.size() <= 0) {
                    stickies.remove(intent.getAction());
                }
            }
            if (stickies.size() <= 0) {
                mStickyBroadcasts.remove(userId);
            }
        }
    }
}
#method_after
public final void unbroadcastIntent(IApplicationThread caller, Intent intent, int userId) {
    // Refuse possible leaked file descriptors
    if (intent != null && intent.hasFileDescriptors() == true) {
        throw new IllegalArgumentException("File descriptors passed in Intent");
    }
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, ALLOW_NON_FULL, "removeStickyBroadcast", null);
    synchronized (this) {
        if (checkCallingPermission(android.Manifest.permission.BROADCAST_STICKY) != PackageManager.PERMISSION_GRANTED) {
            String msg = "Permission Denial: unbroadcastIntent() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + android.Manifest.permission.BROADCAST_STICKY;
            Slog.w(TAG, msg);
            throw new SecurityException(msg);
        }
        ArrayMap<String, ArrayList<Intent>> stickies = mStickyBroadcasts.get(userId);
        if (stickies != null) {
            ArrayList<Intent> list = stickies.get(intent.getAction());
            if (list != null) {
                int N = list.size();
                int i;
                for (i = 0; i < N; i++) {
                    if (intent.filterEquals(list.get(i))) {
                        list.remove(i);
                        break;
                    }
                }
                if (list.size() <= 0) {
                    stickies.remove(intent.getAction());
                }
            }
            if (stickies.size() <= 0) {
                mStickyBroadcasts.remove(userId);
            }
        }
    }
}
#end_block

#method_before
// =========================================================
// INSTRUMENTATION
// =========================================================
public boolean startInstrumentation(ComponentName className, String profileFile, int flags, Bundle arguments, IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection, int userId, String abiOverride) {
    enforceNotIsolatedCaller("startInstrumentation");
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startInstrumentation", null);
    // Refuse possible leaked file descriptors
    if (arguments != null && arguments.hasFileDescriptors()) {
        throw new IllegalArgumentException("File descriptors passed in Bundle");
    }
    synchronized (this) {
        InstrumentationInfo ii = null;
        ApplicationInfo ai = null;
        try {
            ii = mContext.getPackageManager().getInstrumentationInfo(className, STOCK_PM_FLAGS);
            ai = AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage, STOCK_PM_FLAGS, userId);
        } catch (PackageManager.NameNotFoundException e) {
        } catch (RemoteException e) {
        }
        if (ii == null) {
            reportStartInstrumentationFailure(watcher, className, "Unable to find instrumentation info for: " + className);
            return false;
        }
        if (ai == null) {
            reportStartInstrumentationFailure(watcher, className, "Unable to find instrumentation target package: " + ii.targetPackage);
            return false;
        }
        int match = mContext.getPackageManager().checkSignatures(ii.targetPackage, ii.packageName);
        if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
            String msg = "Permission Denial: starting instrumentation " + className + " from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingPid() + " not allowed because package " + ii.packageName + " does not have a signature matching the target " + ii.targetPackage;
            reportStartInstrumentationFailure(watcher, className, msg);
            throw new SecurityException(msg);
        }
        final long origId = Binder.clearCallingIdentity();
        // Instrumentation can kill and relaunch even persistent processes
        forceStopPackageLocked(ii.targetPackage, -1, true, false, true, true, false, userId, "start instr");
        ProcessRecord app = addAppLocked(ai, false, abiOverride);
        app.instrumentationClass = className;
        app.instrumentationInfo = ai;
        app.instrumentationProfileFile = profileFile;
        app.instrumentationArguments = arguments;
        app.instrumentationWatcher = watcher;
        app.instrumentationUiAutomationConnection = uiAutomationConnection;
        app.instrumentationResultClass = className;
        Binder.restoreCallingIdentity(origId);
    }
    return true;
}
#method_after
// =========================================================
// INSTRUMENTATION
// =========================================================
public boolean startInstrumentation(ComponentName className, String profileFile, int flags, Bundle arguments, IInstrumentationWatcher watcher, IUiAutomationConnection uiAutomationConnection, int userId, String abiOverride) {
    enforceNotIsolatedCaller("startInstrumentation");
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startInstrumentation", null);
    // Refuse possible leaked file descriptors
    if (arguments != null && arguments.hasFileDescriptors()) {
        throw new IllegalArgumentException("File descriptors passed in Bundle");
    }
    synchronized (this) {
        InstrumentationInfo ii = null;
        ApplicationInfo ai = null;
        try {
            ii = mContext.getPackageManager().getInstrumentationInfo(className, STOCK_PM_FLAGS);
            ai = AppGlobals.getPackageManager().getApplicationInfo(ii.targetPackage, STOCK_PM_FLAGS, userId);
        } catch (PackageManager.NameNotFoundException e) {
        } catch (RemoteException e) {
        }
        if (ii == null) {
            reportStartInstrumentationFailureLocked(watcher, className, "Unable to find instrumentation info for: " + className);
            return false;
        }
        if (ai == null) {
            reportStartInstrumentationFailureLocked(watcher, className, "Unable to find instrumentation target package: " + ii.targetPackage);
            return false;
        }
        if (!ai.hasCode()) {
            reportStartInstrumentationFailureLocked(watcher, className, "Instrumentation target has no code: " + ii.targetPackage);
            return false;
        }
        int match = mContext.getPackageManager().checkSignatures(ii.targetPackage, ii.packageName);
        if (match < 0 && match != PackageManager.SIGNATURE_FIRST_NOT_SIGNED) {
            String msg = "Permission Denial: starting instrumentation " + className + " from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingPid() + " not allowed because package " + ii.packageName + " does not have a signature matching the target " + ii.targetPackage;
            reportStartInstrumentationFailureLocked(watcher, className, msg);
            throw new SecurityException(msg);
        }
        final long origId = Binder.clearCallingIdentity();
        // Instrumentation can kill and relaunch even persistent processes
        forceStopPackageLocked(ii.targetPackage, -1, true, false, true, true, false, userId, "start instr");
        ProcessRecord app = addAppLocked(ai, false, abiOverride);
        app.instrumentationClass = className;
        app.instrumentationInfo = ai;
        app.instrumentationProfileFile = profileFile;
        app.instrumentationArguments = arguments;
        app.instrumentationWatcher = watcher;
        app.instrumentationUiAutomationConnection = uiAutomationConnection;
        app.instrumentationResultClass = className;
        Binder.restoreCallingIdentity(origId);
    }
    return true;
}
#end_block

#method_before
void finishInstrumentationLocked(ProcessRecord app, int resultCode, Bundle results) {
    if (app.instrumentationWatcher != null) {
        try {
            // NOTE:  IInstrumentationWatcher *must* be oneway here
            app.instrumentationWatcher.instrumentationFinished(app.instrumentationClass, resultCode, results);
        } catch (RemoteException e) {
        }
    }
    // Can't call out of the system process with a lock held, so post a message.
    if (app.instrumentationUiAutomationConnection != null) {
        mHandler.obtainMessage(SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG, app.instrumentationUiAutomationConnection).sendToTarget();
    }
    app.instrumentationWatcher = null;
    app.instrumentationUiAutomationConnection = null;
    app.instrumentationClass = null;
    app.instrumentationInfo = null;
    app.instrumentationProfileFile = null;
    app.instrumentationArguments = null;
    forceStopPackageLocked(app.info.packageName, -1, false, false, true, true, false, app.userId, "finished inst");
}
#method_after
void finishInstrumentationLocked(ProcessRecord app, int resultCode, Bundle results) {
    if (app.instrumentationWatcher != null) {
        mInstrumentationReporter.reportFinished(app.instrumentationWatcher, app.instrumentationClass, resultCode, results);
    }
    // Can't call out of the system process with a lock held, so post a message.
    if (app.instrumentationUiAutomationConnection != null) {
        mHandler.obtainMessage(SHUTDOWN_UI_AUTOMATION_CONNECTION_MSG, app.instrumentationUiAutomationConnection).sendToTarget();
    }
    app.instrumentationWatcher = null;
    app.instrumentationUiAutomationConnection = null;
    app.instrumentationClass = null;
    app.instrumentationInfo = null;
    app.instrumentationProfileFile = null;
    app.instrumentationArguments = null;
    forceStopPackageLocked(app.info.packageName, -1, false, false, true, true, false, app.userId, "finished inst");
}
#end_block

#method_before
public void updatePersistentConfiguration(Configuration values) {
    enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, "updateConfiguration()");
    enforceWriteSettingsPermission("updateConfiguration()");
    if (values == null) {
        throw new NullPointerException("Configuration must not be null");
    }
    synchronized (this) {
        final long origId = Binder.clearCallingIdentity();
        updateConfigurationLocked(values, null, true, false);
        Binder.restoreCallingIdentity(origId);
    }
}
#method_after
@Override
public void updatePersistentConfiguration(Configuration values) {
    enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, "updateConfiguration()");
    enforceWriteSettingsPermission("updateConfiguration()");
    if (values == null) {
        throw new NullPointerException("Configuration must not be null");
    }
    int userId = UserHandle.getCallingUserId();
    synchronized (this) {
        final long origId = Binder.clearCallingIdentity();
        updateConfigurationLocked(values, null, false, true, userId);
        Binder.restoreCallingIdentity(origId);
    }
}
#end_block

#method_before
public void updateConfiguration(Configuration values) {
    enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, "updateConfiguration()");
    synchronized (this) {
        if (values == null && mWindowManager != null) {
            // sentinel: fetch the current configuration from the window manager
            values = mWindowManager.computeNewConfiguration();
        }
        if (mWindowManager != null) {
            mProcessList.applyDisplaySize(mWindowManager);
        }
        final long origId = Binder.clearCallingIdentity();
        if (values != null) {
            Settings.System.clearConfiguration(values);
        }
        updateConfigurationLocked(values, null, false, false);
        Binder.restoreCallingIdentity(origId);
    }
}
#method_after
public void updateConfiguration(Configuration values) {
    enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, "updateConfiguration()");
    synchronized (this) {
        if (values == null && mWindowManager != null) {
            // sentinel: fetch the current configuration from the window manager
            values = mWindowManager.computeNewConfiguration();
        }
        if (mWindowManager != null) {
            mProcessList.applyDisplaySize(mWindowManager);
        }
        final long origId = Binder.clearCallingIdentity();
        if (values != null) {
            Settings.System.clearConfiguration(values);
        }
        updateConfigurationLocked(values, null, false);
        Binder.restoreCallingIdentity(origId);
    }
}
#end_block

#method_before
boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean persistent, boolean initLocale) {
    int changes = 0;
    if (values != null) {
        Configuration newConfig = new Configuration(mConfiguration);
        changes = newConfig.updateFrom(values);
        if (changes != 0) {
            if (DEBUG_SWITCH || DEBUG_CONFIGURATION)
                Slog.i(TAG_CONFIGURATION, "Updating configuration to: " + values);
            EventLog.writeEvent(EventLogTags.CONFIGURATION_CHANGED, changes);
            if (!initLocale && values.locale != null && values.userSetLocale) {
                final String languageTag = values.locale.toLanguageTag();
                SystemProperties.set("persist.sys.locale", languageTag);
                mHandler.sendMessage(mHandler.obtainMessage(SEND_LOCALE_TO_MOUNT_DAEMON_MSG, values.locale));
            }
            mConfigurationSeq++;
            if (mConfigurationSeq <= 0) {
                mConfigurationSeq = 1;
            }
            newConfig.seq = mConfigurationSeq;
            mConfiguration = newConfig;
            Slog.i(TAG, "Config changes=" + Integer.toHexString(changes) + " " + newConfig);
            mUsageStatsService.reportConfigurationChange(newConfig, mCurrentUserId);
            // mUsageStatsService.noteStartConfig(newConfig);
            final Configuration configCopy = new Configuration(mConfiguration);
            // TODO: If our config changes, should we auto dismiss any currently
            // showing dialogs?
            mShowDialogs = shouldShowDialogs(newConfig);
            AttributeCache ac = AttributeCache.instance();
            if (ac != null) {
                ac.updateConfiguration(configCopy);
            }
            // Make sure all resources in our process are updated
            // right now, so that anyone who is going to retrieve
            // resource values after we return will be sure to get
            // the new ones.  This is especially important during
            // boot, where the first config change needs to guarantee
            // all resources have that config before following boot
            // code is executed.
            mSystemThread.applyConfigurationToResources(configCopy);
            if (persistent && Settings.System.hasInterestingConfigurationChanges(changes)) {
                Message msg = mHandler.obtainMessage(UPDATE_CONFIGURATION_MSG);
                msg.obj = new Configuration(configCopy);
                mHandler.sendMessage(msg);
            }
            for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
                ProcessRecord app = mLruProcesses.get(i);
                try {
                    if (app.thread != null) {
                        if (DEBUG_CONFIGURATION)
                            Slog.v(TAG_CONFIGURATION, "Sending to proc " + app.processName + " new config " + mConfiguration);
                        app.thread.scheduleConfigurationChanged(configCopy);
                    }
                } catch (Exception e) {
                }
            }
            Intent intent = new Intent(Intent.ACTION_CONFIGURATION_CHANGED);
            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_REPLACE_PENDING | Intent.FLAG_RECEIVER_FOREGROUND);
            broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);
            if ((changes & ActivityInfo.CONFIG_LOCALE) != 0) {
                intent = new Intent(Intent.ACTION_LOCALE_CHANGED);
                intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
                if (!mProcessesReady) {
                    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
                }
                broadcastIntentLocked(null, null, intent, null, null, 0, null, null, null, AppOpsManager.OP_NONE, null, false, false, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);
            }
        }
    }
    boolean kept = true;
    final ActivityStack mainStack = mStackSupervisor.getFocusedStack();
    // mainStack is null during startup.
    if (mainStack != null) {
        if (changes != 0 && starting == null) {
            // If the configuration changed, and the caller is not already
            // in the process of starting an activity, then find the top
            // activity to check if its configuration needs to change.
            starting = mainStack.topRunningActivityLocked(null);
        }
        if (starting != null) {
            kept = mainStack.ensureActivityConfigurationLocked(starting, changes);
            // And we need to make sure at this point that all other activities
            // are made visible with the correct configuration.
            mStackSupervisor.ensureActivitiesVisibleLocked(starting, changes);
        }
    }
    if (values != null && mWindowManager != null) {
        mWindowManager.setNewConfiguration(mConfiguration);
    }
    return kept;
}
#method_after
boolean updateConfigurationLocked(Configuration values, ActivityRecord starting, boolean initLocale) {
    // pass UserHandle.USER_NULL as userId because we don't persist configuration for any user
    return updateConfigurationLocked(values, starting, initLocale, false, UserHandle.USER_NULL);
}
#end_block

#method_before
private static final boolean shouldShowDialogs(Configuration config) {
    return !(config.keyboard == Configuration.KEYBOARD_NOKEYS && config.touchscreen == Configuration.TOUCHSCREEN_NOTOUCH && config.navigation == Configuration.NAVIGATION_NONAV);
}
#method_after
private static final boolean shouldShowDialogs(Configuration config, boolean inVrMode) {
    final boolean inputMethodExists = !(config.keyboard == Configuration.KEYBOARD_NOKEYS && config.touchscreen == Configuration.TOUCHSCREEN_NOTOUCH && config.navigation == Configuration.NAVIGATION_NONAV);
    final boolean uiIsNotCarType = !((config.uiMode & Configuration.UI_MODE_TYPE_MASK) == Configuration.UI_MODE_TYPE_CAR);
    return inputMethodExists && uiIsNotCarType && !inVrMode;
}
#end_block

#method_before
Association startAssociationLocked(int sourceUid, String sourceProcess, int targetUid, ComponentName targetComponent, String targetProcess) {
    if (!mTrackingAssociations) {
        return null;
    }
    ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components = mAssociations.get(targetUid);
    if (components == null) {
        components = new ArrayMap<>();
        mAssociations.put(targetUid, components);
    }
    SparseArray<ArrayMap<String, Association>> sourceUids = components.get(targetComponent);
    if (sourceUids == null) {
        sourceUids = new SparseArray<>();
        components.put(targetComponent, sourceUids);
    }
    ArrayMap<String, Association> sourceProcesses = sourceUids.get(sourceUid);
    if (sourceProcesses == null) {
        sourceProcesses = new ArrayMap<>();
        sourceUids.put(sourceUid, sourceProcesses);
    }
    Association ass = sourceProcesses.get(sourceProcess);
    if (ass == null) {
        ass = new Association(sourceUid, sourceProcess, targetUid, targetComponent, targetProcess);
        sourceProcesses.put(sourceProcess, ass);
    }
    ass.mCount++;
    ass.mNesting++;
    if (ass.mNesting == 1) {
        ass.mStartTime = SystemClock.uptimeMillis();
    }
    return ass;
}
#method_after
Association startAssociationLocked(int sourceUid, String sourceProcess, int sourceState, int targetUid, ComponentName targetComponent, String targetProcess) {
    if (!mTrackingAssociations) {
        return null;
    }
    ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components = mAssociations.get(targetUid);
    if (components == null) {
        components = new ArrayMap<>();
        mAssociations.put(targetUid, components);
    }
    SparseArray<ArrayMap<String, Association>> sourceUids = components.get(targetComponent);
    if (sourceUids == null) {
        sourceUids = new SparseArray<>();
        components.put(targetComponent, sourceUids);
    }
    ArrayMap<String, Association> sourceProcesses = sourceUids.get(sourceUid);
    if (sourceProcesses == null) {
        sourceProcesses = new ArrayMap<>();
        sourceUids.put(sourceUid, sourceProcesses);
    }
    Association ass = sourceProcesses.get(sourceProcess);
    if (ass == null) {
        ass = new Association(sourceUid, sourceProcess, targetUid, targetComponent, targetProcess);
        sourceProcesses.put(sourceProcess, ass);
    }
    ass.mCount++;
    ass.mNesting++;
    if (ass.mNesting == 1) {
        ass.mStartTime = ass.mLastStateUptime = SystemClock.uptimeMillis();
        ass.mLastState = sourceState;
    }
    return ass;
}
#end_block

#method_before
void stopAssociationLocked(int sourceUid, String sourceProcess, int targetUid, ComponentName targetComponent) {
    if (!mTrackingAssociations) {
        return;
    }
    ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components = mAssociations.get(targetUid);
    if (components == null) {
        return;
    }
    SparseArray<ArrayMap<String, Association>> sourceUids = components.get(targetComponent);
    if (sourceUids == null) {
        return;
    }
    ArrayMap<String, Association> sourceProcesses = sourceUids.get(sourceUid);
    if (sourceProcesses == null) {
        return;
    }
    Association ass = sourceProcesses.get(sourceProcess);
    if (ass == null || ass.mNesting <= 0) {
        return;
    }
    ass.mNesting--;
    if (ass.mNesting == 0) {
        ass.mTime += SystemClock.uptimeMillis() - ass.mStartTime;
    }
}
#method_after
void stopAssociationLocked(int sourceUid, String sourceProcess, int targetUid, ComponentName targetComponent) {
    if (!mTrackingAssociations) {
        return;
    }
    ArrayMap<ComponentName, SparseArray<ArrayMap<String, Association>>> components = mAssociations.get(targetUid);
    if (components == null) {
        return;
    }
    SparseArray<ArrayMap<String, Association>> sourceUids = components.get(targetComponent);
    if (sourceUids == null) {
        return;
    }
    ArrayMap<String, Association> sourceProcesses = sourceUids.get(sourceUid);
    if (sourceProcesses == null) {
        return;
    }
    Association ass = sourceProcesses.get(sourceProcess);
    if (ass == null || ass.mNesting <= 0) {
        return;
    }
    ass.mNesting--;
    if (ass.mNesting == 0) {
        long uptime = SystemClock.uptimeMillis();
        ass.mTime += uptime - ass.mStartTime;
        ass.mStateTimes[ass.mLastState - ActivityManager.MIN_PROCESS_STATE] += uptime - ass.mLastStateUptime;
        ass.mLastState = ActivityManager.MAX_PROCESS_STATE + 2;
    }
}
#end_block

#method_before
private final int computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
    if (mAdjSeq == app.adjSeq) {
        // This adjustment has already been computed.
        return app.curRawAdj;
    }
    if (app.thread == null) {
        app.adjSeq = mAdjSeq;
        app.curSchedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
        app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        return (app.curAdj = app.curRawAdj = ProcessList.CACHED_APP_MAX_ADJ);
    }
    app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
    app.adjSource = null;
    app.adjTarget = null;
    app.empty = false;
    app.cached = false;
    final int activitiesSize = app.activities.size();
    if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
        // The max adjustment doesn't allow this app to be anything
        // below foreground, so it is not worth doing work for it.
        app.adjType = "fixed";
        app.adjSeq = mAdjSeq;
        app.curRawAdj = app.maxAdj;
        app.foregroundActivities = false;
        app.curSchedGroup = Process.THREAD_GROUP_DEFAULT;
        app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT;
        // System processes can do UI, and when they do we want to have
        // them trim their memory after the user leaves the UI.  To
        // facilitate this, here we need to determine whether or not it
        // is currently showing UI.
        app.systemNoUi = true;
        if (app == TOP_APP) {
            app.systemNoUi = false;
        } else if (activitiesSize > 0) {
            for (int j = 0; j < activitiesSize; j++) {
                final ActivityRecord r = app.activities.get(j);
                if (r.visible) {
                    app.systemNoUi = false;
                }
            }
        }
        if (!app.systemNoUi) {
            app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;
        }
        return (app.curAdj = app.maxAdj);
    }
    app.systemNoUi = false;
    final int PROCESS_STATE_CUR_TOP = mTopProcessState;
    // Determine the importance of the process, starting with most
    // important to least, and assign an appropriate OOM adjustment.
    int adj;
    int schedGroup;
    int procState;
    boolean foregroundActivities = false;
    BroadcastQueue queue;
    if (app == TOP_APP) {
        // The last app on the list is the foreground app.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = Process.THREAD_GROUP_DEFAULT;
        app.adjType = "top-activity";
        foregroundActivities = true;
        procState = PROCESS_STATE_CUR_TOP;
    } else if (app.instrumentationClass != null) {
        // Don't want to kill running instrumentation.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = Process.THREAD_GROUP_DEFAULT;
        app.adjType = "instrumentation";
        procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
    } else if ((queue = isReceivingBroadcast(app)) != null) {
        // An app that is currently receiving a broadcast also
        // counts as being in the foreground for OOM killer purposes.
        // It's placed in a sched group based on the nature of the
        // broadcast as reflected by which queue it's active in.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = (queue == mFgBroadcastQueue) ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
        app.adjType = "broadcast";
        procState = ActivityManager.PROCESS_STATE_RECEIVER;
    } else if (app.executingServices.size() > 0) {
        // An app that is currently executing a service callback also
        // counts as being in the foreground.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = app.execServicesFg ? Process.THREAD_GROUP_DEFAULT : Process.THREAD_GROUP_BG_NONINTERACTIVE;
        app.adjType = "exec-service";
        procState = ActivityManager.PROCESS_STATE_SERVICE;
    // Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);
    } else {
        // As far as we know the process is empty.  We may change our mind later.
        schedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
        // At this point we don't actually know the adjustment.  Use the cached adj
        // value that the caller wants us to.
        adj = cachedAdj;
        procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        app.cached = true;
        app.empty = true;
        app.adjType = "cch-empty";
    }
    // Examine all activities if not already foreground.
    if (!foregroundActivities && activitiesSize > 0) {
        for (int j = 0; j < activitiesSize; j++) {
            final ActivityRecord r = app.activities.get(j);
            if (r.app != app) {
                Slog.w(TAG, "Wtf, activity " + r + " in proc activity list not using proc " + app + "?!? Using " + r.app + " instead.");
                continue;
            }
            if (r.visible) {
                // App has a visible activity; only upgrade adjustment.
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                    adj = ProcessList.VISIBLE_APP_ADJ;
                    app.adjType = "visible";
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                }
                schedGroup = Process.THREAD_GROUP_DEFAULT;
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
                break;
            } else if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "pausing";
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                }
                schedGroup = Process.THREAD_GROUP_DEFAULT;
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else if (r.state == ActivityState.STOPPING) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "stopping";
                }
                // processes and they should soon all go into the cached state.
                if (!r.finishing) {
                    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
                        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
                    }
                }
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                    procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
                    app.adjType = "cch-act";
                }
            }
        }
    }
    if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
        if (app.foregroundServices) {
            // The user is aware of this app, so make it visible.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
            app.cached = false;
            app.adjType = "fg-service";
            schedGroup = Process.THREAD_GROUP_DEFAULT;
        } else if (app.forcingToForeground != null) {
            // The user is aware of this app, so make it visible.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            app.cached = false;
            app.adjType = "force-fg";
            app.adjSource = app.forcingToForeground;
            schedGroup = Process.THREAD_GROUP_DEFAULT;
        }
    }
    if (app == mHeavyWeightProcess) {
        if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
            // We don't want to kill the current heavy-weight process.
            adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;
            schedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
            app.cached = false;
            app.adjType = "heavy";
        }
        if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
            procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
        }
    }
    if (app == mHomeProcess) {
        if (adj > ProcessList.HOME_APP_ADJ) {
            // This process is hosting what we currently consider to be the
            // home app, so we don't want to let it go into the background.
            adj = ProcessList.HOME_APP_ADJ;
            schedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
            app.cached = false;
            app.adjType = "home";
        }
        if (procState > ActivityManager.PROCESS_STATE_HOME) {
            procState = ActivityManager.PROCESS_STATE_HOME;
        }
    }
    if (app == mPreviousProcess && app.activities.size() > 0) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            // This was the previous process that showed UI to the user.
            // We want to try to keep it around more aggressively, to give
            // a good experience around switching between two apps.
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
            app.cached = false;
            app.adjType = "previous";
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
        }
    }
    if (false)
        Slog.i(TAG, "OOM " + app + ": initial adj=" + adj + " reason=" + app.adjType);
    // By default, we use the computed adjustment.  It may be changed if
    // there are applications dependent on our services or providers, but
    // this gives us a baseline and makes sure we don't get into an
    // infinite recursion.
    app.adjSeq = mAdjSeq;
    app.curRawAdj = adj;
    app.hasStartedServices = false;
    if (mBackupTarget != null && app == mBackupTarget.app) {
        // If possible we want to avoid killing apps while they're being backed up
        if (adj > ProcessList.BACKUP_APP_ADJ) {
            if (DEBUG_BACKUP)
                Slog.v(TAG_BACKUP, "oom BACKUP_APP_ADJ for " + app);
            adj = ProcessList.BACKUP_APP_ADJ;
            if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
            app.adjType = "backup";
            app.cached = false;
        }
        if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
            procState = ActivityManager.PROCESS_STATE_BACKUP;
        }
    }
    boolean mayBeTop = false;
    for (int is = app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
        ServiceRecord s = app.services.valueAt(is);
        if (s.startRequested) {
            app.hasStartedServices = true;
            if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
                procState = ActivityManager.PROCESS_STATE_SERVICE;
            }
            if (app.hasShownUi && app != mHomeProcess) {
                // debug and understand what is going on.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-ui-services";
                }
            } else {
                if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                    // of the background processes.
                    if (adj > ProcessList.SERVICE_ADJ) {
                        adj = ProcessList.SERVICE_ADJ;
                        app.adjType = "started-services";
                        app.cached = false;
                    }
                }
                // even though the service no longer has an impact.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-services";
                }
            }
        }
        for (int conni = s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
            ArrayList<ConnectionRecord> clist = s.connections.valueAt(conni);
            for (int i = 0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
                // XXX should compute this based on the max of
                // all connected clients.
                ConnectionRecord cr = clist.get(i);
                if (cr.binding.client == app) {
                    // Binding to ourself is not interesting.
                    continue;
                }
                if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
                    ProcessRecord client = cr.binding.client;
                    int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
                    int clientProcState = client.curProcState;
                    if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                        // If the other app is cached for any reason, for purposes here
                        // we are going to consider it empty.  The specific cached state
                        // doesn't propagate except under certain conditions.
                        clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                    }
                    String adjType = null;
                    if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
                        // this guy more like a started service.
                        if (app.hasShownUi && app != mHomeProcess) {
                            // debug and understand what is going on.
                            if (adj > clientAdj) {
                                adjType = "cch-bound-ui-services";
                            }
                            app.cached = false;
                            clientAdj = adj;
                            clientProcState = procState;
                        } else {
                            if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                                // to help debug and undertand what is going on.
                                if (adj > clientAdj) {
                                    adjType = "cch-bound-services";
                                }
                                clientAdj = adj;
                            }
                        }
                    }
                    if (adj > clientAdj) {
                        // memory.
                        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                            adjType = "cch-bound-ui-services";
                        } else {
                            if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                                adj = clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
                            } else if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                            } else if (clientAdj > ProcessList.VISIBLE_APP_ADJ) {
                                adj = clientAdj;
                            } else {
                                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                                    adj = ProcessList.VISIBLE_APP_ADJ;
                                }
                            }
                            if (!client.cached) {
                                app.cached = false;
                            }
                            adjType = "service";
                        }
                    }
                    if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                        if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
                            schedGroup = Process.THREAD_GROUP_DEFAULT;
                        }
                        if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                            if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                                // Special handling of clients who are in the top state.
                                // We *may* want to consider this process to be in the
                                // top state as well, but only if there is not another
                                // reason for it to be running.  Being on the top is a
                                // special state, meaning you are specifically running
                                // for the current top app.  If the process is already
                                // running in the background for some other reason, it
                                // is more important to continue considering it to be
                                // in the background state.
                                mayBeTop = true;
                                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                            } else {
                                // give them the best state after that.
                                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else {
                                    clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                                }
                            }
                        }
                    } else {
                        if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                            clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
                        }
                    }
                    if (procState > clientProcState) {
                        procState = clientProcState;
                    }
                    if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
                        app.pendingUiClean = true;
                    }
                    if (adjType != null) {
                        app.adjType = adjType;
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = cr.binding.client;
                        app.adjSourceProcState = clientProcState;
                        app.adjTarget = s.name;
                    }
                }
                if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
                    app.treatLikeActivity = true;
                }
                final ActivityRecord a = cr.activity;
                if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
                    if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
                        adj = ProcessList.FOREGROUND_APP_ADJ;
                        if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                            schedGroup = Process.THREAD_GROUP_DEFAULT;
                        }
                        app.cached = false;
                        app.adjType = "service";
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = a;
                        app.adjSourceProcState = procState;
                        app.adjTarget = s.name;
                    }
                }
            }
        }
    }
    for (int provi = app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
        ContentProviderRecord cpr = app.pubProviders.valueAt(provi);
        for (int i = cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
            ContentProviderConnection conn = cpr.connections.get(i);
            ProcessRecord client = conn.client;
            if (client == app) {
                // Being our own client is not interesting.
                continue;
            }
            int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
            int clientProcState = client.curProcState;
            if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                // If the other app is cached for any reason, for purposes here
                // we are going to consider it empty.
                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
            }
            if (adj > clientAdj) {
                if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    app.adjType = "cch-ui-provider";
                } else {
                    adj = clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
                    app.adjType = "provider";
                }
                app.cached &= client.cached;
                app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
                app.adjSource = client;
                app.adjSourceProcState = clientProcState;
                app.adjTarget = cpr.name;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                    // Special handling of clients who are in the top state.
                    // We *may* want to consider this process to be in the
                    // top state as well, but only if there is not another
                    // reason for it to be running.  Being on the top is a
                    // special state, meaning you are specifically running
                    // for the current top app.  If the process is already
                    // running in the background for some other reason, it
                    // is more important to continue considering it to be
                    // in the background state.
                    mayBeTop = true;
                    clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                } else {
                    // Special handling for above-top states (persistent
                    // processes).  These should not bring the current process
                    // into the top state, since they are not on top.  Instead
                    // give them the best state after that.
                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
            }
            if (procState > clientProcState) {
                procState = clientProcState;
            }
            if (client.curSchedGroup == Process.THREAD_GROUP_DEFAULT) {
                schedGroup = Process.THREAD_GROUP_DEFAULT;
            }
        }
        // FOREGROUND_APP_ADJ.
        if (cpr.hasExternalProcessHandles()) {
            if (adj > ProcessList.FOREGROUND_APP_ADJ) {
                adj = ProcessList.FOREGROUND_APP_ADJ;
                schedGroup = Process.THREAD_GROUP_DEFAULT;
                app.cached = false;
                app.adjType = "provider";
                app.adjTarget = cpr.name;
            }
            if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
                procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            }
        }
    }
    if (app.lastProviderTime > 0 && (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) > now) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
            app.cached = false;
            app.adjType = "provider";
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
        }
    }
    if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
        // to the top state.
        switch(procState) {
            case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
            case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
            case ActivityManager.PROCESS_STATE_SERVICE:
                // These all are longer-term states, so pull them up to the top
                // of the background states, but not all the way to the top state.
                procState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                break;
            default:
                // Otherwise, top is a better choice, so take it.
                procState = ActivityManager.PROCESS_STATE_TOP;
                break;
        }
    }
    if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
        if (app.hasClientActivities) {
            // This is a cached process, but with client activities.  Mark it so.
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
            app.adjType = "cch-client-act";
        } else if (app.treatLikeActivity) {
            // This is a cached process, but somebody wants us to treat it like it has
            // an activity, okay!
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
            app.adjType = "cch-as-act";
        }
    }
    if (adj == ProcessList.SERVICE_ADJ) {
        if (doingAll) {
            app.serviceb = mNewNumAServiceProcs > (mNumServiceProcs / 3);
            mNewNumServiceProcs++;
            // Slog.i(TAG, "ADJ " + app + " serviceb=" + app.serviceb);
            if (!app.serviceb) {
                // keep launcher over it.
                if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
                    app.serviceHighRam = true;
                    app.serviceb = true;
                // Slog.i(TAG, "ADJ " + app + " high ram!");
                } else {
                    mNewNumAServiceProcs++;
                // Slog.i(TAG, "ADJ " + app + " not high ram!");
                }
            } else {
                app.serviceHighRam = false;
            }
        }
        if (app.serviceb) {
            adj = ProcessList.SERVICE_B_ADJ;
        }
    }
    app.curRawAdj = adj;
    // " adj=" + adj + " curAdj=" + app.curAdj + " maxAdj=" + app.maxAdj);
    if (adj > app.maxAdj) {
        adj = app.maxAdj;
        if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
            schedGroup = Process.THREAD_GROUP_DEFAULT;
        }
    }
    // Do final modification to adj.  Everything we do between here and applying
    // the final setAdj must be done in this function, because we will also use
    // it when computing the final cached adj later.  Note that we don't need to
    // worry about this for max adj above, since max adj will always be used to
    // keep it out of the cached vaues.
    app.curAdj = app.modifyRawOomAdj(adj);
    app.curSchedGroup = schedGroup;
    app.curProcState = procState;
    app.foregroundActivities = foregroundActivities;
    return app.curRawAdj;
}
#method_after
private final int computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) {
    if (mAdjSeq == app.adjSeq) {
        // This adjustment has already been computed.
        return app.curRawAdj;
    }
    if (app.thread == null) {
        app.adjSeq = mAdjSeq;
        app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        return (app.curAdj = app.curRawAdj = ProcessList.CACHED_APP_MAX_ADJ);
    }
    app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;
    app.adjSource = null;
    app.adjTarget = null;
    app.empty = false;
    app.cached = false;
    final int activitiesSize = app.activities.size();
    if (app.maxAdj <= ProcessList.FOREGROUND_APP_ADJ) {
        // The max adjustment doesn't allow this app to be anything
        // below foreground, so it is not worth doing work for it.
        app.adjType = "fixed";
        app.adjSeq = mAdjSeq;
        app.curRawAdj = app.maxAdj;
        app.foregroundActivities = false;
        app.curSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT;
        // System processes can do UI, and when they do we want to have
        // them trim their memory after the user leaves the UI.  To
        // facilitate this, here we need to determine whether or not it
        // is currently showing UI.
        app.systemNoUi = true;
        if (app == TOP_APP) {
            app.systemNoUi = false;
            app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;
            app.adjType = "pers-top-activity";
        } else if (activitiesSize > 0) {
            for (int j = 0; j < activitiesSize; j++) {
                final ActivityRecord r = app.activities.get(j);
                if (r.visible) {
                    app.systemNoUi = false;
                }
            }
        }
        if (!app.systemNoUi) {
            app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;
        }
        return (app.curAdj = app.maxAdj);
    }
    app.systemNoUi = false;
    final int PROCESS_STATE_CUR_TOP = mTopProcessState;
    // Determine the importance of the process, starting with most
    // important to least, and assign an appropriate OOM adjustment.
    int adj;
    int schedGroup;
    int procState;
    boolean foregroundActivities = false;
    final ArraySet<BroadcastQueue> queues = new ArraySet<BroadcastQueue>();
    if (app == TOP_APP) {
        // The last app on the list is the foreground app.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
        app.adjType = "top-activity";
        foregroundActivities = true;
        procState = PROCESS_STATE_CUR_TOP;
    } else if (app.instrumentationClass != null) {
        // Don't want to kill running instrumentation.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        app.adjType = "instrumentation";
        procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
    } else if (isReceivingBroadcastLocked(app, queues)) {
        // An app that is currently receiving a broadcast also
        // counts as being in the foreground for OOM killer purposes.
        // It's placed in a sched group based on the nature of the
        // broadcast as reflected by which queue it's active in.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = (queues.contains(mFgBroadcastQueue)) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "broadcast";
        procState = ActivityManager.PROCESS_STATE_RECEIVER;
    } else if (app.executingServices.size() > 0) {
        // An app that is currently executing a service callback also
        // counts as being in the foreground.
        adj = ProcessList.FOREGROUND_APP_ADJ;
        schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;
        app.adjType = "exec-service";
        procState = ActivityManager.PROCESS_STATE_SERVICE;
    // Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);
    } else {
        // As far as we know the process is empty.  We may change our mind later.
        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
        // At this point we don't actually know the adjustment.  Use the cached adj
        // value that the caller wants us to.
        adj = cachedAdj;
        procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
        app.cached = true;
        app.empty = true;
        app.adjType = "cch-empty";
    }
    // Examine all activities if not already foreground.
    if (!foregroundActivities && activitiesSize > 0) {
        int minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;
        for (int j = 0; j < activitiesSize; j++) {
            final ActivityRecord r = app.activities.get(j);
            if (r.app != app) {
                Log.e(TAG, "Found activity " + r + " in proc activity list using " + r.app + " instead of expected " + app);
                if (r.app == null || (r.app.uid == app.uid)) {
                    // Only fix things up when they look sane
                    r.app = app;
                } else {
                    continue;
                }
            }
            if (r.visible) {
                // App has a visible activity; only upgrade adjustment.
                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                    adj = ProcessList.VISIBLE_APP_ADJ;
                    app.adjType = "visible";
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                }
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
                if (r.task != null && minLayer > 0) {
                    final int layer = r.task.mLayerRank;
                    if (layer >= 0 && minLayer > layer) {
                        minLayer = layer;
                    }
                }
                break;
            } else if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "pausing";
                }
                if (procState > PROCESS_STATE_CUR_TOP) {
                    procState = PROCESS_STATE_CUR_TOP;
                }
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else if (r.state == ActivityState.STOPPING) {
                if (adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                    app.adjType = "stopping";
                }
                // processes and they should soon all go into the cached state.
                if (!r.finishing) {
                    if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
                        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
                    }
                }
                app.cached = false;
                app.empty = false;
                foregroundActivities = true;
            } else {
                if (procState > ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                    procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
                    app.adjType = "cch-act";
                }
            }
        }
        if (adj == ProcessList.VISIBLE_APP_ADJ) {
            adj += minLayer;
        }
    }
    if (adj > ProcessList.PERCEPTIBLE_APP_ADJ || procState > ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) {
        if (app.foregroundServices) {
            // The user is aware of this app, so make it visible.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;
            app.cached = false;
            app.adjType = "fg-service";
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        } else if (app.forcingToForeground != null) {
            // The user is aware of this app, so make it visible.
            adj = ProcessList.PERCEPTIBLE_APP_ADJ;
            procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            app.cached = false;
            app.adjType = "force-fg";
            app.adjSource = app.forcingToForeground;
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        }
    }
    if (app == mHeavyWeightProcess) {
        if (adj > ProcessList.HEAVY_WEIGHT_APP_ADJ) {
            // We don't want to kill the current heavy-weight process.
            adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "heavy";
        }
        if (procState > ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
            procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;
        }
    }
    if (app == mHomeProcess) {
        if (adj > ProcessList.HOME_APP_ADJ) {
            // This process is hosting what we currently consider to be the
            // home app, so we don't want to let it go into the background.
            adj = ProcessList.HOME_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "home";
        }
        if (procState > ActivityManager.PROCESS_STATE_HOME) {
            procState = ActivityManager.PROCESS_STATE_HOME;
        }
    }
    if (app == mPreviousProcess && app.activities.size() > 0) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            // This was the previous process that showed UI to the user.
            // We want to try to keep it around more aggressively, to give
            // a good experience around switching between two apps.
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "previous";
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
        }
    }
    if (false)
        Slog.i(TAG, "OOM " + app + ": initial adj=" + adj + " reason=" + app.adjType);
    // By default, we use the computed adjustment.  It may be changed if
    // there are applications dependent on our services or providers, but
    // this gives us a baseline and makes sure we don't get into an
    // infinite recursion.
    app.adjSeq = mAdjSeq;
    app.curRawAdj = adj;
    app.hasStartedServices = false;
    if (mBackupTarget != null && app == mBackupTarget.app) {
        // If possible we want to avoid killing apps while they're being backed up
        if (adj > ProcessList.BACKUP_APP_ADJ) {
            if (DEBUG_BACKUP)
                Slog.v(TAG_BACKUP, "oom BACKUP_APP_ADJ for " + app);
            adj = ProcessList.BACKUP_APP_ADJ;
            if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
            }
            app.adjType = "backup";
            app.cached = false;
        }
        if (procState > ActivityManager.PROCESS_STATE_BACKUP) {
            procState = ActivityManager.PROCESS_STATE_BACKUP;
        }
    }
    boolean mayBeTop = false;
    for (int is = app.services.size() - 1; is >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); is--) {
        ServiceRecord s = app.services.valueAt(is);
        if (s.startRequested) {
            app.hasStartedServices = true;
            if (procState > ActivityManager.PROCESS_STATE_SERVICE) {
                procState = ActivityManager.PROCESS_STATE_SERVICE;
            }
            if (app.hasShownUi && app != mHomeProcess) {
                // debug and understand what is going on.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-ui-services";
                }
            } else {
                if (now < (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                    // of the background processes.
                    if (adj > ProcessList.SERVICE_ADJ) {
                        adj = ProcessList.SERVICE_ADJ;
                        app.adjType = "started-services";
                        app.cached = false;
                    }
                }
                // even though the service no longer has an impact.
                if (adj > ProcessList.SERVICE_ADJ) {
                    app.adjType = "cch-started-services";
                }
            }
        }
        for (int conni = s.connections.size() - 1; conni >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); conni--) {
            ArrayList<ConnectionRecord> clist = s.connections.valueAt(conni);
            for (int i = 0; i < clist.size() && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i++) {
                // XXX should compute this based on the max of
                // all connected clients.
                ConnectionRecord cr = clist.get(i);
                if (cr.binding.client == app) {
                    // Binding to ourself is not interesting.
                    continue;
                }
                if ((cr.flags & Context.BIND_WAIVE_PRIORITY) == 0) {
                    ProcessRecord client = cr.binding.client;
                    int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
                    int clientProcState = client.curProcState;
                    if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                        // If the other app is cached for any reason, for purposes here
                        // we are going to consider it empty.  The specific cached state
                        // doesn't propagate except under certain conditions.
                        clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                    }
                    String adjType = null;
                    if ((cr.flags & Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) {
                        // this guy more like a started service.
                        if (app.hasShownUi && app != mHomeProcess) {
                            // debug and understand what is going on.
                            if (adj > clientAdj) {
                                adjType = "cch-bound-ui-services";
                            }
                            app.cached = false;
                            clientAdj = adj;
                            clientProcState = procState;
                        } else {
                            if (now >= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) {
                                // to help debug and undertand what is going on.
                                if (adj > clientAdj) {
                                    adjType = "cch-bound-services";
                                }
                                clientAdj = adj;
                            }
                        }
                    }
                    if (adj > clientAdj) {
                        // memory.
                        if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                            adjType = "cch-bound-ui-services";
                        } else {
                            if ((cr.flags & (Context.BIND_ABOVE_CLIENT | Context.BIND_IMPORTANT)) != 0) {
                                adj = clientAdj >= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;
                            } else if ((cr.flags & Context.BIND_NOT_VISIBLE) != 0 && clientAdj < ProcessList.PERCEPTIBLE_APP_ADJ && adj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                                adj = ProcessList.PERCEPTIBLE_APP_ADJ;
                            } else if (clientAdj >= ProcessList.PERCEPTIBLE_APP_ADJ) {
                                adj = clientAdj;
                            } else {
                                if (adj > ProcessList.VISIBLE_APP_ADJ) {
                                    adj = Math.max(clientAdj, ProcessList.VISIBLE_APP_ADJ);
                                }
                            }
                            if (!client.cached) {
                                app.cached = false;
                            }
                            adjType = "service";
                        }
                    }
                    if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                        // foreground work.
                        if (client.curSchedGroup > schedGroup) {
                            if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                                schedGroup = client.curSchedGroup;
                            } else {
                                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                            }
                        }
                        if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                            if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                                // Special handling of clients who are in the top state.
                                // We *may* want to consider this process to be in the
                                // top state as well, but only if there is not another
                                // reason for it to be running.  Being on the top is a
                                // special state, meaning you are specifically running
                                // for the current top app.  If the process is already
                                // running in the background for some other reason, it
                                // is more important to continue considering it to be
                                // in the background state.
                                mayBeTop = true;
                                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                            } else {
                                // give them the best state after that.
                                if ((cr.flags & Context.BIND_FOREGROUND_SERVICE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else if (mWakefulness == PowerManagerInternal.WAKEFULNESS_AWAKE && (cr.flags & Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE) != 0) {
                                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                                } else {
                                    clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
                                }
                            }
                        }
                    } else {
                        if (clientProcState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) {
                            clientProcState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;
                        }
                    }
                    if (procState > clientProcState) {
                        procState = clientProcState;
                    }
                    if (procState < ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND && (cr.flags & Context.BIND_SHOWING_UI) != 0) {
                        app.pendingUiClean = true;
                    }
                    if (adjType != null) {
                        app.adjType = adjType;
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = cr.binding.client;
                        app.adjSourceProcState = clientProcState;
                        app.adjTarget = s.name;
                    }
                }
                if ((cr.flags & Context.BIND_TREAT_LIKE_ACTIVITY) != 0) {
                    app.treatLikeActivity = true;
                }
                final ActivityRecord a = cr.activity;
                if ((cr.flags & Context.BIND_ADJUST_WITH_ACTIVITY) != 0) {
                    if (a != null && adj > ProcessList.FOREGROUND_APP_ADJ && (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) {
                        adj = ProcessList.FOREGROUND_APP_ADJ;
                        if ((cr.flags & Context.BIND_NOT_FOREGROUND) == 0) {
                            if ((cr.flags & Context.BIND_IMPORTANT) != 0) {
                                schedGroup = ProcessList.SCHED_GROUP_TOP_APP;
                            } else {
                                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                            }
                        }
                        app.cached = false;
                        app.adjType = "service";
                        app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_SERVICE_IN_USE;
                        app.adjSource = a;
                        app.adjSourceProcState = procState;
                        app.adjTarget = s.name;
                    }
                }
            }
        }
    }
    for (int provi = app.pubProviders.size() - 1; provi >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); provi--) {
        ContentProviderRecord cpr = app.pubProviders.valueAt(provi);
        for (int i = cpr.connections.size() - 1; i >= 0 && (adj > ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState > ActivityManager.PROCESS_STATE_TOP); i--) {
            ContentProviderConnection conn = cpr.connections.get(i);
            ProcessRecord client = conn.client;
            if (client == app) {
                // Being our own client is not interesting.
                continue;
            }
            int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);
            int clientProcState = client.curProcState;
            if (clientProcState >= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) {
                // If the other app is cached for any reason, for purposes here
                // we are going to consider it empty.
                clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
            }
            if (adj > clientAdj) {
                if (app.hasShownUi && app != mHomeProcess && clientAdj > ProcessList.PERCEPTIBLE_APP_ADJ) {
                    app.adjType = "cch-ui-provider";
                } else {
                    adj = clientAdj > ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;
                    app.adjType = "provider";
                }
                app.cached &= client.cached;
                app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_PROVIDER_IN_USE;
                app.adjSource = client;
                app.adjSourceProcState = clientProcState;
                app.adjTarget = cpr.name;
            }
            if (clientProcState <= ActivityManager.PROCESS_STATE_TOP) {
                if (clientProcState == ActivityManager.PROCESS_STATE_TOP) {
                    // Special handling of clients who are in the top state.
                    // We *may* want to consider this process to be in the
                    // top state as well, but only if there is not another
                    // reason for it to be running.  Being on the top is a
                    // special state, meaning you are specifically running
                    // for the current top app.  If the process is already
                    // running in the background for some other reason, it
                    // is more important to continue considering it to be
                    // in the background state.
                    mayBeTop = true;
                    clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;
                } else {
                    // Special handling for above-top states (persistent
                    // processes).  These should not bring the current process
                    // into the top state, since they are not on top.  Instead
                    // give them the best state after that.
                    clientProcState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                }
            }
            if (procState > clientProcState) {
                procState = clientProcState;
            }
            if (client.curSchedGroup > schedGroup) {
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
            }
        }
        // FOREGROUND_APP_ADJ.
        if (cpr.hasExternalProcessHandles()) {
            if (adj > ProcessList.FOREGROUND_APP_ADJ) {
                adj = ProcessList.FOREGROUND_APP_ADJ;
                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
                app.cached = false;
                app.adjType = "provider";
                app.adjTarget = cpr.name;
            }
            if (procState > ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
                procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;
            }
        }
    }
    if (app.lastProviderTime > 0 && (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) > now) {
        if (adj > ProcessList.PREVIOUS_APP_ADJ) {
            adj = ProcessList.PREVIOUS_APP_ADJ;
            schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;
            app.cached = false;
            app.adjType = "provider";
        }
        if (procState > ActivityManager.PROCESS_STATE_LAST_ACTIVITY) {
            procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;
        }
    }
    if (mayBeTop && procState > ActivityManager.PROCESS_STATE_TOP) {
        // to the top state.
        switch(procState) {
            case ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND:
            case ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND:
            case ActivityManager.PROCESS_STATE_SERVICE:
                // These all are longer-term states, so pull them up to the top
                // of the background states, but not all the way to the top state.
                procState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;
                break;
            default:
                // Otherwise, top is a better choice, so take it.
                procState = ActivityManager.PROCESS_STATE_TOP;
                break;
        }
    }
    if (procState >= ActivityManager.PROCESS_STATE_CACHED_EMPTY) {
        if (app.hasClientActivities) {
            // This is a cached process, but with client activities.  Mark it so.
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;
            app.adjType = "cch-client-act";
        } else if (app.treatLikeActivity) {
            // This is a cached process, but somebody wants us to treat it like it has
            // an activity, okay!
            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;
            app.adjType = "cch-as-act";
        }
    }
    if (adj == ProcessList.SERVICE_ADJ) {
        if (doingAll) {
            app.serviceb = mNewNumAServiceProcs > (mNumServiceProcs / 3);
            mNewNumServiceProcs++;
            // Slog.i(TAG, "ADJ " + app + " serviceb=" + app.serviceb);
            if (!app.serviceb) {
                // keep launcher over it.
                if (mLastMemoryLevel > ProcessStats.ADJ_MEM_FACTOR_NORMAL && app.lastPss >= mProcessList.getCachedRestoreThresholdKb()) {
                    app.serviceHighRam = true;
                    app.serviceb = true;
                // Slog.i(TAG, "ADJ " + app + " high ram!");
                } else {
                    mNewNumAServiceProcs++;
                // Slog.i(TAG, "ADJ " + app + " not high ram!");
                }
            } else {
                app.serviceHighRam = false;
            }
        }
        if (app.serviceb) {
            adj = ProcessList.SERVICE_B_ADJ;
        }
    }
    app.curRawAdj = adj;
    // " adj=" + adj + " curAdj=" + app.curAdj + " maxAdj=" + app.maxAdj);
    if (adj > app.maxAdj) {
        adj = app.maxAdj;
        if (app.maxAdj <= ProcessList.PERCEPTIBLE_APP_ADJ) {
            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;
        }
    }
    // Do final modification to adj.  Everything we do between here and applying
    // the final setAdj must be done in this function, because we will also use
    // it when computing the final cached adj later.  Note that we don't need to
    // worry about this for max adj above, since max adj will always be used to
    // keep it out of the cached vaues.
    app.curAdj = app.modifyRawOomAdj(adj);
    app.curSchedGroup = schedGroup;
    app.curProcState = procState;
    app.foregroundActivities = foregroundActivities;
    return app.curRawAdj;
}
#end_block

#method_before
void recordPssSampleLocked(ProcessRecord proc, int procState, long pss, long uss, long now) {
    EventLogTags.writeAmPss(proc.pid, proc.uid, proc.processName, pss * 1024, uss * 1024);
    proc.lastPssTime = now;
    proc.baseProcessTracker.addPss(pss, uss, true, proc.pkgList);
    if (DEBUG_PSS)
        Slog.d(TAG_PSS, "PSS of " + proc.toShortString() + ": " + pss + " lastPss=" + proc.lastPss + " state=" + ProcessList.makeProcStateString(procState));
    if (proc.initialIdlePss == 0) {
        proc.initialIdlePss = pss;
    }
    proc.lastPss = pss;
    if (procState >= ActivityManager.PROCESS_STATE_HOME) {
        proc.lastCachedPss = pss;
    }
    final SparseArray<Pair<Long, String>> watchUids = mMemWatchProcesses.getMap().get(proc.processName);
    Long check = null;
    if (watchUids != null) {
        Pair<Long, String> val = watchUids.get(proc.uid);
        if (val == null) {
            val = watchUids.get(0);
        }
        if (val != null) {
            check = val.first;
        }
    }
    if (check != null) {
        if ((pss * 1024) >= check && proc.thread != null && mMemWatchDumpProcName == null) {
            boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
            if (!isDebuggable) {
                if ((proc.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                    isDebuggable = true;
                }
            }
            if (isDebuggable) {
                Slog.w(TAG, "Process " + proc + " exceeded pss limit " + check + "; reporting");
                final ProcessRecord myProc = proc;
                final File heapdumpFile = DumpHeapProvider.getJavaFile();
                mMemWatchDumpProcName = proc.processName;
                mMemWatchDumpFile = heapdumpFile.toString();
                mMemWatchDumpPid = proc.pid;
                mMemWatchDumpUid = proc.uid;
                BackgroundThread.getHandler().post(new Runnable() {

                    @Override
                    public void run() {
                        revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                        ParcelFileDescriptor fd = null;
                        try {
                            heapdumpFile.delete();
                            fd = ParcelFileDescriptor.open(heapdumpFile, ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE | ParcelFileDescriptor.MODE_WRITE_ONLY | ParcelFileDescriptor.MODE_APPEND);
                            IApplicationThread thread = myProc.thread;
                            if (thread != null) {
                                try {
                                    if (DEBUG_PSS)
                                        Slog.d(TAG_PSS, "Requesting dump heap from " + myProc + " to " + heapdumpFile);
                                    thread.dumpHeap(true, heapdumpFile.toString(), fd);
                                } catch (RemoteException e) {
                                }
                            }
                        } catch (FileNotFoundException e) {
                            e.printStackTrace();
                        } finally {
                            if (fd != null) {
                                try {
                                    fd.close();
                                } catch (IOException e) {
                                }
                            }
                        }
                    }
                });
            } else {
                Slog.w(TAG, "Process " + proc + " exceeded pss limit " + check + ", but debugging not enabled");
            }
        }
    }
}
#method_after
void recordPssSampleLocked(ProcessRecord proc, int procState, long pss, long uss, long swapPss, long now) {
    EventLogTags.writeAmPss(proc.pid, proc.uid, proc.processName, pss * 1024, uss * 1024, swapPss * 1024);
    proc.lastPssTime = now;
    proc.baseProcessTracker.addPss(pss, uss, true, proc.pkgList);
    if (DEBUG_PSS)
        Slog.d(TAG_PSS, "PSS of " + proc.toShortString() + ": " + pss + " lastPss=" + proc.lastPss + " state=" + ProcessList.makeProcStateString(procState));
    if (proc.initialIdlePss == 0) {
        proc.initialIdlePss = pss;
    }
    proc.lastPss = pss;
    proc.lastSwapPss = swapPss;
    if (procState >= ActivityManager.PROCESS_STATE_HOME) {
        proc.lastCachedPss = pss;
        proc.lastCachedSwapPss = swapPss;
    }
    final SparseArray<Pair<Long, String>> watchUids = mMemWatchProcesses.getMap().get(proc.processName);
    Long check = null;
    if (watchUids != null) {
        Pair<Long, String> val = watchUids.get(proc.uid);
        if (val == null) {
            val = watchUids.get(0);
        }
        if (val != null) {
            check = val.first;
        }
    }
    if (check != null) {
        if ((pss * 1024) >= check && proc.thread != null && mMemWatchDumpProcName == null) {
            boolean isDebuggable = "1".equals(SystemProperties.get(SYSTEM_DEBUGGABLE, "0"));
            if (!isDebuggable) {
                if ((proc.info.flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0) {
                    isDebuggable = true;
                }
            }
            if (isDebuggable) {
                Slog.w(TAG, "Process " + proc + " exceeded pss limit " + check + "; reporting");
                final ProcessRecord myProc = proc;
                final File heapdumpFile = DumpHeapProvider.getJavaFile();
                mMemWatchDumpProcName = proc.processName;
                mMemWatchDumpFile = heapdumpFile.toString();
                mMemWatchDumpPid = proc.pid;
                mMemWatchDumpUid = proc.uid;
                BackgroundThread.getHandler().post(new Runnable() {

                    @Override
                    public void run() {
                        revokeUriPermission(ActivityThread.currentActivityThread().getApplicationThread(), DumpHeapActivity.JAVA_URI, Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION, UserHandle.myUserId());
                        ParcelFileDescriptor fd = null;
                        try {
                            heapdumpFile.delete();
                            fd = ParcelFileDescriptor.open(heapdumpFile, ParcelFileDescriptor.MODE_CREATE | ParcelFileDescriptor.MODE_TRUNCATE | ParcelFileDescriptor.MODE_WRITE_ONLY | ParcelFileDescriptor.MODE_APPEND);
                            IApplicationThread thread = myProc.thread;
                            if (thread != null) {
                                try {
                                    if (DEBUG_PSS)
                                        Slog.d(TAG_PSS, "Requesting dump heap from " + myProc + " to " + heapdumpFile);
                                    thread.dumpHeap(true, heapdumpFile.toString(), fd);
                                } catch (RemoteException e) {
                                }
                            }
                        } catch (FileNotFoundException e) {
                            e.printStackTrace();
                        } finally {
                            if (fd != null) {
                                try {
                                    fd.close();
                                } catch (IOException e) {
                                }
                            }
                        }
                    }
                });
            } else {
                Slog.w(TAG, "Process " + proc + " exceeded pss limit " + check + ", but debugging not enabled");
            }
        }
    }
}
#end_block

#method_before
void requestPssAllProcsLocked(long now, boolean always, boolean memLowered) {
    if (!always) {
        if (now < (mLastFullPssTime + (memLowered ? FULL_PSS_LOWERED_INTERVAL : FULL_PSS_MIN_INTERVAL))) {
            return;
        }
    }
    if (DEBUG_PSS)
        Slog.d(TAG_PSS, "Requesting PSS of all procs!  memLowered=" + memLowered);
    mLastFullPssTime = now;
    mFullPssPending = true;
    mPendingPssProcesses.ensureCapacity(mLruProcesses.size());
    mPendingPssProcesses.clear();
    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
        ProcessRecord app = mLruProcesses.get(i);
        if (app.thread == null || app.curProcState == ActivityManager.PROCESS_STATE_NONEXISTENT) {
            continue;
        }
        if (memLowered || now > (app.lastStateTime + ProcessList.PSS_ALL_INTERVAL)) {
            app.pssProcState = app.setProcState;
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, mTestPssMode, isSleeping(), now);
            mPendingPssProcesses.add(app);
        }
    }
    mBgHandler.sendEmptyMessage(COLLECT_PSS_BG_MSG);
}
#method_after
void requestPssAllProcsLocked(long now, boolean always, boolean memLowered) {
    if (!always) {
        if (now < (mLastFullPssTime + (memLowered ? FULL_PSS_LOWERED_INTERVAL : FULL_PSS_MIN_INTERVAL))) {
            return;
        }
    }
    if (DEBUG_PSS)
        Slog.d(TAG_PSS, "Requesting PSS of all procs!  memLowered=" + memLowered);
    mLastFullPssTime = now;
    mFullPssPending = true;
    mPendingPssProcesses.ensureCapacity(mLruProcesses.size());
    mPendingPssProcesses.clear();
    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
        ProcessRecord app = mLruProcesses.get(i);
        if (app.thread == null || app.curProcState == ActivityManager.PROCESS_STATE_NONEXISTENT) {
            continue;
        }
        if (memLowered || now > (app.lastStateTime + ProcessList.PSS_ALL_INTERVAL)) {
            app.pssProcState = app.setProcState;
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, mTestPssMode, isSleepingLocked(), now);
            mPendingPssProcesses.add(app);
        }
    }
    mBgHandler.sendEmptyMessage(COLLECT_PSS_BG_MSG);
}
#end_block

#method_before
private final boolean canGcNowLocked() {
    boolean processingBroadcasts = false;
    for (BroadcastQueue q : mBroadcastQueues) {
        if (q.mParallelBroadcasts.size() != 0 || q.mOrderedBroadcasts.size() != 0) {
            processingBroadcasts = true;
        }
    }
    return !processingBroadcasts && (isSleeping() || mStackSupervisor.allResumedActivitiesIdle());
}
#method_after
private final boolean canGcNowLocked() {
    boolean processingBroadcasts = false;
    for (BroadcastQueue q : mBroadcastQueues) {
        if (q.mParallelBroadcasts.size() != 0 || q.mOrderedBroadcasts.size() != 0) {
            processingBroadcasts = true;
        }
    }
    return !processingBroadcasts && (isSleepingLocked() || mStackSupervisor.allResumedActivitiesIdle());
}
#end_block

#method_before
private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) {
    boolean success = true;
    if (app.curRawAdj != app.setRawAdj) {
        app.setRawAdj = app.curRawAdj;
    }
    int changes = 0;
    if (app.curAdj != app.setAdj) {
        ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj);
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Set " + app.pid + " " + app.processName + " adj " + app.curAdj + ": " + app.adjType);
        app.setAdj = app.curAdj;
    }
    if (app.setSchedGroup != app.curSchedGroup) {
        app.setSchedGroup = app.curSchedGroup;
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Setting process group of " + app.processName + " to " + app.curSchedGroup);
        if (app.waitingToKill != null && app.curReceiver == null && app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) {
            app.kill(app.waitingToKill, true);
            success = false;
        } else {
            if (true) {
                long oldId = Binder.clearCallingIdentity();
                try {
                    Process.setProcessGroup(app.pid, app.curSchedGroup);
                } catch (Exception e) {
                    Slog.w(TAG, "Failed setting process group of " + app.pid + " to " + app.curSchedGroup);
                    e.printStackTrace();
                } finally {
                    Binder.restoreCallingIdentity(oldId);
                }
            } else {
                if (app.thread != null) {
                    try {
                        app.thread.setSchedulingGroup(app.curSchedGroup);
                    } catch (RemoteException e) {
                    }
                }
            }
        }
    }
    if (app.repForegroundActivities != app.foregroundActivities) {
        app.repForegroundActivities = app.foregroundActivities;
        changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
    }
    if (app.repProcState != app.curProcState) {
        app.repProcState = app.curProcState;
        changes |= ProcessChangeItem.CHANGE_PROCESS_STATE;
        if (app.thread != null) {
            try {
                if (false) {
                    // RuntimeException h = new RuntimeException("here");
                    Slog.i(TAG, "Sending new process state " + app.repProcState + " to " + app);
                }
                app.thread.setProcessState(app.repProcState);
            } catch (RemoteException e) {
            }
        }
    }
    if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) {
        if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
            // Experimental code to more aggressively collect pss while
            // running test...  the problem is that this tends to collect
            // the data right when a process is transitioning between process
            // states, which well tend to give noisy data.
            long start = SystemClock.uptimeMillis();
            long pss = Debug.getPss(app.pid, mTmpLong, null);
            recordPssSampleLocked(app, app.curProcState, pss, mTmpLong[0], now);
            mPendingPssProcesses.remove(app);
            Slog.i(TAG, "Recorded pss for " + app + " state " + app.setProcState + " to " + app.curProcState + ": " + (SystemClock.uptimeMillis() - start) + "ms");
        }
        app.lastStateTime = now;
        app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, mTestPssMode, isSleeping(), now);
        if (DEBUG_PSS)
            Slog.d(TAG_PSS, "Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to " + ProcessList.makeProcStateString(app.curProcState) + " next pss in " + (app.nextPssTime - now) + ": " + app);
    } else {
        if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
            requestPssLocked(app, app.setProcState);
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, false, mTestPssMode, isSleeping(), now);
        } else if (false && DEBUG_PSS)
            Slog.d(TAG_PSS, "Not requesting PSS of " + app + ": next=" + (app.nextPssTime - now));
    }
    if (app.setProcState != app.curProcState) {
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Proc state change of " + app.processName + " to " + app.curProcState);
        boolean setImportant = app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
        boolean curImportant = app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
        if (setImportant && !curImportant) {
            // This app is no longer something we consider important enough to allow to
            // use arbitrary amounts of battery power.  Note
            // its current wake lock time to later know to kill it if
            // it is not behaving well.
            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
            synchronized (stats) {
                app.lastWakeTime = stats.getProcessWakeTime(app.info.uid, app.pid, nowElapsed);
            }
            app.lastCpuTime = app.curCpuTime;
        }
        // Inform UsageStats of important process state change
        // Must be called before updating setProcState
        maybeUpdateUsageStatsLocked(app, nowElapsed);
        app.setProcState = app.curProcState;
        if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
            app.notCachedSinceIdle = false;
        }
        if (!doingAll) {
            setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);
        } else {
            app.procStateChanged = true;
        }
    } else if (app.reportedInteraction && (nowElapsed - app.interactionEventTime) > USAGE_STATS_INTERACTION_INTERVAL) {
        // For apps that sit around for a long time in the interactive state, we need
        // to report this at least once a day so they don't go idle.
        maybeUpdateUsageStatsLocked(app, nowElapsed);
    }
    if (changes != 0) {
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Changes in " + app + ": " + changes);
        int i = mPendingProcessChanges.size() - 1;
        ProcessChangeItem item = null;
        while (i >= 0) {
            item = mPendingProcessChanges.get(i);
            if (item.pid == app.pid) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Re-using existing item: " + item);
                break;
            }
            i--;
        }
        if (i < 0) {
            // No existing item in pending changes; need a new one.
            final int NA = mAvailProcessChanges.size();
            if (NA > 0) {
                item = mAvailProcessChanges.remove(NA - 1);
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Retrieving available item: " + item);
            } else {
                item = new ProcessChangeItem();
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Allocating new item: " + item);
            }
            item.changes = 0;
            item.pid = app.pid;
            item.uid = app.info.uid;
            if (mPendingProcessChanges.size() == 0) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "*** Enqueueing dispatch processes changed!");
                mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED).sendToTarget();
            }
            mPendingProcessChanges.add(item);
        }
        item.changes |= changes;
        item.processState = app.repProcState;
        item.foregroundActivities = app.repForegroundActivities;
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Item " + Integer.toHexString(System.identityHashCode(item)) + " " + app.toShortString() + ": changes=" + item.changes + " procState=" + item.processState + " foreground=" + item.foregroundActivities + " type=" + app.adjType + " source=" + app.adjSource + " target=" + app.adjTarget);
    }
    return success;
}
#method_after
private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) {
    boolean success = true;
    if (app.curRawAdj != app.setRawAdj) {
        app.setRawAdj = app.curRawAdj;
    }
    int changes = 0;
    if (app.curAdj != app.setAdj) {
        ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj);
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Set " + app.pid + " " + app.processName + " adj " + app.curAdj + ": " + app.adjType);
        app.setAdj = app.curAdj;
        app.verifiedAdj = ProcessList.INVALID_ADJ;
    }
    if (app.setSchedGroup != app.curSchedGroup) {
        app.setSchedGroup = app.curSchedGroup;
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Setting sched group of " + app.processName + " to " + app.curSchedGroup);
        if (app.waitingToKill != null && app.curReceivers.isEmpty() && app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) {
            app.kill(app.waitingToKill, true);
            success = false;
        } else {
            int processGroup;
            switch(app.curSchedGroup) {
                case ProcessList.SCHED_GROUP_BACKGROUND:
                    processGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;
                    break;
                case ProcessList.SCHED_GROUP_TOP_APP:
                    processGroup = Process.THREAD_GROUP_TOP_APP;
                    break;
                default:
                    processGroup = Process.THREAD_GROUP_DEFAULT;
                    break;
            }
            if (true) {
                long oldId = Binder.clearCallingIdentity();
                try {
                    Process.setProcessGroup(app.pid, processGroup);
                } catch (Exception e) {
                    Slog.w(TAG, "Failed setting process group of " + app.pid + " to " + app.curSchedGroup);
                    e.printStackTrace();
                } finally {
                    Binder.restoreCallingIdentity(oldId);
                }
            } else {
                if (app.thread != null) {
                    try {
                        app.thread.setSchedulingGroup(processGroup);
                    } catch (RemoteException e) {
                    }
                }
            }
        }
    }
    if (app.repForegroundActivities != app.foregroundActivities) {
        app.repForegroundActivities = app.foregroundActivities;
        changes |= ProcessChangeItem.CHANGE_ACTIVITIES;
    }
    if (app.repProcState != app.curProcState) {
        app.repProcState = app.curProcState;
        changes |= ProcessChangeItem.CHANGE_PROCESS_STATE;
        if (app.thread != null) {
            try {
                if (false) {
                    // RuntimeException h = new RuntimeException("here");
                    Slog.i(TAG, "Sending new process state " + app.repProcState + " to " + app);
                }
                app.thread.setProcessState(app.repProcState);
            } catch (RemoteException e) {
            }
        }
    }
    if (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) {
        if (false && mTestPssMode && app.setProcState >= 0 && app.lastStateTime <= (now - 200)) {
            // Experimental code to more aggressively collect pss while
            // running test...  the problem is that this tends to collect
            // the data right when a process is transitioning between process
            // states, which well tend to give noisy data.
            long start = SystemClock.uptimeMillis();
            long pss = Debug.getPss(app.pid, mTmpLong, null);
            recordPssSampleLocked(app, app.curProcState, pss, mTmpLong[0], mTmpLong[1], now);
            mPendingPssProcesses.remove(app);
            Slog.i(TAG, "Recorded pss for " + app + " state " + app.setProcState + " to " + app.curProcState + ": " + (SystemClock.uptimeMillis() - start) + "ms");
        }
        app.lastStateTime = now;
        app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, true, mTestPssMode, isSleepingLocked(), now);
        if (DEBUG_PSS)
            Slog.d(TAG_PSS, "Process state change from " + ProcessList.makeProcStateString(app.setProcState) + " to " + ProcessList.makeProcStateString(app.curProcState) + " next pss in " + (app.nextPssTime - now) + ": " + app);
    } else {
        if (now > app.nextPssTime || (now > (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL) && now > (app.lastStateTime + ProcessList.minTimeFromStateChange(mTestPssMode)))) {
            requestPssLocked(app, app.setProcState);
            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, false, mTestPssMode, isSleepingLocked(), now);
        } else if (false && DEBUG_PSS)
            Slog.d(TAG_PSS, "Not requesting PSS of " + app + ": next=" + (app.nextPssTime - now));
    }
    if (app.setProcState != app.curProcState) {
        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
            Slog.v(TAG_OOM_ADJ, "Proc state change of " + app.processName + " to " + app.curProcState);
        boolean setImportant = app.setProcState < ActivityManager.PROCESS_STATE_SERVICE;
        boolean curImportant = app.curProcState < ActivityManager.PROCESS_STATE_SERVICE;
        if (setImportant && !curImportant) {
            // This app is no longer something we consider important enough to allow to
            // use arbitrary amounts of battery power.  Note
            // its current wake lock time to later know to kill it if
            // it is not behaving well.
            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();
            synchronized (stats) {
                app.lastWakeTime = stats.getProcessWakeTime(app.info.uid, app.pid, nowElapsed);
            }
            app.lastCpuTime = app.curCpuTime;
        }
        // Inform UsageStats of important process state change
        // Must be called before updating setProcState
        maybeUpdateUsageStatsLocked(app, nowElapsed);
        app.setProcState = app.curProcState;
        if (app.setProcState >= ActivityManager.PROCESS_STATE_HOME) {
            app.notCachedSinceIdle = false;
        }
        if (!doingAll) {
            setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);
        } else {
            app.procStateChanged = true;
        }
    } else if (app.reportedInteraction && (nowElapsed - app.interactionEventTime) > USAGE_STATS_INTERACTION_INTERVAL) {
        // For apps that sit around for a long time in the interactive state, we need
        // to report this at least once a day so they don't go idle.
        maybeUpdateUsageStatsLocked(app, nowElapsed);
    }
    if (changes != 0) {
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Changes in " + app + ": " + changes);
        int i = mPendingProcessChanges.size() - 1;
        ProcessChangeItem item = null;
        while (i >= 0) {
            item = mPendingProcessChanges.get(i);
            if (item.pid == app.pid) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Re-using existing item: " + item);
                break;
            }
            i--;
        }
        if (i < 0) {
            // No existing item in pending changes; need a new one.
            final int NA = mAvailProcessChanges.size();
            if (NA > 0) {
                item = mAvailProcessChanges.remove(NA - 1);
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Retrieving available item: " + item);
            } else {
                item = new ProcessChangeItem();
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "Allocating new item: " + item);
            }
            item.changes = 0;
            item.pid = app.pid;
            item.uid = app.info.uid;
            if (mPendingProcessChanges.size() == 0) {
                if (DEBUG_PROCESS_OBSERVERS)
                    Slog.i(TAG_PROCESS_OBSERVERS, "*** Enqueueing dispatch processes changed!");
                mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();
            }
            mPendingProcessChanges.add(item);
        }
        item.changes |= changes;
        item.processState = app.repProcState;
        item.foregroundActivities = app.repForegroundActivities;
        if (DEBUG_PROCESS_OBSERVERS)
            Slog.i(TAG_PROCESS_OBSERVERS, "Item " + Integer.toHexString(System.identityHashCode(item)) + " " + app.toShortString() + ": changes=" + item.changes + " procState=" + item.processState + " foreground=" + item.foregroundActivities + " type=" + app.adjType + " source=" + app.adjSource + " target=" + app.adjTarget);
    }
    return success;
}
#end_block

#method_before
private final void enqueueUidChangeLocked(UidRecord uidRec, boolean gone) {
    if (uidRec.pendingChange == null) {
        if (mPendingUidChanges.size() == 0) {
            if (DEBUG_UID_OBSERVERS)
                Slog.i(TAG_UID_OBSERVERS, "*** Enqueueing dispatch uid changed!");
            mUiHandler.obtainMessage(DISPATCH_UIDS_CHANGED_MSG).sendToTarget();
        }
        final int NA = mAvailUidChanges.size();
        if (NA > 0) {
            uidRec.pendingChange = mAvailUidChanges.remove(NA - 1);
            if (DEBUG_UID_OBSERVERS)
                Slog.i(TAG_UID_OBSERVERS, "Retrieving available item: " + uidRec.pendingChange);
        } else {
            uidRec.pendingChange = new UidRecord.ChangeItem();
            if (DEBUG_UID_OBSERVERS)
                Slog.i(TAG_UID_OBSERVERS, "Allocating new item: " + uidRec.pendingChange);
        }
        uidRec.pendingChange.uidRecord = uidRec;
        uidRec.pendingChange.uid = uidRec.uid;
        mPendingUidChanges.add(uidRec.pendingChange);
    }
    uidRec.pendingChange.gone = gone;
    uidRec.pendingChange.processState = uidRec.setProcState;
}
#method_after
private final void enqueueUidChangeLocked(UidRecord uidRec, int uid, int change) {
    final UidRecord.ChangeItem pendingChange;
    if (uidRec == null || uidRec.pendingChange == null) {
        if (mPendingUidChanges.size() == 0) {
            if (DEBUG_UID_OBSERVERS)
                Slog.i(TAG_UID_OBSERVERS, "*** Enqueueing dispatch uid changed!");
            mUiHandler.obtainMessage(DISPATCH_UIDS_CHANGED_UI_MSG).sendToTarget();
        }
        final int NA = mAvailUidChanges.size();
        if (NA > 0) {
            pendingChange = mAvailUidChanges.remove(NA - 1);
            if (DEBUG_UID_OBSERVERS)
                Slog.i(TAG_UID_OBSERVERS, "Retrieving available item: " + pendingChange);
        } else {
            pendingChange = new UidRecord.ChangeItem();
            if (DEBUG_UID_OBSERVERS)
                Slog.i(TAG_UID_OBSERVERS, "Allocating new item: " + pendingChange);
        }
        if (uidRec != null) {
            uidRec.pendingChange = pendingChange;
            if (change == UidRecord.CHANGE_GONE && !uidRec.idle) {
                // If this uid is going away, and we haven't yet reported it is gone,
                // then do so now.
                change = UidRecord.CHANGE_GONE_IDLE;
            }
        } else if (uid < 0) {
            throw new IllegalArgumentException("No UidRecord or uid");
        }
        pendingChange.uidRecord = uidRec;
        pendingChange.uid = uidRec != null ? uidRec.uid : uid;
        mPendingUidChanges.add(pendingChange);
    } else {
        pendingChange = uidRec.pendingChange;
        if (change == UidRecord.CHANGE_GONE && pendingChange.change == UidRecord.CHANGE_IDLE) {
            change = UidRecord.CHANGE_GONE_IDLE;
        }
    }
    pendingChange.change = change;
    pendingChange.processState = uidRec != null ? uidRec.setProcState : ActivityManager.PROCESS_STATE_NONEXISTENT;
}
#end_block

#method_before
private void maybeUpdateProviderUsageStatsLocked(ProcessRecord app, String providerPkgName, String authority) {
    if (app == null)
        return;
    if (app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        UserState userState = mStartedUsers.get(app.userId);
        if (userState == null)
            return;
        final long now = SystemClock.elapsedRealtime();
        Long lastReported = userState.mProviderLastReportedFg.get(authority);
        if (lastReported == null || lastReported < now - 60 * 1000L) {
            mUsageStatsService.reportContentProviderUsage(authority, providerPkgName, app.userId);
            userState.mProviderLastReportedFg.put(authority, now);
        }
    }
}
#method_after
private void maybeUpdateProviderUsageStatsLocked(ProcessRecord app, String providerPkgName, String authority) {
    if (app == null)
        return;
    if (app.curProcState <= ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) {
        UserState userState = mUserController.getStartedUserStateLocked(app.userId);
        if (userState == null)
            return;
        final long now = SystemClock.elapsedRealtime();
        Long lastReported = userState.mProviderLastReportedFg.get(authority);
        if (lastReported == null || lastReported < now - 60 * 1000L) {
            mUsageStatsService.reportContentProviderUsage(authority, providerPkgName, app.userId);
            userState.mProviderLastReportedFg.put(authority, now);
        }
    }
}
#end_block

#method_before
private final void setProcessTrackerStateLocked(ProcessRecord proc, int memFactor, long now) {
    if (proc.thread != null) {
        if (proc.baseProcessTracker != null) {
            proc.baseProcessTracker.setState(proc.repProcState, memFactor, now, proc.pkgList);
        }
        if (proc.repProcState >= 0) {
            mBatteryStatsService.noteProcessState(proc.processName, proc.info.uid, proc.repProcState);
        }
    }
}
#method_after
private final void setProcessTrackerStateLocked(ProcessRecord proc, int memFactor, long now) {
    if (proc.thread != null) {
        if (proc.baseProcessTracker != null) {
            proc.baseProcessTracker.setState(proc.repProcState, memFactor, now, proc.pkgList);
        }
    }
}
#end_block

#method_before
final void updateOomAdjLocked() {
    final ActivityRecord TOP_ACT = resumedAppLocked();
    final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;
    final long now = SystemClock.uptimeMillis();
    final long nowElapsed = SystemClock.elapsedRealtime();
    final long oldTime = now - ProcessList.MAX_EMPTY_TIME;
    final int N = mLruProcesses.size();
    if (false) {
        RuntimeException e = new RuntimeException();
        e.fillInStackTrace();
        Slog.i(TAG, "updateOomAdj: top=" + TOP_ACT, e);
    }
    // Reset state in all uid records.
    for (int i = mActiveUids.size() - 1; i >= 0; i--) {
        final UidRecord uidRec = mActiveUids.valueAt(i);
        if (false && DEBUG_UID_OBSERVERS)
            Slog.i(TAG_UID_OBSERVERS, "Starting update of " + uidRec);
        uidRec.reset();
    }
    mAdjSeq++;
    mNewNumServiceProcs = 0;
    mNewNumAServiceProcs = 0;
    final int emptyProcessLimit;
    final int cachedProcessLimit;
    if (mProcessLimit <= 0) {
        emptyProcessLimit = cachedProcessLimit = 0;
    } else if (mProcessLimit == 1) {
        emptyProcessLimit = 1;
        cachedProcessLimit = 0;
    } else {
        emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);
        cachedProcessLimit = mProcessLimit - emptyProcessLimit;
    }
    // Let's determine how many processes we have running vs.
    // how many slots we have for background processes; we may want
    // to put multiple processes in a slot of there are enough of
    // them.
    int numSlots = (ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
    int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;
    if (numEmptyProcs > cachedProcessLimit) {
        // If there are more empty processes than our limit on cached
        // processes, then use the cached process limit for the factor.
        // This ensures that the really old empty processes get pushed
        // down to the bottom, so if we are running low on memory we will
        // have a better chance at keeping around more cached processes
        // instead of a gazillion empty processes.
        numEmptyProcs = cachedProcessLimit;
    }
    int emptyFactor = numEmptyProcs / numSlots;
    if (emptyFactor < 1)
        emptyFactor = 1;
    int cachedFactor = (mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
    if (cachedFactor < 1)
        cachedFactor = 1;
    int stepCached = 0;
    int stepEmpty = 0;
    int numCached = 0;
    int numEmpty = 0;
    int numTrimming = 0;
    mNumNonCachedProcs = 0;
    mNumCachedHiddenProcs = 0;
    // First update the OOM adjustment for each of the
    // application processes based on their current state.
    int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
    int nextCachedAdj = curCachedAdj + 1;
    int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;
    int nextEmptyAdj = curEmptyAdj + 2;
    for (int i = N - 1; i >= 0; i--) {
        ProcessRecord app = mLruProcesses.get(i);
        if (!app.killedByAm && app.thread != null) {
            app.procStateChanged = false;
            computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);
            // to the process, do that now.
            if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
                switch(app.curProcState) {
                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        // This process is a cached process holding activities...
                        // assign it the next cached value for that type, and then
                        // step that cached level.
                        app.curRawAdj = curCachedAdj;
                        app.curAdj = app.modifyRawOomAdj(curCachedAdj);
                        if (DEBUG_LRU && false)
                            Slog.d(TAG_LRU, "Assigning activity LRU #" + i + " adj: " + app.curAdj + " (curCachedAdj=" + curCachedAdj + ")");
                        if (curCachedAdj != nextCachedAdj) {
                            stepCached++;
                            if (stepCached >= cachedFactor) {
                                stepCached = 0;
                                curCachedAdj = nextCachedAdj;
                                nextCachedAdj += 2;
                                if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                    nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                }
                            }
                        }
                        break;
                    default:
                        // For everything else, assign next empty cached process
                        // level and bump that up.  Note that this means that
                        // long-running services that have dropped down to the
                        // cached level will be treated as empty (since their process
                        // state is still as a service), which is what we want.
                        app.curRawAdj = curEmptyAdj;
                        app.curAdj = app.modifyRawOomAdj(curEmptyAdj);
                        if (DEBUG_LRU && false)
                            Slog.d(TAG_LRU, "Assigning empty LRU #" + i + " adj: " + app.curAdj + " (curEmptyAdj=" + curEmptyAdj + ")");
                        if (curEmptyAdj != nextEmptyAdj) {
                            stepEmpty++;
                            if (stepEmpty >= emptyFactor) {
                                stepEmpty = 0;
                                curEmptyAdj = nextEmptyAdj;
                                nextEmptyAdj += 2;
                                if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                    nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                }
                            }
                        }
                        break;
                }
            }
            applyOomAdjLocked(app, true, now, nowElapsed);
            // Count the number of process types.
            switch(app.curProcState) {
                case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
                case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                    mNumCachedHiddenProcs++;
                    numCached++;
                    if (numCached > cachedProcessLimit) {
                        app.kill("cached #" + numCached, true);
                    }
                    break;
                case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
                    if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
                        app.kill("empty for " + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000) + "s", true);
                    } else {
                        numEmpty++;
                        if (numEmpty > emptyProcessLimit) {
                            app.kill("empty #" + numEmpty, true);
                        }
                    }
                    break;
                default:
                    mNumNonCachedProcs++;
                    break;
            }
            if (app.isolated && app.services.size() <= 0) {
                // If this is an isolated process, and there are no
                // services running in it, then the process is no longer
                // needed.  We agressively kill these because we can by
                // definition not re-use the same process again, and it is
                // good to avoid having whatever code was running in them
                // left sitting around after no longer needed.
                app.kill("isolated not needed", true);
            } else {
                // Keeping this process, update its uid.
                final UidRecord uidRec = app.uidRecord;
                if (uidRec != null && uidRec.curProcState > app.curProcState) {
                    uidRec.curProcState = app.curProcState;
                }
            }
            if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
                numTrimming++;
            }
        }
    }
    mNumServiceProcs = mNewNumServiceProcs;
    // Now determine the memory trimming level of background processes.
    // Unfortunately we need to start at the back of the list to do this
    // properly.  We only do this if the number of background apps we
    // are managing to keep around is less than half the maximum we desire;
    // if we are keeping a good number around, we'll let them use whatever
    // memory they want.
    final int numCachedAndEmpty = numCached + numEmpty;
    int memFactor;
    if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
        if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
            memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;
        } else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
            memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;
        } else {
            memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;
        }
    } else {
        memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;
    }
    // has gone down since last time.
    if (DEBUG_OOM_ADJ)
        Slog.d(TAG_OOM_ADJ, "oom: memFactor=" + memFactor + " last=" + mLastMemoryLevel + " allowLow=" + mAllowLowerMemLevel + " numProcs=" + mLruProcesses.size() + " last=" + mLastNumProcesses);
    if (memFactor > mLastMemoryLevel) {
        if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {
            memFactor = mLastMemoryLevel;
            if (DEBUG_OOM_ADJ)
                Slog.d(TAG_OOM_ADJ, "Keeping last mem factor!");
        }
    }
    mLastMemoryLevel = memFactor;
    mLastNumProcesses = mLruProcesses.size();
    boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleeping(), now);
    final int trackerMemFactor = mProcessStats.getMemFactorLocked();
    if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {
        if (mLowRamStartTime == 0) {
            mLowRamStartTime = now;
        }
        int step = 0;
        int fgTrimLevel;
        switch(memFactor) {
            case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
                break;
            case ProcessStats.ADJ_MEM_FACTOR_LOW:
                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
                break;
            default:
                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
                break;
        }
        int factor = numTrimming / 3;
        int minFactor = 2;
        if (mHomeProcess != null)
            minFactor++;
        if (mPreviousProcess != null)
            minFactor++;
        if (factor < minFactor)
            factor = minFactor;
        int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mLruProcesses.get(i);
            if (allChanged || app.procStateChanged) {
                setProcessTrackerStateLocked(app, trackerMemFactor, now);
                app.procStateChanged = false;
            }
            if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
                if (app.trimMemoryLevel < curLevel && app.thread != null) {
                    try {
                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
                            Slog.v(TAG_OOM_ADJ, "Trimming memory of " + app.processName + " to " + curLevel);
                        app.thread.scheduleTrimMemory(curLevel);
                    } catch (RemoteException e) {
                    }
                    if (false) {
                        // activities causes more harm than good.
                        if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
                            // Need to do this on its own message because the stack may not
                            // be in a consistent state at this point.
                            // For these apps we will also finish their activities
                            // to help them free memory.
                            mStackSupervisor.scheduleDestroyAllActivities(app, "trim");
                        }
                    }
                }
                app.trimMemoryLevel = curLevel;
                step++;
                if (step >= factor) {
                    step = 0;
                    switch(curLevel) {
                        case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
                            curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;
                            break;
                        case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
                            curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
                            break;
                    }
                }
            } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
                if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
                    try {
                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
                            Slog.v(TAG_OOM_ADJ, "Trimming memory of heavy-weight " + app.processName + " to " + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
                        app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
                    } catch (RemoteException e) {
                    }
                }
                app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
            } else {
                if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
                    // If this application is now in the background and it
                    // had done UI, then give it the special trim level to
                    // have it free UI resources.
                    final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
                    if (app.trimMemoryLevel < level && app.thread != null) {
                        try {
                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
                                Slog.v(TAG_OOM_ADJ, "Trimming memory of bg-ui " + app.processName + " to " + level);
                            app.thread.scheduleTrimMemory(level);
                        } catch (RemoteException e) {
                        }
                    }
                    app.pendingUiClean = false;
                }
                if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
                    try {
                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
                            Slog.v(TAG_OOM_ADJ, "Trimming memory of fg " + app.processName + " to " + fgTrimLevel);
                        app.thread.scheduleTrimMemory(fgTrimLevel);
                    } catch (RemoteException e) {
                    }
                }
                app.trimMemoryLevel = fgTrimLevel;
            }
        }
    } else {
        if (mLowRamStartTime != 0) {
            mLowRamTimeSinceLastIdle += now - mLowRamStartTime;
            mLowRamStartTime = 0;
        }
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mLruProcesses.get(i);
            if (allChanged || app.procStateChanged) {
                setProcessTrackerStateLocked(app, trackerMemFactor, now);
                app.procStateChanged = false;
            }
            if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
                if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
                    try {
                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
                            Slog.v(TAG_OOM_ADJ, "Trimming memory of ui hidden " + app.processName + " to " + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
                        app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
                    } catch (RemoteException e) {
                    }
                }
                app.pendingUiClean = false;
            }
            app.trimMemoryLevel = 0;
        }
    }
    if (mAlwaysFinishActivities) {
        // Need to do this on its own message because the stack may not
        // be in a consistent state at this point.
        mStackSupervisor.scheduleDestroyAllActivities(null, "always-finish");
    }
    if (allChanged) {
        requestPssAllProcsLocked(now, false, mProcessStats.isMemFactorLowered());
    }
    // Update from any uid changes.
    for (int i = mActiveUids.size() - 1; i >= 0; i--) {
        final UidRecord uidRec = mActiveUids.valueAt(i);
        if (uidRec.setProcState != uidRec.curProcState) {
            if (DEBUG_UID_OBSERVERS)
                Slog.i(TAG_UID_OBSERVERS, "Changes in " + uidRec + ": proc state from " + uidRec.setProcState + " to " + uidRec.curProcState);
            uidRec.setProcState = uidRec.curProcState;
            enqueueUidChangeLocked(uidRec, false);
        }
    }
    if (mProcessStats.shouldWriteNowLocked(now)) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                synchronized (ActivityManagerService.this) {
                    mProcessStats.writeStateAsyncLocked();
                }
            }
        });
    }
    if (DEBUG_OOM_ADJ) {
        final long duration = SystemClock.uptimeMillis() - now;
        if (false) {
            Slog.d(TAG_OOM_ADJ, "Did OOM ADJ in " + duration + "ms", new RuntimeException("here").fillInStackTrace());
        } else {
            Slog.d(TAG_OOM_ADJ, "Did OOM ADJ in " + duration + "ms");
        }
    }
}
#method_after
final void updateOomAdjLocked() {
    final ActivityRecord TOP_ACT = resumedAppLocked();
    final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null;
    final long now = SystemClock.uptimeMillis();
    final long nowElapsed = SystemClock.elapsedRealtime();
    final long oldTime = now - ProcessList.MAX_EMPTY_TIME;
    final int N = mLruProcesses.size();
    if (false) {
        RuntimeException e = new RuntimeException();
        e.fillInStackTrace();
        Slog.i(TAG, "updateOomAdj: top=" + TOP_ACT, e);
    }
    // Reset state in all uid records.
    for (int i = mActiveUids.size() - 1; i >= 0; i--) {
        final UidRecord uidRec = mActiveUids.valueAt(i);
        if (false && DEBUG_UID_OBSERVERS)
            Slog.i(TAG_UID_OBSERVERS, "Starting update of " + uidRec);
        uidRec.reset();
    }
    mStackSupervisor.rankTaskLayersIfNeeded();
    mAdjSeq++;
    mNewNumServiceProcs = 0;
    mNewNumAServiceProcs = 0;
    final int emptyProcessLimit;
    final int cachedProcessLimit;
    if (mProcessLimit <= 0) {
        emptyProcessLimit = cachedProcessLimit = 0;
    } else if (mProcessLimit == 1) {
        emptyProcessLimit = 1;
        cachedProcessLimit = 0;
    } else {
        emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);
        cachedProcessLimit = mProcessLimit - emptyProcessLimit;
    }
    // Let's determine how many processes we have running vs.
    // how many slots we have for background processes; we may want
    // to put multiple processes in a slot of there are enough of
    // them.
    int numSlots = (ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;
    int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;
    if (numEmptyProcs > cachedProcessLimit) {
        // If there are more empty processes than our limit on cached
        // processes, then use the cached process limit for the factor.
        // This ensures that the really old empty processes get pushed
        // down to the bottom, so if we are running low on memory we will
        // have a better chance at keeping around more cached processes
        // instead of a gazillion empty processes.
        numEmptyProcs = cachedProcessLimit;
    }
    int emptyFactor = numEmptyProcs / numSlots;
    if (emptyFactor < 1)
        emptyFactor = 1;
    int cachedFactor = (mNumCachedHiddenProcs > 0 ? mNumCachedHiddenProcs : 1) / numSlots;
    if (cachedFactor < 1)
        cachedFactor = 1;
    int stepCached = 0;
    int stepEmpty = 0;
    int numCached = 0;
    int numEmpty = 0;
    int numTrimming = 0;
    mNumNonCachedProcs = 0;
    mNumCachedHiddenProcs = 0;
    // First update the OOM adjustment for each of the
    // application processes based on their current state.
    int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;
    int nextCachedAdj = curCachedAdj + 1;
    int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;
    int nextEmptyAdj = curEmptyAdj + 2;
    for (int i = N - 1; i >= 0; i--) {
        ProcessRecord app = mLruProcesses.get(i);
        if (!app.killedByAm && app.thread != null) {
            app.procStateChanged = false;
            computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now);
            // to the process, do that now.
            if (app.curAdj >= ProcessList.UNKNOWN_ADJ) {
                switch(app.curProcState) {
                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
                    case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                        // This process is a cached process holding activities...
                        // assign it the next cached value for that type, and then
                        // step that cached level.
                        app.curRawAdj = curCachedAdj;
                        app.curAdj = app.modifyRawOomAdj(curCachedAdj);
                        if (DEBUG_LRU && false)
                            Slog.d(TAG_LRU, "Assigning activity LRU #" + i + " adj: " + app.curAdj + " (curCachedAdj=" + curCachedAdj + ")");
                        if (curCachedAdj != nextCachedAdj) {
                            stepCached++;
                            if (stepCached >= cachedFactor) {
                                stepCached = 0;
                                curCachedAdj = nextCachedAdj;
                                nextCachedAdj += 2;
                                if (nextCachedAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                    nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                }
                            }
                        }
                        break;
                    default:
                        // For everything else, assign next empty cached process
                        // level and bump that up.  Note that this means that
                        // long-running services that have dropped down to the
                        // cached level will be treated as empty (since their process
                        // state is still as a service), which is what we want.
                        app.curRawAdj = curEmptyAdj;
                        app.curAdj = app.modifyRawOomAdj(curEmptyAdj);
                        if (DEBUG_LRU && false)
                            Slog.d(TAG_LRU, "Assigning empty LRU #" + i + " adj: " + app.curAdj + " (curEmptyAdj=" + curEmptyAdj + ")");
                        if (curEmptyAdj != nextEmptyAdj) {
                            stepEmpty++;
                            if (stepEmpty >= emptyFactor) {
                                stepEmpty = 0;
                                curEmptyAdj = nextEmptyAdj;
                                nextEmptyAdj += 2;
                                if (nextEmptyAdj > ProcessList.CACHED_APP_MAX_ADJ) {
                                    nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;
                                }
                            }
                        }
                        break;
                }
            }
            applyOomAdjLocked(app, true, now, nowElapsed);
            // Count the number of process types.
            switch(app.curProcState) {
                case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:
                case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:
                    mNumCachedHiddenProcs++;
                    numCached++;
                    if (numCached > cachedProcessLimit) {
                        app.kill("cached #" + numCached, true);
                    }
                    break;
                case ActivityManager.PROCESS_STATE_CACHED_EMPTY:
                    if (numEmpty > ProcessList.TRIM_EMPTY_APPS && app.lastActivityTime < oldTime) {
                        app.kill("empty for " + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000) + "s", true);
                    } else {
                        numEmpty++;
                        if (numEmpty > emptyProcessLimit) {
                            app.kill("empty #" + numEmpty, true);
                        }
                    }
                    break;
                default:
                    mNumNonCachedProcs++;
                    break;
            }
            if (app.isolated && app.services.size() <= 0) {
                // If this is an isolated process, and there are no
                // services running in it, then the process is no longer
                // needed.  We agressively kill these because we can by
                // definition not re-use the same process again, and it is
                // good to avoid having whatever code was running in them
                // left sitting around after no longer needed.
                app.kill("isolated not needed", true);
            } else {
                // Keeping this process, update its uid.
                final UidRecord uidRec = app.uidRecord;
                if (uidRec != null && uidRec.curProcState > app.curProcState) {
                    uidRec.curProcState = app.curProcState;
                }
            }
            if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
                numTrimming++;
            }
        }
    }
    mNumServiceProcs = mNewNumServiceProcs;
    // Now determine the memory trimming level of background processes.
    // Unfortunately we need to start at the back of the list to do this
    // properly.  We only do this if the number of background apps we
    // are managing to keep around is less than half the maximum we desire;
    // if we are keeping a good number around, we'll let them use whatever
    // memory they want.
    final int numCachedAndEmpty = numCached + numEmpty;
    int memFactor;
    if (numCached <= ProcessList.TRIM_CACHED_APPS && numEmpty <= ProcessList.TRIM_EMPTY_APPS) {
        if (numCachedAndEmpty <= ProcessList.TRIM_CRITICAL_THRESHOLD) {
            memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;
        } else if (numCachedAndEmpty <= ProcessList.TRIM_LOW_THRESHOLD) {
            memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;
        } else {
            memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;
        }
    } else {
        memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;
    }
    // has gone down since last time.
    if (DEBUG_OOM_ADJ)
        Slog.d(TAG_OOM_ADJ, "oom: memFactor=" + memFactor + " last=" + mLastMemoryLevel + " allowLow=" + mAllowLowerMemLevel + " numProcs=" + mLruProcesses.size() + " last=" + mLastNumProcesses);
    if (memFactor > mLastMemoryLevel) {
        if (!mAllowLowerMemLevel || mLruProcesses.size() >= mLastNumProcesses) {
            memFactor = mLastMemoryLevel;
            if (DEBUG_OOM_ADJ)
                Slog.d(TAG_OOM_ADJ, "Keeping last mem factor!");
        }
    }
    if (memFactor != mLastMemoryLevel) {
        EventLogTags.writeAmMemFactor(memFactor, mLastMemoryLevel);
    }
    mLastMemoryLevel = memFactor;
    mLastNumProcesses = mLruProcesses.size();
    boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleepingLocked(), now);
    final int trackerMemFactor = mProcessStats.getMemFactorLocked();
    if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {
        if (mLowRamStartTime == 0) {
            mLowRamStartTime = now;
        }
        int step = 0;
        int fgTrimLevel;
        switch(memFactor) {
            case ProcessStats.ADJ_MEM_FACTOR_CRITICAL:
                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;
                break;
            case ProcessStats.ADJ_MEM_FACTOR_LOW:
                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;
                break;
            default:
                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;
                break;
        }
        int factor = numTrimming / 3;
        int minFactor = 2;
        if (mHomeProcess != null)
            minFactor++;
        if (mPreviousProcess != null)
            minFactor++;
        if (factor < minFactor)
            factor = minFactor;
        int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mLruProcesses.get(i);
            if (allChanged || app.procStateChanged) {
                setProcessTrackerStateLocked(app, trackerMemFactor, now);
                app.procStateChanged = false;
            }
            if (app.curProcState >= ActivityManager.PROCESS_STATE_HOME && !app.killedByAm) {
                if (app.trimMemoryLevel < curLevel && app.thread != null) {
                    try {
                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
                            Slog.v(TAG_OOM_ADJ, "Trimming memory of " + app.processName + " to " + curLevel);
                        app.thread.scheduleTrimMemory(curLevel);
                    } catch (RemoteException e) {
                    }
                    if (false) {
                        // activities causes more harm than good.
                        if (curLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE && app != mHomeProcess && app != mPreviousProcess) {
                            // Need to do this on its own message because the stack may not
                            // be in a consistent state at this point.
                            // For these apps we will also finish their activities
                            // to help them free memory.
                            mStackSupervisor.scheduleDestroyAllActivities(app, "trim");
                        }
                    }
                }
                app.trimMemoryLevel = curLevel;
                step++;
                if (step >= factor) {
                    step = 0;
                    switch(curLevel) {
                        case ComponentCallbacks2.TRIM_MEMORY_COMPLETE:
                            curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;
                            break;
                        case ComponentCallbacks2.TRIM_MEMORY_MODERATE:
                            curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
                            break;
                    }
                }
            } else if (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) {
                if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_BACKGROUND && app.thread != null) {
                    try {
                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
                            Slog.v(TAG_OOM_ADJ, "Trimming memory of heavy-weight " + app.processName + " to " + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
                        app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);
                    } catch (RemoteException e) {
                    }
                }
                app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;
            } else {
                if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
                    // If this application is now in the background and it
                    // had done UI, then give it the special trim level to
                    // have it free UI resources.
                    final int level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;
                    if (app.trimMemoryLevel < level && app.thread != null) {
                        try {
                            if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
                                Slog.v(TAG_OOM_ADJ, "Trimming memory of bg-ui " + app.processName + " to " + level);
                            app.thread.scheduleTrimMemory(level);
                        } catch (RemoteException e) {
                        }
                    }
                    app.pendingUiClean = false;
                }
                if (app.trimMemoryLevel < fgTrimLevel && app.thread != null) {
                    try {
                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
                            Slog.v(TAG_OOM_ADJ, "Trimming memory of fg " + app.processName + " to " + fgTrimLevel);
                        app.thread.scheduleTrimMemory(fgTrimLevel);
                    } catch (RemoteException e) {
                    }
                }
                app.trimMemoryLevel = fgTrimLevel;
            }
        }
    } else {
        if (mLowRamStartTime != 0) {
            mLowRamTimeSinceLastIdle += now - mLowRamStartTime;
            mLowRamStartTime = 0;
        }
        for (int i = N - 1; i >= 0; i--) {
            ProcessRecord app = mLruProcesses.get(i);
            if (allChanged || app.procStateChanged) {
                setProcessTrackerStateLocked(app, trackerMemFactor, now);
                app.procStateChanged = false;
            }
            if ((app.curProcState >= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND || app.systemNoUi) && app.pendingUiClean) {
                if (app.trimMemoryLevel < ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN && app.thread != null) {
                    try {
                        if (DEBUG_SWITCH || DEBUG_OOM_ADJ)
                            Slog.v(TAG_OOM_ADJ, "Trimming memory of ui hidden " + app.processName + " to " + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
                        app.thread.scheduleTrimMemory(ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);
                    } catch (RemoteException e) {
                    }
                }
                app.pendingUiClean = false;
            }
            app.trimMemoryLevel = 0;
        }
    }
    if (mAlwaysFinishActivities) {
        // Need to do this on its own message because the stack may not
        // be in a consistent state at this point.
        mStackSupervisor.scheduleDestroyAllActivities(null, "always-finish");
    }
    if (allChanged) {
        requestPssAllProcsLocked(now, false, mProcessStats.isMemFactorLowered());
    }
    // Update from any uid changes.
    for (int i = mActiveUids.size() - 1; i >= 0; i--) {
        final UidRecord uidRec = mActiveUids.valueAt(i);
        int uidChange = UidRecord.CHANGE_PROCSTATE;
        if (uidRec.setProcState != uidRec.curProcState) {
            if (DEBUG_UID_OBSERVERS)
                Slog.i(TAG_UID_OBSERVERS, "Changes in " + uidRec + ": proc state from " + uidRec.setProcState + " to " + uidRec.curProcState);
            if (ActivityManager.isProcStateBackground(uidRec.curProcState)) {
                if (!ActivityManager.isProcStateBackground(uidRec.setProcState)) {
                    uidRec.lastBackgroundTime = nowElapsed;
                    if (!mHandler.hasMessages(IDLE_UIDS_MSG)) {
                        // Note: the background settle time is in elapsed realtime, while
                        // the handler time base is uptime.  All this means is that we may
                        // stop background uids later than we had intended, but that only
                        // happens because the device was sleeping so we are okay anyway.
                        mHandler.sendEmptyMessageDelayed(IDLE_UIDS_MSG, BACKGROUND_SETTLE_TIME);
                    }
                }
            } else {
                if (uidRec.idle) {
                    uidChange = UidRecord.CHANGE_ACTIVE;
                    uidRec.idle = false;
                }
                uidRec.lastBackgroundTime = 0;
            }
            uidRec.setProcState = uidRec.curProcState;
            enqueueUidChangeLocked(uidRec, -1, uidChange);
            noteUidProcessState(uidRec.uid, uidRec.curProcState);
        }
    }
    if (mProcessStats.shouldWriteNowLocked(now)) {
        mHandler.post(new Runnable() {

            @Override
            public void run() {
                synchronized (ActivityManagerService.this) {
                    mProcessStats.writeStateAsyncLocked();
                }
            }
        });
    }
    if (DEBUG_OOM_ADJ) {
        final long duration = SystemClock.uptimeMillis() - now;
        if (false) {
            Slog.d(TAG_OOM_ADJ, "Did OOM ADJ in " + duration + "ms", new RuntimeException("here").fillInStackTrace());
        } else {
            Slog.d(TAG_OOM_ADJ, "Did OOM ADJ in " + duration + "ms");
        }
    }
}
#end_block

#method_before
final void trimApplications() {
    synchronized (this) {
        int i;
        // has been removed.
        for (i = mRemovedProcesses.size() - 1; i >= 0; i--) {
            final ProcessRecord app = mRemovedProcesses.get(i);
            if (app.activities.size() == 0 && app.curReceiver == null && app.services.size() == 0) {
                Slog.i(TAG, "Exiting empty application process " + app.processName + " (" + (app.thread != null ? app.thread.asBinder() : null) + ")\n");
                if (app.pid > 0 && app.pid != MY_PID) {
                    app.kill("empty", false);
                } else {
                    try {
                        app.thread.scheduleExit();
                    } catch (Exception e) {
                    // Ignore exceptions.
                    }
                }
                cleanUpApplicationRecordLocked(app, false, true, -1);
                mRemovedProcesses.remove(i);
                if (app.persistent) {
                    addAppLocked(app.info, false, null);
                }
            }
        }
        // Now update the oom adj for all processes.
        updateOomAdjLocked();
    }
}
#method_after
final void trimApplications() {
    synchronized (this) {
        int i;
        // has been removed.
        for (i = mRemovedProcesses.size() - 1; i >= 0; i--) {
            final ProcessRecord app = mRemovedProcesses.get(i);
            if (app.activities.size() == 0 && app.curReceivers.isEmpty() && app.services.size() == 0) {
                Slog.i(TAG, "Exiting empty application process " + app.toShortString() + " (" + (app.thread != null ? app.thread.asBinder() : null) + ")\n");
                if (app.pid > 0 && app.pid != MY_PID) {
                    app.kill("empty", false);
                } else {
                    try {
                        app.thread.scheduleExit();
                    } catch (Exception e) {
                    // Ignore exceptions.
                    }
                }
                cleanUpApplicationRecordLocked(app, false, true, -1);
                mRemovedProcesses.remove(i);
                if (app.persistent) {
                    addAppLocked(app.info, false, null);
                }
            }
        }
        // Now update the oom adj for all processes.
        updateOomAdjLocked();
    }
}
#end_block

#method_before
private ProcessRecord findProcessLocked(String process, int userId, String callName) {
    userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, ALLOW_FULL_ONLY, callName, null);
    ProcessRecord proc = null;
    try {
        int pid = Integer.parseInt(process);
        synchronized (mPidsSelfLocked) {
            proc = mPidsSelfLocked.get(pid);
        }
    } catch (NumberFormatException e) {
    }
    if (proc == null) {
        ArrayMap<String, SparseArray<ProcessRecord>> all = mProcessNames.getMap();
        SparseArray<ProcessRecord> procs = all.get(process);
        if (procs != null && procs.size() > 0) {
            proc = procs.valueAt(0);
            if (userId != UserHandle.USER_ALL && proc.userId != userId) {
                for (int i = 1; i < procs.size(); i++) {
                    ProcessRecord thisProc = procs.valueAt(i);
                    if (thisProc.userId == userId) {
                        proc = thisProc;
                        break;
                    }
                }
            }
        }
    }
    return proc;
}
#method_after
private ProcessRecord findProcessLocked(String process, int userId, String callName) {
    userId = mUserController.handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, true, ALLOW_FULL_ONLY, callName, null);
    ProcessRecord proc = null;
    try {
        int pid = Integer.parseInt(process);
        synchronized (mPidsSelfLocked) {
            proc = mPidsSelfLocked.get(pid);
        }
    } catch (NumberFormatException e) {
    }
    if (proc == null) {
        ArrayMap<String, SparseArray<ProcessRecord>> all = mProcessNames.getMap();
        SparseArray<ProcessRecord> procs = all.get(process);
        if (procs != null && procs.size() > 0) {
            proc = procs.valueAt(0);
            if (userId != UserHandle.USER_ALL && proc.userId != userId) {
                for (int i = 1; i < procs.size(); i++) {
                    ProcessRecord thisProc = procs.valueAt(i);
                    if (thisProc.userId == userId) {
                        proc = thisProc;
                        break;
                    }
                }
            }
        }
    }
    return proc;
}
#end_block

#method_before
// Multi-user methods
@Override
public boolean startUserInBackground(final int userId) {
    return startUser(userId, /* foreground */
    false);
}
#method_after
// Multi-user methods
@Override
public boolean startUserInBackground(final int userId) {
    return mUserController.startUser(userId, /* foreground */
    false);
}
#end_block

#method_before
@Override
public boolean switchUser(final int userId) {
    enforceShellRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, userId);
    String userName;
    synchronized (this) {
        UserInfo userInfo = getUserManagerLocked().getUserInfo(userId);
        if (userInfo == null) {
            Slog.w(TAG, "No user info for user #" + userId);
            return false;
        }
        if (userInfo.isManagedProfile()) {
            Slog.w(TAG, "Cannot switch to User #" + userId + ": not a full user");
            return false;
        }
        userName = userInfo.name;
        mTargetUserId = userId;
    }
    mUiHandler.removeMessages(START_USER_SWITCH_MSG);
    mUiHandler.sendMessage(mUiHandler.obtainMessage(START_USER_SWITCH_MSG, userId, 0, userName));
    return true;
}
#method_after
@Override
public boolean switchUser(final int targetUserId) {
    enforceShellRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, targetUserId);
    UserInfo currentUserInfo;
    UserInfo targetUserInfo;
    synchronized (this) {
        int currentUserId = mUserController.getCurrentUserIdLocked();
        currentUserInfo = mUserController.getUserInfo(currentUserId);
        targetUserInfo = mUserController.getUserInfo(targetUserId);
        if (targetUserInfo == null) {
            Slog.w(TAG, "No user info for user #" + targetUserId);
            return false;
        }
        if (!targetUserInfo.supportsSwitchTo()) {
            Slog.w(TAG, "Cannot switch to User #" + targetUserId + ": not supported");
            return false;
        }
        if (targetUserInfo.isManagedProfile()) {
            Slog.w(TAG, "Cannot switch to User #" + targetUserId + ": not a full user");
            return false;
        }
        mUserController.setTargetUserIdLocked(targetUserId);
    }
    Pair<UserInfo, UserInfo> userNames = new Pair<>(currentUserInfo, targetUserInfo);
    mUiHandler.removeMessages(START_USER_SWITCH_UI_MSG);
    mUiHandler.sendMessage(mUiHandler.obtainMessage(START_USER_SWITCH_UI_MSG, userNames));
    return true;
}
#end_block

#method_before
@Override
public int stopUser(final int userId, final IStopUserCallback callback) {
    if (checkCallingPermission(INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: switchUser() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + INTERACT_ACROSS_USERS_FULL;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    if (userId < 0 || userId == UserHandle.USER_OWNER) {
        throw new IllegalArgumentException("Can't stop primary user " + userId);
    }
    enforceShellRestriction(UserManager.DISALLOW_DEBUGGING_FEATURES, userId);
    synchronized (this) {
        return stopUserLocked(userId, callback);
    }
}
#method_after
@Override
public int stopUser(final int userId, boolean force, final IStopUserCallback callback) {
    return mUserController.stopUser(userId, force, callback);
}
#end_block

#method_before
@Override
public UserInfo getCurrentUser() {
    if ((checkCallingPermission(INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) && (checkCallingPermission(INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED)) {
        String msg = "Permission Denial: getCurrentUser() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + INTERACT_ACROSS_USERS;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    synchronized (this) {
        int userId = mTargetUserId != UserHandle.USER_NULL ? mTargetUserId : mCurrentUserId;
        return getUserManagerLocked().getUserInfo(userId);
    }
}
#method_after
@Override
public UserInfo getCurrentUser() {
    return mUserController.getCurrentUser();
}
#end_block

#method_before
@Override
public boolean isUserRunning(int userId, boolean orStopped) {
    if (checkCallingPermission(INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: isUserRunning() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + INTERACT_ACROSS_USERS;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    synchronized (this) {
        return isUserRunningLocked(userId, orStopped);
    }
}
#method_after
@Override
public boolean isUserRunning(int userId, int flags) {
    if (userId != UserHandle.getCallingUserId() && checkCallingPermission(INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: isUserRunning() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + INTERACT_ACROSS_USERS;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    synchronized (this) {
        return mUserController.isUserRunningLocked(userId, flags);
    }
}
#end_block

#method_before
@Override
public int[] getRunningUserIds() {
    if (checkCallingPermission(INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: isUserRunning() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + INTERACT_ACROSS_USERS;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    synchronized (this) {
        return mStartedUserArray;
    }
}
#method_after
@Override
public int[] getRunningUserIds() {
    if (checkCallingPermission(INTERACT_ACROSS_USERS) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: isUserRunning() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + INTERACT_ACROSS_USERS;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    synchronized (this) {
        return mUserController.getStartedUserArrayLocked();
    }
}
#end_block

#method_before
@Override
public void registerUserSwitchObserver(IUserSwitchObserver observer) {
    if (checkCallingPermission(INTERACT_ACROSS_USERS_FULL) != PackageManager.PERMISSION_GRANTED) {
        String msg = "Permission Denial: registerUserSwitchObserver() from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid() + " requires " + INTERACT_ACROSS_USERS_FULL;
        Slog.w(TAG, msg);
        throw new SecurityException(msg);
    }
    mUserSwitchObservers.register(observer);
}
#method_after
@Override
public void registerUserSwitchObserver(IUserSwitchObserver observer) {
    mUserController.registerUserSwitchObserver(observer);
}
#end_block

#method_before
@Override
public void unregisterUserSwitchObserver(IUserSwitchObserver observer) {
    mUserSwitchObservers.unregister(observer);
}
#method_after
@Override
public void unregisterUserSwitchObserver(IUserSwitchObserver observer) {
    mUserController.unregisterUserSwitchObserver(observer);
}
#end_block

#method_before
ApplicationInfo getAppInfoForUser(ApplicationInfo info, int userId) {
    if (info == null)
        return null;
    ApplicationInfo newInfo = new ApplicationInfo(info);
    newInfo.uid = applyUserId(info.uid, userId);
    newInfo.dataDir = Environment.getDataUserPackageDirectory(info.volumeUuid, userId, info.packageName).getAbsolutePath();
    return newInfo;
}
#method_after
ApplicationInfo getAppInfoForUser(ApplicationInfo info, int userId) {
    if (info == null)
        return null;
    ApplicationInfo newInfo = new ApplicationInfo(info);
    newInfo.initForUser(userId);
    return newInfo;
}
#end_block

#method_before
@Override
public SleepToken acquireSleepToken(String tag) {
    Preconditions.checkNotNull(tag);
    synchronized (ActivityManagerService.this) {
        SleepTokenImpl token = new SleepTokenImpl(tag);
        mSleepTokens.add(token);
        updateSleepIfNeededLocked();
        return token;
    }
}
#method_after
@Override
public SleepToken acquireSleepToken(String tag) {
    Preconditions.checkNotNull(tag);
    ComponentName requestedVrService = null;
    ComponentName callingVrActivity = null;
    int userId = -1;
    synchronized (ActivityManagerService.this) {
        if (mFocusedActivity != null) {
            requestedVrService = mFocusedActivity.requestedVrComponent;
            callingVrActivity = mFocusedActivity.info.getComponentName();
            userId = mFocusedActivity.userId;
        }
    }
    if (requestedVrService != null) {
        applyVrMode(false, requestedVrService, userId, callingVrActivity, true);
    }
    synchronized (ActivityManagerService.this) {
        SleepTokenImpl token = new SleepTokenImpl(tag);
        mSleepTokens.add(token);
        updateSleepIfNeededLocked();
        return token;
    }
}
#end_block

#method_before
@Override
public void finishAndRemoveTask() {
    checkCaller();
    synchronized (ActivityManagerService.this) {
        long origId = Binder.clearCallingIdentity();
        try {
            if (!removeTaskByIdLocked(mTaskId, false)) {
                throw new IllegalArgumentException("Unable to find task ID " + mTaskId);
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }
}
#method_after
@Override
public void finishAndRemoveTask() {
    checkCaller();
    synchronized (ActivityManagerService.this) {
        long origId = Binder.clearCallingIdentity();
        try {
            // We remove the task from recents to preserve backwards
            if (!removeTaskByIdLocked(mTaskId, false, REMOVE_FROM_RECENTS)) {
                throw new IllegalArgumentException("Unable to find task ID " + mTaskId);
            }
        } finally {
            Binder.restoreCallingIdentity(origId);
        }
    }
}
#end_block

#method_before
@Override
public void moveToFront() {
    checkCaller();
    // Will bring task to front if it already has a root activity.
    startActivityFromRecentsInner(mTaskId, null);
}
#method_after
@Override
public void moveToFront() {
    checkCaller();
    // Will bring task to front if it already has a root activity.
    final long origId = Binder.clearCallingIdentity();
    try {
        synchronized (this) {
            mStackSupervisor.startActivityFromRecentsInner(mTaskId, null);
        }
    } finally {
        Binder.restoreCallingIdentity(origId);
    }
}
#end_block

#method_before
@Override
public int startActivity(IBinder whoThread, String callingPackage, Intent intent, String resolvedType, Bundle options) {
    checkCaller();
    int callingUser = UserHandle.getCallingUserId();
    TaskRecord tr;
    IApplicationThread appThread;
    synchronized (ActivityManagerService.this) {
        tr = mStackSupervisor.anyTaskForIdLocked(mTaskId);
        if (tr == null) {
            throw new IllegalArgumentException("Unable to find task ID " + mTaskId);
        }
        appThread = ApplicationThreadNative.asInterface(whoThread);
        if (appThread == null) {
            throw new IllegalArgumentException("Bad app thread " + appThread);
        }
    }
    return mStackSupervisor.startActivityMayWait(appThread, -1, callingPackage, intent, resolvedType, null, null, null, null, 0, 0, null, null, null, options, false, callingUser, null, tr);
}
#method_after
@Override
public int startActivity(IBinder whoThread, String callingPackage, Intent intent, String resolvedType, Bundle bOptions) {
    checkCaller();
    int callingUser = UserHandle.getCallingUserId();
    TaskRecord tr;
    IApplicationThread appThread;
    synchronized (ActivityManagerService.this) {
        tr = mStackSupervisor.anyTaskForIdLocked(mTaskId);
        if (tr == null) {
            throw new IllegalArgumentException("Unable to find task ID " + mTaskId);
        }
        appThread = ApplicationThreadNative.asInterface(whoThread);
        if (appThread == null) {
            throw new IllegalArgumentException("Bad app thread " + appThread);
        }
    }
    return mActivityStarter.startActivityMayWait(appThread, -1, callingPackage, intent, resolvedType, null, null, null, null, 0, 0, null, null, null, bOptions, false, callingUser, null, tr);
}
#end_block

#method_before
private static NativeLibraryElement[] makePathElements(List<File> files) {
    NativeLibraryElement[] elements = new NativeLibraryElement[files.size()];
    int elementsPos = 0;
    for (File file : files) {
        String path = file.getPath();
        if (path.contains(zipSeparator)) {
            String[] split = path.split(zipSeparator, 2);
            File zip = new File(split[0]);
            File dir = new File(split[1]);
            elements[elementsPos++] = new NativeLibraryElement(zip, dir);
        } else if (file.isDirectory()) {
            // We support directories for looking up native libraries.
            elements[elementsPos++] = new NativeLibraryElement(file);
        } else if (file.isFile()) {
            elements[elementsPos++] = new NativeLibraryElement(file, NoPreloadHolder.EMPTY_DIR);
        } else {
            System.logW("ClassLoader referenced unknown path: " + file);
        }
    }
    if (elementsPos != elements.length) {
        elements = Arrays.copyOf(elements, elementsPos);
    }
    return elements;
}
#method_after
private static NativeLibraryElement[] makePathElements(List<File> files) {
    NativeLibraryElement[] elements = new NativeLibraryElement[files.size()];
    int elementsPos = 0;
    for (File file : files) {
        String path = file.getPath();
        if (path.contains(zipSeparator)) {
            String[] split = path.split(zipSeparator, 2);
            File zip = new File(split[0]);
            String dir = split[1];
            elements[elementsPos++] = new NativeLibraryElement(zip, dir);
        } else if (file.isDirectory()) {
            // We support directories for looking up native libraries.
            elements[elementsPos++] = new NativeLibraryElement(file);
        } else {
            System.logW("ClassLoader referenced unknown path: " + file);
        }
    }
    if (elementsPos != elements.length) {
        elements = Arrays.copyOf(elements, elementsPos);
    }
    return elements;
}
#end_block

#method_before
@Override
public String toString() {
    if (zipDir == null) {
        return "directory \"" + path + "\"";
    } else {
        return "zip file \"" + path + "\"" + (!zipDir.getPath().isEmpty() ? ", dir \"" + zipDir + "\"" : "");
    }
}
#method_after
@Override
public String toString() {
    if (zipDir == null) {
        return "directory \"" + path + "\"";
    } else {
        return "zip file \"" + path + "\"" + (!zipDir.isEmpty() ? ", dir \"" + zipDir + "\"" : "");
    }
}
#end_block

#method_before
public String findNativeLibrary(String name) {
    maybeInit();
    if (zipDir == null) {
        String entryPath = new File(path, name).getPath();
        if (IoUtils.canOpenReadOnly(entryPath)) {
            return entryPath;
        }
    } else if (urlHandler != null) {
        // Having a urlHandler means the element has a zip file.
        // In this case Android supports loading the library iff
        // it is stored in the zip uncompressed.
        String entryName = new File(zipDir, name).getPath();
        if (urlHandler.isEntryStored(entryName)) {
            return path.getPath() + zipSeparator + entryName;
        }
    }
    return null;
}
#method_after
public String findNativeLibrary(String name) {
    maybeInit();
    if (zipDir == null) {
        String entryPath = new File(path, name).getPath();
        if (IoUtils.canOpenReadOnly(entryPath)) {
            return entryPath;
        }
    } else if (urlHandler != null) {
        // Having a urlHandler means the element has a zip file.
        // In this case Android supports loading the library iff
        // it is stored in the zip uncompressed.
        String entryName = zipDir + '/' + name;
        if (urlHandler.isEntryStored(entryName)) {
            return path.getPath() + zipSeparator + entryName;
        }
    }
    return null;
}
#end_block

#method_before
public void testRequestHeaderValidation() throws Exception {
    // Android became more strict after M about which characters were allowed in request header
    // names and values: previously almost anything was allowed if it didn't contain \0.
    assertForbiddenRequestHeaderName(null);
    assertForbiddenRequestHeaderName("");
    assertForbiddenRequestHeaderName("\n");
    assertForbiddenRequestHeaderName("a\nb");
    assertForbiddenRequestHeaderName("\u0000");
    assertForbiddenRequestHeaderName("\r");
    assertForbiddenRequestHeaderName("\t");
    assertForbiddenRequestHeaderName("\u001f");
    assertForbiddenRequestHeaderName("\u007f");
    assertForbiddenRequestHeaderName("\u0080");
    assertForbiddenRequestHeaderName("\ud83c\udf69");
    assertEquals(null, setAndReturnRequestHeaderValue(null));
    assertEquals("", setAndReturnRequestHeaderValue(""));
    assertForbiddenRequestHeaderValue("\u0000");
    // (b) for API 23 (Android N) specifically, it's also permissible to forbid it
    try {
        // passes in case (a), throws IAE in case (b)
        assertEquals("a valid\tvalue", setAndReturnRequestHeaderValue("a valid\tvalue"));
    } catch (IllegalArgumentException tolerated) {
        // verify case (b)
        assertForbiddenRequestHeaderValue("\t");
    }
    assertForbiddenRequestHeaderValue("\u001f");
    assertForbiddenRequestHeaderValue("\u007f");
    // For http://b/28867041 the allowed character range was changed.
    // assertForbiddenRequestHeaderValue("\u0080");
    // assertForbiddenRequestHeaderValue("\ud83c\udf69");
    assertEquals("\u0080", setAndReturnRequestHeaderValue("\u0080"));
    assertEquals("\ud83c\udf69", setAndReturnRequestHeaderValue("\ud83c\udf69"));
    // Workaround for http://b/26422335 , http://b/26889631 , http://b/27606665 :
    // allow (but strip) trailing \n, \r and \r\n
    assertEquals("", setAndReturnRequestHeaderValue("\n"));
    assertEquals("a", setAndReturnRequestHeaderValue("a\n"));
    assertEquals("", setAndReturnRequestHeaderValue("\r"));
    assertEquals("a", setAndReturnRequestHeaderValue("a\r"));
    assertEquals("", setAndReturnRequestHeaderValue("\r\n"));
    assertEquals("a", setAndReturnRequestHeaderValue("a\r\n"));
    assertForbiddenRequestHeaderValue("a\nb");
    assertForbiddenRequestHeaderValue("\nb");
    assertForbiddenRequestHeaderValue("a\rb");
    assertForbiddenRequestHeaderValue("\rb");
    assertForbiddenRequestHeaderValue("a\r\nb");
    assertForbiddenRequestHeaderValue("\r\nb");
// End of workaround
}
#method_after
public void testRequestHeaderValidation() throws Exception {
    // Android became more strict after M about which characters were allowed in request header
    // names and values: previously almost anything was allowed if it didn't contain \0.
    assertForbiddenRequestHeaderName(null);
    assertForbiddenRequestHeaderName("");
    assertForbiddenRequestHeaderName("\n");
    assertForbiddenRequestHeaderName("a\nb");
    assertForbiddenRequestHeaderName("\u0000");
    assertForbiddenRequestHeaderName("\r");
    assertForbiddenRequestHeaderName("\t");
    assertForbiddenRequestHeaderName("\u001f");
    assertForbiddenRequestHeaderName("\u007f");
    assertForbiddenRequestHeaderName("\u0080");
    assertForbiddenRequestHeaderName("\ud83c\udf69");
    assertEquals(null, setAndReturnRequestHeaderValue(null));
    assertEquals("", setAndReturnRequestHeaderValue(""));
    assertForbiddenRequestHeaderValue("\u0000");
    // allow behavior (b).
    try {
        // throws IAE in case (a), passes in case (b)
        assertEquals("a valid\tvalue", setAndReturnRequestHeaderValue("a valid\tvalue"));
    } catch (IllegalArgumentException tolerated) {
        // verify case (a)
        assertForbiddenRequestHeaderValue("\t");
    }
    assertForbiddenRequestHeaderValue("\u001f");
    assertForbiddenRequestHeaderValue("\u007f");
    // For http://b/28867041 the allowed character range was changed.
    // assertForbiddenRequestHeaderValue("\u0080");
    // assertForbiddenRequestHeaderValue("\ud83c\udf69");
    assertEquals("\u0080", setAndReturnRequestHeaderValue("\u0080"));
    assertEquals("\ud83c\udf69", setAndReturnRequestHeaderValue("\ud83c\udf69"));
    // Workaround for http://b/26422335 , http://b/26889631 , http://b/27606665 :
    // allow (but strip) trailing \n, \r and \r\n
    assertEquals("", setAndReturnRequestHeaderValue("\n"));
    assertEquals("a", setAndReturnRequestHeaderValue("a\n"));
    assertEquals("", setAndReturnRequestHeaderValue("\r"));
    assertEquals("a", setAndReturnRequestHeaderValue("a\r"));
    assertEquals("", setAndReturnRequestHeaderValue("\r\n"));
    assertEquals("a", setAndReturnRequestHeaderValue("a\r\n"));
    assertForbiddenRequestHeaderValue("a\nb");
    assertForbiddenRequestHeaderValue("\nb");
    assertForbiddenRequestHeaderValue("a\rb");
    assertForbiddenRequestHeaderValue("\rb");
    assertForbiddenRequestHeaderValue("a\r\nb");
    assertForbiddenRequestHeaderValue("\r\nb");
// End of workaround
}
#end_block

#method_before
// TODO(zqiu): revisit this when integrating the new Passpoint implementation and add
public int match(List<String> credLabels, EAPMethod credMethod) {
    int realmMatch = AuthMatch.None;
    if (!mRealms.isEmpty()) {
        for (String realm : mRealms) {
            List<String> labels = Utils.splitDomain(realm);
            if (DomainMatcher.arg2SubdomainOfArg1(credLabels, labels)) {
                realmMatch = AuthMatch.Realm;
                break;
            }
        }
        if (realmMatch == AuthMatch.None || mEAPMethods.isEmpty()) {
            return realmMatch;
        }
    // else there is a realm match and one or more EAP methods - check them.
    } else if (mEAPMethods.isEmpty()) {
        return AuthMatch.Indeterminate;
    }
    int best = AuthMatch.None;
    for (EAPMethod eapMethod : mEAPMethods) {
        int match = eapMethod.match(credMethod) | realmMatch;
        if (match > best) {
            best = match;
            if (best == AuthMatch.Exact) {
                return best;
            }
        }
    }
    return best;
}
#method_after
// TODO(b/32714185): revisit this when integrating the new Passpoint implementation and add
public int match(List<String> credLabels, EAPMethod credMethod) {
    int realmMatch = AuthMatch.None;
    if (!mRealms.isEmpty()) {
        for (String realm : mRealms) {
            List<String> labels = Utils.splitDomain(realm);
            if (DomainMatcher.arg2SubdomainOfArg1(credLabels, labels)) {
                realmMatch = AuthMatch.Realm;
                break;
            }
        }
        if (realmMatch == AuthMatch.None || mEAPMethods.isEmpty()) {
            return realmMatch;
        }
    // else there is a realm match and one or more EAP methods - check them.
    } else if (mEAPMethods.isEmpty()) {
        return AuthMatch.Indeterminate;
    }
    int best = AuthMatch.None;
    for (EAPMethod eapMethod : mEAPMethods) {
        int match = eapMethod.match(credMethod) | realmMatch;
        if (match > best) {
            best = match;
            if (best == AuthMatch.Exact) {
                return best;
            }
        }
    }
    return best;
}
#end_block

#method_before
// TODO(zqiu): revisit this when integrating the new Passpoint implementation and add
public int match(EAPMethod credMethod) {
    if (mEAPMethodID != credMethod.getEAPMethodID()) {
        return AuthMatch.None;
    }
    switch(mEAPMethodID) {
        case EAP_TTLS:
            if (mAuthParams.isEmpty()) {
                return AuthMatch.Method;
            }
            int paramCount = 0;
            for (Map.Entry<EAP.AuthInfoID, Set<AuthParam>> entry : credMethod.getAuthParams().entrySet()) {
                Set<AuthParam> params = mAuthParams.get(entry.getKey());
                if (params == null) {
                    continue;
                }
                if (!Collections.disjoint(params, entry.getValue())) {
                    return AuthMatch.MethodParam;
                }
                paramCount += params.size();
            }
            return paramCount > 0 ? AuthMatch.None : AuthMatch.Method;
        case EAP_TLS:
            return AuthMatch.MethodParam;
        case EAP_SIM:
        case EAP_AKA:
        case EAP_AKAPrim:
            return AuthMatch.Method;
        default:
            return AuthMatch.Method;
    }
}
#method_after
// TODO(b/32714185): revisit this when integrating the new Passpoint implementation and add
public int match(EAPMethod credMethod) {
    if (mEAPMethodID != credMethod.getEAPMethodID()) {
        return AuthMatch.None;
    }
    switch(mEAPMethodID) {
        case EAP_TTLS:
            if (mAuthParams.isEmpty()) {
                return AuthMatch.Method;
            }
            int paramCount = 0;
            for (Map.Entry<EAP.AuthInfoID, Set<AuthParam>> entry : credMethod.getAuthParams().entrySet()) {
                Set<AuthParam> params = mAuthParams.get(entry.getKey());
                if (params == null) {
                    continue;
                }
                if (!Collections.disjoint(params, entry.getValue())) {
                    return AuthMatch.MethodParam;
                }
                paramCount += params.size();
            }
            return paramCount > 0 ? AuthMatch.None : AuthMatch.Method;
        case EAP_TLS:
            return AuthMatch.MethodParam;
        case EAP_SIM:
        case EAP_AKA:
        case EAP_AKAPrim:
            return AuthMatch.Method;
        default:
            return AuthMatch.Method;
    }
}
#end_block

#method_before
// TODO(zqiu): revisit this when integrating the new Passpoint implementation and add
public int match(String realm, EAPMethod credMethod) {
    if (mRealmData.isEmpty())
        return AuthMatch.Indeterminate;
    List<String> credLabels = Utils.splitDomain(realm);
    int best = AuthMatch.None;
    for (NAIRealmData realmData : mRealmData) {
        int match = realmData.match(credLabels, credMethod);
        if (match > best) {
            best = match;
            if (best == AuthMatch.Exact) {
                return best;
            }
        }
    }
    return best;
}
#method_after
// TODO(b/32714185): revisit this when integrating the new Passpoint implementation and add
public int match(String realm, EAPMethod credMethod) {
    if (mRealmData.isEmpty())
        return AuthMatch.Indeterminate;
    List<String> credLabels = Utils.splitDomain(realm);
    int best = AuthMatch.None;
    for (NAIRealmData realmData : mRealmData) {
        int match = realmData.match(credLabels, credMethod);
        if (match > best) {
            best = match;
            if (best == AuthMatch.Exact) {
                return best;
            }
        }
    }
    return best;
}
#end_block

#method_before
// RSNE format (size unit: byte)
// 
// | Element ID | Length | Version | Group Data Cipher Suite |
// 1           1         2                 4
// | Pairwise Cipher Suite Count | Pairwise Cipher Suite List |
// 2                            4 * m
// | AKM Suite Count | AKM Suite List | RSN Capabilities |
// 2               4 * n               2
// | PMKID Count | PMKID List | Group Management Cipher Suite |
// 2          16 * s                 4
// 
// Note: InformationElement.bytes has 'Element ID' and 'Length'
private void parseRsnElement(InformationElement ie) {
    ByteBuffer buf = ByteBuffer.wrap(ie.bytes).order(ByteOrder.LITTLE_ENDIAN);
    try {
        // version
        if (buf.getShort() != RSNE_VERSION) {
            // incorrect version
            return;
        }
        // found the RSNE IE, hence start building the capability string
        mProtocol = ScanResult.PROTOCOL_WPA2;
        // group data cipher suite
        mGroupCipher = parseRsnCipher(buf.getInt());
        // pairwise cipher suite count
        short cipherCount = buf.getShort();
        // pairwise cipher suite list
        for (int i = 0; i < cipherCount; i++) {
            mPairwiseCipher.add(parseRsnCipher(buf.getInt()));
        }
        // AKM
        // AKM suite count
        short akmCount = buf.getShort();
        for (int i = 0; i < akmCount; i++) {
            int akm = buf.getInt();
            switch(akm) {
                case WPA2_AKM_EAP:
                    mKeyManagement.add(new Integer(ScanResult.AKM_EAP));
                    break;
                case WPA2_AKM_PSK:
                    mKeyManagement.add(new Integer(ScanResult.AKM_PSK));
                    break;
                case WPA2_AKM_FT_EAP:
                    mKeyManagement.add(new Integer(ScanResult.AKM_FT_EAP));
                    break;
                case WPA2_AKM_FT_PSK:
                    mKeyManagement.add(new Integer(ScanResult.AKM_FT_PSK));
                    break;
                case WPA2_AKM_EAP_SHA256:
                    mKeyManagement.add(new Integer(ScanResult.AKM_EAP_SHA256));
                    break;
                case WPA2_AKM_PSK_SHA256:
                    mKeyManagement.add(new Integer(ScanResult.AKM_PSK_SHA256));
                    break;
                default:
                    // do nothing
                    break;
            }
        }
        // Default AKM
        if (mKeyManagement.isEmpty()) {
            mKeyManagement.add(new Integer(ScanResult.AKM_EAP));
        }
    } catch (BufferUnderflowException e) {
        Log.e("IE_Capabilities", "Couldn't parse RSNE, buffer underflow");
    }
}
#method_after
// RSNE format (size unit: byte)
// 
// | Element ID | Length | Version | Group Data Cipher Suite |
// 1           1         2                 4
// | Pairwise Cipher Suite Count | Pairwise Cipher Suite List |
// 2                            4 * m
// | AKM Suite Count | AKM Suite List | RSN Capabilities |
// 2               4 * n               2
// | PMKID Count | PMKID List | Group Management Cipher Suite |
// 2          16 * s                 4
// 
// Note: InformationElement.bytes has 'Element ID' and 'Length'
private void parseRsnElement(InformationElement ie) {
    ByteBuffer buf = ByteBuffer.wrap(ie.bytes).order(ByteOrder.LITTLE_ENDIAN);
    try {
        // version
        if (buf.getShort() != RSNE_VERSION) {
            // incorrect version
            return;
        }
        // found the RSNE IE, hence start building the capability string
        protocol = ScanResult.PROTOCOL_WPA2;
        // group data cipher suite
        groupCipher = parseRsnCipher(buf.getInt());
        // pairwise cipher suite count
        short cipherCount = buf.getShort();
        // pairwise cipher suite list
        for (int i = 0; i < cipherCount; i++) {
            pairwiseCipher.add(parseRsnCipher(buf.getInt()));
        }
        // AKM
        // AKM suite count
        short akmCount = buf.getShort();
        for (int i = 0; i < akmCount; i++) {
            int akm = buf.getInt();
            switch(akm) {
                case WPA2_AKM_EAP:
                    keyManagement.add(ScanResult.KEY_MGMT_EAP);
                    break;
                case WPA2_AKM_PSK:
                    keyManagement.add(ScanResult.KEY_MGMT_PSK);
                    break;
                case WPA2_AKM_FT_EAP:
                    keyManagement.add(ScanResult.KEY_MGMT_FT_EAP);
                    break;
                case WPA2_AKM_FT_PSK:
                    keyManagement.add(ScanResult.KEY_MGMT_FT_PSK);
                    break;
                case WPA2_AKM_EAP_SHA256:
                    keyManagement.add(ScanResult.KEY_MGMT_EAP_SHA256);
                    break;
                case WPA2_AKM_PSK_SHA256:
                    keyManagement.add(ScanResult.KEY_MGMT_PSK_SHA256);
                    break;
                default:
                    // do nothing
                    break;
            }
        }
        // Default AKM
        if (keyManagement.isEmpty()) {
            keyManagement.add(ScanResult.KEY_MGMT_EAP);
        }
    } catch (BufferUnderflowException e) {
        Log.e("IE_Capabilities", "Couldn't parse RSNE, buffer underflow");
    }
}
#end_block

#method_before
private static int parseWpaCipher(int cipher) {
    switch(cipher) {
        case WPA_CIPHER_NONE:
            return ScanResult.CIPHER_NONE;
        case WPA_CIPHER_TKIP:
            return ScanResult.CIPHER_TKIP;
        case WPA_CIPHER_CCMP:
            return ScanResult.CIPHER_CCMP;
        default:
            return ScanResult.CIPHER_NONE;
    }
}
#method_after
private static int parseWpaCipher(int cipher) {
    switch(cipher) {
        case WPA_CIPHER_NONE:
            return ScanResult.CIPHER_NONE;
        case WPA_CIPHER_TKIP:
            return ScanResult.CIPHER_TKIP;
        case WPA_CIPHER_CCMP:
            return ScanResult.CIPHER_CCMP;
        default:
            Log.w("IE_Capabilities", "Unknown WPA cipher suite: " + Integer.toHexString(cipher));
            return ScanResult.CIPHER_NONE;
    }
}
#end_block

#method_before
private static int parseRsnCipher(int cipher) {
    switch(cipher) {
        case RSN_CIPHER_NONE:
            return ScanResult.CIPHER_NONE;
        case RSN_CIPHER_TKIP:
            return ScanResult.CIPHER_TKIP;
        case RSN_CIPHER_CCMP:
            return ScanResult.CIPHER_CCMP;
        case RSN_CIPHER_NO_GROUP_ADDRESSED:
            return ScanResult.CIPHER_NO_GROUP_ADDRESSED;
        default:
            return ScanResult.CIPHER_NONE;
    }
}
#method_after
private static int parseRsnCipher(int cipher) {
    switch(cipher) {
        case RSN_CIPHER_NONE:
            return ScanResult.CIPHER_NONE;
        case RSN_CIPHER_TKIP:
            return ScanResult.CIPHER_TKIP;
        case RSN_CIPHER_CCMP:
            return ScanResult.CIPHER_CCMP;
        case RSN_CIPHER_NO_GROUP_ADDRESSED:
            return ScanResult.CIPHER_NO_GROUP_ADDRESSED;
        default:
            Log.w("IE_Capabilities", "Unknown RSN cipher suite: " + Integer.toHexString(cipher));
            return ScanResult.CIPHER_NONE;
    }
}
#end_block

#method_before
// WPA type 1 format (size unit: byte)
// 
// | Element ID | Length | OUI | Type | Version |
// 1           1       3     1        2
// | Group Data Cipher Suite |
// 4
// | Pairwise Cipher Suite Count | Pairwise Cipher Suite List |
// 2                            4 * m
// | AKM Suite Count | AKM Suite List |
// 2               4 * n
// 
// Note: InformationElement.bytes has 'Element ID' and 'Length'
// stripped off already
private void parseWpaOneElement(InformationElement ie) {
    ByteBuffer buf = ByteBuffer.wrap(ie.bytes).order(ByteOrder.LITTLE_ENDIAN);
    try {
        // skip WPA OUI and type parsing. isWpaOneElement() should have
        // been called for verification before we reach here.
        buf.getInt();
        // version
        if (buf.getShort() != WPA_VENDOR_OUI_VERSION) {
            // incorrect version
            return;
        }
        // start building the string
        mProtocol = ScanResult.PROTOCOL_WPA;
        // group data cipher suite
        mGroupCipher = parseWpaCipher(buf.getInt());
        // pairwise cipher suite count
        short cipherCount = buf.getShort();
        // pairwise chipher suite list
        for (int i = 0; i < cipherCount; i++) {
            mPairwiseCipher.add(parseWpaCipher(buf.getInt()));
        }
        // AKM
        // AKM suite count
        short akmCount = buf.getShort();
        // AKM suite list
        for (int i = 0; i < akmCount; i++) {
            int akm = buf.getInt();
            switch(akm) {
                case WPA_AKM_EAP:
                    mKeyManagement.add(new Integer(ScanResult.AKM_EAP));
                    break;
                case WPA_AKM_PSK:
                    mKeyManagement.add(new Integer(ScanResult.AKM_PSK));
                    break;
                default:
                    // do nothing
                    break;
            }
        }
        // Default AKM
        if (mKeyManagement.isEmpty()) {
            mKeyManagement.add(new Integer(ScanResult.AKM_EAP));
        }
    } catch (BufferUnderflowException e) {
        Log.e("IE_Capabilities", "Couldn't parse type 1 WPA, buffer underflow");
    }
}
#method_after
// WPA type 1 format (size unit: byte)
// 
// | Element ID | Length | OUI | Type | Version |
// 1           1       3     1        2
// | Group Data Cipher Suite |
// 4
// | Pairwise Cipher Suite Count | Pairwise Cipher Suite List |
// 2                            4 * m
// | AKM Suite Count | AKM Suite List |
// 2               4 * n
// 
// Note: InformationElement.bytes has 'Element ID' and 'Length'
// stripped off already
private void parseWpaOneElement(InformationElement ie) {
    ByteBuffer buf = ByteBuffer.wrap(ie.bytes).order(ByteOrder.LITTLE_ENDIAN);
    try {
        // skip WPA OUI and type parsing. isWpaOneElement() should have
        // been called for verification before we reach here.
        buf.getInt();
        // version
        if (buf.getShort() != WPA_VENDOR_OUI_VERSION) {
            // incorrect version
            return;
        }
        // start building the string
        protocol = ScanResult.PROTOCOL_WPA;
        // group data cipher suite
        groupCipher = parseWpaCipher(buf.getInt());
        // pairwise cipher suite count
        short cipherCount = buf.getShort();
        // pairwise chipher suite list
        for (int i = 0; i < cipherCount; i++) {
            pairwiseCipher.add(parseWpaCipher(buf.getInt()));
        }
        // AKM
        // AKM suite count
        short akmCount = buf.getShort();
        // AKM suite list
        for (int i = 0; i < akmCount; i++) {
            int akm = buf.getInt();
            switch(akm) {
                case WPA_AKM_EAP:
                    keyManagement.add(ScanResult.KEY_MGMT_EAP);
                    break;
                case WPA_AKM_PSK:
                    keyManagement.add(ScanResult.KEY_MGMT_PSK);
                    break;
                default:
                    // do nothing
                    break;
            }
        }
        // Default AKM
        if (keyManagement.isEmpty()) {
            keyManagement.add(ScanResult.KEY_MGMT_EAP);
        }
    } catch (BufferUnderflowException e) {
        Log.e("IE_Capabilities", "Couldn't parse type 1 WPA, buffer underflow");
    }
}
#end_block

#method_before
/**
 * Parse the Information Element and the 16-bit Capability Information field
 * to build the InformationElemmentUtil.capabilities object.
 *
 * @param ies -- Information Element array
 * @param beaconCap -- 16-bit Beacon Capability Information field
 */
public void from(InformationElement[] ies, BitSet beaconCap) {
    mProtocol = ScanResult.PROTOCOL_NONE;
    mKeyManagement = new ArrayList<Integer>();
    mGroupCipher = ScanResult.CIPHER_NONE;
    mPairwiseCipher = new ArrayList<Integer>();
    boolean rsneFound = false;
    boolean wpaFound = false;
    if (ies == null || beaconCap == null) {
        return;
    }
    mIsESS = beaconCap.get(CAP_ESS_BIT_OFFSET);
    mIsPrivacy = beaconCap.get(CAP_PRIVACY_BIT_OFFSET);
    for (InformationElement ie : ies) {
        if (ie.id == InformationElement.EID_RSN) {
            rsneFound = true;
            parseRsnElement(ie);
        }
        if (ie.id == InformationElement.EID_VSA) {
            if (isWpaOneElement(ie)) {
                wpaFound = true;
                parseWpaOneElement(ie);
            }
        }
    }
}
#method_after
/**
 * Parse the Information Element and the 16-bit Capability Information field
 * to build the InformationElemmentUtil.capabilities object.
 *
 * @param ies -- Information Element array
 * @param beaconCap -- 16-bit Beacon Capability Information field
 */
public void from(InformationElement[] ies, BitSet beaconCap) {
    protocol = ScanResult.PROTOCOL_NONE;
    keyManagement = new ArrayList<Integer>();
    groupCipher = ScanResult.CIPHER_NONE;
    pairwiseCipher = new ArrayList<Integer>();
    boolean rsneFound = false;
    boolean wpaFound = false;
    if (ies == null || beaconCap == null) {
        return;
    }
    isESS = beaconCap.get(CAP_ESS_BIT_OFFSET);
    isPrivacy = beaconCap.get(CAP_PRIVACY_BIT_OFFSET);
    for (InformationElement ie : ies) {
        if (ie.id == InformationElement.EID_RSN) {
            rsneFound = true;
            parseRsnElement(ie);
        }
        if (ie.id == InformationElement.EID_VSA) {
            if (isWpaOneElement(ie)) {
                wpaFound = true;
                parseWpaOneElement(ie);
            }
        }
    }
}
#end_block

#method_before
private String keyManagementToString(int akm) {
    switch(akm) {
        case ScanResult.AKM_NONE:
            return "None";
        case ScanResult.AKM_PSK:
            return "PSK";
        case ScanResult.AKM_EAP:
            return "EAP";
        case ScanResult.AKM_FT_EAP:
            return "FT/EAP";
        case ScanResult.AKM_FT_PSK:
            return "FT/PSK";
        case ScanResult.AKM_EAP_SHA256:
            return "EAP-SHA256";
        case ScanResult.AKM_PSK_SHA256:
            return "PSK-SHA256";
        default:
            return "?";
    }
}
#method_after
private String keyManagementToString(int akm) {
    switch(akm) {
        case ScanResult.KEY_MGMT_NONE:
            return "None";
        case ScanResult.KEY_MGMT_PSK:
            return "PSK";
        case ScanResult.KEY_MGMT_EAP:
            return "EAP";
        case ScanResult.KEY_MGMT_FT_EAP:
            return "FT/EAP";
        case ScanResult.KEY_MGMT_FT_PSK:
            return "FT/PSK";
        case ScanResult.KEY_MGMT_EAP_SHA256:
            return "EAP-SHA256";
        case ScanResult.KEY_MGMT_PSK_SHA256:
            return "PSK-SHA256";
        default:
            return "?";
    }
}
#end_block

#method_before
public String generateCapabilitiesString() {
    String capabilities = "";
    // private Beacon without an RSNE or WPA IE, hence WEP0
    boolean isWEP = (mProtocol == ScanResult.PROTOCOL_NONE) && mIsPrivacy;
    if (mProtocol != ScanResult.PROTOCOL_NONE || isWEP) {
        capabilities += "[" + (isWEP ? "WEP" : protocolToString(mProtocol));
        for (int i = 0; i < mKeyManagement.size(); i++) {
            capabilities += ((i == 0) ? "-" : "+") + keyManagementToString(mKeyManagement.get(i));
        }
        for (int i = 0; i < mPairwiseCipher.size(); i++) {
            capabilities += ((i == 0) ? "-" : "+") + cipherToString(mPairwiseCipher.get(i));
        }
        capabilities += "]";
    }
    if (mIsESS) {
        capabilities += "[ESS]";
    }
    return capabilities;
}
#method_after
public String generateCapabilitiesString() {
    String capabilities = "";
    // private Beacon without an RSNE or WPA IE, hence WEP0
    boolean isWEP = (protocol == ScanResult.PROTOCOL_NONE) && isPrivacy;
    if (protocol != ScanResult.PROTOCOL_NONE || isWEP) {
        capabilities += "[" + (isWEP ? "WEP" : protocolToString(protocol));
        for (int i = 0; i < keyManagement.size(); i++) {
            capabilities += ((i == 0) ? "-" : "+") + keyManagementToString(keyManagement.get(i));
        }
        for (int i = 0; i < pairwiseCipher.size(); i++) {
            capabilities += ((i == 0) ? "-" : "+") + cipherToString(pairwiseCipher.get(i));
        }
        capabilities += "]";
    }
    if (isESS) {
        capabilities += "[ESS]";
    }
    return capabilities;
}
#end_block

#method_before
static boolean matchOnSP(String xmlSP, CarrierIdentifier id) {
    boolean matchFound = false;
    String currentSP = id.getSpn();
    if (SPN_EMPTY_MATCH.equalsIgnoreCase(xmlSP)) {
        if (TextUtils.isEmpty(currentSP) || SPN_EMPTY_MATCH.equalsIgnoreCase(currentSP)) {
            matchFound = true;
        }
    } else if (currentSP != null) {
        Pattern spPattern = Pattern.compile(xmlSP);
        Matcher matcher = spPattern.matcher(currentSP);
        matchFound = matcher.matches();
    }
    return matchFound;
}
#method_after
static boolean matchOnSP(String xmlSP, CarrierIdentifier id) {
    boolean matchFound = false;
    String currentSP = id.getSpn();
    if (SPN_EMPTY_MATCH.equalsIgnoreCase(xmlSP)) {
        if (TextUtils.isEmpty(currentSP)) {
            matchFound = true;
        }
    } else if (currentSP != null) {
        Pattern spPattern = Pattern.compile(xmlSP);
        Matcher matcher = spPattern.matcher(currentSP);
        matchFound = matcher.matches();
    }
    return matchFound;
}
#end_block

#method_before
private void verifyLteInfo(CellInfoLte lte) {
    verifyRssiDbm(lte.getCellSignalStrength().getDbm());
    // Verify LTE physical cell id information.
    // Only physical cell id is available for LTE neighbor.
    int pci = lte.getCellIdentity().getPci();
    // Physical cell id should be within [0, 503].
    assertTrue("getPci() out of range [0, 503]", pci >= 0 && pci <= 503);
    int earfcn = lte.getCellIdentity().getEarfcn();
    // Reference 3GPP 36.101 Table 5.7.3-1
    assertTrue("getEarfcn() out of range [0,47000]", earfcn >= 0 && earfcn <= 47000);
    CellSignalStrengthLte cellSignalStrengthLte = lte.getCellSignalStrength();
    // Integer.MAX_VALUE indicates an unavailable field
    int rsrp = cellSignalStrengthLte.getRsrp();
    // RSRP is being treated as RSSI in LTE (they are similar but not quite right)
    // so reusing the constants here.
    assertTrue("getRsrp() out of range", rsrp >= MIN_RSRP && rsrp <= MAX_RSRP);
    int rsrq = cellSignalStrengthLte.getRsrq();
    assertTrue("getRsrq() out of range", rsrq >= MIN_RSRQ && rsrq <= MAX_RSRQ);
    int rssnr = cellSignalStrengthLte.getRssnr();
    assertTrue("getRssnr() out of range | Integer.MAX_VALUE", rssnr == Integer.MAX_VALUE || (rssnr >= MIN_RSSNR && rssnr <= MAX_RSSNR));
    int cqi = cellSignalStrengthLte.getCqi();
    assertTrue("getCqi() out of range | Integer.MAX_VALUE", cqi == Integer.MAX_VALUE || (cqi >= MIN_CQI && cqi <= MAX_CQI));
    int ta = cellSignalStrengthLte.getTimingAdvance();
    assertTrue("getTimingAdvance() invalid [0-1282] | Integer.MAX_VALUE", ta == Integer.MAX_VALUE || (ta >= 0 && ta <= 1282));
}
#method_after
private void verifyLteInfo(CellInfoLte lte) {
    verifyRssiDbm(lte.getCellSignalStrength().getDbm());
    // Verify LTE physical cell id information.
    // Only physical cell id is available for LTE neighbor.
    int pci = lte.getCellIdentity().getPci();
    // Physical cell id should be within [0, 503].
    assertTrue("getPci() out of range [0, 503], pci=" + pci, pci >= 0 && pci <= 503);
    int earfcn = lte.getCellIdentity().getEarfcn();
    // Reference 3GPP 36.101 Table 5.7.3-1
    assertTrue("getEarfcn() out of range [0,47000], earfcn=" + earfcn, earfcn >= 0 && earfcn <= 47000);
    CellSignalStrengthLte cellSignalStrengthLte = lte.getCellSignalStrength();
    // Integer.MAX_VALUE indicates an unavailable field
    int rsrp = cellSignalStrengthLte.getRsrp();
    // RSRP is being treated as RSSI in LTE (they are similar but not quite right)
    // so reusing the constants here.
    assertTrue("getRsrp() out of range, rsrp=" + rsrp, rsrp >= MIN_RSRP && rsrp <= MAX_RSRP);
    int rsrq = cellSignalStrengthLte.getRsrq();
    assertTrue("getRsrq() out of range | Integer.MAX_VALUE, rsrq=" + rsrq, rsrq == Integer.MAX_VALUE || (rsrq >= MIN_RSRQ && rsrq <= MAX_RSRQ));
    int rssnr = cellSignalStrengthLte.getRssnr();
    assertTrue("getRssnr() out of range | Integer.MAX_VALUE, rssnr=" + rssnr, rssnr == Integer.MAX_VALUE || (rssnr >= MIN_RSSNR && rssnr <= MAX_RSSNR));
    int cqi = cellSignalStrengthLte.getCqi();
    assertTrue("getCqi() out of range | Integer.MAX_VALUE, cqi=" + cqi, cqi == Integer.MAX_VALUE || (cqi >= MIN_CQI && cqi <= MAX_CQI));
    int ta = cellSignalStrengthLte.getTimingAdvance();
    assertTrue("getTimingAdvance() invalid [0-1282] | Integer.MAX_VALUE, ta=" + ta, ta == Integer.MAX_VALUE || (ta >= 0 && ta <= 1282));
}
#end_block

#method_before
private void verifyWcdmaInfo(CellInfoWcdma wcdma) {
    verifyRssiDbm(wcdma.getCellSignalStrength().getDbm());
    // Verify wcdma primary scrambling code information.
    // Primary scrambling code should be within [0, 511].
    int psc = wcdma.getCellIdentity().getPsc();
    assertTrue("getPsc() out of range [0, 511]", psc >= 0 && psc <= 511);
    int uarfcn = wcdma.getCellIdentity().getUarfcn();
    // Reference 3GPP 25.101 Table 5.2
    assertTrue("getUarfcn() out of range [400,11000]", uarfcn >= 400 && uarfcn <= 11000);
}
#method_after
private void verifyWcdmaInfo(CellInfoWcdma wcdma) {
    verifyRssiDbm(wcdma.getCellSignalStrength().getDbm());
    // Verify wcdma primary scrambling code information.
    // Primary scrambling code should be within [0, 511].
    int psc = wcdma.getCellIdentity().getPsc();
    assertTrue("getPsc() out of range [0, 511], psc=" + psc, psc >= 0 && psc <= 511);
    int uarfcn = wcdma.getCellIdentity().getUarfcn();
    // Reference 3GPP 25.101 Table 5.2
    assertTrue("getUarfcn() out of range [400,11000], uarfcn=" + uarfcn, uarfcn >= 400 && uarfcn <= 11000);
}
#end_block

#method_before
private void verifyGsmInfo(CellInfoGsm gsm) {
    verifyRssiDbm(gsm.getCellSignalStrength().getDbm());
    // Verify gsm local area code and cellid.
    // Local area code and cellid should be with [0, 65535].
    int lac = gsm.getCellIdentity().getLac();
    assertTrue("getLac() out of range [0, 65535]", !gsm.isRegistered() || lac >= 0 && lac <= 65535);
    int cid = gsm.getCellIdentity().getCid();
    assertTrue("getCid() out range [0, 65535]", !gsm.isRegistered() || cid >= 0 && cid <= 65535);
    int arfcn = gsm.getCellIdentity().getArfcn();
    // Reference 3GPP 45.005 Table 2-2
    assertTrue("getArfcn() out of range [0,1024]", arfcn >= 0 && arfcn <= 1024);
    int bsic = gsm.getCellIdentity().getBsic();
// TODO(kevinsoup): b/32774471
// assertTrue("getBsic() out of range [0,63]", bsic >=0 && bsic <=63);
}
#method_after
private void verifyGsmInfo(CellInfoGsm gsm) {
    verifyRssiDbm(gsm.getCellSignalStrength().getDbm());
    // Verify gsm local area code and cellid.
    // Local area code and cellid should be with [0, 65535].
    int lac = gsm.getCellIdentity().getLac();
    assertTrue("getLac() out of range [0, 65535], lac=" + lac, !gsm.isRegistered() || lac >= 0 && lac <= 65535);
    int cid = gsm.getCellIdentity().getCid();
    assertTrue("getCid() out range [0, 65535], cid=" + cid, !gsm.isRegistered() || cid >= 0 && cid <= 65535);
    int arfcn = gsm.getCellIdentity().getArfcn();
    // Reference 3GPP 45.005 Table 2-2
    assertTrue("getArfcn() out of range [0,1024], arfcn=" + arfcn, arfcn >= 0 && arfcn <= 1024);
    int bsic = gsm.getCellIdentity().getBsic();
// TODO(b/32774471) - Bsic should always be valid
// assertTrue("getBsic() out of range [0,63]", bsic >=0 && bsic <=63);
}
#end_block

#method_before
private void verifyRssiDbm(int dbm) {
    assertTrue("getCellSignalStrength().getDbm() out of range", dbm >= MIN_RSSI && dbm <= MAX_RSSI);
}
#method_after
private void verifyRssiDbm(int dbm) {
    assertTrue("getCellSignalStrength().getDbm() out of range, dbm=" + dbm, dbm >= MIN_RSSI && dbm <= MAX_RSSI);
}
#end_block

#method_before
public final boolean applyConfigurationToResourcesLocked(@NonNull Configuration config, @Nullable CompatibilityInfo compat) {
    try {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "ResourcesManager#applyConfigurationToResourcesLocked");
        if (!mResConfiguration.isOtherSeqNewer(config) && compat == null) {
            if (DEBUG || DEBUG_CONFIGURATION)
                Slog.v(TAG, "Skipping new config: curSeq=" + mResConfiguration.seq + ", newSeq=" + config.seq);
            return false;
        }
        int changes = mResConfiguration.updateFrom(config);
        // Things might have changed in display manager, so clear the cached displays.
        mDisplays.clear();
        DisplayMetrics defaultDisplayMetrics = getDisplayMetrics();
        if (compat != null && (mResCompatibilityInfo == null || !mResCompatibilityInfo.equals(compat))) {
            mResCompatibilityInfo = compat;
            changes |= ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        }
        Resources.updateSystemConfiguration(config, defaultDisplayMetrics, compat);
        ApplicationPackageManager.configurationChanged();
        // Slog.i(TAG, "Configuration changed in " + currentPackageName());
        Configuration tmpConfig = null;
        for (int i = mResourceImpls.size() - 1; i >= 0; i--) {
            ResourcesKey key = mResourceImpls.keyAt(i);
            ResourcesImpl r = findResourcesImplForKeyLocked(key);
            if (r != null) {
                if (DEBUG || DEBUG_CONFIGURATION)
                    Slog.v(TAG, "Changing resources " + r + " config to: " + config);
                int displayId = key.mDisplayId;
                boolean isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY);
                DisplayMetrics dm = defaultDisplayMetrics;
                final boolean hasOverrideConfiguration = key.hasOverrideConfiguration();
                if (!isDefaultDisplay || hasOverrideConfiguration) {
                    if (tmpConfig == null) {
                        tmpConfig = new Configuration();
                    }
                    tmpConfig.setTo(config);
                    if (!isDefaultDisplay) {
                        // Get new DisplayMetrics based on the DisplayAdjustments given
                        // to the ResourcesImpl. Udate a copy if the CompatibilityInfo
                        // changed, because the ResourcesImpl object will handle the
                        // update internally.
                        DisplayAdjustments daj = r.getDisplayAdjustments();
                        if (compat != null) {
                            daj = new DisplayAdjustments(daj);
                            daj.setCompatibilityInfo(compat);
                        }
                        dm = getDisplayMetrics(displayId, daj);
                        applyNonDefaultDisplayMetricsToConfiguration(dm, tmpConfig);
                    }
                    if (hasOverrideConfiguration) {
                        tmpConfig.updateFrom(key.mOverrideConfiguration);
                    }
                    r.updateConfiguration(tmpConfig, dm, compat);
                } else {
                    r.updateConfiguration(config, dm, compat);
                }
            // Slog.i(TAG, "Updated app resources " + v.getKey()
            // + " " + r + ": " + r.getConfiguration());
            } else {
                // Slog.i(TAG, "Removing old resources " + v.getKey());
                mResourceImpls.removeAt(i);
            }
        }
        return changes != 0;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    }
}
#method_after
public final boolean applyConfigurationToResourcesLocked(@NonNull Configuration config, @Nullable CompatibilityInfo compat) {
    try {
        Trace.traceBegin(Trace.TRACE_TAG_RESOURCES, "ResourcesManager#applyConfigurationToResourcesLocked");
        if (!mResConfiguration.isOtherSeqNewer(config) && compat == null) {
            if (DEBUG || DEBUG_CONFIGURATION)
                Slog.v(TAG, "Skipping new config: curSeq=" + mResConfiguration.seq + ", newSeq=" + config.seq);
            return false;
        }
        int changes = mResConfiguration.updateFrom(config);
        // Things might have changed in display manager, so clear the cached displays.
        mDisplays.clear();
        DisplayMetrics defaultDisplayMetrics = getDisplayMetrics();
        if (compat != null && (mResCompatibilityInfo == null || !mResCompatibilityInfo.equals(compat))) {
            mResCompatibilityInfo = compat;
            changes |= ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_SCREEN_SIZE | ActivityInfo.CONFIG_SMALLEST_SCREEN_SIZE;
        }
        Resources.updateSystemConfiguration(config, defaultDisplayMetrics, compat);
        ApplicationPackageManager.configurationChanged();
        // Slog.i(TAG, "Configuration changed in " + currentPackageName());
        Configuration tmpConfig = null;
        for (int i = mResourceImpls.size() - 1; i >= 0; i--) {
            ResourcesKey key = mResourceImpls.keyAt(i);
            WeakReference<ResourcesImpl> weakImplRef = mResourceImpls.valueAt(i);
            ResourcesImpl r = weakImplRef != null ? weakImplRef.get() : null;
            if (r != null) {
                if (DEBUG || DEBUG_CONFIGURATION)
                    Slog.v(TAG, "Changing resources " + r + " config to: " + config);
                int displayId = key.mDisplayId;
                boolean isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY);
                DisplayMetrics dm = defaultDisplayMetrics;
                final boolean hasOverrideConfiguration = key.hasOverrideConfiguration();
                if (!isDefaultDisplay || hasOverrideConfiguration) {
                    if (tmpConfig == null) {
                        tmpConfig = new Configuration();
                    }
                    tmpConfig.setTo(config);
                    if (!isDefaultDisplay) {
                        // Get new DisplayMetrics based on the DisplayAdjustments given
                        // to the ResourcesImpl. Udate a copy if the CompatibilityInfo
                        // changed, because the ResourcesImpl object will handle the
                        // update internally.
                        DisplayAdjustments daj = r.getDisplayAdjustments();
                        if (compat != null) {
                            daj = new DisplayAdjustments(daj);
                            daj.setCompatibilityInfo(compat);
                        }
                        dm = getDisplayMetrics(displayId, daj);
                        applyNonDefaultDisplayMetricsToConfiguration(dm, tmpConfig);
                    }
                    if (hasOverrideConfiguration) {
                        tmpConfig.updateFrom(key.mOverrideConfiguration);
                    }
                    r.updateConfiguration(tmpConfig, dm, compat);
                } else {
                    r.updateConfiguration(config, dm, compat);
                }
            // Slog.i(TAG, "Updated app resources " + v.getKey()
            // + " " + r + ": " + r.getConfiguration());
            } else {
                // Slog.i(TAG, "Removing old resources " + v.getKey());
                mResourceImpls.removeAt(i);
            }
        }
        return changes != 0;
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_RESOURCES);
    }
}
#end_block

#method_before
public void appendLibAssetForMainAssetPath(String assetPath, String libAsset) {
    synchronized (this) {
        // Record which ResourcesImpl need updating
        // (and what ResourcesKey they should update to).
        final ArrayMap<ResourcesImpl, ResourcesKey> updatedResourceKeys = new ArrayMap<>();
        final int implCount = mResourceImpls.size();
        for (int i = 0; i < implCount; i++) {
            final ResourcesKey key = mResourceImpls.keyAt(i);
            final ResourcesImpl impl = findResourcesImplForKeyLocked(key);
            if (impl != null && key.mResDir.equals(assetPath)) {
                if (!ArrayUtils.contains(key.mLibDirs, libAsset)) {
                    final int newLibAssetCount = 1 + (key.mLibDirs != null ? key.mLibDirs.length : 0);
                    final String[] newLibAssets = new String[newLibAssetCount];
                    if (key.mLibDirs != null) {
                        System.arraycopy(key.mLibDirs, 0, newLibAssets, 0, key.mLibDirs.length);
                    }
                    newLibAssets[newLibAssetCount - 1] = libAsset;
                    updatedResourceKeys.put(impl, new ResourcesKey(key.mResDir, key.mSplitResDirs, key.mOverlayDirs, newLibAssets, key.mDisplayId, key.mOverrideConfiguration, key.mCompatInfo));
                }
            }
        }
        // Bail early if there is no work to do.
        if (updatedResourceKeys.isEmpty()) {
            return;
        }
        // Update any references to ResourcesImpl that require reloading.
        final int resourcesCount = mResourceReferences.size();
        for (int i = 0; i < resourcesCount; i++) {
            final Resources r = mResourceReferences.get(i).get();
            if (r != null) {
                final ResourcesKey key = updatedResourceKeys.get(r.getImpl());
                if (key != null) {
                    r.setImpl(findOrCreateResourcesImplForKeyLocked(key));
                }
            }
        }
        // Update any references to ResourcesImpl that require reloading for each Activity.
        for (ActivityResources activityResources : mActivityResourceReferences.values()) {
            final int resCount = activityResources.activityResources.size();
            for (int i = 0; i < resCount; i++) {
                final Resources r = activityResources.activityResources.get(i).get();
                if (r != null) {
                    final ResourcesKey key = updatedResourceKeys.get(r.getImpl());
                    if (key != null) {
                        r.setImpl(findOrCreateResourcesImplForKeyLocked(key));
                    }
                }
            }
        }
    }
}
#method_after
public void appendLibAssetForMainAssetPath(String assetPath, String libAsset) {
    synchronized (this) {
        // Record which ResourcesImpl need updating
        // (and what ResourcesKey they should update to).
        final ArrayMap<ResourcesImpl, ResourcesKey> updatedResourceKeys = new ArrayMap<>();
        final int implCount = mResourceImpls.size();
        for (int i = 0; i < implCount; i++) {
            final ResourcesKey key = mResourceImpls.keyAt(i);
            final WeakReference<ResourcesImpl> weakImplRef = mResourceImpls.valueAt(i);
            final ResourcesImpl impl = weakImplRef != null ? weakImplRef.get() : null;
            if (impl != null && key.mResDir.equals(assetPath)) {
                if (!ArrayUtils.contains(key.mLibDirs, libAsset)) {
                    final int newLibAssetCount = 1 + (key.mLibDirs != null ? key.mLibDirs.length : 0);
                    final String[] newLibAssets = new String[newLibAssetCount];
                    if (key.mLibDirs != null) {
                        System.arraycopy(key.mLibDirs, 0, newLibAssets, 0, key.mLibDirs.length);
                    }
                    newLibAssets[newLibAssetCount - 1] = libAsset;
                    updatedResourceKeys.put(impl, new ResourcesKey(key.mResDir, key.mSplitResDirs, key.mOverlayDirs, newLibAssets, key.mDisplayId, key.mOverrideConfiguration, key.mCompatInfo));
                }
            }
        }
        // Bail early if there is no work to do.
        if (updatedResourceKeys.isEmpty()) {
            return;
        }
        // Update any references to ResourcesImpl that require reloading.
        final int resourcesCount = mResourceReferences.size();
        for (int i = 0; i < resourcesCount; i++) {
            final Resources r = mResourceReferences.get(i).get();
            if (r != null) {
                final ResourcesKey key = updatedResourceKeys.get(r.getImpl());
                if (key != null) {
                    r.setImpl(findOrCreateResourcesImplForKeyLocked(key));
                }
            }
        }
        // Update any references to ResourcesImpl that require reloading for each Activity.
        for (ActivityResources activityResources : mActivityResourceReferences.values()) {
            final int resCount = activityResources.activityResources.size();
            for (int i = 0; i < resCount; i++) {
                final Resources r = activityResources.activityResources.get(i).get();
                if (r != null) {
                    final ResourcesKey key = updatedResourceKeys.get(r.getImpl());
                    if (key != null) {
                        r.setImpl(findOrCreateResourcesImplForKeyLocked(key));
                    }
                }
            }
        }
    }
}
#end_block

#method_before
public static boolean isDeveloperOptionsEnabled(final Instrumentation instrumentation) throws UiObjectNotFoundException {
    SettingsUtil.findItem(instrumentation, "Developer options").waitForExists(5000);
    return SettingsUtil.scrollToItem(instrumentation, "Developer options");
}
#method_after
public static boolean isDeveloperOptionsEnabled(final Instrumentation instrumentation) throws UiObjectNotFoundException {
    SettingsUtil.findItem(instrumentation, "Developer options").waitForExists(TimeUnit.MILLISECONDS.convert(5L, TimeUnit.SECONDS));
    return SettingsUtil.scrollToItem(instrumentation, "Developer options");
}
#end_block

#method_before
@Test
public void parseConfigFile() throws Exception {
    String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE);
    PasspointConfiguration expectedConfig = generateConfigurationFromProfile();
    PasspointConfiguration actualConfig = ConfigBuilder.buildPasspointConfig("application/x-wifi-config", configStr.getBytes());
    assertTrue(actualConfig.equals(expectedConfig));
}
#method_after
@Test
public void parseConfigFile() throws Exception {
    String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT);
    PasspointConfiguration expectedConfig = generateConfigurationFromProfile();
    PasspointConfiguration actualConfig = ConfigBuilder.buildPasspointConfig("application/x-wifi-config", configStr.getBytes());
    assertTrue(actualConfig.equals(expectedConfig));
}
#end_block

#method_before
@Test
public void parseConfigFileWithInvalidMimeType() throws Exception {
    String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE);
    assertNull(ConfigBuilder.buildPasspointConfig("application/wifi-config", configStr.getBytes()));
}
#method_after
@Test
public void parseConfigFileWithInvalidMimeType() throws Exception {
    String configStr = loadResourceFile(PASSPOINT_INSTALLATION_FILE_WITH_CA_CERT);
    assertNull(ConfigBuilder.buildPasspointConfig("application/wifi-config", configStr.getBytes()));
}
#end_block

#method_before
private static MimePart parseMimePart(LineNumberReader in, String boundary) throws IOException {
    MimeHeader header = parseHeaders(in);
    // Expect encoding type to be base64.
    if (!TextUtils.equals(header.encodingType, ENCODING_BASE64)) {
        throw new IOException("Unexpected encoding type: " + header.encodingType);
    }
    StringBuilder text = new StringBuilder();
    boolean isLast = false;
    String partBoundary = "--" + boundary;
    String endBoundary = partBoundary + "--";
    for (; ; ) {
        String line = in.readLine();
        if (line == null) {
            throw new IOException("Unexpected EOF file in body @ " + in.getLineNumber());
        }
        // Check for boundary line.
        if (line.startsWith(partBoundary)) {
            if (line.equals(endBoundary)) {
                isLast = true;
            }
            break;
        }
        text.append(line);
    }
    MimePart part = new MimePart();
    part.type = header.contentType;
    part.data = Base64.decode(text.toString(), Base64.DEFAULT);
    part.isLast = isLast;
    return part;
}
#method_after
private static MimePart parseMimePart(LineNumberReader in, String boundary) throws IOException {
    MimeHeader header = parseHeaders(in);
    // Expect encoding type to be base64.
    if (!TextUtils.equals(header.encodingType, ENCODING_BASE64)) {
        throw new IOException("Unexpected encoding type: " + header.encodingType);
    }
    // Check for a valid content type.
    if (!TextUtils.equals(header.contentType, TYPE_PASSPOINT_PROFILE) && !TextUtils.equals(header.contentType, TYPE_CA_CERT) && !TextUtils.equals(header.contentType, TYPE_PKCS12)) {
        throw new IOException("Unexpected content type: " + header.contentType);
    }
    StringBuilder text = new StringBuilder();
    boolean isLast = false;
    String partBoundary = "--" + boundary;
    String endBoundary = partBoundary + "--";
    for (; ; ) {
        String line = in.readLine();
        if (line == null) {
            throw new IOException("Unexpected EOF file in body @ " + in.getLineNumber());
        }
        // Check for boundary line.
        if (line.startsWith(partBoundary)) {
            if (line.equals(endBoundary)) {
                isLast = true;
            }
            break;
        }
        text.append(line);
    }
    MimePart part = new MimePart();
    part.type = header.contentType;
    part.data = Base64.decode(text.toString(), Base64.DEFAULT);
    part.isLast = isLast;
    return part;
}
#end_block

#method_before
private void initialize(Locale locale) {
    this.locale = locale;
    // Android-changed: Removed use of DecimalFormatSymbolsProvider. Switched to ICU.
    // get resource bundle data - try the cache first
    boolean needCacheUpdate = false;
    Object[] data = cachedLocaleData.get(locale);
    if (data == null) {
        /* cache miss */
        locale = LocaleData.mapInvalidAndNullLocales(locale);
        LocaleData localeData = LocaleData.get(locale);
        data = new Object[3];
        String[] values = new String[11];
        values[0] = String.valueOf(localeData.decimalSeparator);
        values[1] = String.valueOf(localeData.groupingSeparator);
        values[2] = String.valueOf(localeData.patternSeparator);
        values[3] = String.valueOf(localeData.percent);
        values[4] = String.valueOf(localeData.zeroDigit);
        values[5] = "#";
        values[6] = localeData.minusSign;
        values[7] = localeData.exponentSeparator;
        values[8] = String.valueOf(localeData.perMill);
        values[9] = localeData.infinity;
        values[10] = localeData.NaN;
        data[0] = values;
        needCacheUpdate = true;
    }
    String[] numberElements = (String[]) data[0];
    decimalSeparator = numberElements[0].charAt(0);
    groupingSeparator = numberElements[1].charAt(0);
    patternSeparator = numberElements[2].charAt(0);
    percent = maybeStripMarkers(numberElements[3], '%');
    // different for Arabic,etc.
    zeroDigit = numberElements[4].charAt(0);
    digit = numberElements[5].charAt(0);
    minusSign = maybeStripMarkers(numberElements[6], '-');
    exponential = numberElements[7].charAt(0);
    // string representation new since 1.6
    exponentialSeparator = numberElements[7];
    perMill = numberElements[8].charAt(0);
    infinity = numberElements[9];
    NaN = numberElements[10];
    // ISO 3166 country code, and exceptions are expensive.
    if (!"".equals(locale.getCountry())) {
        try {
            currency = Currency.getInstance(locale);
        } catch (IllegalArgumentException e) {
        // use default values below for compatibility
        }
    }
    if (currency != null) {
        intlCurrencySymbol = currency.getCurrencyCode();
        if (data[1] != null && data[1] == intlCurrencySymbol) {
            currencySymbol = (String) data[2];
        } else {
            currencySymbol = currency.getSymbol(locale);
            data[1] = intlCurrencySymbol;
            data[2] = currencySymbol;
            needCacheUpdate = true;
        }
    } else {
        // default values
        intlCurrencySymbol = "XXX";
        try {
            currency = Currency.getInstance(intlCurrencySymbol);
        } catch (IllegalArgumentException e) {
        }
        currencySymbol = "\u00A4";
    }
    // Currently the monetary decimal separator is the same as the
    // standard decimal separator for all locales that we support.
    // If that changes, add a new entry to NumberElements.
    monetarySeparator = decimalSeparator;
    if (needCacheUpdate) {
        cachedLocaleData.putIfAbsent(locale, data);
    }
}
#method_after
private void initialize(Locale locale) {
    this.locale = locale;
    // Android-changed: Removed use of DecimalFormatSymbolsProvider. Switched to ICU.
    // get resource bundle data - try the cache first
    boolean needCacheUpdate = false;
    Object[] data = cachedLocaleData.get(locale);
    if (data == null) {
        /* cache miss */
        locale = LocaleData.mapInvalidAndNullLocales(locale);
        LocaleData localeData = LocaleData.get(locale);
        data = new Object[3];
        String[] values = new String[11];
        values[0] = String.valueOf(localeData.decimalSeparator);
        values[1] = String.valueOf(localeData.groupingSeparator);
        values[2] = String.valueOf(localeData.patternSeparator);
        values[3] = String.valueOf(localeData.percent);
        values[4] = String.valueOf(localeData.zeroDigit);
        values[5] = "#";
        values[6] = localeData.minusSign;
        values[7] = localeData.exponentSeparator;
        values[8] = String.valueOf(localeData.perMill);
        values[9] = localeData.infinity;
        values[10] = localeData.NaN;
        data[0] = values;
        needCacheUpdate = true;
    }
    String[] numberElements = (String[]) data[0];
    // Android-changed: Added maybeStripMarkers
    decimalSeparator = numberElements[0].charAt(0);
    groupingSeparator = numberElements[1].charAt(0);
    patternSeparator = numberElements[2].charAt(0);
    percent = maybeStripMarkers(numberElements[3], '%');
    // different for Arabic,etc.
    zeroDigit = numberElements[4].charAt(0);
    digit = numberElements[5].charAt(0);
    minusSign = maybeStripMarkers(numberElements[6], '-');
    exponential = numberElements[7].charAt(0);
    // string representation new since 1.6
    exponentialSeparator = numberElements[7];
    perMill = numberElements[8].charAt(0);
    infinity = numberElements[9];
    NaN = numberElements[10];
    // ISO 3166 country code, and exceptions are expensive.
    if (!"".equals(locale.getCountry())) {
        try {
            currency = Currency.getInstance(locale);
        } catch (IllegalArgumentException e) {
        // use default values below for compatibility
        }
    }
    if (currency != null) {
        intlCurrencySymbol = currency.getCurrencyCode();
        if (data[1] != null && data[1] == intlCurrencySymbol) {
            currencySymbol = (String) data[2];
        } else {
            currencySymbol = currency.getSymbol(locale);
            data[1] = intlCurrencySymbol;
            data[2] = currencySymbol;
            needCacheUpdate = true;
        }
    } else {
        // default values
        intlCurrencySymbol = "XXX";
        try {
            currency = Currency.getInstance(intlCurrencySymbol);
        } catch (IllegalArgumentException e) {
        }
        currencySymbol = "\u00A4";
    }
    // Currently the monetary decimal separator is the same as the
    // standard decimal separator for all locales that we support.
    // If that changes, add a new entry to NumberElements.
    monetarySeparator = decimalSeparator;
    if (needCacheUpdate) {
        cachedLocaleData.putIfAbsent(locale, data);
    }
}
#end_block

#method_before
private static char maybeStripMarkers(String symbol, char fallback) {
    final int length = symbol.length();
    if (length == 1) {
        return symbol.charAt(0);
    }
    if (length > 1) {
        char first = symbol.charAt(0);
        if (first == '\u200E' || first == '\u200F' || first == '\u061C') {
            return symbol.charAt(1);
        } else {
            return first;
        }
    }
    return fallback;
}
#method_after
// Android-changed: maybeStripMarkers added in b/26207216, fixed in b/32465689.
private static char maybeStripMarkers(String symbol, char fallback) {
    final int length = symbol.length();
    if (length == 1) {
        return symbol.charAt(0);
    }
    if (length > 1) {
        char first = symbol.charAt(0);
        if (first == '\u200E' || first == '\u200F' || first == '\u061C') {
            return symbol.charAt(1);
        }
    }
    return fallback;
}
#end_block

#method_before
public void setReturnValueTo(Object reference) {
    references[references.length - 1] = reference;
}
#method_after
public void setReturnValueTo(Object reference) {
    final Class<?> returnType = type.returnType();
    if (returnType.isPrimitive()) {
        throw new IllegalStateException("return type is not a reference type: " + returnType);
    }
    if (reference != null && !returnType.isInstance(reference)) {
        throw new IllegalArgumentException("reference is not type " + returnType);
    }
    references[references.length - 1] = reference;
}
#end_block

#method_before
public MethodHandle findConstructor(Class<?> refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // The queried type is (PT1,PT2,..)V
    if (type.returnType() != void.class) {
        throw new NoSuchElementException("Unable to find constructor of type: " + type);
    }
    Constructor constructor = refc.getDeclaredConstructor(type.ptypes());
    if (constructor == null) {
        throw new NoSuchMethodException("No constructor for " + constructor.getDeclaringClass() + " matching " + type);
    }
    checkAccess(refc, constructor.getDeclaringClass(), constructor.getModifiers(), constructor.getName());
    return makeMethodHandleForConstructor(constructor);
}
#method_after
public MethodHandle findConstructor(Class<?> refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // TODO: Support varargs methods. The returned method handle must be a var-args
    // collector in that case.
    // The queried |type| is (PT1,PT2,..)V
    Constructor constructor = refc.getDeclaredConstructor(type.ptypes());
    if (constructor == null) {
        throw new NoSuchMethodException("No constructor for " + constructor.getDeclaringClass() + " matching " + type);
    }
    checkAccess(refc, constructor.getDeclaringClass(), constructor.getModifiers(), constructor.getName());
    return makeMethodHandleForConstructor(constructor);
}
#end_block

#method_before
@Override
public void transform(EmulatedStackFrame emulatedStackFrame) throws Throwable {
    final Class<?> receiverType = type().rtype();
    checkInstantiable(receiverType);
    // Allocate memory for receiver.
    Object receiver = Unsafe.getUnsafe().allocateInstance(receiverType);
    // The MethodHandle type for the caller has the form of
    // {rtype=T,ptypes=A1..An}. The constructor MethodHandle is of
    // the form {rtype=void,ptypes=T,A1...An}. So the frame for
    // the constructor needs to have a slot with the receiver
    // in position 0.
    EmulatedStackFrame constructorFrame = EmulatedStackFrame.create(constructorHandle.type());
    constructorFrame.setReferenceUnchecked(0, receiver);
    emulatedStackFrame.copyRangeTo(constructorFrame, callerRange, 1, 0);
    constructorHandle.invoke(constructorFrame);
    // Set return result for caller.
    emulatedStackFrame.setReturnValueTo(receiver);
}
#method_after
@Override
public void transform(EmulatedStackFrame emulatedStackFrame) throws Throwable {
    final Class<?> receiverType = type().rtype();
    checkInstantiable(receiverType);
    // Allocate memory for receiver.
    Object receiver = Unsafe.getUnsafe().allocateInstance(receiverType);
    // The MethodHandle type for the caller has the form of
    // {rtype=T,ptypes=A1..An}. The constructor MethodHandle is of
    // the form {rtype=void,ptypes=T,A1...An}. So the frame for
    // the constructor needs to have a slot with the receiver
    // in position 0.
    EmulatedStackFrame constructorFrame = EmulatedStackFrame.create(constructorHandle.type());
    constructorFrame.setReference(0, receiver);
    emulatedStackFrame.copyRangeTo(constructorFrame, callerRange, 1, 0);
    constructorHandle.invoke(constructorFrame);
    // Set return result for caller.
    emulatedStackFrame.setReturnValueTo(receiver);
}
#end_block

#method_before
public void test_ByteBufferAsXBuffer_ByteOrder() {
    ByteBuffer byteBuffer = ByteBuffer.allocate(10);
    for (int i = 0; i < 10; i++) {
        byteBuffer.put((byte) i);
    }
    byteBuffer.rewind();
    ByteBuffer byteBufferBigEndian = byteBuffer.duplicate().order(ByteOrder.BIG_ENDIAN);
    ByteBuffer byteBufferLittleEndian = byteBuffer.duplicate().order(ByteOrder.LITTLE_ENDIAN);
    // asXBuffer.
    assertFalse(byteBufferBigEndian.asShortBuffer().get() == byteBufferLittleEndian.asShortBuffer().get());
    assertFalse(byteBufferBigEndian.asIntBuffer().get() == byteBufferLittleEndian.asIntBuffer().get());
    assertFalse(byteBufferBigEndian.asLongBuffer().get() == byteBufferLittleEndian.asLongBuffer().get());
    assertFalse(byteBufferBigEndian.asDoubleBuffer().get() == byteBufferLittleEndian.asDoubleBuffer().get());
    assertFalse(byteBufferBigEndian.asCharBuffer().get() == byteBufferLittleEndian.asCharBuffer().get());
    assertFalse(byteBufferBigEndian.asFloatBuffer().get() == byteBufferLittleEndian.asFloatBuffer().get());
    // asXBuffer().asReadOnlyBuffer()
    assertFalse(byteBufferBigEndian.asShortBuffer().asReadOnlyBuffer().get() == byteBufferLittleEndian.asShortBuffer().asReadOnlyBuffer().get());
    assertFalse(byteBufferBigEndian.asIntBuffer().asReadOnlyBuffer().get() == byteBufferLittleEndian.asIntBuffer().asReadOnlyBuffer().get());
    assertFalse(byteBufferBigEndian.asLongBuffer().asReadOnlyBuffer().get() == byteBufferLittleEndian.asLongBuffer().asReadOnlyBuffer().get());
    assertFalse(byteBufferBigEndian.asDoubleBuffer().asReadOnlyBuffer().get() == byteBufferLittleEndian.asDoubleBuffer().asReadOnlyBuffer().get());
    assertFalse(byteBufferBigEndian.asCharBuffer().asReadOnlyBuffer().get() == byteBufferLittleEndian.asCharBuffer().asReadOnlyBuffer().get());
    assertFalse(byteBufferBigEndian.asFloatBuffer().asReadOnlyBuffer().get() == byteBufferLittleEndian.asFloatBuffer().asReadOnlyBuffer().get());
    // asXBuffer().duplicate()
    assertFalse(byteBufferBigEndian.asShortBuffer().duplicate().get() == byteBufferLittleEndian.asShortBuffer().duplicate().get());
    assertFalse(byteBufferBigEndian.asIntBuffer().duplicate().get() == byteBufferLittleEndian.asIntBuffer().duplicate().get());
    assertFalse(byteBufferBigEndian.asLongBuffer().duplicate().get() == byteBufferLittleEndian.asLongBuffer().duplicate().get());
    assertFalse(byteBufferBigEndian.asDoubleBuffer().duplicate().get() == byteBufferLittleEndian.asDoubleBuffer().duplicate().get());
    assertFalse(byteBufferBigEndian.asCharBuffer().duplicate().get() == byteBufferLittleEndian.asCharBuffer().duplicate().get());
    assertFalse(byteBufferBigEndian.asFloatBuffer().duplicate().get() == byteBufferLittleEndian.asFloatBuffer().duplicate().get());
    // asXBuffer().slice()
    assertFalse(byteBufferBigEndian.asShortBuffer().slice().get() == byteBufferLittleEndian.asShortBuffer().slice().get());
    assertFalse(byteBufferBigEndian.asIntBuffer().slice().get() == byteBufferLittleEndian.asIntBuffer().slice().get());
    assertFalse(byteBufferBigEndian.asLongBuffer().slice().get() == byteBufferLittleEndian.asLongBuffer().slice().get());
    assertFalse(byteBufferBigEndian.asDoubleBuffer().slice().get() == byteBufferLittleEndian.asDoubleBuffer().slice().get());
    assertFalse(byteBufferBigEndian.asCharBuffer().slice().get() == byteBufferLittleEndian.asCharBuffer().slice().get());
    assertFalse(byteBufferBigEndian.asFloatBuffer().slice().get() == byteBufferLittleEndian.asFloatBuffer().slice().get());
}
#method_after
public void test_ByteBufferAsXBuffer_ByteOrder() {
    ByteBuffer byteBuffer = ByteBuffer.allocate(10);
    // Fill a ByteBuffer with different bytes that make it easy to tell byte ordering issues.
    for (int i = 0; i < 10; i++) {
        byteBuffer.put((byte) i);
    }
    byteBuffer.rewind();
    // Obtain a big-endian and little-endian copy of the source array.
    ByteBuffer bigEndian = byteBuffer.duplicate().order(ByteOrder.BIG_ENDIAN);
    ByteBuffer littleEndian = byteBuffer.duplicate().order(ByteOrder.LITTLE_ENDIAN);
    // Check each type longer than a byte to confirm the ordering differs.
    // asXBuffer.
    assertFalse(bigEndian.asShortBuffer().get() == littleEndian.asShortBuffer().get());
    assertFalse(bigEndian.asIntBuffer().get() == littleEndian.asIntBuffer().get());
    assertFalse(bigEndian.asLongBuffer().get() == littleEndian.asLongBuffer().get());
    assertFalse(bigEndian.asDoubleBuffer().get() == littleEndian.asDoubleBuffer().get());
    assertFalse(bigEndian.asCharBuffer().get() == littleEndian.asCharBuffer().get());
    assertFalse(bigEndian.asFloatBuffer().get() == littleEndian.asFloatBuffer().get());
    // asXBuffer().asReadOnlyBuffer()
    assertFalse(bigEndian.asShortBuffer().asReadOnlyBuffer().get() == littleEndian.asShortBuffer().asReadOnlyBuffer().get());
    assertFalse(bigEndian.asIntBuffer().asReadOnlyBuffer().get() == littleEndian.asIntBuffer().asReadOnlyBuffer().get());
    assertFalse(bigEndian.asLongBuffer().asReadOnlyBuffer().get() == littleEndian.asLongBuffer().asReadOnlyBuffer().get());
    assertFalse(bigEndian.asDoubleBuffer().asReadOnlyBuffer().get() == littleEndian.asDoubleBuffer().asReadOnlyBuffer().get());
    assertFalse(bigEndian.asCharBuffer().asReadOnlyBuffer().get() == littleEndian.asCharBuffer().asReadOnlyBuffer().get());
    assertFalse(bigEndian.asFloatBuffer().asReadOnlyBuffer().get() == littleEndian.asFloatBuffer().asReadOnlyBuffer().get());
    // asXBuffer().duplicate()
    assertFalse(bigEndian.asShortBuffer().duplicate().get() == littleEndian.asShortBuffer().duplicate().get());
    assertFalse(bigEndian.asIntBuffer().duplicate().get() == littleEndian.asIntBuffer().duplicate().get());
    assertFalse(bigEndian.asLongBuffer().duplicate().get() == littleEndian.asLongBuffer().duplicate().get());
    assertFalse(bigEndian.asDoubleBuffer().duplicate().get() == littleEndian.asDoubleBuffer().duplicate().get());
    assertFalse(bigEndian.asCharBuffer().duplicate().get() == littleEndian.asCharBuffer().duplicate().get());
    assertFalse(bigEndian.asFloatBuffer().duplicate().get() == littleEndian.asFloatBuffer().duplicate().get());
    // asXBuffer().slice()
    assertFalse(bigEndian.asShortBuffer().slice().get() == littleEndian.asShortBuffer().slice().get());
    assertFalse(bigEndian.asIntBuffer().slice().get() == littleEndian.asIntBuffer().slice().get());
    assertFalse(bigEndian.asLongBuffer().slice().get() == littleEndian.asLongBuffer().slice().get());
    assertFalse(bigEndian.asDoubleBuffer().slice().get() == littleEndian.asDoubleBuffer().slice().get());
    assertFalse(bigEndian.asCharBuffer().slice().get() == littleEndian.asCharBuffer().slice().get());
    assertFalse(bigEndian.asFloatBuffer().slice().get() == littleEndian.asFloatBuffer().slice().get());
}
#end_block

#method_before
public MethodHandle findConstructor(Class<?> refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    if (type.returnType() != void.class) {
        throw new NoSuchElementException("Unable to find constructor of type: " + type);
    }
    Constructor constructor = refc.getDeclaredConstructor(type.ptypes());
    checkAccess(refc, constructor.getDeclaringClass(), constructor.getModifiers(), constructor.getName());
    MethodType handleType = type.changeReturnType(refc);
    return new MethodHandleImpl(constructor.getArtMethod(), MethodHandle.INVOKE_DIRECT, handleType);
}
#method_after
public MethodHandle findConstructor(Class<?> refc, MethodType type) throws NoSuchMethodException, IllegalAccessException {
    // TODO: Support varargs methods. The returned method handle must be a var-args
    // collector in that case.
    // The queried |type| is (PT1,PT2,..)V
    Constructor constructor = refc.getDeclaredConstructor(type.ptypes());
    if (constructor == null) {
        throw new NoSuchMethodException("No constructor for " + constructor.getDeclaringClass() + " matching " + type);
    }
    checkAccess(refc, constructor.getDeclaringClass(), constructor.getModifiers(), constructor.getName());
    return makeMethodHandleForConstructor(constructor);
}
#end_block

#method_before
public MethodHandle unreflectConstructor(Constructor<?> c) throws IllegalAccessException {
    if (c == null) {
        throw new NullPointerException("c == null");
    }
    if (!c.isAccessible()) {
        checkAccess(c.getDeclaringClass(), c.getDeclaringClass(), c.getModifiers(), c.getName());
    }
    MethodType methodType = MethodType.methodType(c.getDeclaringClass(), c.getParameterTypes());
    return new MethodHandleImpl(c.getArtMethod(), MethodHandle.INVOKE_DIRECT, methodType);
}
#method_after
public MethodHandle unreflectConstructor(Constructor<?> c) throws IllegalAccessException {
    if (c == null) {
        throw new NullPointerException("c == null");
    }
    if (!c.isAccessible()) {
        checkAccess(c.getDeclaringClass(), c.getDeclaringClass(), c.getModifiers(), c.getName());
    }
    return makeMethodHandleForConstructor(c);
}
#end_block

#method_before
// http://b/25878034
// 
// The test makes sure that #exists doesn't use stat. To implement the same, it installs
// SECCOMP filter. The SECCOMP filter is designed to not allow stat(fstatat64/newfstatat) calls
// and whenever a thread makes the system call, android.system.ErrnoException
public void testExistsOnSystem() throws ErrnoException {
    assertEquals("SECCOMP filter is not installed.", 0, installSeccompFilter());
    try {
        android.system.Os.stat("/sdcard");
        fail("Seccomp filter didn't obstruct stat call.");
    } catch (android.system.ErrnoException expected) {
        assertEquals(OsConstants.EPERM, expected.errno);
    }
    File sh = new File("/sdcard");
    assertTrue(sh.exists());
}
#method_after
// http://b/25878034
// 
// The test makes sure that #exists doesn't use stat. To implement the same, it installs
// SECCOMP filter. The SECCOMP filter is designed to not allow stat(fstatat64/newfstatat) calls
// and whenever a thread makes the system call, android.system.ErrnoException
public void testExistsOnSystem() throws ErrnoException, IOException {
    File tmpFile = File.createTempFile("testExistsOnSystem", ".tmp");
    try {
        assertEquals("SECCOMP filter is not installed.", 0, installSeccompFilter());
        try {
            // Verify that SECCOMP filter obstructs stat.
            stat(tmpFile.getAbsolutePath());
            fail();
        } catch (ErrnoException expected) {
            assertEquals(OsConstants.EPERM, expected.errno);
        }
        assertTrue(tmpFile.exists());
    } finally {
        tmpFile.delete();
    }
}
#end_block

#method_before
public void testReaderWriter_allReturnTypes() {
    EmulatedStackFrame stackFrame = EmulatedStackFrame.create(MethodType.methodType(boolean.class));
    EmulatedStackFrame.StackFrameWriter writer = new EmulatedStackFrame.StackFrameWriter();
    writer.attach(stackFrame).asReturnValueAccessor();
    EmulatedStackFrame.StackFrameReader reader = new EmulatedStackFrame.StackFrameReader();
    reader.attach(stackFrame).asReturnValueAccessor();
    writer.putNextBoolean(true);
    assertTrue(reader.nextBoolean());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(char.class));
    writer.attach(stackFrame).asReturnValueAccessor();
    reader.attach(stackFrame).asReturnValueAccessor();
    writer.putNextChar('a');
    assertEquals('a', reader.nextChar());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(short.class));
    writer.attach(stackFrame).asReturnValueAccessor();
    reader.attach(stackFrame).asReturnValueAccessor();
    writer.putNextShort((short) 52);
    assertEquals((short) 52, reader.nextShort());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(int.class));
    writer.attach(stackFrame).asReturnValueAccessor();
    reader.attach(stackFrame).asReturnValueAccessor();
    writer.putNextInt(64);
    assertEquals(64, reader.nextInt());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(long.class));
    writer.attach(stackFrame).asReturnValueAccessor();
    reader.attach(stackFrame).asReturnValueAccessor();
    writer.putNextLong(72);
    assertEquals(72, reader.nextLong());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(float.class));
    writer.attach(stackFrame).asReturnValueAccessor();
    reader.attach(stackFrame).asReturnValueAccessor();
    writer.putNextFloat(52.0f);
    assertEquals(52.0f, reader.nextFloat());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(double.class));
    writer.attach(stackFrame).asReturnValueAccessor();
    reader.attach(stackFrame).asReturnValueAccessor();
    writer.putNextDouble(73.0);
    assertEquals(73.0, reader.nextDouble());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(String.class));
    writer.attach(stackFrame).asReturnValueAccessor();
    reader.attach(stackFrame).asReturnValueAccessor();
    writer.putNextReference("foo", String.class);
    assertEquals("foo", reader.nextReference(String.class));
}
#method_after
public void testReaderWriter_allReturnTypes() {
    EmulatedStackFrame stackFrame = EmulatedStackFrame.create(MethodType.methodType(boolean.class));
    EmulatedStackFrame.StackFrameWriter writer = new EmulatedStackFrame.StackFrameWriter();
    writer.attach(stackFrame).makeReturnValueAccessor();
    EmulatedStackFrame.StackFrameReader reader = new EmulatedStackFrame.StackFrameReader();
    reader.attach(stackFrame).makeReturnValueAccessor();
    writer.putNextBoolean(true);
    assertTrue(reader.nextBoolean());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(char.class));
    writer.attach(stackFrame).makeReturnValueAccessor();
    reader.attach(stackFrame).makeReturnValueAccessor();
    writer.putNextChar('a');
    assertEquals('a', reader.nextChar());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(short.class));
    writer.attach(stackFrame).makeReturnValueAccessor();
    reader.attach(stackFrame).makeReturnValueAccessor();
    writer.putNextShort((short) 52);
    assertEquals((short) 52, reader.nextShort());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(int.class));
    writer.attach(stackFrame).makeReturnValueAccessor();
    reader.attach(stackFrame).makeReturnValueAccessor();
    writer.putNextInt(64);
    assertEquals(64, reader.nextInt());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(long.class));
    writer.attach(stackFrame).makeReturnValueAccessor();
    reader.attach(stackFrame).makeReturnValueAccessor();
    writer.putNextLong(72);
    assertEquals(72, reader.nextLong());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(float.class));
    writer.attach(stackFrame).makeReturnValueAccessor();
    reader.attach(stackFrame).makeReturnValueAccessor();
    writer.putNextFloat(52.0f);
    assertEquals(52.0f, reader.nextFloat());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(double.class));
    writer.attach(stackFrame).makeReturnValueAccessor();
    reader.attach(stackFrame).makeReturnValueAccessor();
    writer.putNextDouble(73.0);
    assertEquals(73.0, reader.nextDouble());
    stackFrame = EmulatedStackFrame.create(MethodType.methodType(String.class));
    writer.attach(stackFrame).makeReturnValueAccessor();
    reader.attach(stackFrame).makeReturnValueAccessor();
    writer.putNextReference("foo", String.class);
    assertEquals("foo", reader.nextReference(String.class));
}
#end_block

#method_before
public void testReturnValueReaderWriter_wrongTypes() {
    EmulatedStackFrame stackFrame = EmulatedStackFrame.create(MethodType.methodType(boolean.class, String.class));
    EmulatedStackFrame.StackFrameReader reader = new EmulatedStackFrame.StackFrameReader();
    reader.attach(stackFrame);
    reader.asReturnValueReader();
    try {
        reader.nextInt();
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // Should succeeed.
    assertFalse(reader.nextBoolean());
    // The next attempt should fail.
    try {
        reader.nextBoolean();
        fail();
    } catch (IllegalArgumentException expected) {
    }
    EmulatedStackFrame.StackFrameWriter writer = new EmulatedStackFrame.StackFrameWriter();
    writer.attach(stackFrame);
    writer.asReturnValueWriter();
    try {
        writer.putNextInt(0);
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // Should succeeed.
    writer.putNextBoolean(true);
    // The next attempt should fail.
    try {
        writer.putNextBoolean(false);
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#method_after
public void testReturnValueReaderWriter_wrongTypes() {
    EmulatedStackFrame stackFrame = EmulatedStackFrame.create(MethodType.methodType(boolean.class, String.class));
    EmulatedStackFrame.StackFrameReader reader = new EmulatedStackFrame.StackFrameReader();
    reader.attach(stackFrame);
    reader.makeReturnValueAccessor();
    try {
        reader.nextInt();
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // Should succeeed.
    assertFalse(reader.nextBoolean());
    // The next attempt should fail.
    try {
        reader.nextBoolean();
        fail();
    } catch (IllegalArgumentException expected) {
    }
    EmulatedStackFrame.StackFrameWriter writer = new EmulatedStackFrame.StackFrameWriter();
    writer.attach(stackFrame);
    writer.makeReturnValueAccessor();
    try {
        writer.putNextInt(0);
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // Should succeeed.
    writer.putNextBoolean(true);
    // The next attempt should fail.
    try {
        writer.putNextBoolean(false);
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#end_block

#method_before
@Override
public void transform(EmulatedStackFrame emulatedStackFrame) throws Throwable {
    reader.attach(emulatedStackFrame);
    writer.attach(emulatedStackFrame);
    // Read the array object and the index from the stack frame.
    final Object[] array = (Object[]) reader.nextReference(arrayClass);
    final int index = reader.nextInt();
    // Write the array element back to the stack frame.
    writer.asReturnValueWriter();
    writer.putNextReference(array[index], arrayClass.getComponentType());
}
#method_after
@Override
public void transform(EmulatedStackFrame emulatedStackFrame) throws Throwable {
    reader.attach(emulatedStackFrame);
    writer.attach(emulatedStackFrame);
    // Read the array object and the index from the stack frame.
    final Object[] array = (Object[]) reader.nextReference(arrayClass);
    final int index = reader.nextInt();
    // Write the array element back to the stack frame.
    writer.makeReturnValueAccessor();
    writer.putNextReference(array[index], arrayClass.getComponentType());
}
#end_block

#method_before
@Override
public void transform(EmulatedStackFrame emulatedStackFrame) throws Throwable {
    reader.attach(emulatedStackFrame);
    writer.attach(emulatedStackFrame);
    writer.asReturnValueWriter();
    writer.putNextReference(reader.nextReference(type), type);
}
#method_after
@Override
public void transform(EmulatedStackFrame emulatedStackFrame) throws Throwable {
    reader.attach(emulatedStackFrame);
    writer.attach(emulatedStackFrame);
    writer.makeReturnValueAccessor();
    writer.putNextReference(reader.nextReference(type), type);
}
#end_block

#method_before
@Override
public void transform(EmulatedStackFrame emulatedStackFrame) throws Throwable {
    writer.attach(emulatedStackFrame);
    writer.asReturnValueWriter();
    switch(typeChar) {
        case 'L':
            {
                writer.putNextReference(asReference, type);
                break;
            }
        case 'I':
            {
                writer.putNextInt(asInt);
                break;
            }
        case 'C':
            {
                writer.putNextChar((char) asInt);
                break;
            }
        case 'S':
            {
                writer.putNextShort((short) asInt);
                break;
            }
        case 'B':
            {
                writer.putNextByte((byte) asInt);
                break;
            }
        case 'Z':
            {
                writer.putNextBoolean(asInt == 1);
                break;
            }
        case 'J':
            {
                writer.putNextLong(asLong);
                break;
            }
        case 'F':
            {
                writer.putNextFloat(asFloat);
                break;
            }
        case 'D':
            {
                writer.putNextDouble(asDouble);
                break;
            }
        default:
            throw new AssertionError("Unexpected typeChar: " + typeChar);
    }
}
#method_after
@Override
public void transform(EmulatedStackFrame emulatedStackFrame) throws Throwable {
    writer.attach(emulatedStackFrame);
    writer.makeReturnValueAccessor();
    switch(typeChar) {
        case 'L':
            {
                writer.putNextReference(asReference, type);
                break;
            }
        case 'I':
            {
                writer.putNextInt(asInt);
                break;
            }
        case 'C':
            {
                writer.putNextChar((char) asInt);
                break;
            }
        case 'S':
            {
                writer.putNextShort((short) asInt);
                break;
            }
        case 'B':
            {
                writer.putNextByte((byte) asInt);
                break;
            }
        case 'Z':
            {
                writer.putNextBoolean(asInt == 1);
                break;
            }
        case 'J':
            {
                writer.putNextLong(asLong);
                break;
            }
        case 'F':
            {
                writer.putNextFloat(asFloat);
                break;
            }
        case 'D':
            {
                writer.putNextDouble(asDouble);
                break;
            }
        default:
            throw new AssertionError("Unexpected typeChar: " + typeChar);
    }
}
#end_block

#method_before
public StackFrameAccessor attach(EmulatedStackFrame stackFrame) {
    frame = stackFrame;
    frameBuf = ByteBuffer.wrap(frame.stackFrame).order(ByteOrder.LITTLE_ENDIAN);
    numArgs = frame.type.ptypes().length;
    return this;
}
#method_after
public StackFrameAccessor attach(EmulatedStackFrame stackFrame) {
    frame = stackFrame;
    frameBuf = ByteBuffer.wrap(frame.stackFrame).order(ByteOrder.LITTLE_ENDIAN);
    numArgs = frame.type.ptypes().length;
    referencesOffset = 0;
    argumentIdx = 0;
    return this;
}
#end_block

#method_before
protected void checkType(Class<?> type) {
    if (argumentIdx >= numArgs || argumentIdx == -1) {
        throw new IllegalArgumentException("Invalid argument index: " + argumentIdx);
    }
    final Class<?> expectedType = (argumentIdx < 0) ? frame.type.rtype() : frame.type.ptypes()[argumentIdx];
    if (expectedType != type) {
        throw new IllegalArgumentException("Incorrect type: " + type + ", expected: " + expectedType);
    }
}
#method_after
protected void checkType(Class<?> type) {
    if (argumentIdx >= numArgs || argumentIdx == (RETURN_VALUE_IDX + 1)) {
        throw new IllegalArgumentException("Invalid argument index: " + argumentIdx);
    }
    final Class<?> expectedType = (argumentIdx == RETURN_VALUE_IDX) ? frame.type.rtype() : frame.type.ptypes()[argumentIdx];
    if (expectedType != type) {
        throw new IllegalArgumentException("Incorrect type: " + type + ", expected: " + expectedType);
    }
}
#end_block

#method_before
public void putNextShort(short value) {
    checkType(short.class);
    argumentIdx++;
    frameBuf.putInt((short) value);
}
#method_after
public void putNextShort(short value) {
    checkType(short.class);
    argumentIdx++;
    frameBuf.putInt((int) value);
}
#end_block

#method_before
public void testFileInputStream() throws Exception {
    File f = new File("/dev/zero");
    recorder.clear();
    FileInputStream fis = new FileInputStream(f);
    recorder.expectAndClear("onReadFromDisk");
    fis.read(new byte[4], 0, 4);
    recorder.expectAndClear("onReadFromDisk");
    fis.read();
    recorder.expectAndClear("onReadFromDisk");
    fis.skip(1);
    recorder.expectAndClear("onReadFromDisk");
    fis.close();
}
#method_after
public void testFileInputStream() throws Exception {
    // The file itself doesn't matter: it just has to exist and allow the creation of the
    // FileInputStream. The BlockGuard should have the same behavior towards a normal file and
    // system file.
    File tmpFile = File.createTempFile("inputFile", ".txt");
    try (FileOutputStream fos = new FileOutputStream(tmpFile)) {
        fos.write("01234567890".getBytes());
    }
    try {
        recorder.clear();
        FileInputStream fis = new FileInputStream(tmpFile);
        recorder.expectAndClear("onReadFromDisk");
        fis.read(new byte[4], 0, 4);
        recorder.expectAndClear("onReadFromDisk");
        fis.read();
        recorder.expectAndClear("onReadFromDisk");
        fis.skip(1);
        recorder.expectAndClear("onReadFromDisk");
        fis.close();
    } finally {
        tmpFile.delete();
    }
}
#end_block

#method_before
public Messenger getMessenger() {
    enforceAccessPermission();
    enforceChangePermission();
    return new Messenger(mClientHandler);
}
#method_after
@Override
public Messenger getMessenger() {
    enforceAccessPermission();
    enforceChangePermission();
    return new Messenger(mClientHandler);
}
#end_block

#method_before
public Messenger getP2pStateMachineMessenger() {
    enforceConnectivityInternalOrLocationHardwarePermission();
    enforceAccessPermission();
    enforceChangePermission();
    return new Messenger(mP2pStateMachine.getHandler());
}
#method_after
@Override
public Messenger getP2pStateMachineMessenger() {
    enforceConnectivityInternalOrLocationHardwarePermission();
    enforceAccessPermission();
    enforceChangePermission();
    return new Messenger(mP2pStateMachine.getHandler());
}
#end_block

#method_before
public void setMiracastMode(int mode) {
    enforceConnectivityInternalPermission();
    mP2pStateMachine.sendMessage(SET_MIRACAST_MODE, mode);
}
#method_after
@Override
public void setMiracastMode(int mode) {
    enforceConnectivityInternalPermission();
    mP2pStateMachine.sendMessage(SET_MIRACAST_MODE, mode);
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump WifiP2pService from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    mP2pStateMachine.dump(fd, pw, args);
    pw.println("mAutonomousGroup " + mAutonomousGroup);
    pw.println("mJoinExistingGroup " + mJoinExistingGroup);
    pw.println("mDiscoveryStarted " + mDiscoveryStarted);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mTemporarilyDisconnectedWifi " + mTemporarilyDisconnectedWifi);
    pw.println("mServiceDiscReqId " + mServiceDiscReqId);
    pw.println();
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump WifiP2pService from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    mP2pStateMachine.dump(fd, pw, args);
    pw.println("mAutonomousGroup " + mAutonomousGroup);
    pw.println("mJoinExistingGroup " + mJoinExistingGroup);
    pw.println("mDiscoveryStarted " + mDiscoveryStarted);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mTemporarilyDisconnectedWifi " + mTemporarilyDisconnectedWifi);
    pw.println("mServiceDiscReqId " + mServiceDiscReqId);
    pw.println();
    final IpManager ipManager = mIpManager;
    if (ipManager != null) {
        pw.println("mIpManager:");
        ipManager.dump(fd, pw, args);
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                if (DBG)
                    logd("Full connection with WifiStateMachine established");
                mWifiChannel = (AsyncChannel) message.obj;
            } else {
                loge("Full connection failure, error = " + message.arg1);
                mWifiChannel = null;
            }
            break;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            if (message.arg1 == AsyncChannel.STATUS_SEND_UNSUCCESSFUL) {
                loge("Send failed, client connection lost");
            } else {
                loge("Client connection lost with reason: " + message.arg1);
            }
            mWifiChannel = null;
            break;
        case AsyncChannel.CMD_CHANNEL_FULL_CONNECTION:
            AsyncChannel ac = new AsyncChannel();
            ac.connect(mContext, getHandler(), message.replyTo);
            break;
        case BLOCK_DISCOVERY:
            mDiscoveryBlocked = (message.arg1 == ENABLED ? true : false);
            // always reset this - we went to a state that doesn't support discovery so
            // it would have stopped regardless
            mDiscoveryPostponed = false;
            if (mDiscoveryBlocked) {
                try {
                    StateMachine m = (StateMachine) message.obj;
                    m.sendMessage(message.arg2);
                } catch (Exception e) {
                    loge("unable to send BLOCK_DISCOVERY response: " + e);
                }
            }
            break;
        case WifiP2pManager.DISCOVER_PEERS:
            replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.STOP_DISCOVERY:
            replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.DISCOVER_SERVICES:
            replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.CONNECT:
            replyToMessage(message, WifiP2pManager.CONNECT_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.CANCEL_CONNECT:
            replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.CREATE_GROUP:
            replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.REMOVE_GROUP:
            replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.ADD_LOCAL_SERVICE:
            replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.REMOVE_LOCAL_SERVICE:
            replyToMessage(message, WifiP2pManager.REMOVE_LOCAL_SERVICE_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.CLEAR_LOCAL_SERVICES:
            replyToMessage(message, WifiP2pManager.CLEAR_LOCAL_SERVICES_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.ADD_SERVICE_REQUEST:
            replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.REMOVE_SERVICE_REQUEST:
            replyToMessage(message, WifiP2pManager.REMOVE_SERVICE_REQUEST_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
            replyToMessage(message, WifiP2pManager.CLEAR_SERVICE_REQUESTS_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.SET_DEVICE_NAME:
            replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.DELETE_PERSISTENT_GROUP:
            replyToMessage(message, WifiP2pManager.DELETE_PERSISTENT_GROUP, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.SET_WFD_INFO:
            replyToMessage(message, WifiP2pManager.SET_WFD_INFO_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.REQUEST_PEERS:
            replyToMessage(message, WifiP2pManager.RESPONSE_PEERS, new WifiP2pDeviceList(mPeers));
            break;
        case WifiP2pManager.REQUEST_CONNECTION_INFO:
            replyToMessage(message, WifiP2pManager.RESPONSE_CONNECTION_INFO, new WifiP2pInfo(mWifiP2pInfo));
            break;
        case WifiP2pManager.REQUEST_GROUP_INFO:
            replyToMessage(message, WifiP2pManager.RESPONSE_GROUP_INFO, mGroup != null ? new WifiP2pGroup(mGroup) : null);
            break;
        case WifiP2pManager.REQUEST_PERSISTENT_GROUP_INFO:
            replyToMessage(message, WifiP2pManager.RESPONSE_PERSISTENT_GROUP_INFO, new WifiP2pGroupList(mGroups, null));
            break;
        case WifiP2pManager.START_WPS:
            replyToMessage(message, WifiP2pManager.START_WPS_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.GET_HANDOVER_REQUEST:
        case WifiP2pManager.GET_HANDOVER_SELECT:
            replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE, null);
            break;
        case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:
        case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:
            replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED, WifiP2pManager.BUSY);
            break;
        // Ignore
        case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.WPS_SUCCESS_EVENT:
        case WifiMonitor.WPS_FAIL_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case WifiMonitor.WPS_TIMEOUT_EVENT:
        case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
        case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
        case WifiMonitor.P2P_DEVICE_LOST_EVENT:
        case WifiMonitor.P2P_FIND_STOPPED_EVENT:
        case WifiMonitor.P2P_SERV_DISC_RESP_EVENT:
        case PEER_CONNECTION_USER_ACCEPT:
        case PEER_CONNECTION_USER_REJECT:
        case DISCONNECT_WIFI_RESPONSE:
        case DROP_WIFI_USER_ACCEPT:
        case DROP_WIFI_USER_REJECT:
        case GROUP_CREATING_TIMED_OUT:
        case DISABLE_P2P_TIMED_OUT:
        case DhcpStateMachine.CMD_PRE_DHCP_ACTION:
        case DhcpStateMachine.CMD_POST_DHCP_ACTION:
        case DhcpStateMachine.CMD_ON_QUIT:
        case WifiMonitor.P2P_PROV_DISC_FAILURE_EVENT:
        case SET_MIRACAST_MODE:
        case WifiP2pManager.START_LISTEN:
        case WifiP2pManager.STOP_LISTEN:
        case WifiP2pManager.SET_CHANNEL:
        case SET_COUNTRY_CODE:
            break;
        case WifiStateMachine.CMD_ENABLE_P2P:
            // Enable is lazy and has no response
            break;
        case WifiStateMachine.CMD_DISABLE_P2P_REQ:
            // If we end up handling in default, p2p is not enabled
            mWifiChannel.sendMessage(WifiStateMachine.CMD_DISABLE_P2P_RSP);
            break;
        /* unexpected group created, remove */
        case WifiMonitor.P2P_GROUP_STARTED_EVENT:
            mGroup = (WifiP2pGroup) message.obj;
            loge("Unexpected group creation, remove " + mGroup);
            mWifiNative.p2pGroupRemove(mGroup.getInterface());
            break;
        // failure causes supplicant issues. Ignore right now.
        case WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
            break;
        default:
            loge("Unhandled message " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                if (DBG)
                    logd("Full connection with WifiStateMachine established");
                mWifiChannel = (AsyncChannel) message.obj;
            } else {
                loge("Full connection failure, error = " + message.arg1);
                mWifiChannel = null;
            }
            break;
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            if (message.arg1 == AsyncChannel.STATUS_SEND_UNSUCCESSFUL) {
                loge("Send failed, client connection lost");
            } else {
                loge("Client connection lost with reason: " + message.arg1);
            }
            mWifiChannel = null;
            break;
        case AsyncChannel.CMD_CHANNEL_FULL_CONNECTION:
            AsyncChannel ac = new AsyncChannel();
            ac.connect(mContext, getHandler(), message.replyTo);
            break;
        case BLOCK_DISCOVERY:
            mDiscoveryBlocked = (message.arg1 == ENABLED ? true : false);
            // always reset this - we went to a state that doesn't support discovery so
            // it would have stopped regardless
            mDiscoveryPostponed = false;
            if (mDiscoveryBlocked) {
                try {
                    StateMachine m = (StateMachine) message.obj;
                    m.sendMessage(message.arg2);
                } catch (Exception e) {
                    loge("unable to send BLOCK_DISCOVERY response: " + e);
                }
            }
            break;
        case WifiP2pManager.DISCOVER_PEERS:
            replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.STOP_DISCOVERY:
            replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.DISCOVER_SERVICES:
            replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.CONNECT:
            replyToMessage(message, WifiP2pManager.CONNECT_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.CANCEL_CONNECT:
            replyToMessage(message, WifiP2pManager.CANCEL_CONNECT_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.CREATE_GROUP:
            replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.REMOVE_GROUP:
            replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.ADD_LOCAL_SERVICE:
            replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.REMOVE_LOCAL_SERVICE:
            replyToMessage(message, WifiP2pManager.REMOVE_LOCAL_SERVICE_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.CLEAR_LOCAL_SERVICES:
            replyToMessage(message, WifiP2pManager.CLEAR_LOCAL_SERVICES_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.ADD_SERVICE_REQUEST:
            replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.REMOVE_SERVICE_REQUEST:
            replyToMessage(message, WifiP2pManager.REMOVE_SERVICE_REQUEST_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
            replyToMessage(message, WifiP2pManager.CLEAR_SERVICE_REQUESTS_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.SET_DEVICE_NAME:
            replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.DELETE_PERSISTENT_GROUP:
            replyToMessage(message, WifiP2pManager.DELETE_PERSISTENT_GROUP, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.SET_WFD_INFO:
            replyToMessage(message, WifiP2pManager.SET_WFD_INFO_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.REQUEST_PEERS:
            replyToMessage(message, WifiP2pManager.RESPONSE_PEERS, new WifiP2pDeviceList(mPeers));
            break;
        case WifiP2pManager.REQUEST_CONNECTION_INFO:
            replyToMessage(message, WifiP2pManager.RESPONSE_CONNECTION_INFO, new WifiP2pInfo(mWifiP2pInfo));
            break;
        case WifiP2pManager.REQUEST_GROUP_INFO:
            replyToMessage(message, WifiP2pManager.RESPONSE_GROUP_INFO, mGroup != null ? new WifiP2pGroup(mGroup) : null);
            break;
        case WifiP2pManager.REQUEST_PERSISTENT_GROUP_INFO:
            replyToMessage(message, WifiP2pManager.RESPONSE_PERSISTENT_GROUP_INFO, new WifiP2pGroupList(mGroups, null));
            break;
        case WifiP2pManager.START_WPS:
            replyToMessage(message, WifiP2pManager.START_WPS_FAILED, WifiP2pManager.BUSY);
            break;
        case WifiP2pManager.GET_HANDOVER_REQUEST:
        case WifiP2pManager.GET_HANDOVER_SELECT:
            replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE, null);
            break;
        case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:
        case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:
            replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED, WifiP2pManager.BUSY);
            break;
        // Ignore
        case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.WPS_SUCCESS_EVENT:
        case WifiMonitor.WPS_FAIL_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case WifiMonitor.WPS_TIMEOUT_EVENT:
        case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
        case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
        case WifiMonitor.P2P_DEVICE_LOST_EVENT:
        case WifiMonitor.P2P_FIND_STOPPED_EVENT:
        case WifiMonitor.P2P_SERV_DISC_RESP_EVENT:
        case PEER_CONNECTION_USER_ACCEPT:
        case PEER_CONNECTION_USER_REJECT:
        case DISCONNECT_WIFI_RESPONSE:
        case DROP_WIFI_USER_ACCEPT:
        case DROP_WIFI_USER_REJECT:
        case GROUP_CREATING_TIMED_OUT:
        case DISABLE_P2P_TIMED_OUT:
        case IPM_PRE_DHCP_ACTION:
        case IPM_POST_DHCP_ACTION:
        case IPM_DHCP_RESULTS:
        case IPM_PROVISIONING_SUCCESS:
        case IPM_PROVISIONING_FAILURE:
        case WifiMonitor.P2P_PROV_DISC_FAILURE_EVENT:
        case SET_MIRACAST_MODE:
        case WifiP2pManager.START_LISTEN:
        case WifiP2pManager.STOP_LISTEN:
        case WifiP2pManager.SET_CHANNEL:
        case WifiStateMachine.CMD_ENABLE_P2P:
            // Enable is lazy and has no response
            break;
        case WifiStateMachine.CMD_DISABLE_P2P_REQ:
            // If we end up handling in default, p2p is not enabled
            mWifiChannel.sendMessage(WifiStateMachine.CMD_DISABLE_P2P_RSP);
            break;
        /* unexpected group created, remove */
        case WifiMonitor.P2P_GROUP_STARTED_EVENT:
            mGroup = (WifiP2pGroup) message.obj;
            loge("Unexpected group creation, remove " + mGroup);
            mWifiNative.p2pGroupRemove(mGroup.getInterface());
            break;
        // failure causes supplicant issues. Ignore right now.
        case WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
            break;
        default:
            loge("Unhandled message " + message);
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        case WifiStateMachine.CMD_ENABLE_P2P:
            try {
                mNwService.setInterfaceUp(mInterface);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            mWifiMonitor.startMonitoring();
            transitionTo(mP2pEnablingState);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        case WifiStateMachine.CMD_ENABLE_P2P:
            try {
                mNwService.setInterfaceUp(mWifiNative.getInterfaceName());
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            mWifiMonitor.startMonitoring(mWifiNative.getInterfaceName());
            transitionTo(mP2pEnablingState);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            loge("Unexpected loss of p2p socket connection");
            transitionTo(mP2pDisabledState);
            break;
        case WifiStateMachine.CMD_ENABLE_P2P:
            // Nothing to do
            break;
        case WifiStateMachine.CMD_DISABLE_P2P_REQ:
            if (mPeers.clear()) {
                sendPeersChangedBroadcast();
            }
            if (mGroups.clear())
                sendP2pPersistentGroupsChangedBroadcast();
            mWifiMonitor.stopMonitoring();
            transitionTo(mP2pDisablingState);
            break;
        case WifiP2pManager.SET_DEVICE_NAME:
            {
                WifiP2pDevice d = (WifiP2pDevice) message.obj;
                if (d != null && setAndPersistDeviceName(d.deviceName)) {
                    if (DBG)
                        logd("set device name " + d.deviceName);
                    replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_SUCCEEDED);
                } else {
                    replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_FAILED, WifiP2pManager.ERROR);
                }
                break;
            }
        case WifiP2pManager.SET_WFD_INFO:
            {
                WifiP2pWfdInfo d = (WifiP2pWfdInfo) message.obj;
                if (d != null && setWfdInfo(d)) {
                    replyToMessage(message, WifiP2pManager.SET_WFD_INFO_SUCCEEDED);
                } else {
                    replyToMessage(message, WifiP2pManager.SET_WFD_INFO_FAILED, WifiP2pManager.ERROR);
                }
                break;
            }
        case BLOCK_DISCOVERY:
            boolean blocked = (message.arg1 == ENABLED ? true : false);
            if (mDiscoveryBlocked == blocked)
                break;
            mDiscoveryBlocked = blocked;
            if (blocked && mDiscoveryStarted) {
                mWifiNative.p2pStopFind();
                mDiscoveryPostponed = true;
            }
            if (!blocked && mDiscoveryPostponed) {
                mDiscoveryPostponed = false;
                mWifiNative.p2pFind(DISCOVER_TIMEOUT_S);
            }
            if (blocked) {
                try {
                    StateMachine m = (StateMachine) message.obj;
                    m.sendMessage(message.arg2);
                } catch (Exception e) {
                    loge("unable to send BLOCK_DISCOVERY response: " + e);
                }
            }
            break;
        case WifiP2pManager.DISCOVER_PEERS:
            if (mDiscoveryBlocked) {
                replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED, WifiP2pManager.BUSY);
                break;
            }
            // do not send service discovery request while normal find operation.
            clearSupplicantServiceRequest();
            if (mWifiNative.p2pFind(DISCOVER_TIMEOUT_S)) {
                replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_SUCCEEDED);
                sendP2pDiscoveryChangedBroadcast(true);
            } else {
                replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED, WifiP2pManager.ERROR);
            }
            break;
        case WifiMonitor.P2P_FIND_STOPPED_EVENT:
            sendP2pDiscoveryChangedBroadcast(false);
            break;
        case WifiP2pManager.STOP_DISCOVERY:
            if (mWifiNative.p2pStopFind()) {
                replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED, WifiP2pManager.ERROR);
            }
            break;
        case WifiP2pManager.DISCOVER_SERVICES:
            if (mDiscoveryBlocked) {
                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED, WifiP2pManager.BUSY);
                break;
            }
            if (DBG)
                logd(getName() + " discover services");
            if (!updateSupplicantServiceRequest()) {
                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED, WifiP2pManager.NO_SERVICE_REQUESTS);
                break;
            }
            if (mWifiNative.p2pFind(DISCOVER_TIMEOUT_S)) {
                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED, WifiP2pManager.ERROR);
            }
            break;
        case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
            WifiP2pDevice device = (WifiP2pDevice) message.obj;
            if (mThisDevice.deviceAddress.equals(device.deviceAddress))
                break;
            mPeers.updateSupplicantDetails(device);
            sendPeersChangedBroadcast();
            break;
        case WifiMonitor.P2P_DEVICE_LOST_EVENT:
            device = (WifiP2pDevice) message.obj;
            // Gets current details for the one removed
            device = mPeers.remove(device.deviceAddress);
            if (device != null) {
                sendPeersChangedBroadcast();
            }
            break;
        case WifiP2pManager.ADD_LOCAL_SERVICE:
            if (DBG)
                logd(getName() + " add service");
            WifiP2pServiceInfo servInfo = (WifiP2pServiceInfo) message.obj;
            if (addLocalService(message.replyTo, servInfo)) {
                replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_FAILED);
            }
            break;
        case WifiP2pManager.REMOVE_LOCAL_SERVICE:
            if (DBG)
                logd(getName() + " remove service");
            servInfo = (WifiP2pServiceInfo) message.obj;
            removeLocalService(message.replyTo, servInfo);
            replyToMessage(message, WifiP2pManager.REMOVE_LOCAL_SERVICE_SUCCEEDED);
            break;
        case WifiP2pManager.CLEAR_LOCAL_SERVICES:
            if (DBG)
                logd(getName() + " clear service");
            clearLocalServices(message.replyTo);
            replyToMessage(message, WifiP2pManager.CLEAR_LOCAL_SERVICES_SUCCEEDED);
            break;
        case WifiP2pManager.ADD_SERVICE_REQUEST:
            if (DBG)
                logd(getName() + " add service request");
            if (!addServiceRequest(message.replyTo, (WifiP2pServiceRequest) message.obj)) {
                replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED);
                break;
            }
            replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_SUCCEEDED);
            break;
        case WifiP2pManager.REMOVE_SERVICE_REQUEST:
            if (DBG)
                logd(getName() + " remove service request");
            removeServiceRequest(message.replyTo, (WifiP2pServiceRequest) message.obj);
            replyToMessage(message, WifiP2pManager.REMOVE_SERVICE_REQUEST_SUCCEEDED);
            break;
        case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
            if (DBG)
                logd(getName() + " clear service request");
            clearServiceRequests(message.replyTo);
            replyToMessage(message, WifiP2pManager.CLEAR_SERVICE_REQUESTS_SUCCEEDED);
            break;
        case WifiMonitor.P2P_SERV_DISC_RESP_EVENT:
            if (DBG)
                logd(getName() + " receive service response");
            List<WifiP2pServiceResponse> sdRespList = (List<WifiP2pServiceResponse>) message.obj;
            for (WifiP2pServiceResponse resp : sdRespList) {
                WifiP2pDevice dev = mPeers.get(resp.getSrcDevice().deviceAddress);
                resp.setSrcDevice(dev);
                sendServiceResponse(resp);
            }
            break;
        case WifiP2pManager.DELETE_PERSISTENT_GROUP:
            if (DBG)
                logd(getName() + " delete persistent group");
            mGroups.remove(message.arg1);
            replyToMessage(message, WifiP2pManager.DELETE_PERSISTENT_GROUP_SUCCEEDED);
            break;
        case SET_MIRACAST_MODE:
            mWifiNative.setMiracastMode(message.arg1);
            break;
        case WifiP2pManager.START_LISTEN:
            if (DBG)
                logd(getName() + " start listen mode");
            mWifiNative.p2pFlush();
            if (mWifiNative.p2pExtListen(true, 500, 500)) {
                replyToMessage(message, WifiP2pManager.START_LISTEN_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
            }
            break;
        case WifiP2pManager.STOP_LISTEN:
            if (DBG)
                logd(getName() + " stop listen mode");
            if (mWifiNative.p2pExtListen(false, 0, 0)) {
                replyToMessage(message, WifiP2pManager.STOP_LISTEN_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED);
            }
            mWifiNative.p2pFlush();
            break;
        case WifiP2pManager.SET_CHANNEL:
            Bundle p2pChannels = (Bundle) message.obj;
            int lc = p2pChannels.getInt("lc", 0);
            int oc = p2pChannels.getInt("oc", 0);
            if (DBG)
                logd(getName() + " set listen and operating channel");
            if (mWifiNative.p2pSetChannel(lc, oc)) {
                replyToMessage(message, WifiP2pManager.SET_CHANNEL_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.SET_CHANNEL_FAILED);
            }
            break;
        case SET_COUNTRY_CODE:
            String countryCode = (String) message.obj;
            countryCode = countryCode.toUpperCase(Locale.ROOT);
            if (mLastSetCountryCode == null || countryCode.equals(mLastSetCountryCode) == false) {
                if (mWifiNative.setCountryCode(countryCode)) {
                    mLastSetCountryCode = countryCode;
                }
            }
            break;
        case WifiP2pManager.GET_HANDOVER_REQUEST:
            Bundle requestBundle = new Bundle();
            requestBundle.putString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE, mWifiNative.getNfcHandoverRequest());
            replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE, requestBundle);
            break;
        case WifiP2pManager.GET_HANDOVER_SELECT:
            Bundle selectBundle = new Bundle();
            selectBundle.putString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE, mWifiNative.getNfcHandoverSelect());
            replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE, selectBundle);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            loge("Unexpected loss of p2p socket connection");
            transitionTo(mP2pDisabledState);
            break;
        case WifiStateMachine.CMD_ENABLE_P2P:
            // Nothing to do
            break;
        case WifiStateMachine.CMD_DISABLE_P2P_REQ:
            if (mPeers.clear()) {
                sendPeersChangedBroadcast();
            }
            if (mGroups.clear())
                sendP2pPersistentGroupsChangedBroadcast();
            mWifiMonitor.stopMonitoring(mWifiNative.getInterfaceName());
            transitionTo(mP2pDisablingState);
            break;
        case WifiP2pManager.SET_DEVICE_NAME:
            {
                WifiP2pDevice d = (WifiP2pDevice) message.obj;
                if (d != null && setAndPersistDeviceName(d.deviceName)) {
                    if (DBG)
                        logd("set device name " + d.deviceName);
                    replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_SUCCEEDED);
                } else {
                    replyToMessage(message, WifiP2pManager.SET_DEVICE_NAME_FAILED, WifiP2pManager.ERROR);
                }
                break;
            }
        case WifiP2pManager.SET_WFD_INFO:
            {
                WifiP2pWfdInfo d = (WifiP2pWfdInfo) message.obj;
                if (d != null && setWfdInfo(d)) {
                    replyToMessage(message, WifiP2pManager.SET_WFD_INFO_SUCCEEDED);
                } else {
                    replyToMessage(message, WifiP2pManager.SET_WFD_INFO_FAILED, WifiP2pManager.ERROR);
                }
                break;
            }
        case BLOCK_DISCOVERY:
            boolean blocked = (message.arg1 == ENABLED ? true : false);
            if (mDiscoveryBlocked == blocked)
                break;
            mDiscoveryBlocked = blocked;
            if (blocked && mDiscoveryStarted) {
                mWifiNative.p2pStopFind();
                mDiscoveryPostponed = true;
            }
            if (!blocked && mDiscoveryPostponed) {
                mDiscoveryPostponed = false;
                mWifiNative.p2pFind(DISCOVER_TIMEOUT_S);
            }
            if (blocked) {
                try {
                    StateMachine m = (StateMachine) message.obj;
                    m.sendMessage(message.arg2);
                } catch (Exception e) {
                    loge("unable to send BLOCK_DISCOVERY response: " + e);
                }
            }
            break;
        case WifiP2pManager.DISCOVER_PEERS:
            if (mDiscoveryBlocked) {
                replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED, WifiP2pManager.BUSY);
                break;
            }
            // do not send service discovery request while normal find operation.
            clearSupplicantServiceRequest();
            if (mWifiNative.p2pFind(DISCOVER_TIMEOUT_S)) {
                replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_SUCCEEDED);
                sendP2pDiscoveryChangedBroadcast(true);
            } else {
                replyToMessage(message, WifiP2pManager.DISCOVER_PEERS_FAILED, WifiP2pManager.ERROR);
            }
            break;
        case WifiMonitor.P2P_FIND_STOPPED_EVENT:
            sendP2pDiscoveryChangedBroadcast(false);
            break;
        case WifiP2pManager.STOP_DISCOVERY:
            if (mWifiNative.p2pStopFind()) {
                replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED, WifiP2pManager.ERROR);
            }
            break;
        case WifiP2pManager.DISCOVER_SERVICES:
            if (mDiscoveryBlocked) {
                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED, WifiP2pManager.BUSY);
                break;
            }
            if (DBG)
                logd(getName() + " discover services");
            if (!updateSupplicantServiceRequest()) {
                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED, WifiP2pManager.NO_SERVICE_REQUESTS);
                break;
            }
            if (mWifiNative.p2pFind(DISCOVER_TIMEOUT_S)) {
                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.DISCOVER_SERVICES_FAILED, WifiP2pManager.ERROR);
            }
            break;
        case WifiMonitor.P2P_DEVICE_FOUND_EVENT:
            WifiP2pDevice device = (WifiP2pDevice) message.obj;
            if (mThisDevice.deviceAddress.equals(device.deviceAddress))
                break;
            mPeers.updateSupplicantDetails(device);
            sendPeersChangedBroadcast();
            break;
        case WifiMonitor.P2P_DEVICE_LOST_EVENT:
            device = (WifiP2pDevice) message.obj;
            // Gets current details for the one removed
            device = mPeers.remove(device.deviceAddress);
            if (device != null) {
                sendPeersChangedBroadcast();
            }
            break;
        case WifiP2pManager.ADD_LOCAL_SERVICE:
            if (DBG)
                logd(getName() + " add service");
            WifiP2pServiceInfo servInfo = (WifiP2pServiceInfo) message.obj;
            if (addLocalService(message.replyTo, servInfo)) {
                replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.ADD_LOCAL_SERVICE_FAILED);
            }
            break;
        case WifiP2pManager.REMOVE_LOCAL_SERVICE:
            if (DBG)
                logd(getName() + " remove service");
            servInfo = (WifiP2pServiceInfo) message.obj;
            removeLocalService(message.replyTo, servInfo);
            replyToMessage(message, WifiP2pManager.REMOVE_LOCAL_SERVICE_SUCCEEDED);
            break;
        case WifiP2pManager.CLEAR_LOCAL_SERVICES:
            if (DBG)
                logd(getName() + " clear service");
            clearLocalServices(message.replyTo);
            replyToMessage(message, WifiP2pManager.CLEAR_LOCAL_SERVICES_SUCCEEDED);
            break;
        case WifiP2pManager.ADD_SERVICE_REQUEST:
            if (DBG)
                logd(getName() + " add service request");
            if (!addServiceRequest(message.replyTo, (WifiP2pServiceRequest) message.obj)) {
                replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_FAILED);
                break;
            }
            replyToMessage(message, WifiP2pManager.ADD_SERVICE_REQUEST_SUCCEEDED);
            break;
        case WifiP2pManager.REMOVE_SERVICE_REQUEST:
            if (DBG)
                logd(getName() + " remove service request");
            removeServiceRequest(message.replyTo, (WifiP2pServiceRequest) message.obj);
            replyToMessage(message, WifiP2pManager.REMOVE_SERVICE_REQUEST_SUCCEEDED);
            break;
        case WifiP2pManager.CLEAR_SERVICE_REQUESTS:
            if (DBG)
                logd(getName() + " clear service request");
            clearServiceRequests(message.replyTo);
            replyToMessage(message, WifiP2pManager.CLEAR_SERVICE_REQUESTS_SUCCEEDED);
            break;
        case WifiMonitor.P2P_SERV_DISC_RESP_EVENT:
            if (DBG)
                logd(getName() + " receive service response");
            List<WifiP2pServiceResponse> sdRespList = (List<WifiP2pServiceResponse>) message.obj;
            for (WifiP2pServiceResponse resp : sdRespList) {
                WifiP2pDevice dev = mPeers.get(resp.getSrcDevice().deviceAddress);
                resp.setSrcDevice(dev);
                sendServiceResponse(resp);
            }
            break;
        case WifiP2pManager.DELETE_PERSISTENT_GROUP:
            if (DBG)
                logd(getName() + " delete persistent group");
            mGroups.remove(message.arg1);
            replyToMessage(message, WifiP2pManager.DELETE_PERSISTENT_GROUP_SUCCEEDED);
            break;
        case SET_MIRACAST_MODE:
            mWifiNative.setMiracastMode(message.arg1);
            break;
        case WifiP2pManager.START_LISTEN:
            if (DBG)
                logd(getName() + " start listen mode");
            mWifiNative.p2pFlush();
            if (mWifiNative.p2pExtListen(true, 500, 500)) {
                replyToMessage(message, WifiP2pManager.START_LISTEN_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
            }
            break;
        case WifiP2pManager.STOP_LISTEN:
            if (DBG)
                logd(getName() + " stop listen mode");
            if (mWifiNative.p2pExtListen(false, 0, 0)) {
                replyToMessage(message, WifiP2pManager.STOP_LISTEN_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED);
            }
            mWifiNative.p2pFlush();
            break;
        case WifiP2pManager.SET_CHANNEL:
            Bundle p2pChannels = (Bundle) message.obj;
            int lc = p2pChannels.getInt("lc", 0);
            int oc = p2pChannels.getInt("oc", 0);
            if (DBG)
                logd(getName() + " set listen and operating channel");
            if (mWifiNative.p2pSetChannel(lc, oc)) {
                replyToMessage(message, WifiP2pManager.SET_CHANNEL_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.SET_CHANNEL_FAILED);
            }
            break;
        case WifiP2pManager.GET_HANDOVER_REQUEST:
            Bundle requestBundle = new Bundle();
            requestBundle.putString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE, mWifiNative.getNfcHandoverRequest());
            replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE, requestBundle);
            break;
        case WifiP2pManager.GET_HANDOVER_SELECT:
            Bundle selectBundle = new Bundle();
            selectBundle.putString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE, mWifiNative.getNfcHandoverSelect());
            replyToMessage(message, WifiP2pManager.RESPONSE_GET_HANDOVER_MESSAGE, selectBundle);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void exit() {
    sendP2pDiscoveryChangedBroadcast(false);
    sendP2pStateChangedBroadcast(false);
    mNetworkInfo.setIsAvailable(false);
    mLastSetCountryCode = null;
}
#method_after
@Override
public void exit() {
    sendP2pDiscoveryChangedBroadcast(false);
    sendP2pStateChangedBroadcast(false);
    mNetworkInfo.setIsAvailable(false);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        case WifiP2pManager.CONNECT:
            if (DBG)
                logd(getName() + " sending connect");
            WifiP2pConfig config = (WifiP2pConfig) message.obj;
            if (isConfigInvalid(config)) {
                loge("Dropping connect requeset " + config);
                replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
                break;
            }
            mAutonomousGroup = false;
            mWifiNative.p2pStopFind();
            if (reinvokePersistentGroup(config)) {
                transitionTo(mGroupNegotiationState);
            } else {
                transitionTo(mProvisionDiscoveryState);
            }
            mSavedPeerConfig = config;
            mPeers.updateStatus(mSavedPeerConfig.deviceAddress, WifiP2pDevice.INVITED);
            sendPeersChangedBroadcast();
            replyToMessage(message, WifiP2pManager.CONNECT_SUCCEEDED);
            break;
        case WifiP2pManager.STOP_DISCOVERY:
            if (mWifiNative.p2pStopFind()) {
                // When discovery stops in inactive state, flush to clear
                // state peer data
                mWifiNative.p2pFlush();
                mServiceDiscReqId = null;
                replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED, WifiP2pManager.ERROR);
            }
            break;
        case WifiMonitor.P2P_GO_NEGOTIATION_REQUEST_EVENT:
            config = (WifiP2pConfig) message.obj;
            if (isConfigInvalid(config)) {
                loge("Dropping GO neg request " + config);
                break;
            }
            mSavedPeerConfig = config;
            mAutonomousGroup = false;
            mJoinExistingGroup = false;
            transitionTo(mUserAuthorizingNegotiationRequestState);
            break;
        case WifiMonitor.P2P_INVITATION_RECEIVED_EVENT:
            WifiP2pGroup group = (WifiP2pGroup) message.obj;
            WifiP2pDevice owner = group.getOwner();
            if (owner == null) {
                loge("Ignored invitation from null owner");
                break;
            }
            config = new WifiP2pConfig();
            config.deviceAddress = group.getOwner().deviceAddress;
            if (isConfigInvalid(config)) {
                loge("Dropping invitation request " + config);
                break;
            }
            mSavedPeerConfig = config;
            // wps method. Default is to use PBC.
            if ((owner = mPeers.get(owner.deviceAddress)) != null) {
                if (owner.wpsPbcSupported()) {
                    mSavedPeerConfig.wps.setup = WpsInfo.PBC;
                } else if (owner.wpsKeypadSupported()) {
                    mSavedPeerConfig.wps.setup = WpsInfo.KEYPAD;
                } else if (owner.wpsDisplaySupported()) {
                    mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
                }
            }
            mAutonomousGroup = false;
            mJoinExistingGroup = true;
            transitionTo(mUserAuthorizingInviteRequestState);
            break;
        case WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
        case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
        case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
            // group negotiation comes through causes issues
            break;
        case WifiP2pManager.CREATE_GROUP:
            mAutonomousGroup = true;
            int netId = message.arg1;
            boolean ret = false;
            if (netId == WifiP2pGroup.PERSISTENT_NET_ID) {
                // check if the go persistent group is present.
                netId = mGroups.getNetworkId(mThisDevice.deviceAddress);
                if (netId != -1) {
                    ret = mWifiNative.p2pGroupAdd(netId);
                } else {
                    ret = mWifiNative.p2pGroupAdd(true);
                }
            } else {
                ret = mWifiNative.p2pGroupAdd(false);
            }
            if (ret) {
                replyToMessage(message, WifiP2pManager.CREATE_GROUP_SUCCEEDED);
                transitionTo(mGroupNegotiationState);
            } else {
                replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED, WifiP2pManager.ERROR);
            // remain at this state.
            }
            break;
        case WifiMonitor.P2P_GROUP_STARTED_EVENT:
            mGroup = (WifiP2pGroup) message.obj;
            if (DBG)
                logd(getName() + " group started");
            // We hit this scenario when a persistent group is reinvoked
            if (mGroup.getNetworkId() == WifiP2pGroup.PERSISTENT_NET_ID) {
                mAutonomousGroup = false;
                deferMessage(message);
                transitionTo(mGroupNegotiationState);
            } else {
                loge("Unexpected group creation, remove " + mGroup);
                mWifiNative.p2pGroupRemove(mGroup.getInterface());
            }
            break;
        case WifiP2pManager.START_LISTEN:
            if (DBG)
                logd(getName() + " start listen mode");
            mWifiNative.p2pFlush();
            if (mWifiNative.p2pExtListen(true, 500, 500)) {
                replyToMessage(message, WifiP2pManager.START_LISTEN_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
            }
            break;
        case WifiP2pManager.STOP_LISTEN:
            if (DBG)
                logd(getName() + " stop listen mode");
            if (mWifiNative.p2pExtListen(false, 0, 0)) {
                replyToMessage(message, WifiP2pManager.STOP_LISTEN_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED);
            }
            mWifiNative.p2pFlush();
            break;
        case WifiP2pManager.SET_CHANNEL:
            Bundle p2pChannels = (Bundle) message.obj;
            int lc = p2pChannels.getInt("lc", 0);
            int oc = p2pChannels.getInt("oc", 0);
            if (DBG)
                logd(getName() + " set listen and operating channel");
            if (mWifiNative.p2pSetChannel(lc, oc)) {
                replyToMessage(message, WifiP2pManager.SET_CHANNEL_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.SET_CHANNEL_FAILED);
            }
            break;
        case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:
            String handoverSelect = null;
            if (message.obj != null) {
                handoverSelect = ((Bundle) message.obj).getString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE);
            }
            if (handoverSelect != null && mWifiNative.initiatorReportNfcHandover(handoverSelect)) {
                replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_SUCCEEDED);
                transitionTo(mGroupCreatingState);
            } else {
                replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED);
            }
            break;
        case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:
            String handoverRequest = null;
            if (message.obj != null) {
                handoverRequest = ((Bundle) message.obj).getString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE);
            }
            if (handoverRequest != null && mWifiNative.responderReportNfcHandover(handoverRequest)) {
                replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_SUCCEEDED);
                transitionTo(mGroupCreatingState);
            } else {
                replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        case WifiP2pManager.CONNECT:
            if (DBG)
                logd(getName() + " sending connect");
            WifiP2pConfig config = (WifiP2pConfig) message.obj;
            if (isConfigInvalid(config)) {
                loge("Dropping connect requeset " + config);
                replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
                break;
            }
            mAutonomousGroup = false;
            mWifiNative.p2pStopFind();
            if (reinvokePersistentGroup(config)) {
                transitionTo(mGroupNegotiationState);
            } else {
                transitionTo(mProvisionDiscoveryState);
            }
            mSavedPeerConfig = config;
            mPeers.updateStatus(mSavedPeerConfig.deviceAddress, WifiP2pDevice.INVITED);
            sendPeersChangedBroadcast();
            replyToMessage(message, WifiP2pManager.CONNECT_SUCCEEDED);
            break;
        case WifiP2pManager.STOP_DISCOVERY:
            if (mWifiNative.p2pStopFind()) {
                // When discovery stops in inactive state, flush to clear
                // state peer data
                mWifiNative.p2pFlush();
                mServiceDiscReqId = null;
                replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.STOP_DISCOVERY_FAILED, WifiP2pManager.ERROR);
            }
            break;
        case WifiMonitor.P2P_GO_NEGOTIATION_REQUEST_EVENT:
            config = (WifiP2pConfig) message.obj;
            if (isConfigInvalid(config)) {
                loge("Dropping GO neg request " + config);
                break;
            }
            mSavedPeerConfig = config;
            mAutonomousGroup = false;
            mJoinExistingGroup = false;
            transitionTo(mUserAuthorizingNegotiationRequestState);
            break;
        case WifiMonitor.P2P_INVITATION_RECEIVED_EVENT:
            WifiP2pGroup group = (WifiP2pGroup) message.obj;
            WifiP2pDevice owner = group.getOwner();
            if (owner == null) {
                int id = group.getNetworkId();
                if (id < 0) {
                    loge("Ignored invitation from null owner");
                    break;
                }
                String addr = mGroups.getOwnerAddr(id);
                if (addr != null) {
                    group.setOwner(new WifiP2pDevice(addr));
                    owner = group.getOwner();
                } else {
                    loge("Ignored invitation from null owner");
                    break;
                }
            }
            config = new WifiP2pConfig();
            config.deviceAddress = group.getOwner().deviceAddress;
            if (isConfigInvalid(config)) {
                loge("Dropping invitation request " + config);
                break;
            }
            mSavedPeerConfig = config;
            // wps method. Default is to use PBC.
            if ((owner = mPeers.get(owner.deviceAddress)) != null) {
                if (owner.wpsPbcSupported()) {
                    mSavedPeerConfig.wps.setup = WpsInfo.PBC;
                } else if (owner.wpsKeypadSupported()) {
                    mSavedPeerConfig.wps.setup = WpsInfo.KEYPAD;
                } else if (owner.wpsDisplaySupported()) {
                    mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
                }
            }
            mAutonomousGroup = false;
            mJoinExistingGroup = true;
            transitionTo(mUserAuthorizingInviteRequestState);
            break;
        case WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
        case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
        case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
            // group negotiation comes through causes issues
            break;
        case WifiP2pManager.CREATE_GROUP:
            mAutonomousGroup = true;
            int netId = message.arg1;
            boolean ret = false;
            if (netId == WifiP2pGroup.PERSISTENT_NET_ID) {
                // check if the go persistent group is present.
                netId = mGroups.getNetworkId(mThisDevice.deviceAddress);
                if (netId != -1) {
                    ret = mWifiNative.p2pGroupAdd(netId);
                } else {
                    ret = mWifiNative.p2pGroupAdd(true);
                }
            } else {
                ret = mWifiNative.p2pGroupAdd(false);
            }
            if (ret) {
                replyToMessage(message, WifiP2pManager.CREATE_GROUP_SUCCEEDED);
                transitionTo(mGroupNegotiationState);
            } else {
                replyToMessage(message, WifiP2pManager.CREATE_GROUP_FAILED, WifiP2pManager.ERROR);
            // remain at this state.
            }
            break;
        case WifiMonitor.P2P_GROUP_STARTED_EVENT:
            mGroup = (WifiP2pGroup) message.obj;
            if (DBG)
                logd(getName() + " group started");
            // We hit this scenario when a persistent group is reinvoked
            if (mGroup.getNetworkId() == WifiP2pGroup.PERSISTENT_NET_ID) {
                mAutonomousGroup = false;
                deferMessage(message);
                transitionTo(mGroupNegotiationState);
            } else {
                loge("Unexpected group creation, remove " + mGroup);
                mWifiNative.p2pGroupRemove(mGroup.getInterface());
            }
            break;
        case WifiP2pManager.START_LISTEN:
            if (DBG)
                logd(getName() + " start listen mode");
            mWifiNative.p2pFlush();
            if (mWifiNative.p2pExtListen(true, 500, 500)) {
                replyToMessage(message, WifiP2pManager.START_LISTEN_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.START_LISTEN_FAILED);
            }
            break;
        case WifiP2pManager.STOP_LISTEN:
            if (DBG)
                logd(getName() + " stop listen mode");
            if (mWifiNative.p2pExtListen(false, 0, 0)) {
                replyToMessage(message, WifiP2pManager.STOP_LISTEN_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.STOP_LISTEN_FAILED);
            }
            mWifiNative.p2pFlush();
            break;
        case WifiP2pManager.SET_CHANNEL:
            Bundle p2pChannels = (Bundle) message.obj;
            int lc = p2pChannels.getInt("lc", 0);
            int oc = p2pChannels.getInt("oc", 0);
            if (DBG)
                logd(getName() + " set listen and operating channel");
            if (mWifiNative.p2pSetChannel(lc, oc)) {
                replyToMessage(message, WifiP2pManager.SET_CHANNEL_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.SET_CHANNEL_FAILED);
            }
            break;
        case WifiP2pManager.INITIATOR_REPORT_NFC_HANDOVER:
            String handoverSelect = null;
            if (message.obj != null) {
                handoverSelect = ((Bundle) message.obj).getString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE);
            }
            if (handoverSelect != null && mWifiNative.initiatorReportNfcHandover(handoverSelect)) {
                replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_SUCCEEDED);
                transitionTo(mGroupCreatingState);
            } else {
                replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED);
            }
            break;
        case WifiP2pManager.RESPONDER_REPORT_NFC_HANDOVER:
            String handoverRequest = null;
            if (message.obj != null) {
                handoverRequest = ((Bundle) message.obj).getString(WifiP2pManager.EXTRA_HANDOVER_MESSAGE);
            }
            if (handoverRequest != null && mWifiNative.responderReportNfcHandover(handoverRequest)) {
                replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_SUCCEEDED);
                transitionTo(mGroupCreatingState);
            } else {
                replyToMessage(message, WifiP2pManager.REPORT_NFC_HANDOVER_FAILED);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        // afterwards
        case WifiMonitor.P2P_GO_NEGOTIATION_SUCCESS_EVENT:
        case WifiMonitor.P2P_GROUP_FORMATION_SUCCESS_EVENT:
            if (DBG)
                logd(getName() + " go success");
            break;
        case WifiMonitor.P2P_GROUP_STARTED_EVENT:
            mGroup = (WifiP2pGroup) message.obj;
            if (DBG)
                logd(getName() + " group started");
            if (mGroup.getNetworkId() == WifiP2pGroup.PERSISTENT_NET_ID) {
                /*
                         * update cache information and set network id to mGroup.
                         */
                updatePersistentNetworks(NO_RELOAD);
                String devAddr = mGroup.getOwner().deviceAddress;
                mGroup.setNetworkId(mGroups.getNetworkId(devAddr, mGroup.getNetworkName()));
            }
            if (mGroup.isGroupOwner()) {
                // failure during 4-way Handshake.
                if (!mAutonomousGroup) {
                    mWifiNative.setP2pGroupIdle(mGroup.getInterface(), GROUP_IDLE_TIME_S);
                }
                startDhcpServer(mGroup.getInterface());
            } else {
                mWifiNative.setP2pGroupIdle(mGroup.getInterface(), GROUP_IDLE_TIME_S);
                mDhcpStateMachine = DhcpStateMachine.makeDhcpStateMachine(mContext, P2pStateMachine.this, mGroup.getInterface());
                // TODO: We should use DHCP state machine PRE message like WifiStateMachine
                mWifiNative.setP2pPowerSave(mGroup.getInterface(), false);
                mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_START_DHCP);
                WifiP2pDevice groupOwner = mGroup.getOwner();
                WifiP2pDevice peer = mPeers.get(groupOwner.deviceAddress);
                if (peer != null) {
                    // update group owner details with peer details found at discovery
                    groupOwner.updateSupplicantDetails(peer);
                    mPeers.updateStatus(groupOwner.deviceAddress, WifiP2pDevice.CONNECTED);
                    sendPeersChangedBroadcast();
                } else {
                    // A supplicant bug can lead to reporting an invalid
                    // group owner address (all zeroes) at times. Avoid a
                    // crash, but continue group creation since it is not
                    // essential.
                    logw("Unknown group owner " + groupOwner);
                }
            }
            transitionTo(mGroupCreatedState);
            break;
        case WifiMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT:
            P2pStatus status = (P2pStatus) message.obj;
            if (status == P2pStatus.NO_COMMON_CHANNEL) {
                transitionTo(mFrequencyConflictState);
                break;
            }
        /* continue with group removal handling */
        case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
            if (DBG)
                logd(getName() + " go failure");
            handleGroupCreationFailure();
            transitionTo(mInactiveState);
            break;
        // failure causes supplicant issues. Ignore right now.
        case WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
            status = (P2pStatus) message.obj;
            if (status == P2pStatus.NO_COMMON_CHANNEL) {
                transitionTo(mFrequencyConflictState);
                break;
            }
            break;
        case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
            status = (P2pStatus) message.obj;
            if (status == P2pStatus.SUCCESS) {
                // wait P2P_GROUP_STARTED_EVENT.
                break;
            }
            loge("Invitation result " + status);
            if (status == P2pStatus.UNKNOWN_P2P_GROUP) {
                // target device has already removed the credential.
                // So, remove this credential accordingly.
                int netId = mSavedPeerConfig.netId;
                if (netId >= 0) {
                    if (DBG)
                        logd("Remove unknown client from the list");
                    removeClientFromList(netId, mSavedPeerConfig.deviceAddress, true);
                }
                // Reinvocation has failed, try group negotiation
                mSavedPeerConfig.netId = WifiP2pGroup.PERSISTENT_NET_ID;
                p2pConnectWithPinDisplay(mSavedPeerConfig);
            } else if (status == P2pStatus.INFORMATION_IS_CURRENTLY_UNAVAILABLE) {
                // Devices setting persistent_reconnect to 0 in wpa_supplicant
                // always defer the invocation request and return
                // "information is currently unable" error.
                // So, try another way to connect for interoperability.
                mSavedPeerConfig.netId = WifiP2pGroup.PERSISTENT_NET_ID;
                p2pConnectWithPinDisplay(mSavedPeerConfig);
            } else if (status == P2pStatus.NO_COMMON_CHANNEL) {
                transitionTo(mFrequencyConflictState);
            } else {
                handleGroupCreationFailure();
                transitionTo(mInactiveState);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        // afterwards
        case WifiMonitor.P2P_GO_NEGOTIATION_SUCCESS_EVENT:
        case WifiMonitor.P2P_GROUP_FORMATION_SUCCESS_EVENT:
            if (DBG)
                logd(getName() + " go success");
            break;
        case WifiMonitor.P2P_GROUP_STARTED_EVENT:
            mGroup = (WifiP2pGroup) message.obj;
            if (DBG)
                logd(getName() + " group started");
            if (mGroup.getNetworkId() == WifiP2pGroup.PERSISTENT_NET_ID) {
                /*
                         * update cache information and set network id to mGroup.
                         */
                updatePersistentNetworks(NO_RELOAD);
                String devAddr = mGroup.getOwner().deviceAddress;
                mGroup.setNetworkId(mGroups.getNetworkId(devAddr, mGroup.getNetworkName()));
            }
            if (mGroup.isGroupOwner()) {
                // failure during 4-way Handshake.
                if (!mAutonomousGroup) {
                    mWifiNative.setP2pGroupIdle(mGroup.getInterface(), GROUP_IDLE_TIME_S);
                }
                startDhcpServer(mGroup.getInterface());
            } else {
                mWifiNative.setP2pGroupIdle(mGroup.getInterface(), GROUP_IDLE_TIME_S);
                startIpManager(mGroup.getInterface());
                WifiP2pDevice groupOwner = mGroup.getOwner();
                WifiP2pDevice peer = mPeers.get(groupOwner.deviceAddress);
                if (peer != null) {
                    // update group owner details with peer details found at discovery
                    groupOwner.updateSupplicantDetails(peer);
                    mPeers.updateStatus(groupOwner.deviceAddress, WifiP2pDevice.CONNECTED);
                    sendPeersChangedBroadcast();
                } else {
                    // A supplicant bug can lead to reporting an invalid
                    // group owner address (all zeroes) at times. Avoid a
                    // crash, but continue group creation since it is not
                    // essential.
                    logw("Unknown group owner " + groupOwner);
                }
            }
            transitionTo(mGroupCreatedState);
            break;
        case WifiMonitor.P2P_GO_NEGOTIATION_FAILURE_EVENT:
            P2pStatus status = (P2pStatus) message.obj;
            if (status == P2pStatus.NO_COMMON_CHANNEL) {
                transitionTo(mFrequencyConflictState);
                break;
            }
        /* continue with group removal handling */
        case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
            if (DBG)
                logd(getName() + " go failure");
            handleGroupCreationFailure();
            transitionTo(mInactiveState);
            break;
        // failure causes supplicant issues. Ignore right now.
        case WifiMonitor.P2P_GROUP_FORMATION_FAILURE_EVENT:
            status = (P2pStatus) message.obj;
            if (status == P2pStatus.NO_COMMON_CHANNEL) {
                transitionTo(mFrequencyConflictState);
                break;
            }
            break;
        case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
            status = (P2pStatus) message.obj;
            if (status == P2pStatus.SUCCESS) {
                // wait P2P_GROUP_STARTED_EVENT.
                break;
            }
            loge("Invitation result " + status);
            if (status == P2pStatus.UNKNOWN_P2P_GROUP) {
                // target device has already removed the credential.
                // So, remove this credential accordingly.
                int netId = mSavedPeerConfig.netId;
                if (netId >= 0) {
                    if (DBG)
                        logd("Remove unknown client from the list");
                    removeClientFromList(netId, mSavedPeerConfig.deviceAddress, true);
                }
                // Reinvocation has failed, try group negotiation
                mSavedPeerConfig.netId = WifiP2pGroup.PERSISTENT_NET_ID;
                p2pConnectWithPinDisplay(mSavedPeerConfig);
            } else if (status == P2pStatus.INFORMATION_IS_CURRENTLY_UNAVAILABLE) {
                // Devices setting persistent_reconnect to 0 in wpa_supplicant
                // always defer the invocation request and return
                // "information is currently unable" error.
                // So, try another way to connect for interoperability.
                mSavedPeerConfig.netId = WifiP2pGroup.PERSISTENT_NET_ID;
                p2pConnectWithPinDisplay(mSavedPeerConfig);
            } else if (status == P2pStatus.NO_COMMON_CHANNEL) {
                transitionTo(mFrequencyConflictState);
            } else {
                handleGroupCreationFailure();
                transitionTo(mInactiveState);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
private void notifyFrequencyConflict() {
    logd("Notify frequency conflict");
    Resources r = Resources.getSystem();
    AlertDialog dialog = new AlertDialog.Builder(mContext).setMessage(r.getString(R.string.wifi_p2p_frequency_conflict_message, getDeviceName(mSavedPeerConfig.deviceAddress))).setPositiveButton(r.getString(R.string.dlg_ok), new OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            sendMessage(DROP_WIFI_USER_ACCEPT);
        }
    }).setNegativeButton(r.getString(R.string.decline), new OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            sendMessage(DROP_WIFI_USER_REJECT);
        }
    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

        @Override
        public void onCancel(DialogInterface arg0) {
            sendMessage(DROP_WIFI_USER_REJECT);
        }
    }).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
    mFrequencyConflictDialog = dialog;
}
#method_after
private void notifyFrequencyConflict() {
    logd("Notify frequency conflict");
    Resources r = Resources.getSystem();
    AlertDialog dialog = new AlertDialog.Builder(mContext).setMessage(r.getString(R.string.wifi_p2p_frequency_conflict_message, getDeviceName(mSavedPeerConfig.deviceAddress))).setPositiveButton(r.getString(R.string.dlg_ok), new OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            sendMessage(DROP_WIFI_USER_ACCEPT);
        }
    }).setNegativeButton(r.getString(R.string.decline), new OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            sendMessage(DROP_WIFI_USER_REJECT);
        }
    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

        @Override
        public void onCancel(DialogInterface arg0) {
            sendMessage(DROP_WIFI_USER_REJECT);
        }
    }).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
    attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
    dialog.getWindow().setAttributes(attrs);
    dialog.show();
    mFrequencyConflictDialog = dialog;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        case WifiMonitor.AP_STA_CONNECTED_EVENT:
            WifiP2pDevice device = (WifiP2pDevice) message.obj;
            String deviceAddress = device.deviceAddress;
            // Clear timeout that was set when group was started.
            mWifiNative.setP2pGroupIdle(mGroup.getInterface(), 0);
            if (deviceAddress != null) {
                if (mPeers.get(deviceAddress) != null) {
                    mGroup.addClient(mPeers.get(deviceAddress));
                } else {
                    mGroup.addClient(deviceAddress);
                }
                mPeers.updateStatus(deviceAddress, WifiP2pDevice.CONNECTED);
                if (DBG)
                    logd(getName() + " ap sta connected");
                sendPeersChangedBroadcast();
            } else {
                loge("Connect on null device address, ignore");
            }
            sendP2pConnectionChangedBroadcast();
            break;
        case WifiMonitor.AP_STA_DISCONNECTED_EVENT:
            device = (WifiP2pDevice) message.obj;
            deviceAddress = device.deviceAddress;
            if (deviceAddress != null) {
                mPeers.updateStatus(deviceAddress, WifiP2pDevice.AVAILABLE);
                if (mGroup.removeClient(deviceAddress)) {
                    if (DBG)
                        logd("Removed client " + deviceAddress);
                    if (!mAutonomousGroup && mGroup.isClientListEmpty()) {
                        logd("Client list empty, remove non-persistent p2p group");
                        mWifiNative.p2pGroupRemove(mGroup.getInterface());
                    // We end up sending connection changed broadcast
                    // when this happens at exit()
                    } else {
                        // Notify when a client disconnects from group
                        sendP2pConnectionChangedBroadcast();
                    }
                } else {
                    if (DBG)
                        logd("Failed to remove client " + deviceAddress);
                    for (WifiP2pDevice c : mGroup.getClientList()) {
                        if (DBG)
                            logd("client " + c.deviceAddress);
                    }
                }
                sendPeersChangedBroadcast();
                if (DBG)
                    logd(getName() + " ap sta disconnected");
            } else {
                loge("Disconnect on unknown device: " + device);
            }
            break;
        case DhcpStateMachine.CMD_POST_DHCP_ACTION:
            DhcpResults dhcpResults = (DhcpResults) message.obj;
            if (message.arg1 == DhcpStateMachine.DHCP_SUCCESS && dhcpResults != null) {
                if (DBG)
                    logd("DhcpResults: " + dhcpResults);
                setWifiP2pInfoOnGroupFormation(dhcpResults.serverAddress);
                sendP2pConnectionChangedBroadcast();
                // Turn on power save on client
                mWifiNative.setP2pPowerSave(mGroup.getInterface(), true);
                try {
                    String iface = mGroup.getInterface();
                    mNwService.addInterfaceToLocalNetwork(iface, dhcpResults.getRoutes(iface));
                } catch (RemoteException e) {
                    loge("Failed to add iface to local network " + e);
                }
            } else {
                loge("DHCP failed");
                mWifiNative.p2pGroupRemove(mGroup.getInterface());
            }
            break;
        case WifiP2pManager.REMOVE_GROUP:
            if (DBG)
                logd(getName() + " remove group");
            if (mWifiNative.p2pGroupRemove(mGroup.getInterface())) {
                transitionTo(mOngoingGroupRemovalState);
                replyToMessage(message, WifiP2pManager.REMOVE_GROUP_SUCCEEDED);
            } else {
                handleGroupRemoved();
                transitionTo(mInactiveState);
                replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED, WifiP2pManager.ERROR);
            }
            break;
        /* We do not listen to NETWORK_DISCONNECTION_EVENT for group removal
                 * handling since supplicant actually tries to reconnect after a temporary
                 * disconnect until group idle time out. Eventually, a group removal event
                 * will come when group has been removed.
                 *
                 * When there are connectivity issues during temporary disconnect, the application
                 * will also just remove the group.
                 *
                 * Treating network disconnection as group removal causes race conditions since
                 * supplicant would still maintain the group at that stage.
                 */
        case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
            if (DBG)
                logd(getName() + " group removed");
            handleGroupRemoved();
            transitionTo(mInactiveState);
            break;
        case WifiMonitor.P2P_DEVICE_LOST_EVENT:
            device = (WifiP2pDevice) message.obj;
            // Device loss for a connected device indicates it is not in discovery any more
            if (mGroup.contains(device)) {
                if (DBG)
                    logd("Add device to lost list " + device);
                mPeersLostDuringConnection.updateSupplicantDetails(device);
                return HANDLED;
            }
            // Do the regular device lost handling
            return NOT_HANDLED;
        case WifiStateMachine.CMD_DISABLE_P2P_REQ:
            sendMessage(WifiP2pManager.REMOVE_GROUP);
            deferMessage(message);
            break;
        // WPS window
        case WifiP2pManager.START_WPS:
            WpsInfo wps = (WpsInfo) message.obj;
            if (wps == null) {
                replyToMessage(message, WifiP2pManager.START_WPS_FAILED);
                break;
            }
            boolean ret = true;
            if (wps.setup == WpsInfo.PBC) {
                ret = mWifiNative.startWpsPbc(mGroup.getInterface(), null);
            } else {
                if (wps.pin == null) {
                    String pin = mWifiNative.startWpsPinDisplay(mGroup.getInterface());
                    try {
                        Integer.parseInt(pin);
                        notifyInvitationSent(pin, "any");
                    } catch (NumberFormatException ignore) {
                        ret = false;
                    }
                } else {
                    ret = mWifiNative.startWpsPinKeypad(mGroup.getInterface(), wps.pin);
                }
            }
            replyToMessage(message, ret ? WifiP2pManager.START_WPS_SUCCEEDED : WifiP2pManager.START_WPS_FAILED);
            break;
        case WifiP2pManager.CONNECT:
            WifiP2pConfig config = (WifiP2pConfig) message.obj;
            if (isConfigInvalid(config)) {
                loge("Dropping connect requeset " + config);
                replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
                break;
            }
            logd("Inviting device : " + config.deviceAddress);
            mSavedPeerConfig = config;
            if (mWifiNative.p2pInvite(mGroup, config.deviceAddress)) {
                mPeers.updateStatus(config.deviceAddress, WifiP2pDevice.INVITED);
                sendPeersChangedBroadcast();
                replyToMessage(message, WifiP2pManager.CONNECT_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.CONNECT_FAILED, WifiP2pManager.ERROR);
            }
            // TODO: figure out updating the status to declined when invitation is rejected
            break;
        case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
            P2pStatus status = (P2pStatus) message.obj;
            if (status == P2pStatus.SUCCESS) {
                // invocation was succeeded.
                break;
            }
            loge("Invitation result " + status);
            if (status == P2pStatus.UNKNOWN_P2P_GROUP) {
                // target device has already removed the credential.
                // So, remove this credential accordingly.
                int netId = mGroup.getNetworkId();
                if (netId >= 0) {
                    if (DBG)
                        logd("Remove unknown client from the list");
                    if (!removeClientFromList(netId, mSavedPeerConfig.deviceAddress, false)) {
                        // not found the client on the list
                        loge("Already removed the client, ignore");
                        break;
                    }
                    // try invitation.
                    sendMessage(WifiP2pManager.CONNECT, mSavedPeerConfig);
                }
            }
            break;
        case WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
        case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
        case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
            WifiP2pProvDiscEvent provDisc = (WifiP2pProvDiscEvent) message.obj;
            mSavedPeerConfig = new WifiP2pConfig();
            mSavedPeerConfig.deviceAddress = provDisc.device.deviceAddress;
            if (message.what == WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT) {
                mSavedPeerConfig.wps.setup = WpsInfo.KEYPAD;
            } else if (message.what == WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT) {
                mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
                mSavedPeerConfig.wps.pin = provDisc.pin;
            } else {
                mSavedPeerConfig.wps.setup = WpsInfo.PBC;
            }
            transitionTo(mUserAuthorizingJoinState);
            break;
        case WifiMonitor.P2P_GROUP_STARTED_EVENT:
            loge("Duplicate group creation event notice, ignore");
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    if (DBG)
        logd(getName() + message.toString());
    switch(message.what) {
        case WifiMonitor.AP_STA_CONNECTED_EVENT:
            WifiP2pDevice device = (WifiP2pDevice) message.obj;
            String deviceAddress = device.deviceAddress;
            // Clear timeout that was set when group was started.
            mWifiNative.setP2pGroupIdle(mGroup.getInterface(), 0);
            if (deviceAddress != null) {
                if (mPeers.get(deviceAddress) != null) {
                    mGroup.addClient(mPeers.get(deviceAddress));
                } else {
                    mGroup.addClient(deviceAddress);
                }
                mPeers.updateStatus(deviceAddress, WifiP2pDevice.CONNECTED);
                if (DBG)
                    logd(getName() + " ap sta connected");
                sendPeersChangedBroadcast();
            } else {
                loge("Connect on null device address, ignore");
            }
            sendP2pConnectionChangedBroadcast();
            break;
        case WifiMonitor.AP_STA_DISCONNECTED_EVENT:
            device = (WifiP2pDevice) message.obj;
            deviceAddress = device.deviceAddress;
            if (deviceAddress != null) {
                mPeers.updateStatus(deviceAddress, WifiP2pDevice.AVAILABLE);
                if (mGroup.removeClient(deviceAddress)) {
                    if (DBG)
                        logd("Removed client " + deviceAddress);
                    if (!mAutonomousGroup && mGroup.isClientListEmpty()) {
                        logd("Client list empty, remove non-persistent p2p group");
                        mWifiNative.p2pGroupRemove(mGroup.getInterface());
                    // We end up sending connection changed broadcast
                    // when this happens at exit()
                    } else {
                        // Notify when a client disconnects from group
                        sendP2pConnectionChangedBroadcast();
                    }
                } else {
                    if (DBG)
                        logd("Failed to remove client " + deviceAddress);
                    for (WifiP2pDevice c : mGroup.getClientList()) {
                        if (DBG)
                            logd("client " + c.deviceAddress);
                    }
                }
                sendPeersChangedBroadcast();
                if (DBG)
                    logd(getName() + " ap sta disconnected");
            } else {
                loge("Disconnect on unknown device: " + device);
            }
            break;
        case IPM_PRE_DHCP_ACTION:
            mWifiNative.setP2pPowerSave(mGroup.getInterface(), false);
            mIpManager.completedPreDhcpAction();
            break;
        case IPM_POST_DHCP_ACTION:
            mWifiNative.setP2pPowerSave(mGroup.getInterface(), true);
            break;
        case IPM_DHCP_RESULTS:
            mDhcpResults = (DhcpResults) message.obj;
            break;
        case IPM_PROVISIONING_SUCCESS:
            if (DBG)
                logd("mDhcpResults: " + mDhcpResults);
            setWifiP2pInfoOnGroupFormation(mDhcpResults.serverAddress);
            sendP2pConnectionChangedBroadcast();
            try {
                final String ifname = mGroup.getInterface();
                mNwService.addInterfaceToLocalNetwork(ifname, mDhcpResults.getRoutes(ifname));
            } catch (RemoteException e) {
                loge("Failed to add iface to local network " + e);
            }
            break;
        case IPM_PROVISIONING_FAILURE:
            loge("IP provisioning failed");
            mWifiNative.p2pGroupRemove(mGroup.getInterface());
            break;
        case WifiP2pManager.REMOVE_GROUP:
            if (DBG)
                logd(getName() + " remove group");
            if (mWifiNative.p2pGroupRemove(mGroup.getInterface())) {
                transitionTo(mOngoingGroupRemovalState);
                replyToMessage(message, WifiP2pManager.REMOVE_GROUP_SUCCEEDED);
            } else {
                handleGroupRemoved();
                transitionTo(mInactiveState);
                replyToMessage(message, WifiP2pManager.REMOVE_GROUP_FAILED, WifiP2pManager.ERROR);
            }
            break;
        /* We do not listen to NETWORK_DISCONNECTION_EVENT for group removal
                 * handling since supplicant actually tries to reconnect after a temporary
                 * disconnect until group idle time out. Eventually, a group removal event
                 * will come when group has been removed.
                 *
                 * When there are connectivity issues during temporary disconnect, the application
                 * will also just remove the group.
                 *
                 * Treating network disconnection as group removal causes race conditions since
                 * supplicant would still maintain the group at that stage.
                 */
        case WifiMonitor.P2P_GROUP_REMOVED_EVENT:
            if (DBG)
                logd(getName() + " group removed");
            handleGroupRemoved();
            transitionTo(mInactiveState);
            break;
        case WifiMonitor.P2P_DEVICE_LOST_EVENT:
            device = (WifiP2pDevice) message.obj;
            // Device loss for a connected device indicates it is not in discovery any more
            if (mGroup.contains(device)) {
                if (DBG)
                    logd("Add device to lost list " + device);
                mPeersLostDuringConnection.updateSupplicantDetails(device);
                return HANDLED;
            }
            // Do the regular device lost handling
            return NOT_HANDLED;
        case WifiStateMachine.CMD_DISABLE_P2P_REQ:
            sendMessage(WifiP2pManager.REMOVE_GROUP);
            deferMessage(message);
            break;
        // WPS window
        case WifiP2pManager.START_WPS:
            WpsInfo wps = (WpsInfo) message.obj;
            if (wps == null) {
                replyToMessage(message, WifiP2pManager.START_WPS_FAILED);
                break;
            }
            boolean ret = true;
            if (wps.setup == WpsInfo.PBC) {
                ret = mWifiNative.startWpsPbc(mGroup.getInterface(), null);
            } else {
                if (wps.pin == null) {
                    String pin = mWifiNative.startWpsPinDisplay(mGroup.getInterface());
                    try {
                        Integer.parseInt(pin);
                        notifyInvitationSent(pin, "any");
                    } catch (NumberFormatException ignore) {
                        ret = false;
                    }
                } else {
                    ret = mWifiNative.startWpsPinKeypad(mGroup.getInterface(), wps.pin);
                }
            }
            replyToMessage(message, ret ? WifiP2pManager.START_WPS_SUCCEEDED : WifiP2pManager.START_WPS_FAILED);
            break;
        case WifiP2pManager.CONNECT:
            WifiP2pConfig config = (WifiP2pConfig) message.obj;
            if (isConfigInvalid(config)) {
                loge("Dropping connect requeset " + config);
                replyToMessage(message, WifiP2pManager.CONNECT_FAILED);
                break;
            }
            logd("Inviting device : " + config.deviceAddress);
            mSavedPeerConfig = config;
            if (mWifiNative.p2pInvite(mGroup, config.deviceAddress)) {
                mPeers.updateStatus(config.deviceAddress, WifiP2pDevice.INVITED);
                sendPeersChangedBroadcast();
                replyToMessage(message, WifiP2pManager.CONNECT_SUCCEEDED);
            } else {
                replyToMessage(message, WifiP2pManager.CONNECT_FAILED, WifiP2pManager.ERROR);
            }
            // TODO: figure out updating the status to declined when invitation is rejected
            break;
        case WifiMonitor.P2P_INVITATION_RESULT_EVENT:
            P2pStatus status = (P2pStatus) message.obj;
            if (status == P2pStatus.SUCCESS) {
                // invocation was succeeded.
                break;
            }
            loge("Invitation result " + status);
            if (status == P2pStatus.UNKNOWN_P2P_GROUP) {
                // target device has already removed the credential.
                // So, remove this credential accordingly.
                int netId = mGroup.getNetworkId();
                if (netId >= 0) {
                    if (DBG)
                        logd("Remove unknown client from the list");
                    if (!removeClientFromList(netId, mSavedPeerConfig.deviceAddress, false)) {
                        // not found the client on the list
                        loge("Already removed the client, ignore");
                        break;
                    }
                    // try invitation.
                    sendMessage(WifiP2pManager.CONNECT, mSavedPeerConfig);
                }
            }
            break;
        case WifiMonitor.P2P_PROV_DISC_PBC_REQ_EVENT:
        case WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT:
        case WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT:
            WifiP2pProvDiscEvent provDisc = (WifiP2pProvDiscEvent) message.obj;
            mSavedPeerConfig = new WifiP2pConfig();
            mSavedPeerConfig.deviceAddress = provDisc.device.deviceAddress;
            if (message.what == WifiMonitor.P2P_PROV_DISC_ENTER_PIN_EVENT) {
                mSavedPeerConfig.wps.setup = WpsInfo.KEYPAD;
            } else if (message.what == WifiMonitor.P2P_PROV_DISC_SHOW_PIN_EVENT) {
                mSavedPeerConfig.wps.setup = WpsInfo.DISPLAY;
                mSavedPeerConfig.wps.pin = provDisc.pin;
            } else {
                mSavedPeerConfig.wps.setup = WpsInfo.PBC;
            }
            transitionTo(mUserAuthorizingJoinState);
            break;
        case WifiMonitor.P2P_GROUP_STARTED_EVENT:
            loge("Duplicate group creation event notice, ignore");
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    pw.println("mWifiP2pInfo " + mWifiP2pInfo);
    pw.println("mGroup " + mGroup);
    pw.println("mSavedPeerConfig " + mSavedPeerConfig);
    pw.println("mSavedP2pGroup " + mSavedP2pGroup);
    pw.println();
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    pw.println("mWifiP2pInfo " + mWifiP2pInfo);
    pw.println("mGroup " + mGroup);
    pw.println("mSavedPeerConfig " + mSavedPeerConfig);
    pw.println();
}
#end_block

#method_before
private void notifyP2pEnableFailure() {
    Resources r = Resources.getSystem();
    AlertDialog dialog = new AlertDialog.Builder(mContext).setTitle(r.getString(R.string.wifi_p2p_dialog_title)).setMessage(r.getString(R.string.wifi_p2p_failed_message)).setPositiveButton(r.getString(R.string.ok), null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
}
#method_after
private void notifyP2pEnableFailure() {
    Resources r = Resources.getSystem();
    AlertDialog dialog = new AlertDialog.Builder(mContext).setTitle(r.getString(R.string.wifi_p2p_dialog_title)).setMessage(r.getString(R.string.wifi_p2p_failed_message)).setPositiveButton(r.getString(R.string.ok), null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
    attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
    dialog.getWindow().setAttributes(attrs);
    dialog.show();
}
#end_block

#method_before
private void notifyInvitationSent(String pin, String peerAddress) {
    Resources r = Resources.getSystem();
    final View textEntryView = LayoutInflater.from(mContext).inflate(R.layout.wifi_p2p_dialog, null);
    ViewGroup group = (ViewGroup) textEntryView.findViewById(R.id.info);
    addRowToDialog(group, R.string.wifi_p2p_to_message, getDeviceName(peerAddress));
    addRowToDialog(group, R.string.wifi_p2p_show_pin_message, pin);
    AlertDialog dialog = new AlertDialog.Builder(mContext).setTitle(r.getString(R.string.wifi_p2p_invitation_sent_title)).setView(textEntryView).setPositiveButton(r.getString(R.string.ok), null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
}
#method_after
private void notifyInvitationSent(String pin, String peerAddress) {
    Resources r = Resources.getSystem();
    final View textEntryView = LayoutInflater.from(mContext).inflate(R.layout.wifi_p2p_dialog, null);
    ViewGroup group = (ViewGroup) textEntryView.findViewById(R.id.info);
    addRowToDialog(group, R.string.wifi_p2p_to_message, getDeviceName(peerAddress));
    addRowToDialog(group, R.string.wifi_p2p_show_pin_message, pin);
    AlertDialog dialog = new AlertDialog.Builder(mContext).setTitle(r.getString(R.string.wifi_p2p_invitation_sent_title)).setView(textEntryView).setPositiveButton(r.getString(R.string.ok), null).create();
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
    attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
    dialog.getWindow().setAttributes(attrs);
    dialog.show();
}
#end_block

#method_before
private void notifyInvitationReceived() {
    Resources r = Resources.getSystem();
    final WpsInfo wps = mSavedPeerConfig.wps;
    final View textEntryView = LayoutInflater.from(mContext).inflate(R.layout.wifi_p2p_dialog, null);
    ViewGroup group = (ViewGroup) textEntryView.findViewById(R.id.info);
    addRowToDialog(group, R.string.wifi_p2p_from_message, getDeviceName(mSavedPeerConfig.deviceAddress));
    final EditText pin = (EditText) textEntryView.findViewById(R.id.wifi_p2p_wps_pin);
    AlertDialog dialog = new AlertDialog.Builder(mContext).setTitle(r.getString(R.string.wifi_p2p_invitation_to_connect_title)).setView(textEntryView).setPositiveButton(r.getString(R.string.accept), new OnClickListener() {

        public void onClick(DialogInterface dialog, int which) {
            if (wps.setup == WpsInfo.KEYPAD) {
                mSavedPeerConfig.wps.pin = pin.getText().toString();
            }
            if (DBG)
                logd(getName() + " accept invitation " + mSavedPeerConfig);
            sendMessage(PEER_CONNECTION_USER_ACCEPT);
        }
    }).setNegativeButton(r.getString(R.string.decline), new OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            if (DBG)
                logd(getName() + " ignore connect");
            sendMessage(PEER_CONNECTION_USER_REJECT);
        }
    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

        @Override
        public void onCancel(DialogInterface arg0) {
            if (DBG)
                logd(getName() + " ignore connect");
            sendMessage(PEER_CONNECTION_USER_REJECT);
        }
    }).create();
    dialog.setCanceledOnTouchOutside(false);
    // make the enter pin area or the display pin area visible
    switch(wps.setup) {
        case WpsInfo.KEYPAD:
            if (DBG)
                logd("Enter pin section visible");
            textEntryView.findViewById(R.id.enter_pin_section).setVisibility(View.VISIBLE);
            break;
        case WpsInfo.DISPLAY:
            if (DBG)
                logd("Shown pin section visible");
            addRowToDialog(group, R.string.wifi_p2p_show_pin_message, wps.pin);
            break;
        default:
            break;
    }
    if ((r.getConfiguration().uiMode & Configuration.UI_MODE_TYPE_APPLIANCE) == Configuration.UI_MODE_TYPE_APPLIANCE) {
        // For appliance devices, add a key listener which accepts.
        dialog.setOnKeyListener(new DialogInterface.OnKeyListener() {

            @Override
            public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                // TODO: make the actual key come from a config value.
                if (keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
                    sendMessage(PEER_CONNECTION_USER_ACCEPT);
                    dialog.dismiss();
                    return true;
                }
                return false;
            }
        });
    // TODO: add timeout for this dialog.
    // TODO: update UI in appliance mode to tell user what to do.
    }
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    dialog.show();
}
#method_after
private void notifyInvitationReceived() {
    Resources r = Resources.getSystem();
    final WpsInfo wps = mSavedPeerConfig.wps;
    final View textEntryView = LayoutInflater.from(mContext).inflate(R.layout.wifi_p2p_dialog, null);
    ViewGroup group = (ViewGroup) textEntryView.findViewById(R.id.info);
    addRowToDialog(group, R.string.wifi_p2p_from_message, getDeviceName(mSavedPeerConfig.deviceAddress));
    final EditText pin = (EditText) textEntryView.findViewById(R.id.wifi_p2p_wps_pin);
    AlertDialog dialog = new AlertDialog.Builder(mContext).setTitle(r.getString(R.string.wifi_p2p_invitation_to_connect_title)).setView(textEntryView).setPositiveButton(r.getString(R.string.accept), new OnClickListener() {

        public void onClick(DialogInterface dialog, int which) {
            if (wps.setup == WpsInfo.KEYPAD) {
                mSavedPeerConfig.wps.pin = pin.getText().toString();
            }
            if (DBG)
                logd(getName() + " accept invitation " + mSavedPeerConfig);
            sendMessage(PEER_CONNECTION_USER_ACCEPT);
        }
    }).setNegativeButton(r.getString(R.string.decline), new OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            if (DBG)
                logd(getName() + " ignore connect");
            sendMessage(PEER_CONNECTION_USER_REJECT);
        }
    }).setOnCancelListener(new DialogInterface.OnCancelListener() {

        @Override
        public void onCancel(DialogInterface arg0) {
            if (DBG)
                logd(getName() + " ignore connect");
            sendMessage(PEER_CONNECTION_USER_REJECT);
        }
    }).create();
    dialog.setCanceledOnTouchOutside(false);
    // make the enter pin area or the display pin area visible
    switch(wps.setup) {
        case WpsInfo.KEYPAD:
            if (DBG)
                logd("Enter pin section visible");
            textEntryView.findViewById(R.id.enter_pin_section).setVisibility(View.VISIBLE);
            break;
        case WpsInfo.DISPLAY:
            if (DBG)
                logd("Shown pin section visible");
            addRowToDialog(group, R.string.wifi_p2p_show_pin_message, wps.pin);
            break;
        default:
            break;
    }
    if ((r.getConfiguration().uiMode & Configuration.UI_MODE_TYPE_APPLIANCE) == Configuration.UI_MODE_TYPE_APPLIANCE) {
        // For appliance devices, add a key listener which accepts.
        dialog.setOnKeyListener(new DialogInterface.OnKeyListener() {

            @Override
            public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                // TODO: make the actual key come from a config value.
                if (keyCode == KeyEvent.KEYCODE_VOLUME_MUTE) {
                    sendMessage(PEER_CONNECTION_USER_ACCEPT);
                    dialog.dismiss();
                    return true;
                }
                return false;
            }
        });
    // TODO: add timeout for this dialog.
    // TODO: update UI in appliance mode to tell user what to do.
    }
    dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
    WindowManager.LayoutParams attrs = dialog.getWindow().getAttributes();
    attrs.privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_SHOW_FOR_ALL_USERS;
    dialog.getWindow().setAttributes(attrs);
    dialog.show();
}
#end_block

#method_before
private void initializeP2pSettings() {
    mWifiNative.setPersistentReconnect(true);
    mThisDevice.deviceName = getPersistedDeviceName();
    mWifiNative.setDeviceName(mThisDevice.deviceName);
    // DIRECT-XY-DEVICENAME (XY is randomly generated)
    mWifiNative.setP2pSsidPostfix("-" + mThisDevice.deviceName);
    mWifiNative.setDeviceType(mThisDevice.primaryDeviceType);
    // Supplicant defaults to using virtual display with display
    // which refers to a remote display. Use physical_display
    mWifiNative.setConfigMethods("virtual_push_button physical_display keypad");
    // STA has higher priority over P2P
    mWifiNative.setConcurrencyPriority("sta");
    mThisDevice.deviceAddress = mWifiNative.p2pGetDeviceAddress();
    updateThisDevice(WifiP2pDevice.AVAILABLE);
    if (DBG)
        logd("DeviceAddress: " + mThisDevice.deviceAddress);
    mClientInfoList.clear();
    mWifiNative.p2pFlush();
    mWifiNative.p2pServiceFlush();
    mServiceTransactionId = 0;
    mServiceDiscReqId = null;
    String countryCode = Settings.Global.getString(mContext.getContentResolver(), Settings.Global.WIFI_COUNTRY_CODE);
    if (countryCode != null && !countryCode.isEmpty()) {
        mP2pStateMachine.sendMessage(SET_COUNTRY_CODE, countryCode);
    }
    updatePersistentNetworks(RELOAD);
}
#method_after
private void initializeP2pSettings() {
    mWifiNative.setPersistentReconnect(true);
    mThisDevice.deviceName = getPersistedDeviceName();
    mWifiNative.setDeviceName(mThisDevice.deviceName);
    // DIRECT-XY-DEVICENAME (XY is randomly generated)
    mWifiNative.setP2pSsidPostfix("-" + mThisDevice.deviceName);
    mWifiNative.setDeviceType(mThisDevice.primaryDeviceType);
    // Supplicant defaults to using virtual display with display
    // which refers to a remote display. Use physical_display
    mWifiNative.setConfigMethods("virtual_push_button physical_display keypad");
    // STA has higher priority over P2P
    mWifiNative.setConcurrencyPriority("sta");
    mThisDevice.deviceAddress = mWifiNative.p2pGetDeviceAddress();
    updateThisDevice(WifiP2pDevice.AVAILABLE);
    if (DBG)
        logd("DeviceAddress: " + mThisDevice.deviceAddress);
    mClientInfoList.clear();
    mWifiNative.p2pFlush();
    mWifiNative.p2pServiceFlush();
    mServiceTransactionId = 0;
    mServiceDiscReqId = null;
    updatePersistentNetworks(RELOAD);
}
#end_block

#method_before
private void handleGroupCreationFailure() {
    resetWifiP2pInfo();
    mNetworkInfo.setDetailedState(NetworkInfo.DetailedState.FAILED, null, null);
    sendP2pConnectionChangedBroadcast();
    // Remove only the peer we failed to connect to so that other devices discovered
    // that have not timed out still remain in list for connection
    boolean peersChanged = mPeers.remove(mPeersLostDuringConnection);
    if (mSavedPeerConfig.deviceAddress != null && mPeers.remove(mSavedPeerConfig.deviceAddress) != null) {
        peersChanged = true;
    }
    if (peersChanged) {
        sendPeersChangedBroadcast();
    }
    mPeersLostDuringConnection.clear();
    mServiceDiscReqId = null;
    sendMessage(WifiP2pManager.DISCOVER_PEERS);
}
#method_after
private void handleGroupCreationFailure() {
    resetWifiP2pInfo();
    mNetworkInfo.setDetailedState(NetworkInfo.DetailedState.FAILED, null, null);
    sendP2pConnectionChangedBroadcast();
    // Remove only the peer we failed to connect to so that other devices discovered
    // that have not timed out still remain in list for connection
    boolean peersChanged = mPeers.remove(mPeersLostDuringConnection);
    if (TextUtils.isEmpty(mSavedPeerConfig.deviceAddress) == false && mPeers.remove(mSavedPeerConfig.deviceAddress) != null) {
        peersChanged = true;
    }
    if (peersChanged) {
        sendPeersChangedBroadcast();
    }
    mPeersLostDuringConnection.clear();
    mServiceDiscReqId = null;
    sendMessage(WifiP2pManager.DISCOVER_PEERS);
}
#end_block

#method_before
private void handleGroupRemoved() {
    if (mGroup.isGroupOwner()) {
        stopDhcpServer(mGroup.getInterface());
    } else {
        if (DBG)
            logd("stop DHCP client");
        mDhcpStateMachine.sendMessage(DhcpStateMachine.CMD_STOP_DHCP);
        mDhcpStateMachine.doQuit();
        mDhcpStateMachine = null;
        try {
            mNwService.removeInterfaceFromLocalNetwork(mGroup.getInterface());
        } catch (RemoteException e) {
            loge("Failed to remove iface from local network " + e);
        }
    }
    try {
        mNwService.clearInterfaceAddresses(mGroup.getInterface());
    } catch (Exception e) {
        loge("Failed to clear addresses " + e);
    }
    NetworkUtils.resetConnections(mGroup.getInterface(), NetworkUtils.RESET_ALL_ADDRESSES);
    // Clear any timeout that was set. This is essential for devices
    // that reuse the main p2p interface for a created group.
    mWifiNative.setP2pGroupIdle(mGroup.getInterface(), 0);
    boolean peersChanged = false;
    // that have not timed out still remain in list for connection
    for (WifiP2pDevice d : mGroup.getClientList()) {
        if (mPeers.remove(d))
            peersChanged = true;
    }
    if (mPeers.remove(mGroup.getOwner()))
        peersChanged = true;
    if (mPeers.remove(mPeersLostDuringConnection))
        peersChanged = true;
    if (peersChanged) {
        sendPeersChangedBroadcast();
    }
    mGroup = null;
    mPeersLostDuringConnection.clear();
    mServiceDiscReqId = null;
    if (mTemporarilyDisconnectedWifi) {
        mWifiChannel.sendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST, 0);
        mTemporarilyDisconnectedWifi = false;
    }
}
#method_after
private void handleGroupRemoved() {
    if (mGroup.isGroupOwner()) {
        stopDhcpServer(mGroup.getInterface());
    } else {
        if (DBG)
            logd("stop IpManager");
        stopIpManager();
        try {
            mNwService.removeInterfaceFromLocalNetwork(mGroup.getInterface());
        } catch (RemoteException e) {
            loge("Failed to remove iface from local network " + e);
        }
    }
    try {
        mNwService.clearInterfaceAddresses(mGroup.getInterface());
    } catch (Exception e) {
        loge("Failed to clear addresses " + e);
    }
    // Clear any timeout that was set. This is essential for devices
    // that reuse the main p2p interface for a created group.
    mWifiNative.setP2pGroupIdle(mGroup.getInterface(), 0);
    boolean peersChanged = false;
    // that have not timed out still remain in list for connection
    for (WifiP2pDevice d : mGroup.getClientList()) {
        if (mPeers.remove(d))
            peersChanged = true;
    }
    if (mPeers.remove(mGroup.getOwner()))
        peersChanged = true;
    if (mPeers.remove(mPeersLostDuringConnection))
        peersChanged = true;
    if (peersChanged) {
        sendPeersChangedBroadcast();
    }
    mGroup = null;
    mPeersLostDuringConnection.clear();
    mServiceDiscReqId = null;
    if (mTemporarilyDisconnectedWifi) {
        mWifiChannel.sendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST, 0);
        mTemporarilyDisconnectedWifi = false;
    }
}
#end_block

#method_before
// http://b/26117827
// 
public void test_available_on_nonIOCTL_supported_file() throws IOException, ErrnoException {
    File file = new File("/dev/zero");
    try (FileInputStream input = new FileInputStream(file)) {
        assertEquals(0, input.available());
    }
    try (FileInputStream input = new FileInputStream(file)) {
        android.system.Os.ioctlInt(input.getFD(), OsConstants.FIONREAD, new MutableInt(0));
        fail();
    } catch (ErrnoException expected) {
        assertTrue("FIONREAD should have returned ENOTTY for the file. If it doesn't return" + " FIONREAD, the test no more holds validity.", expected.getMessage().contains("ENOTTY"));
    }
}
#method_after
// http://b/26117827
// 
public void test_available_on_nonIOCTL_supported_file() throws Exception {
    File file = new File("/dev/zero");
    try (FileInputStream input = new FileInputStream(file)) {
        assertEquals(0, input.available());
    }
    try (FileInputStream input = new FileInputStream(file)) {
        android.system.Os.ioctlInt(input.getFD(), OsConstants.FIONREAD, new MutableInt(0));
        fail();
    } catch (ErrnoException expected) {
        assertEquals("FIONREAD should have returned ENOTTY for the file. If it doesn't return" + " FIONREAD, the test is no longer valid.", OsConstants.ENOTTY, expected.errno);
    }
}
#end_block

#method_before
// http://b/25878034
// 
// The test makes sure that #exists doesn't use stat. To implement the same, it installs
// SECCOMP filter. The SECCOMP filter is designed to not allow stat(fstatat64/newfstatat) calls
// and whenever a threads makes the system call, it will wait indefinitely and timeout will
public void testExistsOnSystem() {
    assertEquals("SECCOMP filter is not installed.", 0, installSeccompFilter());
    File sh = new File("/sdcard");
    assertTrue(sh.exists());
}
#method_after
// http://b/25878034
// 
// The test makes sure that #exists doesn't use stat. To implement the same, it installs
// SECCOMP filter. The SECCOMP filter is designed to not allow stat(fstatat64/newfstatat) calls
// and whenever a thread makes the system call, android.system.ErrnoException
public void testExistsOnSystem() throws ErrnoException {
    assertEquals("SECCOMP filter is not installed.", 0, installSeccompFilter());
    File sh = new File("/sdcard");
    assertTrue(sh.exists());
}
#end_block

#method_before
void enableVerboseLogging(int verbose) {
    if (verbose > 0) {
        mVerboseLoggingEnabled = true;
        setLogRecSize(ActivityManager.isLowRamDeviceStatic() ? NUM_LOG_RECS_VERBOSE_LOW_MEMORY : NUM_LOG_RECS_VERBOSE);
    } else {
        mVerboseLoggingEnabled = false;
        setLogRecSize(NUM_LOG_RECS_NORMAL);
    }
    configureVerboseHalLogging(mVerboseLoggingEnabled);
    setSupplicantLogLevel();
    mCountryCode.enableVerboseLogging(verbose);
    mWifiScoreReport.enableVerboseLogging(mVerboseLoggingEnabled);
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mWifiMonitor.enableVerboseLogging(verbose);
    mWifiNative.enableVerboseLogging(verbose);
    mWifiConfigManager.enableVerboseLogging(verbose);
    mSupplicantStateTracker.enableVerboseLogging(verbose);
    mWifiQualifiedNetworkSelector.enableVerboseLogging(verbose);
    if (mWifiConnectivityManager != null) {
        mWifiConnectivityManager.enableVerboseLogging(verbose);
    }
}
#method_after
void enableVerboseLogging(int verbose) {
    if (verbose > 0) {
        mVerboseLoggingEnabled = true;
        setLogRecSize(ActivityManager.isLowRamDeviceStatic() ? NUM_LOG_RECS_VERBOSE_LOW_MEMORY : NUM_LOG_RECS_VERBOSE);
    } else {
        mVerboseLoggingEnabled = false;
        setLogRecSize(NUM_LOG_RECS_NORMAL);
    }
    configureVerboseHalLogging(mVerboseLoggingEnabled);
    setSupplicantLogLevel();
    mCountryCode.enableVerboseLogging(verbose);
    mWifiScoreReport.enableVerboseLogging(mVerboseLoggingEnabled);
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mWifiMonitor.enableVerboseLogging(verbose);
    mWifiNative.enableVerboseLogging(verbose);
    mWifiConfigManager.enableVerboseLogging(verbose);
    mSupplicantStateTracker.enableVerboseLogging(verbose);
}
#end_block

#method_before
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!mWifiConfigManager.enableNetwork(netId, true, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to enable=" + netId);
        return false;
    }
    if (!mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to connect=" + netId);
        // App does not have the permission to force a connection. But, we should still
        // reconsider this newly enabled network for network selection.
        mWifiConnectivityManager.forceConnectivityScan();
    } else {
        // Trigger an immediate connection to the specified network. We're also noting the user
        // connect choice here, so that it will be considered in the next network selection.
        mWifiConnectivityManager.setUserConnectChoice(netId);
        startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
    }
    return true;
}
#method_after
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!mWifiConfigManager.enableNetwork(netId, true, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to enable=" + netId);
        return false;
    }
    if (!mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to connect=" + netId);
        // App does not have the permission to force a connection. But, we should still
        // reconsider this newly enabled network for network selection.
        mWifiConnectivityManager.forceConnectivityScan();
    } else {
        // Trigger an immediate connection to the specified network. We're also noting the user
        // connect choice here, so that it will be considered in the next network selection.
        mWifiConnectivityManager.setUserConnectChoice(netId);
        if (mWifiInfo.getNetworkId() == netId) {
            // We're already connected to the user specified network, don't trigger a
            // reconnection.
            logi("connectToUserSelectNetwork already connecting/connected=" + netId);
        } else {
            startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
        }
    }
    return true;
}
#end_block

#method_before
private void handleScanRequest(Message message) {
    ScanSettings settings = null;
    WorkSource workSource = null;
    // unbundle parameters
    Bundle bundle = (Bundle) message.obj;
    if (bundle != null) {
        settings = bundle.getParcelable(CUSTOMIZED_SCAN_SETTING);
        workSource = bundle.getParcelable(CUSTOMIZED_SCAN_WORKSOURCE);
    }
    Set<Integer> freqs = null;
    if (settings != null && settings.channelSet != null) {
        freqs = new HashSet<>();
        for (WifiChannel channel : settings.channelSet) {
            freqs.add(channel.freqMHz);
        }
    }
    // Retrieve the list of hidden networkId's to scan for.
    // TODO(b/29503772)
    Set<Integer> hiddenNetworkIds = new HashSet<>();
    // call wifi native to start the scan
    if (startScanNative(freqs, hiddenNetworkIds, workSource)) {
        // a full scan covers everything, clearing scan request buffer
        if (freqs == null)
            mBufferedScanMsg.clear();
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_OK;
        if (workSource != null) {
            // External worksource was passed along the scan request,
            // hence always send a broadcast
            mSendScanResultsBroadcast = true;
        }
        return;
    }
    if (!mIsScanOngoing) {
        // discard this request and pop up the next one
        if (mBufferedScanMsg.size() > 0) {
            sendMessage(mBufferedScanMsg.remove());
        }
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
    } else if (!mIsFullScanOngoing) {
        // buffer the scan request to make sure specified channels will be scanned eventually
        if (freqs == null)
            mBufferedScanMsg.clear();
        if (mBufferedScanMsg.size() < SCAN_REQUEST_BUFFER_MAX_SIZE) {
            Message msg = obtainMessage(CMD_START_SCAN, message.arg1, message.arg2, bundle);
            mBufferedScanMsg.add(msg);
        } else {
            // if too many requests in buffer, combine them into a single full scan
            bundle = new Bundle();
            bundle.putParcelable(CUSTOMIZED_SCAN_SETTING, null);
            bundle.putParcelable(CUSTOMIZED_SCAN_WORKSOURCE, workSource);
            Message msg = obtainMessage(CMD_START_SCAN, message.arg1, message.arg2, bundle);
            mBufferedScanMsg.clear();
            mBufferedScanMsg.add(msg);
        }
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_LOOPED;
    } else {
        // mIsScanOngoing and mIsFullScanOngoing
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
    }
}
#method_after
private void handleScanRequest(Message message) {
    ScanSettings settings = null;
    WorkSource workSource = null;
    // unbundle parameters
    Bundle bundle = (Bundle) message.obj;
    if (bundle != null) {
        settings = bundle.getParcelable(CUSTOMIZED_SCAN_SETTING);
        workSource = bundle.getParcelable(CUSTOMIZED_SCAN_WORKSOURCE);
    }
    Set<Integer> freqs = null;
    if (settings != null && settings.channelSet != null) {
        freqs = new HashSet<>();
        for (WifiChannel channel : settings.channelSet) {
            freqs.add(channel.freqMHz);
        }
    }
    // Retrieve the list of hidden network SSIDs to scan for.
    List<WifiScanner.ScanSettings.HiddenNetwork> hiddenNetworks = mWifiConfigManager.retrieveHiddenNetworkList();
    // call wifi native to start the scan
    if (startScanNative(freqs, hiddenNetworks, workSource)) {
        // a full scan covers everything, clearing scan request buffer
        if (freqs == null)
            mBufferedScanMsg.clear();
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_OK;
        return;
    }
    if (!mIsScanOngoing) {
        // discard this request and pop up the next one
        if (mBufferedScanMsg.size() > 0) {
            sendMessage(mBufferedScanMsg.remove());
        }
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
    } else if (!mIsFullScanOngoing) {
        // buffer the scan request to make sure specified channels will be scanned eventually
        if (freqs == null)
            mBufferedScanMsg.clear();
        if (mBufferedScanMsg.size() < SCAN_REQUEST_BUFFER_MAX_SIZE) {
            Message msg = obtainMessage(CMD_START_SCAN, message.arg1, message.arg2, bundle);
            mBufferedScanMsg.add(msg);
        } else {
            // if too many requests in buffer, combine them into a single full scan
            bundle = new Bundle();
            bundle.putParcelable(CUSTOMIZED_SCAN_SETTING, null);
            bundle.putParcelable(CUSTOMIZED_SCAN_WORKSOURCE, workSource);
            Message msg = obtainMessage(CMD_START_SCAN, message.arg1, message.arg2, bundle);
            mBufferedScanMsg.clear();
            mBufferedScanMsg.add(msg);
        }
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_LOOPED;
    } else {
        // mIsScanOngoing and mIsFullScanOngoing
        messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
    }
}
#end_block

#method_before
// TODO this is a temporary measure to bridge between WifiScanner and WifiStateMachine until
// scan functionality is refactored out of WifiStateMachine.
private boolean startScanNative(final Set<Integer> freqs, Set<Integer> hiddenNetworkIds, WorkSource workSource) {
    WifiScanner.ScanSettings settings = new WifiScanner.ScanSettings();
    if (freqs == null) {
        settings.band = WifiScanner.WIFI_BAND_BOTH_WITH_DFS;
    } else {
        settings.band = WifiScanner.WIFI_BAND_UNSPECIFIED;
        int index = 0;
        settings.channels = new WifiScanner.ChannelSpec[freqs.size()];
        for (Integer freq : freqs) {
            settings.channels[index++] = new WifiScanner.ChannelSpec(freq);
        }
    }
    settings.reportEvents = WifiScanner.REPORT_EVENT_AFTER_EACH_SCAN | WifiScanner.REPORT_EVENT_FULL_SCAN_RESULT;
    if (hiddenNetworkIds != null && hiddenNetworkIds.size() > 0) {
        int i = 0;
        settings.hiddenNetworkIds = new int[hiddenNetworkIds.size()];
        for (Integer netId : hiddenNetworkIds) {
            settings.hiddenNetworkIds[i++] = netId;
        }
    }
    WifiScanner.ScanListener nativeScanListener = new WifiScanner.ScanListener() {

        // ignore all events since WifiStateMachine is registered for the supplicant events
        @Override
        public void onSuccess() {
        }

        @Override
        public void onFailure(int reason, String description) {
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
        }

        @Override
        public void onResults(WifiScanner.ScanData[] results) {
        }

        @Override
        public void onFullResult(ScanResult fullScanResult) {
        }

        @Override
        public void onPeriodChanged(int periodInMs) {
        }
    };
    mWifiScanner.startScan(settings, nativeScanListener, workSource);
    mIsScanOngoing = true;
    mIsFullScanOngoing = (freqs == null);
    lastScanFreqs = freqs;
    return true;
}
#method_after
// TODO this is a temporary measure to bridge between WifiScanner and WifiStateMachine until
// scan functionality is refactored out of WifiStateMachine.
private boolean startScanNative(final Set<Integer> freqs, List<WifiScanner.ScanSettings.HiddenNetwork> hiddenNetworkList, WorkSource workSource) {
    WifiScanner.ScanSettings settings = new WifiScanner.ScanSettings();
    if (freqs == null) {
        settings.band = WifiScanner.WIFI_BAND_BOTH_WITH_DFS;
    } else {
        settings.band = WifiScanner.WIFI_BAND_UNSPECIFIED;
        int index = 0;
        settings.channels = new WifiScanner.ChannelSpec[freqs.size()];
        for (Integer freq : freqs) {
            settings.channels[index++] = new WifiScanner.ChannelSpec(freq);
        }
    }
    settings.reportEvents = WifiScanner.REPORT_EVENT_AFTER_EACH_SCAN | WifiScanner.REPORT_EVENT_FULL_SCAN_RESULT;
    settings.hiddenNetworks = hiddenNetworkList.toArray(new WifiScanner.ScanSettings.HiddenNetwork[hiddenNetworkList.size()]);
    WifiScanner.ScanListener nativeScanListener = new WifiScanner.ScanListener() {

        // ignore all events since WifiStateMachine is registered for the supplicant events
        @Override
        public void onSuccess() {
        }

        @Override
        public void onFailure(int reason, String description) {
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
        }

        @Override
        public void onResults(WifiScanner.ScanData[] results) {
        }

        @Override
        public void onFullResult(ScanResult fullScanResult) {
        }

        @Override
        public void onPeriodChanged(int periodInMs) {
        }
    };
    mWifiScanner.startScan(settings, nativeScanListener, workSource);
    mIsScanOngoing = true;
    mIsFullScanOngoing = (freqs == null);
    lastScanFreqs = freqs;
    return true;
}
#end_block

#method_before
public boolean syncQueryPasspointIcon(AsyncChannel channel, long bssid, String fileName) {
    Bundle bundle = new Bundle();
    bundle.putLong("BSSID", bssid);
    bundle.putString("FILENAME", fileName);
    Message resultMsg = channel.sendMessageSynchronously(CMD_QUERY_OSU_ICON, bundle);
    int result = resultMsg.arg1;
    resultMsg.recycle();
    return result == 1;
}
#method_after
public boolean syncQueryPasspointIcon(AsyncChannel channel, long bssid, String fileName) {
    Bundle bundle = new Bundle();
    bundle.putLong(EXTRA_OSU_ICON_QUERY_BSSID, bssid);
    bundle.putString(EXTRA_OSU_ICON_QUERY_FILENAME, fileName);
    Message resultMsg = channel.sendMessageSynchronously(CMD_QUERY_OSU_ICON, bundle);
    int result = resultMsg.arg1;
    resultMsg.recycle();
    return result == 1;
}
#end_block

#method_before
/**
 * Get adaptors synchronously
 */
public int syncGetSupportedFeatures(AsyncChannel channel) {
    Message resultMsg = channel.sendMessageSynchronously(CMD_GET_SUPPORTED_FEATURES);
    int supportedFeatureSet = resultMsg.arg1;
    resultMsg.recycle();
    return supportedFeatureSet;
}
#method_after
/**
 * Get adaptors synchronously
 */
public int syncGetSupportedFeatures(AsyncChannel channel) {
    Message resultMsg = channel.sendMessageSynchronously(CMD_GET_SUPPORTED_FEATURES);
    int supportedFeatureSet = resultMsg.arg1;
    resultMsg.recycle();
    // Mask the feature set against system properties.
    boolean disableRtt = mPropertyService.getBoolean("config.disable_rtt", false);
    if (disableRtt) {
        supportedFeatureSet &= ~(WifiManager.WIFI_FEATURE_D2D_RTT | WifiManager.WIFI_FEATURE_D2AP_RTT);
    }
    return supportedFeatureSet;
}
#end_block

#method_before
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("Supplicant status " + mWifiNative.status(true));
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    updateWifiMetrics();
    mWifiMetrics.dump(fd, pw, args);
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    mWifiQualifiedNetworkSelector.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    if (mWifiConnectivityManager != null) {
        mWifiConnectivityManager.dump(fd, pw, args);
    }
}
#method_after
@Override
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    if (args.length > 1 && WifiMetrics.PROTO_DUMP_ARG.equals(args[0]) && WifiMetrics.CLEAN_DUMP_ARG.equals(args[1])) {
        // Dump only wifi metrics serialized proto bytes (base64)
        updateWifiMetrics();
        mWifiMetrics.dump(fd, pw, args);
        return;
    }
    super.dump(fd, pw, args);
    mSupplicantStateTracker.dump(fd, pw, args);
    pw.println("mLinkProperties " + mLinkProperties);
    pw.println("mWifiInfo " + mWifiInfo);
    pw.println("mDhcpResults " + mDhcpResults);
    pw.println("mNetworkInfo " + mNetworkInfo);
    pw.println("mLastSignalLevel " + mLastSignalLevel);
    pw.println("mLastBssid " + mLastBssid);
    pw.println("mLastNetworkId " + mLastNetworkId);
    pw.println("mOperationalMode " + mOperationalMode);
    pw.println("mUserWantsSuspendOpt " + mUserWantsSuspendOpt);
    pw.println("mSuspendOptNeedsDisabled " + mSuspendOptNeedsDisabled);
    pw.println("Supplicant status " + mWifiNative.status(true));
    if (mCountryCode.getCountryCodeSentToDriver() != null) {
        pw.println("CountryCode sent to driver " + mCountryCode.getCountryCodeSentToDriver());
    } else {
        if (mCountryCode.getCountryCode() != null) {
            pw.println("CountryCode: " + mCountryCode.getCountryCode() + " was not sent to driver");
        } else {
            pw.println("CountryCode was not initialized");
        }
    }
    if (mNetworkFactory != null) {
        mNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mNetworkFactory is not initialized");
    }
    if (mUntrustedNetworkFactory != null) {
        mUntrustedNetworkFactory.dump(fd, pw, args);
    } else {
        pw.println("mUntrustedNetworkFactory is not initialized");
    }
    pw.println("Wlan Wake Reasons:" + mWifiNative.getWlanWakeReasonCount());
    pw.println();
    updateWifiMetrics();
    mWifiMetrics.dump(fd, pw, args);
    pw.println();
    mWifiConfigManager.dump(fd, pw, args);
    pw.println();
    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_USER_ACTION);
    mWifiDiagnostics.dump(fd, pw, args);
    dumpIpManager(fd, pw, args);
    mWifiNetworkSelector.dump(fd, pw, args);
}
#end_block

#method_before
private void fetchRssiLinkSpeedAndFrequencyNative() {
    Integer newRssi = null;
    Integer newLinkSpeed = null;
    Integer newFrequency = null;
    String signalPoll = mWifiNative.signalPoll();
    if (signalPoll != null) {
        String[] lines = signalPoll.split("\n");
        for (String line : lines) {
            String[] prop = line.split("=");
            if (prop.length < 2)
                continue;
            try {
                if (prop[0].equals("RSSI")) {
                    newRssi = Integer.parseInt(prop[1]);
                } else if (prop[0].equals("LINKSPEED")) {
                    newLinkSpeed = Integer.parseInt(prop[1]);
                } else if (prop[0].equals("FREQUENCY")) {
                    newFrequency = Integer.parseInt(prop[1]);
                }
            } catch (NumberFormatException e) {
            // Ignore, defaults on rssi and linkspeed are assigned
            }
        }
    }
    if (mVerboseLoggingEnabled) {
        logd("fetchRssiLinkSpeedAndFrequencyNative rssi=" + newRssi + " linkspeed=" + newLinkSpeed + " freq=" + newFrequency);
    }
    if (newRssi != null && newRssi > WifiInfo.INVALID_RSSI && newRssi < WifiInfo.MAX_RSSI) {
        /* some implementations avoid negative values by adding 256
             * so we need to adjust for that here.
             */
        if (newRssi > 0)
            newRssi -= 256;
        mWifiInfo.setRssi(newRssi);
        /*
             * Log the rssi poll value in metrics
             */
        mWifiMetrics.incrementRssiPollRssiCount(newRssi);
        /*
             * Rather then sending the raw RSSI out every time it
             * changes, we precalculate the signal level that would
             * be displayed in the status bar, and only send the
             * broadcast if that much more coarse-grained number
             * changes. This cuts down greatly on the number of
             * broadcasts, at the cost of not informing others
             * interested in RSSI of all the changes in signal
             * level.
             */
        int newSignalLevel = WifiManager.calculateSignalLevel(newRssi, WifiManager.RSSI_LEVELS);
        if (newSignalLevel != mLastSignalLevel) {
            updateCapabilities(getCurrentWifiConfiguration());
            sendRssiChangeBroadcast(newRssi);
        }
        mLastSignalLevel = newSignalLevel;
    } else {
        mWifiInfo.setRssi(WifiInfo.INVALID_RSSI);
        updateCapabilities(getCurrentWifiConfiguration());
    }
    if (newLinkSpeed != null) {
        mWifiInfo.setLinkSpeed(newLinkSpeed);
    }
    if (newFrequency != null && newFrequency > 0) {
        if (ScanResult.is5GHz(newFrequency)) {
            mWifiConnectionStatistics.num5GhzConnected++;
        }
        if (ScanResult.is24GHz(newFrequency)) {
            mWifiConnectionStatistics.num24GhzConnected++;
        }
        mWifiInfo.setFrequency(newFrequency);
    }
    mWifiConfigManager.updateScanDetailCacheFromWifiInfo(mWifiInfo);
}
#method_after
private void fetchRssiLinkSpeedAndFrequencyNative() {
    Integer newRssi = null;
    Integer newLinkSpeed = null;
    Integer newFrequency = null;
    int[] poll_result = null;
    try {
        poll_result = mClientInterface.signalPoll();
        if (poll_result == null || poll_result.length != 2) {
            return;
        }
    } catch (RemoteException e1) {
    }
    newRssi = poll_result[0];
    newLinkSpeed = poll_result[1];
    // Ideally we shoudn't rely on signal polls to update frequency: b/31595463.
    // TODO(nywang): When wificond finally takes over the scanning
    // function, we should cache the frequency of asscociated ap from scan results.
    String signalPoll = mWifiNative.signalPoll();
    if (signalPoll != null) {
        String[] lines = signalPoll.split("\n");
        for (String line : lines) {
            String[] prop = line.split("=");
            if (prop.length < 2)
                continue;
            try {
                if (prop[0].equals("FREQUENCY")) {
                    newFrequency = Integer.parseInt(prop[1]);
                }
            } catch (NumberFormatException e) {
            // Ignore, defaults on rssi and linkspeed are assigned
            }
        }
    }
    if (mVerboseLoggingEnabled) {
        logd("fetchRssiLinkSpeedAndFrequencyNative rssi=" + newRssi + " linkspeed=" + newLinkSpeed + " freq=" + newFrequency);
    }
    if (newRssi != null && newRssi > WifiInfo.INVALID_RSSI && newRssi < WifiInfo.MAX_RSSI) {
        /* some implementations avoid negative values by adding 256
             * so we need to adjust for that here.
             */
        if (newRssi > 0)
            newRssi -= 256;
        mWifiInfo.setRssi(newRssi);
        /*
             * Log the rssi poll value in metrics
             */
        mWifiMetrics.incrementRssiPollRssiCount(newRssi);
        /*
             * Rather then sending the raw RSSI out every time it
             * changes, we precalculate the signal level that would
             * be displayed in the status bar, and only send the
             * broadcast if that much more coarse-grained number
             * changes. This cuts down greatly on the number of
             * broadcasts, at the cost of not informing others
             * interested in RSSI of all the changes in signal
             * level.
             */
        int newSignalLevel = WifiManager.calculateSignalLevel(newRssi, WifiManager.RSSI_LEVELS);
        if (newSignalLevel != mLastSignalLevel) {
            updateCapabilities(getCurrentWifiConfiguration());
            sendRssiChangeBroadcast(newRssi);
        }
        mLastSignalLevel = newSignalLevel;
    } else {
        mWifiInfo.setRssi(WifiInfo.INVALID_RSSI);
        updateCapabilities(getCurrentWifiConfiguration());
    }
    if (newLinkSpeed != null) {
        mWifiInfo.setLinkSpeed(newLinkSpeed);
    }
    if (newFrequency != null && newFrequency > 0) {
        if (ScanResult.is5GHz(newFrequency)) {
            mWifiConnectionStatistics.num5GhzConnected++;
        }
        if (ScanResult.is24GHz(newFrequency)) {
            mWifiConnectionStatistics.num24GhzConnected++;
        }
        mWifiInfo.setFrequency(newFrequency);
    }
    mWifiConfigManager.updateScanDetailCacheFromWifiInfo(mWifiInfo);
}
#end_block

#method_before
private void fetchPktcntNative(RssiPacketCountInfo info) {
    String pktcntPoll = mWifiNative.pktcntPoll();
    if (pktcntPoll != null) {
        String[] lines = pktcntPoll.split("\n");
        for (String line : lines) {
            String[] prop = line.split("=");
            if (prop.length < 2)
                continue;
            try {
                if (prop[0].equals("TXGOOD")) {
                    info.txgood = Integer.parseInt(prop[1]);
                } else if (prop[0].equals("TXBAD")) {
                    info.txbad = Integer.parseInt(prop[1]);
                }
            } catch (NumberFormatException e) {
            // Ignore
            }
        }
    }
}
#method_after
private void fetchPktcntNative(RssiPacketCountInfo info) {
    int[] counters = null;
    try {
        counters = mClientInterface.getPacketCounters();
        if (counters == null || counters.length != 2) {
            return;
        }
    } catch (RemoteException e1) {
    }
    info.txgood = counters[0];
    info.txbad = counters[1];
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                    } else {
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CAPABILITY_FREQ:
            replyToMessage(message, message.what, null);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_BOOT_COMPLETED:
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_SET_FREQUENCY_BAND:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            mWifiConfigManager.handleUserSwitch(message.arg1);
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_ADD_PASSPOINT_MO:
        case CMD_MODIFY_PASSPOINT_MO:
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case AsyncChannel.CMD_CHANNEL_HALF_CONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    if (message.arg1 == AsyncChannel.STATUS_SUCCESSFUL) {
                        p2pSendMessage(AsyncChannel.CMD_CHANNEL_FULL_CONNECTION);
                    } else {
                        loge("WifiP2pService connection failure, error=" + message.arg1);
                    }
                } else {
                    loge("got HALF_CONNECTED for unknown channel");
                }
                break;
            }
        case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
            {
                AsyncChannel ac = (AsyncChannel) message.obj;
                if (ac == mWifiP2pChannel) {
                    loge("WifiP2pService channel lost, message.arg1 =" + message.arg1);
                // TODO: Re-establish connection to state machine after a delay
                // mWifiP2pChannel.connect(mContext, getHandler(),
                // mWifiP2pManager.getMessenger());
                }
                break;
            }
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            break;
        /* Synchronous call returns */
        case CMD_PING_SUPPLICANT:
        case CMD_ENABLE_NETWORK:
        case CMD_ADD_OR_UPDATE_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_SAVE_CONFIG:
            replyToMessage(message, message.what, FAILURE);
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, (List<WifiConfiguration>) null);
            break;
        case CMD_ENABLE_RSSI_POLL:
            mEnableRssiPolling = (message.arg1 == 1);
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_BOOT_COMPLETED:
            maybeRegisterNetworkFactory();
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        /* Discard */
        case CMD_START_SCAN:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_STOP_SUPPLICANT_FAILED:
        case CMD_DRIVER_START_TIMED_OUT:
        case CMD_START_AP:
        case CMD_START_AP_FAILURE:
        case CMD_STOP_AP:
        case CMD_AP_STOPPED:
        case CMD_DISCONNECT:
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
        case CMD_RELOAD_TLS_AND_RECONNECT:
        case WifiMonitor.SUP_CONNECTION_EVENT:
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
        case WifiMonitor.WPS_OVERLAP_EVENT:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_RSSI_POLL:
        case DhcpClient.CMD_PRE_DHCP_ACTION:
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
        case DhcpClient.CMD_POST_DHCP_ACTION:
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
        case CMD_DISABLE_P2P_RSP:
        case WifiMonitor.SUP_REQUEST_IDENTITY:
        case CMD_TEST_NETWORK_DISCONNECT:
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
        case CMD_TARGET_BSSID:
        case CMD_START_CONNECT:
        case CMD_START_ROAM:
        case CMD_ASSOCIATED_BSSID:
        case CMD_UNWANTED_NETWORK:
        case CMD_DISCONNECTING_WATCHDOG_TIMER:
        case CMD_ROAM_WATCHDOG_TIMER:
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, true);
            } else {
                setSuspendOptimizations(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case WifiMonitor.DRIVER_HUNG_EVENT:
            setSupplicantRunning(false);
            setSupplicantRunning(true);
            break;
        case WifiManager.CONNECT_NETWORK:
            replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.FORGET_NETWORK:
            replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.SAVE_NETWORK:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.START_WPS:
            replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.CANCEL_WPS:
            replyToMessage(message, WifiManager.CANCEL_WPS_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.DISABLE_NETWORK:
            replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.BUSY);
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_FAILED, WifiManager.BUSY);
            break;
        case CMD_GET_SUPPORTED_FEATURES:
            int featureSet = mWifiNative.getSupportedFeatureSet();
            replyToMessage(message, message.what, featureSet);
            break;
        case CMD_FIRMWARE_ALERT:
            if (mWifiDiagnostics != null) {
                byte[] buffer = (byte[]) message.obj;
                int alertReason = message.arg1;
                mWifiDiagnostics.captureAlertData(alertReason, buffer);
                mWifiMetrics.incrementAlertReasonCount(alertReason);
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            // Not supported hence reply with error message
            replyToMessage(message, message.what, null);
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            mTemporarilyDisconnectWifi = (message.arg1 == 1);
            replyToMessage(message, WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
            break;
        /* Link configuration (IP address, DNS, ...) changes notified via netlink */
        case CMD_UPDATE_LINKPROPERTIES:
            updateLinkProperties((LinkProperties) message.obj);
            break;
        case CMD_GET_MATCHING_CONFIG:
            replyToMessage(message, message.what);
            break;
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
        case CMD_IP_CONFIGURATION_LOST:
        case CMD_IP_REACHABILITY_LOST:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_GET_CONNECTION_STATISTICS:
            replyToMessage(message, message.what, mWifiConnectionStatistics);
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            deferMessage(message);
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            if (mNetworkAgent != null)
                mNetworkAgent.onPacketKeepaliveEvent(message.arg1, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            break;
        case CMD_USER_SWITCH:
            mWifiConfigManager.handleUserSwitch(message.arg1);
            break;
        case CMD_USER_UNLOCK:
            mWifiConfigManager.handleUserUnlock(message.arg1);
            break;
        case CMD_USER_STOP:
            mWifiConfigManager.handleUserStop(message.arg1);
            break;
        case CMD_ADD_PASSPOINT_MO:
        case CMD_MODIFY_PASSPOINT_MO:
        case CMD_QUERY_OSU_ICON:
        case CMD_MATCH_PROVIDER_NETWORK:
            /* reply with arg1 = 0 - it returns API failure to the calling app
                     * (message.what is not looked at)
                     */
            replyToMessage(message, message.what);
            break;
        case CMD_RESET_SIM_NETWORKS:
            /* Defer this message until supplicant is started. */
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        case CMD_INSTALL_PACKET_FILTER:
            mWifiNative.installPacketFilter((byte[]) message.obj);
            break;
        case CMD_SET_FALLBACK_PACKET_FILTERING:
            if ((boolean) message.obj) {
                mWifiNative.startFilteringMulticastV4Packets();
            } else {
                mWifiNative.stopFilteringMulticastV4Packets();
            }
            break;
        case CMD_CLIENT_INTERFACE_BINDER_DEATH:
            // We have lost contact with a client interface, which means that we cannot
            // trust that the driver is up or that the interface is ready.  We are fit
            // for no WiFi related work.
            transitionTo(mInitialState);
            break;
        default:
            loge("Error! unhandled message" + message);
            break;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    cleanup();
    if (mWifiP2pChannel == null && mWifiP2pServiceImpl != null) {
        mWifiP2pChannel = new AsyncChannel();
        mWifiP2pChannel.connect(mContext, getHandler(), mWifiP2pServiceImpl.getP2pStateMachineMessenger());
    }
    if (mWifiApConfigStore == null) {
        mWifiApConfigStore = mFacade.makeApConfigStore(mContext, mBackupManagerProxy);
    }
}
#method_after
@Override
public void enter() {
    cleanup();
    if (mWifiP2pChannel == null && mWifiP2pServiceImpl != null) {
        mWifiP2pChannel = new AsyncChannel();
        mWifiP2pChannel.connect(mContext, getHandler(), mWifiP2pServiceImpl.getP2pStateMachineMessenger());
    }
    if (mWifiApConfigStore == null) {
        mWifiApConfigStore = mWifiInjector.getWifiApConfigStore();
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            mClientInterface = setupDriverForClientMode(mWificond);
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash can leave the interface up and
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure interface is down and we have no IP
                // addresses before a supplicant start.
                mNwService.setInterfaceDown(mInterfaceName);
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.startHal()) {
                // starting HAL is optional
                Log.e(TAG, "Failed to start HAL for client mode");
            }
            try {
                if (!mClientInterface.enableSupplicant()) {
                    loge("Failed to start supplicant!");
                    setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                    cleanup();
                    break;
                }
            } catch (RemoteException e) {
                cleanup();
                break;
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_START_SUPPLICANT:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            mClientInterface = setupDriverForClientMode(mWificond);
            if (mClientInterface == null || !mDeathRecipient.linkToDeath(mClientInterface.asBinder())) {
                setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                cleanup();
                break;
            }
            try {
                // A runtime crash or shutting down AP mode can leave
                // IP addresses configured, and this affects
                // connectivity when supplicant starts up.
                // Ensure we have no IP addresses before a supplicant start.
                mNwService.clearInterfaceAddresses(mInterfaceName);
                // Set privacy extensions
                mNwService.setInterfaceIpv6PrivacyExtensions(mInterfaceName, true);
                // IPv6 is enabled only as long as access point is connected since:
                // - IPv6 addresses and routes stick around after disconnection
                // - kernel is unaware when connected and fails to start IPv6 negotiation
                // - kernel can start autoconfiguration when 802.1x is not complete
                mNwService.disableIpv6(mInterfaceName);
            } catch (RemoteException re) {
                loge("Unable to change interface settings: " + re);
            } catch (IllegalStateException ie) {
                loge("Unable to change interface settings: " + ie);
            }
            if (!mWifiNative.startHal()) {
                // starting HAL is optional
                Log.e(TAG, "Failed to start HAL for client mode");
            }
            try {
                if (!mClientInterface.enableSupplicant()) {
                    loge("Failed to start supplicant!");
                    setWifiState(WifiManager.WIFI_STATE_UNKNOWN);
                    cleanup();
                    break;
                }
            } catch (RemoteException e) {
                cleanup();
                break;
            }
            setSupplicantLogLevel();
            setWifiState(WIFI_STATE_ENABLING);
            if (mVerboseLoggingEnabled)
                log("Supplicant start successful");
            mWifiMonitor.startMonitoring(mInterfaceName);
            transitionTo(mSupplicantStartingState);
            break;
        case CMD_START_AP:
            // Refresh our reference to wificond.  This allows us to tolerate restarts.
            mWificond = mWifiInjector.makeWificond();
            transitionTo(mSoftApState);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode != DISABLED_MODE) {
                sendMessage(CMD_START_SUPPLICANT);
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection established");
            setWifiState(WIFI_STATE_ENABLED);
            mSupplicantRestartCount = 0;
            /* Reset the supplicant state to indicate the supplicant
                     * state is not known at this time */
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            /* Initialize data structures */
            mLastBssid = null;
            mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
            mLastSignalLevel = -1;
            mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
            /* set frequency band of operation */
            setFrequencyBand();
            mWifiConfigManager.loadFromStore();
            initializeWpsDetails();
            sendSupplicantConnectionChangedBroadcast(true);
            transitionTo(mSupplicantStartedState);
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
                loge("Failed to setup control channel, restart supplicant");
                mWifiMonitor.stopAllMonitoring();
                try {
                    mClientInterface.disableSupplicant();
                } catch (RemoteException e) {
                // The client interface is dead, there is nothing more we can do.
                }
                transitionTo(mInitialState);
                sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            } else {
                loge("Failed " + mSupplicantRestartCount + " times to start supplicant, unload driver");
                mSupplicantRestartCount = 0;
                setWifiState(WIFI_STATE_UNKNOWN);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_SET_FREQUENCY_BAND:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection established");
            setWifiState(WIFI_STATE_ENABLED);
            mSupplicantRestartCount = 0;
            /* Reset the supplicant state to indicate the supplicant
                     * state is not known at this time */
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            /* Initialize data structures */
            mLastBssid = null;
            mLastNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
            mLastSignalLevel = -1;
            mWifiInfo.setMacAddress(mWifiNative.getMacAddress());
            mWifiConfigManager.loadFromStore();
            initializeWpsDetails();
            sendSupplicantConnectionChangedBroadcast(true);
            transitionTo(mSupplicantStartedState);
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (++mSupplicantRestartCount <= SUPPLICANT_RESTART_TRIES) {
                loge("Failed to setup control channel, restart supplicant");
                mWifiMonitor.stopAllMonitoring();
                try {
                    mClientInterface.disableSupplicant();
                } catch (RemoteException e) {
                // The client interface is dead, there is nothing more we can do.
                }
                transitionTo(mInitialState);
                sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            } else {
                loge("Failed " + mSupplicantRestartCount + " times to start supplicant, unload driver");
                mSupplicantRestartCount = 0;
                setWifiState(WIFI_STATE_UNKNOWN);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    /* Wifi is available as long as we have a connection to supplicant */
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = new WifiConnectivityManager(mContext, WifiStateMachine.this, mWifiScanner, mWifiConfigManager, mWifiInfo, mWifiQualifiedNetworkSelector, mWifiInjector, getHandler().getLooper(), hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    /* initialize network state */
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    if (mNanSupported && mWifiNanManager != null) {
        if (mOperationalMode == CONNECT_MODE) {
            mWifiNanManager.enableUsage();
        } else {
        /*
                     * NAN state machine starts in disabled state. Nothing
                     * needed to keep it disabled.
                     */
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#method_after
@Override
public void enter() {
    if (mVerboseLoggingEnabled) {
        logd("SupplicantStartedState enter");
    }
    /* Wifi is available as long as we have a connection to supplicant */
    mNetworkInfo.setIsAvailable(true);
    if (mNetworkAgent != null)
        mNetworkAgent.sendNetworkInfo(mNetworkInfo);
    int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_supplicant_scan_interval);
    mSupplicantScanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SUPPLICANT_SCAN_INTERVAL_MS, defaultInterval);
    mWifiNative.setScanInterval((int) mSupplicantScanIntervalMs / 1000);
    mWifiNative.setExternalSim(true);
    /* turn on use of DFS channels */
    mWifiNative.setDfsFlag(true);
    setRandomMacOui();
    mWifiNative.enableAutoConnect(false);
    mCountryCode.setReadyForChange(true);
    // wifi scanning service is initialized
    if (mWifiScanner == null) {
        mWifiScanner = mWifiInjector.getWifiScanner();
        synchronized (mWifiReqCountLock) {
            mWifiConnectivityManager = new WifiConnectivityManager(mContext, WifiStateMachine.this, mWifiScanner, mWifiConfigManager, mWifiInfo, mWifiNetworkSelector, mWifiInjector, getHandler().getLooper(), hasConnectionRequests());
            mWifiConnectivityManager.setUntrustedConnectionAllowed(mUntrustedReqCount > 0);
            mWifiConnectivityManager.handleScreenStateChanged(mScreenOn);
        }
    }
    mWifiDiagnostics.startLogging(mVerboseLoggingEnabled);
    mIsRunning = true;
    updateBatteryWorkSource(null);
    /**
     * Enable bluetooth coexistence scan mode when bluetooth connection is active.
     * When this mode is on, some of the low-level scan parameters used by the
     * driver are changed to reduce interference with bluetooth
     */
    mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
    /* initialize network state */
    setNetworkDetailedState(DetailedState.DISCONNECTED);
    // Disable legacy multicast filtering, which on some chipsets defaults to enabled.
    // Legacy IPv6 multicast filtering blocks ICMPv6 router advertisements which breaks IPv6
    // provisioning. Legacy IPv4 multicast filtering may be re-enabled later via
    // IpManager.Callback.setFallbackMulticastFilter()
    mWifiNative.stopFilteringMulticastV4Packets();
    mWifiNative.stopFilteringMulticastV6Packets();
    if (mOperationalMode == SCAN_ONLY_MODE || mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
        mWifiNative.disconnect();
        if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
            setWifiState(WIFI_STATE_DISABLED);
        }
        transitionTo(mScanModeState);
    } else if (mOperationalMode == CONNECT_MODE) {
        // Status pulls in the current supplicant state and network connection state
        // events over the monitor connection. This helps framework sync up with
        // current supplicant state
        // TODO: actually check the supplicant status string and make sure the supplicant
        // is in disconnecte4d state.
        mWifiNative.status();
        // Transitioning to Disconnected state will trigger a scan and subsequently AutoJoin
        transitionTo(mDisconnectedState);
    } else if (mOperationalMode == DISABLED_MODE) {
        transitionTo(mSupplicantStoppingState);
    }
    // Set the right suspend mode settings
    mWifiNative.setSuspendOptimizations(mSuspendOptNeedsDisabled == 0 && mUserWantsSuspendOpt.get());
    mWifiNative.setPowerSave(true);
    if (mP2pSupported) {
        if (mOperationalMode == CONNECT_MODE) {
            p2pSendMessage(WifiStateMachine.CMD_ENABLE_P2P);
        } else {
        // P2P state machine starts in disabled state, and is not enabled until
        // CMD_ENABLE_P2P is sent from here; so, nothing needs to be done to
        // keep it disabled.
        }
    }
    if (mNanSupported && mWifiNanManager != null) {
        if (mOperationalMode == CONNECT_MODE) {
            mWifiNanManager.enableUsage();
        } else {
        /*
                     * NAN state machine starts in disabled state. Nothing
                     * needed to keep it disabled.
                     */
        }
    }
    final Intent intent = new Intent(WifiManager.WIFI_SCAN_AVAILABLE);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    intent.putExtra(WifiManager.EXTRA_SCAN_AVAILABLE, WIFI_STATE_ENABLED);
    mContext.sendStickyBroadcastAsUser(intent, UserHandle.ALL);
    // Enable link layer stats gathering
    mWifiNative.setWifiLinkLayerStats("wlan0", 1);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            if (mIsFullScanOngoing || mSendScanResultsBroadcast) {
                /* Just updated results from full scan, let apps know about this */
                boolean scanSucceeded = message.what == WifiMonitor.SCAN_RESULTS_EVENT;
                sendScanResultsAvailableBroadcast(scanSucceeded);
            }
            mSendScanResultsBroadcast = false;
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_SET_FREQUENCY_BAND:
            int band = message.arg1;
            if (mVerboseLoggingEnabled)
                log("set frequency band " + band);
            if (mWifiNative.setBand(band)) {
                if (mVerboseLoggingEnabled)
                    logd("did set frequency band " + band);
                mFrequencyBand.set(band);
                // Flush old data - like scan results
                mWifiNative.bssFlush();
                if (mVerboseLoggingEnabled)
                    logd("done set frequency band " + band);
            } else {
                loge("Failed to set frequency band " + band);
            }
            break;
        case CMD_GET_CAPABILITY_FREQ:
            String freqs = mWifiNative.getFreqCapability();
            replyToMessage(message, message.what, freqs);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for ANQP requests.
            mPasspointManager.notifyANQPDone((long) message.obj, message.arg1 != 0);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for icon requests.
            IconEvent event = (IconEvent) message.obj;
            mPasspointManager.notifyIconDone(event.getBSSID(), event);
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for WNM frames
            // monitoring.
            mPasspointManager.receivedWnmFrame((WnmData) message.obj);
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            if (mWifiConnectivityManager != null) {
                mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            }
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                if (mWifiConnectivityManager != null) {
                    mWifiConnectivityManager.forceConnectivityScan();
                }
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_STOP_SUPPLICANT:
            /* Supplicant stopped by user */
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            /* Supplicant connection lost */
            loge("Connection lost, restart supplicant");
            handleSupplicantConnectionLoss(true);
            handleNetworkDisconnect();
            mSupplicantStateTracker.sendMessage(CMD_RESET_SUPPLICANT_STATE);
            if (mP2pSupported) {
                transitionTo(mWaitForP2pDisableState);
            } else {
                transitionTo(mInitialState);
            }
            sendMessageDelayed(CMD_START_SUPPLICANT, SUPPLICANT_RESTART_INTERVAL_MSECS);
            break;
        case CMD_START_SCAN:
            // TODO: remove scan request path (b/31445200)
            handleScanRequest(message);
            break;
        case WifiMonitor.SCAN_RESULTS_EVENT:
        case WifiMonitor.SCAN_FAILED_EVENT:
            // TODO: remove handing of SCAN_RESULTS_EVENT and SCAN_FAILED_EVENT when scan
            // results are retrieved from WifiScanner (b/31444878)
            // Make sure our NetworkFactory is registered
            maybeRegisterNetworkFactory();
            setScanResults();
            mIsScanOngoing = false;
            mIsFullScanOngoing = false;
            if (mBufferedScanMsg.size() > 0)
                sendMessage(mBufferedScanMsg.remove());
            break;
        case CMD_PING_SUPPLICANT:
            boolean ok = mWifiNative.ping();
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_START_AP:
            /* Cannot start soft AP while in client mode */
            loge("Failed to start soft AP with a running supplicant");
            setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
            break;
        case CMD_SET_OPERATIONAL_MODE:
            mOperationalMode = message.arg1;
            if (mOperationalMode == DISABLED_MODE) {
                transitionTo(mSupplicantStoppingState);
            }
            break;
        case CMD_TARGET_BSSID:
            // Trying to associate to this BSSID
            if (message.obj != null) {
                mTargetRoamBSSID = (String) message.obj;
            }
            break;
        case CMD_GET_LINK_LAYER_STATS:
            WifiLinkLayerStats stats = getWifiLinkLayerStats();
            replyToMessage(message, message.what, stats);
            break;
        case CMD_RESET_SIM_NETWORKS:
            log("resetting EAP-SIM/AKA/AKA' networks since SIM was changed");
            mWifiConfigManager.resetSimNetworks();
            break;
        case CMD_BLUETOOTH_ADAPTER_STATE_CHANGE:
            mBluetoothConnectionActive = (message.arg1 != BluetoothAdapter.STATE_DISCONNECTED);
            mWifiNative.setBluetoothCoexistenceScanMode(mBluetoothConnectionActive);
            break;
        case CMD_SET_SUSPEND_OPT_ENABLED:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, true);
                if (message.arg2 == 1) {
                    mSuspendWakeLock.release();
                }
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_SCREEN, false);
            }
            break;
        case CMD_SET_HIGH_PERF_MODE:
            if (message.arg1 == 1) {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, false);
            } else {
                setSuspendOptimizationsNative(SUSPEND_DUE_TO_HIGH_PERF, true);
            }
            break;
        case CMD_ENABLE_TDLS:
            if (message.obj != null) {
                String remoteAddress = (String) message.obj;
                boolean enable = (message.arg1 == 1);
                mWifiNative.startTdls(remoteAddress, enable);
            }
            break;
        case WifiMonitor.ANQP_DONE_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for ANQP requests.
            mPasspointManager.notifyANQPDone((long) message.obj, message.arg1 != 0);
            break;
        case CMD_STOP_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int ret = stopWifiIPPacketOffload(slot);
                if (mNetworkAgent != null) {
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ret);
                }
                break;
            }
        case WifiMonitor.RX_HS20_ANQP_ICON_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for icon requests.
            IconEvent event = (IconEvent) message.obj;
            mPasspointManager.notifyIconDone(event.getBSSID(), event);
            break;
        case WifiMonitor.HS20_REMEDIATION_EVENT:
            // TODO(zqiu): remove this when switch over to wificond for WNM frames
            // monitoring.
            mPasspointManager.receivedWnmFrame((WnmData) message.obj);
            break;
        case CMD_CONFIG_ND_OFFLOAD:
            final boolean enabled = (message.arg1 > 0);
            mWifiNative.configureNeighborDiscoveryOffload(enabled);
            break;
        case CMD_ENABLE_WIFI_CONNECTIVITY_MANAGER:
            mWifiConnectivityManager.enable(message.arg1 == 1 ? true : false);
            break;
        case CMD_ENABLE_AUTOJOIN_WHEN_ASSOCIATED:
            final boolean allowed = (message.arg1 > 0);
            boolean old_state = mEnableAutoJoinWhenAssociated;
            mEnableAutoJoinWhenAssociated = allowed;
            if (!old_state && allowed && mScreenOn && getCurrentState() == mConnectedState) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            loge("Supplicant connection received while stopping");
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection lost");
            handleSupplicantConnectionLoss(false);
            transitionTo(mInitialState);
            break;
        case CMD_STOP_SUPPLICANT_FAILED:
            if (message.arg1 == mSupplicantStopFailureToken) {
                loge("Timed out on a supplicant stop, kill and proceed");
                handleSupplicantConnectionLoss(true);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_SET_FREQUENCY_BAND:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.SUP_CONNECTION_EVENT:
            loge("Supplicant connection received while stopping");
            break;
        case WifiMonitor.SUP_DISCONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Supplicant connection lost");
            handleSupplicantConnectionLoss(false);
            transitionTo(mInitialState);
            break;
        case CMD_STOP_SUPPLICANT_FAILED:
            if (message.arg1 == mSupplicantStopFailureToken) {
                loge("Timed out on a supplicant stop, kill and proceed");
                handleSupplicantConnectionLoss(true);
                transitionTo(mInitialState);
            }
            break;
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiStateMachine.CMD_DISABLE_P2P_RSP:
            transitionTo(mTransitionToState);
            break;
        /* Defer wifi start/shut and driver commands */
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_SET_FREQUENCY_BAND:
        case CMD_START_SCAN:
        case CMD_DISCONNECT:
        case CMD_REASSOCIATE:
        case CMD_RECONNECT:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiStateMachine.CMD_DISABLE_P2P_RSP:
            transitionTo(mTransitionToState);
            break;
        /* Defer wifi start/shut and driver commands */
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
        case CMD_START_SUPPLICANT:
        case CMD_STOP_SUPPLICANT:
        case CMD_START_AP:
        case CMD_STOP_AP:
        case CMD_SET_OPERATIONAL_MODE:
        case CMD_START_SCAN:
        case CMD_DISCONNECT:
        case CMD_REASSOCIATE:
        case CMD_RECONNECT:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DEFERRED;
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    // Inform WifiConnectivityManager that Wifi is enabled
    if (mWifiConnectivityManager != null) {
        mWifiConnectivityManager.setWifiEnabled(true);
    }
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
}
#method_after
@Override
public void enter() {
    // Inform WifiConnectivityManager that Wifi is enabled
    mWifiConnectivityManager.setWifiEnabled(true);
    // Inform metrics that Wifi is Enabled (but not yet connected)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISCONNECTED);
}
#end_block

#method_before
@Override
public void exit() {
    // Inform WifiConnectivityManager that Wifi is disabled
    if (mWifiConnectivityManager != null) {
        mWifiConnectivityManager.setWifiEnabled(false);
    }
    // Inform metrics that Wifi is being disabled (Toggled, airplane enabled, etc)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISABLED);
}
#method_after
@Override
public void exit() {
    // Inform WifiConnectivityManager that Wifi is disabled
    mWifiConnectivityManager.setWifiEnabled(false);
    // Inform metrics that Wifi is being disabled (Toggled, airplane enabled, etc)
    mWifiMetrics.setWifiState(WifiMetricsProto.WifiLog.WIFI_DISABLED);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                if (mWifiConnectivityManager != null) {
                    didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false);
                }
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            if (mWifiConnectivityManager != null) {
                mWifiConnectivityManager.forceConnectivityScan();
            }
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " roam=" + Boolean.toString(mAutoRoaming));
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            mWifiConfigManager.removeNetworksForUser(message.arg1);
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            mWifiInfo.setBSSID(mLastBssid);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (mWifiConnectivityManager != null) {
                mWifiConnectivityManager.trackBssid(mLastBssid, true);
            }
            sendNetworkStateChangeBroadcast(mLastBssid);
            transitionTo(mObtainingIpState);
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_ADD_PASSPOINT_MO:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_MODIFY_PASSPOINT_MO:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong("BSSID"), ((Bundle) message.obj).getString("FILENAME"));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config;
    int netId;
    boolean ok;
    boolean didDisconnect;
    String bssid;
    String ssid;
    NetworkUpdateResult result;
    logStateAndMessage(message, this);
    switch(message.what) {
        case WifiMonitor.ASSOCIATION_REJECTION_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_ASSOC_FAILURE);
            didBlackListBSSID = false;
            bssid = (String) message.obj;
            if (bssid == null || TextUtils.isEmpty(bssid)) {
                // If BSSID is null, use the target roam BSSID
                bssid = mTargetRoamBSSID;
            }
            if (bssid != null) {
                // If we have a BSSID, tell configStore to black list it
                didBlackListBSSID = mWifiConnectivityManager.trackBssid(bssid, false);
            }
            mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_ASSOCIATION_REJECTION);
            mSupplicantStateTracker.sendMessage(WifiMonitor.ASSOCIATION_REJECTION_EVENT);
            // If rejection occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_ASSOCIATION_REJECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), bssid, WifiLastResortWatchdog.FAILURE_CODE_ASSOCIATION);
            break;
        case WifiMonitor.AUTHENTICATION_FAILURE_EVENT:
            mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTH_FAILURE);
            mSupplicantStateTracker.sendMessage(WifiMonitor.AUTHENTICATION_FAILURE_EVENT);
            if (mTargetNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                mWifiConfigManager.updateNetworkSelectionStatus(mTargetNetworkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            }
            // If failure occurred while Metrics is tracking a ConnnectionEvent, end it.
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_AUTHENTICATION_FAILURE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.e(TAG, "Supplicant SSID temporary disabled:" + mWifiConfigManager.getConfiguredNetwork(netId));
            mWifiConfigManager.updateNetworkSelectionStatus(netId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_FAILURE);
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_SSID_TEMP_DISABLED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            mWifiInjector.getWifiLastResortWatchdog().noteConnectionFailureAndTriggerIfNeeded(getTargetSsid(), mTargetRoamBSSID, WifiLastResortWatchdog.FAILURE_CODE_AUTHENTICATION);
            break;
        case WifiMonitor.SSID_REENABLED:
            netId = lookupFrameworkNetworkId(message.arg1);
            Log.d(TAG, "Supplicant SSID reenable:" + mWifiConfigManager.getConfiguredNetwork(netId));
            // Algorithm of disable/enable
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            SupplicantState state = handleSupplicantStateChange(message);
            // We detect the interface going down and recover from it
            if (!SupplicantState.isDriverActive(state)) {
                if (mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                    handleNetworkDisconnect();
                }
                log("Detected an interface down, restart driver");
                // Rely on the fact that this will force us into killing supplicant and then
                // restart supplicant from a clean state.
                transitionTo(mSupplicantStoppingState);
                sendMessage(CMD_START_SUPPLICANT);
                break;
            }
            // disconnected, we need to handle a disconnection
            if (!isLinkDebouncing() && state == SupplicantState.DISCONNECTED && mNetworkInfo.getState() != NetworkInfo.State.DISCONNECTED) {
                if (mVerboseLoggingEnabled) {
                    log("Missed CTRL-EVENT-DISCONNECTED, disconnect");
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            // interest (e.g. routers); harmless if none are configured.
            if (state == SupplicantState.COMPLETED) {
                mIpManager.confirmConfiguration();
            }
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
            } else {
                mWifiNative.reconnect();
                mTemporarilyDisconnectWifi = false;
            }
            break;
        case CMD_ADD_OR_UPDATE_NETWORK:
            config = (WifiConfiguration) message.obj;
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, result.getNetworkId());
            break;
        case CMD_REMOVE_NETWORK:
            netId = message.arg1;
            ok = mWifiConfigManager.removeNetwork(message.arg1, message.sendingUid);
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            } else if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                // Disconnect and let autojoin reselect a new network
                sendMessage(CMD_DISCONNECT);
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case CMD_ENABLE_NETWORK:
            boolean disableOthers = message.arg2 == 1;
            netId = message.arg1;
            if (disableOthers) {
                // If the app has all the necessary permissions, this will trigger a connect
                // attempt.
                ok = connectToUserSelectNetwork(netId, message.sendingUid);
            } else {
                ok = mWifiConfigManager.enableNetwork(netId, false, message.sendingUid);
            }
            if (!ok) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
            }
            replyToMessage(message, message.what, ok ? SUCCESS : FAILURE);
            break;
        case WifiManager.DISABLE_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.disableNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.DISABLE_NETWORK_SUCCEEDED);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to remove network");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.DISABLE_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_DISABLE_EPHEMERAL_NETWORK:
            config = mWifiConfigManager.disableEphemeralNetwork((String) message.obj);
            if (config != null) {
                if (config.networkId == mTargetNetworkId || config.networkId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            }
            break;
        case CMD_SAVE_CONFIG:
            ok = mWifiConfigManager.saveToStore(true);
            replyToMessage(message, CMD_SAVE_CONFIG, ok ? SUCCESS : FAILURE);
            // Inform the backup manager about a data change
            mBackupManagerProxy.notifyDataChanged();
            break;
        case CMD_GET_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getSavedNetworks());
            break;
        case WifiMonitor.SUP_REQUEST_IDENTITY:
            int supplicantNetworkId = message.arg2;
            netId = lookupFrameworkNetworkId(supplicantNetworkId);
            boolean identitySent = false;
            int eapMethod = WifiEnterpriseConfig.Eap.NONE;
            if (targetWificonfiguration != null && targetWificonfiguration.enterpriseConfig != null) {
                eapMethod = targetWificonfiguration.enterpriseConfig.getEapMethod();
            }
            // For SIM & AKA/AKA' EAP method Only, get identity from ICC
            if (targetWificonfiguration != null && targetWificonfiguration.networkId == netId && (targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_EAP) || targetWificonfiguration.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.IEEE8021X)) && TelephonyUtil.isSimEapMethod(eapMethod)) {
                String identity = TelephonyUtil.getSimIdentity(getTelephonyManager(), eapMethod);
                if (identity != null) {
                    mWifiNative.simIdentityResponse(supplicantNetworkId, identity);
                    identitySent = true;
                }
            }
            if (!identitySent) {
                // Supplicant lacks credentials to connect to that network, hence black list
                ssid = (String) message.obj;
                if (targetWificonfiguration != null && ssid != null && targetWificonfiguration.SSID != null && targetWificonfiguration.SSID.equals("\"" + ssid + "\"")) {
                    mWifiConfigManager.updateNetworkSelectionStatus(targetWificonfiguration.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_AUTHENTICATION_NO_CREDENTIALS);
                }
                mWifiNative.disconnect();
            }
            break;
        case WifiMonitor.SUP_REQUEST_SIM_AUTH:
            logd("Received SUP_REQUEST_SIM_AUTH");
            SimAuthRequestData requestData = (SimAuthRequestData) message.obj;
            if (requestData != null) {
                if (requestData.protocol == WifiEnterpriseConfig.Eap.SIM) {
                    handleGsmAuthRequest(requestData);
                } else if (requestData.protocol == WifiEnterpriseConfig.Eap.AKA || requestData.protocol == WifiEnterpriseConfig.Eap.AKA_PRIME) {
                    handle3GAuthRequest(requestData);
                }
            } else {
                loge("Invalid sim auth request");
            }
            break;
        case CMD_GET_PRIVILEGED_CONFIGURED_NETWORKS:
            replyToMessage(message, message.what, mWifiConfigManager.getConfiguredNetworksWithPasswords());
            break;
        case CMD_GET_MATCHING_CONFIG:
            // TODO(b/31065385)
            replyToMessage(message, message.what, null);
            break;
        case CMD_RECONNECT:
            mWifiConnectivityManager.forceConnectivityScan();
            break;
        case CMD_REASSOCIATE:
            lastConnectAttemptTimestamp = mClock.getWallClockMillis();
            mWifiNative.reassociate();
            break;
        case CMD_RELOAD_TLS_AND_RECONNECT:
            if (mWifiConfigManager.needsUnlockedKeyStore()) {
                logd("Reconnecting to give a chance to un-connected TLS networks");
                mWifiNative.disconnect();
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                mWifiNative.reconnect();
            }
            break;
        case CMD_START_ROAM:
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            return HANDLED;
        case CMD_START_CONNECT:
            /* connect command coming from auto-join */
            netId = message.arg1;
            bssid = (String) message.obj;
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            if (config == null) {
                loge("CMD_START_CONNECT and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            logd("CMD_START_CONNECT sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " config " + config.configKey() + " targetRoamBSSID " + mTargetRoamBSSID);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_UNRELATED);
            boolean shouldDisconnect = (getCurrentState() != mDisconnectedState);
            if (mWifiSupplicantControl.connectToNetwork(config, shouldDisconnect)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = false;
                if (isRoaming() || isLinkDebouncing()) {
                    transitionTo(mRoamingState);
                } else if (shouldDisconnect) {
                    transitionTo(mDisconnectingState);
                } else {
                    transitionTo(mDisconnectedState);
                }
            } else {
                loge("CMD_START_CONNECT Failed to start connection to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            break;
        case CMD_REMOVE_APP_CONFIGURATIONS:
            mWifiConfigManager.removeNetworksForApp((ApplicationInfo) message.obj);
            break;
        case CMD_REMOVE_USER_CONFIGURATIONS:
            mWifiConfigManager.removeNetworksForUser(message.arg1);
            break;
        case WifiManager.CONNECT_NETWORK:
            /**
             * The connect message can contain a network id passed as arg1 on message or
             * or a config passed as obj on message.
             * For a new network, a config is passed to create and connect.
             * For an existing network, a network id is passed
             */
            netId = message.arg1;
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            // New network addition.
            if (config != null) {
                result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
                if (!result.isSuccess()) {
                    loge("CONNECT_NETWORK adding/updating config=" + config + " failed");
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                    break;
                }
                netId = result.getNetworkId();
            }
            if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                break;
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.CONNECT_NETWORK_SUCCEEDED);
            break;
        case WifiManager.SAVE_NETWORK:
            config = (WifiConfiguration) message.obj;
            mWifiConnectionStatistics.numWifiManagerJoinAttempt++;
            if (config == null) {
                loge("SAVE_NETWORK with null configuration" + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName());
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            result = mWifiConfigManager.addOrUpdateNetwork(config, message.sendingUid);
            if (!result.isSuccess()) {
                loge("SAVE_NETWORK adding/updating config=" + config + " failed");
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.ERROR);
                break;
            }
            netId = result.getNetworkId();
            if (mWifiInfo.getNetworkId() == netId) {
                if (result.hasIpChanged()) {
                    // The currently connection configuration was changed
                    // We switched from DHCP to static or from static to DHCP, or the
                    // static IP address has changed.
                    log("Reconfiguring IP on connection");
                    // TODO: clear addresses and disable IPv6
                    // to simplify obtainingIpState.
                    transitionTo(mObtainingIpState);
                }
                if (result.hasProxyChanged()) {
                    log("Reconfiguring proxy on connection");
                    mIpManager.setHttpProxy(getCurrentWifiConfiguration().getHttpProxy());
                }
            } else {
                if (!connectToUserSelectNetwork(netId, message.sendingUid)) {
                    messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                    replyToMessage(message, WifiManager.SAVE_NETWORK_FAILED, WifiManager.NOT_AUTHORIZED);
                    break;
                }
            }
            broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_SAVED, config);
            replyToMessage(message, WifiManager.SAVE_NETWORK_SUCCEEDED);
            break;
        case WifiManager.FORGET_NETWORK:
            netId = message.arg1;
            if (mWifiConfigManager.removeNetwork(netId, message.sendingUid)) {
                replyToMessage(message, WifiManager.FORGET_NETWORK_SUCCEEDED);
                broadcastWifiCredentialChanged(WifiManager.WIFI_CREDENTIAL_FORGOT, (WifiConfiguration) message.obj);
                if (netId == mTargetNetworkId || netId == mLastNetworkId) {
                    // Disconnect and let autojoin reselect a new network
                    sendMessage(CMD_DISCONNECT);
                }
            } else {
                loge("Failed to forget network");
                replyToMessage(message, WifiManager.FORGET_NETWORK_FAILED, WifiManager.ERROR);
            }
            break;
        case WifiManager.START_WPS:
            WpsInfo wpsInfo = (WpsInfo) message.obj;
            WpsResult wpsResult;
            switch(wpsInfo.setup) {
                case WpsInfo.PBC:
                    wpsResult = mWifiSupplicantControl.startWpsPbc(wpsInfo);
                    break;
                case WpsInfo.KEYPAD:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromAccessPoint(wpsInfo);
                    break;
                case WpsInfo.DISPLAY:
                    wpsResult = mWifiSupplicantControl.startWpsWithPinFromDevice(wpsInfo);
                    break;
                default:
                    wpsResult = new WpsResult(Status.FAILURE);
                    loge("Invalid setup for WPS");
                    break;
            }
            if (wpsResult.status == Status.SUCCESS) {
                replyToMessage(message, WifiManager.START_WPS_SUCCEEDED, wpsResult);
                transitionTo(mWpsRunningState);
            } else {
                loge("Failed to start WPS with config " + wpsInfo.toString());
                replyToMessage(message, WifiManager.WPS_FAILED, WifiManager.ERROR);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // This is where we can confirm the connection BSSID. Use it to find the
            // right ScanDetail to populate metrics.
            String someBssid = (String) message.obj;
            if (someBssid != null) {
                // Get the ScanDetail associated with this BSSID.
                ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(mTargetNetworkId);
                if (scanDetailCache != null) {
                    mWifiMetrics.setConnectionScanDetail(scanDetailCache.getScanDetail(someBssid));
                }
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mVerboseLoggingEnabled)
                log("Network connection established");
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mLastBssid = (String) message.obj;
            mWifiInfo.setBSSID(mLastBssid);
            mWifiInfo.setNetworkId(mLastNetworkId);
            mWifiConnectivityManager.trackBssid(mLastBssid, true);
            sendNetworkStateChangeBroadcast(mLastBssid);
            transitionTo(mObtainingIpState);
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // at the chip etc...
            if (mVerboseLoggingEnabled)
                log("ConnectModeState: Network connection lost ");
            handleNetworkDisconnect();
            transitionTo(mDisconnectedState);
            break;
        case CMD_ADD_PASSPOINT_MO:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_MODIFY_PASSPOINT_MO:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        case CMD_QUERY_OSU_ICON:
            mPasspointManager.queryPasspointIcon(((Bundle) message.obj).getLong(EXTRA_OSU_ICON_QUERY_BSSID), ((Bundle) message.obj).getString(EXTRA_OSU_ICON_QUERY_FILENAME));
            break;
        case CMD_MATCH_PROVIDER_NETWORK:
            // TODO(b/31065385): Passpoint config management.
            replyToMessage(message, message.what, 0);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
boolean startScanForConfiguration(WifiConfiguration config) {
    if (config == null)
        return false;
    // We are still seeing a fairly high power consumption triggered by autojoin scans
    // Hence do partial scans only for PSK configuration that are roamable since the
    // primary purpose of the partial scans is roaming.
    // Full badn scans with exponential backoff for the purpose or extended roaming and
    // network switching are performed unconditionally.
    ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(config.networkId);
    if (scanDetailCache == null || !config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK) || scanDetailCache.size() > 6) {
        // return true but to not trigger the scan
        return true;
    }
    Set<Integer> freqs = mWifiConfigManager.fetchChannelSetForNetworkForPartialScan(config.networkId, ONE_HOUR_MILLI);
    if (freqs != null && freqs.size() != 0) {
        // if (mVerboseLoggingEnabled) {
        logd("starting scan for " + config.configKey() + " with " + freqs);
        // }
        Set<Integer> hiddenNetworkIds = new HashSet<>();
        if (config.hiddenSSID) {
            hiddenNetworkIds.add(config.networkId);
        }
        // Call wifi native to start the scan
        if (startScanNative(freqs, hiddenNetworkIds, WIFI_WORK_SOURCE)) {
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_OK;
        } else {
            // used for debug only, mark scan as failed
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_HANDLING_ERROR;
        }
        return true;
    } else {
        if (mVerboseLoggingEnabled)
            logd("no channels for " + config.configKey());
        return false;
    }
}
#method_after
boolean startScanForConfiguration(WifiConfiguration config) {
    if (config == null)
        return false;
    // We are still seeing a fairly high power consumption triggered by autojoin scans
    // Hence do partial scans only for PSK configuration that are roamable since the
    // primary purpose of the partial scans is roaming.
    // Full badn scans with exponential backoff for the purpose or extended roaming and
    // network switching are performed unconditionally.
    ScanDetailCache scanDetailCache = mWifiConfigManager.getScanDetailCacheForNetwork(config.networkId);
    if (scanDetailCache == null || !config.allowedKeyManagement.get(WifiConfiguration.KeyMgmt.WPA_PSK) || scanDetailCache.size() > 6) {
        // return true but to not trigger the scan
        return true;
    }
    Set<Integer> freqs = mWifiConfigManager.fetchChannelSetForNetworkForPartialScan(config.networkId, ONE_HOUR_MILLI);
    if (freqs != null && freqs.size() != 0) {
        // if (mVerboseLoggingEnabled) {
        logd("starting scan for " + config.configKey() + " with " + freqs);
        // }
        List<WifiScanner.ScanSettings.HiddenNetwork> hiddenNetworks = new ArrayList<>();
        if (config.hiddenSSID) {
            hiddenNetworks.add(new WifiScanner.ScanSettings.HiddenNetwork(config.SSID));
        }
        // Call wifi native to start the scan
        if (startScanNative(freqs, hiddenNetworks, WIFI_WORK_SOURCE)) {
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_OK;
        } else {
            // used for debug only, mark scan as failed
            messageHandlingStatus = MESSAGE_HANDLING_STATUS_HANDLING_ERROR;
        }
        return true;
    } else {
        if (mVerboseLoggingEnabled)
            logd("no channels for " + config.configKey());
        return false;
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            handleIpReachabilityLost();
            transitionTo(mDisconnectingState);
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
                if (message.arg1 == SCAN_ONLY_WITH_WIFI_OFF_MODE || message.arg1 == DISABLED_MODE) {
                    noteWifiDisabledWhileAssociated();
                }
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            fetchPktcntNative(info);
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    switch(message.what) {
        case DhcpClient.CMD_PRE_DHCP_ACTION:
            handlePreDhcpSetup();
            break;
        case DhcpClient.CMD_PRE_DHCP_ACTION_COMPLETE:
            mIpManager.completedPreDhcpAction();
            break;
        case DhcpClient.CMD_POST_DHCP_ACTION:
            handlePostDhcpSetup();
            // similarly--via messages sent back from IpManager.
            break;
        case CMD_IPV4_PROVISIONING_SUCCESS:
            {
                handleIPv4Success((DhcpResults) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
                break;
            }
        case CMD_IPV4_PROVISIONING_FAILURE:
            {
                handleIPv4Failure();
                break;
            }
        case CMD_IP_CONFIGURATION_SUCCESSFUL:
            handleSuccessfulIpConfiguration();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            sendConnectedState();
            transitionTo(mConnectedState);
            break;
        case CMD_IP_CONFIGURATION_LOST:
            // Get Link layer stats so that we get fresh tx packet counters.
            getWifiLinkLayerStats();
            handleIpConfigurationLost();
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_DHCP, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            transitionTo(mDisconnectingState);
            break;
        case CMD_IP_REACHABILITY_LOST:
            if (mVerboseLoggingEnabled && message.obj != null)
                log((String) message.obj);
            if (mIpReachabilityDisconnectEnabled) {
                handleIpReachabilityLost();
                transitionTo(mDisconnectingState);
            } else {
                logd("CMD_IP_REACHABILITY_LOST but disconnect disabled -- ignore");
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            transitionTo(mDisconnectingState);
            break;
        case WifiP2pServiceImpl.DISCONNECT_WIFI_REQUEST:
            if (message.arg1 == 1) {
                mWifiNative.disconnect();
                mTemporarilyDisconnectWifi = true;
                transitionTo(mDisconnectingState);
            }
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                sendMessage(CMD_DISCONNECT);
                deferMessage(message);
                if (message.arg1 == SCAN_ONLY_WITH_WIFI_OFF_MODE || message.arg1 == DISABLED_MODE) {
                    noteWifiDisabledWhileAssociated();
                }
            }
            break;
        /* Ignore connection to same network */
        case WifiManager.CONNECT_NETWORK:
            int netId = message.arg1;
            if (mWifiInfo.getNetworkId() == netId) {
                break;
            }
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            mWifiInfo.setBSSID((String) message.obj);
            mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
            mWifiInfo.setNetworkId(mLastNetworkId);
            if (!mLastBssid.equals(message.obj)) {
                mLastBssid = (String) message.obj;
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_RSSI_POLL:
            if (message.arg1 == mRssiPollToken) {
                if (mEnableChipWakeUpWhenAssociated) {
                    if (mVerboseLoggingEnabled) {
                        log(" get link layer stats " + mWifiLinkLayerStatsSupported);
                    }
                    WifiLinkLayerStats stats = getWifiLinkLayerStats();
                    if (stats != null) {
                        // Sanity check the results provided by driver
                        if (mWifiInfo.getRssi() != WifiInfo.INVALID_RSSI && (stats.rssi_mgmt == 0 || stats.beacon_rx == 0)) {
                            stats = null;
                        }
                    }
                    // Get Info and continue polling
                    fetchRssiLinkSpeedAndFrequencyNative();
                    // Send the update score to network agent.
                    mWifiScoreReport.calculateAndReportScore(mWifiInfo, mNetworkAgent, mAggressiveHandover, mWifiMetrics);
                }
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
                if (mVerboseLoggingEnabled)
                    sendRssiChangeBroadcast(mWifiInfo.getRssi());
            } else {
            // Polling has completed
            }
            break;
        case CMD_ENABLE_RSSI_POLL:
            cleanWifiScore();
            if (mEnableRssiPollWhenAssociated) {
                mEnableRssiPolling = (message.arg1 == 1);
            } else {
                mEnableRssiPolling = false;
            }
            mRssiPollToken++;
            if (mEnableRssiPolling) {
                // First poll
                fetchRssiLinkSpeedAndFrequencyNative();
                sendMessageDelayed(obtainMessage(CMD_RSSI_POLL, mRssiPollToken, 0), POLL_RSSI_INTERVAL_MSECS);
            }
            break;
        case WifiManager.RSSI_PKTCNT_FETCH:
            RssiPacketCountInfo info = new RssiPacketCountInfo();
            fetchRssiLinkSpeedAndFrequencyNative();
            info.rssi = mWifiInfo.getRssi();
            fetchPktcntNative(info);
            replyToMessage(message, WifiManager.RSSI_PKTCNT_FETCH_SUCCEEDED, info);
            break;
        case CMD_DELAYED_NETWORK_DISCONNECT:
            if (!isLinkDebouncing()) {
                // Ignore if we are not debouncing
                logd("CMD_DELAYED_NETWORK_DISCONNECT and not debouncing - ignore " + message.arg1);
                return HANDLED;
            } else {
                logd("CMD_DELAYED_NETWORK_DISCONNECT and debouncing - disconnect " + message.arg1);
                mIsLinkDebouncing = false;
                // If we are still debouncing while this message comes,
                // it means we were not able to reconnect within the alloted time
                // = LINK_FLAPPING_DEBOUNCE_MSEC
                // and thus, trigger a real disconnect
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            if ((String) message.obj == null) {
                logw("Associated command w/o BSSID");
                break;
            }
            mLastBssid = (String) message.obj;
            if (mLastBssid != null && (mWifiInfo.getBSSID() == null || !mLastBssid.equals(mWifiInfo.getBSSID()))) {
                mWifiInfo.setBSSID((String) message.obj);
                sendNetworkStateChangeBroadcast(mLastBssid);
            }
            break;
        case CMD_START_RSSI_MONITORING_OFFLOAD:
        case CMD_RSSI_THRESHOLD_BREACH:
            byte currRssi = (byte) message.arg1;
            processRssiThreshold(currRssi, message.what);
            break;
        case CMD_STOP_RSSI_MONITORING_OFFLOAD:
            stopRssiMonitoringOffload();
            break;
        case CMD_RESET_SIM_NETWORKS:
            if (// sim was removed
            message.arg1 == 0 && mLastNetworkId != WifiConfiguration.INVALID_NETWORK_ID) {
                WifiConfiguration config = mWifiConfigManager.getConfiguredNetwork(mLastNetworkId);
                if (TelephonyUtil.isSimConfig(config)) {
                    mWifiNative.disconnect();
                    transitionTo(mDisconnectingState);
                }
            }
            /* allow parent state to reset data for other networks */
            return NOT_HANDLED;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    WifiConfiguration config;
    switch(message.what) {
        case CMD_IP_CONFIGURATION_LOST:
            config = getCurrentWifiConfiguration();
            if (config != null) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTOROAM_FAILURE);
            }
            return NOT_HANDLED;
        case CMD_UNWANTED_NETWORK:
            if (mVerboseLoggingEnabled) {
                log("Roaming and CS doesnt want the network -> ignore");
            }
            return HANDLED;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                deferMessage(message);
            }
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            /**
             * If we get a SUPPLICANT_STATE_CHANGE_EVENT indicating a DISCONNECT
             * before NETWORK_DISCONNECTION_EVENT
             * And there is an associated BSSID corresponding to our target BSSID, then
             * we have missed the network disconnection, transition to mDisconnectedState
             * and handle the rest of the events there.
             */
            StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
            if (stateChangeResult.state == SupplicantState.DISCONNECTED || stateChangeResult.state == SupplicantState.INACTIVE || stateChangeResult.state == SupplicantState.INTERFACE_DISABLED) {
                if (mVerboseLoggingEnabled) {
                    log("STATE_CHANGE_EVENT in roaming state " + stateChangeResult.toString());
                }
                if (stateChangeResult.BSSID != null && stateChangeResult.BSSID.equals(mTargetRoamBSSID)) {
                    handleNetworkDisconnect();
                    transitionTo(mDisconnectedState);
                }
            }
            if (stateChangeResult.state == SupplicantState.ASSOCIATED) {
                // We completed the layer2 roaming part
                mAssociated = true;
                if (stateChangeResult.BSSID != null) {
                    mTargetRoamBSSID = stateChangeResult.BSSID;
                }
            }
            break;
        case CMD_ROAM_WATCHDOG_TIMER:
            if (roamWatchdogCount == message.arg1) {
                if (mVerboseLoggingEnabled)
                    log("roaming watchdog! -> disconnect");
                mWifiMetrics.endConnectionEvent(WifiMetrics.ConnectionEvent.FAILURE_ROAM_TIMEOUT, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                mRoamFailCount++;
                handleNetworkDisconnect();
                mWifiNative.disconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mAssociated) {
                if (mVerboseLoggingEnabled) {
                    log("roaming and Network connection established");
                }
                mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
                mLastBssid = (String) message.obj;
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                if (mWifiConnectivityManager != null) {
                    mWifiConnectivityManager.trackBssid(mLastBssid, true);
                }
                sendNetworkStateChangeBroadcast(mLastBssid);
                // Successful framework roam! (probably)
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                // We must clear the config BSSID, as the wifi chipset may decide to roam
                // from this point on and having the BSSID specified by QNS would cause
                // the roam to fail and the device to disconnect.
                // When transition from RoamingState to DisconnectingState or
                // DisconnectedState, the config BSSID is cleared by
                // handleNetworkDisconnect().
                clearTargetBssid("RoamingCompleted");
                // We used to transition to ObtainingIpState in an
                // attempt to do DHCPv4 RENEWs on framework roams.
                // DHCP can take too long to time out, and we now rely
                // upon IpManager's use of IpReachabilityMonitor to
                // confirm our current network configuration.
                // 
                // mIpManager.confirmConfiguration() is called within
                // the handling of SupplicantState.COMPLETED.
                transitionTo(mConnectedState);
            } else {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // Throw away but only if it corresponds to the network we're roaming to
            String bssid = (String) message.obj;
            if (true) {
                String target = "";
                if (mTargetRoamBSSID != null)
                    target = mTargetRoamBSSID;
                log("NETWORK_DISCONNECTION_EVENT in roaming state" + " BSSID=" + bssid + " target=" + target);
            }
            if (bssid != null && bssid.equals(mTargetRoamBSSID)) {
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            // Auth error while roaming
            int netId = lookupFrameworkNetworkId(message.arg1);
            logd("SSID_TEMP_DISABLED nid=" + Integer.toString(mLastNetworkId) + " id=" + netId + " isRoaming=" + isRoaming() + " roam=" + mAutoRoaming);
            if (netId == mLastNetworkId) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTOROAM_FAILURE);
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectingState);
            }
            return NOT_HANDLED;
        case CMD_START_SCAN:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    logStateAndMessage(message, this);
    WifiConfiguration config;
    switch(message.what) {
        case CMD_IP_CONFIGURATION_LOST:
            config = getCurrentWifiConfiguration();
            if (config != null) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTOROAM_FAILURE);
            }
            return NOT_HANDLED;
        case CMD_UNWANTED_NETWORK:
            if (mVerboseLoggingEnabled) {
                log("Roaming and CS doesnt want the network -> ignore");
            }
            return HANDLED;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                deferMessage(message);
            }
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            /**
             * If we get a SUPPLICANT_STATE_CHANGE_EVENT indicating a DISCONNECT
             * before NETWORK_DISCONNECTION_EVENT
             * And there is an associated BSSID corresponding to our target BSSID, then
             * we have missed the network disconnection, transition to mDisconnectedState
             * and handle the rest of the events there.
             */
            StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
            if (stateChangeResult.state == SupplicantState.DISCONNECTED || stateChangeResult.state == SupplicantState.INACTIVE || stateChangeResult.state == SupplicantState.INTERFACE_DISABLED) {
                if (mVerboseLoggingEnabled) {
                    log("STATE_CHANGE_EVENT in roaming state " + stateChangeResult.toString());
                }
                if (stateChangeResult.BSSID != null && stateChangeResult.BSSID.equals(mTargetRoamBSSID)) {
                    handleNetworkDisconnect();
                    transitionTo(mDisconnectedState);
                }
            }
            if (stateChangeResult.state == SupplicantState.ASSOCIATED) {
                // We completed the layer2 roaming part
                mAssociated = true;
                if (stateChangeResult.BSSID != null) {
                    mTargetRoamBSSID = stateChangeResult.BSSID;
                }
            }
            break;
        case CMD_ROAM_WATCHDOG_TIMER:
            if (roamWatchdogCount == message.arg1) {
                if (mVerboseLoggingEnabled)
                    log("roaming watchdog! -> disconnect");
                mWifiMetrics.endConnectionEvent(WifiMetrics.ConnectionEvent.FAILURE_ROAM_TIMEOUT, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                mRoamFailCount++;
                handleNetworkDisconnect();
                mWifiNative.disconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case WifiMonitor.NETWORK_CONNECTION_EVENT:
            if (mAssociated) {
                if (mVerboseLoggingEnabled) {
                    log("roaming and Network connection established");
                }
                mLastNetworkId = lookupFrameworkNetworkId(message.arg1);
                mLastBssid = (String) message.obj;
                mWifiInfo.setBSSID(mLastBssid);
                mWifiInfo.setNetworkId(mLastNetworkId);
                mWifiConnectivityManager.trackBssid(mLastBssid, true);
                sendNetworkStateChangeBroadcast(mLastBssid);
                // Successful framework roam! (probably)
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NONE, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                // We must clear the config BSSID, as the wifi chipset may decide to roam
                // from this point on and having the BSSID specified by QNS would cause
                // the roam to fail and the device to disconnect.
                // When transition from RoamingState to DisconnectingState or
                // DisconnectedState, the config BSSID is cleared by
                // handleNetworkDisconnect().
                clearTargetBssid("RoamingCompleted");
                // We used to transition to ObtainingIpState in an
                // attempt to do DHCPv4 RENEWs on framework roams.
                // DHCP can take too long to time out, and we now rely
                // upon IpManager's use of IpReachabilityMonitor to
                // confirm our current network configuration.
                // 
                // mIpManager.confirmConfiguration() is called within
                // the handling of SupplicantState.COMPLETED.
                transitionTo(mConnectedState);
            } else {
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_DISCARD;
            }
            break;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // Throw away but only if it corresponds to the network we're roaming to
            String bssid = (String) message.obj;
            if (true) {
                String target = "";
                if (mTargetRoamBSSID != null)
                    target = mTargetRoamBSSID;
                log("NETWORK_DISCONNECTION_EVENT in roaming state" + " BSSID=" + bssid + " target=" + target);
            }
            if (bssid != null && bssid.equals(mTargetRoamBSSID)) {
                handleNetworkDisconnect();
                transitionTo(mDisconnectedState);
            }
            break;
        case WifiMonitor.SSID_TEMP_DISABLED:
            // Auth error while roaming
            int netId = lookupFrameworkNetworkId(message.arg1);
            logd("SSID_TEMP_DISABLED nid=" + Integer.toString(mLastNetworkId) + " id=" + netId + " isRoaming=" + isRoaming() + " roam=" + mAutoRoaming);
            if (netId == mLastNetworkId) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_AUTOROAM_FAILURE);
                }
                handleNetworkDisconnect();
                transitionTo(mDisconnectingState);
            }
            return NOT_HANDLED;
        case CMD_START_SCAN:
            deferMessage(message);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    updateDefaultRouteMacAddress(1000);
    if (mVerboseLoggingEnabled) {
        log("Enter ConnectedState " + " mScreenOn=" + mScreenOn);
    }
    if (mWifiConnectivityManager != null) {
        mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED);
    }
    registerConnected();
    lastConnectAttemptTimestamp = 0;
    targetWificonfiguration = null;
    // Paranoia
    mIsLinkDebouncing = false;
    // Not roaming anymore
    mAutoRoaming = false;
    if (testNetworkDisconnect) {
        testNetworkDisconnectCounter++;
        logd("ConnectedState Enter start disconnect test " + testNetworkDisconnectCounter);
        sendMessageDelayed(obtainMessage(CMD_TEST_NETWORK_DISCONNECT, testNetworkDisconnectCounter, 0), 15000);
    }
    mLastDriverRoamAttempt = 0;
    mTargetNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
    mWifiInjector.getWifiLastResortWatchdog().connectedStateTransition(true);
}
#method_after
@Override
public void enter() {
    updateDefaultRouteMacAddress(1000);
    if (mVerboseLoggingEnabled) {
        log("Enter ConnectedState " + " mScreenOn=" + mScreenOn);
    }
    mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_CONNECTED);
    registerConnected();
    lastConnectAttemptTimestamp = 0;
    targetWificonfiguration = null;
    // Paranoia
    mIsLinkDebouncing = false;
    // Not roaming anymore
    mAutoRoaming = false;
    if (testNetworkDisconnect) {
        testNetworkDisconnectCounter++;
        logd("ConnectedState Enter start disconnect test " + testNetworkDisconnectCounter);
        sendMessageDelayed(obtainMessage(CMD_TEST_NETWORK_DISCONNECT, testNetworkDisconnectCounter, 0), 15000);
    }
    mLastDriverRoamAttempt = 0;
    mTargetNetworkId = WifiConfiguration.INVALID_NETWORK_ID;
    mWifiInjector.getWifiLastResortWatchdog().connectedStateTransition(true);
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config = null;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_UNWANTED_NETWORK:
            if (message.arg1 == NETWORK_STATUS_UNWANTED_DISCONNECT) {
                mWifiNative.disconnect();
                transitionTo(mDisconnectingState);
            } else if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN || message.arg1 == NETWORK_STATUS_UNWANTED_VALIDATION_FAILED) {
                Log.d(TAG, (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN ? "NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN" : "NETWORK_STATUS_UNWANTED_VALIDATION_FAILED"));
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // Disable autojoin
                    if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN) {
                        mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, false);
                        mWifiConfigManager.updateNetworkSelectionStatus(config.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_NO_INTERNET);
                    }
                    mWifiConfigManager.incrementNetworkNoInternetAccessReports(config.networkId);
                }
            }
            return HANDLED;
        case CMD_NETWORK_STATUS:
            if (message.arg1 == NetworkAgent.VALID_NETWORK) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // re-enable autojoin
                    mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, true);
                }
            }
            return HANDLED;
        case CMD_ACCEPT_UNVALIDATED:
            boolean accept = (message.arg1 != 0);
            mWifiConfigManager.setNetworkNoInternetAccessExpected(mLastNetworkId, accept);
            return HANDLED;
        case CMD_TEST_NETWORK_DISCONNECT:
            // Force a disconnect
            if (message.arg1 == testNetworkDisconnectCounter) {
                mWifiNative.disconnect();
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // ASSOCIATING to a new BSSID while already connected, indicates
            // that driver is roaming
            mLastDriverRoamAttempt = mClock.getWallClockMillis();
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            long lastRoam = 0;
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            if (mLastDriverRoamAttempt != 0) {
                // Calculate time since last driver roam attempt
                lastRoam = mClock.getWallClockMillis() - mLastDriverRoamAttempt;
                mLastDriverRoamAttempt = 0;
            }
            if (unexpectedDisconnectedReason(message.arg2)) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_UNEXPECTED_DISCONNECT);
            }
            config = getCurrentWifiConfiguration();
            if (mEnableLinkDebouncing && mScreenOn && !isLinkDebouncing() && config != null && config.getNetworkSelectionStatus().isNetworkEnabled() && config.networkId != mWifiConfigManager.getLastSelectedNetwork() && (message.arg2 != 3 || /* reason cannot be 3, i.e. locally generated */
            (lastRoam > 0 && lastRoam < 2000)) && ((ScanResult.is24GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > WifiQualifiedNetworkSelector.QUALIFIED_RSSI_24G_BAND) || (ScanResult.is5GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5))) {
                // Start de-bouncing the L2 disconnection:
                // this L2 disconnection might be spurious.
                // Hence we allow 4 seconds for the state machine to try
                // to reconnect, go thru the
                // roaming cycle and enter Obtaining IP address
                // before signalling the disconnect to ConnectivityService and L3
                startScanForConfiguration(getCurrentWifiConfiguration());
                mIsLinkDebouncing = true;
                sendMessageDelayed(obtainMessage(CMD_DELAYED_NETWORK_DISCONNECT, 0, mLastNetworkId), LINK_FLAPPING_DEBOUNCE_MSEC);
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " reason=" + message.arg2 + " -> debounce");
                }
                return HANDLED;
            } else {
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " was debouncing=" + isLinkDebouncing() + " reason=" + message.arg2 + " Network Selection Status=" + (config == null ? "Unavailable" : config.getNetworkSelectionStatus().getNetworkStatusString()));
                }
            }
            break;
        case CMD_START_ROAM:
            // Clear the driver roam indication since we are attempting a framework roam
            mLastDriverRoamAttempt = 0;
            /* Connect command coming from auto-join */
            int netId = message.arg1;
            ScanResult candidate = (ScanResult) message.obj;
            String bssid = SUPPLICANT_BSSID_ANY;
            if (candidate != null) {
                bssid = candidate.BSSID;
            }
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            if (config == null) {
                loge("CMD_START_ROAM and no config, bail out...");
                break;
            }
            logd("CMD_START_ROAM sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " config " + config.configKey() + " roam=" + Integer.toString(message.arg2) + " to " + bssid + " targetRoamBSSID " + mTargetRoamBSSID);
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE);
            if (mWifiSupplicantControl.roamToNetwork(config)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = true;
                transitionTo(mRoamingState);
            } else {
                loge("CMD_START_ROAM Failed to start roaming to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int intervalSeconds = message.arg2;
                KeepalivePacketData pkt = (KeepalivePacketData) message.obj;
                byte[] dstMac;
                try {
                    InetAddress gateway = RouteInfo.selectBestRoute(mLinkProperties.getRoutes(), pkt.dstAddress).getGateway();
                    String dstMacStr = macAddressFromRoute(gateway.getHostAddress());
                    dstMac = macAddressFromString(dstMacStr);
                } catch (NullPointerException | IllegalArgumentException e) {
                    loge("Can't find MAC address for next hop to " + pkt.dstAddress);
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ConnectivityManager.PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
                    break;
                }
                pkt.dstMac = dstMac;
                int result = startWifiIPPacketOffload(slot, pkt, intervalSeconds);
                mNetworkAgent.onPacketKeepaliveEvent(slot, result);
                break;
            }
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    WifiConfiguration config = null;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_UNWANTED_NETWORK:
            if (message.arg1 == NETWORK_STATUS_UNWANTED_DISCONNECT) {
                mWifiNative.disconnect();
                transitionTo(mDisconnectingState);
            } else if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN || message.arg1 == NETWORK_STATUS_UNWANTED_VALIDATION_FAILED) {
                Log.d(TAG, (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN ? "NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN" : "NETWORK_STATUS_UNWANTED_VALIDATION_FAILED"));
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // Disable autojoin
                    if (message.arg1 == NETWORK_STATUS_UNWANTED_DISABLE_AUTOJOIN) {
                        mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, false);
                        mWifiConfigManager.updateNetworkSelectionStatus(config.networkId, WifiConfiguration.NetworkSelectionStatus.DISABLED_NO_INTERNET);
                    }
                    mWifiConfigManager.incrementNetworkNoInternetAccessReports(config.networkId);
                }
            }
            return HANDLED;
        case CMD_NETWORK_STATUS:
            if (message.arg1 == NetworkAgent.VALID_NETWORK) {
                config = getCurrentWifiConfiguration();
                if (config != null) {
                    // re-enable autojoin
                    mWifiConfigManager.setNetworkValidatedInternetAccess(config.networkId, true);
                }
            }
            return HANDLED;
        case CMD_ACCEPT_UNVALIDATED:
            boolean accept = (message.arg1 != 0);
            mWifiConfigManager.setNetworkNoInternetAccessExpected(mLastNetworkId, accept);
            return HANDLED;
        case CMD_TEST_NETWORK_DISCONNECT:
            // Force a disconnect
            if (message.arg1 == testNetworkDisconnectCounter) {
                mWifiNative.disconnect();
            }
            break;
        case CMD_ASSOCIATED_BSSID:
            // ASSOCIATING to a new BSSID while already connected, indicates
            // that driver is roaming
            mLastDriverRoamAttempt = mClock.getWallClockMillis();
            return NOT_HANDLED;
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            long lastRoam = 0;
            reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_NETWORK_DISCONNECTION, WifiMetricsProto.ConnectionEvent.HLF_NONE);
            if (mLastDriverRoamAttempt != 0) {
                // Calculate time since last driver roam attempt
                lastRoam = mClock.getWallClockMillis() - mLastDriverRoamAttempt;
                mLastDriverRoamAttempt = 0;
            }
            if (unexpectedDisconnectedReason(message.arg2)) {
                mWifiDiagnostics.captureBugReportData(WifiDiagnostics.REPORT_REASON_UNEXPECTED_DISCONNECT);
            }
            config = getCurrentWifiConfiguration();
            if (mEnableLinkDebouncing && mScreenOn && !isLinkDebouncing() && config != null && config.getNetworkSelectionStatus().isNetworkEnabled() && config.networkId != mWifiConfigManager.getLastSelectedNetwork() && (message.arg2 != 3 || /* reason cannot be 3, i.e. locally generated */
            (lastRoam > 0 && lastRoam < 2000)) && ((ScanResult.is24GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5) || (ScanResult.is5GHz(mWifiInfo.getFrequency()) && mWifiInfo.getRssi() > mThresholdQualifiedRssi5))) {
                // Start de-bouncing the L2 disconnection:
                // this L2 disconnection might be spurious.
                // Hence we allow 4 seconds for the state machine to try
                // to reconnect, go thru the
                // roaming cycle and enter Obtaining IP address
                // before signalling the disconnect to ConnectivityService and L3
                startScanForConfiguration(getCurrentWifiConfiguration());
                mIsLinkDebouncing = true;
                sendMessageDelayed(obtainMessage(CMD_DELAYED_NETWORK_DISCONNECT, 0, mLastNetworkId), LINK_FLAPPING_DEBOUNCE_MSEC);
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " reason=" + message.arg2 + " -> debounce");
                }
                return HANDLED;
            } else {
                if (mVerboseLoggingEnabled) {
                    log("NETWORK_DISCONNECTION_EVENT in connected state" + " BSSID=" + mWifiInfo.getBSSID() + " RSSI=" + mWifiInfo.getRssi() + " freq=" + mWifiInfo.getFrequency() + " was debouncing=" + isLinkDebouncing() + " reason=" + message.arg2 + " Network Selection Status=" + (config == null ? "Unavailable" : config.getNetworkSelectionStatus().getNetworkStatusString()));
                }
            }
            break;
        case CMD_START_ROAM:
            // Clear the driver roam indication since we are attempting a framework roam
            mLastDriverRoamAttempt = 0;
            /* Connect command coming from auto-join */
            int netId = message.arg1;
            ScanResult candidate = (ScanResult) message.obj;
            String bssid = SUPPLICANT_BSSID_ANY;
            if (candidate != null) {
                bssid = candidate.BSSID;
            }
            config = mWifiConfigManager.getConfiguredNetworkWithPassword(netId);
            if (config == null) {
                loge("CMD_START_ROAM and no config, bail out...");
                break;
            }
            mTargetNetworkId = netId;
            setTargetBssid(config, bssid);
            logd("CMD_START_ROAM sup state " + mSupplicantStateTracker.getSupplicantStateName() + " my state " + getCurrentState().getName() + " nid=" + Integer.toString(netId) + " config " + config.configKey() + " targetRoamBSSID " + mTargetRoamBSSID);
            mWifiMetrics.startConnectionEvent(config, mTargetRoamBSSID, WifiMetricsProto.ConnectionEvent.ROAM_ENTERPRISE);
            if (mWifiSupplicantControl.roamToNetwork(config)) {
                lastConnectAttemptTimestamp = mClock.getWallClockMillis();
                targetWificonfiguration = config;
                mAutoRoaming = true;
                transitionTo(mRoamingState);
            } else {
                loge("CMD_START_ROAM Failed to start roaming to network " + config);
                reportConnectionAttemptEnd(WifiMetrics.ConnectionEvent.FAILURE_CONNECT_NETWORK_FAILED, WifiMetricsProto.ConnectionEvent.HLF_NONE);
                replyToMessage(message, WifiManager.CONNECT_NETWORK_FAILED, WifiManager.ERROR);
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_FAIL;
                break;
            }
            break;
        case CMD_START_IP_PACKET_OFFLOAD:
            {
                int slot = message.arg1;
                int intervalSeconds = message.arg2;
                KeepalivePacketData pkt = (KeepalivePacketData) message.obj;
                byte[] dstMac;
                try {
                    InetAddress gateway = RouteInfo.selectBestRoute(mLinkProperties.getRoutes(), pkt.dstAddress).getGateway();
                    String dstMacStr = macAddressFromRoute(gateway.getHostAddress());
                    dstMac = macAddressFromString(dstMacStr);
                } catch (NullPointerException | IllegalArgumentException e) {
                    loge("Can't find MAC address for next hop to " + pkt.dstAddress);
                    mNetworkAgent.onPacketKeepaliveEvent(slot, ConnectivityManager.PacketKeepalive.ERROR_INVALID_IP_ADDRESS);
                    break;
                }
                pkt.dstMac = dstMac;
                int result = startWifiIPPacketOffload(slot, pkt, intervalSeconds);
                mNetworkAgent.onPacketKeepaliveEvent(slot, result);
                break;
            }
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void exit() {
    logd("WifiStateMachine: Leaving Connected state");
    if (mWifiConnectivityManager != null) {
        mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_TRANSITIONING);
    }
    mLastDriverRoamAttempt = 0;
    mWifiInjector.getWifiLastResortWatchdog().connectedStateTransition(false);
}
#method_after
@Override
public void exit() {
    logd("WifiStateMachine: Leaving Connected state");
    mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_TRANSITIONING);
    mLastDriverRoamAttempt = 0;
    mWifiInjector.getWifiLastResortWatchdog().connectedStateTransition(false);
}
#end_block

#method_before
@Override
public void enter() {
    // due to p2p
    if (mTemporarilyDisconnectWifi) {
        p2pSendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
        return;
    }
    if (mVerboseLoggingEnabled) {
        logd(" Enter DisconnectedState screenOn=" + mScreenOn);
    }
    /**
     * clear the roaming state, if we were roaming, we failed
     */
    mAutoRoaming = false;
    if (mWifiConnectivityManager != null) {
        mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED);
    }
    /**
     * If we have no networks saved, the supplicant stops doing the periodic scan.
     * The scans are useful to notify the user of the presence of an open network.
     * Note that these are not wake up scans.
     */
    if (mNoNetworksPeriodicScan != 0 && !mP2pConnected.get() && mWifiConfigManager.getSavedNetworks().size() == 0) {
        sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
    }
    mDisconnectedTimeStamp = mClock.getWallClockMillis();
}
#method_after
@Override
public void enter() {
    // due to p2p
    if (mTemporarilyDisconnectWifi) {
        p2pSendMessage(WifiP2pServiceImpl.DISCONNECT_WIFI_RESPONSE);
        return;
    }
    if (mVerboseLoggingEnabled) {
        logd(" Enter DisconnectedState screenOn=" + mScreenOn);
    }
    /**
     * clear the roaming state, if we were roaming, we failed
     */
    mAutoRoaming = false;
    mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_DISCONNECTED);
    /**
     * If we have no networks saved, the supplicant stops doing the periodic scan.
     * The scans are useful to notify the user of the presence of an open network.
     * Note that these are not wake up scans.
     */
    if (mNoNetworksPeriodicScan != 0 && !mP2pConnected.get() && mWifiConfigManager.getSavedNetworks().size() == 0) {
        sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
    }
    mDisconnectedTimeStamp = mClock.getWallClockMillis();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    boolean ret = HANDLED;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
            if (mP2pConnected.get())
                break;
            if (mNoNetworksPeriodicScan != 0 && message.arg1 == mPeriodicScanToken && mWifiConfigManager.getSavedNetworks().size() == 0) {
                startScan(UNKNOWN_SCAN_SOURCE, -1, null, WIFI_WORK_SOURCE);
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case WifiManager.FORGET_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_REMOVE_APP_CONFIGURATIONS:
        case CMD_REMOVE_USER_CONFIGURATIONS:
            // Set up a delayed message here. After the forget/remove is handled
            // the handled delayed message will determine if there is a need to
            // scan and continue
            sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            ret = NOT_HANDLED;
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                mOperationalMode = message.arg1;
                if (mOperationalMode == DISABLED_MODE) {
                    transitionTo(mSupplicantStoppingState);
                } else if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
                    p2pSendMessage(CMD_DISABLE_P2P_REQ);
                    setWifiState(WIFI_STATE_DISABLED);
                    transitionTo(mScanModeState);
                } else if (mOperationalMode == SCAN_ONLY_MODE) {
                    transitionTo(mScanModeState);
                }
            }
            break;
        case CMD_DISCONNECT:
            if (mVerboseLoggingEnabled)
                log("Ignore CMD_DISCONNECT when already disconnected.");
            break;
        /* Ignore network disconnect */
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // Interpret this as an L2 connection failure
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
            if (mVerboseLoggingEnabled) {
                logd("SUPPLICANT_STATE_CHANGE_EVENT state=" + stateChangeResult.state + " -> state= " + WifiInfo.getDetailedStateOf(stateChangeResult.state) + " debouncing=" + isLinkDebouncing());
            }
            setNetworkDetailedState(WifiInfo.getDetailedStateOf(stateChangeResult.state));
            /* ConnectModeState does the rest of the handling */
            ret = NOT_HANDLED;
            break;
        case CMD_START_SCAN:
            if (!checkOrDeferScanAllowed(message)) {
                // The scan request was rescheduled
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_REFUSED;
                return HANDLED;
            }
            ret = NOT_HANDLED;
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            if (mP2pConnected.get()) {
                int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_scan_interval_p2p_connected);
                long scanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SCAN_INTERVAL_WHEN_P2P_CONNECTED_MS, defaultInterval);
                mWifiNative.setScanInterval((int) scanIntervalMs / 1000);
            } else if (mWifiConfigManager.getSavedNetworks().size() == 0) {
                if (mVerboseLoggingEnabled)
                    log("Turn on scanning after p2p disconnected");
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
            if (mTemporarilyDisconnectWifi) {
                // temporarily disconnected for p2p
                break;
            } else {
                // ConnectModeState handles it
                ret = NOT_HANDLED;
            }
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        default:
            ret = NOT_HANDLED;
    }
    return ret;
}
#method_after
@Override
public boolean processMessage(Message message) {
    boolean ret = HANDLED;
    logStateAndMessage(message, this);
    switch(message.what) {
        case CMD_NO_NETWORKS_PERIODIC_SCAN:
            if (mP2pConnected.get())
                break;
            if (mNoNetworksPeriodicScan != 0 && message.arg1 == mPeriodicScanToken && mWifiConfigManager.getSavedNetworks().size() == 0) {
                startScan(UNKNOWN_SCAN_SOURCE, -1, null, WIFI_WORK_SOURCE);
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case WifiManager.FORGET_NETWORK:
        case CMD_REMOVE_NETWORK:
        case CMD_REMOVE_APP_CONFIGURATIONS:
        case CMD_REMOVE_USER_CONFIGURATIONS:
            // Set up a delayed message here. After the forget/remove is handled
            // the handled delayed message will determine if there is a need to
            // scan and continue
            sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            ret = NOT_HANDLED;
            break;
        case CMD_SET_OPERATIONAL_MODE:
            if (message.arg1 != CONNECT_MODE) {
                mOperationalMode = message.arg1;
                if (mOperationalMode == DISABLED_MODE) {
                    transitionTo(mSupplicantStoppingState);
                } else if (mOperationalMode == SCAN_ONLY_WITH_WIFI_OFF_MODE) {
                    p2pSendMessage(CMD_DISABLE_P2P_REQ);
                    setWifiState(WIFI_STATE_DISABLED);
                    transitionTo(mScanModeState);
                } else if (mOperationalMode == SCAN_ONLY_MODE) {
                    transitionTo(mScanModeState);
                }
            }
            break;
        case CMD_DISCONNECT:
            mWifiNative.disconnect();
            break;
        /* Ignore network disconnect */
        case WifiMonitor.NETWORK_DISCONNECTION_EVENT:
            // Interpret this as an L2 connection failure
            break;
        case WifiMonitor.SUPPLICANT_STATE_CHANGE_EVENT:
            StateChangeResult stateChangeResult = (StateChangeResult) message.obj;
            if (mVerboseLoggingEnabled) {
                logd("SUPPLICANT_STATE_CHANGE_EVENT state=" + stateChangeResult.state + " -> state= " + WifiInfo.getDetailedStateOf(stateChangeResult.state) + " debouncing=" + isLinkDebouncing());
            }
            setNetworkDetailedState(WifiInfo.getDetailedStateOf(stateChangeResult.state));
            /* ConnectModeState does the rest of the handling */
            ret = NOT_HANDLED;
            break;
        case CMD_START_SCAN:
            if (!checkOrDeferScanAllowed(message)) {
                // The scan request was rescheduled
                messageHandlingStatus = MESSAGE_HANDLING_STATUS_REFUSED;
                return HANDLED;
            }
            ret = NOT_HANDLED;
            break;
        case WifiP2pServiceImpl.P2P_CONNECTION_CHANGED:
            NetworkInfo info = (NetworkInfo) message.obj;
            mP2pConnected.set(info.isConnected());
            if (mP2pConnected.get()) {
                int defaultInterval = mContext.getResources().getInteger(R.integer.config_wifi_scan_interval_p2p_connected);
                long scanIntervalMs = mFacade.getLongSetting(mContext, Settings.Global.WIFI_SCAN_INTERVAL_WHEN_P2P_CONNECTED_MS, defaultInterval);
                mWifiNative.setScanInterval((int) scanIntervalMs / 1000);
            } else if (mWifiConfigManager.getSavedNetworks().size() == 0) {
                if (mVerboseLoggingEnabled)
                    log("Turn on scanning after p2p disconnected");
                sendMessageDelayed(obtainMessage(CMD_NO_NETWORKS_PERIODIC_SCAN, ++mPeriodicScanToken, 0), mNoNetworksPeriodicScan);
            }
            break;
        case CMD_RECONNECT:
        case CMD_REASSOCIATE:
            if (mTemporarilyDisconnectWifi) {
                // temporarily disconnected for p2p
                break;
            } else {
                // ConnectModeState handles it
                ret = NOT_HANDLED;
            }
            break;
        case CMD_SCREEN_STATE_CHANGED:
            handleScreenStateChanged(message.arg1 != 0);
            break;
        default:
            ret = NOT_HANDLED;
    }
    return ret;
}
#end_block

#method_before
@Override
public void exit() {
    if (mWifiConnectivityManager != null) {
        mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_TRANSITIONING);
    }
}
#method_after
@Override
public void exit() {
    mWifiConnectivityManager.handleConnectionStateChanged(WifiConnectivityManager.WIFI_STATE_TRANSITIONING);
}
#end_block

#method_before
@Override
public void enter() {
    final Message message = getCurrentMessage();
    if (message.what != CMD_START_AP) {
        throw new RuntimeException("Illegal transition to SoftApState: " + message);
    }
    IApInterface apInterface = setupDriverForSoftAp();
    if (apInterface == null) {
        setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
        /**
         * Transition to InitialState to reset the
         * driver/HAL back to the initial state.
         */
        transitionTo(mInitialState);
        return;
    }
    WifiConfiguration config = (WifiConfiguration) message.obj;
    if (config == null) {
        /**
         * Configuration not provided in the command, fallback to use the current
         * configuration.
         */
        config = mWifiApConfigStore.getApConfiguration();
    } else {
        /* Update AP configuration. */
        mWifiApConfigStore.setApConfiguration(config);
    }
    checkAndSetConnectivityInstance();
    mSoftApManager = mWifiInjector.makeSoftApManager(mWifiNative, mNwService, mCm, mCountryCode.getCountryCode(), mWifiApConfigStore.getAllowed2GChannel(), new SoftApListener(), apInterface);
    mSoftApManager.start(config);
}
#method_after
@Override
public void enter() {
    final Message message = getCurrentMessage();
    if (message.what != CMD_START_AP) {
        throw new RuntimeException("Illegal transition to SoftApState: " + message);
    }
    IApInterface apInterface = setupDriverForSoftAp();
    if (apInterface == null) {
        setWifiApState(WIFI_AP_STATE_FAILED, WifiManager.SAP_START_FAILURE_GENERAL);
        /**
         * Transition to InitialState to reset the
         * driver/HAL back to the initial state.
         */
        transitionTo(mInitialState);
        return;
    }
    WifiConfiguration config = (WifiConfiguration) message.obj;
    checkAndSetConnectivityInstance();
    mSoftApManager = mWifiInjector.makeSoftApManager(mNwService, new SoftApListener(), apInterface, config);
    mSoftApManager.start();
}
#end_block

#method_before
public SoftApManager makeSoftApManager(WifiNative wifiNative, INetworkManagementService nmService, ConnectivityManager cm, String countryCode, ArrayList<Integer> allowed2GChannels, SoftApManager.Listener listener, IApInterface apInterface) {
    return new SoftApManager(mWifiServiceHandlerThread.getLooper(), wifiNative, countryCode, allowed2GChannels, listener, apInterface);
}
#method_after
public SoftApManager makeSoftApManager(INetworkManagementService nmService, SoftApManager.Listener listener, IApInterface apInterface, WifiConfiguration config) {
    return new SoftApManager(mWifiServiceHandlerThread.getLooper(), mWifiNative, mCountryCode.getCountryCode(), listener, apInterface, nmService, mWifiApConfigStore, config);
}
#end_block

#method_before
public PasspointEventHandler makePasspointEventHandler(PasspointManager passpointManager) {
    return new PasspointEventHandler(mWifiNative, passpointManager);
}
#method_after
public PasspointEventHandler makePasspointEventHandler(PasspointEventHandler.Callbacks callbacks) {
    return new PasspointEventHandler(mWifiNative, callbacks);
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    initMocks(this);
    when(mWifiInjector.makePasspointEventHandler(any(PasspointManager.class))).thenReturn(mHandler);
    mManager = new PasspointManager(mContext, mWifiInjector);
}
#method_after
@Before
public void setUp() throws Exception {
    initMocks(this);
    mManager = new PasspointManager(mContext, mWifiInjector);
    ArgumentCaptor<PasspointEventHandler.Callbacks> callbacks = ArgumentCaptor.forClass(PasspointEventHandler.Callbacks.class);
    verify(mWifiInjector).makePasspointEventHandler(callbacks.capture());
    mCallbacks = callbacks.getValue();
}
#end_block

#method_before
@Test
public void iconResponseSuccess() {
    byte[] iconData = new byte[] { 0x00, 0x11 };
    mManager.onIconResponse(BSSID, ICON_FILENAME, iconData);
    verifyIconIntent(BSSID, ICON_FILENAME, iconData);
}
#method_after
@Test
public void iconResponseSuccess() {
    byte[] iconData = new byte[] { 0x00, 0x11 };
    mCallbacks.onIconResponse(BSSID, ICON_FILENAME, iconData);
    verifyIconIntent(BSSID, ICON_FILENAME, iconData);
}
#end_block

#method_before
@Test
public void iconResponseFailure() {
    mManager.onIconResponse(BSSID, ICON_FILENAME, null);
    verifyIconIntent(BSSID, ICON_FILENAME, null);
}
#method_after
@Test
public void iconResponseFailure() {
    mCallbacks.onIconResponse(BSSID, ICON_FILENAME, null);
    verifyIconIntent(BSSID, ICON_FILENAME, null);
}
#end_block

#method_before
public void testThreadDoubleStart() {
    final ReentrantLock lock = new ReentrantLock();
    Thread thread = new Thread() {

        public void run() {
            lock.lock();
        }
    };
    lock.lock();
    try {
        thread.start();
        try {
            thread.start();
            fail("Call Thread.start for already started thread should throw IllegalThreadStateException");
        } catch (IllegalThreadStateException e) {
        }
    } finally {
        lock.unlock();
    }
    try {
        thread.join();
    } catch (InterruptedException e) {
    }
}
#method_after
public void testThreadDoubleStart() {
    final ReentrantLock lock = new ReentrantLock();
    Thread thread = new Thread() {

        public void run() {
            // Lock should be acquired by the main thread and
            // this thread should block on this operation.
            lock.lock();
        }
    };
    // Acquire lock to ensure that new thread is not finished
    // when we call start() second time.
    lock.lock();
    try {
        thread.start();
        try {
            thread.start();
            fail();
        } catch (IllegalThreadStateException expected) {
        }
    } finally {
        lock.unlock();
    }
    try {
        thread.join();
    } catch (InterruptedException ignored) {
    }
}
#end_block

#method_before
public void testThreadRestart() {
    Thread thread = new Thread();
    thread.start();
    try {
        thread.join();
    } catch (InterruptedException e) {
    }
    try {
        thread.start();
        fail("Cannot restart thread");
    } catch (IllegalThreadStateException e) {
    }
}
#method_after
public void testThreadRestart() {
    Thread thread = new Thread();
    thread.start();
    try {
        thread.join();
    } catch (InterruptedException ignored) {
    }
    try {
        thread.start();
        fail();
    } catch (IllegalThreadStateException expected) {
    }
}
#end_block

#method_before
public synchronized void start() {
    /**
     * This method is not invoked for the main method thread or "system"
     * group threads created/set up by the VM. Any new functionality added
     * to this method in the future may have to also be added to the VM.
     *
     * A zero status value corresponds to state "NEW".
     */
    if (threadStatus != 0 || started)
        throw new IllegalThreadStateException();
    /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
    group.add(this);
    started = false;
    try {
        nativeCreate(this, stackSize, daemon);
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
        /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
        }
    }
}
#method_after
public synchronized void start() {
    // Android-changed: throw if 'started' is true
    if (threadStatus != 0 || started)
        throw new IllegalThreadStateException();
    /* Notify the group that this thread is about to be started
         * so that it can be added to the group's list of threads
         * and the group's unstarted count can be decremented. */
    group.add(this);
    started = false;
    try {
        nativeCreate(this, stackSize, daemon);
        started = true;
    } finally {
        try {
            if (!started) {
                group.threadStartFailed(this);
            }
        } catch (Throwable ignore) {
        /* do nothing. If start0 threw a Throwable then
                  it will be passed up the call stack */
        }
    }
}
#end_block

#method_before
private static Class<?> tryToLoadClass(final ClassLoader loader, final Class<?> helper) throws ClassNotFoundException {
    try {
        return loader.loadClass(helper.getName());
    } catch (ClassNotFoundException e) {
        // The helper class is NOT found in target ClassLoader, we have to define the helper class.
        final byte[] classBinary = classToByteArray(helper);
        return AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {

            @Override
            public Class<?> run() {
                try {
                    // Define the helper class in the target ClassLoader,
                    // then we can call the helper to load the native library.
                    Method defineClass = ClassLoader.class.getDeclaredMethod("defineClass", String.class, byte[].class, int.class, int.class);
                    defineClass.setAccessible(true);
                    return (Class<?>) defineClass.invoke(loader, helper.getName(), classBinary, 0, classBinary.length);
                } catch (Exception e) {
                    throw new IllegalStateException("Define class failed!", e);
                }
            }
        });
    }
}
#method_after
private static Class<?> tryToLoadClass(final ClassLoader loader, final Class<?> helper) throws ClassNotFoundException {
    try {
        return loader.loadClass(helper.getName());
    } catch (ClassNotFoundException e) {
        // The helper class is NOT found in target ClassLoader, we have to define the helper
        // class.
        final byte[] classBinary = classToByteArray(helper);
        return AccessController.doPrivileged(new PrivilegedAction<Class<?>>() {

            @Override
            public Class<?> run() {
                try {
                    // Define the helper class in the target ClassLoader,
                    // then we can call the helper to load the native library.
                    Method defineClass = ClassLoader.class.getDeclaredMethod("defineClass", String.class, byte[].class, int.class, int.class);
                    defineClass.setAccessible(true);
                    return (Class<?>) defineClass.invoke(loader, helper.getName(), classBinary, 0, classBinary.length);
                } catch (Exception e) {
                    throw new IllegalStateException("Define class failed!", e);
                }
            }
        });
    }
}
#end_block

#method_before
public static PasspointConfiguration parseMOText(String xmlString) {
    // Convert the XML string to a XML tree.
    XMLParser xmlParser = new XMLParser();
    XMLNode root = null;
    try {
        root = xmlParser.parse(xmlString);
    } catch (IOException | SAXException e) {
        return null;
    }
    if (root == null) {
        return null;
    }
    // Verify root node is a "MgmtTree" node.
    if (root.getTag() != TAG_MANAGEMENT_TREE) {
        Log.e(TAG, "Root is not a MgmtTree");
        return null;
    }
    String verDtd = null;
    PasspointConfiguration config = null;
    for (XMLNode child : root.getChildren()) {
        switch(child.getTag()) {
            case TAG_VER_DTD:
                if (verDtd != null) {
                    Log.e(TAG, "Duplicate VerDTD element");
                    return null;
                }
                verDtd = child.getText();
                break;
            case TAG_NODE:
                if (config != null) {
                    Log.e(TAG, "Unexpected multiple child nodes");
                    return null;
                }
                try {
                    config = parsePpsNode(child);
                } catch (ParsingException e) {
                    Log.e(TAG, e.getMessage());
                    return null;
                }
                break;
            default:
                Log.e(TAG, "Unknown node: " + child.getTag());
                return null;
        }
    }
    return config;
}
#method_after
public static PasspointConfiguration parseMOText(String xmlString) {
    // Convert the XML string to a XML tree.
    XMLParser xmlParser = new XMLParser();
    XMLNode root = null;
    try {
        root = xmlParser.parse(xmlString);
    } catch (IOException | SAXException e) {
        return null;
    }
    if (root == null) {
        return null;
    }
    // Verify root node is a "MgmtTree" node.
    if (root.getTag() != TAG_MANAGEMENT_TREE) {
        Log.e(TAG, "Root is not a MgmtTree");
        return null;
    }
    // Used for detecting duplicate VerDTD element.
    String verDtd = null;
    PasspointConfiguration config = null;
    for (XMLNode child : root.getChildren()) {
        switch(child.getTag()) {
            case TAG_VER_DTD:
                if (verDtd != null) {
                    Log.e(TAG, "Duplicate VerDTD element");
                    return null;
                }
                verDtd = child.getText();
                break;
            case TAG_NODE:
                if (config != null) {
                    Log.e(TAG, "Unexpected multiple Node element under MgmtTree");
                    return null;
                }
                try {
                    config = parsePpsNode(child);
                } catch (ParsingException e) {
                    Log.e(TAG, e.getMessage());
                    return null;
                }
                break;
            default:
                Log.e(TAG, "Unknown node: " + child.getTag());
                return null;
        }
    }
    return config;
}
#end_block

#method_before
private static PasspointConfiguration parsePpsNode(XMLNode node) throws ParsingException {
    PasspointConfiguration config = null;
    String nodeName = null;
    for (XMLNode child : node.getChildren()) {
        switch(child.getTag()) {
            case TAG_NODE_NAME:
                if (nodeName != null)
                    throw new ParsingException("Duplicant NodeName: " + child.getText());
                nodeName = child.getText();
                if (!TextUtils.equals(nodeName, NODE_PER_PROVIDER_SUBSCRIPTION))
                    throw new ParsingException("Unexpected NodeName: " + nodeName);
                break;
            case TAG_NODE:
                // Only one PerProviderSubscription instance is expected and allowed.
                if (config != null) {
                    throw new ParsingException("Multiple PPS instance");
                }
                // Convert the XML tree to a PPS tree.
                PPSNode ppsInstanceRoot = buildPpsNode(child);
                config = parsePpsInstance(ppsInstanceRoot);
                break;
            case TAG_RT_PROPERTIES:
                // Parse and verify URN stored in the RT (Run Time) Properties.
                String urn = parseUrn(child);
                if (!TextUtils.equals(urn, PPS_MO_URN))
                    throw new ParsingException("Unknown URN: " + urn);
                break;
            default:
                throw new ParsingException("Unknown tag under PPS node: " + child.getTag());
        }
    }
    return config;
}
#method_after
private static PasspointConfiguration parsePpsNode(XMLNode node) throws ParsingException {
    PasspointConfiguration config = null;
    String nodeName = null;
    for (XMLNode child : node.getChildren()) {
        switch(child.getTag()) {
            case TAG_NODE_NAME:
                if (nodeName != null) {
                    throw new ParsingException("Duplicant NodeName: " + child.getText());
                }
                nodeName = child.getText();
                if (!TextUtils.equals(nodeName, NODE_PER_PROVIDER_SUBSCRIPTION)) {
                    throw new ParsingException("Unexpected NodeName: " + nodeName);
                }
                break;
            case TAG_NODE:
                // Only one PerProviderSubscription instance is expected and allowed.
                if (config != null) {
                    throw new ParsingException("Multiple PPS instance");
                }
                // Convert the XML tree to a PPS tree.
                PPSNode ppsInstanceRoot = buildPpsNode(child);
                config = parsePpsInstance(ppsInstanceRoot);
                break;
            case TAG_RT_PROPERTIES:
                // Parse and verify URN stored in the RT (Run Time) Properties.
                String urn = parseUrn(child);
                if (!TextUtils.equals(urn, PPS_MO_URN)) {
                    throw new ParsingException("Unknown URN: " + urn);
                }
                break;
            default:
                throw new ParsingException("Unknown tag under PPS node: " + child.getTag());
        }
    }
    return config;
}
#end_block

#method_before
private static String parseUrn(XMLNode node) throws ParsingException {
    if (node.getChildren().size() != 1)
        throw new ParsingException("Expect RTPProperties node to only have one child");
    XMLNode typeNode = node.getChildren().get(0);
    if (typeNode.getChildren().size() != 1)
        throw new ParsingException("Expect Type node to only have one child");
    if (!TextUtils.equals(typeNode.getTag(), TAG_TYPE))
        throw new ParsingException("Unexpected tag for Type: " + typeNode.getTag());
    XMLNode ddfNameNode = typeNode.getChildren().get(0);
    if (!ddfNameNode.getChildren().isEmpty())
        throw new ParsingException("Expect DDFName node to have no child");
    if (!TextUtils.equals(ddfNameNode.getTag(), TAG_DDF_NAME))
        throw new ParsingException("Unexpected tag for DDFName: " + ddfNameNode.getTag());
    return ddfNameNode.getText();
}
#method_after
private static String parseUrn(XMLNode node) throws ParsingException {
    if (node.getChildren().size() != 1)
        throw new ParsingException("Expect RTPProperties node to only have one child");
    XMLNode typeNode = node.getChildren().get(0);
    if (typeNode.getChildren().size() != 1) {
        throw new ParsingException("Expect Type node to only have one child");
    }
    if (!TextUtils.equals(typeNode.getTag(), TAG_TYPE)) {
        throw new ParsingException("Unexpected tag for Type: " + typeNode.getTag());
    }
    XMLNode ddfNameNode = typeNode.getChildren().get(0);
    if (!ddfNameNode.getChildren().isEmpty()) {
        throw new ParsingException("Expect DDFName node to have no child");
    }
    if (!TextUtils.equals(ddfNameNode.getTag(), TAG_DDF_NAME)) {
        throw new ParsingException("Unexpected tag for DDFName: " + ddfNameNode.getTag());
    }
    return ddfNameNode.getText();
}
#end_block

#method_before
private static PPSNode buildPpsNode(XMLNode node) throws ParsingException {
    String nodeName = null;
    String nodeValue = null;
    List<PPSNode> childNodes = new ArrayList<PPSNode>();
    // Names of parsed child nodes, use for detecting multiple child nodes with the same name.
    Set<String> parsedNodes = new HashSet<String>();
    for (XMLNode child : node.getChildren()) {
        String tag = child.getTag();
        if (TextUtils.equals(tag, TAG_NODE_NAME)) {
            if (nodeName != null)
                throw new ParsingException("Duplicate NodeName node");
            nodeName = child.getText();
        } else if (TextUtils.equals(tag, TAG_NODE)) {
            PPSNode ppsNode = buildPpsNode(child);
            if (parsedNodes.contains(ppsNode.getName()))
                throw new ParsingException("Duplicate node: " + ppsNode.getName());
            childNodes.add(ppsNode);
        } else if (TextUtils.equals(tag, TAG_VALUE)) {
            if (nodeValue != null)
                throw new ParsingException("Duplicate Value node");
            nodeValue = child.getText();
        } else {
            throw new ParsingException("Unknown tag: " + tag);
        }
    }
    if (nodeName == null)
        throw new ParsingException("Invalid node: missing NodeName");
    if (nodeValue == null && childNodes.size() == 0)
        throw new ParsingException("Invalid node: " + nodeName + " missing both value and children");
    if (nodeValue != null && childNodes.size() > 0)
        throw new ParsingException("Invalid node: " + nodeName + " contained both value and children");
    if (nodeValue != null)
        return new LeafNode(nodeName, nodeValue);
    return new InternalNode(nodeName, childNodes);
}
#method_after
private static PPSNode buildPpsNode(XMLNode node) throws ParsingException {
    String nodeName = null;
    String nodeValue = null;
    List<PPSNode> childNodes = new ArrayList<PPSNode>();
    // Names of parsed child nodes, use for detecting multiple child nodes with the same name.
    Set<String> parsedNodes = new HashSet<String>();
    for (XMLNode child : node.getChildren()) {
        String tag = child.getTag();
        if (TextUtils.equals(tag, TAG_NODE_NAME)) {
            if (nodeName != null) {
                throw new ParsingException("Duplicate NodeName node");
            }
            nodeName = child.getText();
        } else if (TextUtils.equals(tag, TAG_NODE)) {
            PPSNode ppsNode = buildPpsNode(child);
            if (parsedNodes.contains(ppsNode.getName())) {
                throw new ParsingException("Duplicate node: " + ppsNode.getName());
            }
            parsedNodes.add(ppsNode.getName());
            childNodes.add(ppsNode);
        } else if (TextUtils.equals(tag, TAG_VALUE)) {
            if (nodeValue != null) {
                throw new ParsingException("Duplicate Value node");
            }
            nodeValue = child.getText();
        } else {
            throw new ParsingException("Unknown tag: " + tag);
        }
    }
    if (nodeName == null) {
        throw new ParsingException("Invalid node: missing NodeName");
    }
    if (nodeValue == null && childNodes.size() == 0) {
        throw new ParsingException("Invalid node: " + nodeName + " missing both value and children");
    }
    if (nodeValue != null && childNodes.size() > 0) {
        throw new ParsingException("Invalid node: " + nodeName + " contained both value and children");
    }
    if (nodeValue != null) {
        return new LeafNode(nodeName, nodeValue);
    }
    return new InternalNode(nodeName, childNodes);
}
#end_block

#method_before
private static String getPpsNodeValue(PPSNode node) throws ParsingException {
    if (!node.isLeaf())
        throw new ParsingException("Cannot get value from a non-leaf node: " + node.getName());
    return node.getValue();
}
#method_after
private static String getPpsNodeValue(PPSNode node) throws ParsingException {
    if (!node.isLeaf()) {
        throw new ParsingException("Cannot get value from a non-leaf node: " + node.getName());
    }
    return node.getValue();
}
#end_block

#method_before
private static PasspointConfiguration parsePpsInstance(PPSNode root) throws ParsingException {
    if (root.isLeaf())
        throw new ParsingException("Leaf node not expected for PPS instance");
    PasspointConfiguration config = new PasspointConfiguration();
    for (PPSNode child : root.getChildren()) {
        switch(child.getName()) {
            case NODE_HOMESP:
                config.homeSp = parseHomeSP(child);
                break;
            case NODE_CREDENTIAL:
                config.credential = parseCredential(child);
                break;
            default:
                throw new ParsingException("Unknown node: " + child.getName());
        }
    }
    return config;
}
#method_after
private static PasspointConfiguration parsePpsInstance(PPSNode root) throws ParsingException {
    if (root.isLeaf()) {
        throw new ParsingException("Leaf node not expected for PPS instance");
    }
    PasspointConfiguration config = new PasspointConfiguration();
    for (PPSNode child : root.getChildren()) {
        switch(child.getName()) {
            case NODE_HOMESP:
                config.homeSp = parseHomeSP(child);
                break;
            case NODE_CREDENTIAL:
                config.credential = parseCredential(child);
                break;
            default:
                throw new ParsingException("Unknown node: " + child.getName());
        }
    }
    return config;
}
#end_block

#method_before
private static HomeSP parseHomeSP(PPSNode node) throws ParsingException {
    if (node.isLeaf())
        throw new ParsingException("Leaf node not expected for HomeSP");
    HomeSP homeSp = new HomeSP();
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_FQDN:
                homeSp.fqdn = getPpsNodeValue(child);
                break;
            case NODE_FRIENDLY_NAME:
                homeSp.friendlyName = getPpsNodeValue(child);
                break;
            case NODE_ROAMING_CONSORTIUM_OI:
                homeSp.roamingConsortiumOIs = parseRoamingConsortiumOI(getPpsNodeValue(child));
                break;
            default:
                throw new ParsingException("Unknown node under HomeSP: " + child.getName());
        }
    }
    return homeSp;
}
#method_after
private static HomeSP parseHomeSP(PPSNode node) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for HomeSP");
    }
    HomeSP homeSp = new HomeSP();
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_FQDN:
                homeSp.fqdn = getPpsNodeValue(child);
                break;
            case NODE_FRIENDLY_NAME:
                homeSp.friendlyName = getPpsNodeValue(child);
                break;
            case NODE_ROAMING_CONSORTIUM_OI:
                homeSp.roamingConsortiumOIs = parseRoamingConsortiumOI(getPpsNodeValue(child));
                break;
            default:
                throw new ParsingException("Unknown node under HomeSP: " + child.getName());
        }
    }
    return homeSp;
}
#end_block

#method_before
private static Credential parseCredential(PPSNode node) throws ParsingException {
    if (node.isLeaf())
        throw new ParsingException("Leaf node not expected for HomeSP");
    Credential credential = new Credential();
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_USERNAME_PASSWORD:
                credential.userCredential = parseUserCredential(child);
                break;
            case NODE_DIGITAL_CERTIFICATE:
                credential.certCredential = parseCertificateCredential(child);
                break;
            case NODE_REALM:
                credential.realm = getPpsNodeValue(child);
                break;
            case NODE_SIM:
                credential.simCredential = parseSimCredential(child);
                break;
            default:
                throw new ParsingException("Unknown node under Credential: " + child.getName());
        }
    }
    return credential;
}
#method_after
private static Credential parseCredential(PPSNode node) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for HomeSP");
    }
    Credential credential = new Credential();
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_USERNAME_PASSWORD:
                credential.userCredential = parseUserCredential(child);
                break;
            case NODE_DIGITAL_CERTIFICATE:
                credential.certCredential = parseCertificateCredential(child);
                break;
            case NODE_REALM:
                credential.realm = getPpsNodeValue(child);
                break;
            case NODE_SIM:
                credential.simCredential = parseSimCredential(child);
                break;
            default:
                throw new ParsingException("Unknown node under Credential: " + child.getName());
        }
    }
    return credential;
}
#end_block

#method_before
private static Credential.UserCredential parseUserCredential(PPSNode node) throws ParsingException {
    if (node.isLeaf())
        throw new ParsingException("Leaf node not expected for UsernamePassword");
    Credential.UserCredential userCred = new Credential.UserCredential();
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_USERNAME:
                userCred.username = getPpsNodeValue(child);
                break;
            case NODE_PASSWORD:
                userCred.password = getPpsNodeValue(child);
                break;
            case NODE_EAP_METHOD:
                parseEAPMethod(child, userCred);
                break;
            default:
                throw new ParsingException("Unknown node under UsernamPassword: " + child.getName());
        }
    }
    return userCred;
}
#method_after
private static Credential.UserCredential parseUserCredential(PPSNode node) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for UsernamePassword");
    }
    Credential.UserCredential userCred = new Credential.UserCredential();
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_USERNAME:
                userCred.username = getPpsNodeValue(child);
                break;
            case NODE_PASSWORD:
                userCred.password = getPpsNodeValue(child);
                break;
            case NODE_EAP_METHOD:
                parseEAPMethod(child, userCred);
                break;
            default:
                throw new ParsingException("Unknown node under UsernamPassword: " + child.getName());
        }
    }
    return userCred;
}
#end_block

#method_before
private static void parseEAPMethod(PPSNode node, Credential.UserCredential userCred) throws ParsingException {
    if (node.isLeaf())
        throw new ParsingException("Leaf node not expected for EAPMethod");
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_EAP_TYPE:
                userCred.eapType = parseInteger(getPpsNodeValue(child));
                break;
            case NODE_INNER_METHOD:
                userCred.nonEapInnerMethod = getPpsNodeValue(child);
                break;
            default:
                throw new ParsingException("Unknown node under EAPMethod: " + child.getName());
        }
    }
}
#method_after
private static void parseEAPMethod(PPSNode node, Credential.UserCredential userCred) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for EAPMethod");
    }
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_EAP_TYPE:
                userCred.eapType = parseInteger(getPpsNodeValue(child));
                break;
            case NODE_INNER_METHOD:
                userCred.nonEapInnerMethod = getPpsNodeValue(child);
                break;
            default:
                throw new ParsingException("Unknown node under EAPMethod: " + child.getName());
        }
    }
}
#end_block

#method_before
private static Credential.CertificateCredential parseCertificateCredential(PPSNode node) throws ParsingException {
    if (node.isLeaf())
        throw new ParsingException("Leaf node not expected for DigitalCertificate");
    Credential.CertificateCredential certCred = new Credential.CertificateCredential();
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_CERTIFICATE_TYPE:
                certCred.certType = getPpsNodeValue(child);
                break;
            case NODE_CERT_SHA256_FINGERPRINT:
                certCred.certSha256FingerPrint = parseHexString(getPpsNodeValue(child));
                break;
            default:
                throw new ParsingException("Unknown node under DigitalCertificate: " + child.getName());
        }
    }
    return certCred;
}
#method_after
private static Credential.CertificateCredential parseCertificateCredential(PPSNode node) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for DigitalCertificate");
    }
    Credential.CertificateCredential certCred = new Credential.CertificateCredential();
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_CERTIFICATE_TYPE:
                certCred.certType = getPpsNodeValue(child);
                break;
            case NODE_CERT_SHA256_FINGERPRINT:
                certCred.certSha256FingerPrint = parseHexString(getPpsNodeValue(child));
                break;
            default:
                throw new ParsingException("Unknown node under DigitalCertificate: " + child.getName());
        }
    }
    return certCred;
}
#end_block

#method_before
private static Credential.SimCredential parseSimCredential(PPSNode node) throws ParsingException {
    if (node.isLeaf())
        throw new ParsingException("Leaf node not expected for SIM");
    Credential.SimCredential simCred = new Credential.SimCredential();
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_SIM_IMSI:
                simCred.imsi = getPpsNodeValue(child);
                break;
            case NODE_EAP_TYPE:
                simCred.eapType = parseInteger(getPpsNodeValue(child));
                break;
            default:
                throw new ParsingException("Unknown node under SIM: " + child.getName());
        }
    }
    return simCred;
}
#method_after
private static Credential.SimCredential parseSimCredential(PPSNode node) throws ParsingException {
    if (node.isLeaf()) {
        throw new ParsingException("Leaf node not expected for SIM");
    }
    Credential.SimCredential simCred = new Credential.SimCredential();
    for (PPSNode child : node.getChildren()) {
        switch(child.getName()) {
            case NODE_SIM_IMSI:
                simCred.imsi = getPpsNodeValue(child);
                break;
            case NODE_EAP_TYPE:
                simCred.eapType = parseInteger(getPpsNodeValue(child));
                break;
            default:
                throw new ParsingException("Unknown node under SIM: " + child.getName());
        }
    }
    return simCred;
}
#end_block

#method_before
private static byte[] parseHexString(String str) throws ParsingException {
    byte[] result = new byte[str.length() / 2];
    for (int i = 0; i < result.length; i++) {
        int index = i * 2;
        try {
            result[i] = (byte) Integer.parseInt(str.substring(index, index + 2), 16);
        } catch (NumberFormatException e) {
            throw new ParsingException("Invalid hex string: " + str);
        }
    }
    return result;
}
#method_after
private static byte[] parseHexString(String str) throws ParsingException {
    if ((str.length() & 1) == 1) {
        throw new ParsingException("Odd length hex string: " + str.length());
    }
    byte[] result = new byte[str.length() / 2];
    for (int i = 0; i < result.length; i++) {
        int index = i * 2;
        try {
            result[i] = (byte) Integer.parseInt(str.substring(index, index + 2), 16);
        } catch (NumberFormatException e) {
            throw new ParsingException("Invalid hex string: " + str);
        }
    }
    return result;
}
#end_block

#method_before
public void close() {
    // Remove the leading the trailing whitespaces.
    mText = mTextBuilder.toString().trim();
    mTextBuilder = null;
}
#method_after
public void close() {
    // Remove the leading and the trailing whitespaces.
    mText = mTextBuilder.toString().trim();
    mTextBuilder = null;
}
#end_block

#method_before
@Override
public boolean equals(Object thatObject) {
    if (this == thatObject) {
        return true;
    }
    if (thatObject == null || getClass() != thatObject.getClass()) {
        return false;
    }
    XMLNode that = (XMLNode) thatObject;
    return TextUtils.equals(mTag, that.mTag) && TextUtils.equals(getText(), that.getText()) && mChildren.equals(that.mChildren);
}
#method_after
@Override
public boolean equals(Object thatObject) {
    if (this == thatObject) {
        return true;
    }
    if (!(thatObject instanceof XMLNode)) {
        return false;
    }
    XMLNode that = (XMLNode) thatObject;
    return TextUtils.equals(mTag, that.mTag) && TextUtils.equals(mText, that.mText) && mChildren.equals(that.mChildren);
}
#end_block

#method_before
@Override
public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
    XMLNode parent = mCurrent;
    mCurrent = new XMLNode(parent, qName);
    if (mRoot == null)
        mRoot = mCurrent;
    else if (parent == null)
        throw new SAXException("More than one root nodes");
    else
        parent.addChild(mCurrent);
}
#method_after
@Override
public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
    XMLNode parent = mCurrent;
    mCurrent = new XMLNode(parent, qName);
    if (mRoot == null) {
        mRoot = mCurrent;
    } else if (parent == null) {
        throw new SAXException("More than one root nodes");
    } else {
        parent.addChild(mCurrent);
    }
}
#end_block

#method_before
@Override
public void endElement(String uri, String localName, String qName) throws SAXException {
    if (!qName.equals(mCurrent.getTag()))
        throw new SAXException("End tag '" + qName + "' doesn't match current node: " + mCurrent);
    mCurrent.close();
    mCurrent = mCurrent.getParent();
}
#method_after
@Override
public void endElement(String uri, String localName, String qName) throws SAXException {
    if (!qName.equals(mCurrent.getTag())) {
        throw new SAXException("End tag '" + qName + "' doesn't match current node: " + mCurrent);
    }
    mCurrent.close();
    mCurrent = mCurrent.getParent();
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeString(username);
    dest.writeString(password);
    dest.writeInt(machineManaged ? 1 : 0);
    dest.writeString(softTokenApp);
    dest.writeInt(ableToShare ? 1 : 0);
    dest.writeInt(eapType);
    dest.writeParcelable(expandedEapMethod, flags);
    dest.writeParcelable(innerEapMethod, flags);
    dest.writeString(nonEapInnerMethod);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeString(username);
    dest.writeString(password);
    dest.writeInt(eapType);
    dest.writeString(nonEapInnerMethod);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeLong(creationTime);
    dest.writeLong(expirationTime);
    dest.writeString(realm);
    dest.writeInt(checkAAAServerCertStatus ? 1 : 0);
    dest.writeParcelable(userCredential, flags);
    dest.writeParcelable(certCredential, flags);
    dest.writeParcelable(simCredential, flags);
    writeCertificate(dest, caCertificate);
    writeCertificates(dest, clientCertifcateChain);
    writePrivateKey(dest, clientPrivateKey);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeString(realm);
    dest.writeParcelable(userCredential, flags);
    dest.writeParcelable(certCredential, flags);
    dest.writeParcelable(simCredential, flags);
    ParcelUtil.writeCertificate(dest, caCertificate);
    ParcelUtil.writeCertificates(dest, clientCertificateChain);
    ParcelUtil.writePrivateKey(dest, clientPrivateKey);
}
#end_block

#method_before
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeString(fqdn);
    dest.writeString(friendlyName);
    dest.writeString(iconUrl);
    dest.writeBundle(homeNetworkIds);
    dest.writeBundle(homeOIList);
    dest.writeStringArray(otherHomePartners);
    dest.writeLongArray(roamingConsortiumOIs);
}
#method_after
@Override
public void writeToParcel(Parcel dest, int flags) {
    dest.writeString(fqdn);
    dest.writeString(friendlyName);
    dest.writeLongArray(roamingConsortiumOIs);
}
#end_block

#method_before
void releaseFD() {
    synchronized (fdLock) {
        fdUseCount--;
        if (fdUseCount == -1) {
            if (fd != null) {
                try {
                    socketClose();
                } catch (IOException e) {
                } finally {
                    fd = null;
                }
            }
        }
    }
}
#method_after
void releaseFD() {
    synchronized (fdLock) {
        fdUseCount--;
        if (fdUseCount == -1) {
            if (fd != null) {
                try {
                    socketClose();
                } catch (IOException e) {
                // Android-changed(http://b/26470377): Some Android code doesn't expect file
                // descriptor to be null. socketClose invalidates the fd by closing the fd.
                // } finally {
                // fd = null;
                }
            }
        }
    }
}
#end_block

#method_before
protected void finalize() {
    if (guard != null) {
        guard.warnIfOpen();
    }
    end();
}
#method_after
protected void finalize() {
    // Android-changed: added close guard
    if (guard != null) {
        guard.warnIfOpen();
    }
    end();
}
#end_block

#method_before
public void end() {
    synchronized (zsRef) {
        guard.close();
        long addr = zsRef.address();
        zsRef.clear();
        if (addr != 0) {
            end(addr);
            buf = null;
        }
    }
}
#method_after
public void end() {
    synchronized (zsRef) {
        // Android-changed: added close guard
        guard.close();
        long addr = zsRef.address();
        zsRef.clear();
        if (addr != 0) {
            end(addr);
            buf = null;
        }
    }
}
#end_block

#method_before
protected void finalize() {
    if (guard != null) {
        guard.warnIfOpen();
    }
    end();
}
#method_after
protected void finalize() {
    // Android-changed: added close guard
    if (guard != null) {
        guard.warnIfOpen();
    }
    end();
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mContext.getResources()).thenReturn(mResources);
    mTethering = new Tethering(mContext, mNMService, mStatsService, mPolicyManager, mLooper, mSystemProperties);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mContext.getResources()).thenReturn(mResources);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_usb_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_wifi_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    mTethering = new Tethering(mContext, mNMService, mStatsService, mPolicyManager, mLooper.getLooper(), mSystemProperties);
}
#end_block

#method_before
private void setupForRequiredProvisioning() {
    // Produce some acceptable looking provision app setting if requested.
    when(mResources.getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app)).thenReturn(PROVISIONING_APP_NAME);
    // Don't disable tethering provisioning unless requested.
    when(mSystemProperties.getBoolean(Tethering.DISABLE_PROVISIONING_SYSPROP_KEY, anyBoolean())).thenReturn(false);
    // Act like the CarrierConfigManager is present and ready unless told otherwise.
    when(mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE)).thenReturn(mCarrierConfigManager);
    when(mCarrierConfigManager.getConfig()).thenReturn(mCarrierConfig);
    when(mCarrierConfig.getBoolean(CarrierConfigManager.KEY_REQUIRE_ENTITLEMENT_CHECKS_BOOL)).thenReturn(true);
}
#method_after
private void setupForRequiredProvisioning() {
    // Produce some acceptable looking provision app setting if requested.
    when(mResources.getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app)).thenReturn(PROVISIONING_APP_NAME);
    // Don't disable tethering provisioning unless requested.
    when(mSystemProperties.getBoolean(eq(Tethering.DISABLE_PROVISIONING_SYSPROP_KEY), anyBoolean())).thenReturn(false);
    // Act like the CarrierConfigManager is present and ready unless told otherwise.
    when(mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE)).thenReturn(mCarrierConfigManager);
    when(mCarrierConfigManager.getConfig()).thenReturn(mCarrierConfig);
    mCarrierConfig.putBoolean(CarrierConfigManager.KEY_REQUIRE_ENTITLEMENT_CHECKS_BOOL, true);
}
#end_block

#method_before
@Test
public void canRequireProvisioning() {
    setupForRequiredProvisioning();
    verify(mTethering.isTetherProvisioningRequired());
}
#method_after
@Test
public void canRequireProvisioning() {
    setupForRequiredProvisioning();
    assertTrue(mTethering.isTetherProvisioningRequired());
}
#end_block

#method_before
@Test
public void provisioningNotRequiredWhenAppNotFound() {
    setupForRequiredProvisioning();
    when(mResources.getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app)).thenReturn(null);
    verify(!mTethering.isTetherProvisioningRequired());
    when(mResources.getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app)).thenReturn(new String[] { "malformedApp" });
    verify(!mTethering.isTetherProvisioningRequired());
}
#method_after
@Test
public void provisioningNotRequiredWhenAppNotFound() {
    setupForRequiredProvisioning();
    when(mResources.getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app)).thenReturn(null);
    assertTrue(!mTethering.isTetherProvisioningRequired());
    when(mResources.getStringArray(com.android.internal.R.array.config_mobile_hotspot_provision_app)).thenReturn(new String[] { "malformedApp" });
    assertTrue(!mTethering.isTetherProvisioningRequired());
}
#end_block

#method_before
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!mWifiConfigManager.enableNetwork(netId, true, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to enable=" + netId);
        return false;
    }
    if (!mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to connect=" + netId);
        // App does not have the permission to force a connection. But, we should still
        // reconsider this newly enabled network for network selection.
        mWifiConnectivityManager.forceConnectivityScan();
    } else {
        // Trigger an immediate connection to the specified network. We're also noting the user
        // connect choice here, so that it will be considered in the next network selection.
        mWifiConnectivityManager.setUserConnectChoice(netId);
        if (SupplicantState.isConnecting(mWifiInfo.getSupplicantState()) && mWifiInfo.getNetworkId() == netId) {
            // We're already connected to the user specified network, don't trigger a
            // reconnection.
            logi("connectToUserSelectNetwork already connecting/connected=" + netId);
        } else {
            startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
        }
    }
    return true;
}
#method_after
private boolean connectToUserSelectNetwork(int netId, int uid) {
    if (!mWifiConfigManager.enableNetwork(netId, true, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to enable=" + netId);
        return false;
    }
    if (!mWifiConfigManager.checkAndUpdateLastConnectUid(netId, uid)) {
        loge("connectToUserSelectNetwork uid " + uid + " did not have the permissions to connect=" + netId);
        // App does not have the permission to force a connection. But, we should still
        // reconsider this newly enabled network for network selection.
        mWifiConnectivityManager.forceConnectivityScan();
    } else {
        // Trigger an immediate connection to the specified network. We're also noting the user
        // connect choice here, so that it will be considered in the next network selection.
        mWifiConnectivityManager.setUserConnectChoice(netId);
        if (mWifiInfo.getNetworkId() == netId) {
            // We're already connected to the user specified network, don't trigger a
            // reconnection.
            logi("connectToUserSelectNetwork already connecting/connected=" + netId);
        } else {
            startConnectToNetwork(netId, SUPPLICANT_BSSID_ANY);
        }
    }
    return true;
}
#end_block

#method_before
@Test
public void test_newDirectoryStream() throws IOException {
    HashSet<Path> pathsSet = new HashSet<>();
    HashSet<Path> expectedPathsSet = new HashSet<>();
    expectedPathsSet.add(path_dir4);
    try (SecureDirectoryStream<Path> ds_path_root = (SecureDirectoryStream<Path>) Files.newDirectoryStream(path_root)) {
        try (DirectoryStream<Path> ds_path_dir1 = ds_path_root.newDirectoryStream(path_root.relativize(path_dir1))) {
            ds_path_dir1.forEach(path -> pathsSet.add(path));
            assertEquals(expectedPathsSet, pathsSet);
        }
    }
}
#method_after
@Test
public void test_newDirectoryStream() throws IOException {
    HashSet<Path> pathsSet = new HashSet<>();
    HashSet<Path> expectedPathsSet = new HashSet<>();
    expectedPathsSet.add(path_dir4);
    try (SecureDirectoryStream<Path> ds_path_root = (SecureDirectoryStream<Path>) Files.newDirectoryStream(path_root);
        DirectoryStream<Path> ds_path_dir1 = ds_path_root.newDirectoryStream(path_root.relativize(path_dir1))) {
        ds_path_dir1.forEach(path -> pathsSet.add(path));
        assertEquals(expectedPathsSet, pathsSet);
    }
}
#end_block

#method_before
@Test
public void test_getFileAttributeView_Path() throws IOException {
    try (SecureDirectoryStream<Path> ds_path_root = (SecureDirectoryStream<Path>) Files.newDirectoryStream(path_root)) {
        BasicFileAttributeView fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(path_dir1), BasicFileAttributeView.class);
        assertFalse(fileAttributeView.readAttributes().isRegularFile());
        assertTrue(fileAttributeView.readAttributes().isDirectory());
        assertFalse(fileAttributeView.readAttributes().isSymbolicLink());
        fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(path_f1), BasicFileAttributeView.class);
        assertTrue(fileAttributeView.readAttributes().isRegularFile());
        assertFalse(fileAttributeView.readAttributes().isDirectory());
        assertFalse(fileAttributeView.readAttributes().isSymbolicLink());
        // --- Exceptions ---
        try {
            ds_path_root.getFileAttributeView(null, BasicFileAttributeView.class);
            fail();
        } catch (NullPointerException expected) {
        }
        try {
            ds_path_root.getFileAttributeView(path_root.relativize(path_f1), null);
            fail();
        } catch (NullPointerException expected) {
        }
        // When directory stream is closed.
        ds_path_root.close();
        fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(path_f1), BasicFileAttributeView.class);
        try {
            fileAttributeView.readAttributes();
            fail();
        } catch (ClosedDirectoryStreamException expected) {
        }
    }
}
#method_after
@Test
public void test_getFileAttributeView_Path() throws IOException {
    try (SecureDirectoryStream<Path> ds_path_root = (SecureDirectoryStream<Path>) Files.newDirectoryStream(path_root)) {
        BasicFileAttributeView fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(path_dir1), BasicFileAttributeView.class);
        assertFalse(fileAttributeView.readAttributes().isRegularFile());
        assertTrue(fileAttributeView.readAttributes().isDirectory());
        assertFalse(fileAttributeView.readAttributes().isSymbolicLink());
        fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(path_f1), BasicFileAttributeView.class);
        assertTrue(fileAttributeView.readAttributes().isRegularFile());
        assertFalse(fileAttributeView.readAttributes().isDirectory());
        assertFalse(fileAttributeView.readAttributes().isSymbolicLink());
        // When file is a symbolic link.
        Path symlinkPath = Paths.get(path_root.toString(), "symlink");
        Files.createSymbolicLink(symlinkPath, path_dir1);
        assertTrue(Files.isSymbolicLink(symlinkPath));
        // When file is a symbolic link and method is invoked with LinkOptions.NOFOLLOW_LINKS.
        fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(symlinkPath), BasicFileAttributeView.class);
        assertTrue(fileAttributeView.readAttributes().isDirectory());
        // --- Exceptions ---
        try {
            ds_path_root.getFileAttributeView(null, BasicFileAttributeView.class);
            fail();
        } catch (NullPointerException expected) {
        }
        try {
            ds_path_root.getFileAttributeView(path_root.relativize(path_f1), null);
            fail();
        } catch (NullPointerException expected) {
        }
        // When directory stream is closed.
        ds_path_root.close();
        fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(path_f1), BasicFileAttributeView.class);
        try {
            fileAttributeView.readAttributes();
            fail();
        } catch (ClosedDirectoryStreamException expected) {
        }
    }
}
#end_block

#method_before
@Test
public void test_getFileAttributeView_Path_LinkOptions() throws IOException {
    Path symlinkPath = Paths.get(path_root.toString(), "symlink");
    // When file is a symbolic link and method is invoked with LinkOptions.NOFOLLOW_LINKS.
    try (SecureDirectoryStream<Path> ds_path_root = (SecureDirectoryStream<Path>) Files.newDirectoryStream(path_root)) {
        BasicFileAttributeView fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(symlinkPath), BasicFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);
        fileAttributeView.readAttributes();
        fail();
    } catch (FileSystemException expected) {
    }
    // When file is not a symbolic link.
    try (SecureDirectoryStream<Path> ds_path_root = (SecureDirectoryStream<Path>) Files.newDirectoryStream(path_root)) {
        BasicFileAttributeView fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(path_f1), BasicFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);
        assertTrue(fileAttributeView.readAttributes().isRegularFile());
        assertFalse(fileAttributeView.readAttributes().isDirectory());
        assertFalse(fileAttributeView.readAttributes().isSymbolicLink());
    }
    // NullPointerException
    try (SecureDirectoryStream<Path> ds_path_root = (SecureDirectoryStream<Path>) Files.newDirectoryStream(path_root)) {
        ds_path_root.getFileAttributeView(path_root.relativize(path_f1), BasicFileAttributeView.class, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
@Test
public void test_getFileAttributeView_Path_LinkOptions() throws IOException {
    Path symlinkPath = Paths.get(path_root.toString(), "symlink");
    Files.createSymbolicLink(symlinkPath, path_dir1);
    assertTrue(Files.isSymbolicLink(symlinkPath));
    // When file is a symbolic link and method is invoked with LinkOptions.NOFOLLOW_LINKS.
    try (SecureDirectoryStream<Path> ds_path_root = (SecureDirectoryStream<Path>) Files.newDirectoryStream(path_root)) {
        BasicFileAttributeView fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(symlinkPath), BasicFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);
        assertTrue(fileAttributeView.readAttributes().isSymbolicLink());
    }
    // When file is not a symbolic link.
    try (SecureDirectoryStream<Path> ds_path_root = (SecureDirectoryStream<Path>) Files.newDirectoryStream(path_root)) {
        BasicFileAttributeView fileAttributeView = ds_path_root.getFileAttributeView(path_root.relativize(path_f1), BasicFileAttributeView.class, LinkOption.NOFOLLOW_LINKS);
        assertTrue(fileAttributeView.readAttributes().isRegularFile());
        assertFalse(fileAttributeView.readAttributes().isDirectory());
        assertFalse(fileAttributeView.readAttributes().isSymbolicLink());
    }
    // NullPointerException
    try (SecureDirectoryStream<Path> ds_path_root = (SecureDirectoryStream<Path>) Files.newDirectoryStream(path_root)) {
        ds_path_root.getFileAttributeView(path_root.relativize(path_f1), BasicFileAttributeView.class, null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
protected final boolean closeImpl() throws IOException {
    if (!isClosed) {
        isClosed = true;
        try {
            closedir(dp);
        } catch (UnixException x) {
            throw new IOException(x.errorString());
        }
        return true;
    } else {
        return false;
    }
}
#method_after
protected final boolean closeImpl() throws IOException {
    if (!isClosed) {
        isClosed = true;
        try {
            closedir(dp);
        } catch (UnixException x) {
            throw new IOException(x.errorString());
        }
        // Android-changed: Add CloseGuard support.
        guard.close();
        return true;
    } else {
        return false;
    }
}
#end_block

#method_before
@Override
public void close() throws IOException {
    writeLock().lock();
    try {
        closeImpl();
    } finally {
        writeLock().unlock();
    }
    guard.close();
}
#method_after
@Override
public void close() throws IOException {
    writeLock().lock();
    try {
        closeImpl();
    } finally {
        writeLock().unlock();
    }
}
#end_block

#method_before
protected void finalize() throws IOException {
    if (guard != null) {
        guard.warnIfOpen();
    }
    close();
}
#method_after
/**
 * Cleans up if the user forgets to close it.
 */
protected void finalize() throws IOException {
    if (guard != null) {
        guard.warnIfOpen();
    }
    close();
}
#end_block

#method_before
@Override
public void close() throws IOException {
    ds.writeLock().lock();
    try {
        if (ds.closeImpl()) {
            UnixNativeDispatcher.close(dfd);
        }
    } finally {
        ds.writeLock().unlock();
    }
    guard.close();
}
#method_after
@Override
public void close() throws IOException {
    ds.writeLock().lock();
    try {
        if (ds.closeImpl()) {
            UnixNativeDispatcher.close(dfd);
        }
    } finally {
        ds.writeLock().unlock();
    }
    // Android-changed: Add CloseGuard support.
    guard.close();
}
#end_block

#method_before
protected void finalize() throws IOException {
    if (guard != null) {
        guard.warnIfOpen();
    }
    close();
}
#method_after
/**
 * Cleans up if the user forgets to close it.
 */
protected void finalize() throws IOException {
    if (guard != null) {
        guard.warnIfOpen();
    }
    close();
}
#end_block

#method_before
public static void onWebViewProviderChanged(PackageInfo packageInfo) {
    LogPrinter printer = new LogPrinter(Log.DEBUG, LOGTAG);
    packageInfo.applicationInfo.dump(printer, "");
    sPackage = packageInfo;
    final String serviceName = getServiceName();
    if (SystemService.isStopped(serviceName)) {
        SystemService.start(serviceName);
    } else if (sZygote != null) {
        SystemService.restart(serviceName);
    }
    try {
        SystemService.waitForState(serviceName, SystemService.State.RUNNING, 5000);
    } catch (TimeoutException e) {
        Log.e(LOGTAG, "Timed out waiting for " + serviceName);
        return;
    }
    connectToZygoteIfNeeded();
}
#method_after
public static void onWebViewProviderChanged(PackageInfo packageInfo) {
    sPackage = packageInfo;
    // If multi-process is not enabled, then do not start the zygote service.
    if (!sMultiprocessEnabled) {
        return;
    }
    final String serviceName = getServiceName();
    if (SystemService.isStopped(serviceName)) {
        SystemService.start(serviceName);
    } else if (sZygote != null) {
        SystemService.restart(serviceName);
    }
    try {
        SystemService.waitForState(serviceName, SystemService.State.RUNNING, 5000);
    } catch (TimeoutException e) {
        Log.e(LOGTAG, "Timed out waiting for " + serviceName);
        return;
    }
    connectToZygoteIfNeeded();
}
#end_block

#method_before
@Override
protected boolean handlePreloadPackage(String packagePath, String libsPath) {
    Log.d(TAG, "Preload package ********************************************************");
    Log.d(TAG, "WebView package = " + packagePath);
    return false;
}
#method_after
@Override
protected boolean handlePreloadPackage(String packagePath, String libsPath) {
    // TODO: Use preload information to setup the ClassLoader.
    return false;
}
#end_block

#method_before
public static void main(String[] argv) {
    sServer = new WebViewZygoteServer();
    try {
        sServer.registerServerSocket("webview_zygote");
        Log.d(TAG, "Listening for WebView requests");
        sServer.runSelectLoop(TextUtils.join(",", Build.SUPPORTED_ABIS));
        sServer.closeServerSocket();
    } catch (Zygote.MethodAndArgsCaller caller) {
        caller.run();
    } catch (RuntimeException e) {
        Log.e(TAG, "Fatal exception:", e);
    }
    Log.d(TAG, "Exiting webview_zygote server loop");
    System.exit(0);
}
#method_after
public static void main(String[] argv) {
    sServer = new WebViewZygoteServer();
    // Zygote goes into its own process group.
    try {
        Os.setpgid(0, 0);
    } catch (ErrnoException ex) {
        throw new RuntimeException("Failed to setpgid(0,0)", ex);
    }
    try {
        sServer.registerServerSocket("webview_zygote");
        sServer.runSelectLoop(TextUtils.join(",", Build.SUPPORTED_ABIS));
        sServer.closeServerSocket();
    } catch (Zygote.MethodAndArgsCaller caller) {
        caller.run();
    } catch (RuntimeException e) {
        Log.e(TAG, "Fatal exception:", e);
    }
    System.exit(0);
}
#end_block

#method_before
private static String getAbiList(BufferedWriter writer, DataInputStream inputStream) throws IOException {
    // Each query starts with the argument count (1 in this case)
    writer.write("1");
    // ... followed by a new-line.
    writer.newLine();
    // ... followed by our only argument.
    writer.write("--query-abi-list");
    writer.newLine();
    writer.flush();
    // The response is a length prefixed stream of ASCII bytes.
    int numBytes = inputStream.readInt();
    byte[] bytes = new byte[numBytes];
    inputStream.readFully(bytes);
    return new String(bytes, StandardCharsets.US_ASCII);
}
#method_after
@GuardedBy("mLock")
private static String getAbiList(BufferedWriter writer, DataInputStream inputStream) throws IOException {
    // Each query starts with the argument count (1 in this case)
    writer.write("1");
    // ... followed by a new-line.
    writer.newLine();
    // ... followed by our only argument.
    writer.write("--query-abi-list");
    writer.newLine();
    writer.flush();
    // The response is a length prefixed stream of ASCII bytes.
    int numBytes = inputStream.readInt();
    byte[] bytes = new byte[numBytes];
    inputStream.readFully(bytes);
    return new String(bytes, StandardCharsets.US_ASCII);
}
#end_block

#method_before
private static Process.ProcessStartResult zygoteSendArgsAndGetResult(ZygoteState zygoteState, ArrayList<String> args) throws ZygoteStartFailedEx {
    try {
        /**
         * See com.android.internal.os.SystemZygoteInit.readArgumentList()
         * Presently the wire format to the zygote process is:
         * a) a count of arguments (argc, in essence)
         * b) a number of newline-separated argument strings equal to count
         *
         * After the zygote process reads these it will write the pid of
         * the child or -1 on failure, followed by boolean to
         * indicate whether a wrapper process was used.
         */
        final BufferedWriter writer = zygoteState.writer;
        final DataInputStream inputStream = zygoteState.inputStream;
        writer.write(Integer.toString(args.size()));
        writer.newLine();
        int sz = args.size();
        for (int i = 0; i < sz; i++) {
            String arg = args.get(i);
            if (arg.indexOf('\n') >= 0) {
                throw new ZygoteStartFailedEx("embedded newlines not allowed");
            }
            writer.write(arg);
            writer.newLine();
        }
        writer.flush();
        // Should there be a timeout on this?
        Process.ProcessStartResult result = new Process.ProcessStartResult();
        result.pid = inputStream.readInt();
        if (result.pid < 0) {
            throw new ZygoteStartFailedEx("fork() failed");
        }
        result.usingWrapper = inputStream.readBoolean();
        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
#method_after
@GuardedBy("mLock")
private static Process.ProcessStartResult zygoteSendArgsAndGetResult(ZygoteState zygoteState, ArrayList<String> args) throws ZygoteStartFailedEx {
    try {
        /**
         * See com.android.internal.os.SystemZygoteInit.readArgumentList()
         * Presently the wire format to the zygote process is:
         * a) a count of arguments (argc, in essence)
         * b) a number of newline-separated argument strings equal to count
         *
         * After the zygote process reads these it will write the pid of
         * the child or -1 on failure, followed by boolean to
         * indicate whether a wrapper process was used.
         */
        final BufferedWriter writer = zygoteState.writer;
        final DataInputStream inputStream = zygoteState.inputStream;
        writer.write(Integer.toString(args.size()));
        writer.newLine();
        int sz = args.size();
        for (int i = 0; i < sz; i++) {
            String arg = args.get(i);
            if (arg.indexOf('\n') >= 0) {
                throw new ZygoteStartFailedEx("embedded newlines not allowed");
            }
            writer.write(arg);
            writer.newLine();
        }
        writer.flush();
        // Should there be a timeout on this?
        Process.ProcessStartResult result = new Process.ProcessStartResult();
        result.pid = inputStream.readInt();
        if (result.pid < 0) {
            throw new ZygoteStartFailedEx("fork() failed");
        }
        result.usingWrapper = inputStream.readBoolean();
        return result;
    } catch (IOException ex) {
        zygoteState.close();
        throw new ZygoteStartFailedEx(ex);
    }
}
#end_block

#method_before
private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx {
    synchronized (this) {
        ArrayList<String> argsForZygote = new ArrayList<String>();
        // --runtime-args, --setuid=, --setgid=,
        // and --setgroups= must go first
        argsForZygote.add("--runtime-args");
        argsForZygote.add("--setuid=" + uid);
        argsForZygote.add("--setgid=" + gid);
        if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {
            argsForZygote.add("--enable-jni-logging");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {
            argsForZygote.add("--enable-safemode");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {
            argsForZygote.add("--enable-debugger");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {
            argsForZygote.add("--enable-checkjni");
        }
        if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {
            argsForZygote.add("--generate-debug-info");
        }
        if ((debugFlags & Zygote.DEBUG_ALWAYS_JIT) != 0) {
            argsForZygote.add("--always-jit");
        }
        if ((debugFlags & Zygote.DEBUG_NATIVE_DEBUGGABLE) != 0) {
            argsForZygote.add("--native-debuggable");
        }
        if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {
            argsForZygote.add("--enable-assert");
        }
        if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {
            argsForZygote.add("--mount-external-default");
        } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {
            argsForZygote.add("--mount-external-read");
        } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {
            argsForZygote.add("--mount-external-write");
        }
        argsForZygote.add("--target-sdk-version=" + targetSdkVersion);
        // --setgroups is a comma-separated list
        if (gids != null && gids.length > 0) {
            StringBuilder sb = new StringBuilder();
            sb.append("--setgroups=");
            int sz = gids.length;
            for (int i = 0; i < sz; i++) {
                if (i != 0) {
                    sb.append(',');
                }
                sb.append(gids[i]);
            }
            argsForZygote.add(sb.toString());
        }
        if (niceName != null) {
            argsForZygote.add("--nice-name=" + niceName);
        }
        if (seInfo != null) {
            argsForZygote.add("--seinfo=" + seInfo);
        }
        if (instructionSet != null) {
            argsForZygote.add("--instruction-set=" + instructionSet);
        }
        if (appDataDir != null) {
            argsForZygote.add("--app-data-dir=" + appDataDir);
        }
        argsForZygote.add(processClass);
        if (extraArgs != null) {
            for (String arg : extraArgs) {
                argsForZygote.add(arg);
            }
        }
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
#method_after
private Process.ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx {
    ArrayList<String> argsForZygote = new ArrayList<String>();
    // --runtime-args, --setuid=, --setgid=,
    // and --setgroups= must go first
    argsForZygote.add("--runtime-args");
    argsForZygote.add("--setuid=" + uid);
    argsForZygote.add("--setgid=" + gid);
    if ((debugFlags & Zygote.DEBUG_ENABLE_JNI_LOGGING) != 0) {
        argsForZygote.add("--enable-jni-logging");
    }
    if ((debugFlags & Zygote.DEBUG_ENABLE_SAFEMODE) != 0) {
        argsForZygote.add("--enable-safemode");
    }
    if ((debugFlags & Zygote.DEBUG_ENABLE_DEBUGGER) != 0) {
        argsForZygote.add("--enable-debugger");
    }
    if ((debugFlags & Zygote.DEBUG_ENABLE_CHECKJNI) != 0) {
        argsForZygote.add("--enable-checkjni");
    }
    if ((debugFlags & Zygote.DEBUG_GENERATE_DEBUG_INFO) != 0) {
        argsForZygote.add("--generate-debug-info");
    }
    if ((debugFlags & Zygote.DEBUG_ALWAYS_JIT) != 0) {
        argsForZygote.add("--always-jit");
    }
    if ((debugFlags & Zygote.DEBUG_NATIVE_DEBUGGABLE) != 0) {
        argsForZygote.add("--native-debuggable");
    }
    if ((debugFlags & Zygote.DEBUG_ENABLE_ASSERT) != 0) {
        argsForZygote.add("--enable-assert");
    }
    if (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) {
        argsForZygote.add("--mount-external-default");
    } else if (mountExternal == Zygote.MOUNT_EXTERNAL_READ) {
        argsForZygote.add("--mount-external-read");
    } else if (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) {
        argsForZygote.add("--mount-external-write");
    }
    argsForZygote.add("--target-sdk-version=" + targetSdkVersion);
    // --setgroups is a comma-separated list
    if (gids != null && gids.length > 0) {
        StringBuilder sb = new StringBuilder();
        sb.append("--setgroups=");
        int sz = gids.length;
        for (int i = 0; i < sz; i++) {
            if (i != 0) {
                sb.append(',');
            }
            sb.append(gids[i]);
        }
        argsForZygote.add(sb.toString());
    }
    if (niceName != null) {
        argsForZygote.add("--nice-name=" + niceName);
    }
    if (seInfo != null) {
        argsForZygote.add("--seinfo=" + seInfo);
    }
    if (instructionSet != null) {
        argsForZygote.add("--instruction-set=" + instructionSet);
    }
    if (appDataDir != null) {
        argsForZygote.add("--app-data-dir=" + appDataDir);
    }
    argsForZygote.add(processClass);
    if (extraArgs != null) {
        for (String arg : extraArgs) {
            argsForZygote.add(arg);
        }
    }
    synchronized (mLock) {
        return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
    }
}
#end_block

#method_before
public void establishZygoteConnectionForAbi(String abi) {
    try {
        openZygoteSocketIfNeeded(abi);
    } catch (ZygoteStartFailedEx ex) {
        throw new RuntimeException("Unable to connect to zygote for abi: " + abi, ex);
    }
}
#method_after
public void establishZygoteConnectionForAbi(String abi) {
    try {
        synchronized (mLock) {
            openZygoteSocketIfNeeded(abi);
        }
    } catch (ZygoteStartFailedEx ex) {
        throw new RuntimeException("Unable to connect to zygote for abi: " + abi, ex);
    }
}
#end_block

#method_before
private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {
    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
        try {
            primaryZygoteState = ZygoteState.connect(mSocket);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to primary zygote", ioe);
        }
    }
    if (primaryZygoteState.matches(abi)) {
        return primaryZygoteState;
    }
    // The primary zygote didn't match. Try the secondary.
    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
        try {
            secondaryZygoteState = ZygoteState.connect(mSecondarySocket);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to secondary zygote", ioe);
        }
    }
    if (secondaryZygoteState.matches(abi)) {
        return secondaryZygoteState;
    }
    throw new ZygoteStartFailedEx("Unsupported zygote ABI: " + abi);
}
#method_after
@GuardedBy("mLock")
private ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {
    Preconditions.checkState(Thread.holdsLock(mLock), "ZygoteProcess lock not held");
    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
        try {
            primaryZygoteState = ZygoteState.connect(mSocket);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to primary zygote", ioe);
        }
    }
    if (primaryZygoteState.matches(abi)) {
        return primaryZygoteState;
    }
    // The primary zygote didn't match. Try the secondary.
    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
        try {
            secondaryZygoteState = ZygoteState.connect(mSecondarySocket);
        } catch (IOException ioe) {
            throw new ZygoteStartFailedEx("Error connecting to secondary zygote", ioe);
        }
    }
    if (secondaryZygoteState.matches(abi)) {
        return secondaryZygoteState;
    }
    throw new ZygoteStartFailedEx("Unsupported zygote ABI: " + abi);
}
#end_block

#method_before
public void preloadPackageForAbi(String packagePath, String libsPath, String abi) throws ZygoteStartFailedEx, IOException {
    ZygoteState state = openZygoteSocketIfNeeded(abi);
    state.writer.write("3");
    state.writer.newLine();
    state.writer.write("--preload-package");
    state.writer.newLine();
    state.writer.write(packagePath);
    state.writer.newLine();
    state.writer.write(libsPath);
    state.writer.newLine();
    state.writer.flush();
}
#method_after
public void preloadPackageForAbi(String packagePath, String libsPath, String abi) throws ZygoteStartFailedEx, IOException {
    synchronized (mLock) {
        ZygoteState state = openZygoteSocketIfNeeded(abi);
        state.writer.write("3");
        state.writer.newLine();
        state.writer.write("--preload-package");
        state.writer.newLine();
        state.writer.write(packagePath);
        state.writer.newLine();
        state.writer.write(libsPath);
        state.writer.newLine();
        state.writer.flush();
    }
}
#end_block

