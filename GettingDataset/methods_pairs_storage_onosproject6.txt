697
#method_before
private void startSubscriptionConnection(String filterSchema) throws NetconfException {
    if (!serverCapabilities.contains("interleave")) {
        throw new NetconfException("Device" + deviceInfo + "does not support interleave");
    }
    String reply = sendRequest(createSubscriptionString(filterSchema));
    if (!checkReply(reply)) {
        throw new NetconfException("Subscription not successful with device " + deviceInfo + " with reply " + reply);
    }
    subscriptionConnected = true;
}
#method_after
@Beta
private void startSubscriptionConnection(String filterSchema) throws NetconfException {
    if (!serverCapabilities.contains("interleave")) {
        throw new NetconfException("Device" + deviceInfo + "does not support interleave");
    }
    String reply = sendRequest(createSubscriptionString(filterSchema));
    if (!checkReply(reply)) {
        throw new NetconfException("Subscription not successful with device " + deviceInfo + " with reply " + reply);
    }
    subscriptionConnected = true;
}
#end_block

#method_before
public void startSubscription(String filterSchema) throws NetconfException {
    if (!subscriptionConnected) {
        startSubscriptionConnection(filterSchema);
    }
    streamHandler.setEnableNotifications(true);
}
#method_after
@Override
public void startSubscription() throws NetconfException {
    if (!subscriptionConnected) {
        startSubscriptionConnection(null);
    }
    streamHandler.setEnableNotifications(true);
}
#end_block

#method_before
public void startSubscription(String filterSchema) throws NetconfException {
    if (!subscriptionConnected) {
        startSubscriptionConnection(filterSchema);
    }
    streamHandler.setEnableNotifications(true);
}
#method_after
@Beta
@Override
public void startSubscription(String filterSchema) throws NetconfException {
    if (!subscriptionConnected) {
        startSubscriptionConnection(filterSchema);
    }
    streamHandler.setEnableNotifications(true);
}
#end_block

#method_before
private String createSubscriptionString(String filterSchema) {
    StringBuilder subscriptionbuffer = new StringBuilder();
    subscriptionbuffer.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    subscriptionbuffer.append("  <create-subscription\n");
    subscriptionbuffer.append("xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n");
    if (filterSchema != null) {
        subscriptionbuffer.append("    ");
        subscriptionbuffer.append(SUBSCRIPTION_FILTER_OPEN).append(NEW_LINE);
        subscriptionbuffer.append(filterSchema).append(NEW_LINE);
        subscriptionbuffer.append("    ");
        subscriptionbuffer.append(FILTER_CLOSE).append(NEW_LINE);
    }
    subscriptionbuffer.append("  </create-subscription>\n");
    subscriptionbuffer.append("</rpc>\n");
    subscriptionbuffer.append(ENDPATTERN);
    return subscriptionbuffer.toString();
}
#method_after
@Beta
private String createSubscriptionString(String filterSchema) {
    StringBuilder subscriptionbuffer = new StringBuilder();
    subscriptionbuffer.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    subscriptionbuffer.append("  <create-subscription\n");
    subscriptionbuffer.append("xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n");
    // FIXME Only subtree filtering supported at the moment.
    if (filterSchema != null) {
        subscriptionbuffer.append("    ");
        subscriptionbuffer.append(SUBSCRIPTION_SUBTREE_FILTER_OPEN).append(NEW_LINE);
        subscriptionbuffer.append(filterSchema).append(NEW_LINE);
        subscriptionbuffer.append("    ");
        subscriptionbuffer.append(SUBTREE_FILTER_CLOSE).append(NEW_LINE);
    }
    subscriptionbuffer.append("  </create-subscription>\n");
    subscriptionbuffer.append("</rpc>\n");
    subscriptionbuffer.append(ENDPATTERN);
    return subscriptionbuffer.toString();
}
#end_block

#method_before
@Override
public String get(String filterSchema, String withDefaultsMode) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(GET_OPEN).append(NEW_LINE);
    if (filterSchema != null) {
        rpc.append(FILTER_OPEN).append(NEW_LINE);
        rpc.append(filterSchema).append(NEW_LINE);
        rpc.append(FILTER_CLOSE).append(NEW_LINE);
    }
    if (withDefaultsMode != null) {
        rpc.append(WITH_DEFAULT_OPEN).append(NETCONF_WITH_DEFAULTS_NAMESPACE).append(">");
        rpc.append(withDefaultsMode).append(WITH_DEFAULT_CLOSE).append(NEW_LINE);
    }
    rpc.append(GET_CLOSE).append(NEW_LINE);
    rpc.append(RPC_CLOSE).append(NEW_LINE);
    rpc.append(ENDPATTERN);
    String reply = sendRequest(rpc.toString());
    checkReply(reply);
    return reply;
}
#method_after
@Override
public String get(String filterSchema, String withDefaultsMode) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(GET_OPEN).append(NEW_LINE);
    if (filterSchema != null) {
        rpc.append(SUBTREE_FILTER_OPEN).append(NEW_LINE);
        rpc.append(filterSchema).append(NEW_LINE);
        rpc.append(SUBTREE_FILTER_CLOSE).append(NEW_LINE);
    }
    if (withDefaultsMode != null) {
        rpc.append(WITH_DEFAULT_OPEN).append(NETCONF_WITH_DEFAULTS_NAMESPACE).append(">");
        rpc.append(withDefaultsMode).append(WITH_DEFAULT_CLOSE).append(NEW_LINE);
    }
    rpc.append(GET_CLOSE).append(NEW_LINE);
    rpc.append(RPC_CLOSE).append(NEW_LINE);
    rpc.append(ENDPATTERN);
    String reply = sendRequest(rpc.toString());
    checkReply(reply);
    return reply;
}
#end_block

#method_before
@Override
protected void execute() {
    DriverService service = get(DriverService.class);
    deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    VoltAlertConfig voltNe = h.behaviour(VoltAlertConfig.class);
    String reply = voltNe.getAlertFilter();
    if (reply != null) {
        print("%s", reply);
    }
}
#method_after
@Override
protected void execute() {
    DriverService service = get(DriverService.class);
    deviceId = DeviceId.deviceId(uri);
    DriverHandler h = service.createHandler(deviceId);
    VoltAlertConfig voltNe = h.behaviour(VoltAlertConfig.class);
    String reply = voltNe.getAlertFilter();
    if (reply != null) {
        print("%s", reply);
    } else {
        print("No reply from %s", deviceId.toString());
    }
}
#end_block

#method_before
@Before
public void setUp() {
    sut = new PathIntentCompiler();
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication("org.onosproject.net.intent")).andReturn(appId);
    sut.coreService = coreService;
    sut.resourceService = new MockResourceService();
    Intent.bindIdGenerator(idGenerator);
    intent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).path(new DefaultPath(pid, links, hops)).build();
    // Intent with VLAN encap without egress VLAN
    constraintVlanIntent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, links, hops)).build();
    // Intent with VLAN encap with ingress and egress VLAN
    constrainIngressEgressVlanIntent = PathIntent.builder().appId(APP_ID).selector(vlanSelector).treatment(vlanTreatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, links, hops)).build();
    constraintMplsIntent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.MPLS))).path(new DefaultPath(pid, links, hops)).build();
    constraintVlanIntent2 = PathIntent.builder().appId(APP_ID).selector(vlanSelector).treatment(vlanTreatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, linksOneHop, nHops)).build();
    intentExtensionService = createMock(IntentExtensionService.class);
    intentExtensionService.registerCompiler(PathIntent.class, sut);
    intentExtensionService.unregisterCompiler(PathIntent.class);
    registrator = new IntentConfigurableRegistrator();
    registrator.extensionService = intentExtensionService;
    registrator.cfgService = new ComponentConfigAdapter();
    registrator.activate();
    sut.registrator = registrator;
    replay(coreService, intentExtensionService);
}
#method_after
@Before
public void setUp() {
    sut = new PathIntentCompiler();
    coreService = createMock(CoreService.class);
    expect(coreService.registerApplication("org.onosproject.net.intent")).andReturn(appId);
    sut.coreService = coreService;
    sut.resourceService = new MockResourceService();
    Intent.bindIdGenerator(idGenerator);
    intent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).path(new DefaultPath(pid, links, hops)).build();
    // Intent with VLAN encap without egress VLAN
    constraintVlanIntent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, links, hops)).build();
    // Intent with VLAN encap with ingress and egress VLAN
    constrainIngressEgressVlanIntent = PathIntent.builder().appId(APP_ID).selector(vlanSelector).treatment(vlanTreatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, links, hops)).build();
    constraintMplsIntent = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.MPLS))).path(new DefaultPath(pid, links, hops)).build();
    edgeIntentNoVlan = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, edgeNet, edgeHops)).build();
    edgeIntentIngressVlan = PathIntent.builder().appId(APP_ID).selector(vlanSelector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, edgeNet, edgeHops)).build();
    edgeIntentEgressVlan = PathIntent.builder().appId(APP_ID).selector(selector).treatment(vlanTreatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, edgeNet, edgeHops)).build();
    edgeIntentVlan = PathIntent.builder().appId(APP_ID).selector(vlanSelector).treatment(vlanTreatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, edgeNet, edgeHops)).build();
    singleHopIndirectIntentNoVlan = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, singleHopIndirect, singleHopIndirectHops)).build();
    singleHopIndirectIntentIngressVlan = PathIntent.builder().appId(APP_ID).selector(vlanSelector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, singleHopIndirect, singleHopIndirectHops)).build();
    singleHopIndirectIntentEgressVlan = PathIntent.builder().appId(APP_ID).selector(selector).treatment(vlanTreatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, singleHopIndirect, singleHopIndirectHops)).build();
    singleHopIndirectIntentVlan = PathIntent.builder().appId(APP_ID).selector(vlanSelector).treatment(vlanTreatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, singleHopIndirect, singleHopIndirectHops)).build();
    singleHopDirectIntentNoVlan = PathIntent.builder().appId(APP_ID).selector(selector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, singleHopDirect, singleHopDirectHops)).build();
    singleHopDirectIntentIngressVlan = PathIntent.builder().appId(APP_ID).selector(vlanSelector).treatment(treatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, singleHopDirect, singleHopDirectHops)).build();
    singleHopDirectIntentEgressVlan = PathIntent.builder().appId(APP_ID).selector(selector).treatment(vlanTreatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, singleHopDirect, singleHopDirectHops)).build();
    singleHopDirectIntentVlan = PathIntent.builder().appId(APP_ID).selector(vlanSelector).treatment(vlanTreatment).priority(PRIORITY).constraints(ImmutableList.of(new EncapsulationConstraint(EncapsulationType.VLAN))).path(new DefaultPath(pid, singleHopDirect, singleHopDirectHops)).build();
    intentExtensionService = createMock(IntentExtensionService.class);
    intentExtensionService.registerCompiler(PathIntent.class, sut);
    intentExtensionService.unregisterCompiler(PathIntent.class);
    registrator = new IntentConfigurableRegistrator();
    registrator.extensionService = intentExtensionService;
    registrator.cfgService = new ComponentConfigAdapter();
    registrator.activate();
    sut.registrator = registrator;
    replay(coreService, intentExtensionService);
}
#end_block

#method_before
@Test
public void testPushGroupMetrics() {
    groupStore.deviceInitialAuditCompleted(deviceId1, true);
    groupStore.deviceInitialAuditCompleted(deviceId2, true);
    GroupDescription groupDescription3 = new DefaultGroupDescription(deviceId1, GroupDescription.Type.SELECT, buckets, new DefaultGroupKey("aaa".getBytes()), null, APP_ID);
    groupStore.storeGroupDescription(groupDescription1);
    groupStore.storeGroupDescription(groupDescription2);
    groupStore.storeGroupDescription(groupDescription3);
    Group group1 = groupStore.getGroup(deviceId1, groupId1);
    assertThat(group1, instanceOf(DefaultGroup.class));
    DefaultGroup defaultGroup1 = (DefaultGroup) group1;
    defaultGroup1.setPackets(55L);
    defaultGroup1.setBytes(66L);
    groupStore.pushGroupMetrics(deviceId1, ImmutableList.of(group1));
    // Make sure the group was updated.
    Group requeryGroup1 = groupStore.getGroup(deviceId1, groupId1);
    assertThat(requeryGroup1.packets(), is(55L));
    assertThat(requeryGroup1.bytes(), is(66L));
}
#method_after
@Test
public void testPushGroupMetrics() {
    groupStore.deviceInitialAuditCompleted(deviceId1, true);
    groupStore.deviceInitialAuditCompleted(deviceId2, true);
    GroupDescription groupDescription3 = new DefaultGroupDescription(deviceId1, SELECT, buckets, new DefaultGroupKey("aaa".getBytes()), null, APP_ID);
    groupStore.storeGroupDescription(groupDescription1);
    groupStore.storeGroupDescription(groupDescription2);
    groupStore.storeGroupDescription(groupDescription3);
    Group group1 = groupStore.getGroup(deviceId1, groupId1);
    assertThat(group1, instanceOf(DefaultGroup.class));
    DefaultGroup defaultGroup1 = (DefaultGroup) group1;
    defaultGroup1.setPackets(55L);
    defaultGroup1.setBytes(66L);
    groupStore.pushGroupMetrics(deviceId1, ImmutableList.of(group1));
    // Make sure the group was updated.
    Group requeryGroup1 = groupStore.getGroup(deviceId1, groupId1);
    assertThat(requeryGroup1.packets(), is(55L));
    assertThat(requeryGroup1.bytes(), is(66L));
}
#end_block

#method_before
@Test
public void testGroupOperationFailed() {
    TestDelegate delegate = new TestDelegate();
    groupStore.setDelegate(delegate);
    groupStore.deviceInitialAuditCompleted(deviceId1, true);
    groupStore.deviceInitialAuditCompleted(deviceId2, true);
    groupStore.storeGroupDescription(groupDescription1);
    groupStore.storeGroupDescription(groupDescription2);
    List<GroupEvent> eventsAfterAdds = delegate.eventsSeen();
    assertThat(eventsAfterAdds, hasSize(2));
    eventsAfterAdds.stream().forEach(event -> assertThat(event.type(), is(GroupEvent.Type.GROUP_ADD_REQUESTED)));
    delegate.resetEvents();
    GroupOperation opAdd = GroupOperation.createAddGroupOperation(groupId1, GroupDescription.Type.INDIRECT, buckets);
    groupStore.groupOperationFailed(deviceId1, opAdd);
    List<GroupEvent> eventsAfterAddFailed = delegate.eventsSeen();
    assertThat(eventsAfterAddFailed, hasSize(2));
    assertThat(eventsAfterAddFailed.get(0).type(), is(GroupEvent.Type.GROUP_ADD_FAILED));
    assertThat(eventsAfterAddFailed.get(1).type(), is(GroupEvent.Type.GROUP_REMOVED));
    delegate.resetEvents();
    GroupOperation opModify = GroupOperation.createModifyGroupOperation(groupId2, GroupDescription.Type.INDIRECT, buckets);
    groupStore.groupOperationFailed(deviceId2, opModify);
    List<GroupEvent> eventsAfterModifyFailed = delegate.eventsSeen();
    assertThat(eventsAfterModifyFailed, hasSize(1));
    assertThat(eventsAfterModifyFailed.get(0).type(), is(GroupEvent.Type.GROUP_UPDATE_FAILED));
    delegate.resetEvents();
    GroupOperation opDelete = GroupOperation.createDeleteGroupOperation(groupId2, GroupDescription.Type.INDIRECT);
    groupStore.groupOperationFailed(deviceId2, opDelete);
    List<GroupEvent> eventsAfterDeleteFailed = delegate.eventsSeen();
    assertThat(eventsAfterDeleteFailed, hasSize(1));
    assertThat(eventsAfterDeleteFailed.get(0).type(), is(GroupEvent.Type.GROUP_REMOVE_FAILED));
    delegate.resetEvents();
}
#method_after
@Test
public void testGroupOperationFailed() {
    TestDelegate delegate = new TestDelegate();
    groupStore.setDelegate(delegate);
    groupStore.deviceInitialAuditCompleted(deviceId1, true);
    groupStore.deviceInitialAuditCompleted(deviceId2, true);
    groupStore.storeGroupDescription(groupDescription1);
    groupStore.storeGroupDescription(groupDescription2);
    List<GroupEvent> eventsAfterAdds = delegate.eventsSeen();
    assertThat(eventsAfterAdds, hasSize(2));
    eventsAfterAdds.stream().forEach(event -> assertThat(event.type(), is(GroupEvent.Type.GROUP_ADD_REQUESTED)));
    delegate.resetEvents();
    GroupOperation opAdd = GroupOperation.createAddGroupOperation(groupId1, INDIRECT, buckets);
    groupStore.groupOperationFailed(deviceId1, opAdd);
    List<GroupEvent> eventsAfterAddFailed = delegate.eventsSeen();
    assertThat(eventsAfterAddFailed, hasSize(2));
    assertThat(eventsAfterAddFailed.get(0).type(), is(GroupEvent.Type.GROUP_ADD_FAILED));
    assertThat(eventsAfterAddFailed.get(1).type(), is(GroupEvent.Type.GROUP_REMOVED));
    delegate.resetEvents();
    GroupOperation opModify = GroupOperation.createModifyGroupOperation(groupId2, INDIRECT, buckets);
    groupStore.groupOperationFailed(deviceId2, opModify);
    List<GroupEvent> eventsAfterModifyFailed = delegate.eventsSeen();
    assertThat(eventsAfterModifyFailed, hasSize(1));
    assertThat(eventsAfterModifyFailed.get(0).type(), is(GroupEvent.Type.GROUP_UPDATE_FAILED));
    delegate.resetEvents();
    GroupOperation opDelete = GroupOperation.createDeleteGroupOperation(groupId2, INDIRECT);
    groupStore.groupOperationFailed(deviceId2, opDelete);
    List<GroupEvent> eventsAfterDeleteFailed = delegate.eventsSeen();
    assertThat(eventsAfterDeleteFailed, hasSize(1));
    assertThat(eventsAfterDeleteFailed.get(0).type(), is(GroupEvent.Type.GROUP_REMOVE_FAILED));
    delegate.resetEvents();
}
#end_block

#method_before
@Test
public void testUpdateGroupDescription() {
    GroupBuckets buckets = new GroupBuckets(ImmutableList.of(failoverGroupBucket));
    groupStore.deviceInitialAuditCompleted(deviceId1, true);
    groupStore.storeGroupDescription(groupDescription1);
    GroupKey newKey = new DefaultGroupKey("123".getBytes());
    groupStore.updateGroupDescription(deviceId1, groupKey1, GroupStore.UpdateType.ADD, buckets, newKey);
    Group group1 = groupStore.getGroup(deviceId1, groupId1);
    assertThat(group1.appCookie(), is(newKey));
    assertThat(group1.buckets().buckets(), hasSize(2));
}
#method_after
@Test
public void testUpdateGroupDescription() {
    GroupBuckets buckets = new GroupBuckets(ImmutableList.of(failoverGroupBucket));
    groupStore.deviceInitialAuditCompleted(deviceId1, true);
    groupStore.storeGroupDescription(groupDescription1);
    GroupKey newKey = new DefaultGroupKey("123".getBytes());
    groupStore.updateGroupDescription(deviceId1, groupKey1, ADD, buckets, newKey);
    Group group1 = groupStore.getGroup(deviceId1, groupId1);
    assertThat(group1.appCookie(), is(newKey));
    assertThat(group1.buckets().buckets(), hasSize(2));
}
#end_block

#method_before
@Test
public void codecEncodeTest() {
    GroupBucket bucket1 = DefaultGroupBucket.createSelectGroupBucket(DefaultTrafficTreatment.emptyTreatment());
    GroupBucket bucket2 = DefaultGroupBucket.createIndirectGroupBucket(DefaultTrafficTreatment.emptyTreatment());
    GroupBuckets buckets = new GroupBuckets(ImmutableList.of(bucket1, bucket2));
    GroupBuckets bucketsIndirect = new GroupBuckets(ImmutableList.of(bucket2));
    DefaultGroup group = new DefaultGroup(new DefaultGroupId(1), NetTestTools.did("d1"), GroupDescription.Type.ALL, buckets);
    DefaultGroup group1 = new DefaultGroup(new DefaultGroupId(2), NetTestTools.did("d2"), GroupDescription.Type.INDIRECT, bucketsIndirect);
    MockCodecContext context = new MockCodecContext();
    GroupCodec codec = new GroupCodec();
    ObjectNode groupJson = codec.encode(group, context);
    ObjectNode groupJsonIndirect = codec.encode(group1, context);
    assertThat(groupJson, matchesGroup(group));
    assertThat(groupJsonIndirect, matchesGroup(group1));
}
#method_after
@Test
public void codecEncodeTest() {
    GroupBucket bucket1 = DefaultGroupBucket.createSelectGroupBucket(DefaultTrafficTreatment.emptyTreatment());
    GroupBucket bucket2 = DefaultGroupBucket.createIndirectGroupBucket(DefaultTrafficTreatment.emptyTreatment());
    GroupBuckets buckets = new GroupBuckets(ImmutableList.of(bucket1, bucket2));
    GroupBuckets bucketsIndirect = new GroupBuckets(ImmutableList.of(bucket2));
    DefaultGroup group = new DefaultGroup(new DefaultGroupId(1), NetTestTools.did("d1"), ALL, buckets);
    DefaultGroup group1 = new DefaultGroup(new DefaultGroupId(2), NetTestTools.did("d2"), INDIRECT, bucketsIndirect);
    MockCodecContext context = new MockCodecContext();
    GroupCodec codec = new GroupCodec();
    ObjectNode groupJson = codec.encode(group, context);
    ObjectNode groupJsonIndirect = codec.encode(group1, context);
    assertThat(groupJson, matchesGroup(group));
    assertThat(groupJsonIndirect, matchesGroup(group1));
}
#end_block

#method_before
@Override
public List<Intent> compile(SinglePointToMultiPointIntent intent, List<Intent> installable) {
    Set<Link> links = new HashSet<>();
    for (ConnectPoint egressPoint : intent.egressPoints()) {
        if (egressPoint.deviceId().equals(intent.ingressPoint().deviceId())) {
            continue;
        }
        Path path = getPath(intent, intent.ingressPoint().deviceId(), egressPoint.deviceId());
        links.addAll(path.links());
    }
    Intent result = LinkCollectionIntent.builder().appId(intent.appId()).key(intent.key()).selector(intent.selector()).treatment(intent.treatment()).links(links).ingressPoints(ImmutableSet.of(intent.ingressPoint())).egressPoints(intent.egressPoints()).priority(intent.priority()).egressTreatment(true).constraints(intent.constraints()).build();
    return Collections.singletonList(result);
}
#method_after
@Override
public List<Intent> compile(SinglePointToMultiPointIntent intent, List<Intent> installable) {
    Set<Link> links = new HashSet<>();
    for (ConnectPoint egressPoint : intent.egressPoints()) {
        if (egressPoint.deviceId().equals(intent.ingressPoint().deviceId())) {
            continue;
        }
        Path path = getPath(intent, intent.ingressPoint().deviceId(), egressPoint.deviceId());
        links.addAll(path.links());
    }
    Intent result = LinkCollectionIntent.builder().appId(intent.appId()).key(intent.key()).selector(intent.selector()).treatment(intent.treatment()).links(links).ingressPoints(ImmutableSet.of(intent.ingressPoint())).egressPoints(intent.egressPoints()).priority(intent.priority()).applyTreatmentOnEgress(true).constraints(intent.constraints()).build();
    return Collections.singletonList(result);
}
#end_block

#method_before
private List<FlowRule> createRules(LinkCollectionIntent intent, DeviceId deviceId, Set<PortNumber> inPorts, Set<PortNumber> outPorts) {
    TrafficTreatment.Builder defaultTreatmentBuilder = DefaultTrafficTreatment.builder();
    outPorts.stream().forEach(defaultTreatmentBuilder::setOutput);
    TrafficTreatment outputOnlyTreatment = defaultTreatmentBuilder.build();
    List<FlowRule> rules = new ArrayList<>(inPorts.size());
    for (PortNumber inPort : inPorts) {
        TrafficSelector.Builder selectorBuilder;
        TrafficTreatment treatment;
        TrafficTreatment intentTreatment;
        if (!intent.egressTreatmentFlag()) {
            TrafficTreatment.Builder ingressTreatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
            outPorts.stream().forEach(ingressTreatmentBuilder::setOutput);
            intentTreatment = ingressTreatmentBuilder.build();
            Set<PortNumber> ingressPorts = intent.ingressPoints().stream().filter(point -> point.deviceId().equals(deviceId)).map(ConnectPoint::port).collect(Collectors.toSet());
            if (ingressPorts.contains(inPort)) {
                selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
                treatment = intentTreatment;
            } else {
                TrafficSelector modifiedSelector = applyTreatmentToSelector(intent.selector(), intentTreatment);
                selectorBuilder = DefaultTrafficSelector.builder(modifiedSelector);
                treatment = outputOnlyTreatment;
            }
        } else {
            Set<PortNumber> egressPorts = intent.egressPoints().stream().filter(point -> point.deviceId().equals(deviceId)).map(ConnectPoint::port).collect(Collectors.toSet());
            if (outPorts.stream().allMatch(egressPorts::contains)) {
                TrafficTreatment.Builder egressTreatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
                outPorts.stream().forEach(egressTreatmentBuilder::setOutput);
                selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
                treatment = egressTreatmentBuilder.build();
            } else {
                selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
                treatment = outputOnlyTreatment;
            }
        }
        TrafficSelector selector = selectorBuilder.matchInPort(inPort).build();
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector).withTreatment(treatment).withPriority(intent.priority()).fromApp(appId).makePermanent().build();
        rules.add(rule);
    }
    return rules;
}
#method_after
private List<FlowRule> createRules(LinkCollectionIntent intent, DeviceId deviceId, Set<PortNumber> inPorts, Set<PortNumber> outPorts) {
    TrafficTreatment.Builder defaultTreatmentBuilder = DefaultTrafficTreatment.builder();
    outPorts.stream().forEach(defaultTreatmentBuilder::setOutput);
    TrafficTreatment outputOnlyTreatment = defaultTreatmentBuilder.build();
    Set<PortNumber> ingressPorts = Collections.emptySet();
    Set<PortNumber> egressPorts = Collections.emptySet();
    if (!intent.applyTreatmentOnEgress()) {
        ingressPorts = intent.ingressPoints().stream().filter(point -> point.deviceId().equals(deviceId)).map(ConnectPoint::port).collect(Collectors.toSet());
    } else {
        egressPorts = intent.egressPoints().stream().filter(point -> point.deviceId().equals(deviceId)).map(ConnectPoint::port).collect(Collectors.toSet());
    }
    List<FlowRule> rules = new ArrayList<>(inPorts.size());
    for (PortNumber inPort : inPorts) {
        TrafficSelector.Builder selectorBuilder;
        TrafficTreatment treatment;
        TrafficTreatment intentTreatment;
        if (!intent.applyTreatmentOnEgress()) {
            TrafficTreatment.Builder ingressTreatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
            outPorts.stream().forEach(ingressTreatmentBuilder::setOutput);
            intentTreatment = ingressTreatmentBuilder.build();
            if (ingressPorts.contains(inPort)) {
                selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
                treatment = intentTreatment;
            } else {
                selectorBuilder = applyTreatmentToSelector(intent.selector(), intentTreatment);
                treatment = outputOnlyTreatment;
            }
        } else {
            if (outPorts.stream().allMatch(egressPorts::contains)) {
                TrafficTreatment.Builder egressTreatmentBuilder = DefaultTrafficTreatment.builder(intent.treatment());
                outPorts.stream().forEach(egressTreatmentBuilder::setOutput);
                selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
                treatment = egressTreatmentBuilder.build();
            } else {
                selectorBuilder = DefaultTrafficSelector.builder(intent.selector());
                treatment = outputOnlyTreatment;
            }
        }
        TrafficSelector selector = selectorBuilder.matchInPort(inPort).build();
        FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector).withTreatment(treatment).withPriority(intent.priority()).fromApp(appId).makePermanent().build();
        rules.add(rule);
    }
    return rules;
}
#end_block

#method_before
private TrafficSelector applyTreatmentToSelector(TrafficSelector selector, TrafficTreatment treatment) {
    TrafficSelector.Builder defaultSelectorBuilder = DefaultTrafficSelector.builder(selector);
    treatment.allInstructions().forEach(instruction -> {
        switch(instruction.type()) {
            case L0MODIFICATION:
            case L1MODIFICATION:
                throw new IntentCompilationException("L0 and L1 mods not supported");
            case L2MODIFICATION:
                L2ModificationInstruction l2mod = (L2ModificationInstruction) instruction;
                switch(l2mod.subtype()) {
                    case ETH_SRC:
                    case ETH_DST:
                        ModEtherInstruction ethInstr = (ModEtherInstruction) l2mod;
                        switch(ethInstr.subtype()) {
                            case ETH_SRC:
                                defaultSelectorBuilder.matchEthSrc(ethInstr.mac());
                                break;
                            case ETH_DST:
                                defaultSelectorBuilder.matchEthDst(ethInstr.mac());
                                break;
                            default:
                                throw new IntentCompilationException("Bad eth subtype");
                        }
                        break;
                    case VLAN_ID:
                        ModVlanIdInstruction vlanIdInstr = (ModVlanIdInstruction) l2mod;
                        defaultSelectorBuilder.matchVlanId(vlanIdInstr.vlanId());
                        break;
                    case VLAN_PUSH:
                        // FIXME
                        break;
                    case VLAN_POP:
                        // TODO how do we handle dropped label? remove the selector?
                        throw new IntentCompilationException("Can't handle pop label");
                    case VLAN_PCP:
                        ModVlanPcpInstruction vlanPcpInstruction = (ModVlanPcpInstruction) l2mod;
                        defaultSelectorBuilder.matchVlanPcp(vlanPcpInstruction.vlanPcp());
                        break;
                    case MPLS_LABEL:
                    case MPLS_PUSH:
                        // FIXME
                        ModMplsLabelInstruction mplsInstr = (ModMplsLabelInstruction) l2mod;
                        defaultSelectorBuilder.matchMplsLabel(mplsInstr.label());
                        break;
                    case MPLS_POP:
                        // TODO how do we handle dropped label? remove the selector?
                        throw new IntentCompilationException("Can't handle pop label");
                    case DEC_MPLS_TTL:
                        // no-op
                        break;
                    case MPLS_BOS:
                        ModMplsBosInstruction mplsBosInstr = (ModMplsBosInstruction) l2mod;
                        defaultSelectorBuilder.matchMplsBos(mplsBosInstr.mplsBos());
                        break;
                    case TUNNEL_ID:
                        ModTunnelIdInstruction tunInstr = (ModTunnelIdInstruction) l2mod;
                        defaultSelectorBuilder.matchTunnelId(tunInstr.tunnelId());
                        break;
                    default:
                        throw new IntentCompilationException("Unknown L2 Modification instruction");
                }
                break;
            case L3MODIFICATION:
                L3ModificationInstruction l3mod = (L3ModificationInstruction) instruction;
                // TODO check ethernet proto
                switch(l3mod.subtype()) {
                    case IPV4_SRC:
                    case IPV4_DST:
                    case IPV6_SRC:
                    case IPV6_DST:
                        ModIPInstruction ipInstr = (ModIPInstruction) l3mod;
                        // TODO check if ip falls in original prefix
                        IpPrefix prefix = ipInstr.ip().toIpPrefix();
                        switch(ipInstr.subtype()) {
                            case IPV4_SRC:
                                defaultSelectorBuilder.matchIPSrc(prefix);
                                break;
                            case IPV4_DST:
                                defaultSelectorBuilder.matchIPSrc(prefix);
                                break;
                            case IPV6_SRC:
                                defaultSelectorBuilder.matchIPv6Src(prefix);
                                break;
                            case IPV6_DST:
                                defaultSelectorBuilder.matchIPv6Dst(prefix);
                                break;
                            default:
                                throw new IntentCompilationException("Bad type for IP instruction");
                        }
                        break;
                    case IPV6_FLABEL:
                        ModIPv6FlowLabelInstruction ipFlowInstr = (ModIPv6FlowLabelInstruction) l3mod;
                        defaultSelectorBuilder.matchIPv6FlowLabel(ipFlowInstr.flowLabel());
                        break;
                    case DEC_TTL:
                        // no-op
                        break;
                    case TTL_OUT:
                        // no-op
                        break;
                    case TTL_IN:
                        // no-op
                        break;
                    case ARP_SPA:
                        ModArpIPInstruction arpIpInstr = (ModArpIPInstruction) l3mod;
                        if (arpIpInstr.ip().isIp4()) {
                            defaultSelectorBuilder.matchArpSpa((Ip4Address) arpIpInstr.ip());
                        } else {
                            throw new IntentCompilationException("IPv6 not supported for ARP");
                        }
                        break;
                    case ARP_SHA:
                        ModArpEthInstruction arpEthInstr = (ModArpEthInstruction) l3mod;
                        defaultSelectorBuilder.matchArpSha(arpEthInstr.mac());
                        break;
                    case ARP_OP:
                        ModArpOpInstruction arpOpInstr = (ModArpOpInstruction) l3mod;
                        // FIXME is the long to int cast safe?
                        defaultSelectorBuilder.matchArpOp((int) arpOpInstr.op());
                        break;
                    default:
                        throw new IntentCompilationException("Unknown L3 Modification instruction");
                }
                break;
            case L4MODIFICATION:
                if (instruction instanceof ModTransportPortInstruction) {
                    // TODO check IP proto
                    ModTransportPortInstruction l4mod = (ModTransportPortInstruction) instruction;
                    switch(l4mod.subtype()) {
                        case TCP_SRC:
                            defaultSelectorBuilder.matchTcpSrc(l4mod.port());
                            break;
                        case TCP_DST:
                            defaultSelectorBuilder.matchTcpDst(l4mod.port());
                            break;
                        case UDP_SRC:
                            defaultSelectorBuilder.matchUdpSrc(l4mod.port());
                            break;
                        case UDP_DST:
                            defaultSelectorBuilder.matchUdpDst(l4mod.port());
                            break;
                        default:
                            throw new IntentCompilationException("Unknown L4 Modification instruction");
                    }
                } else {
                    throw new IntentCompilationException("Unknown L4 Modification instruction");
                }
                break;
            case NOACTION:
            case OUTPUT:
            case GROUP:
            case QUEUE:
            case TABLE:
            case METER:
            case METADATA:
            case // TODO is extension no-op or unsupported?
            EXTENSION:
                // Nothing to do
                break;
            default:
                throw new IntentCompilationException("Unknown instruction type");
        }
    });
    return defaultSelectorBuilder.build();
}
#method_after
private TrafficSelector.Builder applyTreatmentToSelector(TrafficSelector selector, TrafficTreatment treatment) {
    TrafficSelector.Builder defaultSelectorBuilder = DefaultTrafficSelector.builder(selector);
    treatment.allInstructions().forEach(instruction -> {
        switch(instruction.type()) {
            case L0MODIFICATION:
            case L1MODIFICATION:
                throw new IntentCompilationException("L0 and L1 mods not supported");
            case L2MODIFICATION:
                L2ModificationInstruction l2mod = (L2ModificationInstruction) instruction;
                switch(l2mod.subtype()) {
                    case ETH_SRC:
                    case ETH_DST:
                        ModEtherInstruction ethInstr = (ModEtherInstruction) l2mod;
                        switch(ethInstr.subtype()) {
                            case ETH_SRC:
                                defaultSelectorBuilder.matchEthSrc(ethInstr.mac());
                                break;
                            case ETH_DST:
                                defaultSelectorBuilder.matchEthDst(ethInstr.mac());
                                break;
                            default:
                                throw new IntentCompilationException("Bad eth subtype");
                        }
                        break;
                    case VLAN_ID:
                        ModVlanIdInstruction vlanIdInstr = (ModVlanIdInstruction) l2mod;
                        defaultSelectorBuilder.matchVlanId(vlanIdInstr.vlanId());
                        break;
                    case VLAN_PUSH:
                        // FIXME
                        break;
                    case VLAN_POP:
                        // TODO how do we handle dropped label? remove the selector?
                        throw new IntentCompilationException("Can't handle pop label");
                    case VLAN_PCP:
                        ModVlanPcpInstruction vlanPcpInstruction = (ModVlanPcpInstruction) l2mod;
                        defaultSelectorBuilder.matchVlanPcp(vlanPcpInstruction.vlanPcp());
                        break;
                    case MPLS_LABEL:
                    case MPLS_PUSH:
                        // FIXME
                        ModMplsLabelInstruction mplsInstr = (ModMplsLabelInstruction) l2mod;
                        defaultSelectorBuilder.matchMplsLabel(mplsInstr.label());
                        break;
                    case MPLS_POP:
                        // TODO how do we handle dropped label? remove the selector?
                        throw new IntentCompilationException("Can't handle pop label");
                    case DEC_MPLS_TTL:
                        // no-op
                        break;
                    case MPLS_BOS:
                        ModMplsBosInstruction mplsBosInstr = (ModMplsBosInstruction) l2mod;
                        defaultSelectorBuilder.matchMplsBos(mplsBosInstr.mplsBos());
                        break;
                    case TUNNEL_ID:
                        ModTunnelIdInstruction tunInstr = (ModTunnelIdInstruction) l2mod;
                        defaultSelectorBuilder.matchTunnelId(tunInstr.tunnelId());
                        break;
                    default:
                        throw new IntentCompilationException("Unknown L2 Modification instruction");
                }
                break;
            case L3MODIFICATION:
                L3ModificationInstruction l3mod = (L3ModificationInstruction) instruction;
                // TODO check ethernet proto
                switch(l3mod.subtype()) {
                    case IPV4_SRC:
                    case IPV4_DST:
                    case IPV6_SRC:
                    case IPV6_DST:
                        ModIPInstruction ipInstr = (ModIPInstruction) l3mod;
                        // TODO check if ip falls in original prefix
                        IpPrefix prefix = ipInstr.ip().toIpPrefix();
                        switch(ipInstr.subtype()) {
                            case IPV4_SRC:
                                defaultSelectorBuilder.matchIPSrc(prefix);
                                break;
                            case IPV4_DST:
                                defaultSelectorBuilder.matchIPSrc(prefix);
                                break;
                            case IPV6_SRC:
                                defaultSelectorBuilder.matchIPv6Src(prefix);
                                break;
                            case IPV6_DST:
                                defaultSelectorBuilder.matchIPv6Dst(prefix);
                                break;
                            default:
                                throw new IntentCompilationException("Bad type for IP instruction");
                        }
                        break;
                    case IPV6_FLABEL:
                        ModIPv6FlowLabelInstruction ipFlowInstr = (ModIPv6FlowLabelInstruction) l3mod;
                        defaultSelectorBuilder.matchIPv6FlowLabel(ipFlowInstr.flowLabel());
                        break;
                    case DEC_TTL:
                        // no-op
                        break;
                    case TTL_OUT:
                        // no-op
                        break;
                    case TTL_IN:
                        // no-op
                        break;
                    case ARP_SPA:
                        ModArpIPInstruction arpIpInstr = (ModArpIPInstruction) l3mod;
                        if (arpIpInstr.ip().isIp4()) {
                            defaultSelectorBuilder.matchArpSpa((Ip4Address) arpIpInstr.ip());
                        } else {
                            throw new IntentCompilationException("IPv6 not supported for ARP");
                        }
                        break;
                    case ARP_SHA:
                        ModArpEthInstruction arpEthInstr = (ModArpEthInstruction) l3mod;
                        defaultSelectorBuilder.matchArpSha(arpEthInstr.mac());
                        break;
                    case ARP_OP:
                        ModArpOpInstruction arpOpInstr = (ModArpOpInstruction) l3mod;
                        // FIXME is the long to int cast safe?
                        defaultSelectorBuilder.matchArpOp((int) arpOpInstr.op());
                        break;
                    default:
                        throw new IntentCompilationException("Unknown L3 Modification instruction");
                }
                break;
            case L4MODIFICATION:
                if (instruction instanceof ModTransportPortInstruction) {
                    // TODO check IP proto
                    ModTransportPortInstruction l4mod = (ModTransportPortInstruction) instruction;
                    switch(l4mod.subtype()) {
                        case TCP_SRC:
                            defaultSelectorBuilder.matchTcpSrc(l4mod.port());
                            break;
                        case TCP_DST:
                            defaultSelectorBuilder.matchTcpDst(l4mod.port());
                            break;
                        case UDP_SRC:
                            defaultSelectorBuilder.matchUdpSrc(l4mod.port());
                            break;
                        case UDP_DST:
                            defaultSelectorBuilder.matchUdpDst(l4mod.port());
                            break;
                        default:
                            throw new IntentCompilationException("Unknown L4 Modification instruction");
                    }
                } else {
                    throw new IntentCompilationException("Unknown L4 Modification instruction");
                }
                break;
            case NOACTION:
            case OUTPUT:
            case GROUP:
            case QUEUE:
            case TABLE:
            case METER:
            case METADATA:
            case // TODO is extension no-op or unsupported?
            EXTENSION:
                // Nothing to do
                break;
            default:
                throw new IntentCompilationException("Unknown instruction type");
        }
    });
    return defaultSelectorBuilder;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("id", id()).add("key", key()).add("appId", appId()).add("priority", priority()).add("resources", resources()).add("selector", selector()).add("treatment", treatment()).add("links", links()).add("ingress", ingressPoints()).add("egress", egressPoints()).add("egressTreatmentFlag", egressTreatmentFlag()).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("id", id()).add("key", key()).add("appId", appId()).add("priority", priority()).add("resources", resources()).add("selector", selector()).add("treatment", treatment()).add("links", links()).add("ingress", ingressPoints()).add("egress", egressPoints()).add("treatementOnEgress", applyTreatmentOnEgress()).toString();
}
#end_block

#method_before
@Override
protected List<FlowRule> processVlanIdFilter(VlanIdCriterion vlanIdCriterion, FilteringObjective filt, VlanId assignedVlan, VlanId pushedVlan, boolean popVlan, boolean pushVlan, ApplicationId applicationId) {
    log.debug("For now not adding any VLAN rules " + "into Dell switches as it is ignoring");
    return Collections.emptyList();
}
#method_after
@Override
protected List<FlowRule> processVlanIdFilter(VlanIdCriterion vlanIdCriterion, FilteringObjective filt, VlanId assignedVlan, VlanId modifiedVlan, VlanId pushedVlan, boolean popVlan, boolean pushVlan, ApplicationId applicationId) {
    log.debug("For now not adding any VLAN rules " + "into Dell switches as it is ignoring");
    return Collections.emptyList();
}
#end_block

#method_before
protected List<FlowRule> processVlanIdFilter(VlanIdCriterion vlanIdCriterion, FilteringObjective filt, VlanId assignedVlan, VlanId pushedVlan, boolean pushVlan, boolean popVlan, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<>();
    log.debug("adding rule for VLAN: {}", vlanIdCriterion.vlanId());
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    PortCriterion p = (PortCriterion) filt.key();
    if (vlanIdCriterion.vlanId() != VlanId.NONE) {
        selector.matchVlanId(vlanIdCriterion.vlanId());
        selector.matchInPort(p.port());
        if (popVlan) {
            // Pop outer tag
            treatment.immediate().popVlan();
        }
        if (assignedVlan != null && (!popVlan || !vlanIdCriterion.vlanId().equals(assignedVlan))) {
            // Modify VLAN ID on single tagged packet or modify remaining tag after popping
            // In the first case, do not set VLAN ID again to the already existing value
            treatment.immediate().setVlanId(assignedVlan);
        }
        if (pushVlan) {
            // Push new tag
            treatment.immediate().pushVlan().setVlanId(pushedVlan);
        }
    } else {
        selector.matchInPort(p.port());
        treatment.immediate().pushVlan().setVlanId(assignedVlan);
    }
    treatment.transition(tmacTableId);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(filt.priority()).fromApp(applicationId).makePermanent().forTable(vlanTableId).build();
    rules.add(rule);
    return rules;
}
#method_after
protected List<FlowRule> processVlanIdFilter(VlanIdCriterion vlanIdCriterion, FilteringObjective filt, VlanId assignedVlan, VlanId explicitlyAssignedVlan, VlanId pushedVlan, boolean pushVlan, boolean popVlan, ApplicationId applicationId) {
    List<FlowRule> rules = new ArrayList<>();
    log.debug("adding rule for VLAN: {}", vlanIdCriterion.vlanId());
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    PortCriterion p = (PortCriterion) filt.key();
    if (vlanIdCriterion.vlanId() != VlanId.NONE) {
        selector.matchVlanId(vlanIdCriterion.vlanId());
        selector.matchInPort(p.port());
        if (popVlan) {
            // Pop outer tag
            treatment.immediate().popVlan();
        }
        if (explicitlyAssignedVlan != null && (!popVlan || !vlanIdCriterion.vlanId().equals(assignedVlan))) {
            // Modify VLAN ID on single tagged packet or modify remaining tag after popping
            // In the first case, do not set VLAN ID again to the already existing value
            treatment.immediate().setVlanId(explicitlyAssignedVlan);
        }
        if (pushVlan) {
            // Push new tag
            treatment.immediate().pushVlan().setVlanId(pushedVlan);
        }
    } else {
        selector.matchInPort(p.port());
        treatment.immediate().pushVlan().setVlanId(assignedVlan);
    }
    treatment.transition(tmacTableId);
    FlowRule rule = DefaultFlowRule.builder().forDevice(deviceId).withSelector(selector.build()).withTreatment(treatment.build()).withPriority(filt.priority()).fromApp(applicationId).makePermanent().forTable(vlanTableId).build();
    rules.add(rule);
    return rules;
}
#end_block

#method_before
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // ports as the key
    if (filt.key().equals(Criteria.dummy()) || filt.key().type() != Criterion.Type.IN_PORT) {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    EthCriterion ethCriterion = null;
    VlanIdCriterion vlanIdCriterion = null;
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vlanIdCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            log.debug("driver does not process IP filtering rules as it " + "sends all misses in the IP table to the controller");
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", criterion.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    VlanId assignedVlan = null;
    VlanId pushedVlan = null;
    boolean pushVlan = false;
    boolean popVlan = false;
    if (vlanIdCriterion != null) {
        for (Instruction i : filt.meta().allInstructions()) {
            if (i instanceof ModVlanIdInstruction) {
                if (pushVlan && vlanIdCriterion.vlanId() != VlanId.NONE) {
                    // For untagged packets the pushed VLAN ID will be saved in assignedVlan
                    pushedVlan = ((ModVlanIdInstruction) i).vlanId();
                } else {
                    assignedVlan = ((ModVlanIdInstruction) i).vlanId();
                }
            }
            if (i instanceof L2ModificationInstruction) {
                if (((L2ModificationInstruction) i).subtype().equals(L2ModificationInstruction.L2SubType.VLAN_PUSH)) {
                    pushVlan = true;
                } else if (((L2ModificationInstruction) i).subtype().equals(L2ModificationInstruction.L2SubType.VLAN_POP)) {
                    popVlan = true;
                }
            }
        }
        // For VLAN cross-connect packets, use the configured VLAN unless there is an explicitly provided VLAN ID
        if (vlanIdCriterion.vlanId() != VlanId.NONE) {
            if (assignedVlan == null) {
                assignedVlan = vlanIdCriterion.vlanId();
            }
        // For untagged packets, assign a VLAN ID
        } else {
            if (filt.meta() == null) {
                log.error("Missing metadata in filtering objective required " + "for vlan assignment in dev {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
            if (assignedVlan == null) {
                log.error("Driver requires an assigned vlan-id to tag incoming " + "untagged packets. Not processing vlan filters on " + "device {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
        }
        if (pushVlan && popVlan) {
            log.error("Cannot push and pop vlan in the same filtering objective");
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
        if (popVlan && vlanIdCriterion.vlanId() == VlanId.NONE) {
            log.error("Cannot pop vlan for untagged packets");
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
        if ((pushVlan && pushedVlan == null) && vlanIdCriterion.vlanId() != VlanId.NONE) {
            log.error("No VLAN ID provided for push tag operation");
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null) {
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(ethCriterion, vlanIdCriterion, filt, assignedVlan, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (vlanIdCriterion == null) {
        log.debug("filtering objective missing VLAN ID criterion, " + "cannot program VLAN Table");
    } else {
        for (FlowRule vlanRule : processVlanIdFilter(vlanIdCriterion, filt, assignedVlan, pushedVlan, pushVlan, popVlan, applicationId)) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", vlanRule, deviceId);
            ops = install ? ops.add(vlanRule) : ops.remove(vlanRule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.debug("Provisioned tables in {} with fitering " + "rules", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.warn("Failed to provision tables in {} with " + "fitering rules", deviceId);
        }
    }));
}
#method_after
private void processFilter(FilteringObjective filt, boolean install, ApplicationId applicationId) {
    // ports as the key
    if (filt.key().equals(Criteria.dummy()) || filt.key().type() != Criterion.Type.IN_PORT) {
        log.warn("No key defined in filtering objective from app: {}. Not" + "processing filtering objective", applicationId);
        fail(filt, ObjectiveError.UNKNOWN);
        return;
    }
    EthCriterion ethCriterion = null;
    VlanIdCriterion vlanIdCriterion = null;
    // convert filtering conditions for switch-intfs into flowrules
    FlowRuleOperations.Builder ops = FlowRuleOperations.builder();
    for (Criterion criterion : filt.conditions()) {
        if (criterion.type() == Criterion.Type.ETH_DST) {
            ethCriterion = (EthCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.VLAN_VID) {
            vlanIdCriterion = (VlanIdCriterion) criterion;
        } else if (criterion.type() == Criterion.Type.IPV4_DST) {
            log.debug("driver does not process IP filtering rules as it " + "sends all misses in the IP table to the controller");
        } else {
            log.warn("Driver does not currently process filtering condition" + " of type: {}", criterion.type());
            fail(filt, ObjectiveError.UNSUPPORTED);
        }
    }
    VlanId assignedVlan = null;
    VlanId modifiedVlan = null;
    VlanId pushedVlan = null;
    boolean pushVlan = false;
    boolean popVlan = false;
    if (vlanIdCriterion != null) {
        if (filt.meta() != null) {
            for (Instruction i : filt.meta().allInstructions()) {
                if (i instanceof L2ModificationInstruction) {
                    if (((L2ModificationInstruction) i).subtype().equals(L2ModificationInstruction.L2SubType.VLAN_PUSH)) {
                        pushVlan = true;
                    } else if (((L2ModificationInstruction) i).subtype().equals(L2ModificationInstruction.L2SubType.VLAN_POP)) {
                        if (modifiedVlan != null) {
                            log.error("Pop tag is not allowed after modify VLAN operation " + "in filtering objective", deviceId);
                            fail(filt, ObjectiveError.BADPARAMS);
                            return;
                        }
                        popVlan = true;
                    }
                }
                if (i instanceof ModVlanIdInstruction) {
                    if (pushVlan && vlanIdCriterion.vlanId() != VlanId.NONE) {
                        // Modify VLAN should not appear after pushing a new tag
                        if (pushedVlan != null) {
                            log.error("Modify VLAN not allowed after push tag operation " + "in filtering objective", deviceId);
                            fail(filt, ObjectiveError.BADPARAMS);
                            return;
                        }
                        pushedVlan = ((ModVlanIdInstruction) i).vlanId();
                    } else if (vlanIdCriterion.vlanId() == VlanId.NONE) {
                        // For untagged packets the pushed VLAN ID will be saved in assignedVlan
                        // just to ensure the driver works as designed for the fabric use case
                        assignedVlan = ((ModVlanIdInstruction) i).vlanId();
                    } else {
                        // For tagged packets modifiedVlan will contain the modified value of existing tag
                        if (modifiedVlan != null) {
                            log.error("Driver does not allow multiple modify VLAN operations " + "in the same filtering objective", deviceId);
                            fail(filt, ObjectiveError.BADPARAMS);
                            return;
                        }
                        modifiedVlan = ((ModVlanIdInstruction) i).vlanId();
                    }
                }
            }
        }
        // For VLAN cross-connect packets, use the configured VLAN unless there is an explicitly provided VLAN ID
        if (vlanIdCriterion.vlanId() != VlanId.NONE) {
            if (assignedVlan == null) {
                assignedVlan = vlanIdCriterion.vlanId();
            }
        // For untagged packets, assign a VLAN ID
        } else {
            if (filt.meta() == null) {
                log.error("Missing metadata in filtering objective required " + "for vlan assignment in dev {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
            if (assignedVlan == null) {
                log.error("Driver requires an assigned vlan-id to tag incoming " + "untagged packets. Not processing vlan filters on " + "device {}", deviceId);
                fail(filt, ObjectiveError.BADPARAMS);
                return;
            }
        }
        if (pushVlan && popVlan) {
            log.error("Cannot push and pop vlan in the same filtering objective");
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
        if (popVlan && vlanIdCriterion.vlanId() == VlanId.NONE) {
            log.error("Cannot pop vlan for untagged packets");
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
        if ((pushVlan && pushedVlan == null) && vlanIdCriterion.vlanId() != VlanId.NONE) {
            log.error("No VLAN ID provided for push tag operation");
            fail(filt, ObjectiveError.BADPARAMS);
            return;
        }
    }
    if (ethCriterion == null) {
        log.debug("filtering objective missing dstMac, cannot program TMAC table");
    } else {
        for (FlowRule tmacRule : processEthDstFilter(ethCriterion, vlanIdCriterion, filt, assignedVlan, applicationId)) {
            log.debug("adding MAC filtering rules in TMAC table: {} for dev: {}", tmacRule, deviceId);
            ops = install ? ops.add(tmacRule) : ops.remove(tmacRule);
        }
    }
    if (vlanIdCriterion == null) {
        log.debug("filtering objective missing VLAN ID criterion, " + "cannot program VLAN Table");
    } else {
        for (FlowRule vlanRule : processVlanIdFilter(vlanIdCriterion, filt, assignedVlan, modifiedVlan, pushedVlan, pushVlan, popVlan, applicationId)) {
            log.debug("adding VLAN filtering rule in VLAN table: {} for dev: {}", vlanRule, deviceId);
            ops = install ? ops.add(vlanRule) : ops.remove(vlanRule);
        }
    }
    // apply filtering flow rules
    flowRuleService.apply(ops.build(new FlowRuleOperationsContext() {

        @Override
        public void onSuccess(FlowRuleOperations ops) {
            pass(filt);
            log.debug("Provisioned tables in {} with fitering " + "rules", deviceId);
        }

        @Override
        public void onError(FlowRuleOperations ops) {
            fail(filt, ObjectiveError.FLOWINSTALLATIONFAILED);
            log.warn("Failed to provision tables in {} with " + "fitering rules", deviceId);
        }
    }));
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = super.hashCode();
    result = prime * result + ((distinguishedName == null) ? 0 : distinguishedName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    return Objects.hash(distinguishedName);
}
#end_block

#method_before
@Override
public String toString() {
    return "" + asNum;
}
#method_after
@Override
public String toString() {
    return String.valueOf(asNum);
}
#end_block

#method_before
public static void generateJavaCode(YangNode rootNode, YangPluginConfig yangPlugin) throws TranslatorException, IOException {
    YangNode codeGenNode = rootNode;
    setRootNode(rootNode);
    TraversalType curTraversal = ROOT;
    while (codeGenNode != null) {
        if (curTraversal != PARENT) {
            if (!(codeGenNode instanceof JavaCodeGenerator)) {
                throw new TranslatorException("Unsupported node to generate code");
            }
            setCurNode(codeGenNode);
            try {
                generateCodeEntry(codeGenNode, yangPlugin);
            } catch (InvalidNodeForTranslatorException e) {
                if (codeGenNode.getNextSibling() != null) {
                    curTraversal = SIBILING;
                    codeGenNode = codeGenNode.getNextSibling();
                } else {
                    curTraversal = PARENT;
                    codeGenNode = codeGenNode.getParent();
                }
                continue;
            } catch (Exception e) {
                close(codeGenNode, yangPlugin);
                throw new TranslatorException(e.getMessage());
            }
        }
        if (curTraversal != PARENT && codeGenNode.getChild() != null) {
            curTraversal = CHILD;
            codeGenNode = codeGenNode.getChild();
        } else if (codeGenNode.getNextSibling() != null) {
            try {
                generateCodeExit(codeGenNode, yangPlugin);
            } catch (Exception e) {
                throw new TranslatorException(e.getMessage());
            }
            curTraversal = SIBILING;
            codeGenNode = codeGenNode.getNextSibling();
        } else {
            try {
                generateCodeExit(codeGenNode, yangPlugin);
            } catch (Exception e) {
                throw new TranslatorException(e.getMessage());
            }
            curTraversal = PARENT;
            codeGenNode = codeGenNode.getParent();
        }
    }
}
#method_after
public static void generateJavaCode(YangNode rootNode, YangPluginConfig yangPlugin) throws TranslatorException, IOException {
    YangNode codeGenNode = rootNode;
    setRootNode(rootNode);
    TraversalType curTraversal = ROOT;
    while (codeGenNode != null) {
        if (curTraversal != PARENT) {
            if (!(codeGenNode instanceof JavaCodeGenerator)) {
                throw new TranslatorException("Unsupported node to generate code");
            }
            setCurNode(codeGenNode);
            try {
                generateCodeEntry(codeGenNode, yangPlugin);
            } catch (InvalidNodeForTranslatorException e) {
                if (codeGenNode.getNextSibling() != null) {
                    curTraversal = SIBILING;
                    codeGenNode = codeGenNode.getNextSibling();
                } else {
                    curTraversal = PARENT;
                    codeGenNode = codeGenNode.getParent();
                }
                continue;
            } catch (Exception e) {
                close(codeGenNode, yangPlugin);
                throw new TranslatorException(e.getMessage());
            }
        }
        if (curTraversal != PARENT && codeGenNode.getChild() != null) {
            curTraversal = CHILD;
            codeGenNode = codeGenNode.getChild();
        } else if (codeGenNode.getNextSibling() != null) {
            try {
                generateCodeExit(codeGenNode, yangPlugin);
            } catch (Exception e) {
                close(codeGenNode, yangPlugin);
                throw new TranslatorException(e.getMessage());
            }
            curTraversal = SIBILING;
            codeGenNode = codeGenNode.getNextSibling();
        } else {
            try {
                generateCodeExit(codeGenNode, yangPlugin);
            } catch (Exception e) {
                close(codeGenNode, yangPlugin);
                throw new TranslatorException(e.getMessage());
            }
            curTraversal = PARENT;
            codeGenNode = codeGenNode.getParent();
        }
    }
}
#end_block

#method_before
public static void translatorErrorHandler(YangNode rootNode, YangPluginConfig yangPluginConfig) throws IOException {
    if (rootNode != null) {
        /**
         * Free other resources where translator has failed.
         */
        freeRestResources();
        /**
         * Start removing all open files.
         */
        YangNode tempNode = rootNode;
        setCurNode(tempNode.getChild());
        TraversalType curTraversal = ROOT;
        while (tempNode != null) {
            if (curTraversal != PARENT) {
                close(tempNode, yangPluginConfig);
            }
            if (curTraversal != PARENT && tempNode.getChild() != null) {
                curTraversal = CHILD;
                tempNode = tempNode.getChild();
            } else if (tempNode.getNextSibling() != null) {
                curTraversal = SIBILING;
                tempNode = tempNode.getNextSibling();
            } else {
                curTraversal = PARENT;
                tempNode = tempNode.getParent();
            }
        }
        freeRestResources();
    }
}
#method_after
public static void translatorErrorHandler(YangNode rootNode, YangPluginConfig yangPluginConfig) throws IOException {
    if (rootNode != null) {
        // Free other resources where translator has failed.
        freeRestResources();
        // Start removing all open files.
        YangNode tempNode = rootNode;
        setCurNode(tempNode.getChild());
        TraversalType curTraversal = ROOT;
        while (tempNode != null) {
            if (curTraversal != PARENT) {
                close(tempNode, yangPluginConfig);
            }
            if (curTraversal != PARENT && tempNode.getChild() != null) {
                curTraversal = CHILD;
                tempNode = tempNode.getChild();
            } else if (tempNode.getNextSibling() != null) {
                curTraversal = SIBILING;
                tempNode = tempNode.getNextSibling();
            } else {
                curTraversal = PARENT;
                tempNode = tempNode.getParent();
            }
        }
        freeRestResources();
    }
}
#end_block

#method_before
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    generateEventJavaFile(curNode);
    generateEventListenerJavaFile(curNode);
    generateEventSubjectJavaFile(curNode);
    /**
     * Close all the file handles.
     */
    freeTemporaryResources(false);
}
#method_after
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    generateEventJavaFile(curNode);
    generateEventListenerJavaFile(curNode);
    generateEventSubjectJavaFile(curNode);
    // Close all the file handles.
    freeTemporaryResources(false);
}
#end_block

#method_before
private void generateEventJavaFile(YangNode curNode) throws IOException {
    List<String> imports = new ArrayList<>();
    imports.add(getJavaImportData().getAbstractEventsImport());
    String curNodeInfo = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName());
    String nodeName = curNodeInfo + EVENT_STRING;
    addEnumMethod(nodeName, curNodeInfo + EVENT_SUBJECT_NAME_SUFFIX);
    /**
     * Creates event interface file.
     */
    setEventJavaFileHandle(getJavaFileHandle(curNode, curNodeInfo + EVENT_FILE_NAME_SUFFIX));
    generateEventFile(getEventJavaFileHandle(), curNode, imports);
}
#method_after
private void generateEventJavaFile(YangNode curNode) throws IOException {
    List<String> imports = new ArrayList<>();
    imports.add(getJavaImportData().getAbstractEventsImport());
    String curNodeInfo = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName());
    String nodeName = curNodeInfo + EVENT_STRING;
    addEnumMethod(nodeName, curNodeInfo + EVENT_SUBJECT_NAME_SUFFIX);
    // Creates event interface file.
    setEventJavaFileHandle(getJavaFileHandle(curNode, curNodeInfo + EVENT_FILE_NAME_SUFFIX));
    generateEventFile(getEventJavaFileHandle(), curNode, imports);
}
#end_block

#method_before
private void generateEventListenerJavaFile(YangNode curNode) throws IOException {
    List<String> imports = new ArrayList<>();
    imports.add(getJavaImportData().getEventListenerImport());
    String curNodeInfo = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName());
    /**
     * Creates event listener interface file.
     */
    setEventListenerJavaFileHandle(getJavaFileHandle(curNode, curNodeInfo + EVENT_LISTENER_FILE_NAME_SUFFIX));
    generateEventListenerFile(getEventListenerJavaFileHandle(), curNode, imports);
}
#method_after
private void generateEventListenerJavaFile(YangNode curNode) throws IOException {
    List<String> imports = new ArrayList<>();
    imports.add(getJavaImportData().getEventListenerImport());
    String curNodeInfo = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName());
    // Creates event listener interface file.
    setEventListenerJavaFileHandle(getJavaFileHandle(curNode, curNodeInfo + EVENT_LISTENER_FILE_NAME_SUFFIX));
    generateEventListenerFile(getEventListenerJavaFileHandle(), curNode, imports);
}
#end_block

#method_before
private void generateEventSubjectJavaFile(YangNode curNode) throws IOException {
    String curNodeInfo = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName());
    /**
     * Creates event interface file.
     */
    setEventSubjectJavaFileHandle(getJavaFileHandle(curNode, curNodeInfo + TempJavaEventFragmentFiles.EVENT_SUBJECT_NAME_SUFFIX));
    generateEventSubjectFile(getEventSubjectJavaFileHandle(), curNode);
}
#method_after
private void generateEventSubjectJavaFile(YangNode curNode) throws IOException {
    String curNodeInfo = getCapitalCase(((JavaFileInfoContainer) curNode).getJavaFileInfo().getJavaName());
    // Creates event interface file.
    setEventSubjectJavaFileHandle(getJavaFileHandle(curNode, curNodeInfo + TempJavaEventFragmentFiles.EVENT_SUBJECT_NAME_SUFFIX));
    generateEventSubjectFile(getEventSubjectJavaFileHandle(), curNode);
}
#end_block

#method_before
private void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo javaAttributeInfo, YangPluginConfig pluginConfig, List<YangType<?>> typeList) throws IOException {
    YangDataTypes attrType = javaAttributeInfo.getAttributeType().getDataType();
    if (attrType == INT32 || attrType == UINT16) {
        boolean isIntConflict = validateForConflictingIntTypes(typeList);
        javaAttributeInfo.setIntConflict(isIntConflict);
        setIntConflict(isIntConflict);
        updateAttributeCondition(javaAttributeInfo);
    } else if (attrType == INT64 || attrType == UINT32) {
        boolean isLongConflict = validateForConflictingLongypes(typeList);
        javaAttributeInfo.setLongConflict(isLongConflict);
        setLongConflict(isLongConflict);
        updateAttributeCondition(javaAttributeInfo);
    } else {
        if ((getGeneratedTempFiles() & OF_STRING_IMPL_MASK) != 0) {
            addOfStringMethod(javaAttributeInfo, pluginConfig);
        }
        if ((getGeneratedTempFiles() & CONSTRUCTOR_FOR_TYPE_MASK) != 0) {
            addTypeConstructor(javaAttributeInfo, pluginConfig);
        }
    }
    super.addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo, pluginConfig);
}
#method_after
private void addJavaSnippetInfoToApplicableTempFiles(JavaAttributeInfo javaAttributeInfo, YangPluginConfig pluginConfig, List<YangType<?>> typeList) throws IOException {
    YangDataTypes attrType = javaAttributeInfo.getAttributeType().getDataType();
    if (attrType == INT32 || attrType == UINT16) {
        boolean isIntConflict = validateForConflictingIntTypes(typeList);
        javaAttributeInfo.setIntConflict(isIntConflict);
        updateAttributeCondition(javaAttributeInfo);
        if (!isIntConflict) {
            addMethodsWhenNoConflictingTypes(javaAttributeInfo, pluginConfig);
        }
    } else if (attrType == INT64 || attrType == UINT32) {
        boolean isLongConflict = validateForConflictingLongTypes(typeList);
        javaAttributeInfo.setLongConflict(isLongConflict);
        updateAttributeCondition(javaAttributeInfo);
        if (!isLongConflict) {
            addMethodsWhenNoConflictingTypes(javaAttributeInfo, pluginConfig);
        }
    } else {
        addMethodsWhenNoConflictingTypes(javaAttributeInfo, pluginConfig);
    }
    super.addJavaSnippetInfoToApplicableTempFiles(javaAttributeInfo, pluginConfig);
}
#end_block

#method_before
private void addMethodsInConflictCase(YangPluginConfig pluginConfig) throws IOException {
    JavaAttributeInfo attr = getIntAttribute();
    if (attr != null) {
        attr = getuIntAttribute();
    }
    if (attr != null) {
        if (attr.isIntConflict()) {
            if (getIntIndex() < getUintIndex()) {
                appendToFile(getOfStringImplTempFileHandle(), getOfMethodStringAndJavaDoc(getIntAttribute(), getGeneratedJavaClassName(), pluginConfig) + NEW_LINE);
                addGetterImpl(getIntAttribute(), pluginConfig);
                addFromStringMethod(getIntAttribute(), pluginConfig);
            } else {
                appendToFile(getOfStringImplTempFileHandle(), getOfMethodStringAndJavaDoc(getuIntAttribute(), getGeneratedJavaClassName(), pluginConfig) + NEW_LINE);
                addGetterImpl(getuIntAttribute(), pluginConfig);
                addFromStringMethod(getuIntAttribute(), pluginConfig);
            }
        }
    }
    attr = getLongAttribute();
    if (attr != null) {
        attr = getuLongAttribute();
    }
    if (attr != null) {
        if (attr.isLongConflict()) {
            if (getLongIndex() < getuLongIndex()) {
                appendToFile(getOfStringImplTempFileHandle(), getOfMethodStringAndJavaDoc(getLongAttribute(), getGeneratedJavaClassName(), pluginConfig) + NEW_LINE);
                addGetterImpl(getLongAttribute(), pluginConfig);
                addFromStringMethod(getLongAttribute(), pluginConfig);
            } else {
                appendToFile(getOfStringImplTempFileHandle(), getOfMethodStringAndJavaDoc(getuLongAttribute(), getGeneratedJavaClassName(), pluginConfig) + NEW_LINE);
                addGetterImpl(getuLongAttribute(), pluginConfig);
                addFromStringMethod(getuLongAttribute(), pluginConfig);
            }
        }
    }
}
#method_after
private void addMethodsInConflictCase(YangPluginConfig pluginConfig) throws IOException {
    JavaAttributeInfo attr = getIntAttribute();
    if (attr != null) {
        attr = getUIntAttribute();
    }
    if (attr != null) {
        if (attr.isIntConflict()) {
            if (getIntIndex() < getUIntIndex()) {
                appendToFile(getOfStringImplTempFileHandle(), getOfMethodStringAndJavaDoc(getIntAttribute(), getGeneratedJavaClassName(), pluginConfig) + NEW_LINE);
                addGetterImpl(getIntAttribute(), pluginConfig);
                addFromStringMethod(getIntAttribute(), pluginConfig);
            } else {
                appendToFile(getOfStringImplTempFileHandle(), getOfMethodStringAndJavaDoc(getUIntAttribute(), getGeneratedJavaClassName(), pluginConfig) + NEW_LINE);
                addGetterImpl(getUIntAttribute(), pluginConfig);
                addFromStringMethod(getUIntAttribute(), pluginConfig);
            }
        }
    }
    attr = getLongAttribute();
    if (attr != null) {
        attr = getULongAttribute();
    }
    if (attr != null) {
        if (attr.isLongConflict()) {
            if (getLongIndex() < getULongIndex()) {
                appendToFile(getOfStringImplTempFileHandle(), getOfMethodStringAndJavaDoc(getLongAttribute(), getGeneratedJavaClassName(), pluginConfig) + NEW_LINE);
                addGetterImpl(getLongAttribute(), pluginConfig);
                addFromStringMethod(getLongAttribute(), pluginConfig);
            } else {
                appendToFile(getOfStringImplTempFileHandle(), getOfMethodStringAndJavaDoc(getULongAttribute(), getGeneratedJavaClassName(), pluginConfig) + NEW_LINE);
                addGetterImpl(getULongAttribute(), pluginConfig);
                addFromStringMethod(getULongAttribute(), pluginConfig);
            }
        }
    }
}
#end_block

#method_before
private void addTypeConstructor(YangPluginConfig pluginConfig) throws IOException {
    JavaAttributeInfo attr = getIntAttribute();
    if (attr != null) {
        attr = getuIntAttribute();
    }
    if (attr != null) {
        if (attr.isIntConflict()) {
            appendToFile(getConstructorForTypeTempFileHandle(), getTypeConstructorStringAndJavaDoc(getIntAttribute(), getuIntAttribute(), getGeneratedJavaClassName(), pluginConfig, INT_TYPE_CONFLICT, getIntIndex() < getUintIndex()) + NEW_LINE);
        }
    }
    attr = getLongAttribute();
    if (attr != null) {
        attr = getuLongAttribute();
    }
    if (attr != null) {
        if (attr.isLongConflict()) {
            appendToFile(getConstructorForTypeTempFileHandle(), getTypeConstructorStringAndJavaDoc(getLongAttribute(), getuLongAttribute(), getGeneratedJavaClassName(), pluginConfig, LONG_TYPE_CONFLICT, getLongIndex() < getuLongIndex()) + NEW_LINE);
        }
    }
}
#method_after
private void addTypeConstructor(YangPluginConfig pluginConfig) throws IOException {
    JavaAttributeInfo attr = getIntAttribute();
    if (attr != null) {
        attr = getUIntAttribute();
    }
    if (attr != null) {
        if (attr.isIntConflict()) {
            appendToFile(getConstructorForTypeTempFileHandle(), getTypeConstructorStringAndJavaDoc(getIntAttribute(), getUIntAttribute(), getGeneratedJavaClassName(), pluginConfig, INT_TYPE_CONFLICT, getIntIndex() < getUIntIndex()) + NEW_LINE);
        }
    }
    attr = getLongAttribute();
    if (attr != null) {
        attr = getULongAttribute();
    }
    if (attr != null) {
        if (attr.isLongConflict()) {
            appendToFile(getConstructorForTypeTempFileHandle(), getTypeConstructorStringAndJavaDoc(getLongAttribute(), getULongAttribute(), getGeneratedJavaClassName(), pluginConfig, LONG_TYPE_CONFLICT, getLongIndex() < getULongIndex()) + NEW_LINE);
        }
    }
}
#end_block

#method_before
private boolean validateForConflictingIntTypes(List<YangType<?>> typeList) {
    boolean isIntPresent = false;
    boolean isUintPresent = false;
    for (YangType type : typeList) {
        if (type.getDataType().equals(INT32)) {
            setIntIndex(typeList.indexOf(type));
            isIntPresent = true;
        }
        if (type.getDataType().equals(UINT16)) {
            setUintIndex(typeList.indexOf(type));
            isUintPresent = true;
        }
    }
    return isIntPresent && isUintPresent;
}
#method_after
private boolean validateForConflictingIntTypes(List<YangType<?>> typeList) {
    boolean isIntPresent = false;
    boolean isUIntPresent = false;
    for (YangType type : typeList) {
        if (type.getDataType().equals(INT32)) {
            setIntIndex(typeList.indexOf(type));
            isIntPresent = true;
        }
        if (type.getDataType().equals(UINT16)) {
            setUIntIndex(typeList.indexOf(type));
            isUIntPresent = true;
        }
    }
    return isIntPresent && isUIntPresent;
}
#end_block

#method_before
private void updateAttributeCondition(JavaAttributeInfo javaAttributeInfo) {
    if (javaAttributeInfo.isIntConflict()) {
        if (javaAttributeInfo.getAttributeType().getDataType() == UINT16) {
            setuIntAttribute(javaAttributeInfo);
        } else if (javaAttributeInfo.getAttributeType().getDataType() == INT32) {
            setIntAttribute(javaAttributeInfo);
        }
    }
    if (javaAttributeInfo.isLongConflict()) {
        if (javaAttributeInfo.getAttributeType().getDataType() == UINT32) {
            setuLongAttribute(javaAttributeInfo);
        } else if (javaAttributeInfo.getAttributeType().getDataType() == INT64) {
            setLongAttribute(javaAttributeInfo);
        }
    }
}
#method_after
private void updateAttributeCondition(JavaAttributeInfo javaAttributeInfo) {
    if (javaAttributeInfo.isIntConflict()) {
        if (javaAttributeInfo.getAttributeType().getDataType() == UINT16) {
            setUIntAttribute(javaAttributeInfo);
        } else if (javaAttributeInfo.getAttributeType().getDataType() == INT32) {
            setIntAttribute(javaAttributeInfo);
        }
    }
    if (javaAttributeInfo.isLongConflict()) {
        if (javaAttributeInfo.getAttributeType().getDataType() == UINT32) {
            setULongAttribute(javaAttributeInfo);
        } else if (javaAttributeInfo.getAttributeType().getDataType() == INT64) {
            setLongAttribute(javaAttributeInfo);
        }
    }
}
#end_block

#method_before
private JavaAttributeInfo getIntAttribute() {
    return intAttribute;
}
#method_after
public JavaAttributeInfo getIntAttribute() {
    return intAttribute;
}
#end_block

#method_before
private JavaAttributeInfo getLongAttribute() {
    return longAttribute;
}
#method_after
public JavaAttributeInfo getLongAttribute() {
    return longAttribute;
}
#end_block

#method_before
public boolean isAttributePresent() {
    return isAttributePresent;
}
#method_after
boolean isAttributePresent() {
    return isAttributePresent;
}
#end_block

#method_before
public void setAttributePresent(boolean attributePresent) {
    isAttributePresent = attributePresent;
}
#method_after
private void setAttributePresent(boolean attributePresent) {
    isAttributePresent = attributePresent;
}
#end_block

#method_before
void setAttributesTempFileHandle(File attributeForClass) {
    attributesTempFileHandle = attributeForClass;
}
#method_after
private void setAttributesTempFileHandle(File attributeForClass) {
    attributesTempFileHandle = attributeForClass;
}
#end_block

#method_before
void setGetterImplTempFileHandle(File getterImpl) {
    getterImplTempFileHandle = getterImpl;
}
#method_after
private void setGetterImplTempFileHandle(File getterImpl) {
    getterImplTempFileHandle = getterImpl;
}
#end_block

#method_before
void setHashCodeImplTempFileHandle(File hashCodeMethod) {
    hashCodeImplTempFileHandle = hashCodeMethod;
}
#method_after
private void setHashCodeImplTempFileHandle(File hashCodeMethod) {
    hashCodeImplTempFileHandle = hashCodeMethod;
}
#end_block

#method_before
void setEqualsImplTempFileHandle(File equalsMethod) {
    equalsImplTempFileHandle = equalsMethod;
}
#method_after
private void setEqualsImplTempFileHandle(File equalsMethod) {
    equalsImplTempFileHandle = equalsMethod;
}
#end_block

#method_before
void setToStringImplTempFileHandle(File toStringMethod) {
    toStringImplTempFileHandle = toStringMethod;
}
#method_after
private void setToStringImplTempFileHandle(File toStringMethod) {
    toStringImplTempFileHandle = toStringMethod;
}
#end_block

#method_before
public void setJavaExtendsListHolder(JavaExtendsListHolder javaExtendsListHolder) {
    this.javaExtendsListHolder = javaExtendsListHolder;
}
#method_after
void setJavaExtendsListHolder(JavaExtendsListHolder javaExtendsListHolder) {
    this.javaExtendsListHolder = javaExtendsListHolder;
}
#end_block

#method_before
public void addGetterImpl(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {
    if ((getGeneratedJavaFiles() & BUILDER_CLASS_MASK) != 0 || (getGeneratedJavaFiles() & GENERATE_SERVICE_AND_MANAGER) != 0) {
        appendToFile(getGetterImplTempFileHandle(), getOverRideString() + getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
    } else {
        appendToFile(getGetterImplTempFileHandle(), getJavaDoc(GETTER_METHOD, getCapitalCase(attr.getAttributeName()), false, pluginConfig) + getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
    }
}
#method_after
void addGetterImpl(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {
    if ((getGeneratedJavaFiles() & BUILDER_CLASS_MASK) != 0 || (getGeneratedJavaFiles() & GENERATE_SERVICE_AND_MANAGER) != 0) {
        appendToFile(getGetterImplTempFileHandle(), getOverRideString() + getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
    } else {
        appendToFile(getGetterImplTempFileHandle(), getJavaDoc(GETTER_METHOD, getCapitalCase(attr.getAttributeName()), false, pluginConfig) + getGetterForClass(attr, getGeneratedJavaFiles()) + NEW_LINE);
    }
}
#end_block

#method_before
public void addFromStringMethod(JavaAttributeInfo javaAttributeInfo, JavaAttributeInfo fromStringAttributeInfo) throws IOException {
    appendToFile(getFromStringImplTempFileHandle(), getFromStringMethod(javaAttributeInfo, fromStringAttributeInfo) + NEW_LINE);
}
#method_after
void addFromStringMethod(JavaAttributeInfo javaAttributeInfo, JavaAttributeInfo fromStringAttributeInfo) throws IOException {
    appendToFile(getFromStringImplTempFileHandle(), getFromStringMethod(javaAttributeInfo, fromStringAttributeInfo) + NEW_LINE);
}
#end_block

#method_before
private String getTempDirPath(String absolutePath) {
    return getPackageDirPathFromJavaJPackage(absolutePath) + SLASH + getGeneratedJavaClassName() + TEMP_FOLDER_NAME_SUFIX + SLASH;
}
#method_after
private String getTempDirPath(String absolutePath) {
    return getPackageDirPathFromJavaJPackage(absolutePath) + SLASH + getGeneratedJavaClassName() + TEMP_FOLDER_NAME_SUFFIX + SLASH;
}
#end_block

#method_before
public String parseAttribute(JavaAttributeInfo attr, YangPluginConfig pluginConfig) {
    /*
         * TODO: check if this utility needs to be called or move to the caller
         */
    String attributeName = getCamelCase(attr.getAttributeName(), pluginConfig.getConflictResolver());
    String attributeAccessType = PRIVATE;
    if ((javaFileInfo.getGeneratedFileTypes() & GENERATE_INTERFACE_WITH_BUILDER) != 0) {
        attributeAccessType = PROTECTED;
    }
    if (attr.isQualifiedName()) {
        return getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr(), attributeAccessType);
    } else {
        return getJavaAttributeDefination(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr(), attributeAccessType);
    }
}
#method_after
String parseAttribute(JavaAttributeInfo attr, YangPluginConfig pluginConfig) {
    /*
         * TODO: check if this utility needs to be called or move to the caller
         */
    String attributeName = getCamelCase(attr.getAttributeName(), pluginConfig.getConflictResolver());
    String attributeAccessType = PRIVATE;
    if ((javaFileInfo.getGeneratedFileTypes() & GENERATE_INTERFACE_WITH_BUILDER) != 0) {
        attributeAccessType = PROTECTED;
    }
    if (attr.isQualifiedName()) {
        return getJavaAttributeDefination(attr.getImportInfo().getPkgInfo(), attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr(), attributeAccessType);
    } else {
        return getJavaAttributeDefination(null, attr.getImportInfo().getClassInfo(), attributeName, attr.isListAttr(), attributeAccessType);
    }
}
#end_block

#method_before
public void addCurNodeLeavesInfoToTempFiles(YangNode curNode, YangPluginConfig yangPluginConfig) throws IOException {
    if (!(curNode instanceof YangLeavesHolder)) {
        throw new TranslatorException("Data model node does not have any leaves");
    }
    YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
    addLeavesInfoToTempFiles(leavesHolder.getListOfLeaf(), yangPluginConfig, curNode);
    addLeafListInfoToTempFiles(leavesHolder.getListOfLeafList(), yangPluginConfig, curNode);
}
#method_after
void addCurNodeLeavesInfoToTempFiles(YangNode curNode, YangPluginConfig yangPluginConfig) throws IOException {
    if (!(curNode instanceof YangLeavesHolder)) {
        throw new TranslatorException("Data model node does not have any leaves");
    }
    YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
    addLeavesInfoToTempFiles(leavesHolder.getListOfLeaf(), yangPluginConfig, curNode);
    addLeafListInfoToTempFiles(leavesHolder.getListOfLeafList(), yangPluginConfig, curNode);
}
#end_block

#method_before
String getImplClassName() {
    return getCapitalCase(DEFAULT) + getCapitalCase(getJavaFileInfo().getJavaName());
}
#method_after
private String getImplClassName() {
    return getCapitalCase(DEFAULT) + getCapitalCase(getJavaFileInfo().getJavaName());
}
#end_block

#method_before
String getOpParamImplClassName() {
    return getCapitalCase(getJavaFileInfo().getJavaName()) + OPERATION;
}
#method_after
private String getOpParamImplClassName() {
    return getCapitalCase(getJavaFileInfo().getJavaName()) + OPERATION;
}
#end_block

#method_before
String getOpParamBuilderImplClassName() {
    return getCapitalCase(getJavaFileInfo().getJavaName()) + OPERATION + BUILDER;
}
#method_after
private String getOpParamBuilderImplClassName() {
    return getCapitalCase(getJavaFileInfo().getJavaName()) + OPERATION + BUILDER;
}
#end_block

#method_before
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        addResolvedAugmentedDataNodeImports(curNode);
    }
    TempJavaBeanFragmentFiles tempJavaBeanFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    List<String> imports = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaImportData().getImports();
    createPackage(curNode);
    /*
         * Generate java code.
         */
    if ((fileType & INTERFACE_MASK) != 0 || (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /*
             * Create interface file.
             */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent()));
        /*
             * Create builder interface file.
             */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent()));
            /*
                 * Append builder interface file to interface file and close it.
                 */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
            validateLineLength(getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (curNode instanceof YangCase) {
            removeCaseImport(imports);
        }
        if (curNode instanceof YangAugment) {
            removeAugmentedInfoImport(imports);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 || (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent()) {
            addImportsToStringAndHasCodeMethods(imports, true);
        }
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, true);
        }
        sortImports(imports);
        /*
             * Create impl class file.
             */
        setImplClassJavaFileHandle(getJavaFileHandle(getImplClassName()));
        setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent(), imports));
        /*
             * Create builder class file.
             */
        if ((fileType & BUILDER_CLASS_MASK) != 0) {
            setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
            setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), curNode, isAttributePresent()));
            /*
                 * Append impl class to builder class and close it.
                 */
            mergeJavaFiles(getBuilderClassJavaFileHandle(), getImplClassJavaFileHandle());
            validateLineLength(getImplClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getImplClassJavaFileHandle(), getJavaClassDefClose());
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, false);
        }
        if (!(curNode instanceof YangModule)) {
            if (isAttributePresent()) {
                addImportsToStringAndHasCodeMethods(imports, false);
            }
            if (curNode instanceof YangAugmentableNode) {
                addYangAugmentedOpParamInfoImport(imports);
            }
            JavaQualifiedTypeInfo qualifiedTypeInfo = new JavaQualifiedTypeInfo();
            qualifiedTypeInfo.setClassInfo(getCapitalCase(DEFAULT) + getCapitalCase(getJavaFileInfo().getJavaName()));
            qualifiedTypeInfo.setPkgInfo(getJavaFileInfo().getPackage());
            getJavaExtendsListHolder().addToExtendsList(qualifiedTypeInfo, curNode, tempJavaBeanFragmentFiles);
            addBitsetImport(imports, true);
            if (curNode instanceof YangAugment) {
                addYangAugmentedOpParamInfoImport(imports);
            }
            /*
                 * Create impl class file.
                 */
            setOpParamClassJavaFileHandle(getJavaFileHandle(getOpParamImplClassName()));
            setOpParamClassJavaFileHandle(generateOpParamImplClassFile(getOpParamClassJavaFileHandle(), curNode, isAttributePresent(), imports));
            /*
                 * Create builder class file.
                 */
            if ((fileType & BUILDER_CLASS_MASK) != 0) {
                setBuilderOpParmClassJavaFileHandle(getJavaFileHandle(getOpParamBuilderImplClassName()));
                setBuilderOpParmClassJavaFileHandle(generateOpParamBuilderClassFile(getBuilderOpParmClassJavaFileHandle(), curNode, isAttributePresent()));
                /*
                     * Append impl class to builder class and close it.
                     */
                mergeJavaFiles(getBuilderOpParmClassJavaFileHandle(), getOpParamClassJavaFileHandle());
                validateLineLength(getOpParamClassJavaFileHandle());
                addBitsetImport(imports, false);
            }
            insertDataIntoJavaFile(getOpParamClassJavaFileHandle(), getJavaClassDefClose());
        }
    }
    /*
         * Close all the file handles.
         */
    freeTemporaryResources(false);
}
#method_after
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        addResolvedAugmentedDataNodeImports(curNode);
    }
    TempJavaBeanFragmentFiles tempJavaBeanFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    List<String> imports = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaImportData().getImports();
    createPackage(curNode);
    /*
         * Generate java code.
         */
    if ((fileType & INTERFACE_MASK) != 0 || (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /*
             * Create interface file.
             */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent()));
        /*
             * Create builder interface file.
             */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent()));
            /*
                 * Append builder interface file to interface file and close it.
                 */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
            validateLineLength(getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (curNode instanceof YangCase) {
            removeCaseImport(imports);
        }
        if (curNode instanceof YangAugment) {
            removeAugmentedInfoImport(imports);
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 || (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent()) {
            addImportsToStringAndHasCodeMethods(imports, true);
        }
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, true);
        }
        sortImports(imports);
        /*
             * Create impl class file.
             */
        setImplClassJavaFileHandle(getJavaFileHandle(getImplClassName()));
        setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent(), imports));
        /*
             * Create builder class file.
             */
        if ((fileType & BUILDER_CLASS_MASK) != 0) {
            setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
            setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), curNode, isAttributePresent()));
            /*
                 * Append impl class to builder class and close it.
                 */
            mergeJavaFiles(getBuilderClassJavaFileHandle(), getImplClassJavaFileHandle());
            validateLineLength(getImplClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getImplClassJavaFileHandle(), getJavaClassDefClose());
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports, false);
        }
        if (!(curNode instanceof YangModule)) {
            if (isAttributePresent()) {
                addImportsToStringAndHasCodeMethods(imports, false);
            }
            if (curNode instanceof YangAugmentableNode) {
                addYangAugmentedOpParamInfoImport(imports);
            }
            JavaQualifiedTypeInfo qualifiedTypeInfo = new JavaQualifiedTypeInfo();
            qualifiedTypeInfo.setClassInfo(getCapitalCase(DEFAULT) + getCapitalCase(getJavaFileInfo().getJavaName()));
            qualifiedTypeInfo.setPkgInfo(getJavaFileInfo().getPackage());
            getJavaExtendsListHolder().addToExtendsList(qualifiedTypeInfo, curNode, tempJavaBeanFragmentFiles);
            addBitSetImport(imports, true);
            if (curNode instanceof YangAugment) {
                addYangAugmentedOpParamInfoImport(imports);
            }
            /*
                 * Create impl class file.
                 */
            setOpParamClassJavaFileHandle(getJavaFileHandle(getOpParamImplClassName()));
            setOpParamClassJavaFileHandle(generateOpParamImplClassFile(getOpParamClassJavaFileHandle(), curNode, isAttributePresent(), imports));
            /*
                 * Create builder class file.
                 */
            if ((fileType & BUILDER_CLASS_MASK) != 0) {
                setBuilderOpParmClassJavaFileHandle(getJavaFileHandle(getOpParamBuilderImplClassName()));
                setBuilderOpParmClassJavaFileHandle(generateOpParamBuilderClassFile(getBuilderOpParmClassJavaFileHandle(), curNode, isAttributePresent()));
                /*
                     * Append impl class to builder class and close it.
                     */
                mergeJavaFiles(getBuilderOpParmClassJavaFileHandle(), getOpParamClassJavaFileHandle());
                validateLineLength(getOpParamClassJavaFileHandle());
                addBitSetImport(imports, false);
            }
            insertDataIntoJavaFile(getOpParamClassJavaFileHandle(), getJavaClassDefClose());
        }
    }
    /*
         * Close all the file handles.
         */
    freeTemporaryResources(false);
}
#end_block

#method_before
public void addImportsToStringAndHasCodeMethods(List<String> imports, boolean operation) {
    if (operation) {
        imports.add(getJavaImportData().getImportForHashAndEquals());
        imports.add(getJavaImportData().getImportForToString());
    } else {
        imports.remove(getJavaImportData().getImportForHashAndEquals());
        imports.remove(getJavaImportData().getImportForToString());
    }
}
#method_after
void addImportsToStringAndHasCodeMethods(List<String> imports, boolean operation) {
    if (operation) {
        imports.add(getJavaImportData().getImportForHashAndEquals());
        imports.add(getJavaImportData().getImportForToString());
    } else {
        imports.remove(getJavaImportData().getImportForHashAndEquals());
        imports.remove(getJavaImportData().getImportForToString());
    }
}
#end_block

#method_before
public void addImportsForAugmentableClass(List<String> imports, boolean operations) {
    if (operations) {
        imports.add(getJavaImportData().getHashMapImport());
        imports.add(getJavaImportData().getMapImport());
        imports.add(getJavaImportData().getYangAugmentedInfoImport());
    } else {
        imports.remove(getJavaImportData().getHashMapImport());
        imports.remove(getJavaImportData().getMapImport());
    }
}
#method_after
private void addImportsForAugmentableClass(List<String> imports, boolean operations) {
    if (operations) {
        imports.add(getJavaImportData().getHashMapImport());
        imports.add(getJavaImportData().getMapImport());
        imports.add(getJavaImportData().getYangAugmentedInfoImport());
    } else {
        imports.remove(getJavaImportData().getHashMapImport());
        imports.remove(getJavaImportData().getMapImport());
    }
}
#end_block

#method_before
private void removeAugmentedInfoImport(List<String> imports) {
    imports.remove(getJavaImportData().getYangAugmentedInfoImport());
    for (JavaQualifiedTypeInfo type : getJavaImportData().getImportSet()) {
        if (type.getClassInfo().equals(YANG_AUGMENTED_INFO)) {
            getJavaImportData().getImportSet().remove(type);
            getJavaExtendsListHolder().getExtendsList().remove(type);
        }
    }
}
#method_after
private void removeAugmentedInfoImport(List<String> imports) {
    imports.remove(getJavaImportData().getYangAugmentedInfoImport());
}
#end_block

#method_before
public void freeTemporaryResources(boolean isErrorOccurred) throws IOException {
    boolean isError = isErrorOccurred;
    /*
         * Close all java file handles and when error occurs delete the files.
         */
    if ((getGeneratedJavaFiles() & INTERFACE_MASK) != 0) {
        closeFile(getInterfaceJavaFileHandle(), isError);
    }
    if ((getGeneratedJavaFiles() & BUILDER_CLASS_MASK) != 0) {
        closeFile(getBuilderClassJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & OPERATION_BUILDER_CLASS_MASK) != 0) {
        closeFile(getBuilderOpParmClassJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & BUILDER_INTERFACE_MASK) != 0) {
        closeFile(getBuilderInterfaceJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & IMPL_CLASS_MASK) != 0) {
        closeFile(getImplClassJavaFileHandle(), isError);
    }
    /*
         * Close all temporary file handles and delete the files.
         */
    if ((getGeneratedTempFiles() & GETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getGetterImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & ATTRIBUTES_MASK) != 0) {
        closeFile(getAttributesTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & HASH_CODE_IMPL_MASK) != 0) {
        closeFile(getHashCodeImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & TO_STRING_IMPL_MASK) != 0) {
        closeFile(getToStringImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & EQUALS_IMPL_MASK) != 0) {
        closeFile(getEqualsImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & FROM_STRING_IMPL_MASK) != 0) {
        closeFile(getFromStringImplTempFileHandle(), true);
    }
}
#method_after
public void freeTemporaryResources(boolean isErrorOccurred) throws IOException {
    /*
         * Close all java file handles and when error occurs delete the files.
         */
    if ((getGeneratedJavaFiles() & INTERFACE_MASK) != 0) {
        closeFile(getInterfaceJavaFileHandle(), isErrorOccurred);
    }
    if ((getGeneratedJavaFiles() & BUILDER_CLASS_MASK) != 0) {
        closeFile(getBuilderClassJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & OPERATION_BUILDER_CLASS_MASK) != 0) {
        closeFile(getBuilderOpParmClassJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & BUILDER_INTERFACE_MASK) != 0) {
        closeFile(getBuilderInterfaceJavaFileHandle(), true);
    }
    if ((getGeneratedJavaFiles() & IMPL_CLASS_MASK) != 0) {
        closeFile(getImplClassJavaFileHandle(), isErrorOccurred);
    }
    /*
         * Close all temporary file handles and delete the files.
         */
    if ((getGeneratedTempFiles() & GETTER_FOR_CLASS_MASK) != 0) {
        closeFile(getGetterImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & ATTRIBUTES_MASK) != 0) {
        closeFile(getAttributesTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & HASH_CODE_IMPL_MASK) != 0) {
        closeFile(getHashCodeImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & TO_STRING_IMPL_MASK) != 0) {
        closeFile(getToStringImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & EQUALS_IMPL_MASK) != 0) {
        closeFile(getEqualsImplTempFileHandle(), true);
    }
    if ((getGeneratedTempFiles() & FROM_STRING_IMPL_MASK) != 0) {
        closeFile(getFromStringImplTempFileHandle(), true);
    }
}
#end_block

#method_before
public boolean getIsQualifiedAccessOrAddToImportList(JavaQualifiedTypeInfo importInfo) {
    return getJavaImportData().addImportInfo(importInfo, getGeneratedJavaClassName(), getJavaFileInfo().getPackage());
}
#method_after
boolean getIsQualifiedAccessOrAddToImportList(JavaQualifiedTypeInfo importInfo) {
    return getJavaImportData().addImportInfo(importInfo, getGeneratedJavaClassName(), getJavaFileInfo().getPackage());
}
#end_block

#method_before
public File getOpParamClassJavaFileHandle() {
    return opParamClassJavaFileHandle;
}
#method_after
private File getOpParamClassJavaFileHandle() {
    return opParamClassJavaFileHandle;
}
#end_block

#method_before
public void setOpParamClassJavaFileHandle(File opParamClassJavaFileHandle) {
    this.opParamClassJavaFileHandle = opParamClassJavaFileHandle;
}
#method_after
private void setOpParamClassJavaFileHandle(File opParamClassJavaFileHandle) {
    this.opParamClassJavaFileHandle = opParamClassJavaFileHandle;
}
#end_block

#method_before
@Override
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles().getJavaImportData().getImports();
    createPackage(curNode);
    boolean isNotification = false;
    if (curNode instanceof YangJavaModule) {
        if (!((YangJavaModule) curNode).getNotificationNodes().isEmpty()) {
            isNotification = true;
        }
    } else if (curNode instanceof YangJavaSubModule) {
        if (!((YangJavaSubModule) curNode).getNotificationNodes().isEmpty()) {
            isNotification = true;
        }
    }
    if (isNotification) {
        addListenersImport(curNode, imports, true, LISTENER_SERVICE);
    }
    /**
     * Creates rpc interface file.
     */
    setBaseCodePath(getServiceGenPath());
    setServiceInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(SERVICE_FILE_NAME_SUFFIX)));
    generateServiceInterfaceFile(getServiceInterfaceJavaFileHandle(), curNode, imports);
    setBaseCodePath(getJavaFileInfo().getBaseCodeGenPath());
    if (isNotification) {
        addListenersImport(curNode, imports, false, LISTENER_SERVICE);
        addListenersImport(curNode, imports, true, LISTENER_REG);
    }
    addAnnotationsImports(imports, true);
    /**
     * Create builder class file.
     */
    if (isManagerNeedToBeGenerated()) {
        setManagerJavaFileHandle(getJavaFileHandle(getJavaClassName(MANAGER_FILE_NAME_SUFFIX)));
        generateManagerClassFile(getManagerJavaFileHandle(), imports, curNode);
        insertDataIntoJavaFile(getManagerJavaFileHandle(), getJavaClassDefClose());
    }
    if (isNotification) {
        addListenersImport(curNode, imports, false, LISTENER_REG);
    }
    addAnnotationsImports(imports, false);
    /**
     * Close all the file handles.
     */
    freeTemporaryResources(false);
}
#method_after
@Override
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles().getJavaImportData().getImports();
    createPackage(curNode);
    boolean isNotification = false;
    if (curNode instanceof YangJavaModule) {
        if (!((YangJavaModule) curNode).getNotificationNodes().isEmpty()) {
            isNotification = true;
        }
    } else if (curNode instanceof YangJavaSubModule) {
        if (!((YangJavaSubModule) curNode).getNotificationNodes().isEmpty()) {
            isNotification = true;
        }
    }
    if (isNotification) {
        addListenersImport(curNode, imports, true, LISTENER_SERVICE);
    }
    // Creates rpc interface file.
    setBaseCodePath(getServiceGenPath());
    setServiceInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(SERVICE_FILE_NAME_SUFFIX)));
    generateServiceInterfaceFile(getServiceInterfaceJavaFileHandle(), curNode, imports);
    setBaseCodePath(getJavaFileInfo().getBaseCodeGenPath());
    if (isNotification) {
        addListenersImport(curNode, imports, false, LISTENER_SERVICE);
        addListenersImport(curNode, imports, true, LISTENER_REG);
    }
    addAnnotationsImports(imports, true);
    // Create builder class file.
    if (isManagerNeedToBeGenerated()) {
        setManagerJavaFileHandle(getJavaFileHandle(getJavaClassName(MANAGER_FILE_NAME_SUFFIX)));
        generateManagerClassFile(getManagerJavaFileHandle(), imports, curNode);
        insertDataIntoJavaFile(getManagerJavaFileHandle(), getJavaClassDefClose());
    }
    if (isNotification) {
        addListenersImport(curNode, imports, false, LISTENER_REG);
    }
    addAnnotationsImports(imports, false);
    // Close all the file handles.
    freeTemporaryResources(false);
}
#end_block

#method_before
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    if (isAttrPresent) {
        /**
         * Add getter methods to interface file.
         */
        try {
            /**
             * Getter methods.
             */
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while interface file generation");
        }
    }
    return validateLineLength(file);
}
#method_after
public static File generateInterfaceFile(File file, List<String> imports, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    String className = getCapitalCase(javaFileInfo.getJavaName());
    initiateJavaFileGeneration(file, INTERFACE_MASK, imports, curNode, className);
    if (isAttrPresent) {
        // Add getter methods to interface file.
        try {
            // Getter methods.
            insertDataIntoJavaFile(file, getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while interface file generation");
        }
    }
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_INTERFACE_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        try {
            /**
             * Getter methods.
             */
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            /**
             * Setter methods.
             */
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder interface file generation");
        }
    }
    /**
     * Add build method to builder interface file.
     */
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface(pluginConfig));
    /**
     * Add getters and setters in builder interface.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateBuilderInterfaceFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_INTERFACE_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        try {
            // Getter methods.
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(GETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(NEW_LINE);
            methods.add(FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(SETTER_FOR_INTERFACE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder interface file generation");
        }
    }
    // Add build method to builder interface file.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodForInterface(pluginConfig));
    // Add getters and setters in builder interface.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateBuilderClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
        try {
            /**
             * Getter methods.
             */
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            /**
             * Setter methods.
             */
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            insertDataIntoJavaFile(file, NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    /**
     * Add default constructor and build method impl.
     */
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl());
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER, pluginConfig));
    /**
     * Add methods in builder class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return validateLineLength(file);
}
#method_after
public static File generateBuilderClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Setter methods.
            methods.add(getDataFromTempFileHandle(SETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            insertDataIntoJavaFile(file, NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    // Add default constructor and build method impl.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addBuildMethodImpl());
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PUBLIC, BUILDER, pluginConfig));
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateOpParamBuilderClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    initiateJavaFileGeneration(file, OPERATION_BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + OPERATION_ENUM + SPACE + OP_PARAM_TYPE + SEMI_COLAN + NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        try {
            if (curNode instanceof YangLeavesHolder) {
                YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
                List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
                List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
                if (leaves != null && !leaves.isEmpty()) {
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + FILTER_LEAF + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + SELECT_LEAF + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                }
                if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + FILTER_LEAF_LIST + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + SELECT_LEAF_LIST + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                }
            }
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        try {
            /**
             * Setter methods.
             */
            methods.add(getSetterForLeaf(className, curNode, pluginConfig));
            methods.add(getSetterForLeafList(className, curNode, pluginConfig));
            if (curNode instanceof YangLeavesHolder) {
                YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
                List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
                List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
                if (leaves != null && !leaves.isEmpty()) {
                    methods.add(getToStringLeafgetter());
                    methods.add(getToStringSelectLeafgetter());
                }
                if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
                    methods.add(getToStringLeafListgetter());
                    methods.add(getToStringSelectLeafListgetter());
                }
            }
            methods.add(getOperationTypegetter());
            methods.add(getOperationTypeSetter());
            insertDataIntoJavaFile(file, NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    /**
     * Add methods in builder class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return validateLineLength(file);
}
#method_after
public static File generateOpParamBuilderClassFile(File file, YangNode curNode, boolean isAttrPresent) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    initiateJavaFileGeneration(file, OPERATION_BUILDER_CLASS_MASK, null, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + OPERATION_ENUM + SPACE + OP_PARAM_TYPE + SEMI_COLAN + NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        try {
            if (curNode instanceof YangLeavesHolder) {
                YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
                List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
                List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
                if (leaves != null && !leaves.isEmpty()) {
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + FILTER_LEAF + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + SELECT_LEAF + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                }
                if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + FILTER_LEAF_LIST + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + SELECT_LEAF_LIST + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                }
            }
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        try {
            // Setter methods.
            methods.add(getSetterForLeaf(className, curNode, pluginConfig));
            methods.add(getSetterForLeafList(className, curNode, pluginConfig));
            if (curNode instanceof YangLeavesHolder) {
                YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
                List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
                List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
                if (leaves != null && !leaves.isEmpty()) {
                    methods.add(getToStringLeafgetter());
                    methods.add(getToStringSelectLeafgetter());
                }
                if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
                    methods.add(getToStringLeafListgetter());
                    methods.add(getToStringSelectLeafListgetter());
                }
            }
            methods.add(getOperationTypegetter());
            methods.add(getOperationTypeSetter());
            insertDataIntoJavaFile(file, NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while builder class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateManagerClassFile(File file, List<String> imports, YangNode curNode) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + MANAGER;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    insertDataIntoJavaFile(file, LOGGER_STATEMENT);
    methods.add(addActivateMethod());
    methods.add(addDeActivateMethod());
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        /**
         * Getter methods.
         */
        methods.add(getOverRideString() + getGetterForClass(rootAttribute, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE);
        /**
         * Setter methods.
         */
        methods.add(getOverRideString() + getSetterForClass(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE);
        methods.add(getAugmentsDataMethodForManager(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGeninfo = (JavaCodeGeneratorInfo) curNode;
            /**
             * Rpc methods
             */
            methods.add(getDataFromTempFileHandle(RPC_IMPL_MASK, javaGeninfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
        insertDataIntoJavaFile(file, NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while manager class file generation");
    }
    /**
     * Add methods in builder class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return validateLineLength(file);
}
#method_after
public static File generateManagerClassFile(File file, List<String> imports, YangNode curNode) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + MANAGER;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    insertDataIntoJavaFile(file, LOGGER_STATEMENT);
    methods.add(addActivateMethod());
    methods.add(addDeActivateMethod());
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        // Getter methods.
        methods.add(getOverRideString() + getGetterForClass(rootAttribute, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE);
        // Setter methods.
        methods.add(getOverRideString() + getSetterForClass(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE);
        methods.add(getAugmentsDataMethodForManager(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
        insertDataIntoJavaFile(file, NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while manager class file generation");
    }
    // Add methods in builder class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateImplClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, IMPL_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        try {
            /**
             * Getter methods.
             */
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            /**
             * Hash code method.
             */
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
            /**
             * Equals method.
             */
            methods.add(getEqualsMethodClose(getEqualsMethodOpen(getCapitalCase(DEFAULT) + className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            /**
             * To string method.
             */
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    try {
        /**
         * Constructor.
         */
        String constructor = getConstructorStart(className, pluginConfig);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getAugmentInfoImpl());
        methods.add(getAugmentInfoMapImpl(javaFileInfo.getPluginConfig()));
    }
    /**
     * Add methods in impl class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return validateLineLength(file);
}
#method_after
public static File generateImplClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path;
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        path = javaFileInfo.getPluginConfig().getCodeGenDir() + javaFileInfo.getPackageFilePath();
    } else {
        path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    }
    initiateJavaFileGeneration(file, IMPL_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (curNode instanceof YangAugmentableNode) {
        insertDataIntoJavaFile(file, addAugmentationAttribute());
    }
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        try {
            // Getter methods.
            methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path));
            // Hash code method.
            methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
            // Equals method.
            methods.add(getEqualsMethodClose(getEqualsMethodOpen(getCapitalCase(DEFAULT) + className) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path)));
            // To string method.
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path) + getToStringMethodClose());
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    try {
        // Constructor.
        String constructor = getConstructorStart(className, pluginConfig);
        constructor = constructor + getDataFromTempFileHandle(CONSTRUCTOR_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles(), path);
        methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
    }
    if (curNode instanceof YangAugmentableNode) {
        methods.add(getAddAugmentInfoMethodImpl());
        methods.add(getAugmentInfoImpl());
        methods.add(getAugmentInfoMapImpl(javaFileInfo.getPluginConfig()));
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateOpParamImplClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    initiateJavaFileGeneration(file, OPERATION_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + ENUM + SPACE + OPERATION_ENUM + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + MERGE + NEW_LINE + EIGHT_SPACE_INDENTATION + REPLACE + NEW_LINE + EIGHT_SPACE_INDENTATION + CREATE + NEW_LINE + EIGHT_SPACE_INDENTATION + DELETE + NEW_LINE + EIGHT_SPACE_INDENTATION + REMOVE + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        /**
         * Add attribute strings.
         */
        try {
            insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + OPERATION_ENUM + SPACE + OP_PARAM_TYPE + SEMI_COLAN + NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        try {
            if (curNode instanceof YangLeavesHolder) {
                YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
                List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
                List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
                if (leaves != null && !leaves.isEmpty()) {
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + FILTER_LEAF + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + SELECT_LEAF + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                }
                if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + FILTER_LEAF_LIST + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + SELECT_LEAF_LIST + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                }
            }
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        if (curNode instanceof YangLeavesHolder) {
            YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
            List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
            List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
            if (leaves != null && !leaves.isEmpty()) {
                methods.add(getToStringLeafgetter());
                methods.add(getToStringSelectLeafgetter());
            }
            if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
                methods.add(getToStringLeafListgetter());
                methods.add(getToStringSelectLeafListgetter());
            }
        }
        methods.add(getOperationTypegetter());
        methods.add(getIsFilterContentMatch(className, curNode, pluginConfig));
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    String constructor = getOpParamConstructorStart(className, pluginConfig);
    constructor = constructor + EIGHT_SPACE_INDENTATION + SUPER + OPEN_PARENTHESIS + BUILDER.toLowerCase() + OBJECT + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    if (curNode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
        List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        String filterLeaf = "";
        String filterLeafList = "";
        if (leaves != null && !leaves.isEmpty()) {
            filterLeaf = EIGHT_SPACE_INDENTATION + FILTER_LEAF + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_FILTER_LEAF + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        }
        if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
            filterLeafList = EIGHT_SPACE_INDENTATION + FILTER_LEAF_LIST + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_FILTER_LEAF_LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        }
        constructor = constructor + filterLeaf + filterLeafList;
    }
    methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    if (curNode instanceof YangAugment) {
        String clsName = getCapitalCase(DEFAULT) + getCapitalCase(YangJavaModelUtils.getAugmentClassName((YangAugment) curNode, pluginConfig));
        methods.add(getBaseClassMethodImpl(clsName));
    }
    /**
     * Add methods in impl class.
     */
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return validateLineLength(file);
}
#method_after
public static File generateOpParamImplClassFile(File file, YangNode curNode, boolean isAttrPresent, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    initiateJavaFileGeneration(file, OPERATION_CLASS_MASK, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    if (isAttrPresent) {
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + ENUM + SPACE + OPERATION_ENUM + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + MERGE + NEW_LINE + EIGHT_SPACE_INDENTATION + REPLACE + NEW_LINE + EIGHT_SPACE_INDENTATION + CREATE + NEW_LINE + EIGHT_SPACE_INDENTATION + DELETE + NEW_LINE + EIGHT_SPACE_INDENTATION + REMOVE + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        // Add attribute strings.
        try {
            insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + OPERATION_ENUM + SPACE + OP_PARAM_TYPE + SEMI_COLAN + NEW_LINE);
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        try {
            if (curNode instanceof YangLeavesHolder) {
                YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
                List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
                List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
                if (leaves != null && !leaves.isEmpty()) {
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + FILTER_LEAF + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + SELECT_LEAF + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                }
                if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + FILTER_LEAF_LIST + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                    insertDataIntoJavaFile(file, FOUR_SPACE_INDENTATION + PRIVATE + SPACE + BITSET + SPACE + SELECT_LEAF_LIST + SPACE + EQUAL + SPACE + NEW + SPACE + BITSET + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE);
                }
            }
        } catch (IOException e) {
            throw new IOException("No data found in temporary java code fragment files for " + className + " while impl class file generation");
        }
        if (curNode instanceof YangLeavesHolder) {
            YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
            List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
            List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
            if (leaves != null && !leaves.isEmpty()) {
                methods.add(getToStringLeafgetter());
                methods.add(getToStringSelectLeafgetter());
            }
            if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
                methods.add(getToStringLeafListgetter());
                methods.add(getToStringSelectLeafListgetter());
            }
        }
        methods.add(getOperationTypegetter());
        methods.add(getIsFilterContentMatch(className, curNode, pluginConfig));
    } else {
        insertDataIntoJavaFile(file, NEW_LINE);
    }
    String constructor = getOpParamConstructorStart(className, pluginConfig);
    constructor = constructor + EIGHT_SPACE_INDENTATION + SUPER + OPEN_PARENTHESIS + BUILDER.toLowerCase() + OBJECT + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    if (curNode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
        List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        String filterLeaf = "";
        String filterLeafList = "";
        if (leaves != null && !leaves.isEmpty()) {
            filterLeaf = EIGHT_SPACE_INDENTATION + FILTER_LEAF + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_FILTER_LEAF + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        }
        if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
            filterLeafList = EIGHT_SPACE_INDENTATION + FILTER_LEAF_LIST + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_FILTER_LEAF_LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
        }
        constructor = constructor + filterLeaf + filterLeafList;
    }
    methods.add(constructor + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET);
    if (curNode instanceof YangAugment) {
        String clsName = getCapitalCase(DEFAULT) + getCapitalCase(YangJavaModelUtils.getAugmentClassName((YangAugment) curNode, pluginConfig));
        methods.add(getBaseClassMethodImpl(clsName));
    }
    // Add methods in impl class.
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    if (type.getDataType().equals(YangDataTypes.BINARY)) {
        imports.add(IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_IMPORT_BASE64_CLASS);
    }
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig));
    try {
        /**
         * Type constructor.
         */
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Of method.
         */
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        /**
         * To string method.
         */
        if (type.getDataType().equals(YangDataTypes.BINARY)) {
            JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = MethodsGenerator.getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(YangDataTypes.BITS)) {
            JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = MethodsGenerator.getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGeninfo = (JavaCodeGeneratorInfo) curNode;
        /**
         * From string method.
         */
        methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGeninfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    if (type.getDataType().equals(YangDataTypes.BINARY)) {
        imports.add(IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_IMPORT_BASE64_CLASS);
    }
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        if (type.getDataType().equals(YangDataTypes.BINARY)) {
            JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = MethodsGenerator.getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(YangDataTypes.BITS)) {
            JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = MethodsGenerator.getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        // From string method.
        methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateUnionClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    TempJavaTypeFragmentFiles tempJavaTypeFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles();
    if (tempJavaTypeFragmentFiles.isLongConflict()) {
        imports.add(tempJavaTypeFragmentFiles.getJavaImportData().getBigIntegerImport());
        sort(imports);
    }
    initiateJavaFileGeneration(file, className, GENERATE_UNION_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        if (tempJavaTypeFragmentFiles.isIntConflict()) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeIntRange(PRIVATE, tempJavaTypeFragmentFiles.getIntIndex() < tempJavaTypeFragmentFiles.getUintIndex()));
        }
        if (tempJavaTypeFragmentFiles.isLongConflict()) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeLongRange(PRIVATE, tempJavaTypeFragmentFiles.getLongIndex() < tempJavaTypeFragmentFiles.getuLongIndex()));
        }
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig));
    try {
        /**
         * Type constructor.
         */
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Of string method.
         */
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        /**
         * To string method.
         */
        methods.add(getToStringMethodOpen() + getOmitNullValueString() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        /**
         * From string method.
         */
        methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        if ((tempJavaTypeFragmentFiles.isIntConflict())) {
            methods.add(MethodsGenerator.getRangeValidatorMethodForUnion(INT));
        }
        if (tempJavaTypeFragmentFiles.isLongConflict()) {
            methods.add(MethodsGenerator.getRangeValidatorMethodForUnion(BIG_INTEGER));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateUnionClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    TempJavaTypeFragmentFiles tempJavaTypeFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles();
    boolean isIntConflict = false;
    boolean isLongConflict = false;
    JavaAttributeInfo intAttr = tempJavaTypeFragmentFiles.getIntAttribute();
    if (intAttr == null) {
        intAttr = tempJavaTypeFragmentFiles.getUIntAttribute();
    }
    JavaAttributeInfo longAttr = tempJavaTypeFragmentFiles.getLongAttribute();
    if (longAttr == null) {
        longAttr = tempJavaTypeFragmentFiles.getULongAttribute();
    }
    if (intAttr != null) {
        isIntConflict = intAttr.isIntConflict();
    }
    if (longAttr != null) {
        isLongConflict = longAttr.isLongConflict();
    }
    if (isLongConflict) {
        imports.add(tempJavaTypeFragmentFiles.getJavaImportData().getBigIntegerImport());
        sort(imports);
    }
    initiateJavaFileGeneration(file, className, GENERATE_UNION_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    // Add attribute strings.
    try {
        if (isIntConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeIntRange(PRIVATE, tempJavaTypeFragmentFiles.getIntIndex() < tempJavaTypeFragmentFiles.getUIntIndex()));
        }
        if (isLongConflict) {
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addStaticAttributeLongRange(PRIVATE, tempJavaTypeFragmentFiles.getLongIndex() < tempJavaTypeFragmentFiles.getULongIndex()));
        }
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    // Default constructor.
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig));
    try {
        // Type constructor.
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Of string method.
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Getter methods.
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        // Hash code method.
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        // Equals method.
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        // To string method.
        methods.add(getToStringMethodOpen() + getOmitNullValueString() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        // From string method.
        methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
        if (isIntConflict) {
            methods.add(MethodsGenerator.getRangeValidatorMethodForUnion(INT));
        }
        if (isLongConflict) {
            methods.add(MethodsGenerator.getRangeValidatorMethodForUnion(BIG_INTEGER));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while union class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = javaFileInfo.getJavaName();
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, pluginConfig);
    /**
     * Add attribute strings.
     */
    try {
        JavaCodeGeneratorInfo javaGeninfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGeninfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    /**
     * Add an
     * attribute to get the enum's values.
     */
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    /**
     * Add a constructor for enum.
     */
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, pluginConfig) + getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    TempJavaEnumerationFragmentFiles enumFragFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles();
    insertDataIntoJavaFile(file, getEnumsOfMethod(className, enumFragFiles.getJavaAttributeForEnum(pluginConfig), enumFragFiles.getEnumSetJavaMap(), enumFragFiles.getEnumStringList(), pluginConfig) + NEW_LINE);
    /**
     * Add a getter method for enum.
     */
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, pluginConfig) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = javaFileInfo.getJavaName();
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, pluginConfig);
    // Add attribute strings.
    try {
        JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    // Add an attribute to get the enum's values.
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    // Add a constructor for enum.
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, pluginConfig) + getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    TempJavaEnumerationFragmentFiles enumFragFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles();
    insertDataIntoJavaFile(file, getEnumsOfMethod(className, enumFragFiles.getJavaAttributeForEnum(pluginConfig), enumFragFiles.getEnumSetJavaMap(), enumFragFiles.getEnumStringList(), pluginConfig) + NEW_LINE);
    // Add a getter method for enum.
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, pluginConfig) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        /**
         * Getter methods.
         */
        methods.add(getGetterString(rootAttribute, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        /**
         * Setter methods.
         */
        methods.add(getSetterString(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGeninfo = (JavaCodeGeneratorInfo) curNode;
            /**
             * Rpc methods
             */
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGeninfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while rpc class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateServiceInterfaceFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    TempJavaServiceFragmentFiles tempJavaServiceFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles();
    String className = getCapitalCase(javaFileInfo.getJavaName()) + SERVICE_METHOD_STRING;
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, GENERATE_SERVICE_AND_MANAGER, imports, curNode, className);
    List<String> methods = new ArrayList<>();
    JavaAttributeInfo rootAttribute = getCurNodeAsAttributeInTarget(curNode, curNode, false, tempJavaServiceFragmentFiles);
    try {
        // Getter methods.
        methods.add(getGetterString(rootAttribute, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        // Setter methods.
        methods.add(getSetterString(rootAttribute, className, GENERATE_SERVICE_AND_MANAGER, javaFileInfo.getPluginConfig()) + NEW_LINE);
        methods.add(getAugmentsDataMethodForService(curNode) + NEW_LINE);
        if (((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getServiceTempFiles() != null) {
            JavaCodeGeneratorInfo javaGenInfo = (JavaCodeGeneratorInfo) curNode;
            // Rpc methods
            methods.add(getDataFromTempFileHandle(RPC_INTERFACE_MASK, javaGenInfo.getTempJavaCodeFragmentFiles().getServiceTempFiles(), path));
        }
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while rpc class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Path("subscribe")
public Response subscribe(InputStream input) {
    EventSubscriptionService service = get(EventSubscriptionService.class);
    try {
        EventSubscriber sub = parseSubscriptionData(input);
        service.subscribe(sub);
    // It will subscribe to all the topics. Not only the one that is sent by the consumer.
    // producerThread = new Producer();
    } catch (Exception e) {
        log.error(e.getMessage());
        return Response.status(BAD_REQUEST).entity(e.getMessage()).build();
    }
    return ok(EVENT_SUBSCRIPTION_SUCCESSFUL).build();
}
#method_after
@POST
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Path("subscribe")
public Response subscribe(InputStream input) {
    EventSubscriptionService service = get(EventSubscriptionService.class);
    try {
        EventSubscriber sub = parseSubscriptionData(input);
        service.subscribe(sub);
    // It will subscribe to all the topics. Not only the one that is sent by the consumer.
    } catch (Exception e) {
        log.error(e.getMessage());
        return Response.status(BAD_REQUEST).entity(e.getMessage()).build();
    }
    return ok(EVENT_SUBSCRIPTION_SUCCESSFUL).build();
}
#end_block

#method_before
public static String getSetterForLeaf(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
        if (leaves != null) {
            for (YangLeaf leaf : leaves) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeaf(tempFragmentFiles, leaf, pluginConfig);
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                String attributeName = javaAttributeInfo.getAttributeName();
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#method_after
public static String getSetterForLeaf(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
        if (leaves != null && !leaves.isEmpty()) {
            for (YangLeaf leaf : leaves) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeaf(tempFragmentFiles, leaf, pluginConfig);
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                String attributeName = javaAttributeInfo.getAttributeName();
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#end_block

#method_before
public static String getSetterForLeafList(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        if (listOfLeafList != null) {
            numleaf = 1;
            for (YangLeafList leafList : listOfLeafList) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeafList(tempFragmentFiles, leafList, pluginConfig);
                String attributeName = javaAttributeInfo.getAttributeName();
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                if (javaAttributeInfo.isListAttr()) {
                    attrQuaifiedType = getListString() + attrQuaifiedType + DIAMOND_CLOSE_BRACKET;
                }
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF_LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#method_after
public static String getSetterForLeafList(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
            for (YangLeafList leafList : listOfLeafList) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeafList(tempFragmentFiles, leafList, pluginConfig);
                String attributeName = javaAttributeInfo.getAttributeName();
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                if (javaAttributeInfo.isListAttr()) {
                    attrQuaifiedType = getListString() + attrQuaifiedType + DIAMOND_CLOSE_BRACKET;
                }
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF_LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#end_block

#method_before
public static String getIsFilterContentMatch(String className, YangNode curNode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = NEW_LINE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + BOOLEAN_DATA_TYPE + SPACE + FILTER_CONTENT_MATCH + OPEN_PARENTHESIS + getCapitalCase(OBJECT) + SPACE + OBJ + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    filterMethod = filterMethod + EIGHT_SPACE_INDENTATION + getCapitalCase(DEFAULT) + getCapitalCase(className) + SPACE + APP_INSTANCE + SPACE + EQUAL + SPACE + OPEN_PARENTHESIS + getCapitalCase(DEFAULT) + getCapitalCase(className) + CLOSE_PARENTHESIS + OBJ + SEMI_COLAN + NEW_LINE;
    if (curNode instanceof YangAugmentableNode) {
        filterMethod = filterMethod + getAugmentableOpParamSyntax();
    }
    if (curNode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
        List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        if (leaves != null) {
            for (YangLeaf leaf : leaves) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeaf(tempFragmentFiles, leaf, pluginConfig);
                String attributeName = javaAttributeInfo.getAttributeName();
                String attrQuaifiedType = "";
                if (isPrimitiveDataType(leaf.getDataType().getDataType())) {
                    attrQuaifiedType = APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + NOT + EQUAL + SPACE + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS;
                } else {
                    attrQuaifiedType = APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + EQUAL + EQUAL + SPACE + NULL + SPACE + OR_OPERATION + SPACE + NOT + OPEN_PARENTHESIS + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + EQUALS_STRING + OPEN_PARENTHESIS + APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS;
                }
                filterMethod = filterMethod + EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + GET_FILTER_LEAF + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + GET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + attrQuaifiedType + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLAN + NEW_LINE + TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
                numleaf++;
            }
        }
        if (listOfLeafList != null) {
            numleaf = 1;
            for (YangLeafList leafList : listOfLeafList) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeafList(tempFragmentFiles, leafList, pluginConfig);
                String attributeName = javaAttributeInfo.getAttributeName();
                String attrQuaifiedType = "";
                if (isPrimitiveDataType(leafList.getDataType().getDataType())) {
                    attrQuaifiedType = APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + NOT + EQUAL + SPACE + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS;
                } else {
                    attrQuaifiedType = APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + EQUAL + EQUAL + SPACE + NULL + OR_OPERATION + OPEN_PARENTHESIS + NOT + OPEN_PARENTHESIS + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + EQUALS_STRING + OPEN_PARENTHESIS + APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS;
                }
                filterMethod = filterMethod + EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + GET_FILTER_LEAF_LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + GET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + attrQuaifiedType + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLAN + NEW_LINE + TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
                numleaf++;
            }
        }
        filterMethod = filterMethod + EIGHT_SPACE_INDENTATION + RETURN + SPACE + TRUE + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
    }
    return filterMethod;
}
#method_after
public static String getIsFilterContentMatch(String className, YangNode curNode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = NEW_LINE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + BOOLEAN_DATA_TYPE + SPACE + FILTER_CONTENT_MATCH + OPEN_PARENTHESIS + getCapitalCase(OBJECT) + SPACE + OBJ + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    filterMethod = filterMethod + EIGHT_SPACE_INDENTATION + getCapitalCase(DEFAULT) + getCapitalCase(className) + SPACE + APP_INSTANCE + SPACE + EQUAL + SPACE + OPEN_PARENTHESIS + getCapitalCase(DEFAULT) + getCapitalCase(className) + CLOSE_PARENTHESIS + OBJ + SEMI_COLAN + NEW_LINE;
    if (curNode instanceof YangAugmentableNode) {
        filterMethod = filterMethod + getAugmentableOpParamSyntax();
    }
    if (curNode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curNode;
        List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        if (leaves != null) {
            for (YangLeaf leaf : leaves) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeaf(tempFragmentFiles, leaf, pluginConfig);
                String attributeName = javaAttributeInfo.getAttributeName();
                String attrQuaifiedType = "";
                if (isPrimitiveDataType(leaf.getDataType().getDataType())) {
                    attrQuaifiedType = APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + NOT + EQUAL + SPACE + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS;
                } else {
                    attrQuaifiedType = APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + EQUAL + EQUAL + SPACE + NULL + SPACE + OR_OPERATION + SPACE + NOT + OPEN_PARENTHESIS + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + EQUALS_STRING + OPEN_PARENTHESIS + APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS;
                }
                filterMethod = filterMethod + EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + GET_FILTER_LEAF + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + GET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + attrQuaifiedType + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLAN + NEW_LINE + TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
                numleaf++;
            }
        }
        if (listOfLeafList != null) {
            numleaf = 1;
            for (YangLeafList leafList : listOfLeafList) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeafList(tempFragmentFiles, leafList, pluginConfig);
                String attributeName = javaAttributeInfo.getAttributeName();
                String attrQuaifiedType = "";
                if (isPrimitiveDataType(leafList.getDataType().getDataType())) {
                    attrQuaifiedType = APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + NOT + EQUAL + SPACE + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS;
                } else {
                    attrQuaifiedType = APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + EQUAL + EQUAL + SPACE + NULL + OR_OPERATION + OPEN_PARENTHESIS + NOT + OPEN_PARENTHESIS + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + EQUALS_STRING + OPEN_PARENTHESIS + APP_INSTANCE + PERIOD + attributeName + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS;
                }
                filterMethod = filterMethod + EIGHT_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + GET_FILTER_LEAF_LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + GET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + TWELVE_SPACE_INDENTATION + IF + SPACE + OPEN_PARENTHESIS + attrQuaifiedType + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + FALSE + SEMI_COLAN + NEW_LINE + TWELVE_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
                numleaf++;
            }
        }
        if (leaves != null || listOfLeafList != null) {
            filterMethod = filterMethod + EIGHT_SPACE_INDENTATION + RETURN + SPACE + TRUE + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
        }
    }
    return filterMethod;
}
#end_block

#method_before
public static String getEnumsOfMethod(String className, JavaAttributeInfo attr, Map<String, Integer> enumMap, List<String> enumList, YangPluginConfig pluginConfig) {
    String attrType = getReturnType(attr);
    String attrName = attr.getAttributeName();
    String method = FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + getCapitalCase(className) + SPACE + OF + OPEN_PARENTHESIS + attrType + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + SWITCH + SPACE + OPEN_PARENTHESIS + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    int value = 0;
    for (String str : enumList) {
        value = enumMap.get(str);
        method = method + TWELVE_SPACE_INDENTATION + CASE + SPACE + value + COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + getCapitalCase(className) + PERIOD + str + SEMI_COLAN + NEW_LINE;
    }
    method = method + TWELVE_SPACE_INDENTATION + DEFAULT + SPACE + COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    return getJavaDoc(OF_METHOD, getCapitalCase(className) + " for type " + attrName, false, pluginConfig) + method;
}
#method_after
public static String getEnumsOfMethod(String className, JavaAttributeInfo attr, Map<String, Integer> enumMap, List<String> enumList, YangPluginConfig pluginConfig) {
    String attrType = getReturnType(attr);
    String attrName = attr.getAttributeName();
    String method = FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + getCapitalCase(className) + SPACE + OF + OPEN_PARENTHESIS + attrType + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + SWITCH + SPACE + OPEN_PARENTHESIS + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    int value = 0;
    for (String str : enumList) {
        value = enumMap.get(str);
        method = method + TWELVE_SPACE_INDENTATION + CASE + SPACE + value + COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + getCapitalCase(className) + PERIOD + str + SEMI_COLAN + NEW_LINE;
    }
    method = method + TWELVE_SPACE_INDENTATION + DEFAULT + SPACE + COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    return getJavaDoc(OF_METHOD, getCapitalCase(className) + " for type" + attrName, false, pluginConfig) + method;
}
#end_block

#method_before
static String getAugmentsDataMethodForService(YangNode parent) {
    List<YangAbsolutePath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    String returnType;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAbsolutePath nodeId : targets) {
        augmentedNode = nodeId.getResolvedNode().getParent();
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode, pluginConfig);
        method = getJavaDoc(GETTER_METHOD, getSmallCase(AUGMENTED + parentName + curNodeName), false, pluginConfig) + getGetterForInterface(AUGMENTED + parentName + getCapitalCase(curNodeName), returnType, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getJavaDoc(MANAGER_SETTER_METHOD, AUGMENTED + getCapitalCase(parentName) + curNodeName, false, pluginConfig) + getSetterForInterface(getSmallCase(AUGMENTED) + parentName + getCapitalCase(curNodeName), returnType, parentName, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#method_after
static String getAugmentsDataMethodForService(YangNode parent) {
    List<YangAtomicPath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    String returnType;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAtomicPath nodeId : targets) {
        augmentedNode = nodeId.getResolvedNode().getParent();
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode, pluginConfig);
        method = getJavaDoc(GETTER_METHOD, getSmallCase(AUGMENTED + parentName + curNodeName), false, pluginConfig) + getGetterForInterface(AUGMENTED + parentName + getCapitalCase(curNodeName), returnType, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getJavaDoc(MANAGER_SETTER_METHOD, AUGMENTED + getCapitalCase(parentName) + curNodeName, false, pluginConfig) + getSetterForInterface(getSmallCase(AUGMENTED) + parentName + getCapitalCase(curNodeName), returnType, parentName, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#end_block

#method_before
static String getAugmentsDataMethodForManager(YangNode parent) {
    List<YangAbsolutePath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String returnType;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAbsolutePath nodeId : targets) {
        augmentedNode = nodeId.getResolvedNode().getParent();
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode, pluginConfig);
        method = getOverRideString() + getGetter(returnType, AUGMENTED + parentName + getCapitalCase(curNodeName), GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getOverRideString() + getSetter(parentName, getSmallCase(AUGMENTED) + getCapitalCase(parentName) + getCapitalCase(curNodeName), returnType, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#method_after
static String getAugmentsDataMethodForManager(YangNode parent) {
    List<YangAtomicPath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String returnType;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAtomicPath nodeId : targets) {
        augmentedNode = nodeId.getResolvedNode().getParent();
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode, pluginConfig);
        method = getOverRideString() + getGetter(returnType, AUGMENTED + parentName + getCapitalCase(curNodeName), GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getOverRideString() + getSetter(parentName, getSmallCase(AUGMENTED) + getCapitalCase(parentName) + getCapitalCase(curNodeName), returnType, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#end_block

#method_before
private static void convertThePrefixesDuringChange(YangLeafRef leafrefForCloning, YangUses yangUses) throws DataModelException {
    List<YangAbsolutePath> absolutePathList = leafrefForCloning.getAbsolutePath();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAbsolutePath> absolutePathIterator = absolutePathList.listIterator();
        while (absolutePathIterator.hasNext()) {
            YangAbsolutePath absolutePath = absolutePathIterator.next();
            Map<String, String> prefixesAndItsImportNameNode = leafrefForCloning.getPrefixAndItsImportedModule();
            if (!prefixesAndItsImportNameNode.isEmpty() || prefixesAndItsImportNameNode != null) {
                String prefixInPath = absolutePath.getNodeIdentifier().getPrefix();
                String importedNodeName = prefixesAndItsImportNameNode.get(prefixInPath);
                assignCurrentLeafrefWithNewPrefixes(importedNodeName, absolutePath, yangUses);
            }
        }
    }
}
#method_after
private static void convertThePrefixesDuringChange(YangLeafRef leafrefForCloning, YangUses yangUses) throws DataModelException {
    List<YangAtomicPath> atomicPathList = leafrefForCloning.getAtomicPath();
    if (atomicPathList != null && !atomicPathList.isEmpty()) {
        Iterator<YangAtomicPath> atomicPathIterator = atomicPathList.listIterator();
        while (atomicPathIterator.hasNext()) {
            YangAtomicPath atomicPath = atomicPathIterator.next();
            Map<String, String> prefixesAndItsImportNameNode = leafrefForCloning.getPrefixAndItsImportedModule();
            if (!prefixesAndItsImportNameNode.isEmpty() || prefixesAndItsImportNameNode != null) {
                String prefixInPath = atomicPath.getNodeIdentifier().getPrefix();
                String importedNodeName = prefixesAndItsImportNameNode.get(prefixInPath);
                assignCurrentLeafrefWithNewPrefixes(importedNodeName, atomicPath, yangUses);
            }
        }
    }
}
#end_block

#method_before
private static void assignCurrentLeafrefWithNewPrefixes(String importedNodeName, YangAbsolutePath absolutePath, YangNode node) throws DataModelException {
    while (!(node instanceof YangReferenceResolver)) {
        node = node.getParent();
        if (node == null) {
            throw new DataModelException("Internal datamodel error: Datamodel tree is not correct");
        }
    }
    if (node instanceof YangModule) {
        List<YangImport> importInUsesList = ((YangModule) node).getImportList();
        if (importInUsesList != null && !importInUsesList.isEmpty()) {
            Iterator<YangImport> importInUsesListIterator = importInUsesList.listIterator();
            while (importInUsesListIterator.hasNext()) {
                YangImport importInUsesNode = importInUsesListIterator.next();
                if (importInUsesNode.getModuleName().equals(importedNodeName)) {
                    absolutePath.getNodeIdentifier().setPrefix(importInUsesNode.getPrefixId());
                }
            }
        }
    }
}
#method_after
private static void assignCurrentLeafrefWithNewPrefixes(String importedNodeName, YangAtomicPath atomicPath, YangNode node) throws DataModelException {
    while (!(node instanceof YangReferenceResolver)) {
        node = node.getParent();
        if (node == null) {
            throw new DataModelException("Internal datamodel error: Datamodel tree is not correct");
        }
    }
    if (node instanceof YangModule) {
        List<YangImport> importInUsesList = ((YangModule) node).getImportList();
        if (importInUsesList != null && !importInUsesList.isEmpty()) {
            Iterator<YangImport> importInUsesListIterator = importInUsesList.listIterator();
            while (importInUsesListIterator.hasNext()) {
                YangImport importInUsesNode = importInUsesListIterator.next();
                if (importInUsesNode.getModuleName().equals(importedNodeName)) {
                    atomicPath.getNodeIdentifier().setPrefix(importInUsesNode.getPrefixId());
                }
            }
        }
    }
}
#end_block

#method_before
private void processXPathLinking(T entityToResolve, YangReferenceResolver root) {
    YangXpathLinker<T> xPathLinker = new YangXpathLinker<T>();
    if (entityToResolve instanceof YangAugment) {
        YangNode targetNode = null;
        YangAugment augment = (YangAugment) entityToResolve;
        targetNode = xPathLinker.processAugmentXpathLinking(augment.getTargetNode(), (YangNode) root);
        if (targetNode != null) {
            if (targetNode instanceof YangAugmentableNode) {
                detectCollisionForAugmentedNode(targetNode, augment);
                ((YangAugmentableNode) targetNode).addAugmentation(augment);
                augment.setAugmentedNode(targetNode);
                Resolvable resolvable = (Resolvable) entityToResolve;
                resolvable.setResolvableStatus(RESOLVED);
            } else {
                throw new LinkerException("Invalid target node type " + targetNode.getNodeType() + " for " + augment.getName());
            }
        } else {
            throw new LinkerException("Failed to link " + augment.getName());
        }
    } else if (entityToResolve instanceof YangLeafRef) {
        YangLeafRef leafRef = (YangLeafRef) entityToResolve;
        Object target = xPathLinker.processLeafRefXpathLinking(leafRef.getAbsolutePath(), (YangNode) root, leafRef);
        if (target != null) {
            YangLeaf leaf = null;
            YangLeafList leafList = null;
            leafRef.setReferredLeafOrLeafList(target);
            if (target instanceof YangLeaf) {
                leaf = (YangLeaf) target;
                leafRef.setResolvableStatus(INTER_FILE_LINKED);
                addUnResolvedLeafRefTypeToStack((T) leaf, getEntityToResolveInfo().getHolderOfEntityToResolve());
            } else {
                leafList = (YangLeafList) target;
                leafRef.setResolvableStatus(INTER_FILE_LINKED);
                addUnResolvedLeafRefTypeToStack((T) leafList, getEntityToResolveInfo().getHolderOfEntityToResolve());
            }
        // TODO: add logic for leaf-ref for path predicates.
        } else {
            LinkerException linkerException = new LinkerException("YANG file error: Unable to find base " + "leaf/leaf-list for given leafref path " + leafRef.getPath());
            linkerException.setCharPosition(leafRef.getCharPosition());
            linkerException.setLine(leafRef.getLineNumber());
            throw linkerException;
        }
    }
}
#method_after
private void processXPathLinking(T entityToResolve, YangReferenceResolver root) {
    YangXpathLinker<T> xPathLinker = new YangXpathLinker<T>();
    if (entityToResolve instanceof YangAugment) {
        YangNode targetNode = null;
        YangAugment augment = (YangAugment) entityToResolve;
        targetNode = xPathLinker.processAugmentXpathLinking(augment.getTargetNode(), (YangNode) root);
        if (targetNode != null) {
            if (targetNode instanceof YangAugmentableNode) {
                detectCollisionForAugmentedNode(targetNode, augment);
                ((YangAugmentableNode) targetNode).addAugmentation(augment);
                augment.setAugmentedNode(targetNode);
                Resolvable resolvable = (Resolvable) entityToResolve;
                resolvable.setResolvableStatus(RESOLVED);
            } else {
                throw new LinkerException("Invalid target node type " + targetNode.getNodeType() + " for " + augment.getName());
            }
        } else {
            throw new LinkerException("Failed to link " + augment.getName());
        }
    } else if (entityToResolve instanceof YangLeafRef) {
        YangLeafRef leafRef = (YangLeafRef) entityToResolve;
        Object target = xPathLinker.processLeafRefXpathLinking(leafRef.getAtomicPath(), (YangNode) root, leafRef);
        if (target != null) {
            YangLeaf leaf = null;
            YangLeafList leafList = null;
            leafRef.setReferredLeafOrLeafList(target);
            if (target instanceof YangLeaf) {
                leaf = (YangLeaf) target;
                leafRef.setResolvableStatus(INTER_FILE_LINKED);
                addUnResolvedLeafRefTypeToStack((T) leaf, getEntityToResolveInfo().getHolderOfEntityToResolve());
            } else {
                leafList = (YangLeafList) target;
                leafRef.setResolvableStatus(INTER_FILE_LINKED);
                addUnResolvedLeafRefTypeToStack((T) leafList, getEntityToResolveInfo().getHolderOfEntityToResolve());
            }
        // TODO: add logic for leaf-ref for path predicates.
        } else {
            LinkerException linkerException = new LinkerException("YANG file error: Unable to find base " + "leaf/leaf-list for given leafref path " + leafRef.getPath());
            linkerException.setCharPosition(leafRef.getCharPosition());
            linkerException.setLine(leafRef.getLineNumber());
            throw linkerException;
        }
    }
}
#end_block

#method_before
public void setAbsolutePathFromRelativePathInLeafref(T resolutionInfo) throws DataModelException {
    if (resolutionInfo instanceof YangLeafRef) {
        YangNode parentOfLeafref = ((YangLeafRef) resolutionInfo).getParentNodeOfLeafref();
        YangLeafRef leafref = (YangLeafRef) resolutionInfo;
        // Checks if the leafref has relative path in it.
        if (leafref.getPathType() == YangPathArgType.RELATIVE_PATH) {
            YangRelativePath relativePath = leafref.getRelativePath();
            List<YangAbsolutePath> absoluteInRelative = relativePath.getAbsolutePath();
            int numberOfAncestors = relativePath.getAncestorNodeCount();
            // Gets the root node from the ancestor count.
            T nodeOrAugmentList = getRootNodeWithAncestorCountForLeafref(numberOfAncestors, parentOfLeafref, leafref);
            if (nodeOrAugmentList instanceof YangNode) {
                String pathNameToBePrefixed = EMPTY_STRING;
                YangNode rootNode = (YangNode) nodeOrAugmentList;
                // Forms a new absolute path from the relative path
                while (!(rootNode instanceof YangReferenceResolver)) {
                    pathNameToBePrefixed = rootNode.getName() + SLASH_FOR_STRING + pathNameToBePrefixed;
                    rootNode = rootNode.getParent();
                    if (rootNode == null) {
                        throw new DataModelException("Internal datamodel error: Datamodel tree is not correct");
                    }
                }
                fillAbsolutePathValuesInLeafref(leafref, pathNameToBePrefixed, absoluteInRelative);
            } else {
                List<String> listOfAugment = (List<String>) nodeOrAugmentList;
                Iterator<String> listOfAugmentIterator = listOfAugment.listIterator();
                String augment = EMPTY_STRING;
                while (listOfAugmentIterator.hasNext()) {
                    augment = augment + SLASH_FOR_STRING + listOfAugmentIterator.next();
                }
                fillAbsolutePathValuesInLeafref(leafref, augment, absoluteInRelative);
            }
        }
    }
}
#method_after
public void setAbsolutePathFromRelativePathInLeafref(T resolutionInfo) throws DataModelException {
    if (resolutionInfo instanceof YangLeafRef) {
        YangNode parentOfLeafref = ((YangLeafRef) resolutionInfo).getParentNodeOfLeafref();
        YangLeafRef leafref = (YangLeafRef) resolutionInfo;
        // Checks if the leafref has relative path in it.
        if (leafref.getPathType() == YangPathArgType.RELATIVE_PATH) {
            YangRelativePath relativePath = leafref.getRelativePath();
            List<YangAtomicPath> absoluteInRelative = relativePath.getAtomicPathList();
            int numberOfAncestors = relativePath.getAncestorNodeCount();
            // Gets the root node from the ancestor count.
            T nodeOrAugmentList = getRootNodeWithAncestorCountForLeafref(numberOfAncestors, parentOfLeafref, leafref);
            if (nodeOrAugmentList instanceof YangNode) {
                String pathNameToBePrefixed = EMPTY_STRING;
                YangNode rootNode = (YangNode) nodeOrAugmentList;
                // Forms a new absolute path from the relative path
                while (!(rootNode instanceof YangReferenceResolver)) {
                    pathNameToBePrefixed = rootNode.getName() + SLASH_FOR_STRING + pathNameToBePrefixed;
                    rootNode = rootNode.getParent();
                    if (rootNode == null) {
                        throw new DataModelException("Internal datamodel error: Datamodel tree is not correct");
                    }
                }
                fillAbsolutePathValuesInLeafref(leafref, pathNameToBePrefixed, absoluteInRelative);
            } else {
                List<String> listOfAugment = (List<String>) nodeOrAugmentList;
                Iterator<String> listOfAugmentIterator = listOfAugment.listIterator();
                String augment = EMPTY_STRING;
                while (listOfAugmentIterator.hasNext()) {
                    augment = augment + SLASH_FOR_STRING + listOfAugmentIterator.next();
                }
                fillAbsolutePathValuesInLeafref(leafref, augment, absoluteInRelative);
            }
        }
    }
}
#end_block

#method_before
private void fillAbsolutePathValuesInLeafref(YangLeafRef leafref, String pathNameToBePrefixed, List<YangAbsolutePath> absoluteInRelative) throws DataModelException {
    leafref.setPathType(YangPathArgType.ABSOLUTE_PATH);
    String[] pathName = new String[0];
    if (pathNameToBePrefixed != EMPTY_STRING && pathNameToBePrefixed != null) {
        pathName = pathNameToBePrefixed.split(SLASH_FOR_STRING);
    }
    List<YangAbsolutePath> finalListForAbsolute = new LinkedList<>();
    for (String value : pathName) {
        if (value != null && !value.isEmpty() && value != EMPTY_STRING) {
            YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(value, YangConstructType.PATH_DATA);
            YangAbsolutePath absolutePath = new YangAbsolutePath();
            absolutePath.setNodeIdentifier(nodeIdentifier);
            finalListForAbsolute.add(absolutePath);
        }
    }
    if (absoluteInRelative != null && !absoluteInRelative.isEmpty()) {
        Iterator<YangAbsolutePath> absolutePathIterator = absoluteInRelative.listIterator();
        while (absolutePathIterator.hasNext()) {
            YangAbsolutePath yangAbsolutePath = absolutePathIterator.next();
            finalListForAbsolute.add(yangAbsolutePath);
        }
        leafref.setAbsolutePath(finalListForAbsolute);
    } else {
        DataModelException dataModelException = new DataModelException("YANG file error: The target node, in the " + "leafref path " + leafref.getPath() + ", is invalid.");
        dataModelException.setCharPosition(leafref.getCharPosition());
        dataModelException.setLine(leafref.getLineNumber());
        throw dataModelException;
    }
}
#method_after
private void fillAbsolutePathValuesInLeafref(YangLeafRef leafref, String pathNameToBePrefixed, List<YangAtomicPath> atomicPathsInRelative) throws DataModelException {
    leafref.setPathType(YangPathArgType.ABSOLUTE_PATH);
    String[] pathName = new String[0];
    if (pathNameToBePrefixed != EMPTY_STRING && pathNameToBePrefixed != null) {
        pathName = pathNameToBePrefixed.split(SLASH_FOR_STRING);
    }
    List<YangAtomicPath> finalListForAbsolute = new LinkedList<>();
    for (String value : pathName) {
        if (value != null && !value.isEmpty() && value != EMPTY_STRING) {
            YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(value, YangConstructType.PATH_DATA);
            YangAtomicPath atomicPath = new YangAtomicPath();
            atomicPath.setNodeIdentifier(nodeIdentifier);
            finalListForAbsolute.add(atomicPath);
        }
    }
    if (atomicPathsInRelative != null && !atomicPathsInRelative.isEmpty()) {
        Iterator<YangAtomicPath> atomicPathIterator = atomicPathsInRelative.listIterator();
        while (atomicPathIterator.hasNext()) {
            YangAtomicPath yangAtomicPath = atomicPathIterator.next();
            finalListForAbsolute.add(yangAtomicPath);
        }
        leafref.setAtomicPath(finalListForAbsolute);
    } else {
        DataModelException dataModelException = new DataModelException("YANG file error: The target node, in the " + "leafref path " + leafref.getPath() + ", is invalid.");
        dataModelException.setCharPosition(leafref.getCharPosition());
        dataModelException.setLine(leafref.getLineNumber());
        throw dataModelException;
    }
}
#end_block

#method_before
private Map<YangAbsolutePath, PrefixResolverType> getPrefixResolverTypes() {
    return prefixResolverTypes;
}
#method_after
public Map<YangAtomicPath, PrefixResolverType> getPrefixResolverTypes() {
    return prefixResolverTypes;
}
#end_block

#method_before
private void setPrefixResolverTypes(Map<YangAbsolutePath, PrefixResolverType> prefixResolverTypes) {
    this.prefixResolverTypes = prefixResolverTypes;
}
#method_after
public void setPrefixResolverTypes(Map<YangAtomicPath, PrefixResolverType> prefixResolverTypes) {
    this.prefixResolverTypes = prefixResolverTypes;
}
#end_block

#method_before
private void addToPrefixResolverList(PrefixResolverType type, YangAbsolutePath path) {
    getPrefixResolverTypes().put(path, type);
}
#method_after
private void addToPrefixResolverList(PrefixResolverType type, YangAtomicPath path) {
    getPrefixResolverTypes().put(path, type);
}
#end_block

#method_before
private List<YangAbsolutePath> getAbsPaths() {
    return absPaths;
}
#method_after
private List<YangAtomicPath> getAbsPaths() {
    return absPaths;
}
#end_block

#method_before
private void setAbsPaths(List<YangAbsolutePath> absPaths) {
    this.absPaths = absPaths;
}
#method_after
private void setAbsPaths(List<YangAtomicPath> absPaths) {
    this.absPaths = absPaths;
}
#end_block

#method_before
private void addToResolvedNodes(YangAbsolutePath path, YangNode node) {
    path.setResolvedNode(node);
}
#method_after
private void addToResolvedNodes(YangAtomicPath path, YangNode node) {
    path.setResolvedNode(node);
}
#end_block

#method_before
T processLeafRefXpathLinking(List<YangAbsolutePath> absPaths, YangNode root, YangLeafRef leafref) {
    YangNode targetNode;
    setRootNode(root);
    setPrefixResolverTypes(new HashMap<>());
    parsePrefixResolverList(absPaths);
    YangAbsolutePath leafRefPath = absPaths.get(absPaths.size() - 1);
    // When leaf-ref path contains only one absolute path.
    if (absPaths.size() == 1) {
        targetNode = getTargetNodewhenSizeIsOne(absPaths);
    } else {
        absPaths.remove(absPaths.size() - 1);
        setAbsPaths(absPaths);
        targetNode = parseData(root);
    }
    if (targetNode == null) {
        targetNode = searchInSubModule(root);
    }
    // Invalid path presence in the node list is checked.
    validateInvalidNodesInThePath(leafref);
    if (targetNode != null) {
        YangLeaf targetLeaf = searchReferredLeaf(targetNode, leafRefPath.getNodeIdentifier().getName());
        if (targetLeaf == null) {
            YangLeafList targetLeafList = searchReferredLeafList(targetNode, leafRefPath.getNodeIdentifier().getName());
            if (targetLeafList != null) {
                return (T) targetLeafList;
            } else {
                LinkerException linkerException = new LinkerException("YANG file error: Unable to find base " + "leaf/leaf-list for given leafref path " + leafref.getPath());
                linkerException.setCharPosition(leafref.getCharPosition());
                linkerException.setLine(leafref.getLineNumber());
                throw linkerException;
            }
        }
        return (T) targetLeaf;
    }
    return null;
}
#method_after
public T processLeafRefXpathLinking(List<YangAtomicPath> atomicPaths, YangNode root, YangLeafRef leafref) {
    YangNode targetNode;
    setRootNode(root);
    setPrefixResolverTypes(new HashMap<>());
    parsePrefixResolverList(atomicPaths);
    YangAtomicPath leafRefPath = atomicPaths.get(atomicPaths.size() - 1);
    // When leaf-ref path contains only one absolute path.
    if (atomicPaths.size() == 1) {
        targetNode = getTargetNodewhenSizeIsOne(atomicPaths);
    } else {
        atomicPaths.remove(atomicPaths.size() - 1);
        setAbsPaths(atomicPaths);
        targetNode = parseData(root);
    }
    if (targetNode == null) {
        targetNode = searchInSubModule(root);
    }
    // Invalid path presence in the node list is checked.
    validateInvalidNodesInThePath(leafref);
    if (targetNode != null) {
        YangLeaf targetLeaf = searchReferredLeaf(targetNode, leafRefPath.getNodeIdentifier().getName());
        if (targetLeaf == null) {
            YangLeafList targetLeafList = searchReferredLeafList(targetNode, leafRefPath.getNodeIdentifier().getName());
            if (targetLeafList != null) {
                return (T) targetLeafList;
            } else {
                LinkerException linkerException = new LinkerException("YANG file error: Unable to find base " + "leaf/leaf-list for given leafref path " + leafref.getPath());
                linkerException.setCharPosition(leafref.getCharPosition());
                linkerException.setLine(leafref.getLineNumber());
                throw linkerException;
            }
        }
        return (T) targetLeaf;
    }
    return null;
}
#end_block

#method_before
private void validateInvalidNodesInThePath(YangLeafRef leafref) {
    for (YangAbsolutePath absolutePath : (Iterable<YangAbsolutePath>) leafref.getAbsolutePath()) {
        YangNode nodeInPath = absolutePath.getResolvedNode();
        if (nodeInPath instanceof YangGrouping || nodeInPath instanceof YangUses || nodeInPath instanceof YangTypeDef || nodeInPath instanceof YangCase || nodeInPath instanceof YangChoice) {
            LinkerException linkerException = new LinkerException("YANG file error: The target node, in the " + "leafref path " + leafref.getPath() + ", is invalid.");
            linkerException.setCharPosition(leafref.getCharPosition());
            linkerException.setLine(leafref.getLineNumber());
            throw linkerException;
        }
    }
}
#method_after
private void validateInvalidNodesInThePath(YangLeafRef leafref) {
    for (YangAtomicPath absolutePath : (Iterable<YangAtomicPath>) leafref.getAtomicPath()) {
        YangNode nodeInPath = absolutePath.getResolvedNode();
        if (nodeInPath instanceof YangGrouping || nodeInPath instanceof YangUses || nodeInPath instanceof YangTypeDef || nodeInPath instanceof YangCase || nodeInPath instanceof YangChoice) {
            LinkerException linkerException = new LinkerException("YANG file error: The target node, in the " + "leafref path " + leafref.getPath() + ", is invalid.");
            linkerException.setCharPosition(leafref.getCharPosition());
            linkerException.setLine(leafref.getLineNumber());
            throw linkerException;
        }
    }
}
#end_block

#method_before
private YangNode getTargetNodewhenSizeIsOne(List<YangAbsolutePath> absPaths) {
    if (absPaths.get(0).getNodeIdentifier().getPrefix() != null && !absPaths.get(0).getNodeIdentifier().getPrefix().equals(getRootsPrefix(getRootNode()))) {
        return getImportedNode(getRootNode(), absPaths.get(0).getNodeIdentifier());
    }
    return getRootNode();
}
#method_after
private YangNode getTargetNodewhenSizeIsOne(List<YangAtomicPath> absPaths) {
    if (absPaths.get(0).getNodeIdentifier().getPrefix() != null && !absPaths.get(0).getNodeIdentifier().getPrefix().equals(getRootsPrefix(getRootNode()))) {
        return getImportedNode(getRootNode(), absPaths.get(0).getNodeIdentifier());
    }
    return getRootNode();
}
#end_block

#method_before
public YangNode processAugmentXpathLinking(List<YangAbsolutePath> absPaths, YangNode root) {
    setAbsPaths(absPaths);
    setRootNode(root);
    setPrefixResolverTypes(new HashMap<>());
    parsePrefixResolverList(absPaths);
    YangNode targetNode = parseData(root);
    if (targetNode == null) {
        targetNode = searchInSubModule(root);
    }
    return targetNode;
}
#method_after
public YangNode processAugmentXpathLinking(List<YangAtomicPath> absPaths, YangNode root) {
    setAbsPaths(absPaths);
    setRootNode(root);
    setPrefixResolverTypes(new HashMap<>());
    parsePrefixResolverList(absPaths);
    YangNode targetNode = parseData(root);
    if (targetNode == null) {
        targetNode = searchInSubModule(root);
    }
    return targetNode;
}
#end_block

#method_before
private YangNode parseData(YangNode root) {
    String rootPrefix = getRootsPrefix(root);
    Iterator<YangAbsolutePath> pathIterator = getAbsPaths().iterator();
    YangAbsolutePath path = pathIterator.next();
    if (path.getNodeIdentifier().getPrefix() != null && !path.getNodeIdentifier().getPrefix().equals(rootPrefix)) {
        return parsePath(getImportedNode(root, path.getNodeIdentifier()));
    } else {
        return parsePath(root);
    }
}
#method_after
private YangNode parseData(YangNode root) {
    String rootPrefix = getRootsPrefix(root);
    Iterator<YangAtomicPath> pathIterator = getAbsPaths().iterator();
    YangAtomicPath path = pathIterator.next();
    if (path.getNodeIdentifier().getPrefix() != null && !path.getNodeIdentifier().getPrefix().equals(rootPrefix)) {
        return parsePath(getImportedNode(root, path.getNodeIdentifier()));
    } else {
        return parsePath(root);
    }
}
#end_block

#method_before
private YangNode parsePath(YangNode root) {
    YangNode tempNode = root;
    Stack<YangNode> linkerStack = new Stack<>();
    Iterator<YangAbsolutePath> pathIterator = getAbsPaths().iterator();
    YangAbsolutePath tempPath = pathIterator.next();
    setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
    int index = 0;
    YangNode tempAugment;
    do {
        if (tempPath.getNodeIdentifier().getPrefix() == null) {
            tempAugment = resolveIntraFileAugment(tempPath, root);
        } else {
            tempAugment = resolveInterFileAugment(tempPath, root);
        }
        if (tempAugment != null) {
            linkerStack.push(tempNode);
            tempNode = tempAugment;
        }
        tempNode = searchTargetNode(tempNode, tempPath.getNodeIdentifier());
        if (tempNode == null && linkerStack.size() != 0) {
            tempNode = linkerStack.peek();
            linkerStack.pop();
            tempNode = searchTargetNode(tempNode, tempPath.getNodeIdentifier());
        }
        if (tempNode != null) {
            addToResolvedNodes(tempPath, tempNode);
        }
        if (index == getAbsPaths().size() - 1) {
            break;
        }
        tempPath = pathIterator.next();
        index++;
    } while (validate(tempNode, index));
    return tempNode;
}
#method_after
private YangNode parsePath(YangNode root) {
    YangNode tempNode = root;
    Stack<YangNode> linkerStack = new Stack<>();
    Iterator<YangAtomicPath> pathIterator = getAbsPaths().iterator();
    YangAtomicPath tempPath = pathIterator.next();
    setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
    int index = 0;
    YangNode tempAugment;
    do {
        if (tempPath.getNodeIdentifier().getPrefix() == null) {
            tempAugment = resolveIntraFileAugment(tempPath, root);
        } else {
            tempAugment = resolveInterFileAugment(tempPath, root);
        }
        if (tempAugment != null) {
            linkerStack.push(tempNode);
            tempNode = tempAugment;
        }
        tempNode = searchTargetNode(tempNode, tempPath.getNodeIdentifier());
        if (tempNode == null && linkerStack.size() != 0) {
            tempNode = linkerStack.peek();
            linkerStack.pop();
            tempNode = searchTargetNode(tempNode, tempPath.getNodeIdentifier());
        }
        if (tempNode != null) {
            addToResolvedNodes(tempPath, tempNode);
        }
        if (index == getAbsPaths().size() - 1) {
            break;
        }
        tempPath = pathIterator.next();
        index++;
    } while (validate(tempNode, index));
    return tempNode;
}
#end_block

#method_before
private YangNode resolveIntraFileAugment(YangAbsolutePath tempPath, YangNode root) {
    YangNode tempAugment;
    if (getCurPrefix() != tempPath.getNodeIdentifier().getPrefix()) {
        root = getIncludedNode(getRootNode(), tempPath.getNodeIdentifier().getName());
        if (root == null) {
            root = getIncludedNode(getRootNode(), getAugmentNodeIdentifier(tempPath.getNodeIdentifier(), absPaths, getRootNode()));
            if (root == null) {
                root = getRootNode();
            }
        }
    } else {
        if (getCurPrefix() != null) {
            root = getImportedNode(root, tempPath.getNodeIdentifier());
        }
    }
    setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
    tempAugment = getAugment(tempPath.getNodeIdentifier(), root, getAbsPaths());
    if (tempAugment == null) {
        tempAugment = getAugment(tempPath.getNodeIdentifier(), getRootNode(), getAbsPaths());
    }
    return tempAugment;
}
#method_after
private YangNode resolveIntraFileAugment(YangAtomicPath tempPath, YangNode root) {
    YangNode tempAugment;
    if (getCurPrefix() != tempPath.getNodeIdentifier().getPrefix()) {
        root = getIncludedNode(getRootNode(), tempPath.getNodeIdentifier().getName());
        if (root == null) {
            root = getIncludedNode(getRootNode(), getAugmentNodeIdentifier(tempPath.getNodeIdentifier(), absPaths, getRootNode()));
            if (root == null) {
                root = getRootNode();
            }
        }
    } else {
        if (getCurPrefix() != null) {
            root = getImportedNode(root, tempPath.getNodeIdentifier());
        }
    }
    setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
    tempAugment = getAugment(tempPath.getNodeIdentifier(), root, getAbsPaths());
    if (tempAugment == null) {
        tempAugment = getAugment(tempPath.getNodeIdentifier(), getRootNode(), getAbsPaths());
    }
    return tempAugment;
}
#end_block

#method_before
private YangNode resolveInterFileAugment(YangAbsolutePath tempPath, YangNode root) {
    YangNode tempAugment;
    if (!tempPath.getNodeIdentifier().getPrefix().equals(getCurPrefix())) {
        setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
        root = getImportedNode(getRootNode(), tempPath.getNodeIdentifier());
    }
    tempAugment = getAugment(tempPath.getNodeIdentifier(), root, getAbsPaths());
    if (tempAugment == null) {
        return resolveInterToInterFileAugment(root);
    }
    return tempAugment;
}
#method_after
private YangNode resolveInterFileAugment(YangAtomicPath tempPath, YangNode root) {
    YangNode tempAugment;
    if (!tempPath.getNodeIdentifier().getPrefix().equals(getCurPrefix())) {
        setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
        root = getImportedNode(getRootNode(), tempPath.getNodeIdentifier());
    }
    tempAugment = getAugment(tempPath.getNodeIdentifier(), root, getAbsPaths());
    if (tempAugment == null) {
        return resolveInterToInterFileAugment(root);
    }
    return tempAugment;
}
#end_block

#method_before
private YangNode resolveInterToInterFileAugment(YangNode root) {
    List<YangAugment> augments = getListOfYangAugment(root);
    int index;
    List<YangAbsolutePath> absPaths = new ArrayList<>();
    for (YangAugment augment : augments) {
        index = 0;
        for (YangAbsolutePath path : augment.getTargetNode()) {
            if (!searchForAugmentInImportedNode(path.getNodeIdentifier(), index)) {
                absPaths.clear();
                break;
            }
            absPaths.add(path);
            index++;
        }
        if (!absPaths.isEmpty() && absPaths.size() == getAbsPaths().size() - 1) {
            return augment;
        } else {
            absPaths.clear();
        }
    }
    return null;
}
#method_after
private YangNode resolveInterToInterFileAugment(YangNode root) {
    List<YangAugment> augments = getListOfYangAugment(root);
    int index;
    List<YangAtomicPath> absPaths = new ArrayList<>();
    for (YangAugment augment : augments) {
        index = 0;
        for (YangAtomicPath path : augment.getTargetNode()) {
            if (!searchForAugmentInImportedNode(path.getNodeIdentifier(), index)) {
                absPaths.clear();
                break;
            }
            absPaths.add(path);
            index++;
        }
        if (!absPaths.isEmpty() && absPaths.size() == getAbsPaths().size() - 1) {
            return augment;
        } else {
            absPaths.clear();
        }
    }
    return null;
}
#end_block

#method_before
private YangNode getAugment(YangNodeIdentifier tempNodeId, YangNode root, List<YangAbsolutePath> absPaths) {
    String augmentName = getAugmentNodeIdentifier(tempNodeId, absPaths, root);
    if (augmentName != null) {
        return searchAugmentNode(root, augmentName);
    }
    return null;
}
#method_after
private YangNode getAugment(YangNodeIdentifier tempNodeId, YangNode root, List<YangAtomicPath> absPaths) {
    String augmentName = getAugmentNodeIdentifier(tempNodeId, absPaths, root);
    if (augmentName != null) {
        return searchAugmentNode(root, augmentName);
    }
    return null;
}
#end_block

#method_before
private String getAugmentNodeIdentifier(YangNodeIdentifier nodeId, List<YangAbsolutePath> absPaths, YangNode root) {
    Iterator<YangAbsolutePath> nodeIdIterator = absPaths.iterator();
    YangAbsolutePath tempNodeId;
    StringBuilder builder = new StringBuilder();
    String id;
    PrefixResolverType type;
    while (nodeIdIterator.hasNext()) {
        tempNodeId = nodeIdIterator.next();
        if (!tempNodeId.getNodeIdentifier().equals(nodeId)) {
            type = getPrefixResolverTypes().get(tempNodeId);
            switch(type) {
                case INTER_TO_INTRA:
                    id = "/" + tempNodeId.getNodeIdentifier().getName();
                    break;
                case INTRA_TO_INTER:
                    if (!getRootsPrefix(root).equals(tempNodeId.getNodeIdentifier().getPrefix())) {
                        id = "/" + tempNodeId.getNodeIdentifier().getPrefix() + ":" + tempNodeId.getNodeIdentifier().getName();
                    } else {
                        id = "/" + tempNodeId.getNodeIdentifier().getName();
                    }
                    break;
                case INTER_TO_INTER:
                    id = "/" + tempNodeId.getNodeIdentifier().getPrefix() + ":" + tempNodeId.getNodeIdentifier().getName();
                    break;
                case NO_PREFIX_CHANGE_FOR_INTRA:
                    id = "/" + tempNodeId.getNodeIdentifier().getName();
                    break;
                case NO_PREFIX_CHANGE_FOR_INTER:
                    if (!getRootsPrefix(root).equals(tempNodeId.getNodeIdentifier().getPrefix())) {
                        id = "/" + tempNodeId.getNodeIdentifier().getPrefix() + ":" + tempNodeId.getNodeIdentifier().getName();
                    } else {
                        id = "/" + tempNodeId.getNodeIdentifier().getName();
                    }
                    break;
                default:
                    id = "/" + tempNodeId.getNodeIdentifier().getName();
                    break;
            }
            builder.append(id);
        } else {
            return builder.toString();
        }
    }
    return null;
}
#method_after
private String getAugmentNodeIdentifier(YangNodeIdentifier nodeId, List<YangAtomicPath> absPaths, YangNode root) {
    Iterator<YangAtomicPath> nodeIdIterator = absPaths.iterator();
    YangAtomicPath tempNodeId;
    StringBuilder builder = new StringBuilder();
    String id;
    PrefixResolverType type;
    while (nodeIdIterator.hasNext()) {
        tempNodeId = nodeIdIterator.next();
        if (!tempNodeId.getNodeIdentifier().equals(nodeId)) {
            type = getPrefixResolverTypes().get(tempNodeId);
            switch(type) {
                case INTER_TO_INTRA:
                    id = "/" + tempNodeId.getNodeIdentifier().getName();
                    break;
                case INTRA_TO_INTER:
                    if (!getRootsPrefix(root).equals(tempNodeId.getNodeIdentifier().getPrefix())) {
                        id = "/" + tempNodeId.getNodeIdentifier().getPrefix() + ":" + tempNodeId.getNodeIdentifier().getName();
                    } else {
                        id = "/" + tempNodeId.getNodeIdentifier().getName();
                    }
                    break;
                case INTER_TO_INTER:
                    id = "/" + tempNodeId.getNodeIdentifier().getPrefix() + ":" + tempNodeId.getNodeIdentifier().getName();
                    break;
                case NO_PREFIX_CHANGE_FOR_INTRA:
                    id = "/" + tempNodeId.getNodeIdentifier().getName();
                    break;
                case NO_PREFIX_CHANGE_FOR_INTER:
                    if (!getRootsPrefix(root).equals(tempNodeId.getNodeIdentifier().getPrefix())) {
                        id = "/" + tempNodeId.getNodeIdentifier().getPrefix() + ":" + tempNodeId.getNodeIdentifier().getName();
                    } else {
                        id = "/" + tempNodeId.getNodeIdentifier().getName();
                    }
                    break;
                default:
                    id = "/" + tempNodeId.getNodeIdentifier().getName();
                    break;
            }
            builder.append(id);
        } else {
            return builder.toString();
        }
    }
    return null;
}
#end_block

#method_before
private void parsePrefixResolverList(List<YangAbsolutePath> absolutePaths) {
    Iterator<YangAbsolutePath> pathIterator = absolutePaths.iterator();
    YangAbsolutePath absPath;
    String prePrefix;
    String curPrefix = null;
    while (pathIterator.hasNext()) {
        prePrefix = curPrefix;
        absPath = pathIterator.next();
        curPrefix = absPath.getNodeIdentifier().getPrefix();
        if (curPrefix != null) {
            if (!curPrefix.equals(prePrefix)) {
                if (prePrefix != null) {
                    addToPrefixResolverList(INTER_TO_INTER, absPath);
                } else {
                    addToPrefixResolverList(INTRA_TO_INTER, absPath);
                }
            } else {
                addToPrefixResolverList(NO_PREFIX_CHANGE_FOR_INTER, absPath);
            }
        } else {
            if (prePrefix != null) {
                addToPrefixResolverList(INTER_TO_INTRA, absPath);
            } else {
                addToPrefixResolverList(NO_PREFIX_CHANGE_FOR_INTRA, absPath);
            }
        }
    }
}
#method_after
private void parsePrefixResolverList(List<YangAtomicPath> absolutePaths) {
    Iterator<YangAtomicPath> pathIterator = absolutePaths.iterator();
    YangAtomicPath absPath;
    String prePrefix;
    String curPrefix = null;
    while (pathIterator.hasNext()) {
        prePrefix = curPrefix;
        absPath = pathIterator.next();
        curPrefix = absPath.getNodeIdentifier().getPrefix();
        if (curPrefix != null) {
            if (!curPrefix.equals(prePrefix)) {
                if (prePrefix != null) {
                    addToPrefixResolverList(INTER_TO_INTER, absPath);
                } else {
                    addToPrefixResolverList(INTRA_TO_INTER, absPath);
                }
            } else {
                addToPrefixResolverList(NO_PREFIX_CHANGE_FOR_INTER, absPath);
            }
        } else {
            if (prePrefix != null) {
                addToPrefixResolverList(INTER_TO_INTRA, absPath);
            } else {
                addToPrefixResolverList(NO_PREFIX_CHANGE_FOR_INTRA, absPath);
            }
        }
    }
}
#end_block

#method_before
public List<YangAbsolutePath> getTargetNode() {
    return targetNode;
}
#method_after
public List<YangAtomicPath> getTargetNode() {
    return targetNode;
}
#end_block

#method_before
public void setTargetNode(List<YangAbsolutePath> nodeIdentifiers) {
    targetNode = nodeIdentifiers;
}
#method_after
public void setTargetNode(List<YangAtomicPath> nodeIdentifiers) {
    targetNode = nodeIdentifiers;
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /*
             * For deleting the generated code in previous build.
             */
        deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        deleteDirectory(getDirectory(baseDir, outputDirectory));
        String searchDir = getDirectory(baseDir, yangFilesDir);
        String codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        String managerCodeGenDir = getDirectory(baseDir, managerFileDir) + SLASH;
        // Creates conflict resolver and set values to it.
        YangToJavaNamingConflictUtil conflictResolver = new YangToJavaNamingConflictUtil();
        conflictResolver.setReplacementForPeriod(replacementForPeriod);
        conflictResolver.setReplacementForHyphen(replacementForHyphen);
        conflictResolver.setReplacementForUnderscore(replacementForUnderscore);
        conflictResolver.setPrefixForIdentifier(prefixForIdentifier);
        YangPluginConfig yangPlugin = new YangPluginConfig();
        yangPlugin.setCodeGenDir(codeGenDir);
        yangPlugin.setManagerCodeGenDir(managerCodeGenDir);
        yangPlugin.setConflictResolver(conflictResolver);
        /*
             * Obtain the YANG files at a path mentioned in plugin and creates
             * YANG file information set.
             */
        createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
        // Check if there are any file to translate, if not return.
        if (getYangFileInfoSet() == null || getYangFileInfoSet().isEmpty()) {
            // No files to translate
            return;
        }
        // Resolve inter jar dependency.
        resolveInterJarDependency();
        // Carry out the parsing for all the YANG files.
        parseYangFileInfoSet();
        // Resolve dependencies using linker.
        resolveDependenciesUsingLinker();
        // Perform translation to JAVA.
        translateToJava(yangPlugin);
        // Serialize data model.
        serializeDataModel(getDirectory(baseDir, outputDirectory), getYangFileInfoSet(), project, true);
        addToCompilationRoot(codeGenDir, project, context);
        addToCompilationRoot(managerCodeGenDir, project, context);
        copyYangFilesToTarget(getYangFileInfoSet(), getDirectory(baseDir, outputDirectory), project);
    } catch (IOException | ParserException e) {
        String fileName = "";
        if (getCurYangFileInfo() != null) {
            fileName = getCurYangFileInfo().getYangFileName();
        }
        try {
            translatorErrorHandler(getRootNode());
            deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        throw new MojoExecutionException("Exception occured due to " + e.getLocalizedMessage() + " in " + fileName + " YANG file.");
    }
}
#method_after
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /*
             * For deleting the generated code in previous build.
             */
        deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        deleteDirectory(getDirectory(baseDir, outputDirectory));
        String searchDir = getDirectory(baseDir, yangFilesDir);
        String codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        String managerCodeGenDir = getDirectory(baseDir, managerFileDir) + SLASH;
        // Creates conflict resolver and set values to it.
        YangToJavaNamingConflictUtil conflictResolver = new YangToJavaNamingConflictUtil();
        conflictResolver.setReplacementForPeriod(replacementForPeriod);
        conflictResolver.setReplacementForHyphen(replacementForHyphen);
        conflictResolver.setReplacementForUnderscore(replacementForUnderscore);
        conflictResolver.setPrefixForIdentifier(prefixForIdentifier);
        YangPluginConfig yangPlugin = new YangPluginConfig();
        yangPlugin.setCodeGenDir(codeGenDir);
        yangPlugin.setManagerCodeGenDir(managerCodeGenDir);
        yangPlugin.setConflictResolver(conflictResolver);
        yangPlugin.setCodeGenerateForsbi(generateJavaFileForsbi.toLowerCase());
        /*
             * Obtain the YANG files at a path mentioned in plugin and creates
             * YANG file information set.
             */
        createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
        // Check if there are any file to translate, if not return.
        if (getYangFileInfoSet() == null || getYangFileInfoSet().isEmpty()) {
            // No files to translate
            return;
        }
        // Resolve inter jar dependency.
        resolveInterJarDependency();
        // Carry out the parsing for all the YANG files.
        parseYangFileInfoSet();
        // Resolve dependencies using linker.
        resolveDependenciesUsingLinker();
        // Perform translation to JAVA.
        translateToJava(yangPlugin);
        // Serialize data model.
        serializeDataModel(getDirectory(baseDir, outputDirectory), getYangFileInfoSet(), project, true);
        addToCompilationRoot(codeGenDir, project, context);
        addToCompilationRoot(managerCodeGenDir, project, context);
        copyYangFilesToTarget(getYangFileInfoSet(), getDirectory(baseDir, outputDirectory), project);
    } catch (IOException | ParserException e) {
        String fileName = "";
        if (getCurYangFileInfo() != null) {
            fileName = getCurYangFileInfo().getYangFileName();
        }
        try {
            translatorErrorHandler(getRootNode());
            deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        throw new MojoExecutionException("Exception occured due to " + e.getLocalizedMessage() + " in " + fileName + " YANG file.");
    }
}
#end_block

#method_before
@Override
public void generateCodeExit() throws TranslatorException {
    /**
     * As part of the notification support the following files needs to be generated.
     * 1) Subject of the notification(event), this is simple interface with builder class.
     * 2) Event class extending "AbstractEvent" and defining event type enum.
     * 3) Event listener interface extending "EventListener".
     * 4) Event subject class.
     *
     * The manager class needs to extend the "ListenerRegistry".
     */
    try {
        if ((getJavaFileInfo().getGeneratedFileTypes() & GENERATE_ALL_EVENT_CLASS_MASK) != 0) {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_ALL_EVENT_CLASS_MASK, this);
        }
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
        if (isManagerCodeGenRequired(this)) {
            if (isGenerationOfCodeReq(getJavaFileInfo())) {
                getTempJavaCodeFragmentFiles().getServiceTempFiles().setManagerNeedToBeGenerated(true);
            }
        }
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_SERVICE_AND_MANAGER, this);
        searchAndDeleteTempDir(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
        searchAndDeleteTempDir(getJavaFileInfo().getPluginConfig().getCodeGenDir() + getJavaFileInfo().getPackageFilePath());
    } catch (IOException e) {
        throw new TranslatorException("Failed to generate code for module node " + getName());
    }
}
#method_after
@Override
public void generateCodeExit() throws TranslatorException {
    /**
     * As part of the notification support the following files needs to be generated.
     * 1) Subject of the notification(event), this is simple interface with builder class.
     * 2) Event class extending "AbstractEvent" and defining event type enum.
     * 3) Event listener interface extending "EventListener".
     * 4) Event subject class.
     *
     * The manager class needs to extend the "ListenerRegistry".
     */
    try {
        if ((getJavaFileInfo().getGeneratedFileTypes() & GENERATE_ALL_EVENT_CLASS_MASK) != 0) {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_ALL_EVENT_CLASS_MASK, this);
        }
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
        if (isManagerCodeGenRequired(this)) {
            if (isGenerationOfCodeReq(getJavaFileInfo())) {
                if ((getJavaFileInfo().getPluginConfig().getCodeGenerateForsbi() == null) || (!getJavaFileInfo().getPluginConfig().getCodeGenerateForsbi().equals(SBI))) {
                    getTempJavaCodeFragmentFiles().getServiceTempFiles().setManagerNeedToBeGenerated(true);
                }
            }
        }
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_SERVICE_AND_MANAGER, this);
        searchAndDeleteTempDir(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
        searchAndDeleteTempDir(getJavaFileInfo().getPluginConfig().getCodeGenDir() + getJavaFileInfo().getPackageFilePath());
    } catch (IOException e) {
        throw new TranslatorException("Failed to generate code for module node " + getName());
    }
}
#end_block

#method_before
static List<YangAbsolutePath> getSetOfNodeIdentifiers(YangNode parent) {
    List<YangAbsolutePath> targets = new ArrayList<>();
    YangNodeIdentifier nodeId;
    List<YangAugment> augments = getListOfAugments(parent);
    for (YangAugment augment : augments) {
        nodeId = augment.getTargetNode().get(0).getNodeIdentifier();
        if (validateNodeIdentifierInSet(nodeId, targets)) {
            targets.add(augment.getTargetNode().get(0));
        }
    }
    return targets;
}
#method_after
static List<YangAtomicPath> getSetOfNodeIdentifiers(YangNode parent) {
    List<YangAtomicPath> targets = new ArrayList<>();
    YangNodeIdentifier nodeId;
    List<YangAugment> augments = getListOfAugments(parent);
    for (YangAugment augment : augments) {
        nodeId = augment.getTargetNode().get(0).getNodeIdentifier();
        if (validateNodeIdentifierInSet(nodeId, targets)) {
            targets.add(augment.getTargetNode().get(0));
        }
    }
    return targets;
}
#end_block

#method_before
private static boolean validateNodeIdentifierInSet(YangNodeIdentifier nodeId, List<YangAbsolutePath> targets) {
    boolean isPresent = true;
    for (YangAbsolutePath target : targets) {
        if (target.getNodeIdentifier().getName().equals(nodeId.getName())) {
            if (target.getNodeIdentifier().getPrefix() != null) {
                isPresent = !target.getNodeIdentifier().getPrefix().equals(nodeId.getPrefix());
            } else {
                isPresent = nodeId.getPrefix() != null;
            }
        }
    }
    return isPresent;
}
#method_after
private static boolean validateNodeIdentifierInSet(YangNodeIdentifier nodeId, List<YangAtomicPath> targets) {
    boolean isPresent = true;
    for (YangAtomicPath target : targets) {
        if (target.getNodeIdentifier().getName().equals(nodeId.getName())) {
            if (target.getNodeIdentifier().getPrefix() != null) {
                isPresent = !target.getNodeIdentifier().getPrefix().equals(nodeId.getPrefix());
            } else {
                isPresent = nodeId.getPrefix() != null;
            }
        }
    }
    return isPresent;
}
#end_block

#method_before
public static void addResolvedAugmentedDataNodeImports(YangNode parent) {
    List<YangAbsolutePath> targets = getSetOfNodeIdentifiers(parent);
    TempJavaCodeFragmentFiles tempJavaCodeFragmentFiles = ((JavaCodeGeneratorInfo) parent).getTempJavaCodeFragmentFiles();
    YangNode augmentedNode;
    JavaQualifiedTypeInfo javaQualifiedTypeInfo;
    String curNodeName;
    JavaFileInfo parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    for (YangAbsolutePath nodeId : targets) {
        augmentedNode = nodeId.getResolvedNode().getParent();
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), parentInfo.getPluginConfig().getConflictResolver()));
        }
        javaQualifiedTypeInfo = getQualifiedTypeInfoOfAugmentedNode(augmentedNode, getCapitalCase(curNodeName), parentInfo.getPluginConfig());
        tempJavaCodeFragmentFiles.getServiceTempFiles().getJavaImportData().addImportInfo(javaQualifiedTypeInfo, parentInfo.getJavaName(), parentInfo.getPackage());
    }
}
#method_after
public static void addResolvedAugmentedDataNodeImports(YangNode parent) {
    List<YangAtomicPath> targets = getSetOfNodeIdentifiers(parent);
    TempJavaCodeFragmentFiles tempJavaCodeFragmentFiles = ((JavaCodeGeneratorInfo) parent).getTempJavaCodeFragmentFiles();
    YangNode augmentedNode;
    JavaQualifiedTypeInfo javaQualifiedTypeInfo;
    String curNodeName;
    JavaFileInfo parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    for (YangAtomicPath nodeId : targets) {
        augmentedNode = nodeId.getResolvedNode().getParent();
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), parentInfo.getPluginConfig().getConflictResolver()));
        }
        javaQualifiedTypeInfo = getQualifiedTypeInfoOfAugmentedNode(augmentedNode, getCapitalCase(curNodeName), parentInfo.getPluginConfig());
        tempJavaCodeFragmentFiles.getServiceTempFiles().getJavaImportData().addImportInfo(javaQualifiedTypeInfo, parentInfo.getJavaName(), parentInfo.getPackage());
    }
}
#end_block

#method_before
@Override
public void generateCodeExit() throws TranslatorException {
    /**
     * As part of the notification support the following files needs to be generated.
     * 1) Subject of the notification(event), this is simple interface with builder class.
     * 2) Event class extending "AbstractEvent" and defining event type enum.
     * 3) Event listener interface extending "EventListener".
     * 4) Event subject class.
     *
     * The manager class needs to extend the "ListenerRegistry".
     */
    try {
        if ((getJavaFileInfo().getGeneratedFileTypes() & GENERATE_ALL_EVENT_CLASS_MASK) != 0) {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_ALL_EVENT_CLASS_MASK, this);
        }
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
        if (isManagerCodeGenRequired(this)) {
            if (isGenerationOfCodeReq(getJavaFileInfo())) {
                getTempJavaCodeFragmentFiles().getServiceTempFiles().setManagerNeedToBeGenerated(true);
            }
        }
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_SERVICE_AND_MANAGER, this);
        searchAndDeleteTempDir(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
        searchAndDeleteTempDir(getJavaFileInfo().getPluginConfig().getCodeGenDir() + getJavaFileInfo().getPackageFilePath());
    } catch (IOException e) {
        throw new TranslatorException("Failed to generate code for submodule node " + getName());
    }
}
#method_after
@Override
public void generateCodeExit() throws TranslatorException {
    /**
     * As part of the notification support the following files needs to be generated.
     * 1) Subject of the notification(event), this is simple interface with builder class.
     * 2) Event class extending "AbstractEvent" and defining event type enum.
     * 3) Event listener interface extending "EventListener".
     * 4) Event subject class.
     *
     * The manager class needs to extend the "ListenerRegistry".
     */
    try {
        if ((getJavaFileInfo().getGeneratedFileTypes() & GENERATE_ALL_EVENT_CLASS_MASK) != 0) {
            getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_ALL_EVENT_CLASS_MASK, this);
        }
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_INTERFACE_WITH_BUILDER, this);
        if (isManagerCodeGenRequired(this)) {
            if (isGenerationOfCodeReq(getJavaFileInfo())) {
                if ((getJavaFileInfo().getPluginConfig().getCodeGenerateForsbi() == null) || (!getJavaFileInfo().getPluginConfig().getCodeGenerateForsbi().equals(SBI))) {
                    getTempJavaCodeFragmentFiles().getServiceTempFiles().setManagerNeedToBeGenerated(true);
                }
            }
        }
        getTempJavaCodeFragmentFiles().generateJavaFile(GENERATE_SERVICE_AND_MANAGER, this);
        searchAndDeleteTempDir(getJavaFileInfo().getBaseCodeGenPath() + getJavaFileInfo().getPackageFilePath());
        searchAndDeleteTempDir(getJavaFileInfo().getPluginConfig().getCodeGenDir() + getJavaFileInfo().getPackageFilePath());
    } catch (IOException e) {
        throw new TranslatorException("Failed to generate code for submodule node " + getName());
    }
}
#end_block

#method_before
public void updateFilePriorityOfNode(YangNode yangNode) {
    int curNodePriority = yangNode.getPriority();
    if (yangNode instanceof YangReferenceResolver) {
        List<YangImport> yangImportList = ((YangReferenceResolver) yangNode).getImportList();
        Iterator<YangImport> importInfoIterator = yangImportList.iterator();
        // Run through the imported list to update priority.
        while (importInfoIterator.hasNext()) {
            YangImport yangImport = importInfoIterator.next();
            YangNode importedNode = yangImport.getImportedNode();
            if (curNodePriority >= importedNode.getPriority()) {
                importedNode.setPriority(curNodePriority + 1);
                updateFilePriorityOfNode(importedNode);
            }
        }
        List<YangInclude> yangIncludeList = ((YangReferenceResolver) yangNode).getIncludeList();
        Iterator<YangInclude> includeInfoIterator = yangIncludeList.iterator();
        // Run through the imported list to update priority.
        while (includeInfoIterator.hasNext()) {
            YangInclude yangInclude = includeInfoIterator.next();
            YangNode includedNode = yangInclude.getIncludedNode();
            if (curNodePriority >= includedNode.getPriority()) {
                includedNode.setPriority(curNodePriority + 1);
                updateFilePriorityOfNode(includedNode);
            }
        }
    }
}
#method_after
public void updateFilePriorityOfNode(YangNode yangNode) {
    int curNodePriority = yangNode.getPriority();
    if (yangNode instanceof YangReferenceResolver) {
        List<YangImport> yangImportList = ((YangReferenceResolver) yangNode).getImportList();
        if (yangImportList != null && !yangImportList.isEmpty()) {
            Iterator<YangImport> importInfoIterator = yangImportList.iterator();
            // Run through the imported list to update priority.
            while (importInfoIterator.hasNext()) {
                YangImport yangImport = importInfoIterator.next();
                YangNode importedNode = yangImport.getImportedNode();
                if (curNodePriority >= importedNode.getPriority()) {
                    importedNode.setPriority(curNodePriority + 1);
                    updateFilePriorityOfNode(importedNode);
                }
            }
        }
        List<YangInclude> yangIncludeList = ((YangReferenceResolver) yangNode).getIncludeList();
        if (yangIncludeList != null && !yangIncludeList.isEmpty()) {
            Iterator<YangInclude> includeInfoIterator = yangIncludeList.iterator();
            // Run through the imported list to update priority.
            while (includeInfoIterator.hasNext()) {
                YangInclude yangInclude = includeInfoIterator.next();
                YangNode includedNode = yangInclude.getIncludedNode();
                if (curNodePriority >= includedNode.getPriority()) {
                    includedNode.setPriority(curNodePriority + 1);
                    updateFilePriorityOfNode(includedNode);
                }
            }
        }
    }
}
#end_block

#method_before
@Test
public void processDecimal64TypeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/Decimal64TypeStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("decimal64"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(((YangDecimal64) leafInfo.getDataType().getDataTypeExtendedInfo()).getFractionDigit(), is(2));
}
#method_after
@Test
public void processDecimal64TypeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64TypeStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("decimal64"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(((YangDecimal64) leafInfo.getDataType().getDataTypeExtendedInfo()).getFractionDigit(), is(2));
}
#end_block

#method_before
@Test
public void processDecimal64TypeWithRangeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/Decimal64TypeWithRangeStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("decimal64"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(((YangDecimal64) leafInfo.getDataType().getDataTypeExtendedInfo()).getFractionDigit(), is(8));
    YangRangeRestriction rangeRestriction = ((YangDecimal64<YangRangeRestriction>) leafInfo.getDataType().getDataTypeExtendedInfo()).getRangeRestrictedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(-92233720368.54775808));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(92233720368.54775807));
}
#method_after
@Test
public void processDecimal64TypeWithRangeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64TypeWithRangeStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("decimal64"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(((YangDecimal64) leafInfo.getDataType().getDataTypeExtendedInfo()).getFractionDigit(), is(8));
    YangRangeRestriction rangeRestriction = ((YangDecimal64<YangRangeRestriction>) leafInfo.getDataType().getDataTypeExtendedInfo()).getRangeRestrictedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(-92233720368.54775808));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(92233720368.54775807));
}
#end_block

#method_before
@Test
public void processDecimal64ValueSuccessfulValidation() throws IOException, ParserException, DataModelException {
    YangNode node = manager.getDataModel("src/test/resources/Decimal64TypeValidation.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    YangDecimal64 decimal64 = (YangDecimal64) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafInfo.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("decimal64"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(decimal64.getFractionDigit(), is(18));
    decimal64.setValue(new BigDecimal(-9.223372036854775808));
    decimal64.validateValue();
    decimal64.setValue(new BigDecimal(9.223372036854775807));
    decimal64.validateValue();
}
#method_after
@Test
public void processDecimal64ValueSuccessfulValidation() throws IOException, ParserException, DataModelException {
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64TypeValidation.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    YangDecimal64 decimal64 = (YangDecimal64) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafInfo.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("decimal64"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(decimal64.getFractionDigit(), is(18));
    decimal64.setValue(new BigDecimal(-9.223372036854775808));
    decimal64.validateValue();
    decimal64.setValue(new BigDecimal(9.223372036854775807));
    decimal64.validateValue();
}
#end_block

#method_before
@Test
public void processDecimal64ValueFailureValidation() throws IOException, ParserException, DataModelException {
    thrown.expect(DataModelException.class);
    thrown.expectMessage("YANG file error : decimal64 validation failed.");
    YangNode node = manager.getDataModel("src/test/resources/Decimal64TypeValidation.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    YangDecimal64 decimal64 = (YangDecimal64) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafInfo.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("decimal64"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(decimal64.getFractionDigit(), is(18));
    decimal64.setValue(new BigDecimal(-92233720368547758.08));
    // validation should fail
    decimal64.validateValue();
}
#method_after
@Test
public void processDecimal64ValueFailureValidation() throws IOException, ParserException, DataModelException {
    thrown.expect(DataModelException.class);
    thrown.expectMessage("YANG file error : decimal64 validation failed.");
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64TypeValidation.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    YangDecimal64 decimal64 = (YangDecimal64) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafInfo.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("decimal64"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(decimal64.getFractionDigit(), is(18));
    decimal64.setValue(new BigDecimal(-92233720368547758.08));
    // validation should fail
    decimal64.validateValue();
}
#end_block

#method_before
@Test
public void processDecimal64InvalidMaxFraction() throws IOException, ParserException, DataModelException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : fraction-digits value should be between 1 and 18.");
    manager.getDataModel("src/test/resources/Decimal64TypeInvalidMaxValueFraction.yang");
}
#method_after
@Test
public void processDecimal64InvalidMaxFraction() throws IOException, ParserException, DataModelException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : fraction-digits value should be between 1 and 18.");
    manager.getDataModel("src/test/resources/decimal64/Decimal64TypeInvalidMaxValueFraction.yang");
}
#end_block

#method_before
@Test
public void processDecimal64InvalidMinFraction1() throws IOException, ParserException, DataModelException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : fraction-digits value should be between 1 and 18.");
    manager.getDataModel("src/test/resources/Decimal64TypeInvalidMinValueFraction1.yang");
}
#method_after
@Test
public void processDecimal64InvalidMinFraction1() throws IOException, ParserException, DataModelException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : fraction-digits value should be between 1 and 18.");
    manager.getDataModel("src/test/resources/decimal64/Decimal64TypeInvalidMinValueFraction1.yang");
}
#end_block

#method_before
@Test
public void processDecimal64InvalidMinFraction2() throws IOException, ParserException, DataModelException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : fraction-digits value should be between 1 and 18.");
    manager.getDataModel("src/test/resources/Decimal64TypeInvalidMinValueFraction2.yang");
}
#method_after
@Test
public void processDecimal64InvalidMinFraction2() throws IOException, ParserException, DataModelException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : fraction-digits value should be between 1 and 18.");
    manager.getDataModel("src/test/resources/decimal64/Decimal64TypeInvalidMinValueFraction2.yang");
}
#end_block

#method_before
@Test
public void processDecimal64TypeWithMultiValueRangeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/Decimal64TypeWithMultiValueRangeStmnt.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("decimal64"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(((YangDecimal64) leafInfo.getDataType().getDataTypeExtendedInfo()).getFractionDigit(), is(18));
    YangRangeRestriction rangeRestriction = ((YangDecimal64<YangRangeRestriction>) leafInfo.getDataType().getDataTypeExtendedInfo()).getRangeRestrictedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    // range "1 .. 3.14 | 10 | 20..max";
    // check first range 1 .. 3.14
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(-9.22));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(7.22));
    // check second range 10
    rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(8.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(8.0));
    // check third range 20..max
    rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(9.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(9.223372036854776));
}
#method_after
@Test
public void processDecimal64TypeWithMultiValueRangeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64TypeWithMultiValueRangeStmnt.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("decimal64"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(((YangDecimal64) leafInfo.getDataType().getDataTypeExtendedInfo()).getFractionDigit(), is(18));
    YangRangeRestriction rangeRestriction = ((YangDecimal64<YangRangeRestriction>) leafInfo.getDataType().getDataTypeExtendedInfo()).getRangeRestrictedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    // range "1 .. 3.14 | 10 | 20..max";
    // check first range 1 .. 3.14
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(-9.22));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(7.22));
    // check second range 10
    rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(8.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(8.0));
    // check third range 20..max
    rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(9.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(9.223372036854776));
}
#end_block

#method_before
@Test
public void processDecimal64InvalidRange() throws IOException, ParserException, DataModelException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : decimal64 validation failed.");
    manager.getDataModel("src/test/resources/Decimal64TypeInvalidRangeStmnt.yang");
}
#method_after
@Test
public void processDecimal64InvalidRange() throws IOException, ParserException, DataModelException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : decimal64 validation failed.");
    manager.getDataModel("src/test/resources/decimal64/Decimal64TypeInvalidRangeStmnt.yang");
}
#end_block

#method_before
@Test
public void processDecimal64WithoutFraction() throws IOException, ParserException, DataModelException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : a type decimal64 must have fraction-digits statement.");
    manager.getDataModel("src/test/resources/Decimal64TypeWithoutFraction.yang");
}
#method_after
@Test
public void processDecimal64WithoutFraction() throws IOException, ParserException, DataModelException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : a type decimal64 must have fraction-digits statement.");
    manager.getDataModel("src/test/resources/decimal64/Decimal64TypeWithoutFraction.yang");
}
#end_block

#method_before
@Test
public void processDecimal64TypedefStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/Decimal64TypedefStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("setFourDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("validDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    YangTypeDef typedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(typedef.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    YangType type = typedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) typedef.getTypeList().iterator().next();
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
}
#method_after
@Test
public void processDecimal64TypedefStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64TypedefStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("setFourDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("validDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    YangTypeDef typedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(typedef.getName(), is("validDecimal"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
    YangType type = typedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) typedef.getTypeList().iterator().next();
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
}
#end_block

#method_before
@Test
public void processDecimal64MultiTypedefStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/Decimal64MultiTypedefStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    // check leaf type
    assertThat(leafInfo.getName(), is("lowerDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("midDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    assertThat(derivedInfoType.getDataType(), is(YangDataTypes.DERIVED));
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    // check previous typedef
    YangTypeDef prevTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(prevTypedef.getName(), is("midDecimal"));
    YangType type = prevTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DERIVED));
    derivedInfo = (YangDerivedInfo) type.getDataTypeExtendedInfo();
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(topTypedef.getName(), is("topDecimal"));
    type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) type;
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
}
#method_after
@Test
public void processDecimal64MultiTypedefStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64MultiTypedefStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    // check leaf type
    assertThat(leafInfo.getName(), is("lowerDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("midDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    assertThat(derivedInfoType.getDataType(), is(YangDataTypes.DERIVED));
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    // check previous typedef
    YangTypeDef prevTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(prevTypedef.getName(), is("midDecimal"));
    YangType type = prevTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DERIVED));
    derivedInfo = (YangDerivedInfo) type.getDataTypeExtendedInfo();
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(topTypedef.getName(), is("topDecimal"));
    type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) type;
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
}
#end_block

#method_before
@Test
public void processDecimal64MultiTypedefRangeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/Decimal64MultiTypedefRangeStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    // check leaf type
    assertThat(leafInfo.getName(), is("lowerDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("midDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    assertThat(derivedInfoType.getDataType(), is(YangDataTypes.DERIVED));
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    // Check range restriction
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) derivedInfo.getResolvedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(1.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
    // check previous typedef
    YangTypeDef prevTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(prevTypedef.getName(), is("midDecimal"));
    YangType type = prevTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DERIVED));
    derivedInfo = (YangDerivedInfo) type.getDataTypeExtendedInfo();
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(topTypedef.getName(), is("topDecimal"));
    type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) type;
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
    // Check range restriction
    rangeRestriction = (YangRangeRestriction) decimal64.getRangeRestrictedExtendedInfo();
    rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(1.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
}
#method_after
@Test
public void processDecimal64MultiTypedefRangeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64MultiTypedefRangeStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    // check leaf type
    assertThat(leafInfo.getName(), is("lowerDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("midDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    assertThat(derivedInfoType.getDataType(), is(YangDataTypes.DERIVED));
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    // Check range restriction
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) derivedInfo.getResolvedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(1.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
    // check previous typedef
    YangTypeDef prevTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(prevTypedef.getName(), is("midDecimal"));
    YangType type = prevTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DERIVED));
    derivedInfo = (YangDerivedInfo) type.getDataTypeExtendedInfo();
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(topTypedef.getName(), is("topDecimal"));
    type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) type;
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
    // Check range restriction
    rangeRestriction = (YangRangeRestriction) decimal64.getRangeRestrictedExtendedInfo();
    rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(1.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
}
#end_block

#method_before
@Test
public void processDecimal64MultiTypedefRangeInLeafStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/Decimal64MultiTypedefRangeInLeafStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    // check leaf type
    assertThat(leafInfo.getName(), is("lowerDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("midDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    assertThat(derivedInfoType.getDataType(), is(YangDataTypes.DERIVED));
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    // Check range restriction
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) derivedInfo.getResolvedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(1.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
    // check previous typedef
    YangTypeDef prevTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(prevTypedef.getName(), is("midDecimal"));
    YangType type = prevTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DERIVED));
    derivedInfo = (YangDerivedInfo) type.getDataTypeExtendedInfo();
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(topTypedef.getName(), is("topDecimal"));
    type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) type;
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
}
#method_after
@Test
public void processDecimal64MultiTypedefRangeInLeafStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64MultiTypedefRangeInLeafStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    // check leaf type
    assertThat(leafInfo.getName(), is("lowerDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("midDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    assertThat(derivedInfoType.getDataType(), is(YangDataTypes.DERIVED));
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    // Check range restriction
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) derivedInfo.getResolvedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(1.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
    // check previous typedef
    YangTypeDef prevTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(prevTypedef.getName(), is("midDecimal"));
    YangType type = prevTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DERIVED));
    derivedInfo = (YangDerivedInfo) type.getDataTypeExtendedInfo();
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(topTypedef.getName(), is("topDecimal"));
    type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) type;
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
}
#end_block

#method_before
@Test
public void processDecimal64MultiTypedefMultipleRangeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/Decimal64MultiTypedefMultiRangeStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    // check leaf type
    assertThat(leafInfo.getName(), is("lowerDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("midDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    assertThat(derivedInfoType.getDataType(), is(YangDataTypes.DERIVED));
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    // Check range restriction
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) derivedInfo.getResolvedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(4.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(11.0));
    // check previous typedef
    YangTypeDef prevTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(prevTypedef.getName(), is("midDecimal"));
    YangType type = prevTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DERIVED));
    derivedInfo = (YangDerivedInfo) type.getDataTypeExtendedInfo();
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(topTypedef.getName(), is("topDecimal"));
    type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) type;
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
    // Check range restriction
    rangeRestriction = (YangRangeRestriction) decimal64.getRangeRestrictedExtendedInfo();
    rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(1.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
}
#method_after
@Test
public void processDecimal64MultiTypedefMultipleRangeStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64MultiTypedefMultiRangeStatement.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    // check leaf type
    assertThat(leafInfo.getName(), is("lowerDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("midDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    assertThat(derivedInfoType.getDataType(), is(YangDataTypes.DERIVED));
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    // Check range restriction
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) derivedInfo.getResolvedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(4.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(11.0));
    // check previous typedef
    YangTypeDef prevTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(prevTypedef.getName(), is("midDecimal"));
    YangType type = prevTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DERIVED));
    derivedInfo = (YangDerivedInfo) type.getDataTypeExtendedInfo();
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(topTypedef.getName(), is("topDecimal"));
    type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) type;
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
    // Check range restriction
    rangeRestriction = (YangRangeRestriction) decimal64.getRangeRestrictedExtendedInfo();
    rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(1.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
}
#end_block

#method_before
@Test
public void processDecimal64MultiTypedefMultiInvalidRangeStatement() throws IOException, LinkerException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage(" Range interval doesn't fall within the referred restriction ranges");
    manager.getDataModel("src/test/resources/Decimal64MultiTypedefMultiInvalidRangeStatement.yang");
}
#method_after
@Test
public void processDecimal64MultiTypedefMultiInvalidRangeStatement() throws IOException, LinkerException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage(" Range interval doesn't fall within the referred restriction ranges");
    manager.getDataModel("src/test/resources/decimal64/Decimal64MultiTypedefMultiInvalidRangeStatement.yang");
}
#end_block

#method_before
@Test
public void processDecimal64MultiTypedefWithMaxRange() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/Decimal64MultiTypedefWithMaxRange.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    // check leaf type
    assertThat(leafInfo.getName(), is("lowerDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("midDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    assertThat(derivedInfoType.getDataType(), is(YangDataTypes.DERIVED));
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    // Check range restriction
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) derivedInfo.getResolvedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(4.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
    // check previous typedef
    YangTypeDef prevTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(prevTypedef.getName(), is("midDecimal"));
    YangType type = prevTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DERIVED));
    derivedInfo = (YangDerivedInfo) type.getDataTypeExtendedInfo();
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(topTypedef.getName(), is("topDecimal"));
    type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) type;
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
    // Check range restriction
    rangeRestriction = (YangRangeRestriction) decimal64.getRangeRestrictedExtendedInfo();
    rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(1.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
}
#method_after
@Test
public void processDecimal64MultiTypedefWithMaxRange() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/decimal64/Decimal64MultiTypedefWithMaxRange.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    // check leaf type
    assertThat(leafInfo.getName(), is("lowerDecimal"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("midDecimal"));
    YangType<YangDerivedInfo> derivedInfoType = (YangType<YangDerivedInfo>) leafInfo.getDataType();
    assertThat(derivedInfoType.getDataType(), is(YangDataTypes.DERIVED));
    YangDerivedInfo derivedInfo = (YangDerivedInfo) derivedInfoType.getDataTypeExtendedInfo();
    // Check range restriction
    YangRangeRestriction rangeRestriction = (YangRangeRestriction) derivedInfo.getResolvedExtendedInfo();
    ListIterator<YangRangeInterval> rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    YangRangeInterval rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(4.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
    // check previous typedef
    YangTypeDef prevTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(prevTypedef.getName(), is("midDecimal"));
    YangType type = prevTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DERIVED));
    derivedInfo = (YangDerivedInfo) type.getDataTypeExtendedInfo();
    // check top typedef
    YangTypeDef topTypedef = (YangTypeDef) derivedInfo.getReferredTypeDef();
    assertThat(topTypedef.getName(), is("topDecimal"));
    type = topTypedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.DECIMAL64));
    assertThat(type.getDataTypeName(), is("decimal64"));
    YangType<YangDecimal64> decimal64Type = (YangType<YangDecimal64>) type;
    YangDecimal64 decimal64 = decimal64Type.getDataTypeExtendedInfo();
    assertThat(decimal64.getFractionDigit(), is(4));
    // Check range restriction
    rangeRestriction = (YangRangeRestriction) decimal64.getRangeRestrictedExtendedInfo();
    rangeListIterator = rangeRestriction.getAscendingRangeIntervals().listIterator();
    rangeInterval = rangeListIterator.next();
    assertThat(((YangDecimal64) rangeInterval.getStartValue()).getValue().doubleValue(), is(1.0));
    assertThat(((YangDecimal64) rangeInterval.getEndValue()).getValue().doubleValue(), is(12.0));
}
#end_block

#method_before
public static String getSetterForLeaf(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
        if (leaves != null) {
            for (YangLeaf leaf : leaves) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeaf(tempFragmentFiles, leaf, pluginConfig);
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                String attributeName = javaAttributeInfo.getAttributeName();
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#method_after
public static String getSetterForLeaf(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
        if (leaves != null && !leaves.isEmpty()) {
            for (YangLeaf leaf : leaves) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeaf(tempFragmentFiles, leaf, pluginConfig);
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                String attributeName = javaAttributeInfo.getAttributeName();
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#end_block

#method_before
public static String getSetterForLeafList(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        if (listOfLeafList != null) {
            numleaf = 1;
            for (YangLeafList leafList : listOfLeafList) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeafList(tempFragmentFiles, leafList, pluginConfig);
                String attributeName = javaAttributeInfo.getAttributeName();
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                if (javaAttributeInfo.isListAttr()) {
                    attrQuaifiedType = getListString() + attrQuaifiedType + DIAMOND_CLOSE_BRACKET;
                }
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF_LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#method_after
public static String getSetterForLeafList(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
            for (YangLeafList leafList : listOfLeafList) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeafList(tempFragmentFiles, leafList, pluginConfig);
                String attributeName = javaAttributeInfo.getAttributeName();
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                if (javaAttributeInfo.isListAttr()) {
                    attrQuaifiedType = getListString() + attrQuaifiedType + DIAMOND_CLOSE_BRACKET;
                }
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF_LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#end_block

#method_before
public static String getEnumsOfMethod(String className, JavaAttributeInfo attr, Map<String, Integer> enumMap, List<String> enumList, YangPluginConfig pluginConfig) {
    String attrType = getReturnType(attr);
    String attrName = attr.getAttributeName();
    String method = FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + getCapitalCase(className) + SPACE + OF + OPEN_PARENTHESIS + attrType + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + SWITCH + SPACE + OPEN_PARENTHESIS + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    int value = 0;
    for (String str : enumList) {
        value = enumMap.get(str);
        method = method + TWELVE_SPACE_INDENTATION + CASE + SPACE + value + COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + getCapitalCase(className) + PERIOD + str + SEMI_COLAN + NEW_LINE;
    }
    method = method + TWELVE_SPACE_INDENTATION + DEFAULT + SPACE + COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    return getJavaDoc(OF_METHOD, getCapitalCase(className) + " for type " + attrName, false, pluginConfig) + method;
}
#method_after
public static String getEnumsOfMethod(String className, JavaAttributeInfo attr, Map<String, Integer> enumMap, List<String> enumList, YangPluginConfig pluginConfig) {
    String attrType = getReturnType(attr);
    String attrName = attr.getAttributeName();
    String method = FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STATIC + SPACE + getCapitalCase(className) + SPACE + OF + OPEN_PARENTHESIS + attrType + SPACE + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + SWITCH + SPACE + OPEN_PARENTHESIS + VALUE + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    int value = 0;
    for (String str : enumList) {
        value = enumMap.get(str);
        method = method + TWELVE_SPACE_INDENTATION + CASE + SPACE + value + COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + getCapitalCase(className) + PERIOD + str + SEMI_COLAN + NEW_LINE;
    }
    method = method + TWELVE_SPACE_INDENTATION + DEFAULT + SPACE + COLON + NEW_LINE + SIXTEEN_SPACE_INDENTATION + RETURN + SPACE + NULL + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
    return getJavaDoc(OF_METHOD, getCapitalCase(className) + FOR_TYPE + attrName, false, pluginConfig) + method;
}
#end_block

#method_before
public static String getAugmentsDataMethodForService(YangNode parent) {
    Map<YangAbsolutePath, YangAugment> resolvedAugmentsForManager = getResolvedAugmentsForManager(parent);
    List<YangAbsolutePath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    String returnType;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAbsolutePath nodeId : targets) {
        augmentedNode = resolvedAugmentsForManager.get(nodeId).getResolveNodeInPath().get(nodeId);
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode.getParent(), pluginConfig);
        method = getJavaDoc(GETTER_METHOD, getSmallCase(AUGMENTED + parentName + curNodeName), false, pluginConfig) + getGetterForInterface(AUGMENTED + parentName + getCapitalCase(curNodeName), returnType, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getJavaDoc(MANAGER_SETTER_METHOD, AUGMENTED + getCapitalCase(parentName) + curNodeName, false, pluginConfig) + getSetterForInterface(getSmallCase(AUGMENTED) + parentName + getCapitalCase(curNodeName), returnType, parentName, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#method_after
public static String getAugmentsDataMethodForService(YangNode parent) {
    Map<YangAtomicPath, YangAugment> resolvedAugmentsForManager = getResolvedAugmentsForManager(parent);
    List<YangAtomicPath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    String returnType;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAtomicPath nodeId : targets) {
        augmentedNode = resolvedAugmentsForManager.get(nodeId).getResolveNodeInPath().get(nodeId);
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode.getParent(), pluginConfig);
        method = getJavaDoc(GETTER_METHOD, getSmallCase(AUGMENTED + parentName + curNodeName), false, pluginConfig) + getGetterForInterface(AUGMENTED + parentName + getCapitalCase(curNodeName), returnType, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getJavaDoc(MANAGER_SETTER_METHOD, AUGMENTED + getCapitalCase(parentName) + curNodeName, false, pluginConfig) + getSetterForInterface(getSmallCase(AUGMENTED) + parentName + getCapitalCase(curNodeName), returnType, parentName, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#end_block

#method_before
public static String getAugmentsDataMethodForManager(YangNode parent) {
    Map<YangAbsolutePath, YangAugment> resolvedAugmentsForManager = getResolvedAugmentsForManager(parent);
    List<YangAbsolutePath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String returnType;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAbsolutePath nodeId : targets) {
        augmentedNode = resolvedAugmentsForManager.get(nodeId).getResolveNodeInPath().get(nodeId);
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode.getParent(), pluginConfig);
        method = getOverRideString() + getGetter(returnType, AUGMENTED + parentName + getCapitalCase(curNodeName), GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getOverRideString() + getSetter(parentName, getSmallCase(AUGMENTED) + getCapitalCase(parentName) + getCapitalCase(curNodeName), returnType, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#method_after
public static String getAugmentsDataMethodForManager(YangNode parent) {
    Map<YangAtomicPath, YangAugment> resolvedAugmentsForManager = getResolvedAugmentsForManager(parent);
    List<YangAtomicPath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String returnType;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAtomicPath nodeId : targets) {
        augmentedNode = resolvedAugmentsForManager.get(nodeId).getResolveNodeInPath().get(nodeId);
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode.getParent(), pluginConfig);
        method = getOverRideString() + getGetter(returnType, AUGMENTED + parentName + getCapitalCase(curNodeName), GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getOverRideString() + getSetter(parentName, getSmallCase(AUGMENTED) + getCapitalCase(parentName) + getCapitalCase(curNodeName), returnType, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#end_block

#method_before
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    if (type.getDataType().equals(YangDataTypes.BINARY)) {
        imports.add(IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_IMPORT_BASE64_CLASS);
    }
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig));
    try {
        /**
         * Type constructor.
         */
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Of method.
         */
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        /**
         * To string method.
         */
        if (type.getDataType().equals(YangDataTypes.BINARY)) {
            JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("binary"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "binary", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = MethodsGenerator.getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(YangDataTypes.BITS)) {
            JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase("bits"));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, "bits", null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = MethodsGenerator.getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGeninfo = (JavaCodeGeneratorInfo) curNode;
        /**
         * From string method.
         */
        methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGeninfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateTypeDefClassFile(File file, YangNode curNode, List<String> imports) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    // import
    String className = getCapitalCase(javaFileInfo.getJavaName());
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    YangTypeDef typeDef = (YangTypeDef) curNode;
    List<YangType<?>> types = typeDef.getTypeList();
    YangType type = types.get(0);
    if (type.getDataType().equals(YangDataTypes.BINARY)) {
        imports.add(IMPORT + JAVA_UTIL_OBJECTS_IMPORT_PKG + PERIOD + JAVA_UTIL_IMPORT_BASE64_CLASS);
    }
    initiateJavaFileGeneration(file, className, GENERATE_TYPEDEF_CLASS, imports, path, pluginConfig);
    List<String> methods = new ArrayList<>();
    /**
     * Add attribute strings.
     */
    try {
        insertDataIntoJavaFile(file, NEW_LINE + FOUR_SPACE_INDENTATION + getDataFromTempFileHandle(ATTRIBUTES_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    /**
     * Default constructor.
     */
    methods.add(((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().addDefaultConstructor(PRIVATE, EMPTY_STRING, pluginConfig));
    try {
        /**
         * Type constructor.
         */
        methods.add(getDataFromTempFileHandle(CONSTRUCTOR_FOR_TYPE_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Of method.
         */
        methods.add(getDataFromTempFileHandle(OF_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Getter method.
         */
        methods.add(getDataFromTempFileHandle(GETTER_FOR_CLASS_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path));
        /**
         * Hash code method.
         */
        methods.add(getHashCodeMethodClose(getHashCodeMethodOpen() + getDataFromTempFileHandle(HASH_CODE_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path).replace(NEW_LINE, EMPTY_STRING)));
        /**
         * Equals method.
         */
        methods.add(getEqualsMethodClose(getEqualsMethodOpen(className + EMPTY_STRING) + getDataFromTempFileHandle(EQUALS_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path)));
        /**
         * To string method.
         */
        if (type.getDataType().equals(YangDataTypes.BINARY)) {
            JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase(BINARY_STRING));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, BINARY_STRING, null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = MethodsGenerator.getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + BASE64 + PERIOD + GET_ENCODER + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + ENCODE_TO_STRING + OPEN_PARENTHESIS + attributeName + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else if (type.getDataType().equals(YangDataTypes.BITS)) {
            JavaQualifiedTypeInfo qualifiedTypeInfo = getQualifiedTypeInfoOfCurNode(curNode, getCapitalCase(BITS_STRING));
            JavaAttributeInfo attr = getAttributeInfoForTheData(qualifiedTypeInfo, BITS_STRING, null, false, false);
            String attributeName = attr.getAttributeName();
            String bitsToStringMethod = MethodsGenerator.getOverRideString() + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + STRING_DATA_TYPE + SPACE + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + attributeName + PERIOD + TO + STRING_DATA_TYPE + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET + NEW_LINE;
            methods.add(bitsToStringMethod);
        } else {
            methods.add(getToStringMethodOpen() + getDataFromTempFileHandle(TO_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getToStringMethodClose());
        }
        JavaCodeGeneratorInfo javaGeninfo = (JavaCodeGeneratorInfo) curNode;
        /**
         * From string method.
         */
        methods.add(getFromStringMethodSignature(className, pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, javaGeninfo.getTempJavaCodeFragmentFiles().getTypeTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + className + " while type def class file generation");
    }
    for (String method : methods) {
        insertDataIntoJavaFile(file, method);
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static Map<YangAbsolutePath, YangAugment> getResolvedAugmentsForManager(YangNode parent) {
    Map<YangAbsolutePath, YangAugment> resolvedAugmentsForManager = new HashMap<>();
    YangNodeIdentifier nodeId;
    List<YangAbsolutePath> targets = new ArrayList<>();
    for (YangAugment augment : getListOfAugments(parent)) {
        nodeId = augment.getTargetNode().get(0).getNodeIdentifier();
        if (validateNodeIdentifierInSet(nodeId, targets)) {
            targets.add(augment.getTargetNode().get(0));
            resolvedAugmentsForManager.put(augment.getTargetNode().get(0), augment);
        }
    }
    return resolvedAugmentsForManager;
}
#method_after
public static Map<YangAtomicPath, YangAugment> getResolvedAugmentsForManager(YangNode parent) {
    Map<YangAtomicPath, YangAugment> resolvedAugmentsForManager = new HashMap<>();
    YangNodeIdentifier nodeId;
    List<YangAtomicPath> targets = new ArrayList<>();
    for (YangAugment augment : getListOfAugments(parent)) {
        nodeId = augment.getTargetNode().get(0).getNodeIdentifier();
        if (validateNodeIdentifierInSet(nodeId, targets)) {
            targets.add(augment.getTargetNode().get(0));
            resolvedAugmentsForManager.put(augment.getTargetNode().get(0), augment);
        }
    }
    return resolvedAugmentsForManager;
}
#end_block

#method_before
public static List<YangAbsolutePath> getSetOfNodeIdentifiers(YangNode parent) {
    List<YangAbsolutePath> targets = new ArrayList<>();
    YangNodeIdentifier nodeId;
    List<YangAugment> augments = getListOfAugments(parent);
    for (YangAugment augment : augments) {
        nodeId = augment.getTargetNode().get(0).getNodeIdentifier();
        if (validateNodeIdentifierInSet(nodeId, targets)) {
            targets.add(augment.getTargetNode().get(0));
        }
    }
    return targets;
}
#method_after
public static List<YangAtomicPath> getSetOfNodeIdentifiers(YangNode parent) {
    List<YangAtomicPath> targets = new ArrayList<>();
    YangNodeIdentifier nodeId;
    List<YangAugment> augments = getListOfAugments(parent);
    for (YangAugment augment : augments) {
        nodeId = augment.getTargetNode().get(0).getNodeIdentifier();
        if (validateNodeIdentifierInSet(nodeId, targets)) {
            targets.add(augment.getTargetNode().get(0));
        }
    }
    return targets;
}
#end_block

#method_before
private static boolean validateNodeIdentifierInSet(YangNodeIdentifier nodeId, List<YangAbsolutePath> targets) {
    boolean isPresent = true;
    for (YangAbsolutePath target : targets) {
        if (target.getNodeIdentifier().getName().equals(nodeId.getName())) {
            if (target.getNodeIdentifier().getPrefix() != null) {
                isPresent = !target.getNodeIdentifier().getPrefix().equals(nodeId.getPrefix());
            } else {
                isPresent = nodeId.getPrefix() != null;
            }
        }
    }
    return isPresent;
}
#method_after
private static boolean validateNodeIdentifierInSet(YangNodeIdentifier nodeId, List<YangAtomicPath> targets) {
    boolean isPresent = true;
    for (YangAtomicPath target : targets) {
        if (target.getNodeIdentifier().getName().equals(nodeId.getName())) {
            if (target.getNodeIdentifier().getPrefix() != null) {
                isPresent = !target.getNodeIdentifier().getPrefix().equals(nodeId.getPrefix());
            } else {
                isPresent = nodeId.getPrefix() != null;
            }
        }
    }
    return isPresent;
}
#end_block

#method_before
public static void addResolvedAugmentedDataNodeImports(YangNode parent) {
    Map<YangAbsolutePath, YangAugment> resolvedAugmentsForManager = getResolvedAugmentsForManager(parent);
    List<YangAbsolutePath> targets = getSetOfNodeIdentifiers(parent);
    TempJavaCodeFragmentFiles tempJavaCodeFragmentFiles = ((JavaCodeGeneratorInfo) parent).getTempJavaCodeFragmentFiles();
    YangNode augmentedNode;
    JavaQualifiedTypeInfo javaQualifiedTypeInfo;
    String curNodeName;
    JavaFileInfo parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    for (YangAbsolutePath nodeId : targets) {
        augmentedNode = resolvedAugmentsForManager.get(nodeId).getResolveNodeInPath().get(nodeId);
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), parentInfo.getPluginConfig().getConflictResolver()));
        }
        javaQualifiedTypeInfo = getQualifiedTypeInfoOfAugmentedNode(augmentedNode, getCapitalCase(curNodeName), parentInfo.getPluginConfig());
        tempJavaCodeFragmentFiles.getServiceTempFiles().getJavaImportData().addImportInfo(javaQualifiedTypeInfo, parentInfo.getJavaName(), parentInfo.getPackage());
    }
}
#method_after
public static void addResolvedAugmentedDataNodeImports(YangNode parent) {
    Map<YangAtomicPath, YangAugment> resolvedAugmentsForManager = getResolvedAugmentsForManager(parent);
    List<YangAtomicPath> targets = getSetOfNodeIdentifiers(parent);
    TempJavaCodeFragmentFiles tempJavaCodeFragmentFiles = ((JavaCodeGeneratorInfo) parent).getTempJavaCodeFragmentFiles();
    YangNode augmentedNode;
    JavaQualifiedTypeInfo javaQualifiedTypeInfo;
    String curNodeName;
    JavaFileInfo parentInfo = ((JavaFileInfoContainer) parent).getJavaFileInfo();
    for (YangAtomicPath nodeId : targets) {
        augmentedNode = resolvedAugmentsForManager.get(nodeId).getResolveNodeInPath().get(nodeId);
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), parentInfo.getPluginConfig().getConflictResolver()));
        }
        javaQualifiedTypeInfo = getQualifiedTypeInfoOfAugmentedNode(augmentedNode, getCapitalCase(curNodeName), parentInfo.getPluginConfig());
        tempJavaCodeFragmentFiles.getServiceTempFiles().getJavaImportData().addImportInfo(javaQualifiedTypeInfo, parentInfo.getJavaName(), parentInfo.getPackage());
    }
}
#end_block

#method_before
public static String getSetterForLeaf(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        if (leaves != null) {
            for (YangLeaf leaf : leaves) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeaf(tempFragmentFiles, leaf, pluginConfig);
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                String attributeName = javaAttributeInfo.getAttributeName();
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#method_after
public static String getSetterForLeaf(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeaf> leaves = leavesHolder.getListOfLeaf();
        if (leaves != null && !leaves.isEmpty()) {
            for (YangLeaf leaf : leaves) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeaf(tempFragmentFiles, leaf, pluginConfig);
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                String attributeName = javaAttributeInfo.getAttributeName();
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#end_block

#method_before
public static String getSetterForLeafList(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        if (listOfLeafList != null) {
            numleaf = 1;
            for (YangLeafList leafList : listOfLeafList) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeafList(tempFragmentFiles, leafList, pluginConfig);
                String attributeName = javaAttributeInfo.getAttributeName();
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                if (javaAttributeInfo.isListAttr()) {
                    attrQuaifiedType = getListString() + attrQuaifiedType + DIAMOND_CLOSE_BRACKET;
                }
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF_LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#method_after
public static String getSetterForLeafList(String className, YangNode curnode, YangPluginConfig pluginConfig) {
    int numleaf = 1;
    String filterMethod = "";
    TempJavaBeanFragmentFiles tempFragmentFiles = ((JavaCodeGeneratorInfo) curnode).getTempJavaCodeFragmentFiles().getBeanTempFiles();
    if (curnode instanceof YangLeavesHolder) {
        YangLeavesHolder leavesHolder = (YangLeavesHolder) curnode;
        List<YangLeafList> listOfLeafList = leavesHolder.getListOfLeafList();
        if (listOfLeafList != null && !listOfLeafList.isEmpty()) {
            for (YangLeafList leafList : listOfLeafList) {
                JavaAttributeInfo javaAttributeInfo = getJavaAttributeOfLeafList(tempFragmentFiles, leafList, pluginConfig);
                String attributeName = javaAttributeInfo.getAttributeName();
                String attrQuaifiedType = getReturnType(javaAttributeInfo);
                if (javaAttributeInfo.isListAttr()) {
                    attrQuaifiedType = getListString() + attrQuaifiedType + DIAMOND_CLOSE_BRACKET;
                }
                filterMethod = filterMethod + NEW_LINE + FOUR_SPACE_INDENTATION + OVERRIDE + NEW_LINE + FOUR_SPACE_INDENTATION + PUBLIC + SPACE + className + BUILDER + SPACE + attributeName + OPEN_PARENTHESIS + attrQuaifiedType + SPACE + RECEIVED_OBJECT + attributeName + CLOSE_PARENTHESIS + SPACE + OPEN_CURLY_BRACKET + NEW_LINE + EIGHT_SPACE_INDENTATION + attributeName + SPACE + EQUAL + SPACE + RECEIVED_OBJECT + attributeName + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + GET_FILTER_LEAF_LIST + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + PERIOD + SET_METHOD_PREFIX + OPEN_PARENTHESIS + String.valueOf(numleaf) + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE + EIGHT_SPACE_INDENTATION + RETURN + SPACE + THIS + SEMI_COLAN + NEW_LINE + FOUR_SPACE_INDENTATION + CLOSE_CURLY_BRACKET;
                numleaf++;
            }
        }
    }
    return filterMethod;
}
#end_block

#method_before
public static String getAugmentsDataMethodForService(YangNode parent) {
    Map<YangAbsolutePath, YangAugment> resolvedAugmentsForManager = getResolvedAugmentsForManager(parent);
    List<YangAbsolutePath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    String returnType;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAbsolutePath nodeId : targets) {
        augmentedNode = resolvedAugmentsForManager.get(nodeId).getResolveNodeInPath().get(nodeId);
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode.getParent(), pluginConfig);
        method = getJavaDoc(GETTER_METHOD, getSmallCase(AUGMENTED + parentName + curNodeName), false, pluginConfig) + getGetterForInterface(AUGMENTED + parentName + getCapitalCase(curNodeName), returnType, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getJavaDoc(MANAGER_SETTER_METHOD, AUGMENTED + getCapitalCase(parentName) + curNodeName, false, pluginConfig) + getSetterForInterface(getSmallCase(AUGMENTED) + parentName + getCapitalCase(curNodeName), returnType, parentName, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#method_after
public static String getAugmentsDataMethodForService(YangNode parent) {
    Map<YangAtomicPath, YangAugment> resolvedAugmentsForManager = getResolvedAugmentsForManager(parent);
    List<YangAtomicPath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    String returnType;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAtomicPath nodeId : targets) {
        augmentedNode = resolvedAugmentsForManager.get(nodeId).getResolveNodeInPath().get(nodeId);
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode.getParent(), pluginConfig);
        method = getJavaDoc(GETTER_METHOD, getSmallCase(AUGMENTED + parentName + curNodeName), false, pluginConfig) + getGetterForInterface(AUGMENTED + parentName + getCapitalCase(curNodeName), returnType, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getJavaDoc(MANAGER_SETTER_METHOD, AUGMENTED + getCapitalCase(parentName) + curNodeName, false, pluginConfig) + getSetterForInterface(getSmallCase(AUGMENTED) + parentName + getCapitalCase(curNodeName), returnType, parentName, false, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#end_block

#method_before
public static String getAugmentsDataMethodForManager(YangNode parent) {
    Map<YangAbsolutePath, YangAugment> resolvedAugmentsForManager = getResolvedAugmentsForManager(parent);
    List<YangAbsolutePath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String returnType;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAbsolutePath nodeId : targets) {
        augmentedNode = resolvedAugmentsForManager.get(nodeId).getResolveNodeInPath().get(nodeId);
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode.getParent(), pluginConfig);
        method = getOverRideString() + getGetter(returnType, AUGMENTED + parentName + getCapitalCase(curNodeName), GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getOverRideString() + getSetter(parentName, getSmallCase(AUGMENTED) + getCapitalCase(parentName) + getCapitalCase(curNodeName), returnType, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#method_after
public static String getAugmentsDataMethodForManager(YangNode parent) {
    Map<YangAtomicPath, YangAugment> resolvedAugmentsForManager = getResolvedAugmentsForManager(parent);
    List<YangAtomicPath> targets = getSetOfNodeIdentifiers(parent);
    YangNode augmentedNode;
    String curNodeName;
    String returnType;
    String method;
    StringBuilder methods = new StringBuilder();
    String parentName;
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) parent).getJavaFileInfo().getPluginConfig();
    for (YangAtomicPath nodeId : targets) {
        augmentedNode = resolvedAugmentsForManager.get(nodeId).getResolveNodeInPath().get(nodeId);
        if (((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName() != null) {
            curNodeName = ((JavaFileInfoContainer) augmentedNode).getJavaFileInfo().getJavaName();
        } else {
            curNodeName = getCapitalCase(getCamelCase(augmentedNode.getName(), pluginConfig.getConflictResolver()));
        }
        returnType = getAugmentedClassNameForDataMethods(augmentedNode, parent);
        parentName = getParentNodeNameForDataMethods(augmentedNode.getParent(), pluginConfig);
        method = getOverRideString() + getGetter(returnType, AUGMENTED + parentName + getCapitalCase(curNodeName), GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
        method = getOverRideString() + getSetter(parentName, getSmallCase(AUGMENTED) + getCapitalCase(parentName) + getCapitalCase(curNodeName), returnType, GENERATE_SERVICE_AND_MANAGER) + NEW_LINE;
        methods.append(method);
    }
    return methods.toString();
}
#end_block

#method_before
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        addResolvedAugmentedDataNodeImports(curNode);
    }
    List<String> imports = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaImportData().getImports();
    JavaFileInfo curInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    createPackage(curNode);
    /*
         * Generate java code.
         */
    if ((fileType & INTERFACE_MASK) != 0 || (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /*
             * Create interface file.
             */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent()));
        /*
             * Create builder interface file.
             */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent()));
            /*
                 * Append builder interface file to interface file and close it.
                 */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
            validateLineLength(getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (curNode instanceof YangCase) {
            removeCaseImport(imports);
        }
        if (curNode instanceof YangJavaAugment) {
            updateAugmentConstructorTempFile(curNode, curInfo.getPluginConfig());
            YangJavaAugment augment = (YangJavaAugment) curNode;
            List<JavaQualifiedTypeInfo> infoList = augment.getExtendedClassInfo();
            for (JavaQualifiedTypeInfo info : infoList) {
                if (info.getClassInfo().equals(getCapitalCase(getCamelCase(augment.getAugmentedNode().getName(), null)))) {
                    removeAugmentedImport(imports, info);
                }
            }
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 || (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent()) {
            addImportsToStringAndHasCodeMethods(imports, true);
        }
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports);
        }
        sortImports(imports);
        /*
             * Create impl class file.
             */
        setImplClassJavaFileHandle(getJavaFileHandle(getImplClassName()));
        setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent(), imports));
        /*
             * Create builder class file.
             */
        if ((fileType & BUILDER_CLASS_MASK) != 0) {
            setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
            setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), curNode, isAttributePresent()));
            /*
                 * Append impl class to builder class and close it.
                 */
            mergeJavaFiles(getBuilderClassJavaFileHandle(), getImplClassJavaFileHandle());
            validateLineLength(getImplClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getImplClassJavaFileHandle(), getJavaClassDefClose());
        if (!(curNode instanceof YangModule)) {
            if (isAttributePresent()) {
                addImportsToStringAndHasCodeMethods(imports, false);
            }
            addBitsetImport(imports, true);
            /*
             * Create impl class file.
             */
            setOpParamClassJavaFileHandle(getJavaFileHandle(getOpParamImplClassName()));
            setOpParamClassJavaFileHandle(generateOpParamImplClassFile(getOpParamClassJavaFileHandle(), curNode, isAttributePresent(), imports));
            /*
             * Create builder class file.
             */
            if ((fileType & BUILDER_CLASS_MASK) != 0) {
                setBuilderOpParmClassJavaFileHandle(getJavaFileHandle(getOpParamBuilderImplClassName()));
                setBuilderOpParmClassJavaFileHandle(generateOpParamBuilderClassFile(getBuilderOpParmClassJavaFileHandle(), curNode, isAttributePresent()));
                /*
                 * Append impl class to builder class and close it.
                 */
                mergeJavaFiles(getBuilderOpParmClassJavaFileHandle(), getOpParamClassJavaFileHandle());
                validateLineLength(getOpParamClassJavaFileHandle());
                addBitsetImport(imports, false);
            }
            insertDataIntoJavaFile(getOpParamClassJavaFileHandle(), getJavaClassDefClose());
        }
    }
    /*
         * Close all the file handles.
         */
    freeTemporaryResources(false);
}
#method_after
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    if (curNode instanceof YangModule || curNode instanceof YangSubModule) {
        addResolvedAugmentedDataNodeImports(curNode);
    }
    List<String> imports = ((JavaCodeGeneratorInfo) curNode).getTempJavaCodeFragmentFiles().getBeanTempFiles().getJavaImportData().getImports();
    JavaFileInfo curInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    createPackage(curNode);
    /*
         * Generate java code.
         */
    if ((fileType & INTERFACE_MASK) != 0 || (fileType & BUILDER_INTERFACE_MASK) != 0) {
        /*
             * Create interface file.
             */
        setInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(INTERFACE_FILE_NAME_SUFFIX)));
        setInterfaceJavaFileHandle(generateInterfaceFile(getInterfaceJavaFileHandle(), imports, curNode, isAttributePresent()));
        /*
             * Create builder interface file.
             */
        if ((fileType & BUILDER_INTERFACE_MASK) != 0) {
            setBuilderInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_INTERFACE_FILE_NAME_SUFFIX)));
            setBuilderInterfaceJavaFileHandle(generateBuilderInterfaceFile(getBuilderInterfaceJavaFileHandle(), curNode, isAttributePresent()));
            /*
                 * Append builder interface file to interface file and close it.
                 */
            mergeJavaFiles(getBuilderInterfaceJavaFileHandle(), getInterfaceJavaFileHandle());
            validateLineLength(getInterfaceJavaFileHandle());
        }
        insertDataIntoJavaFile(getInterfaceJavaFileHandle(), getJavaClassDefClose());
        if (curNode instanceof YangCase) {
            removeCaseImport(imports);
        }
        if (curNode instanceof YangJavaAugment) {
            updateAugmentConstructorTempFile(curNode, curInfo.getPluginConfig());
            YangJavaAugment augment = (YangJavaAugment) curNode;
            List<JavaQualifiedTypeInfo> infoList = augment.getExtendedClassInfo();
            for (JavaQualifiedTypeInfo info : infoList) {
                if (info.getClassInfo().equals(getCapitalCase(getCamelCase(augment.getAugmentedNode().getName(), null)))) {
                    removeAugmentedImport(imports, info);
                }
            }
        }
    }
    if ((fileType & BUILDER_CLASS_MASK) != 0 || (fileType & IMPL_CLASS_MASK) != 0) {
        if (isAttributePresent()) {
            addImportsToStringAndHasCodeMethods(imports, true);
        }
        if (curNode instanceof YangAugmentableNode) {
            addImportsForAugmentableClass(imports);
        }
        sortImports(imports);
        /*
             * Create impl class file.
             */
        setImplClassJavaFileHandle(getJavaFileHandle(getImplClassName()));
        setImplClassJavaFileHandle(generateImplClassFile(getImplClassJavaFileHandle(), curNode, isAttributePresent(), imports));
        /*
             * Create builder class file.
             */
        if ((fileType & BUILDER_CLASS_MASK) != 0) {
            setBuilderClassJavaFileHandle(getJavaFileHandle(getJavaClassName(BUILDER_CLASS_FILE_NAME_SUFFIX)));
            setBuilderClassJavaFileHandle(generateBuilderClassFile(getBuilderClassJavaFileHandle(), curNode, isAttributePresent()));
            /*
                 * Append impl class to builder class and close it.
                 */
            mergeJavaFiles(getBuilderClassJavaFileHandle(), getImplClassJavaFileHandle());
            validateLineLength(getImplClassJavaFileHandle());
        }
        insertDataIntoJavaFile(getImplClassJavaFileHandle(), getJavaClassDefClose());
        if (!(curNode instanceof YangModule)) {
            if (isAttributePresent()) {
                addImportsToStringAndHasCodeMethods(imports, false);
            }
            addBitsetImport(imports, true);
            /*
                 * Create impl class file.
                 */
            setOpParamClassJavaFileHandle(getJavaFileHandle(getOpParamImplClassName()));
            setOpParamClassJavaFileHandle(generateOpParamImplClassFile(getOpParamClassJavaFileHandle(), curNode, isAttributePresent(), imports));
            /*
                 * Create builder class file.
                 */
            if ((fileType & BUILDER_CLASS_MASK) != 0) {
                setBuilderOpParmClassJavaFileHandle(getJavaFileHandle(getOpParamBuilderImplClassName()));
                setBuilderOpParmClassJavaFileHandle(generateOpParamBuilderClassFile(getBuilderOpParmClassJavaFileHandle(), curNode, isAttributePresent()));
                /*
                     * Append impl class to builder class and close it.
                     */
                mergeJavaFiles(getBuilderOpParmClassJavaFileHandle(), getOpParamClassJavaFileHandle());
                validateLineLength(getOpParamClassJavaFileHandle());
                addBitsetImport(imports, false);
            }
            insertDataIntoJavaFile(getOpParamClassJavaFileHandle(), getJavaClassDefClose());
        }
    }
    /*
         * Close all the file handles.
         */
    freeTemporaryResources(false);
}
#end_block

#method_before
@Activate
protected void activate() {
    this.kafkaEventStore = new TreeMap<Long, OnosEvent>();
    lastPublishedEvent = storageService.<Long>atomicValueBuilder().withName("sequenceNumber").build().asAtomicValue();
    startGC();
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    kafkaEventStore = new TreeMap<Long, OnosEvent>();
    lastPublishedEvent = storageService.<Long>atomicValueBuilder().withName("onos-app-kafka-published-seqNumber").build().asAtomicValue();
    startGC();
    log.info("Started");
}
#end_block

#method_before
@Override
public void run() {
    for (OnosEvent event : kafkaEventStore.values()) {
    // TODO: Check the timestamp and delete it from the map if it is
    // less than the timestamp of last published event.
    }
}
#method_after
@Override
public void run() {
    kafkaEventStore.headMap(lastPublishedEvent.get(), true).clear();
}
#end_block

#method_before
@Override
public String rebootOnu(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    String[] onuId = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return reply;
    }
    onuId = target.split(HYPHEN);
    if (onuId.length != 2) {
        log.error("Invalid number of arguments");
        return reply;
    }
    try {
        pon = Integer.parseInt(onuId[0]);
        onu = Integer.parseInt(onuId[1]);
    } catch (NumberFormatException e) {
        log.error("Non-number input");
        return reply;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(ANGLE_LEFT).append(ONU_REBOOT).append(SPACE);
        request.append(VOLT_NE_NAMESPACE).append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(onuId[0]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(ONU_ID, false));
        request.append(onuId[1]);
        request.append(buildEndTag(ONU_ID));
        request.append(buildEndTag(ONU_REBOOT));
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().doUserRpc(request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception ", ncDeviceId, e);
    }
    return reply;
}
#method_after
@Override
public String rebootOnu(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    String[] onuId = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return reply;
    }
    onuId = target.split(HYPHEN);
    if (onuId.length != 2) {
        log.error("Invalid number of arguments");
        return reply;
    }
    try {
        pon = Integer.parseInt(onuId[0]);
        onu = Integer.parseInt(onuId[1]);
    } catch (NumberFormatException e) {
        log.error("Non-number input");
        return reply;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(ANGLE_LEFT).append(ONU_REBOOT).append(SPACE);
        request.append(VOLT_NE_NAMESPACE).append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(onuId[0]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(ONU_ID, false));
        request.append(onuId[1]);
        request.append(buildEndTag(ONU_ID));
        request.append(buildEndTag(ONU_REBOOT));
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().doWrappedRpc(request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception ", ncDeviceId, e);
    }
    return reply;
}
#end_block

#method_before
@Override
public String loopbackEthOnu(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    String[] ethId = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return reply;
    }
    ethId = target.split(HYPHEN);
    if (ethId.length != 3) {
        log.error("Invalid number of arguments");
        return reply;
    }
    try {
        pon = Integer.parseInt(ethId[0]);
        onu = Integer.parseInt(ethId[1]);
        eth = Integer.parseInt(ethId[2]);
    } catch (NumberFormatException e) {
        log.error("Non-number input");
        return reply;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(ANGLE_LEFT).append(ONU_ETHPORT_LOOPBACK).append(SPACE);
        request.append(VOLT_NE_NAMESPACE).append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(ethId[0]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(ONU_ID, false));
        request.append(ethId[1]);
        request.append(buildEndTag(ONU_ID));
        request.append(buildStartTag(ETHPORT_ID, false));
        request.append(ethId[2]);
        request.append(buildEndTag(ETHPORT_ID));
        request.append(buildEndTag(ONU_ETHPORT_LOOPBACK));
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().doUserRpc(request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception ", ncDeviceId, e);
    }
    return reply;
}
#method_after
@Override
public String loopbackEthOnu(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    String[] ethId = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return reply;
    }
    ethId = target.split(HYPHEN);
    if (ethId.length != 3) {
        log.error("Invalid number of arguments");
        return reply;
    }
    try {
        pon = Integer.parseInt(ethId[0]);
        onu = Integer.parseInt(ethId[1]);
        eth = Integer.parseInt(ethId[2]);
    } catch (NumberFormatException e) {
        log.error("Non-number input");
        return reply;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(ANGLE_LEFT).append(ONU_ETHPORT_LOOPBACK).append(SPACE);
        request.append(VOLT_NE_NAMESPACE).append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(ethId[0]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(ONU_ID, false));
        request.append(ethId[1]);
        request.append(buildEndTag(ONU_ID));
        request.append(buildStartTag(ETHPORT_ID, false));
        request.append(ethId[2]);
        request.append(buildEndTag(ETHPORT_ID));
        request.append(buildEndTag(ONU_ETHPORT_LOOPBACK));
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().doWrappedRpc(request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception ", ncDeviceId, e);
    }
    return reply;
}
#end_block

#method_before
@Override
public String setOnu(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return reply;
    }
    String[] data = target.split(COLON);
    if (data.length != 3) {
        log.error("Invalid number of arguments");
        return reply;
    }
    String[] onuId = data[0].split(HYPHEN);
    if (onuId.length != 2) {
        log.error("Invalid ONU identifier");
        return reply;
    }
    try {
        pon = Integer.parseInt(onuId[0]);
        onu = Integer.parseInt(onuId[1]);
    } catch (NumberFormatException e) {
        log.error("Non-number input");
        return reply;
    }
    if (!onuConfigParams.contains(data[1])) {
        log.error("Unsupported parameter: " + data[1]);
        return reply;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(ANGLE_LEFT).append(ONU_SET_CONFIG).append(SPACE);
        request.append(VOLT_NE_NAMESPACE).append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(onuId[0]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(ONU_ID, false));
        request.append(onuId[1]);
        request.append(buildEndTag(ONU_ID));
        request.append(buildStartTag(CONFIG_INFO));
        request.append(buildStartTag(data[1], false));
        request.append(data[2]);
        request.append(buildEndTag(data[1]));
        request.append(buildEndTag(CONFIG_INFO));
        request.append(buildEndTag(ONU_SET_CONFIG));
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().doUserRpc(request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception ", ncDeviceId, e);
    }
    return reply;
}
#method_after
@Override
public String setOnu(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return reply;
    }
    String[] data = target.split(COLON);
    if (data.length != 3) {
        log.error("Invalid number of arguments");
        return reply;
    }
    String[] onuId = data[0].split(HYPHEN);
    if (onuId.length != 2) {
        log.error("Invalid ONU identifier");
        return reply;
    }
    try {
        pon = Integer.parseInt(onuId[0]);
        onu = Integer.parseInt(onuId[1]);
    } catch (NumberFormatException e) {
        log.error("Non-number input");
        return reply;
    }
    if (!onuConfigParams.contains(data[1])) {
        log.error("Unsupported parameter: " + data[1]);
        return reply;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(ANGLE_LEFT).append(ONU_SET_CONFIG).append(SPACE);
        request.append(VOLT_NE_NAMESPACE).append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(onuId[0]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(ONU_ID, false));
        request.append(onuId[1]);
        request.append(buildEndTag(ONU_ID));
        request.append(buildStartTag(CONFIG_INFO));
        request.append(buildStartTag(data[1], false));
        request.append(data[2]);
        request.append(buildEndTag(data[1]));
        request.append(buildEndTag(CONFIG_INFO));
        request.append(buildEndTag(ONU_SET_CONFIG));
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().doWrappedRpc(request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception ", ncDeviceId, e);
    }
    return reply;
}
#end_block

#method_before
private void validateKey(List<YangLeaf> leaves, List<YangLeafList> leafLists, List<String> keys) throws DataModelException {
    boolean leafFound = false;
    List<YangLeaf> keyLeaves = new LinkedList<>();
    List<YangLeafList> keyLeafLists = new LinkedList<>();
    /*
         * 1. Leaf identifier must refer to a child leaf of the list 2. A leaf
         * that is part of the key must not be the built-in type "empty".
         */
    for (String key : keys) {
        if (leaves != null && !leaves.isEmpty()) {
            for (YangLeaf leaf : leaves) {
                if (key.equals(leaf.getName())) {
                    if (leaf.getDataType().getDataType() == YangDataTypes.EMPTY) {
                        throw new DataModelException(" A leaf that is part of the key must not be the built-in " + "type \"empty\".");
                    }
                    leafFound = true;
                    keyLeaves.add(leaf);
                    break;
                }
            }
        }
        if (leafLists != null && !leafLists.isEmpty()) {
            for (YangLeafList leafList : leafLists) {
                if (key.equals(leafList.getName())) {
                    if (leafList.getDataType().getDataType() == YangDataTypes.EMPTY) {
                        throw new DataModelException(" A leaf-list that is part of the key" + " must not be the built-in type \"empty\".");
                    }
                    leafFound = true;
                    keyLeafLists.add(leafList);
                    break;
                }
            }
        }
        if (!leafFound && !isUsesPresentInList() && !isListPresentInGrouping()) {
            throw new DataModelException("An identifier, in key, must refer to a child leaf of the list");
        }
        leafFound = false;
    }
    /*
         * All key leafs in a list MUST have the same value for their "config"
         * as the list itself.
         */
    for (YangLeaf keyLeaf : keyLeaves) {
        if (isConfig != keyLeaf.isConfig()) {
            throw new DataModelException("All key leafs in a list must have the same value for their" + " \"config\" as the list itself.");
        }
    }
    /*
        * All key leafs in a list MUST have the same value for their "config"
        * as the list itself.
        */
    for (YangLeafList keyLeafList : keyLeafLists) {
        if (isConfig() != keyLeafList.isConfig()) {
            throw new DataModelException("All key leaf-lists in a list must have the same value for their" + " \"config\" as the list itself.");
        }
    }
}
#method_after
private void validateKey(List<YangLeaf> leaves, List<YangLeafList> leafLists, List<String> keys) throws DataModelException {
    boolean leafFound = false;
    List<YangLeaf> keyLeaves = new LinkedList<>();
    List<YangLeafList> keyLeafLists = new LinkedList<>();
    /*
         * 1. Leaf identifier must refer to a child leaf of the list 2. A leaf
         * that is part of the key must not be the built-in type "empty".
         */
    for (String key : keys) {
        if (leaves != null && !leaves.isEmpty()) {
            for (YangLeaf leaf : leaves) {
                if (key.equals(leaf.getName())) {
                    if (leaf.getDataType().getDataType() == YangDataTypes.EMPTY) {
                        throw new DataModelException(" A leaf that is part of the key must not be the built-in " + "type \"empty\".");
                    }
                    leafFound = true;
                    keyLeaves.add(leaf);
                    break;
                }
            }
        }
        if (leafLists != null && !leafLists.isEmpty()) {
            for (YangLeafList leafList : leafLists) {
                if (key.equals(leafList.getName())) {
                    if (leafList.getDataType().getDataType() == YangDataTypes.EMPTY) {
                        throw new DataModelException(" A leaf-list that is part of the key" + " must not be the built-in type \"empty\".");
                    }
                    leafFound = true;
                    keyLeafLists.add(leafList);
                    break;
                }
            }
        }
        if (!leafFound && !isUsesPresentInList() && !isListPresentInGrouping()) {
            throw new DataModelException("An identifier, in key, must refer to a child leaf of the list");
        }
        leafFound = false;
    }
    /*
         * All key leafs in a list MUST have the same value for their "config"
         * as the list itself.
         */
    for (YangLeaf keyLeaf : keyLeaves) {
        if (isConfig != keyLeaf.isConfig()) {
            throw new DataModelException("All key leafs in a list must have the same value for their" + " \"config\" as the list itself.");
        }
    }
    /*
         * All key leafs in a list MUST have the same value for their "config"
         * as the list itself.
         */
    for (YangLeafList keyLeafList : keyLeafLists) {
        if (isConfig() != keyLeafList.isConfig()) {
            throw new DataModelException("All key leaf-lists in a list must have the same value for their" + " \"config\" as the list itself.");
        }
    }
}
#end_block

#method_before
private void resolveSelfFileLinkingForLeafref(YangNode potentialAncestorWithReferredNode) throws DataModelException {
    YangNode ancestorWithTheReferredNode = potentialAncestorWithReferredNode;
    YangLeafRef leafref = (YangLeafRef) getCurrentEntityToResolveFromStack();
    boolean referredLeafFound = false;
    /*
         * Takes absolute path and takes the root node as module/sub-module,
         * then sends the list of nodes for finding the target leaf.
         */
    if (leafref.getPathType() == YangPathArgType.ABSOLUTE_PATH) {
        List<YangAbsolutePath> absolutePathList = leafref.getAbsolutePath();
        if (absolutePathList != null && !absolutePathList.isEmpty()) {
            Iterator<YangAbsolutePath> listOfYangAbsolutePath = absolutePathList.listIterator();
            if (getCurReferenceResolver() instanceof YangModule) {
                YangModule rootNode = (YangModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAbsolutePath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            } else if (getCurReferenceResolver() instanceof YangSubModule) {
                YangSubModule rootNode = (YangSubModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAbsolutePath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            }
        }
    /*
             * Takes relative path, goes to the parent node by using the
             * ancestor count and sends the list of nodes for finding the target
             * leaf.
             */
    } else if (leafref.getPathType() == YangPathArgType.RELATIVE_PATH) {
        YangRelativePath yangRelativePath = leafref.getRelativePath();
        int parentNodes = yangRelativePath.getAncestorNodeCount();
        List<YangAbsolutePath> absolutePathList = yangRelativePath.getAbsolutePath();
        if (absolutePathList != null && !absolutePathList.isEmpty()) {
            Iterator<YangAbsolutePath> listOfYangAbsolutePath = absolutePathList.listIterator();
            // Gets the root node from ancestor count.
            YangNode rootparentNode = getRootNodeWithAncestorCount(parentNodes, ancestorWithTheReferredNode);
            // Sends list of nodes for finding the target leaf.
            referredLeafFound = isLeafReferenceFound(listOfYangAbsolutePath, rootparentNode, referredLeafFound, potentialAncestorWithReferredNode);
        }
    }
    if (referredLeafFound) {
        return;
    }
    /*
         * In case prefix is not present it's a candidate for inter-file
         * resolution via include list.
         */
    if (getRefPrefix() == null) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTRA_FILE_RESOLVED);
    }
}
#method_after
private void resolveSelfFileLinkingForLeafref(YangNode potentialAncestorWithReferredNode) throws DataModelException {
    YangNode ancestorWithTheReferredNode = potentialAncestorWithReferredNode;
    YangLeafRef leafref = (YangLeafRef) getCurrentEntityToResolveFromStack();
    boolean referredLeafFound = false;
    /*
         * Takes absolute path and takes the root node as module/sub-module,
         * then sends the list of nodes for finding the target leaf.
         */
    if (leafref.getPathType() == YangPathArgType.ABSOLUTE_PATH) {
        List<YangAtomicPath> atomicPathList = leafref.getAtomicPath();
        if (atomicPathList != null && !atomicPathList.isEmpty()) {
            Iterator<YangAtomicPath> listOfYangAtomicPath = atomicPathList.listIterator();
            if (getCurReferenceResolver() instanceof YangModule) {
                YangModule rootNode = (YangModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAtomicPath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            } else if (getCurReferenceResolver() instanceof YangSubModule) {
                YangSubModule rootNode = (YangSubModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAtomicPath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            }
        }
    /*
             * Takes relative path, goes to the parent node by using the
             * ancestor count and sends the list of nodes for finding the target
             * leaf.
             */
    } else if (leafref.getPathType() == YangPathArgType.RELATIVE_PATH) {
        YangRelativePath yangRelativePath = leafref.getRelativePath();
        int parentNodes = yangRelativePath.getAncestorNodeCount();
        List<YangAtomicPath> atomicPathList = yangRelativePath.getAtomicPathList();
        if (atomicPathList != null && !atomicPathList.isEmpty()) {
            Iterator<YangAtomicPath> listOfAtomicPath = atomicPathList.listIterator();
            // Gets the root node from ancestor count.
            YangNode rootparentNode = getRootNodeWithAncestorCount(parentNodes, ancestorWithTheReferredNode);
            // Sends list of nodes for finding the target leaf.
            referredLeafFound = isLeafReferenceFound(listOfAtomicPath, rootparentNode, referredLeafFound, potentialAncestorWithReferredNode);
        }
    }
    if (referredLeafFound) {
        return;
    }
    /*
         * In case prefix is not present it's a candidate for inter-file
         * resolution via include list.
         */
    if (getRefPrefix() == null) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTRA_FILE_RESOLVED);
    }
}
#end_block

#method_before
private boolean isLeafReferenceFound(Iterator<YangAbsolutePath> listOfYangAbsolutePath, YangNode ancestorWithTheReferredNode, boolean referredLeafFound, YangNode potentialAncestorWithReferredNode) throws DataModelException {
    while (listOfYangAbsolutePath.hasNext()) {
        YangAbsolutePath absolutePath = listOfYangAbsolutePath.next();
        String nodeName = absolutePath.getNodeIdentifier().getName();
        // When child is not present, only leaf/leaf-list is available in the node.
        if (ancestorWithTheReferredNode.getChild() == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode, nodeName, (T) LINKED);
            break;
        }
        ancestorWithTheReferredNode = ancestorWithTheReferredNode.getChild();
        // Checks all the siblings under the node and returns the matched node.
        YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(ancestorWithTheReferredNode, nodeName);
        // When node is not found in all the siblings, leaf-list may be the node we have to find.
        if (nodeFound == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode.getParent(), nodeName, (T) LINKED);
        } else {
            ancestorWithTheReferredNode = nodeFound;
            // For the node check if path predicate is present and fill its values.
            List<YangPathPredicate> pathPredicateList = absolutePath.getPredicatesExp();
            if (pathPredicateList != null && !pathPredicateList.isEmpty()) {
                Iterator<YangPathPredicate> listOfYangPathPredicate = pathPredicateList.listIterator();
                fillPathPredicatesForTheNode(ancestorWithTheReferredNode, listOfYangPathPredicate, potentialAncestorWithReferredNode);
            }
        }
        // If leaf is also not found and node is also not found return the status as false.
        if (!referredLeafFound && nodeFound == null) {
            break;
        }
    }
    return referredLeafFound;
}
#method_after
private boolean isLeafReferenceFound(Iterator<YangAtomicPath> listOfYangAtomicPath, YangNode ancestorWithTheReferredNode, boolean referredLeafFound, YangNode potentialAncestorWithReferredNode) throws DataModelException {
    while (listOfYangAtomicPath.hasNext()) {
        YangAtomicPath atomicPath = listOfYangAtomicPath.next();
        String nodeName = atomicPath.getNodeIdentifier().getName();
        // When child is not present, only leaf/leaf-list is available in the node.
        if (ancestorWithTheReferredNode.getChild() == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode, nodeName, (T) LINKED);
            break;
        }
        ancestorWithTheReferredNode = ancestorWithTheReferredNode.getChild();
        // Checks all the siblings under the node and returns the matched node.
        YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(ancestorWithTheReferredNode, nodeName);
        // When node is not found in all the siblings, leaf-list may be the node we have to find.
        if (nodeFound == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode.getParent(), nodeName, (T) LINKED);
        } else {
            ancestorWithTheReferredNode = nodeFound;
            // For the node check if path predicate is present and fill its values.
            List<YangPathPredicate> pathPredicateList = atomicPath.getPathPredicatesList();
            if (pathPredicateList != null && !pathPredicateList.isEmpty()) {
                Iterator<YangPathPredicate> listOfYangPathPredicate = pathPredicateList.listIterator();
                fillPathPredicatesForTheNode(ancestorWithTheReferredNode, listOfYangPathPredicate, potentialAncestorWithReferredNode);
            }
        }
        // If leaf is also not found and node is also not found return the status as false.
        if (!referredLeafFound && nodeFound == null) {
            break;
        }
    }
    return referredLeafFound;
}
#end_block

#method_before
private void resolveRightAxisNodeInPathPredicate(YangRelativePath relativePath, YangNode rootParentNode, YangPathPredicate pathPredicate) throws DataModelException {
    List<YangAbsolutePath> absolutePathList = relativePath.getAbsolutePath();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAbsolutePath> listOfYangAbsolutePathForRightRelative = absolutePathList.listIterator();
        while (listOfYangAbsolutePathForRightRelative.hasNext()) {
            boolean isRightAxisNodeFound = false;
            YangAbsolutePath absolutePathInPredicate = listOfYangAbsolutePathForRightRelative.next();
            String nodeNameInAbsolutePath = absolutePathInPredicate.getNodeIdentifier().getName();
            // When child is not there check the leaf/leaf-list.
            if (rootParentNode.getChild() == null) {
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode, nodeNameInAbsolutePath, (T) pathPredicate);
                if (!isRightAxisNodeFound) {
                    throw new DataModelException("YANG file error: The path predicates is not referring to an existing leaf/leaflist");
                }
                break;
            }
            rootParentNode = rootParentNode.getChild();
            YangNode nodeFoundInTheRelativePath = isReferredNodeInSiblingProcessedForLeafref(rootParentNode, nodeNameInAbsolutePath);
            if (nodeFoundInTheRelativePath == null) {
                // When node is not found check the leaf/leaf-list.
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode.getParent(), nodeNameInAbsolutePath, (T) pathPredicate);
            } else {
                rootParentNode = nodeFoundInTheRelativePath;
            }
            if (!isRightAxisNodeFound && nodeFoundInTheRelativePath == null) {
                throw new DataModelException("YANG file error: The path predicates is not referring to an existing leaf/leaflist");
            }
        }
    }
}
#method_after
private void resolveRightAxisNodeInPathPredicate(YangRelativePath relativePath, YangNode rootParentNode, YangPathPredicate pathPredicate) throws DataModelException {
    List<YangAtomicPath> absolutePathList = relativePath.getAtomicPathList();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAtomicPath> listOfYangAtomicPathForRightRelative = absolutePathList.listIterator();
        while (listOfYangAtomicPathForRightRelative.hasNext()) {
            boolean isRightAxisNodeFound = false;
            YangAtomicPath absolutePathInPredicate = listOfYangAtomicPathForRightRelative.next();
            String nodeNameInAtomicPath = absolutePathInPredicate.getNodeIdentifier().getName();
            // When child is not there check the leaf/leaf-list.
            if (rootParentNode.getChild() == null) {
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode, nodeNameInAtomicPath, (T) pathPredicate);
                if (!isRightAxisNodeFound) {
                    throw new DataModelException("YANG file error: The path predicates is not referring to an existing leaf/leaflist");
                }
                break;
            }
            rootParentNode = rootParentNode.getChild();
            YangNode nodeFoundInTheRelativePath = isReferredNodeInSiblingProcessedForLeafref(rootParentNode, nodeNameInAtomicPath);
            if (nodeFoundInTheRelativePath == null) {
                // When node is not found check the leaf/leaf-list.
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode.getParent(), nodeNameInAtomicPath, (T) pathPredicate);
            } else {
                rootParentNode = nodeFoundInTheRelativePath;
            }
            if (!isRightAxisNodeFound && nodeFoundInTheRelativePath == null) {
                throw new DataModelException("YANG file error: The path predicates is not referring to an existing leaf/leaflist");
            }
        }
    }
}
#end_block

#method_before
private void addUnResolvedBaseToStack(YangNode node) {
    YangIdentity curNode = (YangIdentity) node;
    if (null != curNode.getBaseNode()) {
        if (curNode.getBaseNode().getResolvableStatus() != RESOLVED) {
            YangEntityToResolveInfoImpl<YangBase> unResolvedEntityInfo = new YangEntityToResolveInfoImpl<>();
            unResolvedEntityInfo.setEntityToResolve(curNode.getBaseNode());
            unResolvedEntityInfo.setHolderOfEntityToResolve(node);
            addInPartialResolvedStack((YangEntityToResolveInfoImpl<T>) unResolvedEntityInfo);
        }
    }
}
#method_after
private void addUnResolvedBaseToStack(YangNode node) {
    YangIdentity curNode = (YangIdentity) node;
    if (curNode.getBaseNode() != null) {
        if (curNode.getBaseNode().getResolvableStatus() != RESOLVED) {
            YangEntityToResolveInfoImpl<YangBase> unResolvedEntityInfo = new YangEntityToResolveInfoImpl<>();
            unResolvedEntityInfo.setEntityToResolve(curNode.getBaseNode());
            unResolvedEntityInfo.setHolderOfEntityToResolve(node);
            addInPartialResolvedStack((YangEntityToResolveInfoImpl<T>) unResolvedEntityInfo);
        }
    }
}
#end_block

#method_before
private void processXPathLinking(YangEntityToResolveInfoImpl<T> entityToResolveInfo, YangReferenceResolver root) {
    YangXpathLinker<T> xPathLinker = new YangXpathLinker<T>();
    T entityToResolve = entityToResolveInfo.getEntityToResolve();
    if (entityToResolve instanceof YangAugment) {
        YangNode targetNode = null;
        YangAugment augment = (YangAugment) entityToResolve;
        targetNode = xPathLinker.processAugmentXpathLinking(augment.getTargetNode(), (YangNode) root);
        if (targetNode != null) {
            if (targetNode instanceof YangAugmentationHolder) {
                detectCollisionForAugmentedNode(targetNode, augment);
                ((AugmentationHolder) targetNode).addAugmentation(augment);
                augment.setAugmentedNode(targetNode);
                Resolvable resolvable = (Resolvable) entityToResolve;
                resolvable.setResolvableStatus(RESOLVED);
            } else {
                throw new LinkerException("Invalid target node type " + targetNode.getNodeType() + " for " + augment.getName());
            }
        } else {
            throw new LinkerException("Failed to link " + augment.getName());
        }
    } else if (entityToResolve instanceof YangLeafRef) {
        YangLeafRef leafRef = (YangLeafRef) entityToResolve;
        Object target = xPathLinker.processLeafRefXpathLinking(leafRef.getAbsolutePath(), (YangNode) root);
        if (target != null) {
            YangLeaf leaf = null;
            YangLeafList leafList = null;
            leafRef.setReferredLeafOrLeafList(target);
            if (target instanceof YangLeaf) {
                leaf = (YangLeaf) target;
                leafRef.setEffectiveDataType(leaf.getDataType());
            } else {
                leafList = (YangLeafList) target;
                leafRef.setEffectiveDataType(leafList.getDataType());
            }
            leafRef.setResolvableStatus(RESOLVED);
        // TODO: add logic for leaf-ref for path predicates.
        } else {
            throw new LinkerException("YANG file error: Unable to find base leaf/leaf-list for given leafref " + leafRef.getPath());
        }
    }
}
#method_after
private void processXPathLinking(YangEntityToResolveInfoImpl<T> entityToResolveInfo, YangReferenceResolver root) {
    YangXpathLinker<T> xPathLinker = new YangXpathLinker<T>();
    T entityToResolve = entityToResolveInfo.getEntityToResolve();
    if (entityToResolve instanceof YangAugment) {
        YangNode targetNode = null;
        YangAugment augment = (YangAugment) entityToResolve;
        targetNode = xPathLinker.processAugmentXpathLinking(augment.getTargetNode(), (YangNode) root);
        if (targetNode != null) {
            if (targetNode instanceof YangAugmentableNode) {
                detectCollisionForAugmentedNode(targetNode, augment);
                ((YangAugmentableNode) targetNode).addAugmentation(augment);
                augment.setAugmentedNode(targetNode);
                Resolvable resolvable = (Resolvable) entityToResolve;
                resolvable.setResolvableStatus(RESOLVED);
            } else {
                throw new LinkerException("Invalid target node type " + targetNode.getNodeType() + " for " + augment.getName());
            }
        } else {
            throw new LinkerException("Failed to link " + augment.getName());
        }
    } else if (entityToResolve instanceof YangLeafRef) {
        YangLeafRef leafRef = (YangLeafRef) entityToResolve;
        Object target = xPathLinker.processLeafRefXpathLinking(leafRef.getAtomicPath(), (YangNode) root);
        if (target != null) {
            YangLeaf leaf = null;
            YangLeafList leafList = null;
            leafRef.setReferredLeafOrLeafList(target);
            if (target instanceof YangLeaf) {
                leaf = (YangLeaf) target;
                leafRef.setEffectiveDataType(leaf.getDataType());
            } else {
                leafList = (YangLeafList) target;
                leafRef.setEffectiveDataType(leafList.getDataType());
            }
            leafRef.setResolvableStatus(RESOLVED);
        // TODO: add logic for leaf-ref for path predicates.
        } else {
            throw new LinkerException("YANG file error: Unable to find base leaf/leaf-list for given leafref " + leafRef.getPath());
        }
    }
}
#end_block

#method_before
private String refPrefixForLeafRef() {
    String refPrefix;
    if (((YangLeafRef) getCurrentEntityToResolveFromStack()).getPathType() == YangPathArgType.ABSOLUTE_PATH) {
        List<YangAbsolutePath> theList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAbsolutePath();
        YangAbsolutePath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    } else {
        YangRelativePath relativePath = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getRelativePath();
        List<YangAbsolutePath> theList = relativePath.getAbsolutePath();
        YangAbsolutePath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    }
    return refPrefix;
}
#method_after
private String refPrefixForLeafRef() {
    String refPrefix;
    if (((YangLeafRef) getCurrentEntityToResolveFromStack()).getPathType() == YangPathArgType.ABSOLUTE_PATH) {
        List<YangAtomicPath> theList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAtomicPath();
        YangAtomicPath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    } else {
        YangRelativePath relativePath = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getRelativePath();
        List<YangAtomicPath> theList = relativePath.getAtomicPathList();
        YangAtomicPath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    }
    return refPrefix;
}
#end_block

#method_before
private boolean findRefLeaf(YangNode importedNode) throws DataModelException {
    boolean isReferredNodeFound = false;
    List<YangAbsolutePath> absolutePathList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAbsolutePath();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAbsolutePath> listOfYangAbsolutePath = absolutePathList.listIterator();
        while (listOfYangAbsolutePath.hasNext()) {
            YangAbsolutePath absolutePath = listOfYangAbsolutePath.next();
            String nodeName = absolutePath.getNodeIdentifier().getName();
            if (importedNode.getChild() == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode, nodeName, (T) INTER_FILE_LINKED);
                break;
            }
            importedNode = importedNode.getChild();
            YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(importedNode, nodeName);
            if (nodeFound == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode.getParent(), nodeName, (T) INTER_FILE_LINKED);
            } else {
                importedNode = nodeFound;
            }
        }
    }
    // TODO: Path predicates filling for inter file has to be done.
    return isReferredNodeFound;
}
#method_after
private boolean findRefLeaf(YangNode importedNode) throws DataModelException {
    boolean isReferredNodeFound = false;
    List<YangAtomicPath> absolutePathList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAtomicPath();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAtomicPath> listOfYangAtomicPath = absolutePathList.listIterator();
        while (listOfYangAtomicPath.hasNext()) {
            YangAtomicPath absolutePath = listOfYangAtomicPath.next();
            String nodeName = absolutePath.getNodeIdentifier().getName();
            if (importedNode.getChild() == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode, nodeName, (T) INTER_FILE_LINKED);
                break;
            }
            importedNode = importedNode.getChild();
            YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(importedNode, nodeName);
            if (nodeFound == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode.getParent(), nodeName, (T) INTER_FILE_LINKED);
            } else {
                importedNode = nodeFound;
            }
        }
    }
    // TODO: Path predicates filling for inter file has to be done.
    return isReferredNodeFound;
}
#end_block

#method_before
@Test
public void processValidAugmentStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ValidAugmentStatement.yang");
    assertThat(node instanceof YangModule, is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangAugment yangAugment = (YangAugment) yangNode.getChild();
    ListIterator<YangAbsolutePath> absPathIterator = yangAugment.getTargetNode().listIterator();
    YangAbsolutePath absPathIdentifier = absPathIterator.next();
    assertThat(absPathIdentifier.getNodeIdentifier().getPrefix(), is("if"));
    assertThat(absPathIdentifier.getNodeIdentifier().getName(), is("interfaces"));
    ListIterator<YangLeaf> leafIterator = yangAugment.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("ds0ChannelNumber"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("ChannelNumber"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
}
#method_after
@Test
public void processValidAugmentStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/ValidAugmentStatement.yang");
    assertThat(node instanceof YangModule, is(true));
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangAugment yangAugment = (YangAugment) yangNode.getChild();
    ListIterator<YangAtomicPath> absPathIterator = yangAugment.getTargetNode().listIterator();
    YangAtomicPath absPathIdentifier = absPathIterator.next();
    assertThat(absPathIdentifier.getNodeIdentifier().getPrefix(), is("if"));
    assertThat(absPathIdentifier.getNodeIdentifier().getName(), is("interfaces"));
    ListIterator<YangLeaf> leafIterator = yangAugment.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("ds0ChannelNumber"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("ChannelNumber"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.DERIVED));
}
#end_block

#method_before
private void addConstructor(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {
    appendToFile(getConstructorImplTempFileHandle(), getConstructor(getGeneratedJavaClassName(), attr, getGeneratedJavaFiles(), pluginConfig));
}
#method_after
private void addConstructor(JavaAttributeInfo attr, YangPluginConfig pluginConfig) throws IOException {
    appendToFile(getConstructorImplTempFileHandle(), getConstructor(attr, getGeneratedJavaFiles(), pluginConfig));
}
#end_block

#method_before
private static String parseTypeForReturnValue(String type) {
    switch(type) {
        case BYTE:
        case INT:
        case SHORT:
        case LONG:
            return "0";
        case BOOLEAN_DATA_TYPE:
            return FALSE;
        default:
            return null;
    }
}
#method_after
private static String parseTypeForReturnValue(String type) {
    switch(type) {
        case BYTE:
        case INT:
        case SHORT:
        case LONG:
        case DOUBLE:
            return "0";
        case BOOLEAN_DATA_TYPE:
            return FALSE;
        default:
            return null;
    }
}
#end_block

#method_before
public static String getConstructor(String yangName, JavaAttributeInfo attr, int generatedJavaFiles, YangPluginConfig pluginConfig) {
    String attributeName = attr.getAttributeName();
    String constructor;
    if ((generatedJavaFiles & GENERATE_SERVICE_AND_MANAGER) != 0) {
        constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_METHOD_PREFIX + getCapitalCase(getCamelCase(attributeName, pluginConfig.getConflictResolver())) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    } else {
        constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    }
    return constructor;
}
#method_after
public static String getConstructor(JavaAttributeInfo attr, int generatedJavaFiles, YangPluginConfig pluginConfig) {
    String attributeName = attr.getAttributeName();
    String constructor;
    if ((generatedJavaFiles & GENERATE_SERVICE_AND_MANAGER) != 0) {
        constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + GET_METHOD_PREFIX + getCapitalCase(getCamelCase(attributeName, pluginConfig.getConflictResolver())) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    } else {
        constructor = EIGHT_SPACE_INDENTATION + THIS + PERIOD + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + SPACE + EQUAL + SPACE + BUILDER.toLowerCase() + OBJECT + PERIOD + getCamelCase(attributeName, pluginConfig.getConflictResolver()) + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN + NEW_LINE;
    }
    return constructor;
}
#end_block

#method_before
private static String getParsedSubString(JavaAttributeInfo attr, JavaAttributeInfo fromStringAttributeInfo) {
    String targetDataType = getReturnType(attr);
    String parseFromStringMethod = getParseFromStringMethod(targetDataType, fromStringAttributeInfo.getAttributeType());
    return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + parseFromStringMethod + OPEN_PARENTHESIS + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS;
}
#method_after
private static String getParsedSubString(JavaAttributeInfo attr, JavaAttributeInfo fromStringAttributeInfo) {
    String targetDataType = getReturnType(attr);
    if (fromStringAttributeInfo.getAttributeType().getDataType() == BINARY) {
        return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + FROM_STRING_PARAM_NAME + PERIOD + GET_BYTES + OPEN_PARENTHESIS + CLOSE_PARENTHESIS;
    } else {
        String parseFromStringMethod = getParseFromStringMethod(targetDataType, fromStringAttributeInfo.getAttributeType());
        return targetDataType + SPACE + TMP_VAL + SPACE + EQUAL + SPACE + parseFromStringMethod + OPEN_PARENTHESIS + FROM_STRING_PARAM_NAME + CLOSE_PARENTHESIS;
    }
}
#end_block

#method_before
public static String getParseFromStringMethod(String targetDataType, YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE_WRAPPER + PERIOD + PARSE_BYTE;
        case INT16:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case INT32:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case INT64:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT8:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case UINT16:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case UINT32:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT64:
            return NEW + SPACE + BIG_INTEGER;
        case STRING:
            return EMPTY_STRING;
        case EMPTY:
        case BOOLEAN:
            return BOOLEAN_WRAPPER + PERIOD + PARSE_BOOLEAN;
        case DECIMAL64:
        case BITS:
        case BINARY:
        case UNION:
        case ENUMERATION:
        case DERIVED:
            return targetDataType + PERIOD + FROM_STRING_METHOD_NAME;
        default:
            throw new TranslatorException("given data type is not supported.");
    }
}
#method_after
public static String getParseFromStringMethod(String targetDataType, YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE_WRAPPER + PERIOD + PARSE_BYTE;
        case INT16:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case INT32:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case INT64:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT8:
            return SHORT_WRAPPER + PERIOD + PARSE_SHORT;
        case UINT16:
            return INTEGER_WRAPPER + PERIOD + PARSE_INT;
        case UINT32:
            return LONG_WRAPPER + PERIOD + PARSE_LONG;
        case UINT64:
            return NEW + SPACE + BIG_INTEGER;
        case DECIMAL64:
            return NEW + SPACE + BIG_DECIMAL;
        case STRING:
            return EMPTY_STRING;
        case EMPTY:
        case BOOLEAN:
            return BOOLEAN_WRAPPER + PERIOD + PARSE_BOOLEAN;
        case BITS:
        case UNION:
        case ENUMERATION:
        case DERIVED:
            return targetDataType + PERIOD + FROM_STRING_METHOD_NAME;
        default:
            throw new TranslatorException("given data type is not supported.");
    }
}
#end_block

#method_before
private void validateKey(List<YangLeaf> leaves, List<YangLeafList> leafLists, List<String> keys) throws DataModelException {
    boolean leafFound = false;
    List<YangLeaf> keyLeaves = new LinkedList<>();
    List<YangLeafList> keyLeafLists = new LinkedList<>();
    /*
         * 1. Leaf identifier must refer to a child leaf of the list 2. A leaf
         * that is part of the key must not be the built-in type "empty".
         */
    for (String key : keys) {
        if (leaves != null && !leaves.isEmpty()) {
            for (YangLeaf leaf : leaves) {
                if (key.equals(leaf.getName())) {
                    if (leaf.getDataType().getDataType() == YangDataTypes.EMPTY) {
                        throw new DataModelException(" A leaf that is part of the key must not be the built-in " + "type \"empty\".");
                    }
                    leafFound = true;
                    keyLeaves.add(leaf);
                    break;
                }
            }
        }
        if (leafLists != null && !leafLists.isEmpty()) {
            for (YangLeafList leafList : leafLists) {
                if (key.equals(leafList.getName())) {
                    if (leafList.getDataType().getDataType() == YangDataTypes.EMPTY) {
                        throw new DataModelException(" A leaf-list that is part of the key" + " must not be the built-in type \"empty\".");
                    }
                    leafFound = true;
                    keyLeafLists.add(leafList);
                    break;
                }
            }
        }
        if (!leafFound && !isUsesPresentInList() && !isListPresentInGrouping()) {
            throw new DataModelException("An identifier, in key, must refer to a child leaf of the list");
        }
        leafFound = false;
    }
    /*
         * All key leafs in a list MUST have the same value for their "config"
         * as the list itself.
         */
    for (YangLeaf keyLeaf : keyLeaves) {
        if (isConfig != keyLeaf.isConfig()) {
            throw new DataModelException("All key leafs in a list must have the same value for their" + " \"config\" as the list itself.");
        }
    }
    /*
        * All key leafs in a list MUST have the same value for their "config"
        * as the list itself.
        */
    for (YangLeafList keyLeafList : keyLeafLists) {
        if (isConfig() != keyLeafList.isConfig()) {
            throw new DataModelException("All key leaf-lists in a list must have the same value for their" + " \"config\" as the list itself.");
        }
    }
}
#method_after
private void validateKey(List<YangLeaf> leaves, List<YangLeafList> leafLists, List<String> keys) throws DataModelException {
    boolean leafFound = false;
    List<YangLeaf> keyLeaves = new LinkedList<>();
    List<YangLeafList> keyLeafLists = new LinkedList<>();
    /*
         * 1. Leaf identifier must refer to a child leaf of the list 2. A leaf
         * that is part of the key must not be the built-in type "empty".
         */
    for (String key : keys) {
        if (leaves != null && !leaves.isEmpty()) {
            for (YangLeaf leaf : leaves) {
                if (key.equals(leaf.getName())) {
                    if (leaf.getDataType().getDataType() == YangDataTypes.EMPTY) {
                        throw new DataModelException(" A leaf that is part of the key must not be the built-in " + "type \"empty\".");
                    }
                    leafFound = true;
                    keyLeaves.add(leaf);
                    break;
                }
            }
        }
        if (leafLists != null && !leafLists.isEmpty()) {
            for (YangLeafList leafList : leafLists) {
                if (key.equals(leafList.getName())) {
                    if (leafList.getDataType().getDataType() == YangDataTypes.EMPTY) {
                        throw new DataModelException(" A leaf-list that is part of the key" + " must not be the built-in type \"empty\".");
                    }
                    leafFound = true;
                    keyLeafLists.add(leafList);
                    break;
                }
            }
        }
        if (!leafFound && !isUsesPresentInList() && !isListPresentInGrouping()) {
            throw new DataModelException("An identifier, in key, must refer to a child leaf of the list");
        }
        leafFound = false;
    }
    /*
         * All key leafs in a list MUST have the same value for their "config"
         * as the list itself.
         */
    for (YangLeaf keyLeaf : keyLeaves) {
        if (isConfig != keyLeaf.isConfig()) {
            throw new DataModelException("All key leafs in a list must have the same value for their" + " \"config\" as the list itself.");
        }
    }
    /*
         * All key leafs in a list MUST have the same value for their "config"
         * as the list itself.
         */
    for (YangLeafList keyLeafList : keyLeafLists) {
        if (isConfig() != keyLeafList.isConfig()) {
            throw new DataModelException("All key leaf-lists in a list must have the same value for their" + " \"config\" as the list itself.");
        }
    }
}
#end_block

#method_before
@Override
public void addAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.add(augmentInfo);
}
#method_after
@Override
public void addAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.add(augmentInfo);
}
#end_block

#method_before
@Override
public void removeAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.remove(augmentInfo);
}
#method_after
@Override
public void removeAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.remove(augmentInfo);
}
#end_block

#method_before
@Override
public List<AugmentedInfo> getAugmentedInfoList() {
    return augmentedInfo;
}
#method_after
@Override
public List<YangAugmentedInfo> getAugmentedInfoList() {
    return yangAugmentedInfo;
}
#end_block

#method_before
@Test
public void processIntraFileLinkingInSubModuleSingleLevel() throws IOException {
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(INTRA_FILE_PATH + "IntraSingleSubModule/"));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    linkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    YangNode targetNode = null;
    String targetNodeName = null;
    for (YangNode node : utilManager.getYangNodeSet()) {
        List<YangAugment> augments = linker.getListOfYangAugment(node);
        for (YangAugment augment : augments) {
            targetNodeName = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier().getName();
            targetNode = linker.processAugmentXpathLinking(augment.getTargetNode(), node);
        }
    }
    assertThat(true, is(targetNode.getName().equals(targetNodeName)));
}
#method_after
@Test
public void processIntraFileLinkingInSubModuleSingleLevel() throws IOException {
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(INTRA_FILE_PATH + "IntraSingleSubModule/"));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    linkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    linkerManager.linkSubModulesToParentModule(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    YangNode targetNode = null;
    String targetNodeName = null;
    for (YangNode node : utilManager.getYangNodeSet()) {
        List<YangAugment> augments = linker.getListOfYangAugment(node);
        for (YangAugment augment : augments) {
            targetNodeName = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier().getName();
            targetNode = linker.processAugmentXpathLinking(augment.getTargetNode(), node);
        }
    }
    assertThat(true, is(targetNode.getName().equals(targetNodeName)));
}
#end_block

#method_before
@Test
public void processIntraFileLinkingInSubModuleMultiLevel() throws IOException {
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(INTRA_FILE_PATH + "IntraMultiSubModule/"));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    linkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    YangNode targetNode = null;
    String targetNodeName = null;
    for (YangNode node : utilManager.getYangNodeSet()) {
        List<YangAugment> augments = linker.getListOfYangAugment(node);
        for (YangAugment augment : augments) {
            targetNodeName = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier().getName();
            targetNode = linker.processAugmentXpathLinking(augment.getTargetNode(), node);
        }
    }
    assertThat(true, is(targetNode.getName().equals(targetNodeName)));
}
#method_after
@Test
public void processIntraFileLinkingInSubModuleMultiLevel() throws IOException {
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(INTRA_FILE_PATH + "IntraMultiSubModule/"));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    linkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    linkerManager.linkSubModulesToParentModule(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    YangNode targetNode = null;
    String targetNodeName = null;
    for (YangNode node : utilManager.getYangNodeSet()) {
        List<YangAugment> augments = linker.getListOfYangAugment(node);
        for (YangAugment augment : augments) {
            targetNodeName = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier().getName();
            targetNode = linker.processAugmentXpathLinking(augment.getTargetNode(), node);
        }
    }
    assertThat(true, is(targetNode.getName().equals(targetNodeName)));
}
#end_block

#method_before
@Test
public void processInterFileLinkingInSubModuleSingleLevel() throws IOException {
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(INTER_FILE_PATH + "InterSingleSubModule/"));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    linkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    YangNode targetNode = null;
    String targetNodeName = null;
    for (YangNode node : utilManager.getYangNodeSet()) {
        List<YangAugment> augments = linker.getListOfYangAugment(node);
        for (YangAugment augment : augments) {
            targetNodeName = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier().getName();
            targetNode = linker.processAugmentXpathLinking(augment.getTargetNode(), node);
        }
    }
    assertThat(true, is(targetNode.getName().equals(targetNodeName)));
}
#method_after
@Test
public void processInterFileLinkingInSubModuleSingleLevel() throws IOException {
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(INTER_FILE_PATH + "InterSingleSubModule/"));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    linkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    linkerManager.linkSubModulesToParentModule(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    YangNode targetNode = null;
    String targetNodeName = null;
    for (YangNode node : utilManager.getYangNodeSet()) {
        List<YangAugment> augments = linker.getListOfYangAugment(node);
        for (YangAugment augment : augments) {
            targetNodeName = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier().getName();
            targetNode = linker.processAugmentXpathLinking(augment.getTargetNode(), node);
        }
    }
    assertThat(true, is(targetNode.getName().equals(targetNodeName)));
}
#end_block

#method_before
@Test
public void processInterFileLinkingInSubModuleMultiLevel() throws IOException {
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(INTER_FILE_PATH + "InterMultiSubModule/"));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    linkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    linkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    YangNode targetNode = null;
    String targetNodeName = null;
    for (YangNode node : utilManager.getYangNodeSet()) {
        List<YangAugment> augments = linker.getListOfYangAugment(node);
        for (YangAugment augment : augments) {
            targetNodeName = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier().getName();
            targetNode = linker.processAugmentXpathLinking(augment.getTargetNode(), node);
        }
    }
    assertThat(true, is(targetNode.getName().equals(targetNodeName)));
}
#method_after
@Test
public void processInterFileLinkingInSubModuleMultiLevel() throws IOException {
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(INTER_FILE_PATH + "InterMultiSubModule/"));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    linkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    linkerManager.linkSubModulesToParentModule(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    linkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    linkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    YangNode targetNode = null;
    String targetNodeName = null;
    for (YangNode node : utilManager.getYangNodeSet()) {
        List<YangAugment> augments = linker.getListOfYangAugment(node);
        for (YangAugment augment : augments) {
            targetNodeName = augment.getTargetNode().get(augment.getTargetNode().size() - 1).getNodeIdentifier().getName();
            targetNode = linker.processAugmentXpathLinking(augment.getTargetNode(), node);
        }
    }
    assertThat(true, is(targetNode.getName().equals(targetNodeName)));
}
#end_block

#method_before
private List<YangAbsolutePath> getAbsPaths() {
    return absPaths;
}
#method_after
private List<YangAtomicPath> getAbsPaths() {
    return absPaths;
}
#end_block

#method_before
private void setAbsPaths(List<YangAbsolutePath> absPaths) {
    this.absPaths = absPaths;
}
#method_after
private void setAbsPaths(List<YangAtomicPath> absPaths) {
    this.absPaths = absPaths;
}
#end_block

#method_before
public Map<YangAbsolutePath, YangNode> getResolvedNodes() {
    return resolvedNodes;
}
#method_after
public Map<YangAtomicPath, YangNode> getResolvedNodes() {
    return resolvedNodes;
}
#end_block

#method_before
private void setResolvedNodes(Map<YangAbsolutePath, YangNode> resolvedNodes) {
    this.resolvedNodes = resolvedNodes;
}
#method_after
private void setResolvedNodes(Map<YangAtomicPath, YangNode> resolvedNodes) {
    this.resolvedNodes = resolvedNodes;
}
#end_block

#method_before
private void addToResolvedNodes(YangAbsolutePath path, YangNode node) {
    getResolvedNodes().put(path, node);
}
#method_after
private void addToResolvedNodes(YangAtomicPath path, YangNode node) {
    getResolvedNodes().put(path, node);
}
#end_block

#method_before
public T processLeafRefXpathLinking(List<YangAbsolutePath> absPaths, YangNode root) {
    YangNode targetNode = null;
    setRootNode(root);
    YangAbsolutePath leafRefPath = absPaths.get(absPaths.size() - 1);
    if (absPaths.size() == 1) {
        targetNode = getTargetNodewhenSizeIsOne(absPaths);
    } else {
        absPaths.remove(absPaths.size() - 1);
        setAbsPaths(absPaths);
        targetNode = parseData(root);
    }
    if (targetNode == null) {
        targetNode = parsePath(getIncludedNode(root));
    }
    if (targetNode != null) {
        YangLeaf targetLeaf = searchReferredLeaf(targetNode, leafRefPath.getNodeIdentifier().getName());
        if (targetLeaf == null) {
            YangLeafList targetLeafList = searchReferredLeafList(targetNode, leafRefPath.getNodeIdentifier().getName());
            if (targetLeafList != null) {
                return (T) targetLeafList;
            } else {
                throw new LinkerException("YANG file error: Unable to find base leaf/leaf-list for given leafref " + leafRefPath.getNodeIdentifier().getName());
            }
        }
        return (T) targetLeaf;
    }
    return null;
}
#method_after
public T processLeafRefXpathLinking(List<YangAtomicPath> absPaths, YangNode root) {
    YangNode targetNode = null;
    setRootNode(root);
    YangAtomicPath leafRefPath = absPaths.get(absPaths.size() - 1);
    // When leaf-ref path contains only one absolute path.
    if (absPaths.size() == 1) {
        targetNode = getTargetNodewhenSizeIsOne(absPaths);
    } else {
        absPaths.remove(absPaths.size() - 1);
        setAbsPaths(absPaths);
        targetNode = parseData(root);
    }
    if (targetNode == null) {
        targetNode = parsePath(getIncludedNode(root));
    }
    if (targetNode != null) {
        YangLeaf targetLeaf = searchReferredLeaf(targetNode, leafRefPath.getNodeIdentifier().getName());
        if (targetLeaf == null) {
            YangLeafList targetLeafList = searchReferredLeafList(targetNode, leafRefPath.getNodeIdentifier().getName());
            if (targetLeafList != null) {
                return (T) targetLeafList;
            } else {
                throw new LinkerException("YANG file error: Unable to find base leaf/leaf-list for given leafref " + leafRefPath.getNodeIdentifier().getName());
            }
        }
        return (T) targetLeaf;
    }
    return null;
}
#end_block

#method_before
private YangNode getTargetNodewhenSizeIsOne(List<YangAbsolutePath> absPaths) {
    if (absPaths.get(0).getNodeIdentifier().getPrefix() != null && !absPaths.get(0).getNodeIdentifier().getPrefix().equals(getRootsPrefix(getRootNode()))) {
        return getImportedNode(getRootNode(), absPaths.get(0).getNodeIdentifier());
    }
    return getRootNode();
}
#method_after
private YangNode getTargetNodewhenSizeIsOne(List<YangAtomicPath> absPaths) {
    if (absPaths.get(0).getNodeIdentifier().getPrefix() != null && !absPaths.get(0).getNodeIdentifier().getPrefix().equals(getRootsPrefix(getRootNode()))) {
        return getImportedNode(getRootNode(), absPaths.get(0).getNodeIdentifier());
    }
    return getRootNode();
}
#end_block

#method_before
public YangNode processAugmentXpathLinking(List<YangAbsolutePath> absPaths, YangNode root) {
    setAbsPaths(absPaths);
    setRootNode(root);
    YangNode targetNode = parseData(root);
    if (targetNode == null) {
        targetNode = parsePath(getIncludedNode(root));
    }
    return targetNode;
}
#method_after
public YangNode processAugmentXpathLinking(List<YangAtomicPath> absPaths, YangNode root) {
    setAbsPaths(absPaths);
    setRootNode(root);
    YangNode targetNode = parseData(root);
    if (targetNode == null) {
        targetNode = parsePath(getIncludedNode(root));
    }
    return targetNode;
}
#end_block

#method_before
private YangNode parseData(YangNode root) {
    String rootPrefix = getRootsPrefix(root);
    Iterator<YangAbsolutePath> pathIterator = getAbsPaths().iterator();
    YangAbsolutePath path = pathIterator.next();
    if (path.getNodeIdentifier().getPrefix() != null && !path.getNodeIdentifier().getPrefix().equals(rootPrefix)) {
        return parsePath(getImportedNode(root, path.getNodeIdentifier()));
    } else {
        return parsePath(root);
    }
}
#method_after
private YangNode parseData(YangNode root) {
    String rootPrefix = getRootsPrefix(root);
    Iterator<YangAtomicPath> pathIterator = getAbsPaths().iterator();
    YangAtomicPath path = pathIterator.next();
    if (path.getNodeIdentifier().getPrefix() != null && !path.getNodeIdentifier().getPrefix().equals(rootPrefix)) {
        return parsePath(getImportedNode(root, path.getNodeIdentifier()));
    } else {
        return parsePath(root);
    }
}
#end_block

#method_before
private YangNode parsePath(YangNode root) {
    YangNode tempNode = root;
    Stack<YangNode> linkerStack = new Stack<>();
    Iterator<YangAbsolutePath> pathIterator = getAbsPaths().iterator();
    YangAbsolutePath tempPath = pathIterator.next();
    setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
    int index = 0;
    YangNode tempAugment = null;
    do {
        if (tempNode instanceof YangUses) {
            tempNode = handleUsesNode(tempNode, tempPath.getNodeIdentifier());
            if (pathIterator.hasNext()) {
                tempPath = pathIterator.next();
                index++;
            } else {
                addToResolvedNodes(tempPath, tempNode);
                return tempNode;
            }
        }
        if (tempPath.getNodeIdentifier().getPrefix() == null) {
            tempAugment = resolveIntraFileAugment(tempPath, root);
        } else {
            tempAugment = resolveInterFileAugment(tempPath, root);
        }
        if (tempAugment != null) {
            linkerStack.push(tempNode);
            tempNode = tempAugment;
        }
        tempNode = searchTargetNode(tempNode, tempPath.getNodeIdentifier());
        if (tempNode == null && linkerStack.size() != 0) {
            tempNode = linkerStack.peek();
            linkerStack.pop();
            tempNode = searchTargetNode(tempNode, tempPath.getNodeIdentifier());
        }
        if (tempNode != null) {
            addToResolvedNodes(tempPath, tempNode);
        }
        if (index == getAbsPaths().size() - 1) {
            break;
        }
        tempPath = pathIterator.next();
        index++;
    } while (validate(tempNode, index));
    return tempNode;
}
#method_after
private YangNode parsePath(YangNode root) {
    YangNode tempNode = root;
    Stack<YangNode> linkerStack = new Stack<>();
    Iterator<YangAtomicPath> pathIterator = getAbsPaths().iterator();
    YangAtomicPath tempPath = pathIterator.next();
    setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
    int index = 0;
    YangNode tempAugment = null;
    do {
        if (tempNode instanceof YangUses) {
            tempNode = handleUsesNode(tempNode, tempPath.getNodeIdentifier());
            if (pathIterator.hasNext()) {
                tempPath = pathIterator.next();
                index++;
            } else {
                addToResolvedNodes(tempPath, tempNode);
                return tempNode;
            }
        }
        if (tempPath.getNodeIdentifier().getPrefix() == null) {
            tempAugment = resolveIntraFileAugment(tempPath, root);
        } else {
            tempAugment = resolveInterFileAugment(tempPath, root);
        }
        if (tempAugment != null) {
            linkerStack.push(tempNode);
            tempNode = tempAugment;
        }
        tempNode = searchTargetNode(tempNode, tempPath.getNodeIdentifier());
        if (tempNode == null && linkerStack.size() != 0) {
            tempNode = linkerStack.peek();
            linkerStack.pop();
            tempNode = searchTargetNode(tempNode, tempPath.getNodeIdentifier());
        }
        if (tempNode != null) {
            addToResolvedNodes(tempPath, tempNode);
        }
        if (index == getAbsPaths().size() - 1) {
            break;
        }
        tempPath = pathIterator.next();
        index++;
    } while (validate(tempNode, index));
    return tempNode;
}
#end_block

#method_before
private YangNode resolveIntraFileAugment(YangAbsolutePath tempPath, YangNode root) {
    YangNode tempAugment = null;
    setPrefixResolverType(PrefixResolverType.NO_PREFIX_CHANGE_FOR_INTRA);
    if (getCurPrefix() != tempPath.getNodeIdentifier().getPrefix()) {
        setPrefixResolverType(PrefixResolverType.INTRA_TO_INTER);
        root = getIncludedNode(getRootNode());
    }
    setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
    tempAugment = getAugment(tempPath.getNodeIdentifier(), root, getAbsPaths());
    if (tempAugment == null) {
        tempAugment = getAugment(tempPath.getNodeIdentifier(), getRootNode(), getAbsPaths());
    }
    return tempAugment;
}
#method_after
private YangNode resolveIntraFileAugment(YangAtomicPath tempPath, YangNode root) {
    YangNode tempAugment = null;
    setPrefixResolverType(PrefixResolverType.NO_PREFIX_CHANGE_FOR_INTRA);
    if (getCurPrefix() != tempPath.getNodeIdentifier().getPrefix()) {
        setPrefixResolverType(PrefixResolverType.INTRA_TO_INTER);
        root = getIncludedNode(getRootNode());
    }
    setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
    tempAugment = getAugment(tempPath.getNodeIdentifier(), root, getAbsPaths());
    if (tempAugment == null) {
        tempAugment = getAugment(tempPath.getNodeIdentifier(), getRootNode(), getAbsPaths());
    }
    return tempAugment;
}
#end_block

#method_before
private YangNode resolveInterFileAugment(YangAbsolutePath tempPath, YangNode root) {
    YangNode tempAugment = null;
    if (tempPath.getNodeIdentifier().getPrefix().equals(getCurPrefix())) {
        setPrefixResolverType(PrefixResolverType.NO_PREFIX_CHANGE_FOR_INTER);
    } else {
        setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
        setPrefixResolverType(PrefixResolverType.INTER_TO_INTER);
        if (getCurPrefix() == null) {
            setPrefixResolverType(PrefixResolverType.INTER_TO_INTRA);
        }
        root = getImportedNode(getRootNode(), tempPath.getNodeIdentifier());
    }
    tempAugment = getAugment(tempPath.getNodeIdentifier(), root, getAbsPaths());
    if (tempAugment == null && getPrefixResolverType().equals(PrefixResolverType.INTER_TO_INTER)) {
        return resolveInterToInterFileAugment(root);
    }
    return tempAugment;
}
#method_after
private YangNode resolveInterFileAugment(YangAtomicPath tempPath, YangNode root) {
    YangNode tempAugment = null;
    if (tempPath.getNodeIdentifier().getPrefix().equals(getCurPrefix())) {
        setPrefixResolverType(PrefixResolverType.NO_PREFIX_CHANGE_FOR_INTER);
    } else {
        setCurPrefix(tempPath.getNodeIdentifier().getPrefix());
        setPrefixResolverType(PrefixResolverType.INTER_TO_INTER);
        if (getCurPrefix() == null) {
            setPrefixResolverType(PrefixResolverType.INTER_TO_INTRA);
        }
        root = getImportedNode(getRootNode(), tempPath.getNodeIdentifier());
    }
    tempAugment = getAugment(tempPath.getNodeIdentifier(), root, getAbsPaths());
    if (tempAugment == null && getPrefixResolverType().equals(PrefixResolverType.INTER_TO_INTER)) {
        return resolveInterToInterFileAugment(root);
    }
    return tempAugment;
}
#end_block

#method_before
private YangNode resolveInterToInterFileAugment(YangNode root) {
    List<YangAugment> augments = getListOfYangAugment(root);
    int index;
    List<YangAbsolutePath> absPaths = new ArrayList<>();
    for (YangAugment augment : augments) {
        index = 0;
        for (YangAbsolutePath path : augment.getTargetNode()) {
            if (!searchForAugmentInImportedNode(path.getNodeIdentifier(), index)) {
                absPaths.clear();
                break;
            }
            absPaths.add(path);
            index++;
        }
        if (!absPaths.isEmpty() && absPaths.size() == getAbsPaths().size() - 1) {
            return augment;
        } else {
            absPaths.clear();
        }
    }
    return null;
}
#method_after
private YangNode resolveInterToInterFileAugment(YangNode root) {
    List<YangAugment> augments = getListOfYangAugment(root);
    int index;
    List<YangAtomicPath> absPaths = new ArrayList<>();
    for (YangAugment augment : augments) {
        index = 0;
        for (YangAtomicPath path : augment.getTargetNode()) {
            if (!searchForAugmentInImportedNode(path.getNodeIdentifier(), index)) {
                absPaths.clear();
                break;
            }
            absPaths.add(path);
            index++;
        }
        if (!absPaths.isEmpty() && absPaths.size() == getAbsPaths().size() - 1) {
            return augment;
        } else {
            absPaths.clear();
        }
    }
    return null;
}
#end_block

#method_before
private YangNode getAugment(YangNodeIdentifier tempNodeId, YangNode root, List<YangAbsolutePath> absPaths) {
    String augmentName = getAugmentNodeIdentifier(tempNodeId, absPaths);
    if (augmentName != null) {
        return searchAugmentNode(root, augmentName);
    }
    return null;
}
#method_after
private YangNode getAugment(YangNodeIdentifier tempNodeId, YangNode root, List<YangAtomicPath> absPaths) {
    String augmentName = getAugmentNodeIdentifier(tempNodeId, absPaths);
    if (augmentName != null) {
        return searchAugmentNode(root, augmentName);
    }
    return null;
}
#end_block

#method_before
private String getAugmentNodeIdentifier(YangNodeIdentifier nodeId, List<YangAbsolutePath> absPaths) {
    Iterator<YangAbsolutePath> nodeIdIterator = absPaths.iterator();
    YangAbsolutePath tempNodeId = null;
    StringBuilder builder = new StringBuilder();
    while (nodeIdIterator.hasNext()) {
        tempNodeId = nodeIdIterator.next();
        if (!tempNodeId.getNodeIdentifier().equals(nodeId)) {
            if (tempNodeId.getNodeIdentifier().getPrefix() != null && (getPrefixResolverType().equals(PrefixResolverType.INTER_TO_INTER) || getPrefixResolverType().equals(PrefixResolverType.INTRA_TO_INTER))) {
                builder.append("/" + tempNodeId.getNodeIdentifier().getPrefix());
                builder.append(":" + tempNodeId.getNodeIdentifier().getName());
            } else {
                builder.append("/" + tempNodeId.getNodeIdentifier().getName());
            }
        } else {
            return builder.toString();
        }
    }
    return null;
}
#method_after
private String getAugmentNodeIdentifier(YangNodeIdentifier nodeId, List<YangAtomicPath> absPaths) {
    Iterator<YangAtomicPath> nodeIdIterator = absPaths.iterator();
    YangAtomicPath tempNodeId = null;
    StringBuilder builder = new StringBuilder();
    while (nodeIdIterator.hasNext()) {
        tempNodeId = nodeIdIterator.next();
        if (!tempNodeId.getNodeIdentifier().equals(nodeId)) {
            if (tempNodeId.getNodeIdentifier().getPrefix() != null && (getPrefixResolverType().equals(PrefixResolverType.INTER_TO_INTER) || getPrefixResolverType().equals(PrefixResolverType.INTRA_TO_INTER))) {
                builder.append("/" + tempNodeId.getNodeIdentifier().getPrefix());
                builder.append(":" + tempNodeId.getNodeIdentifier().getName());
            } else {
                builder.append("/" + tempNodeId.getNodeIdentifier().getName());
            }
        } else {
            return builder.toString();
        }
    }
    return null;
}
#end_block

#method_before
@Test
public void processManagerTranslator() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/manager";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    utilManager.resolveDependenciesUsingLinker();
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir("target/manager/");
    yangPluginConfig.setManagerCodeGenDir("target/manager/");
    utilManager.translateToJava(utilManager.getYangFileInfoSet(), yangPluginConfig);
    String file1 = "target/manager/org/onosproject/yang/gen/v1/test5/test/rev20160704/Test5Manager.java";
    String file2 = "target/manager/org/onosproject/yang/gen/v1/test5/test/rev20160704/Test6Manager.java";
    String file3 = "target/manager/org/onosproject/yang/gen/v1/test5/test/rev20160705/Test7Manager.java";
    File manager = new File(file1);
    assertThat(false, is(manager.exists()));
    File manager2 = new File(file2);
    assertThat(false, is(manager2.exists()));
    File manager3 = new File(file3);
    assertThat(true, is(manager3.exists()));
    deleteDirectory("target/manager/");
}
#method_after
@Test
public void processManagerTranslator() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/manager";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    utilManager.resolveDependenciesUsingLinker();
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir("target/manager/");
    yangPluginConfig.setManagerCodeGenDir("target/manager/");
    utilManager.translateToJava(utilManager.getYangFileInfoSet(), yangPluginConfig);
    String file1 = "target/manager/org/onosproject/yang/gen/v1/test5/test/rev20160704/Test5Manager.java";
    String file2 = "target/manager/org/onosproject/yang/gen/v1/test5/test/rev20160704/Test6Manager.java";
    String file3 = "target/manager/org/onosproject/yang/gen/v1/test5/test/rev20160704/Test7Manager.java";
    File manager = new File(file1);
    assertThat(false, is(manager.exists()));
    File manager2 = new File(file2);
    assertThat(false, is(manager2.exists()));
    File manager3 = new File(file3);
    assertThat(true, is(manager3.exists()));
    deleteDirectory("target/manager/");
}
#end_block

#method_before
@Test
public void processManagerInDifferentPackageTranslator() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/manager";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    utilManager.resolveDependenciesUsingLinker();
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir("target/manager/");
    yangPluginConfig.setManagerCodeGenDir("target/manager1/");
    utilManager.translateToJava(utilManager.getYangFileInfoSet(), yangPluginConfig);
    String file3 = "target/manager1/org/onosproject/yang/gen/v1/test5/test/rev20160705/Test7Manager.java";
    File manager3 = new File(file3);
    assertThat(true, is(manager3.exists()));
    deleteDirectory("target/manager/");
    deleteDirectory("target/manager1/");
}
#method_after
@Test
public void processManagerInDifferentPackageTranslator() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/manager";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    utilManager.resolveDependenciesUsingLinker();
    YangPluginConfig yangPluginConfig = new YangPluginConfig();
    yangPluginConfig.setCodeGenDir("target/manager/");
    yangPluginConfig.setManagerCodeGenDir("target/manager1/");
    utilManager.translateToJava(utilManager.getYangFileInfoSet(), yangPluginConfig);
    String file3 = "target/manager1/org/onosproject/yang/gen/v1/test5/test/rev20160704/Test7Manager.java";
    File manager3 = new File(file3);
    assertThat(true, is(manager3.exists()));
    deleteDirectory("target/manager/");
    deleteDirectory("target/manager1/");
}
#end_block

#method_before
@Override
public void addAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.add(augmentInfo);
}
#method_after
@Override
public void addAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.add(augmentInfo);
}
#end_block

#method_before
@Override
public void removeAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.remove(augmentInfo);
}
#method_after
@Override
public void removeAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.remove(augmentInfo);
}
#end_block

#method_before
@Override
public List<AugmentedInfo> getAugmentedInfoList() {
    return augmentedInfo;
}
#method_after
@Override
public List<YangAugmentedInfo> getAugmentedInfoList() {
    return yangAugmentedInfo;
}
#end_block

#method_before
@Override
public void addAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.add(augmentInfo);
}
#method_after
@Override
public void addAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.add(augmentInfo);
}
#end_block

#method_before
@Override
public void removeAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.remove(augmentInfo);
}
#method_after
@Override
public void removeAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.remove(augmentInfo);
}
#end_block

#method_before
@Override
public List<AugmentedInfo> getAugmentedInfoList() {
    return augmentedInfo;
}
#method_after
@Override
public List<YangAugmentedInfo> getAugmentedInfoList() {
    return yangAugmentedInfo;
}
#end_block

#method_before
@Override
public void addAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.add(augmentInfo);
}
#method_after
@Override
public void addAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.add(augmentInfo);
}
#end_block

#method_before
@Override
public void removeAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.remove(augmentInfo);
}
#method_after
@Override
public void removeAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.remove(augmentInfo);
}
#end_block

#method_before
@Override
public List<AugmentedInfo> getAugmentedInfoList() {
    return augmentedInfo;
}
#method_after
@Override
public List<YangAugmentedInfo> getAugmentedInfoList() {
    return yangAugmentedInfo;
}
#end_block

#method_before
public static void validatePathArgument(String pathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    String completePathString = removeQuotesAndHandleConcat(pathString);
    yangLeafRef.setPath(completePathString);
    if (completePathString.startsWith(SLASH)) {
        yangLeafRef.setPathType(ABSOLUTE_PATH);
        List<YangAbsolutePath> yangAbsoluteList = validateAbsolutePath(completePathString, yangConstruct, ctx, yangLeafRef);
        yangLeafRef.setAbsolutePath(yangAbsoluteList);
    } else if (completePathString.startsWith(ANCESTOR_ACCESSOR)) {
        yangLeafRef.setPathType(RELATIVE_PATH);
        validateRelativePath(completePathString, yangConstruct, ctx, yangLeafRef);
    } else {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
}
#method_after
public static void validatePathArgument(String pathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    String completePathString = removeQuotesAndHandleConcat(pathString);
    yangLeafRef.setPath(completePathString);
    if (completePathString.startsWith(SLASH)) {
        yangLeafRef.setPathType(ABSOLUTE_PATH);
        List<YangAtomicPath> yangAtomicPathListList = validateAbsolutePath(completePathString, yangConstruct, ctx, yangLeafRef);
        yangLeafRef.setAtomicPath(yangAtomicPathListList);
    } else if (completePathString.startsWith(ANCESTOR_ACCESSOR)) {
        yangLeafRef.setPathType(RELATIVE_PATH);
        validateRelativePath(completePathString, yangConstruct, ctx, yangLeafRef);
    } else {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
}
#end_block

#method_before
private static void validateRelativePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath relativePath = new YangRelativePath();
    int numberOfAncestors = 0;
    while (completePathString.startsWith(ANCESTOR_ACCESSOR_IN_PATH)) {
        completePathString = completePathString.replaceFirst(ANCESTOR_ACCESSOR_IN_PATH, EMPTY_STRING);
        numberOfAncestors = numberOfAncestors + 1;
    }
    if (completePathString == null || completePathString.length() == 0) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    relativePath.setAncestorNodeCount(numberOfAncestors);
    List<YangAbsolutePath> absolutePathList = validateAbsolutePath(SLASH_FOR_STRING + completePathString, yangConstruct, ctx, yangLeafRef);
    relativePath.setAbsolutePath(absolutePathList);
    yangLeafRef.setRelativePath(relativePath);
}
#method_after
private static void validateRelativePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath relativePath = new YangRelativePath();
    int numberOfAncestors = 0;
    while (completePathString.startsWith(ANCESTOR_ACCESSOR_IN_PATH)) {
        completePathString = completePathString.replaceFirst(ANCESTOR_ACCESSOR_IN_PATH, EMPTY_STRING);
        numberOfAncestors = numberOfAncestors + 1;
    }
    if (completePathString == null || completePathString.length() == 0) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    relativePath.setAncestorNodeCount(numberOfAncestors);
    List<YangAtomicPath> atomicPath = validateAbsolutePath(SLASH_FOR_STRING + completePathString, yangConstruct, ctx, yangLeafRef);
    relativePath.setAtomicPathList(atomicPath);
    yangLeafRef.setRelativePath(relativePath);
}
#end_block

#method_before
private static List<YangAbsolutePath> validateAbsolutePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAbsolutePath> absolutePathList = new LinkedList<>();
    YangPathPredicate yangPathPredicate = new YangPathPredicate();
    YangNodeIdentifier yangNodeIdentifier;
    while (completePathString != null) {
        String path = completePathString.replaceFirst(SLASH_FOR_STRING, EMPTY_STRING);
        if (path == null || path.length() == 0) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
            parserException.setLine(ctx.getStart().getLine());
            parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw parserException;
        }
        String matchedPathPredicate;
        String nodeIdentifier;
        String[] differentiate = new String[2];
        int forNodeIdentifier = path.indexOf(CHAR_OF_SLASH);
        int forPathPredicate = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
        // Checks if path predicate is present for the node.
        if ((forPathPredicate < forNodeIdentifier) && (forPathPredicate != -1)) {
            List<String> pathPredicate = new ArrayList<>();
            matchedPathPredicate = matchForPathPredicate(path);
            if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            int indexOfMatchedFirstOpenBrace = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
            differentiate[0] = path.substring(0, indexOfMatchedFirstOpenBrace);
            differentiate[1] = path.substring(indexOfMatchedFirstOpenBrace);
            pathPredicate.add(matchedPathPredicate);
            nodeIdentifier = differentiate[0];
            // Starts adding all path predicates of a node into the list.
            if (!differentiate[1].isEmpty()) {
                while (differentiate[1].startsWith(OPEN_SQUARE_BRACKET)) {
                    matchedPathPredicate = matchForPathPredicate(differentiate[1]);
                    if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                        parserException.setLine(ctx.getStart().getLine());
                        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                        throw parserException;
                    }
                    pathPredicate.add(matchedPathPredicate);
                    differentiate[1] = differentiate[1].substring(matchedPathPredicate.length());
                }
            }
            List<YangPathPredicate> pathPredicateList = validatePathPredicate(pathPredicate, yangConstruct, ctx, yangPathPredicate, yangLeafRef);
            YangAbsolutePath absolutePaths = new YangAbsolutePath();
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            absolutePaths.setNodeIdentifier(yangNodeIdentifier);
            absolutePaths.setPredicatesExp(pathPredicateList);
            absolutePathList.add(absolutePaths);
        } else {
            if (path.contains(SLASH_FOR_STRING)) {
                nodeIdentifier = path.substring(0, path.indexOf(CHAR_OF_SLASH));
                differentiate[1] = path.substring(path.indexOf(CHAR_OF_SLASH));
            } else {
                nodeIdentifier = path;
                differentiate[1] = null;
            }
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            YangAbsolutePath absolutePaths = new YangAbsolutePath();
            absolutePaths.setNodeIdentifier(yangNodeIdentifier);
            absolutePaths.setPredicatesExp(null);
            absolutePathList.add(absolutePaths);
        }
        if (differentiate[1] == null || differentiate[1].length() == 0) {
            completePathString = null;
        } else {
            completePathString = differentiate[1];
        }
    }
    return absolutePathList;
}
#method_after
private static List<YangAtomicPath> validateAbsolutePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAtomicPath> absolutePathList = new LinkedList<>();
    YangPathPredicate yangPathPredicate = new YangPathPredicate();
    YangNodeIdentifier yangNodeIdentifier;
    while (completePathString != null) {
        String path = completePathString.replaceFirst(SLASH_FOR_STRING, EMPTY_STRING);
        if (path == null || path.length() == 0) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
            parserException.setLine(ctx.getStart().getLine());
            parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw parserException;
        }
        String matchedPathPredicate;
        String nodeIdentifier;
        String[] differentiate = new String[2];
        int forNodeIdentifier = path.indexOf(CHAR_OF_SLASH);
        int forPathPredicate = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
        // Checks if path predicate is present for the node.
        if ((forPathPredicate < forNodeIdentifier) && (forPathPredicate != -1)) {
            List<String> pathPredicate = new ArrayList<>();
            matchedPathPredicate = matchForPathPredicate(path);
            if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            int indexOfMatchedFirstOpenBrace = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
            differentiate[0] = path.substring(0, indexOfMatchedFirstOpenBrace);
            differentiate[1] = path.substring(indexOfMatchedFirstOpenBrace);
            pathPredicate.add(matchedPathPredicate);
            nodeIdentifier = differentiate[0];
            // Starts adding all path predicates of a node into the list.
            if (!differentiate[1].isEmpty()) {
                while (differentiate[1].startsWith(OPEN_SQUARE_BRACKET)) {
                    matchedPathPredicate = matchForPathPredicate(differentiate[1]);
                    if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                        parserException.setLine(ctx.getStart().getLine());
                        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                        throw parserException;
                    }
                    pathPredicate.add(matchedPathPredicate);
                    differentiate[1] = differentiate[1].substring(matchedPathPredicate.length());
                }
            }
            List<YangPathPredicate> pathPredicateList = validatePathPredicate(pathPredicate, yangConstruct, ctx, yangPathPredicate, yangLeafRef);
            YangAtomicPath atomicPath = new YangAtomicPath();
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            atomicPath.setNodeIdentifier(yangNodeIdentifier);
            atomicPath.setPathPredicatesList(pathPredicateList);
            absolutePathList.add(atomicPath);
        } else {
            if (path.contains(SLASH_FOR_STRING)) {
                nodeIdentifier = path.substring(0, path.indexOf(CHAR_OF_SLASH));
                differentiate[1] = path.substring(path.indexOf(CHAR_OF_SLASH));
            } else {
                nodeIdentifier = path;
                differentiate[1] = null;
            }
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            YangAtomicPath atomicPath = new YangAtomicPath();
            atomicPath.setNodeIdentifier(yangNodeIdentifier);
            atomicPath.setPathPredicatesList(null);
            absolutePathList.add(atomicPath);
        }
        if (differentiate[1] == null || differentiate[1].length() == 0) {
            completePathString = null;
        } else {
            completePathString = differentiate[1];
        }
    }
    return absolutePathList;
}
#end_block

#method_before
private static YangRelativePath validatePathKeyExpression(String rightRelativePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath yangRelativePath = new YangRelativePath();
    String[] relativePath = rightRelativePath.split(SLASH_FOR_STRING);
    List<String> rightAbsolutePath = new ArrayList<>();
    int accessAncestor = 0;
    for (String path : relativePath) {
        if (path.trim().equals(ANCESTOR_ACCESSOR)) {
            accessAncestor = accessAncestor + 1;
        } else {
            rightAbsolutePath.add(path);
        }
    }
    List<YangAbsolutePath> absoluteListInRelativePath = validateRelativePathKeyExpression(rightAbsolutePath, yangConstruct, ctx, yangLeafRef);
    yangRelativePath.setAbsolutePath(absoluteListInRelativePath);
    yangRelativePath.setAncestorNodeCount(accessAncestor);
    return yangRelativePath;
}
#method_after
private static YangRelativePath validatePathKeyExpression(String rightRelativePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath yangRelativePath = new YangRelativePath();
    String[] relativePath = rightRelativePath.split(SLASH_FOR_STRING);
    List<String> rightAbsolutePath = new ArrayList<>();
    int accessAncestor = 0;
    for (String path : relativePath) {
        if (path.trim().equals(ANCESTOR_ACCESSOR)) {
            accessAncestor = accessAncestor + 1;
        } else {
            rightAbsolutePath.add(path);
        }
    }
    List<YangAtomicPath> atomicPathInRelativePath = validateRelativePathKeyExpression(rightAbsolutePath, yangConstruct, ctx, yangLeafRef);
    yangRelativePath.setAtomicPathList(atomicPathInRelativePath);
    yangRelativePath.setAncestorNodeCount(accessAncestor);
    return yangRelativePath;
}
#end_block

#method_before
private static List<YangAbsolutePath> validateRelativePathKeyExpression(List<String> rightAbsolutePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAbsolutePath> absolutePathList = new ArrayList<>();
    YangNodeIdentifier yangNodeIdentifier;
    Iterator<String> nodes = rightAbsolutePath.iterator();
    String currentInvocationFunction = nodes.next();
    currentInvocationFunction = currentInvocationFunction.trim();
    String[] currentFunction = currentInvocationFunction.split("[(]");
    if (!(currentFunction[0].trim().equals(CURRENT)) || !(currentFunction[1].trim().equals(CLOSE_PARENTHESIS))) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    while (nodes.hasNext()) {
        YangAbsolutePath absolutePath = new YangAbsolutePath();
        String node = nodes.next();
        yangNodeIdentifier = getValidNodeIdentifierForLeafref(node.trim(), yangConstruct, ctx, yangLeafRef);
        absolutePath.setNodeIdentifier(yangNodeIdentifier);
        absolutePathList.add(absolutePath);
    }
    return absolutePathList;
}
#method_after
private static List<YangAtomicPath> validateRelativePathKeyExpression(List<String> rightAbsolutePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAtomicPath> atomicPathList = new ArrayList<>();
    YangNodeIdentifier yangNodeIdentifier;
    Iterator<String> nodes = rightAbsolutePath.iterator();
    String currentInvocationFunction = nodes.next();
    currentInvocationFunction = currentInvocationFunction.trim();
    String[] currentFunction = currentInvocationFunction.split("[(]");
    if (!(currentFunction[0].trim().equals(CURRENT)) || !(currentFunction[1].trim().equals(CLOSE_PARENTHESIS))) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    while (nodes.hasNext()) {
        YangAtomicPath atomicPath = new YangAtomicPath();
        String node = nodes.next();
        yangNodeIdentifier = getValidNodeIdentifierForLeafref(node.trim(), yangConstruct, ctx, yangLeafRef);
        atomicPath.setNodeIdentifier(yangNodeIdentifier);
        atomicPathList.add(atomicPath);
    }
    return atomicPathList;
}
#end_block

#method_before
public static List<YangAbsolutePath> getValidAbsoluteSchemaNodeId(String argumentString, YangConstructType yangConstructType, ParserRuleContext ctx) {
    List<YangAbsolutePath> targetNodes = new ArrayList<>();
    YangNodeIdentifier yangNodeIdentifier;
    String tmpSchemaNodeId = removeQuotesAndHandleConcat(argumentString);
    // absolute-schema-nodeid = 1*("/" node-identifier)
    if (!tmpSchemaNodeId.startsWith(SLASH)) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstructType) + " name " + argumentString + "is not valid");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    String[] tmpData = tmpSchemaNodeId.replaceFirst(CARET + SLASH, EMPTY_STRING).split(SLASH);
    for (String nodeIdentifiers : tmpData) {
        yangNodeIdentifier = getValidNodeIdentifier(nodeIdentifiers, yangConstructType, ctx);
        YangAbsolutePath yangAbsPath = new YangAbsolutePath();
        yangAbsPath.setNodeIdentifier(yangNodeIdentifier);
        targetNodes.add(yangAbsPath);
    }
    return targetNodes;
}
#method_after
public static List<YangAtomicPath> getValidAbsoluteSchemaNodeId(String argumentString, YangConstructType yangConstructType, ParserRuleContext ctx) {
    List<YangAtomicPath> targetNodes = new ArrayList<>();
    YangNodeIdentifier yangNodeIdentifier;
    String tmpSchemaNodeId = removeQuotesAndHandleConcat(argumentString);
    // absolute-schema-nodeid = 1*("/" node-identifier)
    if (!tmpSchemaNodeId.startsWith(SLASH)) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstructType) + " name " + argumentString + "is not valid");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    String[] tmpData = tmpSchemaNodeId.replaceFirst(CARET + SLASH, EMPTY_STRING).split(SLASH);
    for (String nodeIdentifiers : tmpData) {
        yangNodeIdentifier = getValidNodeIdentifier(nodeIdentifiers, yangConstructType, ctx);
        YangAtomicPath yangAbsPath = new YangAtomicPath();
        yangAbsPath.setNodeIdentifier(yangNodeIdentifier);
        targetNodes.add(yangAbsPath);
    }
    return targetNodes;
}
#end_block

#method_before
public void addToExtendsList(JavaQualifiedTypeInfo info, YangNode node) {
    JavaFileInfo fileInfo = ((JavaFileInfoContainer) node).getJavaFileInfo();
    JavaImportData importData = getTempJavaFragement(node).getJavaImportData();
    boolean qualified = importData.addImportInfo(info, getCapitalCase(fileInfo.getJavaName()), fileInfo.getPackage());
    /*true means import should be added*/
    getExtendedClassStore().put(info, qualified);
    addToExtendsList(info);
}
#method_after
public void addToExtendsList(JavaQualifiedTypeInfo info, YangNode node) {
    JavaFileInfo fileInfo = ((JavaFileInfoContainer) node).getJavaFileInfo();
    JavaImportData importData = getTempJavaFragment(node).getJavaImportData();
    boolean qualified = importData.addImportInfo(info, getCapitalCase(fileInfo.getJavaName()), fileInfo.getPackage());
    /*true means import should be added*/
    getExtendedClassStore().put(info, qualified);
    addToExtendsList(info);
}
#end_block

#method_before
public List<YangAbsolutePath> getTargetNode() {
    return targetNode;
}
#method_after
public List<YangAtomicPath> getTargetNode() {
    return targetNode;
}
#end_block

#method_before
public void setTargetNode(List<YangAbsolutePath> nodeIdentifiers) {
    targetNode = nodeIdentifiers;
}
#method_after
public void setTargetNode(List<YangAtomicPath> nodeIdentifiers) {
    targetNode = nodeIdentifiers;
}
#end_block

#method_before
private static void write(File file, int genType, JavaDocType javaDocType, YangNode curNode, String fileName) throws IOException {
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getPluginConfig();
    if ((genType & GENERATE_SERVICE_AND_MANAGER) != 0) {
        if (!fileName.matches(REGEX_FOR_ANY_STRING_ENDING_WITH_SERVICE)) {
            insertDataIntoJavaFile(file, getJavaDoc(RPC_MANAGER, fileName, false, pluginConfig));
            insertDataIntoJavaFile(file, addComponentString());
        } else {
            insertDataIntoJavaFile(file, getJavaDoc(javaDocType, fileName, false, pluginConfig));
        }
    } else {
        insertDataIntoJavaFile(file, getJavaDoc(javaDocType, fileName, false, pluginConfig));
    }
    insertDataIntoJavaFile(file, generateClassDefinition(genType, fileName, curNode));
}
#method_after
private static void write(File file, int genType, JavaDocType javaDocType, YangNode curNode, String fileName) throws IOException {
    YangPluginConfig pluginConfig = ((JavaFileInfoContainer) curNode).getJavaFileInfo().getPluginConfig();
    if ((genType & GENERATE_SERVICE_AND_MANAGER) != 0) {
        if (!fileName.matches(REGEX_FOR_ANY_STRING_ENDING_WITH_SERVICE)) {
            insertDataIntoJavaFile(file, getJavaDoc(RPC_MANAGER, fileName, false, pluginConfig));
            insertDataIntoJavaFile(file, JavaCodeSnippetGen.addComponentString());
        } else {
            insertDataIntoJavaFile(file, getJavaDoc(javaDocType, fileName, false, pluginConfig));
        }
    } else {
        insertDataIntoJavaFile(file, getJavaDoc(javaDocType, fileName, false, pluginConfig));
    }
    insertDataIntoJavaFile(file, generateClassDefinition(genType, fileName, curNode));
}
#end_block

#method_before
@Override
public void addAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.add(augmentInfo);
}
#method_after
@Override
public void addAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.add(augmentInfo);
}
#end_block

#method_before
@Override
public void removeAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.remove(augmentInfo);
}
#method_after
@Override
public void removeAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.remove(augmentInfo);
}
#end_block

#method_before
@Override
public List<AugmentedInfo> getAugmentedInfoList() {
    return augmentedInfo;
}
#method_after
@Override
public List<YangAugmentedInfo> getAugmentedInfoList() {
    return yangAugmentedInfo;
}
#end_block

#method_before
@Override
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = getJavaImportData().getImports();
    createPackage(curNode);
    boolean isNotification = false;
    if (curNode instanceof YangJavaModule) {
        if (!((YangJavaModule) curNode).getNotificationNodes().isEmpty()) {
            isNotification = true;
        }
    } else if (curNode instanceof YangJavaSubModule) {
        if (!((YangJavaSubModule) curNode).getNotificationNodes().isEmpty()) {
            isNotification = true;
        }
    }
    if (isNotification) {
        addListnersImport(curNode, imports, true, LISTENER_SERVICE);
    }
    /**
     * Creates rpc interface file.
     */
    setServiceInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(SERVICE_FILE_NAME_SUFFIX)));
    generateServiceInterfaceFile(getServiceInterfaceJavaFileHandle(), curNode, imports, isAttributePresent());
    if (isNotification) {
        addListnersImport(curNode, imports, false, LISTENER_SERVICE);
        addListnersImport(curNode, imports, true, LISTENER_REG);
    }
    addAnnotationsImports(imports, true);
    /**
     * Create builder class file.
     */
    setManagerJavaFileHandle(getJavaFileHandle(getJavaClassName(MANAGER_FILE_NAME_SUFFIX)));
    generateManagerClassFile(getManagerJavaFileHandle(), imports, curNode, isAttributePresent());
    insertDataIntoJavaFile(getManagerJavaFileHandle(), getJavaClassDefClose());
    if (isNotification) {
        addListnersImport(curNode, imports, false, LISTENER_REG);
    }
    addAnnotationsImports(imports, false);
    if (isNotification) {
        generateEventJavaFile(curNode);
        generateEventListenerJavaFile(GENERATE_EVENT_LISTENER_INTERFACE, curNode);
        generateEventSubjectJavaFile(curNode);
    }
    /**
     * Close all the file handles.
     */
    freeTemporaryResources(false);
}
#method_after
@Override
public void generateJavaFile(int fileType, YangNode curNode) throws IOException {
    List<String> imports = getJavaImportData().getImports();
    createPackage(curNode);
    boolean isNotification = false;
    if (curNode instanceof YangJavaModule) {
        if (!((YangJavaModule) curNode).getNotificationNodes().isEmpty()) {
            isNotification = true;
        }
    } else if (curNode instanceof YangJavaSubModule) {
        if (!((YangJavaSubModule) curNode).getNotificationNodes().isEmpty()) {
            isNotification = true;
        }
    }
    if (isNotification) {
        addListenersImport(curNode, imports, true, LISTENER_SERVICE);
    }
    /**
     * Creates rpc interface file.
     */
    setServiceInterfaceJavaFileHandle(getJavaFileHandle(getJavaClassName(SERVICE_FILE_NAME_SUFFIX)));
    generateServiceInterfaceFile(getServiceInterfaceJavaFileHandle(), curNode, imports, isAttributePresent());
    if (isNotification) {
        addListenersImport(curNode, imports, false, LISTENER_SERVICE);
        addListenersImport(curNode, imports, true, LISTENER_REG);
    }
    addAnnotationsImports(imports, true);
    /**
     * Create builder class file.
     */
    setManagerJavaFileHandle(getJavaFileHandle(getJavaClassName(MANAGER_FILE_NAME_SUFFIX)));
    generateManagerClassFile(getManagerJavaFileHandle(), imports, curNode, isAttributePresent());
    insertDataIntoJavaFile(getManagerJavaFileHandle(), getJavaClassDefClose());
    if (isNotification) {
        addListenersImport(curNode, imports, false, LISTENER_REG);
    }
    addAnnotationsImports(imports, false);
    if (isNotification) {
        generateEventJavaFile(curNode);
        generateEventListenerJavaFile(GENERATE_EVENT_LISTENER_INTERFACE, curNode);
        generateEventSubjectJavaFile(curNode);
    }
    /**
     * Close all the file handles.
     */
    freeTemporaryResources(false);
}
#end_block

#method_before
private static void detectCollision(YangNode targetNode, YangAugment augment) {
    YangNode targetNodesChild = targetNode.getChild();
    YangNode augmentsChild = augment.getChild();
    YangLeavesHolder augmentsLeavesHolder = augment;
    YangLeavesHolder targetNodesLeavesHolder = (YangLeavesHolder) targetNode;
    YangNode parent = targetNode;
    while (parent.getParent() != null) {
        parent = parent.getParent();
    }
    if (targetNode instanceof YangAugment) {
        parent = targetNode.getParent();
    }
    if (augmentsLeavesHolder.getListOfLeaf() != null && augmentsLeavesHolder.getListOfLeaf().size() != 0 && targetNodesLeavesHolder.getListOfLeaf() != null) {
        for (YangLeaf leaf : augmentsLeavesHolder.getListOfLeaf()) {
            for (YangLeaf targetLeaf : targetNodesLeavesHolder.getListOfLeaf()) {
                if (targetLeaf.getName().equals(leaf.getName())) {
                    throw new LinkerException("target node " + targetNode.getName() + " contains augmented leaf " + leaf.getName() + " in module " + parent.getName());
                }
            }
        }
    } else if (augmentsLeavesHolder.getListOfLeafList() != null && augmentsLeavesHolder.getListOfLeafList().size() != 0 && targetNodesLeavesHolder.getListOfLeafList() != null) {
        for (YangLeafList leafList : augmentsLeavesHolder.getListOfLeafList()) {
            for (YangLeafList targetLeafList : targetNodesLeavesHolder.getListOfLeafList()) {
                if (targetLeafList.getName().equals(leafList.getName())) {
                    throw new LinkerException("target node " + targetNode.getName() + " contains augmented leaf-list" + leafList.getName() + " in module " + parent.getName());
                }
            }
        }
    } else {
        while (augmentsChild != null) {
            while (targetNodesChild != null) {
                if (targetNodesChild.getName().equals(augmentsChild.getName())) {
                    throw new LinkerException("target node " + targetNode.getName() + " contains augmented child node" + augmentsChild.getName() + " in module " + parent.getName());
                }
                targetNodesChild = targetNodesChild.getNextSibling();
            }
            augmentsChild = augmentsChild.getNextSibling();
        }
    }
}
#method_after
private static void detectCollision(YangNode targetNode, YangAugment augment) {
    YangNode targetNodesChild = targetNode.getChild();
    YangNode augmentsChild = augment.getChild();
    YangLeavesHolder augmentsLeavesHolder = augment;
    YangLeavesHolder targetNodesLeavesHolder = (YangLeavesHolder) targetNode;
    YangNode parent = targetNode;
    if (targetNode instanceof YangAugment) {
        parent = targetNode.getParent();
    } else {
        while (parent.getParent() != null) {
            parent = parent.getParent();
        }
    }
    if (augmentsLeavesHolder.getListOfLeaf() != null && augmentsLeavesHolder.getListOfLeaf().size() != 0 && targetNodesLeavesHolder.getListOfLeaf() != null) {
        for (YangLeaf leaf : augmentsLeavesHolder.getListOfLeaf()) {
            for (YangLeaf targetLeaf : targetNodesLeavesHolder.getListOfLeaf()) {
                if (targetLeaf.getName().equals(leaf.getName())) {
                    throw new LinkerException("target node " + targetNode.getName() + " contains augmented leaf " + leaf.getName() + " in module " + parent.getName());
                }
            }
        }
    } else if (augmentsLeavesHolder.getListOfLeafList() != null && augmentsLeavesHolder.getListOfLeafList().size() != 0 && targetNodesLeavesHolder.getListOfLeafList() != null) {
        for (YangLeafList leafList : augmentsLeavesHolder.getListOfLeafList()) {
            for (YangLeafList targetLeafList : targetNodesLeavesHolder.getListOfLeafList()) {
                if (targetLeafList.getName().equals(leafList.getName())) {
                    throw new LinkerException("target node " + targetNode.getName() + " contains augmented leaf-list" + leafList.getName() + " in module " + parent.getName());
                }
            }
        }
    } else {
        while (augmentsChild != null) {
            while (targetNodesChild != null) {
                if (targetNodesChild.getName().equals(augmentsChild.getName())) {
                    throw new LinkerException("target node " + targetNode.getName() + " contains augmented child node" + augmentsChild.getName() + " in module " + parent.getName());
                }
                targetNodesChild = targetNodesChild.getNextSibling();
            }
            augmentsChild = augmentsChild.getNextSibling();
        }
    }
}
#end_block

#method_before
public static void detectCollisionForAugmentedNode(YangNode targetNode, YangAugment augment) {
    // Detect collision for target node and augment node.
    detectCollision(targetNode, augment);
    List<AugmentedInfo> augmentedInfo = ((AugmentationHolder) targetNode).getAugmentedInfoList();
    // Detect collision for target node and augment node.
    for (AugmentedInfo info : augmentedInfo) {
        detectCollision((YangAugment) info, augment);
    }
}
#method_after
public static void detectCollisionForAugmentedNode(YangNode targetNode, YangAugment augment) {
    // Detect collision for target node and augment node.
    detectCollision(targetNode, augment);
    List<YangAugmentedInfo> yangAugmentedInfo = ((YangAugmentableNode) targetNode).getAugmentedInfoList();
    // Detect collision for target augment node and current augment node.
    for (YangAugmentedInfo info : yangAugmentedInfo) {
        detectCollision((YangAugment) info, augment);
    }
}
#end_block

#method_before
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /*
             * For deleting the generated code in previous build.
             */
        deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        deleteDirectory(getDirectory(baseDir, outputDirectory));
        String searchDir = getDirectory(baseDir, yangFilesDir);
        String codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        String managerCodeGenDir = getDirectory(baseDir, managerFileDir) + SLASH;
        // Creates conflict resolver and set values to it.
        YangToJavaNamingConflictUtil conflictResolver = new YangToJavaNamingConflictUtil();
        conflictResolver.setReplacementForPeriod(replacementForPeriod);
        conflictResolver.setReplacementForHyphen(replacementForHyphen);
        conflictResolver.setReplacementForUnderscore(replacementForUnderscore);
        conflictResolver.setPrefixForIdentifier(prefixForIdentifier);
        YangPluginConfig yangPlugin = new YangPluginConfig();
        yangPlugin.setCodeGenDir(codeGenDir);
        yangPlugin.setManagerCodeGenDir(managerCodeGenDir);
        yangPlugin.setConflictResolver(conflictResolver);
        /*
             * Obtain the YANG files at a path mentioned in plugin and creates
             * YANG file information set.
             */
        createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
        // Check if there are any file to translate, if not return.
        if (getYangFileInfoSet() == null || getYangFileInfoSet().isEmpty()) {
            // No files to translate
            return;
        }
        // Resolve inter jar dependency.
        resolveInterJardependency();
        // Carry out the parsing for all the YANG files.
        parseYangFileInfoSet();
        // Resolve dependencies using linker.
        resolveDependenciesUsingLinker();
        // Perform translation to JAVA.
        translateToJava(getYangFileInfoSet(), yangPlugin);
        // Serialize data model.
        serializeDataModel(getDirectory(baseDir, outputDirectory), getYangFileInfoSet(), project, true);
        addToCompilationRoot(codeGenDir, project, context);
        addToCompilationRoot(managerCodeGenDir, project, context);
        copyYangFilesToTarget(getYangFileInfoSet(), getDirectory(baseDir, outputDirectory), project);
    } catch (IOException | ParserException e) {
        getLog().info(e);
        String fileName = "";
        if (getCurYangFileInfo() != null) {
            fileName = getCurYangFileInfo().getYangFileName();
        }
        try {
            translatorErrorHandler(getRootNode());
            deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        throw new MojoExecutionException("Exception occured due to " + e.getLocalizedMessage() + " in " + fileName + " YANG file.");
    }
}
#method_after
@Override
public void execute() throws MojoExecutionException, MojoFailureException {
    try {
        /*
             * For deleting the generated code in previous build.
             */
        deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        deleteDirectory(getDirectory(baseDir, outputDirectory));
        String searchDir = getDirectory(baseDir, yangFilesDir);
        String codeGenDir = getDirectory(baseDir, classFileDir) + SLASH;
        String managerCodeGenDir = getDirectory(baseDir, managerFileDir) + SLASH;
        // Creates conflict resolver and set values to it.
        YangToJavaNamingConflictUtil conflictResolver = new YangToJavaNamingConflictUtil();
        conflictResolver.setReplacementForPeriod(replacementForPeriod);
        conflictResolver.setReplacementForHyphen(replacementForHyphen);
        conflictResolver.setReplacementForUnderscore(replacementForUnderscore);
        conflictResolver.setPrefixForIdentifier(prefixForIdentifier);
        YangPluginConfig yangPlugin = new YangPluginConfig();
        yangPlugin.setCodeGenDir(codeGenDir);
        yangPlugin.setManagerCodeGenDir(managerCodeGenDir);
        yangPlugin.setConflictResolver(conflictResolver);
        /*
             * Obtain the YANG files at a path mentioned in plugin and creates
             * YANG file information set.
             */
        createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
        // Check if there are any file to translate, if not return.
        if (getYangFileInfoSet() == null || getYangFileInfoSet().isEmpty()) {
            // No files to translate
            return;
        }
        // Resolve inter jar dependency.
        resolveInterJardependency();
        // Carry out the parsing for all the YANG files.
        parseYangFileInfoSet();
        // Resolve dependencies using linker.
        resolveDependenciesUsingLinker();
        // Perform translation to JAVA.
        translateToJava(getYangFileInfoSet(), yangPlugin);
        // Serialize data model.
        serializeDataModel(getDirectory(baseDir, outputDirectory), getYangFileInfoSet(), project, true);
        addToCompilationRoot(codeGenDir, project, context);
        addToCompilationRoot(managerCodeGenDir, project, context);
        copyYangFilesToTarget(getYangFileInfoSet(), getDirectory(baseDir, outputDirectory), project);
    } catch (IOException | ParserException e) {
        String fileName = "";
        if (getCurYangFileInfo() != null) {
            fileName = getCurYangFileInfo().getYangFileName();
        }
        try {
            translatorErrorHandler(getRootNode());
            deleteDirectory(getDirectory(baseDir, classFileDir) + DEFAULT_PKG);
        } catch (IOException ex) {
            throw new MojoExecutionException("Error handler failed to delete files for data model node.");
        }
        throw new MojoExecutionException("Exception occured due to " + e.getLocalizedMessage() + " in " + fileName + " YANG file.");
    }
}
#end_block

#method_before
@Override
public void addAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.add(augmentInfo);
}
#method_after
@Override
public void addAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.add(augmentInfo);
}
#end_block

#method_before
@Override
public void removeAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.remove(augmentInfo);
}
#method_after
@Override
public void removeAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.remove(augmentInfo);
}
#end_block

#method_before
@Override
public List<AugmentedInfo> getAugmentedInfoList() {
    return augmentedInfo;
}
#method_after
@Override
public List<YangAugmentedInfo> getAugmentedInfoList() {
    return yangAugmentedInfo;
}
#end_block

#method_before
@Test
public void getConstructorTest() {
    JavaAttributeInfo testAttr = getTestAttribute();
    YangPluginConfig pluginConfig = new YangPluginConfig();
    String method = getConstructor(CLASS_NAME, testAttr, GENERATE_SERVICE_AND_MANAGER, pluginConfig);
    assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + "builder" + OBJECT + PERIOD + GET_METHOD_PREFIX + "Testname" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN)));
}
#method_after
@Test
public void getConstructorTest() {
    JavaAttributeInfo testAttr = getTestAttribute();
    YangPluginConfig pluginConfig = new YangPluginConfig();
    String method = getConstructor(testAttr, GENERATE_SERVICE_AND_MANAGER, pluginConfig);
    assertThat(true, is(method.contains(THIS + PERIOD + CLASS_NAME + SPACE + EQUAL + SPACE + "builder" + OBJECT + PERIOD + GET_METHOD_PREFIX + "Testname" + OPEN_PARENTHESIS + CLOSE_PARENTHESIS + SEMI_COLAN)));
}
#end_block

#method_before
public static void processAugmentEntry(TreeWalkListener listener, GeneratedYangParser.AugmentStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, AUGMENT_DATA, ctx.augment().getText(), ENTRY);
    // Validate augment argument string
    List<YangAbsolutePath> targetNodes = getValidAbsoluteSchemaNodeId(ctx.augment().getText(), AUGMENT_DATA, ctx);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    // Check for identifier collision
    int line = ctx.getStart().getLine();
    int charPositionInLine = ctx.getStart().getCharPositionInLine();
    detectCollidingChildUtil(listener, line, charPositionInLine, "", AUGMENT_DATA);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangModule || curData instanceof YangSubModule) {
        YangNode curNode = (YangNode) curData;
        YangAugment yangAugment = getYangAugmentNode(JAVA_GENERATION);
        // validateTargetNodePath(targetNodes, curNode, ctx);
        // TODO: handle in linker.
        yangAugment.setTargetNode(targetNodes);
        yangAugment.setName(removeQuotesAndHandleConcat(ctx.augment().getText()));
        try {
            curNode.addChild(yangAugment);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, AUGMENT_DATA, ctx.augment().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangAugment);
        // Add resolution information to the list
        YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangAugment>(yangAugment, curNode, line, charPositionInLine);
        addToResolutionList(resolutionInfo, ctx);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, AUGMENT_DATA, ctx.augment().getText(), ENTRY));
    }
}
#method_after
public static void processAugmentEntry(TreeWalkListener listener, GeneratedYangParser.AugmentStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, AUGMENT_DATA, ctx.augment().getText(), ENTRY);
    // Validate augment argument string
    List<YangAtomicPath> targetNodes = getValidAbsoluteSchemaNodeId(ctx.augment().getText(), AUGMENT_DATA, ctx);
    // Validate sub statement cardinality.
    validateSubStatementsCardinality(ctx);
    // Check for identifier collision
    int line = ctx.getStart().getLine();
    int charPositionInLine = ctx.getStart().getCharPositionInLine();
    detectCollidingChildUtil(listener, line, charPositionInLine, "", AUGMENT_DATA);
    Parsable curData = listener.getParsedDataStack().peek();
    if (curData instanceof YangModule || curData instanceof YangSubModule || curData instanceof YangUses) {
        YangNode curNode = (YangNode) curData;
        YangAugment yangAugment = getYangAugmentNode(JAVA_GENERATION);
        // validateTargetNodePath(targetNodes, curNode, ctx);
        // TODO: handle in linker.
        yangAugment.setTargetNode(targetNodes);
        yangAugment.setName(removeQuotesAndHandleConcat(ctx.augment().getText()));
        try {
            curNode.addChild(yangAugment);
        } catch (DataModelException e) {
            throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, AUGMENT_DATA, ctx.augment().getText(), ENTRY, e.getMessage()));
        }
        listener.getParsedDataStack().push(yangAugment);
        // Add resolution information to the list
        YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangAugment>(yangAugment, curNode, line, charPositionInLine);
        addToResolutionList(resolutionInfo, ctx);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, AUGMENT_DATA, ctx.augment().getText(), ENTRY));
    }
}
#end_block

#method_before
@Override
public void addAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.add(augmentInfo);
}
#method_after
@Override
public void addAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.add(augmentInfo);
}
#end_block

#method_before
@Override
public void removeAugmentation(AugmentedInfo augmentInfo) {
    augmentedInfo.remove(augmentInfo);
}
#method_after
@Override
public void removeAugmentation(YangAugmentedInfo augmentInfo) {
    yangAugmentedInfo.remove(augmentInfo);
}
#end_block

#method_before
@Override
public List<AugmentedInfo> getAugmentedInfoList() {
    return augmentedInfo;
}
#method_after
@Override
public List<YangAugmentedInfo> getAugmentedInfoList() {
    return yangAugmentedInfo;
}
#end_block

#method_before
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = javaFileInfo.getJavaName();
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, pluginConfig);
    /**
     * Add attribute strings.
     */
    try {
        JavaCodeGeneratorInfo javaGeninfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGeninfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    /**
     * Add an
     * attribute to get the enum's values.
     */
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    /**
     * Add a constructor for enum.
     */
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, pluginConfig) + getEnumsConstrcutor(getCapitalCase(className)) + NEW_LINE);
    TempJavaEnumerationFragmentFiles enumFragFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles();
    insertDataIntoJavaFile(file, getEnumsOfMethod(className, enumFragFiles.getJavaAttributeForEnum(pluginConfig), enumFragFiles.getEnumSetJavaMap(), enumFragFiles.getEnumStringList(), pluginConfig) + NEW_LINE);
    /**
     * Add a getter method for enum.
     */
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, pluginConfig) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#method_after
public static File generateEnumClassFile(File file, YangNode curNode) throws IOException {
    JavaFileInfo javaFileInfo = ((JavaFileInfoContainer) curNode).getJavaFileInfo();
    YangPluginConfig pluginConfig = javaFileInfo.getPluginConfig();
    String className = javaFileInfo.getJavaName();
    String path = javaFileInfo.getBaseCodeGenPath() + javaFileInfo.getPackageFilePath();
    initiateJavaFileGeneration(file, getCapitalCase(className), GENERATE_ENUM_CLASS, null, path, pluginConfig);
    /**
     * Add attribute strings.
     */
    try {
        JavaCodeGeneratorInfo javaGeninfo = (JavaCodeGeneratorInfo) curNode;
        insertDataIntoJavaFile(file, trimAtLast(trimAtLast(getDataFromTempFileHandle(ENUM_IMPL_MASK, javaGeninfo.getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path), COMMA), NEW_LINE) + SEMI_COLAN + NEW_LINE);
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    /**
     * Add an
     * attribute to get the enum's values.
     */
    insertDataIntoJavaFile(file, getEnumsValueAttribute(getCapitalCase(className)));
    /**
     * Add a constructor for enum.
     */
    insertDataIntoJavaFile(file, getJavaDoc(TYPE_CONSTRUCTOR, className, false, pluginConfig) + getEnumsConstructor(getCapitalCase(className)) + NEW_LINE);
    TempJavaEnumerationFragmentFiles enumFragFiles = ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles();
    insertDataIntoJavaFile(file, getEnumsOfMethod(className, enumFragFiles.getJavaAttributeForEnum(pluginConfig), enumFragFiles.getEnumSetJavaMap(), enumFragFiles.getEnumStringList(), pluginConfig) + NEW_LINE);
    /**
     * Add a getter method for enum.
     */
    insertDataIntoJavaFile(file, getJavaDoc(GETTER_METHOD, className, false, pluginConfig) + getGetter(INT, className, GENERATE_ENUM_CLASS) + NEW_LINE);
    try {
        insertDataIntoJavaFile(file, getFromStringMethodSignature(getCapitalCase(className), pluginConfig) + getDataFromTempFileHandle(FROM_STRING_IMPL_MASK, ((TempJavaCodeFragmentFilesContainer) curNode).getTempJavaCodeFragmentFiles().getEnumerationTempFiles(), path) + getFromStringMethodClose());
    } catch (IOException e) {
        throw new IOException("No data found in temporary java code fragment files for " + getCapitalCase(className) + " while enum class file generation");
    }
    insertDataIntoJavaFile(file, CLOSE_CURLY_BRACKET + NEW_LINE);
    return validateLineLength(file);
}
#end_block

#method_before
public static String getJavaDataType(YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE;
        case INT16:
            return SHORT;
        case INT32:
            return INT;
        case INT64:
            return LONG;
        case UINT8:
            return SHORT;
        case UINT16:
            return INT;
        case UINT32:
            return LONG;
        case UINT64:
            return BIG_INTEGER;
        case BITS:
            return YANG_BITS_CLASS;
        case BINARY:
            return BYTE + SQUARE_BRACKETS;
        case DECIMAL64:
            return YANG_DECIMAL64_CLASS;
        case STRING:
            return STRING_DATA_TYPE;
        case BOOLEAN:
            return BOOLEAN_DATA_TYPE;
        default:
            throw new TranslatorException("given data type is not supported.");
    }
}
#method_after
public static String getJavaDataType(YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE;
        case INT16:
            return SHORT;
        case INT32:
            return INT;
        case INT64:
            return LONG;
        case UINT8:
            return SHORT;
        case UINT16:
            return INT;
        case UINT32:
            return LONG;
        case UINT64:
            return BIG_INTEGER;
        case BITS:
            return BIT_SET;
        case BINARY:
            return BYTE + SQUARE_BRACKETS;
        case DECIMAL64:
            return BIG_DECIMAL;
        case STRING:
            return STRING_DATA_TYPE;
        case BOOLEAN:
            return BOOLEAN_DATA_TYPE;
        case INSTANCE_IDENTIFIER:
            return STRING_DATA_TYPE;
        case LEAFREF:
            return getJavaDataType(getReferredTypeFromLeafref(yangType));
        default:
            throw new TranslatorException("given data type is not supported.");
    }
}
#end_block

#method_before
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr, YangToJavaNamingConflictUtil pluginConfig) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return YANG_DECIMAL64_CLASS;
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return YANG_BITS_CLASS;
            case BINARY:
                return BYTE + SQUARE_BRACKETS;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return YANG_DECIMAL64_CLASS;
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return YANG_BITS_CLASS;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return BOOLEAN_DATA_TYPE;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                return null;
        }
    }
    return null;
}
#method_after
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr, YangToJavaNamingConflictUtil pluginConfig) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return BIG_DECIMAL;
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return BIT_SET;
            case BINARY:
                return BYTE + SQUARE_BRACKETS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportClass(referredType, isListAttr, pluginConfig);
            case IDENTITYREF:
                YangIdentityRef identityRef = (YangIdentityRef) yangType.getDataTypeExtendedInfo();
                YangIdentity identity = identityRef.getReferredIdentity();
                return getCapitalCase(getCamelCase(((YangJavaIdentity) identity).getName(), pluginConfig));
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                return STRING_DATA_TYPE;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return BIT_SET;
            case DECIMAL64:
                return BIG_DECIMAL;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportClass(referredType, isListAttr, pluginConfig);
            case IDENTITYREF:
                YangIdentityRef identityRef = (YangIdentityRef) yangType.getDataTypeExtendedInfo();
                YangIdentity identity = identityRef.getReferredIdentity();
                return getCapitalCase(getCamelCase(((YangJavaIdentity) identity).getName(), pluginConfig));
            case EMPTY:
                return BOOLEAN_DATA_TYPE;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                return STRING_DATA_TYPE;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                return null;
        }
    }
}
#end_block

#method_before
public static String getJavaImportPackage(YangType<?> yangType, boolean isListAttr, YangToJavaNamingConflictUtil conflictResolver) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
            case INT16:
            case INT32:
            case INT64:
            case UINT8:
            case UINT16:
            case UINT32:
            case STRING:
            case BOOLEAN:
            case EMPTY:
                return JAVA_LANG;
            case UINT64:
                return JAVA_MATH;
            case ENUMERATION:
                return getEnumsPackage(yangType, conflictResolver);
            case DECIMAL64:
                return YANG_TYPES_PKG;
            case BITS:
                return COLLECTION_IMPORTS;
            case BINARY:
                return JAVA_LANG;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case UNION:
                return getUnionPackage(yangType, conflictResolver);
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getTypDefsPackage(yangType, conflictResolver);
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return JAVA_MATH;
            case STRING:
                return JAVA_LANG;
            case ENUMERATION:
                return getEnumsPackage(yangType, conflictResolver);
            case DECIMAL64:
                return YANG_TYPES_PKG;
            case BITS:
                return COLLECTION_IMPORTS;
            case LEAFREF:
                // TODO:LEAFREF
                break;
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return JAVA_LANG;
            case UNION:
                return getUnionPackage(yangType, conflictResolver);
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getTypDefsPackage(yangType, conflictResolver);
            default:
                return null;
        }
    }
    return null;
}
#method_after
public static String getJavaImportPackage(YangType<?> yangType, boolean isListAttr, YangToJavaNamingConflictUtil conflictResolver) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
            case INT16:
            case INT32:
            case INT64:
            case UINT8:
            case UINT16:
            case UINT32:
            case BINARY:
            case STRING:
            case BOOLEAN:
            case EMPTY:
                return JAVA_LANG;
            case UINT64:
            case DECIMAL64:
                return JAVA_MATH;
            case ENUMERATION:
                return getEnumsPackage(yangType, conflictResolver);
            case BITS:
                return COLLECTION_IMPORTS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportPackage(referredType, isListAttr, conflictResolver);
            case IDENTITYREF:
                return getIdentityRefPackage(yangType, conflictResolver);
            case UNION:
                return getUnionPackage(yangType, conflictResolver);
            case INSTANCE_IDENTIFIER:
                return JAVA_LANG;
            case DERIVED:
                return getTypDefsPackage(yangType, conflictResolver);
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
            case DECIMAL64:
                return JAVA_MATH;
            case EMPTY:
            case STRING:
                return JAVA_LANG;
            case ENUMERATION:
                return getEnumsPackage(yangType, conflictResolver);
            case BITS:
                return COLLECTION_IMPORTS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportPackage(referredType, isListAttr, conflictResolver);
            case IDENTITYREF:
                return getIdentityRefPackage(yangType, conflictResolver);
            case UNION:
                return getUnionPackage(yangType, conflictResolver);
            case INSTANCE_IDENTIFIER:
                return JAVA_LANG;
            case DERIVED:
                return getTypDefsPackage(yangType, conflictResolver);
            default:
                return null;
        }
    }
}
#end_block

#method_before
public ResolvableStatus resolve() throws DataModelException {
    YangType<?> baseType = getReferredTypeDef().getTypeDefBaseType();
    /*
         * Checks the data type of the referred typedef, if it's derived, obtain
         * effective built-in type and restrictions from it's derived info,
         * otherwise take from the base type of type itself.
         */
    if (baseType.getDataType() == DERIVED) {
        /*
             * Check whether the referred typedef is resolved.
             */
        if (baseType.getResolvableStatus() != INTRA_FILE_RESOLVED && baseType.getResolvableStatus() != RESOLVED) {
            throw new DataModelException("Linker Error: Referred typedef is not resolved for type.");
        }
        /*
             * Check if the referred typedef is intra file resolved, if yes sets
             * current status also to intra file resolved .
             */
        if (getReferredTypeDef().getTypeDefBaseType().getResolvableStatus() == INTRA_FILE_RESOLVED) {
            return INTRA_FILE_RESOLVED;
        }
        setEffectiveBuiltInType(((YangDerivedInfo<?>) baseType.getDataTypeExtendedInfo()).getEffectiveBuiltInType());
        YangDerivedInfo refDerivedInfo = (YangDerivedInfo<?>) baseType.getDataTypeExtendedInfo();
        /*
             * Check whether the effective built-in type can have range
             * restrictions, if yes call resolution of range.
             */
        if (isOfRangeRestrictedType(getEffectiveBuiltInType())) {
            if (refDerivedInfo.getResolvedExtendedInfo() == null) {
                resolveRangeRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(refDerivedInfo.getResolvedExtendedInfo() instanceof YangRangeRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveRangeRestriction((YangRangeRestriction) refDerivedInfo.getResolvedExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        /*
                 * If the effective built-in type is of type string calls for
                 * string resolution.
                 */
        } else if (getEffectiveBuiltInType() == STRING) {
            if (refDerivedInfo.getResolvedExtendedInfo() == null) {
                resolveStringRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(refDerivedInfo.getResolvedExtendedInfo() instanceof YangStringRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveStringRestriction((YangStringRestriction) refDerivedInfo.getResolvedExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        } else if (getEffectiveBuiltInType() == BINARY) {
            if (refDerivedInfo.getResolvedExtendedInfo() == null) {
                resolveBinaryRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve length restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(refDerivedInfo.getResolvedExtendedInfo() instanceof YangRangeRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveBinaryRestriction((YangRangeRestriction) refDerivedInfo.getResolvedExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve length restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        }
    } else {
        setEffectiveBuiltInType(baseType.getDataType());
        /*
             * Check whether the effective built-in type can have range
             * restrictions, if yes call resolution of range.
             */
        if (isOfRangeRestrictedType(getEffectiveBuiltInType())) {
            if (baseType.getDataTypeExtendedInfo() == null) {
                resolveRangeRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(baseType.getDataTypeExtendedInfo() instanceof YangRangeRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveRangeRestriction((YangRangeRestriction) baseType.getDataTypeExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        /*
                 * If the effective built-in type is of type string calls for
                 * string resolution.
                 */
        } else if (getEffectiveBuiltInType() == STRING) {
            if (baseType.getDataTypeExtendedInfo() == null) {
                resolveStringRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(baseType.getDataTypeExtendedInfo() instanceof YangStringRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveStringRestriction((YangStringRestriction) baseType.getDataTypeExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        } else if (getEffectiveBuiltInType() == BINARY) {
            if (baseType.getDataTypeExtendedInfo() == null) {
                resolveBinaryRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve length restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(baseType.getDataTypeExtendedInfo() instanceof YangRangeRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveBinaryRestriction((YangRangeRestriction) baseType.getDataTypeExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve length restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        }
    }
    /*
         * Check if the data type is the one which can't be restricted, in this
         * case check whether no self restrictions should be present.
         */
    if (isOfValidNonRestrictedType(getEffectiveBuiltInType())) {
        if (Strings.isNullOrEmpty(getLengthRestrictionString()) && Strings.isNullOrEmpty(getRangeRestrictionString()) && getPatternRestriction() == null) {
            return RESOLVED;
        } else {
            throw new DataModelException("YANG file error: Restrictions can't be applied to a given type");
        }
    }
    // Throw exception for unsupported types
    throw new DataModelException("Linker error: Unable to process the derived type.");
}
#method_after
public ResolvableStatus resolve() throws DataModelException {
    YangType<?> baseType = getReferredTypeDef().getTypeDefBaseType();
    /*
         * Checks the data type of the referred typedef, if it's derived, obtain
         * effective built-in type and restrictions from it's derived info,
         * otherwise take from the base type of type itself.
         */
    if (baseType.getDataType() == DERIVED) {
        ResolvableStatus resolvableStatus = resolveTypeDerivedInfo(baseType);
        if (resolvableStatus != null) {
            return resolvableStatus;
        }
    } else if ((baseType.getDataType() == LEAFREF) || (baseType.getDataType() == IDENTITYREF)) {
        setEffectiveBuiltInType(baseType.getDataType());
        return RESOLVED;
    } else {
        setEffectiveBuiltInType(baseType.getDataType());
        /*
             * Check whether the effective built-in type can have range
             * restrictions, if yes call resolution of range.
             */
        if (isOfRangeRestrictedType(getEffectiveBuiltInType())) {
            if (baseType.getDataTypeExtendedInfo() == null) {
                resolveRangeRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(baseType.getDataTypeExtendedInfo() instanceof YangRangeRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveRangeRestriction((YangRangeRestriction) baseType.getDataTypeExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        /*
                 * If the effective built-in type is of type string calls for
                 * string resolution.
                 */
        } else if (getEffectiveBuiltInType() == STRING) {
            if (baseType.getDataTypeExtendedInfo() == null) {
                resolveStringRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(baseType.getDataTypeExtendedInfo() instanceof YangStringRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveStringRestriction((YangStringRestriction) baseType.getDataTypeExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve range/string restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        } else if (getEffectiveBuiltInType() == BINARY) {
            if (baseType.getDataTypeExtendedInfo() == null) {
                resolveBinaryRestriction(null);
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve length restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            } else {
                if (!(baseType.getDataTypeExtendedInfo() instanceof YangRangeRestriction)) {
                    throw new DataModelException("Linker error: Referred typedef restriction info is of invalid " + "type.");
                }
                resolveBinaryRestriction((YangRangeRestriction) baseType.getDataTypeExtendedInfo());
                /*
                     * Return the resolution status as resolved, if it's not
                     * resolve length restriction will throw exception in
                     * previous function.
                     */
                return RESOLVED;
            }
        } else if (getEffectiveBuiltInType() == DECIMAL64) {
            if (baseType.getDataTypeExtendedInfo() != null) {
                if (((YangDecimal64) baseType.getDataTypeExtendedInfo()).getRangeRestrictedExtendedInfo() == null) {
                    resolveRangeRestriction(null);
                    /*
                         * Return the resolution status as resolved, if it's not;
                         * resolve range restriction will throw exception in
                         * previous function.
                         */
                    return RESOLVED;
                } else {
                    if (!(((YangDecimal64) baseType.getDataTypeExtendedInfo()).getRangeRestrictedExtendedInfo() instanceof YangRangeRestriction)) {
                        throw new DataModelException("Linker error: Referred typedef restriction info is" + " of invalid type.");
                    }
                    resolveRangeRestriction((YangRangeRestriction) ((YangDecimal64) baseType.getDataTypeExtendedInfo()).getRangeRestrictedExtendedInfo());
                    /*
                         * Return the resolution status as resolved, if it's not
                         * resolve range/string restriction will throw exception in
                         * previous function.
                         */
                    return RESOLVED;
                }
            } else {
                throw new DataModelException("Linker error: Unable to find type extended info for decimal64.");
            }
        }
    }
    /*
         * Check if the data type is the one which can't be restricted, in this
         * case check whether no self restrictions should be present.
         */
    if (isOfValidNonRestrictedType(getEffectiveBuiltInType())) {
        if (Strings.isNullOrEmpty(getLengthRestrictionString()) && Strings.isNullOrEmpty(getRangeRestrictionString()) && getPatternRestriction() == null) {
            return RESOLVED;
        } else {
            throw new DataModelException("YANG file error: Restrictions can't be applied to a given type");
        }
    }
    // Throw exception for unsupported types
    throw new DataModelException("Linker error: Unable to process the derived type.");
}
#end_block

#method_before
private void resolveBinaryRestriction(YangRangeRestriction refLengthRestriction) throws DataModelException {
    if ((rangeRestrictionString != null) || (patternRestriction != null)) {
        DataModelException dataModelException = new DataModelException("YANG file error: for binary " + "range restriction or pattern restriction is not allowed.");
        dataModelException.setLine(lineNumber);
        dataModelException.setCharPosition(charPositionInLine);
        throw dataModelException;
    }
    // Get the final resolved length restriction
    YangRangeRestriction lengthRestriction = resolveLengthRestriction(refLengthRestriction);
    // Set the lenght restriction.
    setResolvedExtendedInfo((T) lengthRestriction);
}
#method_after
private void resolveBinaryRestriction(YangRangeRestriction refLengthRestriction) throws DataModelException {
    if (rangeRestrictionString != null || patternRestriction != null) {
        DataModelException dataModelException = new DataModelException("YANG file error: for binary " + "range restriction or pattern restriction is not allowed.");
        dataModelException.setLine(lineNumber);
        dataModelException.setCharPosition(charPositionInLine);
        throw dataModelException;
    }
    // Get the final resolved length restriction
    YangRangeRestriction lengthRestriction = resolveLengthRestriction(refLengthRestriction);
    // Set the lenght restriction.
    setResolvedExtendedInfo((T) lengthRestriction);
}
#end_block

#method_before
public static void processIdentityrefEntry(TreeWalkListener listener, GeneratedYangParser.IdentityrefSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, IDENTITYREF_DATA, "", ENTRY);
    if (listener.getParsedDataStack().peek() instanceof YangType) {
        YangIdentityRef identityRef = new YangIdentityRef();
        Parsable typeData = listener.getParsedDataStack().pop();
        YangDataTypes yangDataTypes = ((YangType) typeData).getDataType();
        // Validate node identifier.
        YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(ctx.baseStatement().string().getText(), BASE_DATA, ctx);
        identityRef.setBaseIdentity(nodeIdentifier);
        ((YangType) typeData).setDataTypeExtendedInfo(identityRef);
        int errorLine = ctx.getStart().getLine();
        int errorPosition = ctx.getStart().getCharPositionInLine();
        Parsable tmpData = listener.getParsedDataStack().peek();
        switch(tmpData.getYangConstructType()) {
            case LEAF_DATA:
                if (yangDataTypes == YangDataTypes.IDENTITYREF) {
                    // Pop the stack entry to obtain the parent YANG node.
                    Parsable leaf = listener.getParsedDataStack().pop();
                    Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
                    // Push the popped entry back to the stack.
                    listener.getParsedDataStack().push(leaf);
                    // Verify parent node of leaf
                    if (!(parentNodeOfLeaf instanceof YangNode)) {
                        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
                    }
                    identityRef.setResolvableStatus(UNRESOLVED);
                    // Add resolution information to the list
                    YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangIdentityRef>(identityRef, (YangNode) parentNodeOfLeaf, errorLine, errorPosition);
                    addToResolutionList(resolutionInfo, ctx);
                }
                break;
            case LEAF_LIST_DATA:
                if (yangDataTypes == YangDataTypes.IDENTITYREF) {
                    // Pop the stack entry to obtain the parent YANG node.
                    Parsable leafList = listener.getParsedDataStack().pop();
                    Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
                    // Push the popped entry back to the stack.
                    listener.getParsedDataStack().push(leafList);
                    // Verify parent node of leaf
                    if (!(parentNodeOfLeafList instanceof YangNode)) {
                        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
                    }
                    identityRef.setResolvableStatus(UNRESOLVED);
                    // Add resolution information to the list
                    YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangIdentityRef>(identityRef, (YangNode) parentNodeOfLeafList, errorLine, errorPosition);
                    addToResolutionList(resolutionInfo, ctx);
                }
                break;
            case UNION_DATA:
                if (yangDataTypes == YangDataTypes.IDENTITYREF) {
                    Parsable parentNodeOfUnionNode = listener.getParsedDataStack().peek();
                    // Verify parent node of leaf
                    if (!(parentNodeOfUnionNode instanceof YangNode)) {
                        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
                    }
                    identityRef.setResolvableStatus(UNRESOLVED);
                    // Add resolution information to the list
                    YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangIdentityRef>(identityRef, (YangNode) parentNodeOfUnionNode, errorLine, errorPosition);
                    addToResolutionList(resolutionInfo, ctx);
                }
                break;
            case TYPEDEF_DATA:
                if (yangDataTypes == YangDataTypes.IDENTITYREF) {
                    identityRef.setResolvableStatus(UNRESOLVED);
                }
                break;
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
        }
        listener.getParsedDataStack().push(typeData);
        listener.getParsedDataStack().push(identityRef);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, "", ENTRY));
    }
}
#method_after
public static void processIdentityrefEntry(TreeWalkListener listener, GeneratedYangParser.IdentityrefSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, IDENTITYREF_DATA, "", ENTRY);
    if (listener.getParsedDataStack().peek() instanceof YangType) {
        YangIdentityRef identityRef = new YangIdentityRef();
        Parsable typeData = listener.getParsedDataStack().pop();
        YangDataTypes yangDataTypes = ((YangType) typeData).getDataType();
        YangResolutionInfoImpl resolutionInfo;
        // Validate node identifier.
        YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(ctx.baseStatement().string().getText(), BASE_DATA, ctx);
        identityRef.setBaseIdentity(nodeIdentifier);
        ((YangType) typeData).setDataTypeExtendedInfo(identityRef);
        int errorLine = ctx.getStart().getLine();
        int errorPosition = ctx.getStart().getCharPositionInLine();
        Parsable tmpData = listener.getParsedDataStack().peek();
        switch(tmpData.getYangConstructType()) {
            case LEAF_DATA:
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leaf = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leaf);
                // Verify parent node of leaf
                if (!(parentNodeOfLeaf instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
                }
                identityRef.setResolvableStatus(UNRESOLVED);
                // Add resolution information to the list
                resolutionInfo = new YangResolutionInfoImpl<YangIdentityRef>(identityRef, (YangNode) parentNodeOfLeaf, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
                break;
            case LEAF_LIST_DATA:
                // Pop the stack entry to obtain the parent YANG node.
                Parsable leafList = listener.getParsedDataStack().pop();
                Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
                // Push the popped entry back to the stack.
                listener.getParsedDataStack().push(leafList);
                // Verify parent node of leaf
                if (!(parentNodeOfLeafList instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
                }
                identityRef.setResolvableStatus(UNRESOLVED);
                // Add resolution information to the list
                resolutionInfo = new YangResolutionInfoImpl<YangIdentityRef>(identityRef, (YangNode) parentNodeOfLeafList, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
                break;
            case UNION_DATA:
                Parsable parentNodeOfUnionNode = listener.getParsedDataStack().peek();
                // Verify parent node of leaf
                if (!(parentNodeOfUnionNode instanceof YangNode)) {
                    throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
                }
                identityRef.setResolvableStatus(UNRESOLVED);
                // Add resolution information to the list
                resolutionInfo = new YangResolutionInfoImpl<YangIdentityRef>(identityRef, (YangNode) parentNodeOfUnionNode, errorLine, errorPosition);
                addToResolutionList(resolutionInfo, ctx);
                break;
            case TYPEDEF_DATA:
                /**
                 * Do not add the identity ref to resolution list. It needs to be
                 * added to resolution list, when leaf/leaf list references to
                 * this typedef. At this time that leaf/leaf-list becomes the
                 * parent for the identityref.
                 */
                break;
            default:
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, ctx.getText(), EXIT));
        }
        listener.getParsedDataStack().push(typeData);
        listener.getParsedDataStack().push(identityRef);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, IDENTITYREF_DATA, "", ENTRY));
    }
}
#end_block

#method_before
@Test
public void processIdentityrefType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/IdentityListener.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("IdentityListener"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("tunnel"));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("tunnel-type"));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling().getNextSibling();
    assertThat(yangIdentity.getName(), is("ref-address-family"));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling().getNextSibling().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling().getNextSibling().getNextSibling().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether identityref type got resolved.
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processIdentityrefType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/IdentityListener.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("IdentityListener"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("tunnel"));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("tunnel-type"));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling().getNextSibling();
    assertThat(yangIdentity.getName(), is("ref-address-family"));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling().getNextSibling().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling().getNextSibling().getNextSibling().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether identityref type got resolved.
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processIdentityTypedefStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/IdentityTypedef.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("tunnel"));
    YangTypeDef typedef = (YangTypeDef) yangNode.getChild().getNextSibling();
    assertThat(typedef.getName(), is("type15"));
    YangType type = typedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.IDENTITYREF));
    assertThat(type.getDataTypeName(), is("identityref"));
    YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
    assertThat(identityRef.getName(), is("tunnel"));
    assertThat(identityRef.getBaseIdentity().getName(), is("tunnel"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel-value"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("tunnel"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("tunnel"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("tunnel"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processIdentityTypedefStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/IdentityTypedef.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("tunnel"));
    YangTypeDef typedef = (YangTypeDef) yangNode.getChild().getNextSibling();
    assertThat(typedef.getName(), is("type15"));
    YangType type = typedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.IDENTITYREF));
    assertThat(type.getDataTypeName(), is("identityref"));
    YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
    assertThat(identityRef.getName(), is("tunnel"));
    assertThat(identityRef.getBaseIdentity().getName(), is("tunnel"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel-value"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("tunnel"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("tunnel"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("tunnel"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Override
public void addReferencesToIncludeList(Set<YangNode> yangNodeSet) throws DataModelException {
    Iterator<YangInclude> includeInfoIterator = getIncludeList().iterator();
    // Run through the included list to add references.
    while (includeInfoIterator.hasNext()) {
        YangInclude yangInclude = includeInfoIterator.next();
        YangSubModule subModule = null;
        try {
            subModule = yangInclude.addReferenceToInclude(yangNodeSet);
        } catch (DataModelException e) {
            throw e;
        }
        // Check if the referred sub-modules parent is self
        if (!(subModule.getBelongsTo().getModuleNode() == this)) {
            yangInclude.reportIncludeError();
        }
    }
}
#method_after
@Override
public void addReferencesToIncludeList(Set<YangNode> yangNodeSet) throws DataModelException {
    Iterator<YangInclude> includeInfoIterator = getIncludeList().iterator();
    // Run through the included list to add references.
    while (includeInfoIterator.hasNext()) {
        YangInclude yangInclude = includeInfoIterator.next();
        YangSubModule subModule = null;
        subModule = yangInclude.addReferenceToInclude(yangNodeSet);
        // Check if the referred sub-modules parent is self
        if (!(subModule.getBelongsTo().getModuleNode() == this)) {
            yangInclude.reportIncludeError();
        }
    }
}
#end_block

#method_before
@Override
public void resolve() throws DataModelException {
    // Check if the derived info is present.
    YangIdentity identity = getReferedIdentity();
    if (identity == null) {
        throw new DataModelException("Linker Error: Identity information is missing.");
    }
    while (identity.getBaseNode() != null) {
        if (identity.getBaseNode().getResolvableStatus() != ResolvableStatus.RESOLVED) {
            setResolvableStatus(ResolvableStatus.INTRA_FILE_RESOLVED);
            return;
        }
        identity = identity.getBaseNode().getReferredIdentity();
    }
}
#method_after
@Override
public void resolve() throws DataModelException {
    // Check if the derived info is present.
    YangIdentity identity = getReferredIdentity();
    if (identity == null) {
        throw new DataModelException("Linker Error: Identity information is missing.");
    }
    while (identity.getBaseNode() != null) {
        if (identity.getBaseNode().getResolvableStatus() != ResolvableStatus.RESOLVED) {
            setResolvableStatus(ResolvableStatus.INTRA_FILE_RESOLVED);
            return;
        }
        identity = identity.getBaseNode().getReferredIdentity();
    }
}
#end_block

#method_before
@Test
public void processIdentityInImportedFile() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentityimport";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("IdentityIntraFile")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("IdentityInModule")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("IdentityIntraFile"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processIdentityInImportedFile() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentityimport";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("IdentityIntraFile")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("IdentityInModule")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("IdentityIntraFile"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processIdentityInIncludedFile() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentityinlude";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Carry out linking of sub module with module.
    yangLinkerManager.linkSubModulesToParentModule(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Add references to include list.
    yangLinkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("syslog3")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("syslog4")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("syslog3"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processIdentityInIncludedFile() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentityinlude";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Carry out linking of sub module with module.
    yangLinkerManager.linkSubModulesToParentModule(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Add references to include list.
    yangLinkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("syslog3")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("syslog4")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("syslog3"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processIdentityInImportedFileWithDependency() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentityimportdependency";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("syslog1")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("syslog2")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("syslog1"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processIdentityInImportedFileWithDependency() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentityimportdependency";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("syslog1")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("syslog2")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("syslog1"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processIdentityInIncludedFileWithDependency() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentityincludedependency";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Carry out linking of sub module with module.
    yangLinkerManager.linkSubModulesToParentModule(utilManager.getYangNodeSet());
    // Add references to include list.
    yangLinkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("syslog1")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("syslog2")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("syslog1"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processIdentityInIncludedFileWithDependency() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentityincludedependency";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Carry out linking of sub module with module.
    yangLinkerManager.linkSubModulesToParentModule(utilManager.getYangNodeSet());
    // Add references to include list.
    yangLinkerManager.addRefToYangFilesIncludeList(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("syslog1")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("syslog2")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("syslog1"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
@Test
public void processIdentityTypedefUnresolvedInImportedFile() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentitytypedef";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("IdentityIntraFile")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("IdentityInModule")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("IdentityIntraFile"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    YangTypeDef typedef = (YangTypeDef) yangNode.getChild().getNextSibling().getNextSibling();
    assertThat(typedef.getName(), is("type15"));
    YangType type = typedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.IDENTITYREF));
    assertThat(type.getDataTypeName(), is("identityref"));
    YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
    assertThat(identityRef.getName(), is("ref-address-family"));
    assertThat(identityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(identityRef.getResolvableStatus(), is(ResolvableStatus.UNRESOLVED));
}
#method_after
@Test
public void processIdentityTypedefUnresolvedInImportedFile() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentitytypedef";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("IdentityIntraFile")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("IdentityInModule")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("IdentityIntraFile"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    YangTypeDef typedef = (YangTypeDef) yangNode.getChild().getNextSibling().getNextSibling();
    assertThat(typedef.getName(), is("type15"));
    YangType type = typedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.IDENTITYREF));
    assertThat(type.getDataTypeName(), is("identityref"));
    YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
    assertThat(identityRef.getName(), is("ref-address-family"));
    assertThat(identityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(identityRef.getResolvableStatus(), is(ResolvableStatus.UNRESOLVED));
}
#end_block

#method_before
@Test
public void processIdentityTypedefInImportedFile() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentitytypedef";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("IdentityTypedef")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("IdentityInModule")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("IdentityTypedef"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    YangTypeDef typedef = (YangTypeDef) yangNode.getChild().getNextSibling().getNextSibling();
    assertThat(typedef.getName(), is("type15"));
    YangType type = typedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.IDENTITYREF));
    assertThat(type.getDataTypeName(), is("identityref"));
    YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
    assertThat(identityRef.getName(), is("ref-address-family"));
    assertThat(identityRef.getBaseIdentity().getName(), is("ref-address-family"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferedIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#method_after
@Test
public void processIdentityTypedefInImportedFile() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileidentitytypedef";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("IdentityTypedef")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("IdentityInModule")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("IdentityTypedef"));
    YangIdentity yangIdentity = (YangIdentity) yangNode.getChild();
    assertThat(yangIdentity.getName(), is("ipv4-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    yangIdentity = (YangIdentity) yangNode.getChild().getNextSibling();
    assertThat(yangIdentity.getName(), is("ipv6-address-family"));
    assertThat(yangIdentity.getBaseNode().getBaseIdentifier().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentity.getBaseNode().getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    YangTypeDef typedef = (YangTypeDef) yangNode.getChild().getNextSibling().getNextSibling();
    assertThat(typedef.getName(), is("type15"));
    YangType type = typedef.getTypeList().iterator().next();
    assertThat(type.getDataType(), is(YangDataTypes.IDENTITYREF));
    assertThat(type.getDataTypeName(), is("identityref"));
    YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
    assertThat(identityRef.getName(), is("ref-address-family"));
    assertThat(identityRef.getBaseIdentity().getName(), is("ref-address-family"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("tunnel"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    YangIdentityRef yangIdentityRef = (YangIdentityRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(yangIdentityRef.getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getBaseIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getReferredIdentity().getName(), is("ref-address-family"));
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    ListIterator<YangLeafList> leafListIterator = yangNode.getListOfLeafList().listIterator();
    YangLeafList leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("identityref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.IDENTITYREF));
    yangIdentityRef = (YangIdentityRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(yangIdentityRef.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
}
#end_block

#method_before
public static String getValidIdentifierForLeafref(String identifier, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    String identifierString = removeQuotesAndHandleConcat(identifier);
    ParserException parserException;
    if (identifierString.length() > IDENTIFIER_LENGTH) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " is " + "greater than 64 characters.");
    } else if (!IDENTIFIER_PATTERN.matcher(identifierString).matches()) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " is not " + "valid.");
    } else if (identifierString.toLowerCase().startsWith(XML)) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " must not start with (('X'|'x') ('M'|'m') ('L'|'l')).");
    } else {
        return identifierString;
    }
    parserException.setLine(ctx.getStart().getLine());
    parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
    throw parserException;
}
#method_after
public static String getValidIdentifierForLeafref(String identifier, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    String identifierString = removeQuotesAndHandleConcat(identifier);
    ParserException parserException;
    if (identifierString.length() > IDENTIFIER_LENGTH) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " is " + "greater than 64 characters.");
    } else if (!IDENTIFIER_PATTERN.matcher(identifierString).matches()) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " is not " + "valid.");
    } else if (identifierString.toLowerCase().startsWith(XML)) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " must not start with (('X'|'x') ('M'|'m') ('L'|'l')).");
    } else {
        return identifierString;
    }
    parserException.setLine(ctx.getStart().getLine());
    parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
    throw parserException;
}
#end_block

#method_before
public static void validatePathArgument(String pathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    String completePathString = removeQuotesAndHandleConcat(pathString);
    yangLeafRef.setPath(completePathString);
    if (completePathString.startsWith(SLASH)) {
        yangLeafRef.setPathType(ABSOLUTE_PATH);
        List<YangAbsolutePath> yangAbsoluteList = validateAbsolutePath(completePathString, yangConstruct, ctx, yangLeafRef);
        yangLeafRef.setAbsolutePath(yangAbsoluteList);
    } else if (completePathString.startsWith(ANCESTOR_ACCESSOR)) {
        yangLeafRef.setPathType(RELATIVE_PATH);
        validateRelativePath(completePathString, yangConstruct, ctx, yangLeafRef);
    } else {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
}
#method_after
public static void validatePathArgument(String pathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    String completePathString = removeQuotesAndHandleConcat(pathString);
    yangLeafRef.setPath(completePathString);
    if (completePathString.startsWith(SLASH)) {
        yangLeafRef.setPathType(ABSOLUTE_PATH);
        List<YangAtomicPath> yangAtomicPathListList = validateAbsolutePath(completePathString, yangConstruct, ctx, yangLeafRef);
        yangLeafRef.setAtomicPath(yangAtomicPathListList);
    } else if (completePathString.startsWith(ANCESTOR_ACCESSOR)) {
        yangLeafRef.setPathType(RELATIVE_PATH);
        validateRelativePath(completePathString, yangConstruct, ctx, yangLeafRef);
    } else {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
}
#end_block

#method_before
private static void validateRelativePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath relativePath = new YangRelativePath();
    int numberOfAncestors = 0;
    while (completePathString.startsWith(ANCESTOR_ACCESSOR_IN_PATH)) {
        completePathString = completePathString.replaceFirst(ANCESTOR_ACCESSOR_IN_PATH, EMPTY_STRING);
        numberOfAncestors = numberOfAncestors + 1;
    }
    if (completePathString == null || completePathString.length() == 0) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    relativePath.setAncestor(numberOfAncestors);
    List<YangAbsolutePath> absolutePathList = validateAbsolutePath(SLASH_FOR_STRING + completePathString, yangConstruct, ctx, yangLeafRef);
    relativePath.setAbsolutePath(absolutePathList);
    yangLeafRef.setRelativePath(relativePath);
}
#method_after
private static void validateRelativePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath relativePath = new YangRelativePath();
    int numberOfAncestors = 0;
    while (completePathString.startsWith(ANCESTOR_ACCESSOR_IN_PATH)) {
        completePathString = completePathString.replaceFirst(ANCESTOR_ACCESSOR_IN_PATH, EMPTY_STRING);
        numberOfAncestors = numberOfAncestors + 1;
    }
    if (completePathString == null || completePathString.length() == 0) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    relativePath.setAncestorNodeCount(numberOfAncestors);
    List<YangAtomicPath> atomicPath = validateAbsolutePath(SLASH_FOR_STRING + completePathString, yangConstruct, ctx, yangLeafRef);
    relativePath.setAtomicPathList(atomicPath);
    yangLeafRef.setRelativePath(relativePath);
}
#end_block

#method_before
private static List<YangAbsolutePath> validateAbsolutePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAbsolutePath> absolutePathList = new LinkedList<>();
    YangPathPredicate yangPathPredicate = new YangPathPredicate();
    YangNodeIdentifier yangNodeIdentifier;
    while (completePathString != null) {
        String path = completePathString.replaceFirst(SLASH_FOR_STRING, EMPTY_STRING);
        if (path == null || path.length() == 0) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
            parserException.setLine(ctx.getStart().getLine());
            parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw parserException;
        }
        String matchedPathPredicate;
        String nodeIdentifier;
        String[] differentiate = new String[2];
        int forNodeIdentifier = path.indexOf(CHAR_OF_SLASH);
        int forPathPredicate = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
        // Checks if path predicate is present for the node.
        if ((forPathPredicate < forNodeIdentifier) && (forPathPredicate != -1)) {
            List<String> pathPredicate = new ArrayList<>();
            matchedPathPredicate = matchForPathPredicate(path);
            if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            int indexOfMatchedFirstOpenBrace = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
            differentiate[0] = path.substring(0, indexOfMatchedFirstOpenBrace);
            differentiate[1] = path.substring(indexOfMatchedFirstOpenBrace);
            pathPredicate.add(matchedPathPredicate);
            nodeIdentifier = differentiate[0];
            // Starts adding all path predicates of a node into the list.
            if (!differentiate[1].isEmpty()) {
                while (differentiate[1].startsWith(OPEN_SQUARE_BRACKET)) {
                    matchedPathPredicate = matchForPathPredicate(differentiate[1]);
                    if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                        parserException.setLine(ctx.getStart().getLine());
                        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                        throw parserException;
                    }
                    pathPredicate.add(matchedPathPredicate);
                    differentiate[1] = differentiate[1].substring(matchedPathPredicate.length());
                }
            }
            List<YangPathPredicate> pathPredicateList = validatePathPredicate(pathPredicate, yangConstruct, ctx, yangPathPredicate, yangLeafRef);
            YangAbsolutePath absolutePaths = new YangAbsolutePath();
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            absolutePaths.setNodeIdentifier(yangNodeIdentifier);
            absolutePaths.setPredicatesExp(pathPredicateList);
            absolutePathList.add(absolutePaths);
        } else {
            if (path.contains(SLASH_FOR_STRING)) {
                nodeIdentifier = path.substring(0, path.indexOf(CHAR_OF_SLASH));
                differentiate[1] = path.substring(path.indexOf(CHAR_OF_SLASH));
            } else {
                nodeIdentifier = path;
                differentiate[1] = null;
            }
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            YangAbsolutePath absolutePaths = new YangAbsolutePath();
            absolutePaths.setNodeIdentifier(yangNodeIdentifier);
            absolutePaths.setPredicatesExp(null);
            absolutePathList.add(absolutePaths);
        }
        if (differentiate[1] == null || differentiate[1].length() == 0) {
            completePathString = null;
        } else {
            completePathString = differentiate[1];
        }
    }
    return absolutePathList;
}
#method_after
private static List<YangAtomicPath> validateAbsolutePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAtomicPath> absolutePathList = new LinkedList<>();
    YangPathPredicate yangPathPredicate = new YangPathPredicate();
    YangNodeIdentifier yangNodeIdentifier;
    while (completePathString != null) {
        String path = completePathString.replaceFirst(SLASH_FOR_STRING, EMPTY_STRING);
        if (path == null || path.length() == 0) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
            parserException.setLine(ctx.getStart().getLine());
            parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw parserException;
        }
        String matchedPathPredicate;
        String nodeIdentifier;
        String[] differentiate = new String[2];
        int forNodeIdentifier = path.indexOf(CHAR_OF_SLASH);
        int forPathPredicate = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
        // Checks if path predicate is present for the node.
        if ((forPathPredicate < forNodeIdentifier) && (forPathPredicate != -1)) {
            List<String> pathPredicate = new ArrayList<>();
            matchedPathPredicate = matchForPathPredicate(path);
            if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            int indexOfMatchedFirstOpenBrace = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
            differentiate[0] = path.substring(0, indexOfMatchedFirstOpenBrace);
            differentiate[1] = path.substring(indexOfMatchedFirstOpenBrace);
            pathPredicate.add(matchedPathPredicate);
            nodeIdentifier = differentiate[0];
            // Starts adding all path predicates of a node into the list.
            if (!differentiate[1].isEmpty()) {
                while (differentiate[1].startsWith(OPEN_SQUARE_BRACKET)) {
                    matchedPathPredicate = matchForPathPredicate(differentiate[1]);
                    if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                        parserException.setLine(ctx.getStart().getLine());
                        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                        throw parserException;
                    }
                    pathPredicate.add(matchedPathPredicate);
                    differentiate[1] = differentiate[1].substring(matchedPathPredicate.length());
                }
            }
            List<YangPathPredicate> pathPredicateList = validatePathPredicate(pathPredicate, yangConstruct, ctx, yangPathPredicate, yangLeafRef);
            YangAtomicPath atomicPath = new YangAtomicPath();
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            atomicPath.setNodeIdentifier(yangNodeIdentifier);
            atomicPath.setPathPredicatesList(pathPredicateList);
            absolutePathList.add(atomicPath);
        } else {
            if (path.contains(SLASH_FOR_STRING)) {
                nodeIdentifier = path.substring(0, path.indexOf(CHAR_OF_SLASH));
                differentiate[1] = path.substring(path.indexOf(CHAR_OF_SLASH));
            } else {
                nodeIdentifier = path;
                differentiate[1] = null;
            }
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            YangAtomicPath atomicPath = new YangAtomicPath();
            atomicPath.setNodeIdentifier(yangNodeIdentifier);
            atomicPath.setPathPredicatesList(null);
            absolutePathList.add(atomicPath);
        }
        if (differentiate[1] == null || differentiate[1].length() == 0) {
            completePathString = null;
        } else {
            completePathString = differentiate[1];
        }
    }
    return absolutePathList;
}
#end_block

#method_before
private static YangRelativePath validatePathKeyExpression(String rightRelativePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath yangRelativePath = new YangRelativePath();
    String[] relativePath = rightRelativePath.split(SLASH_FOR_STRING);
    List<String> rightAbsolutePath = new ArrayList<>();
    int accessAncestor = 0;
    for (String path : relativePath) {
        if (path.trim().equals(ANCESTOR_ACCESSOR)) {
            accessAncestor = accessAncestor + 1;
        } else {
            rightAbsolutePath.add(path);
        }
    }
    List<YangAbsolutePath> absoluteListInRelativePath = validateRelativePathKeyExpression(rightAbsolutePath, yangConstruct, ctx, yangLeafRef);
    yangRelativePath.setAbsolutePath(absoluteListInRelativePath);
    yangRelativePath.setAncestor(accessAncestor);
    return yangRelativePath;
}
#method_after
private static YangRelativePath validatePathKeyExpression(String rightRelativePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath yangRelativePath = new YangRelativePath();
    String[] relativePath = rightRelativePath.split(SLASH_FOR_STRING);
    List<String> rightAbsolutePath = new ArrayList<>();
    int accessAncestor = 0;
    for (String path : relativePath) {
        if (path.trim().equals(ANCESTOR_ACCESSOR)) {
            accessAncestor = accessAncestor + 1;
        } else {
            rightAbsolutePath.add(path);
        }
    }
    List<YangAtomicPath> atomicPathInRelativePath = validateRelativePathKeyExpression(rightAbsolutePath, yangConstruct, ctx, yangLeafRef);
    yangRelativePath.setAtomicPathList(atomicPathInRelativePath);
    yangRelativePath.setAncestorNodeCount(accessAncestor);
    return yangRelativePath;
}
#end_block

#method_before
private static List<YangAbsolutePath> validateRelativePathKeyExpression(List<String> rightAbsolutePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAbsolutePath> absolutePathList = new ArrayList<>();
    YangNodeIdentifier yangNodeIdentifier;
    Iterator<String> nodes = rightAbsolutePath.iterator();
    String currentInvocationFunction = nodes.next();
    currentInvocationFunction = currentInvocationFunction.trim();
    String[] currentFunction = currentInvocationFunction.split("[(]");
    if (!(currentFunction[0].trim().equals("current")) || !(currentFunction[1].trim().equals(")"))) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    while (nodes.hasNext()) {
        YangAbsolutePath absolutePath = new YangAbsolutePath();
        String node = nodes.next();
        yangNodeIdentifier = getValidNodeIdentifierForLeafref(node.trim(), yangConstruct, ctx, yangLeafRef);
        absolutePath.setNodeIdentifier(yangNodeIdentifier);
        absolutePathList.add(absolutePath);
    }
    return absolutePathList;
}
#method_after
private static List<YangAtomicPath> validateRelativePathKeyExpression(List<String> rightAbsolutePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAtomicPath> atomicPathList = new ArrayList<>();
    YangNodeIdentifier yangNodeIdentifier;
    Iterator<String> nodes = rightAbsolutePath.iterator();
    String currentInvocationFunction = nodes.next();
    currentInvocationFunction = currentInvocationFunction.trim();
    String[] currentFunction = currentInvocationFunction.split("[(]");
    if (!(currentFunction[0].trim().equals(CURRENT)) || !(currentFunction[1].trim().equals(CLOSE_PARENTHESIS))) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    while (nodes.hasNext()) {
        YangAtomicPath atomicPath = new YangAtomicPath();
        String node = nodes.next();
        yangNodeIdentifier = getValidNodeIdentifierForLeafref(node.trim(), yangConstruct, ctx, yangLeafRef);
        atomicPath.setNodeIdentifier(yangNodeIdentifier);
        atomicPathList.add(atomicPath);
    }
    return atomicPathList;
}
#end_block

#method_before
@Override
public void resolveLinkingForResolutionInfo(YangReferenceResolver dataModelRootNode) throws DataModelException {
    setCurReferenceResolver(dataModelRootNode);
    /* Current node to resolve, it can be a YANG type, YANG uses or YANG if-feature or
        YANG leafref or YANG base or YANG identityref.*/
    T entityToResolve = getEntityToResolveInfo().getEntityToResolve();
    // Check if linking is already done
    if (entityToResolve instanceof Resolvable) {
        Resolvable resolvable = (Resolvable) entityToResolve;
        if (resolvable.getResolvableStatus() == RESOLVED) {
            /**
             * entity is already resolved, so nothing to do
             */
            return;
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than " + "type/uses/if-feature/leafref/base/identityref");
    }
    // Push the initial entity to resolve in stack.
    addInPartialResolvedStack(getEntityToResolveInfo());
    linkAndResolvePartialResolvedStack();
    addDerivedRefTypeToRefTypeResolutionList();
}
#method_after
@Override
public void resolveLinkingForResolutionInfo(YangReferenceResolver dataModelRootNode) throws DataModelException {
    setCurReferenceResolver(dataModelRootNode);
    /**
     * Current node to resolve, it can be a YANG type, YANG uses or YANG if-feature or
     * YANG leafref or YANG base or YANG identityref.
     */
    T entityToResolve = getEntityToResolveInfo().getEntityToResolve();
    // Check if linking is already done
    if (entityToResolve instanceof Resolvable) {
        Resolvable resolvable = (Resolvable) entityToResolve;
        if (resolvable.getResolvableStatus() == RESOLVED) {
            /**
             * entity is already resolved, so nothing to do
             */
            return;
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than " + "type/uses/if-feature/leafref/base/identityref");
    }
    // Push the initial entity to resolve in stack.
    addInPartialResolvedStack(getEntityToResolveInfo());
    linkAndResolvePartialResolvedStack();
    addDerivedRefTypeToRefTypeResolutionList();
}
#end_block

#method_before
private void linkAndResolvePartialResolvedStack() throws DataModelException {
    while (getPartialResolvedStack().size() != 0) {
        /* Current node to resolve, it can be a YANG type or YANG uses or
               YANG if-feature or YANG leafref or YANG base or YANG identityref.
             */
        T entityToResolve = getCurrentEntityToResolveFromStack();
        // Check if linking is already done
        if (entityToResolve instanceof Resolvable) {
            Resolvable resolvable = (Resolvable) entityToResolve;
            switch(resolvable.getResolvableStatus()) {
                case RESOLVED:
                    {
                        /*
                         * If the entity is already resolved in the stack, then pop
                         * it and continue with the remaining stack elements to
                         * resolve
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case LINKED:
                    {
                        /*
                         * If the top of the stack is already linked then resolve
                         * the references and pop the entity and continue with
                         * remaining stack elements to resolve.
                         */
                        resolveTopOfStack(INTRA_FILE);
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTRA_FILE_RESOLVED:
                    {
                        /*
                         * Pop the top of the stack.
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case UNRESOLVED:
                    {
                        linkTopOfStackReferenceUpdateStack();
                        if (resolvable.getResolvableStatus() == UNRESOLVED) {
                            // If current entity is still not resolved, then
                            // linking/resolution has failed.
                            String errorInfo;
                            if (resolvable instanceof YangType) {
                                errorInfo = TYPEDEF_LINKER_ERROR;
                            } else if (resolvable instanceof YangUses) {
                                errorInfo = GROUPING_LINKER_ERROR;
                            } else if (resolvable instanceof YangIfFeature) {
                                errorInfo = FEATURE_LINKER_ERROR;
                            } else if (resolvable instanceof YangBase) {
                                errorInfo = BASE_LINKER_ERROR;
                            } else if (resolvable instanceof YangIdentityRef) {
                                errorInfo = IDENTITYREF_LINKER_ERROR;
                            } else {
                                errorInfo = LEAFREF_LINKER_ERROR;
                            }
                            DataModelException dataModelException = new DataModelException(errorInfo);
                            dataModelException.setLine(getLineNumber());
                            dataModelException.setCharPosition(getCharPosition());
                            throw dataModelException;
                        }
                        break;
                    }
                default:
                    {
                        throw new DataModelException("Data Model Exception: Unsupported, linker state");
                    }
            }
        } else {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses/if-feature" + "/leafref/base/identityref");
        }
    }
}
#method_after
private void linkAndResolvePartialResolvedStack() throws DataModelException {
    while (getPartialResolvedStack().size() != 0) {
        /**
         * Current node to resolve, it can be a YANG type or YANG uses or
         * YANG if-feature or YANG leafref or YANG base or YANG identityref.
         */
        T entityToResolve = getCurrentEntityToResolveFromStack();
        // Check if linking is already done
        if (entityToResolve instanceof Resolvable) {
            Resolvable resolvable = (Resolvable) entityToResolve;
            switch(resolvable.getResolvableStatus()) {
                case RESOLVED:
                    {
                        /*
                         * If the entity is already resolved in the stack, then pop
                         * it and continue with the remaining stack elements to
                         * resolve
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case LINKED:
                    {
                        /*
                         * If the top of the stack is already linked then resolve
                         * the references and pop the entity and continue with
                         * remaining stack elements to resolve.
                         */
                        resolveTopOfStack(INTRA_FILE);
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTRA_FILE_RESOLVED:
                    {
                        /*
                         * Pop the top of the stack.
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case UNRESOLVED:
                    {
                        linkTopOfStackReferenceUpdateStack();
                        if (resolvable.getResolvableStatus() == UNRESOLVED) {
                            // If current entity is still not resolved, then
                            // linking/resolution has failed.
                            String errorInfo;
                            if (resolvable instanceof YangType) {
                                errorInfo = TYPEDEF_LINKER_ERROR;
                            } else if (resolvable instanceof YangUses) {
                                errorInfo = GROUPING_LINKER_ERROR;
                            } else if (resolvable instanceof YangIfFeature) {
                                errorInfo = FEATURE_LINKER_ERROR;
                            } else if (resolvable instanceof YangBase) {
                                errorInfo = BASE_LINKER_ERROR;
                            } else if (resolvable instanceof YangIdentityRef) {
                                errorInfo = IDENTITYREF_LINKER_ERROR;
                            } else {
                                errorInfo = LEAFREF_LINKER_ERROR;
                            }
                            DataModelException dataModelException = new DataModelException(errorInfo);
                            dataModelException.setLine(getLineNumber());
                            dataModelException.setCharPosition(getCharPosition());
                            throw dataModelException;
                        }
                        break;
                    }
                default:
                    {
                        throw new DataModelException("Data Model Exception: Unsupported, linker state");
                    }
            }
        } else {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses/if-feature" + "/leafref/base/identityref");
        }
    }
}
#end_block

#method_before
private void addDerivedRefTypeToRefTypeResolutionList() throws DataModelException {
    YangNode potentialAncestorWithReferredNode = getEntityToResolveInfo().getHolderOfEntityToResolve();
    // If holder is typedef return.
    if (potentialAncestorWithReferredNode instanceof YangTypeDef) {
        return;
    }
    // If entity is not type return.
    if (!(getEntityToResolveInfo().getEntityToResolve() instanceof YangType)) {
        return;
    }
    YangType yangType = (YangType) getEntityToResolveInfo().getEntityToResolve();
    // If type is not resolved return.
    if (yangType.getResolvableStatus() != RESOLVED) {
        return;
    }
    YangDerivedInfo derivedInfo = (YangDerivedInfo) yangType.getDataTypeExtendedInfo();
    /*
         * If the derived types referred type is not leafref/identityref return
         */
    if ((derivedInfo.getEffectiveBuiltInType() != YangDataTypes.LEAFREF) && (derivedInfo.getEffectiveBuiltInType() != YangDataTypes.IDENTITYREF)) {
        return;
    }
    T extendedInfo = (T) derivedInfo.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    while (extendedInfo instanceof YangDerivedInfo) {
        YangDerivedInfo derivedInfoFromTypedef = (YangDerivedInfo) extendedInfo;
        extendedInfo = (T) derivedInfoFromTypedef.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    }
    /*
         * Backup the derived types leafref/identityref info, delete all the info in current type,
         * but for resolution status as resolved. Copy the backed up leafref/identityref to types extended info,
         * create a leafref/identityref resolution info using the current resolution info and
         * add to leafref/identityref resolution list.
         */
    if (derivedInfo.getEffectiveBuiltInType() == YangDataTypes.LEAFREF) {
        YangLeafRef leafRefInTypeDef = (YangLeafRef) extendedInfo;
        yangType.resetYangType();
        yangType.setResolvableStatus(RESOLVED);
        yangType.setDataType(YangDataTypes.LEAFREF);
        yangType.setDataTypeName("leafref");
        yangType.setDataTypeExtendedInfo(leafRefInTypeDef);
        leafRefInTypeDef.setResolvableStatus(UNRESOLVED);
        // Add resolution information to the list.
        YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<>(leafRefInTypeDef, potentialAncestorWithReferredNode, getLineNumber(), getCharPosition());
        getCurReferenceResolver().addToResolutionList(resolutionInfoImpl, ResolvableType.YANG_LEAFREF);
        getCurReferenceResolver().resolveSelfFileLinking(ResolvableType.YANG_LEAFREF);
    } else if (derivedInfo.getEffectiveBuiltInType() == YangDataTypes.IDENTITYREF) {
        YangIdentityRef identityRefInTypeDef = (YangIdentityRef) extendedInfo;
        yangType.resetYangType();
        yangType.setResolvableStatus(RESOLVED);
        yangType.setDataType(YangDataTypes.IDENTITYREF);
        yangType.setDataTypeName("identityref");
        yangType.setDataTypeExtendedInfo(identityRefInTypeDef);
        identityRefInTypeDef.setResolvableStatus(UNRESOLVED);
        // Add resolution information to the list.
        YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<>(identityRefInTypeDef, potentialAncestorWithReferredNode, getLineNumber(), getCharPosition());
        getCurReferenceResolver().addToResolutionList(resolutionInfoImpl, ResolvableType.YANG_IDENTITYREF);
        getCurReferenceResolver().resolveSelfFileLinking(ResolvableType.YANG_IDENTITYREF);
    }
}
#method_after
private void addDerivedRefTypeToRefTypeResolutionList() throws DataModelException {
    YangNode potentialAncestorWithReferredNode = getEntityToResolveInfo().getHolderOfEntityToResolve();
    // If holder is typedef return.
    if (potentialAncestorWithReferredNode instanceof YangTypeDef) {
        return;
    }
    // If entity is not type return.
    if (!(getEntityToResolveInfo().getEntityToResolve() instanceof YangType)) {
        return;
    }
    YangType yangType = (YangType) getEntityToResolveInfo().getEntityToResolve();
    // If type is not resolved return.
    if (yangType.getResolvableStatus() != RESOLVED) {
        return;
    }
    YangDerivedInfo derivedInfo = (YangDerivedInfo) yangType.getDataTypeExtendedInfo();
    /*
         * If the derived types referred type is not leafref/identityref return
         */
    if ((derivedInfo.getEffectiveBuiltInType() != YangDataTypes.LEAFREF) && (derivedInfo.getEffectiveBuiltInType() != YangDataTypes.IDENTITYREF)) {
        return;
    }
    T extendedInfo = (T) derivedInfo.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    while (extendedInfo instanceof YangDerivedInfo) {
        YangDerivedInfo derivedInfoFromTypedef = (YangDerivedInfo) extendedInfo;
        extendedInfo = (T) derivedInfoFromTypedef.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    }
    /*
         * Backup the derived types leafref/identityref info, delete all the info in current type,
         * but for resolution status as resolved. Copy the backed up leafref/identityref to types extended info,
         * create a leafref/identityref resolution info using the current resolution info and
         * add to leafref/identityref resolution list.
         */
    if (derivedInfo.getEffectiveBuiltInType() == YangDataTypes.LEAFREF) {
        YangLeafRef leafRefInTypeDef = (YangLeafRef) extendedInfo;
        yangType.resetYangType();
        yangType.setResolvableStatus(RESOLVED);
        yangType.setDataType(YangDataTypes.LEAFREF);
        yangType.setDataTypeName(LEAFREF);
        yangType.setDataTypeExtendedInfo(leafRefInTypeDef);
        leafRefInTypeDef.setResolvableStatus(UNRESOLVED);
        // Add resolution information to the list.
        YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<>(leafRefInTypeDef, potentialAncestorWithReferredNode, getLineNumber(), getCharPosition());
        getCurReferenceResolver().addToResolutionList(resolutionInfoImpl, ResolvableType.YANG_LEAFREF);
        getCurReferenceResolver().resolveSelfFileLinking(ResolvableType.YANG_LEAFREF);
    } else if (derivedInfo.getEffectiveBuiltInType() == YangDataTypes.IDENTITYREF) {
        YangIdentityRef identityRefInTypeDef = (YangIdentityRef) extendedInfo;
        yangType.resetYangType();
        yangType.setResolvableStatus(RESOLVED);
        yangType.setDataType(YangDataTypes.IDENTITYREF);
        yangType.setDataTypeName(IDENTITYREF);
        yangType.setDataTypeExtendedInfo(identityRefInTypeDef);
        identityRefInTypeDef.setResolvableStatus(UNRESOLVED);
        // Add resolution information to the list.
        YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<>(identityRefInTypeDef, potentialAncestorWithReferredNode, getLineNumber(), getCharPosition());
        getCurReferenceResolver().addToResolutionList(resolutionInfoImpl, ResolvableType.YANG_IDENTITYREF);
        getCurReferenceResolver().resolveSelfFileLinking(ResolvableType.YANG_IDENTITYREF);
    }
}
#end_block

#method_before
private void resolveSelfFileLinkingForLeafref(YangNode potentialAncestorWithReferredNode) throws DataModelException {
    YangNode ancestorWithTheReferredNode = potentialAncestorWithReferredNode;
    YangLeafRef leafref = (YangLeafRef) getCurrentEntityToResolveFromStack();
    boolean referredLeafFound = false;
    /*
         * Takes absolute path and takes the root node as module/sub-module,
         * then sends the list of nodes for finding the target leaf.
         */
    if (leafref.getPathType() == YangPathArgType.ABSOLUTE_PATH) {
        List<YangAbsolutePath> absolutePathList = leafref.getAbsolutePath();
        if (absolutePathList != null && !absolutePathList.isEmpty()) {
            Iterator<YangAbsolutePath> listOfYangAbsolutePath = absolutePathList.listIterator();
            if (getCurReferenceResolver() instanceof YangModule) {
                YangModule rootNode = (YangModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAbsolutePath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            } else if (getCurReferenceResolver() instanceof YangSubModule) {
                YangSubModule rootNode = (YangSubModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAbsolutePath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            }
        }
    /*
             * Takes relative path, goes to the parent node by using the
             * ancestor count and sends the list of nodes for finding the target
             * leaf.
             */
    } else if (leafref.getPathType() == YangPathArgType.RELATIVE_PATH) {
        YangRelativePath yangRelativePath = leafref.getRelativePath();
        int parentNodes = yangRelativePath.getAncestor();
        List<YangAbsolutePath> absolutePathList = yangRelativePath.getAbsolutePath();
        if (absolutePathList != null && !absolutePathList.isEmpty()) {
            Iterator<YangAbsolutePath> listOfYangAbsolutePath = absolutePathList.listIterator();
            // Gets the root node from ancestor count.
            YangNode rootparentNode = getRootNodeWithAncestorCount(parentNodes, ancestorWithTheReferredNode);
            // Sends list of nodes for finding the target leaf.
            referredLeafFound = isLeafReferenceFound(listOfYangAbsolutePath, rootparentNode, referredLeafFound, potentialAncestorWithReferredNode);
        }
    }
    if (referredLeafFound) {
        return;
    }
    /*
         * In case prefix is not present it's a candidate for inter-file
         * resolution via include list.
         */
    if (getRefPrefix() == null) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTRA_FILE_RESOLVED);
    }
}
#method_after
private void resolveSelfFileLinkingForLeafref(YangNode potentialAncestorWithReferredNode) throws DataModelException {
    YangNode ancestorWithTheReferredNode = potentialAncestorWithReferredNode;
    YangLeafRef leafref = (YangLeafRef) getCurrentEntityToResolveFromStack();
    boolean referredLeafFound = false;
    /*
         * Takes absolute path and takes the root node as module/sub-module,
         * then sends the list of nodes for finding the target leaf.
         */
    if (leafref.getPathType() == YangPathArgType.ABSOLUTE_PATH) {
        List<YangAtomicPath> atomicPathList = leafref.getAtomicPath();
        if (atomicPathList != null && !atomicPathList.isEmpty()) {
            Iterator<YangAtomicPath> listOfYangAtomicPath = atomicPathList.listIterator();
            if (getCurReferenceResolver() instanceof YangModule) {
                YangModule rootNode = (YangModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAtomicPath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            } else if (getCurReferenceResolver() instanceof YangSubModule) {
                YangSubModule rootNode = (YangSubModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAtomicPath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            }
        }
    /*
             * Takes relative path, goes to the parent node by using the
             * ancestor count and sends the list of nodes for finding the target
             * leaf.
             */
    } else if (leafref.getPathType() == YangPathArgType.RELATIVE_PATH) {
        YangRelativePath yangRelativePath = leafref.getRelativePath();
        int parentNodes = yangRelativePath.getAncestorNodeCount();
        List<YangAtomicPath> atomicPathList = yangRelativePath.getAtomicPathList();
        if (atomicPathList != null && !atomicPathList.isEmpty()) {
            Iterator<YangAtomicPath> listOfAtomicPath = atomicPathList.listIterator();
            // Gets the root node from ancestor count.
            YangNode rootparentNode = getRootNodeWithAncestorCount(parentNodes, ancestorWithTheReferredNode);
            // Sends list of nodes for finding the target leaf.
            referredLeafFound = isLeafReferenceFound(listOfAtomicPath, rootparentNode, referredLeafFound, potentialAncestorWithReferredNode);
        }
    }
    if (referredLeafFound) {
        return;
    }
    /*
         * In case prefix is not present it's a candidate for inter-file
         * resolution via include list.
         */
    if (getRefPrefix() == null) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTRA_FILE_RESOLVED);
    }
}
#end_block

#method_before
private YangNode getRootNodeWithAncestorCount(int ancestorCount, YangNode currentParent) throws DataModelException {
    int currentParentCount = 1;
    while (currentParentCount < ancestorCount) {
        if (currentParent.getParent() == null) {
            throw new DataModelException("Yang file error: The target node of leafref is invalid.");
        }
        currentParent = currentParent.getParent();
        currentParentCount = currentParentCount + 1;
    }
    return currentParent;
}
#method_after
private YangNode getRootNodeWithAncestorCount(int ancestorCount, YangNode currentParent) throws DataModelException {
    int currentParentCount = 1;
    while (currentParentCount < ancestorCount) {
        if (currentParent.getParent() == null) {
            throw new DataModelException("YANG file error: The target node of leafref is invalid.");
        }
        currentParent = currentParent.getParent();
        currentParentCount = currentParentCount + 1;
    }
    return currentParent;
}
#end_block

#method_before
private boolean isLeafReferenceFound(Iterator<YangAbsolutePath> listOfYangAbsolutePath, YangNode ancestorWithTheReferredNode, boolean referredLeafFound, YangNode potentialAncestorWithReferredNode) throws DataModelException {
    while (listOfYangAbsolutePath.hasNext()) {
        YangAbsolutePath absolutePath = listOfYangAbsolutePath.next();
        String nodeName = absolutePath.getNodeIdentifier().getName();
        // When child is not present, only leaf/leaf-list is available in the node.
        if (ancestorWithTheReferredNode.getChild() == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode, nodeName, (T) LINKED);
            break;
        }
        ancestorWithTheReferredNode = ancestorWithTheReferredNode.getChild();
        // Checks all the siblings under the node and returns the matched node.
        YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(ancestorWithTheReferredNode, nodeName);
        // When node is not found in all the siblings, leaf-list may be the node we have to find.
        if (nodeFound == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode.getParent(), nodeName, (T) LINKED);
        } else {
            ancestorWithTheReferredNode = nodeFound;
            // For the node check if path predicate is present and fill its values.
            List<YangPathPredicate> pathPredicateList = absolutePath.getPredicatesExp();
            if (pathPredicateList != null && !pathPredicateList.isEmpty()) {
                Iterator<YangPathPredicate> listOfYangPathPredicate = pathPredicateList.listIterator();
                fillPathPredicatesForTheNode(ancestorWithTheReferredNode, listOfYangPathPredicate, potentialAncestorWithReferredNode);
            }
        }
        // If leaf is also not found and node is also not found return the status as false.
        if (!referredLeafFound && nodeFound == null) {
            break;
        }
    }
    return referredLeafFound;
}
#method_after
private boolean isLeafReferenceFound(Iterator<YangAtomicPath> listOfYangAtomicPath, YangNode ancestorWithTheReferredNode, boolean referredLeafFound, YangNode potentialAncestorWithReferredNode) throws DataModelException {
    while (listOfYangAtomicPath.hasNext()) {
        YangAtomicPath atomicPath = listOfYangAtomicPath.next();
        String nodeName = atomicPath.getNodeIdentifier().getName();
        // When child is not present, only leaf/leaf-list is available in the node.
        if (ancestorWithTheReferredNode.getChild() == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode, nodeName, (T) LINKED);
            break;
        }
        ancestorWithTheReferredNode = ancestorWithTheReferredNode.getChild();
        // Checks all the siblings under the node and returns the matched node.
        YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(ancestorWithTheReferredNode, nodeName);
        // When node is not found in all the siblings, leaf-list may be the node we have to find.
        if (nodeFound == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode.getParent(), nodeName, (T) LINKED);
        } else {
            ancestorWithTheReferredNode = nodeFound;
            // For the node check if path predicate is present and fill its values.
            List<YangPathPredicate> pathPredicateList = atomicPath.getPathPredicatesList();
            if (pathPredicateList != null && !pathPredicateList.isEmpty()) {
                Iterator<YangPathPredicate> listOfYangPathPredicate = pathPredicateList.listIterator();
                fillPathPredicatesForTheNode(ancestorWithTheReferredNode, listOfYangPathPredicate, potentialAncestorWithReferredNode);
            }
        }
        // If leaf is also not found and node is also not found return the status as false.
        if (!referredLeafFound && nodeFound == null) {
            break;
        }
    }
    return referredLeafFound;
}
#end_block

#method_before
private void fillPathPredicatesForTheNode(YangNode ancestorWithTheReferredNode, Iterator<YangPathPredicate> listOfYangPathPredicate, YangNode potentialAncestorWithReferredNode) throws DataModelException {
    while (listOfYangPathPredicate.hasNext()) {
        if (!(ancestorWithTheReferredNode instanceof YangList)) {
            throw new DataModelException("Yang file error: The path predicates are applicable only for list");
        }
        YangPathPredicate pathPredicate = listOfYangPathPredicate.next();
        YangNodeIdentifier leftNode = pathPredicate.getNodeIdentifier();
        YangRelativePath relativePath = pathPredicate.getRightRelativePath();
        // Checks that the left axis is filled in the path predicate.
        boolean isLeftLeafOrLeafListSetForLeftAxis = getLeftLeafOrLeafListInPredicate((YangList) ancestorWithTheReferredNode, pathPredicate, leftNode);
        if (!isLeftLeafOrLeafListSetForLeftAxis) {
            throw new DataModelException("Yang file error: The path predicate is not referring to an existing leaf/leaflist");
        }
        int parentNodes = relativePath.getAncestor();
        // Finds the root node for the right relative path.
        YangNode rootParentNode = getRootNodeWithAncestorCount(parentNodes, potentialAncestorWithReferredNode);
        // Finds the leaf/leaf-list from the right side relative path.
        resolveRightAxisNodeInPathPredicate(relativePath, rootParentNode, pathPredicate);
    }
}
#method_after
private void fillPathPredicatesForTheNode(YangNode ancestorWithTheReferredNode, Iterator<YangPathPredicate> listOfYangPathPredicate, YangNode potentialAncestorWithReferredNode) throws DataModelException {
    while (listOfYangPathPredicate.hasNext()) {
        if (!(ancestorWithTheReferredNode instanceof YangList)) {
            throw new DataModelException("YANG file error: The path predicates are applicable only for list");
        }
        YangPathPredicate pathPredicate = listOfYangPathPredicate.next();
        YangNodeIdentifier leftNode = pathPredicate.getNodeIdentifier();
        YangRelativePath relativePath = pathPredicate.getRightRelativePath();
        // Checks that the left axis is filled in the path predicate.
        boolean isLeftLeafOrLeafListSetForLeftAxis = getLeftLeafOrLeafListInPredicate((YangList) ancestorWithTheReferredNode, pathPredicate, leftNode);
        if (!isLeftLeafOrLeafListSetForLeftAxis) {
            throw new DataModelException("YANG file error: The path predicate is not referring to an existing leaf/leaflist");
        }
        int parentNodes = relativePath.getAncestorNodeCount();
        // Finds the root node for the right relative path.
        YangNode rootParentNode = getRootNodeWithAncestorCount(parentNodes, potentialAncestorWithReferredNode);
        // Finds the leaf/leaf-list from the right side relative path.
        resolveRightAxisNodeInPathPredicate(relativePath, rootParentNode, pathPredicate);
    }
}
#end_block

#method_before
private void resolveRightAxisNodeInPathPredicate(YangRelativePath relativePath, YangNode rootParentNode, YangPathPredicate pathPredicate) throws DataModelException {
    List<YangAbsolutePath> absolutePathList = relativePath.getAbsolutePath();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAbsolutePath> listOfYangAbsolutePathForRightRelative = absolutePathList.listIterator();
        while (listOfYangAbsolutePathForRightRelative.hasNext()) {
            boolean isRightAxisNodeFound = false;
            YangAbsolutePath absolutePathInPredicate = listOfYangAbsolutePathForRightRelative.next();
            String nodeNameInAbsolutePath = absolutePathInPredicate.getNodeIdentifier().getName();
            // When child is not there check the leaf/leaf-list.
            if (rootParentNode.getChild() == null) {
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode, nodeNameInAbsolutePath, (T) pathPredicate);
                if (!isRightAxisNodeFound) {
                    throw new DataModelException("Yang file error: The path predicates is not referring to an existing leaf/leaflist");
                }
                break;
            }
            rootParentNode = rootParentNode.getChild();
            YangNode nodeFoundInTheRelativePath = isReferredNodeInSiblingProcessedForLeafref(rootParentNode, nodeNameInAbsolutePath);
            if (nodeFoundInTheRelativePath == null) {
                // When node is not found check the leaf/leaf-list.
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode.getParent(), nodeNameInAbsolutePath, (T) pathPredicate);
            } else {
                rootParentNode = nodeFoundInTheRelativePath;
            }
            if (!isRightAxisNodeFound && nodeFoundInTheRelativePath == null) {
                throw new DataModelException("Yang file error: The path predicates is not referring to an existing leaf/leaflist");
            }
        }
    }
}
#method_after
private void resolveRightAxisNodeInPathPredicate(YangRelativePath relativePath, YangNode rootParentNode, YangPathPredicate pathPredicate) throws DataModelException {
    List<YangAtomicPath> absolutePathList = relativePath.getAtomicPathList();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAtomicPath> listOfYangAtomicPathForRightRelative = absolutePathList.listIterator();
        while (listOfYangAtomicPathForRightRelative.hasNext()) {
            boolean isRightAxisNodeFound = false;
            YangAtomicPath absolutePathInPredicate = listOfYangAtomicPathForRightRelative.next();
            String nodeNameInAtomicPath = absolutePathInPredicate.getNodeIdentifier().getName();
            // When child is not there check the leaf/leaf-list.
            if (rootParentNode.getChild() == null) {
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode, nodeNameInAtomicPath, (T) pathPredicate);
                if (!isRightAxisNodeFound) {
                    throw new DataModelException("YANG file error: The path predicates is not referring to an existing leaf/leaflist");
                }
                break;
            }
            rootParentNode = rootParentNode.getChild();
            YangNode nodeFoundInTheRelativePath = isReferredNodeInSiblingProcessedForLeafref(rootParentNode, nodeNameInAtomicPath);
            if (nodeFoundInTheRelativePath == null) {
                // When node is not found check the leaf/leaf-list.
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode.getParent(), nodeNameInAtomicPath, (T) pathPredicate);
            } else {
                rootParentNode = nodeFoundInTheRelativePath;
            }
            if (!isRightAxisNodeFound && nodeFoundInTheRelativePath == null) {
                throw new DataModelException("YANG file error: The path predicates is not referring to an existing leaf/leaflist");
            }
        }
    }
}
#end_block

#method_before
private boolean isReferredLeafOrLeafListFound(YangNode ancestorWithTheReferredNode, String nodeName, T statusOrPathPredicate) throws DataModelException {
    if (!(ancestorWithTheReferredNode instanceof YangLeavesHolder)) {
        throw new DataModelException("Yang file error: The target node of leafref is invalid.");
    }
    YangLeavesHolder leavesHolder = (YangLeavesHolder) ancestorWithTheReferredNode;
    if (leavesHolder.getListOfLeaf() != null) {
        Iterator<YangLeaf> yangLeavesList = leavesHolder.getListOfLeaf().listIterator();
        while (yangLeavesList.hasNext()) {
            YangLeaf yangleaf = yangLeavesList.next();
            if (yangleaf.getName().contentEquals(nodeName)) {
                if (statusOrPathPredicate instanceof ResolvableStatus) {
                    ResolvableStatus status = (ResolvableStatus) statusOrPathPredicate;
                    // Sets the referred leaf to YANG leafref.
                    ((YangLeafRef) getCurrentEntityToResolveFromStack()).setReferredLeafOrLeafList(yangleaf);
                    // Adds reference link of entity to the node under resolution.
                    addReferredEntityLink(ancestorWithTheReferredNode, status);
                    addUnResolvedLeafRefTypeToStack((T) yangleaf, ancestorWithTheReferredNode);
                    return true;
                } else if (statusOrPathPredicate instanceof YangPathPredicate) {
                    YangPathPredicate pathPredicate = (YangPathPredicate) statusOrPathPredicate;
                    // Sets the right axis node.
                    pathPredicate.setRightAxisNode(yangleaf);
                    return true;
                } else {
                    throw new DataModelException("Yang file error: The target node of leafref is invalid.");
                }
            }
        }
    }
    if (leavesHolder.getListOfLeafList() != null) {
        Iterator<YangLeafList> yangLeafListList = leavesHolder.getListOfLeafList().listIterator();
        while (yangLeafListList.hasNext()) {
            YangLeafList yangLeaflist = yangLeafListList.next();
            if (yangLeaflist.getName().contentEquals(nodeName)) {
                if (statusOrPathPredicate instanceof ResolvableStatus) {
                    ResolvableStatus status = (ResolvableStatus) statusOrPathPredicate;
                    // Sets the referred leaf-list to YANG leafref.
                    ((YangLeafRef) getCurrentEntityToResolveFromStack()).setReferredLeafOrLeafList(yangLeaflist);
                    // Adds reference link of entity to the node under resolution.
                    addReferredEntityLink(ancestorWithTheReferredNode, status);
                    addUnResolvedLeafRefTypeToStack((T) yangLeaflist, ancestorWithTheReferredNode);
                    return true;
                } else if (statusOrPathPredicate instanceof YangPathPredicate) {
                    YangPathPredicate pathPredicate = (YangPathPredicate) statusOrPathPredicate;
                    pathPredicate.setRightAxisNode(yangLeaflist);
                    return true;
                } else {
                    throw new DataModelException("Yang file error: The target node of leafref is invalid.");
                }
            }
        }
    }
    return false;
}
#method_after
private boolean isReferredLeafOrLeafListFound(YangNode ancestorWithTheReferredNode, String nodeName, T statusOrPathPredicate) throws DataModelException {
    if (!(ancestorWithTheReferredNode instanceof YangLeavesHolder)) {
        throw new DataModelException("Yang file error: The target node of leafref is invalid.");
    }
    YangLeavesHolder leavesHolder = (YangLeavesHolder) ancestorWithTheReferredNode;
    if (leavesHolder.getListOfLeaf() != null) {
        Iterator<YangLeaf> yangLeavesList = leavesHolder.getListOfLeaf().listIterator();
        while (yangLeavesList.hasNext()) {
            YangLeaf yangleaf = yangLeavesList.next();
            if (yangleaf.getName().contentEquals(nodeName)) {
                if (statusOrPathPredicate instanceof ResolvableStatus) {
                    ResolvableStatus status = (ResolvableStatus) statusOrPathPredicate;
                    // Sets the referred leaf to YANG leafref.
                    ((YangLeafRef) getCurrentEntityToResolveFromStack()).setReferredLeafOrLeafList(yangleaf);
                    // Adds reference link of entity to the node under resolution.
                    addReferredEntityLink(ancestorWithTheReferredNode, status);
                    addUnResolvedLeafRefTypeToStack((T) yangleaf, ancestorWithTheReferredNode);
                    return true;
                } else if (statusOrPathPredicate instanceof YangPathPredicate) {
                    YangPathPredicate pathPredicate = (YangPathPredicate) statusOrPathPredicate;
                    // Sets the right axis node.
                    pathPredicate.setRightAxisNode(yangleaf);
                    return true;
                } else {
                    throw new DataModelException("YANG file error: The target node of leafref is invalid.");
                }
            }
        }
    }
    if (leavesHolder.getListOfLeafList() != null) {
        Iterator<YangLeafList> yangLeafListList = leavesHolder.getListOfLeafList().listIterator();
        while (yangLeafListList.hasNext()) {
            YangLeafList yangLeaflist = yangLeafListList.next();
            if (yangLeaflist.getName().contentEquals(nodeName)) {
                if (statusOrPathPredicate instanceof ResolvableStatus) {
                    ResolvableStatus status = (ResolvableStatus) statusOrPathPredicate;
                    // Sets the referred leaf-list to YANG leafref.
                    ((YangLeafRef) getCurrentEntityToResolveFromStack()).setReferredLeafOrLeafList(yangLeaflist);
                    // Adds reference link of entity to the node under resolution.
                    addReferredEntityLink(ancestorWithTheReferredNode, status);
                    addUnResolvedLeafRefTypeToStack((T) yangLeaflist, ancestorWithTheReferredNode);
                    return true;
                } else if (statusOrPathPredicate instanceof YangPathPredicate) {
                    YangPathPredicate pathPredicate = (YangPathPredicate) statusOrPathPredicate;
                    pathPredicate.setRightAxisNode(yangLeaflist);
                    return true;
                } else {
                    throw new DataModelException("YANG file error: The target node of leafref is invalid.");
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
private YangNode isReferredNodeInSiblingProcessedForLeafref(YangNode potentialReferredNode, String referredNodeName) throws DataModelException {
    while (potentialReferredNode != null) {
        if (potentialReferredNode instanceof YangInput) {
            if (referredNodeName.equalsIgnoreCase("input")) {
                return potentialReferredNode;
            }
        } else if (potentialReferredNode instanceof YangOutput) {
            if (referredNodeName.equalsIgnoreCase("output")) {
                return potentialReferredNode;
            }
        }
        // Check if the potential referred node is the actual referred node
        if (isReferredNodeForLeafref(potentialReferredNode, referredNodeName)) {
            if (potentialReferredNode instanceof YangGrouping || potentialReferredNode instanceof YangTypeDef) {
                if (potentialReferredNode.getParent() instanceof YangRpc) {
                    potentialReferredNode = potentialReferredNode.getNextSibling();
                } else {
                    throw new DataModelException("Yang file error: The target node of leafref is invalid.");
                }
            }
            return potentialReferredNode;
        }
        potentialReferredNode = potentialReferredNode.getNextSibling();
    }
    return null;
}
#method_after
private YangNode isReferredNodeInSiblingProcessedForLeafref(YangNode potentialReferredNode, String referredNodeName) throws DataModelException {
    while (potentialReferredNode != null) {
        if (potentialReferredNode instanceof YangInput) {
            if (referredNodeName.equalsIgnoreCase(INPUT)) {
                return potentialReferredNode;
            }
        } else if (potentialReferredNode instanceof YangOutput) {
            if (referredNodeName.equalsIgnoreCase(OUTPUT)) {
                return potentialReferredNode;
            }
        }
        // Check if the potential referred node is the actual referred node
        if (isReferredNodeForLeafref(potentialReferredNode, referredNodeName)) {
            if (potentialReferredNode instanceof YangGrouping || potentialReferredNode instanceof YangTypeDef) {
                if (potentialReferredNode.getParent() instanceof YangRpc) {
                    potentialReferredNode = potentialReferredNode.getNextSibling();
                } else {
                    throw new DataModelException("YANG file error: The target node of leafref is invalid.");
                }
            }
            return potentialReferredNode;
        }
        potentialReferredNode = potentialReferredNode.getNextSibling();
    }
    return null;
}
#end_block

#method_before
private boolean isReferredNodeForIdentity(YangNode currentReferredNode, String nameOfIdentityRefBase) throws DataModelException {
    if ((getCurrentEntityToResolveFromStack() instanceof YangIdentityRef) || (getCurrentEntityToResolveFromStack() instanceof YangBase)) {
        /*
             * Check if name of node name matches with the current reference node.
             */
        if (currentReferredNode.getName().contentEquals(nameOfIdentityRefBase)) {
            return true;
        }
        return false;
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than identityref");
    }
}
#method_after
private boolean isReferredNodeForIdentity(YangNode currentReferredNode, String nameOfIdentityRefBase) throws DataModelException {
    if ((getCurrentEntityToResolveFromStack() instanceof YangIdentityRef) || (getCurrentEntityToResolveFromStack() instanceof YangBase)) {
        /*
             * Check if name of node name matches with the current reference node.
             */
        return currentReferredNode.getName().contentEquals(nameOfIdentityRefBase);
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than identityref");
    }
}
#end_block

#method_before
private void addReferredEntityLink(YangNode referredNode, ResolvableStatus linkedStatus) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) ((YangType<?>) getCurrentEntityToResolveFromStack()).getDataTypeExtendedInfo();
        derivedInfo.setReferredTypeDef((YangTypeDef) referredNode);
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        ((YangUses) getCurrentEntityToResolveFromStack()).setRefGroup((YangGrouping) referredNode);
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
    // do nothing , referred node is already set
    } else if (getCurrentEntityToResolveFromStack() instanceof YangLeafRef) {
    // do nothing , referred node is already set
    } else if (getCurrentEntityToResolveFromStack() instanceof YangBase) {
        ((YangBase) getCurrentEntityToResolveFromStack()).setReferredIdentity((YangIdentity) referredNode);
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIdentityRef) {
        ((YangIdentityRef) getCurrentEntityToResolveFromStack()).setReferedIdentity((YangIdentity) referredNode);
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type" + "/uses/base/identityref");
    }
    // Sets the resolution status in inside the type/uses.
    ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(linkedStatus);
}
#method_after
private void addReferredEntityLink(YangNode referredNode, ResolvableStatus linkedStatus) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) ((YangType<?>) getCurrentEntityToResolveFromStack()).getDataTypeExtendedInfo();
        derivedInfo.setReferredTypeDef((YangTypeDef) referredNode);
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        ((YangUses) getCurrentEntityToResolveFromStack()).setRefGroup((YangGrouping) referredNode);
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
    // do nothing , referred node is already set
    } else if (getCurrentEntityToResolveFromStack() instanceof YangLeafRef) {
    // do nothing , referred node is already set
    } else if (getCurrentEntityToResolveFromStack() instanceof YangBase) {
        ((YangBase) getCurrentEntityToResolveFromStack()).setReferredIdentity((YangIdentity) referredNode);
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIdentityRef) {
        ((YangIdentityRef) getCurrentEntityToResolveFromStack()).setReferredIdentity((YangIdentity) referredNode);
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type" + "/uses/base/identityref");
    }
    // Sets the resolution status in inside the type/uses.
    ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(linkedStatus);
}
#end_block

#method_before
private void addUnResolvedBaseToStack(YangNode node) {
    YangIdentity curNode = (YangIdentity) node;
    if (null != curNode.getBaseNode()) {
        if (curNode.getBaseNode().getResolvableStatus() != RESOLVED) {
            YangEntityToResolveInfoImpl<YangBase> unResolvedEntityInfo = new YangEntityToResolveInfoImpl<>();
            unResolvedEntityInfo.setEntityToResolve(curNode.getBaseNode());
            unResolvedEntityInfo.setHolderOfEntityToResolve(node);
            addInPartialResolvedStack((YangEntityToResolveInfoImpl<T>) unResolvedEntityInfo);
        }
    }
}
#method_after
private void addUnResolvedBaseToStack(YangNode node) {
    YangIdentity curNode = (YangIdentity) node;
    if (curNode.getBaseNode() != null) {
        if (curNode.getBaseNode().getResolvableStatus() != RESOLVED) {
            YangEntityToResolveInfoImpl<YangBase> unResolvedEntityInfo = new YangEntityToResolveInfoImpl<>();
            unResolvedEntityInfo.setEntityToResolve(curNode.getBaseNode());
            unResolvedEntityInfo.setHolderOfEntityToResolve(node);
            addInPartialResolvedStack((YangEntityToResolveInfoImpl<T>) unResolvedEntityInfo);
        }
    }
}
#end_block

#method_before
private String refPrefixForLeafRef() {
    String refPrefix;
    if (((YangLeafRef) getCurrentEntityToResolveFromStack()).getPathType() == YangPathArgType.ABSOLUTE_PATH) {
        List<YangAbsolutePath> theList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAbsolutePath();
        YangAbsolutePath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    } else {
        YangRelativePath relativePath = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getRelativePath();
        List<YangAbsolutePath> theList = relativePath.getAbsolutePath();
        YangAbsolutePath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    }
    return refPrefix;
}
#method_after
private String refPrefixForLeafRef() {
    String refPrefix;
    if (((YangLeafRef) getCurrentEntityToResolveFromStack()).getPathType() == YangPathArgType.ABSOLUTE_PATH) {
        List<YangAtomicPath> theList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAtomicPath();
        YangAtomicPath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    } else {
        YangRelativePath relativePath = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getRelativePath();
        List<YangAtomicPath> theList = relativePath.getAtomicPathList();
        YangAtomicPath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    }
    return refPrefix;
}
#end_block

#method_before
private boolean findRefLeaf(YangNode importedNode) throws DataModelException {
    boolean isReferredNodeFound = false;
    List<YangAbsolutePath> absolutePathList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAbsolutePath();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAbsolutePath> listOfYangAbsolutePath = absolutePathList.listIterator();
        while (listOfYangAbsolutePath.hasNext()) {
            YangAbsolutePath absolutePath = listOfYangAbsolutePath.next();
            String nodeName = absolutePath.getNodeIdentifier().getName();
            if (importedNode.getChild() == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode, nodeName, (T) INTER_FILE_LINKED);
                break;
            }
            importedNode = importedNode.getChild();
            YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(importedNode, nodeName);
            if (nodeFound == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode.getParent(), nodeName, (T) INTER_FILE_LINKED);
            } else {
                importedNode = nodeFound;
            }
        }
    }
    // TODO: Path predicates filling for inter file has to be done.
    return isReferredNodeFound;
}
#method_after
private boolean findRefLeaf(YangNode importedNode) throws DataModelException {
    boolean isReferredNodeFound = false;
    List<YangAtomicPath> absolutePathList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAtomicPath();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAtomicPath> listOfYangAtomicPath = absolutePathList.listIterator();
        while (listOfYangAtomicPath.hasNext()) {
            YangAtomicPath absolutePath = listOfYangAtomicPath.next();
            String nodeName = absolutePath.getNodeIdentifier().getName();
            if (importedNode.getChild() == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode, nodeName, (T) INTER_FILE_LINKED);
                break;
            }
            importedNode = importedNode.getChild();
            YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(importedNode, nodeName);
            if (nodeFound == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode.getParent(), nodeName, (T) INTER_FILE_LINKED);
            } else {
                importedNode = nodeFound;
            }
        }
    }
    // TODO: Path predicates filling for inter file has to be done.
    return isReferredNodeFound;
}
#end_block

#method_before
private T getRefNode() throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) ((YangType<?>) getCurrentEntityToResolveFromStack()).getDataTypeExtendedInfo();
        return (T) derivedInfo.getReferredTypeDef();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        return (T) ((YangUses) getCurrentEntityToResolveFromStack()).getRefGroup();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
        return (T) ((YangIfFeature) getCurrentEntityToResolveFromStack()).getReferredFeatureHolder();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangLeafRef) {
        return (T) ((YangLeafRef) getCurrentEntityToResolveFromStack()).getReferredLeafOrLeafList();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangBase) {
        return (T) ((YangBase) getCurrentEntityToResolveFromStack()).getReferredIdentity();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIdentityRef) {
        return (T) ((YangIdentityRef) getCurrentEntityToResolveFromStack()).getReferedIdentity();
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type" + "/uses/base/identityref");
    }
}
#method_after
private T getRefNode() throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) ((YangType<?>) getCurrentEntityToResolveFromStack()).getDataTypeExtendedInfo();
        return (T) derivedInfo.getReferredTypeDef();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        return (T) ((YangUses) getCurrentEntityToResolveFromStack()).getRefGroup();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
        return (T) ((YangIfFeature) getCurrentEntityToResolveFromStack()).getReferredFeatureHolder();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangLeafRef) {
        return (T) ((YangLeafRef) getCurrentEntityToResolveFromStack()).getReferredLeafOrLeafList();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangBase) {
        return (T) ((YangBase) getCurrentEntityToResolveFromStack()).getReferredIdentity();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIdentityRef) {
        return (T) ((YangIdentityRef) getCurrentEntityToResolveFromStack()).getReferredIdentity();
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type" + "/uses/base/identityref");
    }
}
#end_block

#method_before
private static String getIdentityClassDefinition(String yangName, YangNode curNode) {
    if (!(curNode instanceof YangJavaIdentity)) {
        throw new RuntimeException("curNode is not Identity node");
    }
    YangJavaIdentity identity = (YangJavaIdentity) curNode;
    if (identity.getBaseNode() != null) {
        YangIdentity baseIdentity = identity.getBaseNode().getReferredIdentity();
        if (!(baseIdentity instanceof YangJavaIdentity)) {
            throw new RuntimeException("curNode is not Identity node");
        }
        YangJavaIdentity baseJavaIdentity = (YangJavaIdentity) baseIdentity;
        return PUBLIC + SPACE + ABSTRCT + SPACE + CLASS + SPACE + yangName + SPACE + EXTEND + SPACE + getCapitalCase(baseJavaIdentity.getJavaFileInfo().getJavaName()) + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    }
    return PUBLIC + SPACE + ABSTRCT + SPACE + CLASS + SPACE + yangName + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#method_after
private static String getIdentityClassDefinition(String yangName, YangNode curNode) {
    if (!(curNode instanceof YangJavaIdentity)) {
        throw new TranslatorException("Expected java identity instance node");
    }
    YangJavaIdentity identity = (YangJavaIdentity) curNode;
    if (identity.getBaseNode() != null) {
        YangIdentity baseIdentity = identity.getBaseNode().getReferredIdentity();
        if (!(baseIdentity instanceof YangJavaIdentity)) {
            throw new TranslatorException("Expected java identity instance node");
        }
        YangJavaIdentity baseJavaIdentity = (YangJavaIdentity) baseIdentity;
        return PUBLIC + SPACE + ABSTRACT + SPACE + CLASS + SPACE + yangName + SPACE + EXTEND + SPACE + getCapitalCase(baseJavaIdentity.getJavaFileInfo().getJavaName()) + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
    }
    return PUBLIC + SPACE + ABSTRACT + SPACE + CLASS + SPACE + yangName + SPACE + OPEN_CURLY_BRACKET + NEW_LINE;
}
#end_block

#method_before
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr, YangToJavaNamingConflictUtil pluginConfig) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return YANG_DECIMAL64_CLASS;
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return YANG_BITS_CLASS;
            case BINARY:
                return YANG_BINARY_CLASS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportClass(referredType, isListAttr, pluginConfig);
            case IDENTITYREF:
                YangIdentityRef identityRef = (YangIdentityRef) yangType.getDataTypeExtendedInfo();
                YangIdentity identity = identityRef.getReferedIdentity();
                return getCapitalCase(getCamelCase(((YangJavaIdentity) identity).getName(), pluginConfig));
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                return STRING_DATA_TYPE;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return YANG_DECIMAL64_CLASS;
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return YANG_BITS_CLASS;
            case BINARY:
                return YANG_BINARY_CLASS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportClass(referredType, isListAttr, pluginConfig);
            case IDENTITYREF:
                YangIdentityRef identityRef = (YangIdentityRef) yangType.getDataTypeExtendedInfo();
                YangIdentity identity = identityRef.getReferedIdentity();
                return getCapitalCase(getCamelCase(((YangJavaIdentity) identity).getName(), pluginConfig));
            case EMPTY:
                return BOOLEAN_DATA_TYPE;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                return STRING_DATA_TYPE;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                return null;
        }
    }
}
#method_after
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr, YangToJavaNamingConflictUtil pluginConfig) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return YANG_DECIMAL64_CLASS;
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return YANG_BITS_CLASS;
            case BINARY:
                return YANG_BINARY_CLASS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportClass(referredType, isListAttr, pluginConfig);
            case IDENTITYREF:
                YangIdentityRef identityRef = (YangIdentityRef) yangType.getDataTypeExtendedInfo();
                YangIdentity identity = identityRef.getReferredIdentity();
                return getCapitalCase(getCamelCase(((YangJavaIdentity) identity).getName(), pluginConfig));
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                return STRING_DATA_TYPE;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return YANG_DECIMAL64_CLASS;
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return YANG_BITS_CLASS;
            case BINARY:
                return YANG_BINARY_CLASS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportClass(referredType, isListAttr, pluginConfig);
            case IDENTITYREF:
                YangIdentityRef identityRef = (YangIdentityRef) yangType.getDataTypeExtendedInfo();
                YangIdentity identity = identityRef.getReferredIdentity();
                return getCapitalCase(getCamelCase(((YangJavaIdentity) identity).getName(), pluginConfig));
            case EMPTY:
                return BOOLEAN_DATA_TYPE;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                return STRING_DATA_TYPE;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                return null;
        }
    }
}
#end_block

#method_before
private static String getIdentityRefPackage(YangType<?> type, YangToJavaNamingConflictUtil conflictResolver) {
    if (!(type.getDataTypeExtendedInfo() instanceof YangIdentityRef)) {
        throw new TranslatorException("type should have been identityref.");
    }
    YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
    YangJavaIdentity identity = (YangJavaIdentity) (identityRef.getReferedIdentity());
    if (identity.getJavaFileInfo().getPackage() == null) {
        return getPackageFromParent(identity.getParent(), conflictResolver);
    }
    return identity.getJavaFileInfo().getPackage();
}
#method_after
private static String getIdentityRefPackage(YangType<?> type, YangToJavaNamingConflictUtil conflictResolver) {
    if (!(type.getDataTypeExtendedInfo() instanceof YangIdentityRef)) {
        throw new TranslatorException("type should have been identityref.");
    }
    YangIdentityRef identityRef = (YangIdentityRef) type.getDataTypeExtendedInfo();
    YangJavaIdentity identity = (YangJavaIdentity) (identityRef.getReferredIdentity());
    if (identity.getJavaFileInfo().getPackage() == null) {
        return getPackageFromParent(identity.getParent(), conflictResolver);
    }
    return identity.getJavaFileInfo().getPackage();
}
#end_block

#method_before
public static void processBaseEntry(TreeWalkListener listener, GeneratedYangParser.BaseStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, BASE_DATA, ctx.string().getText(), ENTRY);
    YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(ctx.string().getText(), BASE_DATA, ctx);
    Parsable tmpData = listener.getParsedDataStack().peek();
    if ((tmpData instanceof YangIdentityRef) || (tmpData instanceof YangType)) {
        return;
    }
    if (!(tmpData instanceof YangIdentity)) {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, BASE_DATA, ctx.string().getText(), ENTRY));
    }
    YangBase yangBase = new YangBase();
    yangBase.setBaseIdentifier(nodeIdentifier);
    ((YangIdentity) tmpData).setBaseNode(yangBase);
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    // Add resolution information to the list
    YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangBase>(yangBase, (YangNode) tmpData, errorLine, errorPosition);
    addToResolutionList(resolutionInfo, ctx);
}
#method_after
public static void processBaseEntry(TreeWalkListener listener, GeneratedYangParser.BaseStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, BASE_DATA, ctx.string().getText(), ENTRY);
    YangNodeIdentifier nodeIdentifier = getValidNodeIdentifier(ctx.string().getText(), BASE_DATA, ctx);
    Parsable tmpData = listener.getParsedDataStack().peek();
    /**
     * For identityref base node identifier is copied in identity listener itself, so no need to process
     * base statement for indentityref
     */
    if (tmpData instanceof YangIdentityRef) {
        return;
    }
    if (!(tmpData instanceof YangIdentity)) {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, BASE_DATA, ctx.string().getText(), ENTRY));
    }
    YangBase yangBase = new YangBase();
    yangBase.setBaseIdentifier(nodeIdentifier);
    ((YangIdentity) tmpData).setBaseNode(yangBase);
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    // Add resolution information to the list
    YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangBase>(yangBase, (YangNode) tmpData, errorLine, errorPosition);
    addToResolutionList(resolutionInfo, ctx);
}
#end_block

#method_before
@Override
public LinkProvider provider() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public DeviceProvider provider() {
    return null;
}
#end_block

#method_before
@Override
public void deleteLink(BgpLinkLsNlriVer4 linkNlri) throws BgpParseException {
    log.debug("Delete link {}", linkNlri.toString());
    if (linkProviderService == null) {
        return;
    }
    LinkDescription linkDes = buildLinkDes(linkNlri, null, false);
    /*
             * Only master for the link src will release the bandwidth resource.
             */
    if (networkConfigService != null && mastershipService.isLocalMaster(linkDes.src().deviceId())) {
        // Releases registered resource for this link
        networkConfigService.removeConfig(linkDes.src(), BandwidthCapacity.class);
        networkConfigService.removeConfig(linkDes.dst(), BandwidthCapacity.class);
    }
    linkProviderService.linkVanished(linkDes);
    linkDes = buildLinkDesForOtherLink(linkNlri, null, false);
    linkProviderService.linkVanished(linkDes);
}
#method_after
@Override
public void deleteLink(BgpLinkLsNlriVer4 linkNlri) throws BgpParseException {
    log.debug("Delete link {}", linkNlri.toString());
    if (linkProviderService == null) {
        return;
    }
    LinkDescription linkDes = buildLinkDes(linkNlri, null, false);
    /*
             * Only master for the link src will release the bandwidth resource.
             */
    if (networkConfigService != null && mastershipService.isLocalMaster(linkDes.src().deviceId())) {
        // Releases registered resource for this link
        networkConfigService.removeConfig(linkDes.src(), BandwidthCapacity.class);
        networkConfigService.removeConfig(linkDes.dst(), BandwidthCapacity.class);
    }
    linkProviderService.linkVanished(linkDes);
    linkDes = new DefaultLinkDescription(linkDes.dst(), linkDes.src(), Link.Type.DIRECT, false, linkDes.annotations());
    linkProviderService.linkVanished(linkDes);
}
#end_block

#method_before
@Override
public boolean releasePath(TunnelId tunnelId) {
    checkNotNull(tunnelId);
    // 1. Query Tunnel from Tunnel manager.
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    if (tunnel == null) {
        return false;
    }
    LspType lspType = LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE));
    if (lspType != WITH_SIGNALLING) {
        localLspIdFreeList.add(Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)));
    }
    // If not zero bandwidth, and delegated (initiated LSPs will also be delegated).
    Log.info("tunnel.annotations().value(BANDWIDTH) :: " + tunnel.annotations().value(BANDWIDTH));
    if (Double.parseDouble(tunnel.annotations().value(BANDWIDTH)) != 0.0) {
        releaseBandwidth(tunnel);
        // Release basic PCECC labels.
        if (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR) {
            // Delete stored tunnel consumer id from PCE store (while still retaining label list.)
            PceccTunnelInfo pceccTunnelInfo = pceStore.getTunnelInfo(tunnel.tunnelId());
            pceccTunnelInfo.tunnelConsumerId(null);
            if (mastershipService.getLocalRole(tunnel.path().src().deviceId()) == MastershipRole.MASTER) {
                crHandler.releaseLabel(tunnel);
            }
        }
    }
    // 2. Call tunnel service.
    return tunnelService.downTunnel(appId, tunnel.tunnelId());
}
#method_after
@Override
public boolean releasePath(TunnelId tunnelId) {
    checkNotNull(tunnelId);
    // 1. Query Tunnel from Tunnel manager.
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    if (tunnel == null) {
        return false;
    }
    LspType lspType = LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE));
    // Release basic PCECC labels.
    if (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR) {
        crHandler.releaseLabel(tunnel);
    }
    // 2. Call tunnel service.
    return tunnelService.downTunnel(appId, tunnel.tunnelId());
}
#end_block

#method_before
@Override
public void event(TunnelEvent event) {
    // Event gets generated with old tunnel object.
    Tunnel tunnel = event.subject();
    if (tunnel.type() != MPLS) {
        return;
    }
    LspType lspType = LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE));
    String tunnelBandwidth = tunnel.annotations().value(BANDWIDTH);
    double bwConstraintValue = 0;
    if (tunnelBandwidth != null) {
        bwConstraintValue = Double.parseDouble(tunnelBandwidth);
    }
    switch(event.type()) {
        case TUNNEL_ADDED:
            // Allocate bandwidth for non-initiated, delegated LSPs with non-zero bandwidth (learned LSPs).
            String pceInit = tunnel.annotations().value(PCE_INIT);
            if (FALSE.equalsIgnoreCase(pceInit) && bwConstraintValue != 0) {
                reserveBandwidth(tunnel.path(), bwConstraintValue, null);
            }
            break;
        case TUNNEL_UPDATED:
            // Allocate/send labels for basic PCECC tunnels.
            if ((tunnel.state() == ESTABLISHED) && (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR) && (mastershipService.getLocalRole(tunnel.path().src().deviceId()) == MastershipRole.MASTER)) {
                if (!crHandler.allocateLabel(tunnel)) {
                    log.error("Unable to allocate labels for a tunnel {}.", tunnel.toString());
                }
            }
            // In CR case, release labels when new tunnel for it is updated.
            if (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR) {
                Collection<Tunnel> tunnels = tunnelService.queryTunnel(tunnel.src(), tunnel.dst());
                for (Tunnel t : tunnels) {
                    if (tunnel.annotations().value(PLSP_ID).equals(t.annotations().value(PLSP_ID)) && !tunnel.annotations().value(LOCAL_LSP_ID).equals(t.annotations().value(LOCAL_LSP_ID))) {
                        if (lspType != WITH_SIGNALLING) {
                            localLspIdFreeList.add(Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)));
                        }
                        // If not zero bandwidth, and delegated (initiated LSPs will also be delegated).
                        if (bwConstraintValue != 0) {
                            releaseBandwidth(event.subject());
                            // Release basic PCECC labels.
                            if (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR) {
                                // Delete stored tunnel consumer id from PCE store
                                // (while still retaining label list.)
                                PceccTunnelInfo pceccTunnelInfo = pceStore.getTunnelInfo(tunnel.tunnelId());
                                pceccTunnelInfo.tunnelConsumerId(null);
                                if (mastershipService.getLocalRole(tunnel.path().src().deviceId()) == MastershipRole.MASTER) {
                                    crHandler.releaseLabel(tunnel);
                                }
                            }
                        }
                    }
                }
            }
            if (tunnel.state() == UNSTABLE) {
                /*
                     * During LSP DB sync if PCC doesn't report LSP which was PCE initiated, it's state is turned into
                     * unstable so that it can be setup again. Add into failed path store so that it can be recomputed
                     * and setup while global reoptimization.
                     */
                List<Constraint> constraints = new LinkedList<>();
                String bandwidth = tunnel.annotations().value(BANDWIDTH);
                if (bandwidth != null) {
                    constraints.add(new BandwidthConstraint(Bandwidth.bps(Double.parseDouble(bandwidth))));
                }
                String costType = tunnel.annotations().value(COST_TYPE);
                if (costType != null) {
                    CostConstraint costConstraint = new CostConstraint(CostConstraint.Type.valueOf(costType));
                    constraints.add(costConstraint);
                }
                constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE))));
                List<Link> links = tunnel.path().links();
                pceStore.addFailedPathInfo(new PcePathInfo(links.get(0).src().deviceId(), links.get(links.size() - 1).dst().deviceId(), tunnel.tunnelName().value(), constraints, lspType));
            }
            break;
        case TUNNEL_REMOVED:
            // Release basic PCECC labels.
            if (lspType != WITHOUT_SIGNALLING_AND_WITHOUT_SR) {
                pceStore.removeTunnelInfo(tunnel.tunnelId());
            }
            break;
        default:
            break;
    }
    return;
}
#method_after
@Override
public void event(TunnelEvent event) {
    // Event gets generated with old tunnel object.
    Tunnel tunnel = event.subject();
    if (tunnel.type() != MPLS) {
        return;
    }
    LspType lspType = LspType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE));
    String tunnelBandwidth = tunnel.annotations().value(BANDWIDTH);
    double bwConstraintValue = 0;
    if (tunnelBandwidth != null) {
        bwConstraintValue = Double.parseDouble(tunnelBandwidth);
    }
    switch(event.type()) {
        case TUNNEL_ADDED:
            // Allocate bandwidth for non-initiated, delegated LSPs with non-zero bandwidth (learned LSPs).
            String pceInit = tunnel.annotations().value(PCE_INIT);
            if (FALSE.equalsIgnoreCase(pceInit) && bwConstraintValue != 0) {
                reserveBandwidth(tunnel.path(), bwConstraintValue, null);
            }
            break;
        case TUNNEL_UPDATED:
            // Allocate/send labels for basic PCECC tunnels.
            if ((tunnel.state() == ESTABLISHED) && (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR) && (mastershipService.getLocalRole(tunnel.path().src().deviceId()) == MastershipRole.MASTER)) {
                if (!crHandler.allocateLabel(tunnel)) {
                    log.error("Unable to allocate labels for a tunnel {}.", tunnel.toString());
                }
            }
            // In CR case, release labels when new tunnel for it is updated.
            if (lspType == WITHOUT_SIGNALLING_AND_WITHOUT_SR && tunnel.state() == ACTIVE && mastershipService.getLocalRole(tunnel.path().src().deviceId()) == MastershipRole.MASTER) {
                Collection<Tunnel> tunnels = tunnelService.queryTunnel(tunnel.src(), tunnel.dst());
                for (Tunnel t : tunnels) {
                    if (tunnel.annotations().value(PLSP_ID).equals(t.annotations().value(PLSP_ID)) && !tunnel.annotations().value(LOCAL_LSP_ID).equals(t.annotations().value(LOCAL_LSP_ID))) {
                        // Release basic PCECC labels.
                        crHandler.releaseLabel(t);
                        break;
                    }
                }
            }
            if (tunnel.state() == UNSTABLE) {
                /*
                     * During LSP DB sync if PCC doesn't report LSP which was PCE initiated, it's state is turned into
                     * unstable so that it can be setup again. Add into failed path store so that it can be recomputed
                     * and setup while global reoptimization.
                     */
                List<Constraint> constraints = new LinkedList<>();
                String bandwidth = tunnel.annotations().value(BANDWIDTH);
                if (bandwidth != null) {
                    constraints.add(new BandwidthConstraint(Bandwidth.bps(Double.parseDouble(bandwidth))));
                }
                String costType = tunnel.annotations().value(COST_TYPE);
                if (costType != null) {
                    CostConstraint costConstraint = new CostConstraint(CostConstraint.Type.valueOf(costType));
                    constraints.add(costConstraint);
                }
                constraints.add(CapabilityConstraint.of(CapabilityType.valueOf(tunnel.annotations().value(LSP_SIG_TYPE))));
                List<Link> links = tunnel.path().links();
                pceStore.addFailedPathInfo(new PcePathInfo(links.get(0).src().deviceId(), links.get(links.size() - 1).dst().deviceId(), tunnel.tunnelName().value(), constraints, lspType));
            }
            break;
        case TUNNEL_REMOVED:
            if (lspType != WITH_SIGNALLING) {
                localLspIdFreeList.add(Short.valueOf(tunnel.annotations().value(LOCAL_LSP_ID)));
            }
            // If not zero bandwidth, and delegated (initiated LSPs will also be delegated).
            if (Double.parseDouble(tunnel.annotations().value(BANDWIDTH)) != 0.0 && mastershipService.getLocalRole(tunnel.path().src().deviceId()) == MastershipRole.MASTER) {
                releaseBandwidth(tunnel);
            }
            if (pceStore.getTunnelInfo(tunnel.tunnelId()) != null) {
                pceStore.removeTunnelInfo(tunnel.tunnelId());
            }
            break;
        default:
            break;
    }
    return;
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefReferToContainerLeaf() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToContainerLeaf.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefReferToContainerLeaf() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToContainerLeaf.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToLeafInInputOfRpc() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToLeafInInputOfRpc.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToLeafInInputOfRpc() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToLeafInInputOfRpc.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToGroupingWithInputInRpc() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToGroupingWithInputInRpc.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToGroupingWithInputInRpc() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToGroupingWithInputInRpc.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToGrouping() throws IOException, ParserException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage("Yang file error: The target node of leafref is invalid.");
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToGroupingInModule.yang");
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToGrouping() throws IOException, ParserException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage("YANG file error: The target node of leafref is invalid.");
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToGroupingInModule.yang");
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefIsInDeepTreeAndLeafIsInModuleWithReferredTypeUnion() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefIsInDeepTreeAndLeafIsInModuleWithReferredTypeUnion.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerParent = (YangContainer) yangNode.getChild().getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerParent.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UNION));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefIsInDeepTreeAndLeafIsInModuleWithReferredTypeUnion() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefIsInDeepTreeAndLeafIsInModuleWithReferredTypeUnion.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerParent = (YangContainer) yangNode.getChild().getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerParent.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("name"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UNION));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefReferToContainerLeafList() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToContainerLeafList.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeafList> leafListIterator;
    YangLeafList leafListInfo;
    leafListIterator = yangNode.getListOfLeafList().listIterator();
    leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefReferToContainerLeafList() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToContainerLeafList.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeafList> leafListIterator;
    YangLeafList leafListInfo;
    leafListIterator = yangNode.getListOfLeafList().listIterator();
    leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToLeafListInInputOfRpc() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToLeafListInInputOfRpc.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeafList> leafListIterator;
    YangLeafList leafListInfo;
    leafListIterator = yangNode.getListOfLeafList().listIterator();
    leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToLeafListInInputOfRpc() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToLeafListInInputOfRpc.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeafList> leafListIterator;
    YangLeafList leafListInfo;
    leafListIterator = yangNode.getListOfLeafList().listIterator();
    leafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("network-ref"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefIsInDeepTreeAndLeafListIsInModuleWithReferredTypeEnumeration() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/" + "SelfResolutionWhenLeafrefIsInDeepTreeAndLeafListIsInModuleWithReferredTypeEnumeration.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerParent = (YangContainer) yangNode.getChild().getChild().getChild();
    ListIterator<YangLeafList> leafListListIterator;
    YangLeafList leafListInfo;
    leafListListIterator = containerParent.getListOfLeafList().listIterator();
    leafListInfo = leafListListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("name"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.ENUMERATION));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefIsInDeepTreeAndLeafListIsInModuleWithReferredTypeEnumeration() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/" + "SelfResolutionWhenLeafrefIsInDeepTreeAndLeafListIsInModuleWithReferredTypeEnumeration.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerParent = (YangContainer) yangNode.getChild().getChild().getChild();
    ListIterator<YangLeafList> leafListListIterator;
    YangLeafList leafListInfo;
    leafListListIterator = containerParent.getListOfLeafList().listIterator();
    leafListInfo = leafListListIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafListInfo.getName(), is("name"));
    assertThat(leafListInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafListInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.ENUMERATION));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefInTypedefReferToContainer() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInTypedefReferToContainer.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    YangContainer yangContainer = (YangContainer) yangNode.getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("network-id"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefInTypedefReferToContainer() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInTypedefReferToContainer.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    YangContainer yangContainer = (YangContainer) yangNode.getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("network-id"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefInTypedefModuleReferToLeafListInInputOfRpc() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInTypedefModuleReferToLeafListInInputOfRpc.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    YangInput yangInput = (YangInput) yangNode.getChild().getChild();
    ListIterator<YangLeafList> leafListIterator;
    YangLeafList yangLeafListInfo;
    leafListIterator = yangInput.getListOfLeafList().listIterator();
    yangLeafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(yangLeafListInfo.getName(), is("network-id"));
    assertThat(yangLeafListInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (yangLeafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefInTypedefModuleReferToLeafListInInputOfRpc() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInTypedefModuleReferToLeafListInInputOfRpc.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    YangInput yangInput = (YangInput) yangNode.getChild().getChild();
    ListIterator<YangLeafList> leafListIterator;
    YangLeafList yangLeafListInfo;
    leafListIterator = yangInput.getListOfLeafList().listIterator();
    yangLeafListInfo = leafListIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(yangLeafListInfo.getName(), is("network-id"));
    assertThat(yangLeafListInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (yangLeafListInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefInTypedefIsInDeepTreeAndLeafListIsInModuleWithReferredTypeEnumeration() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/" + "SelfResolutionWhenLeafrefInTypedefIs" + "InDeepTreeAndLeafListIsInModuleWithReferredTypeEnumeration.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) yangNode.getChild().getChild().getChild().getNextSibling();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf yangLeafInfo;
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    yangLeafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(yangLeafInfo.getName(), is("interval"));
    assertThat(yangLeafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (yangLeafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.ENUMERATION));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefInTypedefIsInDeepTreeAndLeafListIsInModuleWithReferredTypeEnumeration() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/" + "SelfResolutionWhenLeafrefInTypedefIs" + "InDeepTreeAndLeafListIsInModuleWithReferredTypeEnumeration.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer yangContainer = (YangContainer) yangNode.getChild().getChild().getChild().getNextSibling();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf yangLeafInfo;
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    yangLeafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(yangLeafInfo.getName(), is("interval"));
    assertThat(yangLeafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (yangLeafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.ENUMERATION));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefRefersAnotherLeafref() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToAnotherLeafref.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // YangGrouping grouping = (YangGrouping) yangNode.getChild().getNextSibling();
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefRefersAnotherLeafref() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToAnotherLeafref.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // YangGrouping grouping = (YangGrouping) yangNode.getChild().getNextSibling();
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefReferToMultipleLeafref() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToMultipleLeafref.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    YangContainer containerInList = (YangContainer) containerInModule.getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerInList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("remove"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.ENUMERATION));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefReferToMultipleLeafref() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToMultipleLeafref.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    YangContainer containerInList = (YangContainer) containerInModule.getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerInList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("remove"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.ENUMERATION));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefRefersAnotherDerivedType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToAnotherDerivedType.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // YangGrouping grouping = (YangGrouping) yangNode.getChild().getNextSibling();
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefRefersAnotherDerivedType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToAnotherDerivedType.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    // YangGrouping grouping = (YangGrouping) yangNode.getChild().getNextSibling();
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.DERIVED));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefReferToMultipleTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToMultipleTypedef.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    YangContainer containerInList = (YangContainer) containerInModule.getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerInList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("remove"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.ENUMERATION));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefReferToMultipleTypedef() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToMultipleTypedef.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    YangContainer containerInList = (YangContainer) containerInModule.getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerInList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("remove"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.DERIVED));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefReferToDerivedTypeReferringToLeafWithLeafref() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToDerivedTypeReferringToLeafWithLeafref.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    YangContainer containerInList = (YangContainer) containerInModule.getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerInList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("remove"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.ENUMERATION));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefReferToDerivedTypeReferringToLeafWithLeafref() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToDerivedTypeReferringToLeafWithLeafref.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    YangContainer containerInList = (YangContainer) containerInModule.getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerInList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("remove"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.ENUMERATION));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefReferToContainerLeafRelPath() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToContainerLeafRelPath.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefReferToContainerLeafRelPath() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToContainerLeafRelPath.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToGroupingWithInputInRpcRelPath() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToGroupingWithInputInRpcRelPath.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToGroupingWithInputInRpcRelPath() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToGroupingWithInputInRpcRelPath.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = yangNode.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct.
    assertThat(leafInfo.getName(), is("network-ref"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToInvalidRootNodeRelPath() throws IOException, ParserException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage("Yang file error: The target node of leafref is invalid.");
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToInvalidRootNodeRelPath.yang");
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefInModuleReferToInvalidRootNodeRelPath() throws IOException, ParserException {
    thrown.expect(LinkerException.class);
    thrown.expectMessage("YANG file error: The target node of leafref is invalid.");
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInModuleReferToInvalidRootNodeRelPath.yang");
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefInTypedefReferToContainerRelPath() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInTypedefReferToContainerRelPath.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    YangContainer yangContainer = (YangContainer) yangNode.getChild();
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("network-id"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.UINT8));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefInTypedefReferToContainerRelPath() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefInTypedefReferToContainerRelPath.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("ietf-network"));
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    YangContainer yangContainer = (YangContainer) yangNode.getChild();
    leafIterator = yangContainer.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("network-id"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    // Check whether leafref type got resolved.
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    // Check the effective type for the leaf.
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.UINT8));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefReferToMultipleLeafrefRelPath() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToMultipleLeafrefRelPath.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    YangContainer containerInList = (YangContainer) containerInModule.getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerInList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("remove"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.ENUMERATION));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefReferToMultipleLeafrefRelPath() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToMultipleLeafrefRelPath.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    YangContainer containerInList = (YangContainer) containerInModule.getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerInList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("remove"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) (leafInfo.getDataType().getDataTypeExtendedInfo());
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.ENUMERATION));
}
#end_block

#method_before
@Test
public void processSelfResolutionWhenLeafrefReferToDerivedTypeReferringToLeafWithLeafrefRelType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToDerivedTypeReferringToLeafWithLeafrefRelType.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    YangContainer containerInList = (YangContainer) containerInModule.getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerInList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("remove"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.ENUMERATION));
}
#method_after
@Test
public void processSelfResolutionWhenLeafrefReferToDerivedTypeReferringToLeafWithLeafrefRelType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/SelfResolutionWhenLeafrefReferToDerivedTypeReferringToLeafWithLeafrefRelType.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    YangContainer containerInList = (YangContainer) containerInModule.getChild().getChild();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    leafIterator = containerInList.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("remove"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafref.getResolvableStatus(), is(ResolvableStatus.RESOLVED));
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.ENUMERATION));
}
#end_block

#method_before
@Test
public void processPathArgumentStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/PathListener.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("PathListener"));
    YangList listInModule = (YangList) yangNode.getChild();
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    YangLeaf leafNameInList = listInModule.getListOfLeaf().listIterator().next();
    leafIterator = containerInModule.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("ifname"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafref.getPathType(), is(YangPathArgType.RELATIVEPATH));
    YangRelativePath relativePathForName = leafref.getRelativePath();
    assertThat(relativePathForName.getAncestor(), is(2));
    List<YangAbsPath> absPathForName = relativePathForName.getAbsolutePath();
    Iterator<YangAbsPath> absPathIteratorForName = absPathForName.listIterator();
    YangAbsPath abspathForName = absPathIteratorForName.next();
    assertThat(abspathForName.getNodeIdentifier().getName(), is("interface"));
    assertThat(abspathForName.getNodeIdentifier().getPrefix(), is("test"));
    YangAbsPath abspath1 = absPathIteratorForName.next();
    assertThat(abspath1.getNodeIdentifier().getName(), is("name"));
    assertThat(abspath1.getNodeIdentifier().getPrefix(), is("test"));
    YangLeaf leafInfo1 = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo1.getName(), is("status"));
    assertThat(leafInfo1.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo1.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref1 = (YangLeafRef) leafInfo1.getDataType().getDataTypeExtendedInfo();
    assertThat(leafref1.getPathType(), is(YangPathArgType.ABSOLUTEPATH));
    List<YangAbsPath> absolutePathList = leafref1.getAbsolutePath();
    Iterator<YangAbsPath> absPathIterator = absolutePathList.listIterator();
    YangAbsPath abspath = absPathIterator.next();
    assertThat(abspath.getNodeIdentifier().getName(), is("interface"));
    assertThat(abspath.getNodeIdentifier().getPrefix(), is("test"));
    List<YangPathPredicate> pathPredicateList = abspath.getPredicatesExp();
    Iterator<YangPathPredicate> pathPredicate = pathPredicateList.listIterator();
    YangPathPredicate pathPredicate1 = pathPredicate.next();
    assertThat(pathPredicate1.getNodeIdentifier().getName(), is("name"));
    assertThat(pathPredicate1.getNodeIdentifier().getPrefix(), nullValue());
    assertThat(pathPredicate1.getRightRelativePath().getAncestor(), is(1));
    assertThat(pathPredicate1.getPathOperator(), is(YangPathOperator.EQUALTO));
    assertThat(pathPredicate1.getRightRelativePath().getAbsolutePath().listIterator().next().getNodeIdentifier().getName(), is("ifname"));
    YangAbsPath abspath2 = absPathIterator.next();
    assertThat(abspath2.getNodeIdentifier().getName(), is("admin-status"));
    assertThat(abspath2.getNodeIdentifier().getPrefix(), is("test"));
    assertThat(pathPredicate1.getLeftAxisNode(), is(leafNameInList));
    assertThat(pathPredicate1.getRightAxisNode(), is(leafInfo));
}
#method_after
@Test
public void processPathArgumentStatement() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/PathListener.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("PathListener"));
    YangList listInModule = (YangList) yangNode.getChild();
    YangContainer containerInModule = (YangContainer) yangNode.getChild().getNextSibling();
    ListIterator<YangLeaf> leafIterator;
    YangLeaf leafInfo;
    YangLeaf leafNameInList = listInModule.getListOfLeaf().listIterator().next();
    leafIterator = containerInModule.getListOfLeaf().listIterator();
    leafInfo = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo.getName(), is("ifname"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafref.getPathType(), is(YangPathArgType.RELATIVE_PATH));
    YangRelativePath relativePathForName = leafref.getRelativePath();
    assertThat(relativePathForName.getAncestorNodeCount(), is(2));
    List<YangAtomicPath> absPathForName = relativePathForName.getAtomicPathList();
    Iterator<YangAtomicPath> absPathIteratorForName = absPathForName.listIterator();
    YangAtomicPath abspathForName = absPathIteratorForName.next();
    assertThat(abspathForName.getNodeIdentifier().getName(), is("interface"));
    assertThat(abspathForName.getNodeIdentifier().getPrefix(), is("test"));
    YangAtomicPath abspath1 = absPathIteratorForName.next();
    assertThat(abspath1.getNodeIdentifier().getName(), is("name"));
    assertThat(abspath1.getNodeIdentifier().getPrefix(), is("test"));
    YangLeaf leafInfo1 = leafIterator.next();
    // Check whether the information in the leaf is correct under grouping.
    assertThat(leafInfo1.getName(), is("status"));
    assertThat(leafInfo1.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo1.getDataType().getDataType(), is(YangDataTypes.LEAFREF));
    YangLeafRef leafref1 = (YangLeafRef) leafInfo1.getDataType().getDataTypeExtendedInfo();
    assertThat(leafref1.getPathType(), is(YangPathArgType.ABSOLUTE_PATH));
    List<YangAtomicPath> absolutePathList = leafref1.getAtomicPath();
    Iterator<YangAtomicPath> absPathIterator = absolutePathList.listIterator();
    YangAtomicPath abspath = absPathIterator.next();
    assertThat(abspath.getNodeIdentifier().getName(), is("interface"));
    assertThat(abspath.getNodeIdentifier().getPrefix(), is("test"));
    List<YangPathPredicate> pathPredicateList = abspath.getPathPredicatesList();
    Iterator<YangPathPredicate> pathPredicate = pathPredicateList.listIterator();
    YangPathPredicate pathPredicate1 = pathPredicate.next();
    assertThat(pathPredicate1.getNodeIdentifier().getName(), is("name"));
    assertThat(pathPredicate1.getNodeIdentifier().getPrefix(), nullValue());
    assertThat(pathPredicate1.getRightRelativePath().getAncestorNodeCount(), is(1));
    assertThat(pathPredicate1.getPathOperator(), is(YangPathOperator.EQUALTO));
    assertThat(pathPredicate1.getRightRelativePath().getAtomicPathList().listIterator().next().getNodeIdentifier().getName(), is("ifname"));
    YangAtomicPath abspath2 = absPathIterator.next();
    assertThat(abspath2.getNodeIdentifier().getName(), is("admin-status"));
    assertThat(abspath2.getNodeIdentifier().getPrefix(), is("test"));
    assertThat(pathPredicate1.getLeftAxisNode(), is(leafNameInList));
    assertThat(pathPredicate1.getRightAxisNode(), is(leafInfo));
}
#end_block

#method_before
public static void processPathEntry(TreeWalkListener listener, GeneratedYangParser.PathStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, PATH_DATA, ctx.path().getText(), ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    // Checks the holder of path as leafref, else throws error.
    if (curData instanceof YangLeafRef) {
        ((YangLeafRef) curData).setPath(ctx.path().getText());
        // Splitting the path argument and updating it in the datamodel tree.
        validatePathArgument(ctx.path().getText(), PATH_DATA, ctx, (YangLeafRef) curData);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, PATH_DATA, ctx.path().getText(), ENTRY));
    }
}
#method_after
public static void processPathEntry(TreeWalkListener listener, GeneratedYangParser.PathStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, PATH_DATA, ctx.path().getText(), ENTRY);
    Parsable curData = listener.getParsedDataStack().peek();
    // Checks the holder of path as leafref, else throws error.
    if (curData instanceof YangLeafRef) {
        // Splitting the path argument and updating it in the datamodel tree.
        validatePathArgument(ctx.path().getText(), PATH_DATA, ctx, (YangLeafRef) curData);
    } else {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, PATH_DATA, ctx.path().getText(), ENTRY));
    }
}
#end_block

#method_before
public static String getJavaDataType(YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE;
        case INT16:
            return SHORT;
        case INT32:
            return INT;
        case INT64:
            return LONG;
        case UINT8:
            return SHORT;
        case UINT16:
            return INT;
        case UINT32:
            return LONG;
        case UINT64:
            return BIG_INTEGER;
        case BINARY:
            return YANG_BINARY_CLASS;
        case DECIMAL64:
            return YANG_DECIMAL64_CLASS;
        case STRING:
            return STRING_DATA_TYPE;
        case BOOLEAN:
            return BOOLEAN_DATA_TYPE;
        default:
            throw new TranslatorException("given data type is not supported.");
    }
}
#method_after
public static String getJavaDataType(YangType<?> yangType) {
    YangDataTypes type = yangType.getDataType();
    switch(type) {
        case INT8:
            return BYTE;
        case INT16:
            return SHORT;
        case INT32:
            return INT;
        case INT64:
            return LONG;
        case UINT8:
            return SHORT;
        case UINT16:
            return INT;
        case UINT32:
            return LONG;
        case UINT64:
            return BIG_INTEGER;
        case BINARY:
            return YANG_BINARY_CLASS;
        case DECIMAL64:
            return YANG_DECIMAL64_CLASS;
        case STRING:
            return STRING_DATA_TYPE;
        case BOOLEAN:
            return BOOLEAN_DATA_TYPE;
        case INSTANCE_IDENTIFIER:
            return STRING_DATA_TYPE;
        case LEAFREF:
            return getJavaDataType(getReferredTypeFromLeafref(yangType));
        default:
            throw new TranslatorException("given data type is not supported.");
    }
}
#end_block

#method_before
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr, YangToJavaNamingConflictUtil pluginConfig) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return YANG_DECIMAL64_CLASS;
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return YANG_BITS_CLASS;
            case BINARY:
                return YANG_BINARY_CLASS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportClass(referredType, isListAttr, pluginConfig);
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return YANG_DECIMAL64_CLASS;
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return YANG_BITS_CLASS;
            case BINARY:
                return YANG_BINARY_CLASS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportClass(referredType, isListAttr, pluginConfig);
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return BOOLEAN_DATA_TYPE;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                return null;
        }
    }
    return null;
}
#method_after
public static String getJavaImportClass(YangType<?> yangType, boolean isListAttr, YangToJavaNamingConflictUtil pluginConfig) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
                return BYTE_WRAPPER;
            case INT16:
                return SHORT_WRAPPER;
            case INT32:
                return INTEGER_WRAPPER;
            case INT64:
                return LONG_WRAPPER;
            case UINT8:
                return SHORT_WRAPPER;
            case UINT16:
                return INTEGER_WRAPPER;
            case UINT32:
                return LONG_WRAPPER;
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return YANG_DECIMAL64_CLASS;
            case STRING:
                return STRING_DATA_TYPE;
            case BOOLEAN:
                return BOOLEAN_WRAPPER;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return YANG_BITS_CLASS;
            case BINARY:
                return YANG_BINARY_CLASS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportClass(referredType, isListAttr, pluginConfig);
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return BOOLEAN_WRAPPER;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                return STRING_DATA_TYPE;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return BIG_INTEGER;
            case DECIMAL64:
                return YANG_DECIMAL64_CLASS;
            case STRING:
                return STRING_DATA_TYPE;
            case ENUMERATION:
                return getCapitalCase(getCamelCase(((YangJavaEnumeration) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case BITS:
                return YANG_BITS_CLASS;
            case BINARY:
                return YANG_BINARY_CLASS;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportClass(referredType, isListAttr, pluginConfig);
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return BOOLEAN_DATA_TYPE;
            case UNION:
                return getCapitalCase(getCamelCase(((YangJavaUnion) yangType.getDataTypeExtendedInfo()).getName(), pluginConfig));
            case INSTANCE_IDENTIFIER:
                return STRING_DATA_TYPE;
            case DERIVED:
                return getCapitalCase(getCamelCase(yangType.getDataTypeName(), pluginConfig));
            default:
                return null;
        }
    }
    return null;
}
#end_block

#method_before
public static String getJavaImportPackage(YangType<?> yangType, boolean isListAttr, YangToJavaNamingConflictUtil conflictResolver) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
            case INT16:
            case INT32:
            case INT64:
            case UINT8:
            case UINT16:
            case UINT32:
            case STRING:
            case BOOLEAN:
            case EMPTY:
                return JAVA_LANG;
            case UINT64:
                return JAVA_MATH;
            case ENUMERATION:
                return getEnumsPackage(yangType, conflictResolver);
            case DECIMAL64:
            case BITS:
            case BINARY:
                return YANG_TYPES_PKG;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportPackage(referredType, isListAttr, conflictResolver);
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case UNION:
                return getUnionPackage(yangType, conflictResolver);
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getTypDefsPackage(yangType, conflictResolver);
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return JAVA_MATH;
            case STRING:
                return JAVA_LANG;
            case ENUMERATION:
                return getEnumsPackage(yangType, conflictResolver);
            case DECIMAL64:
            case BITS:
            case BINARY:
                return YANG_TYPES_PKG;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportPackage(referredType, isListAttr, conflictResolver);
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return JAVA_LANG;
            case UNION:
                return getUnionPackage(yangType, conflictResolver);
            case INSTANCE_IDENTIFIER:
                // TODO:INSTANCE_IDENTIFIER
                break;
            case DERIVED:
                return getTypDefsPackage(yangType, conflictResolver);
            default:
                return null;
        }
    }
    return null;
}
#method_after
public static String getJavaImportPackage(YangType<?> yangType, boolean isListAttr, YangToJavaNamingConflictUtil conflictResolver) {
    YangDataTypes type = yangType.getDataType();
    if (isListAttr) {
        switch(type) {
            case INT8:
            case INT16:
            case INT32:
            case INT64:
            case UINT8:
            case UINT16:
            case UINT32:
            case STRING:
            case BOOLEAN:
            case EMPTY:
                return JAVA_LANG;
            case UINT64:
                return JAVA_MATH;
            case ENUMERATION:
                return getEnumsPackage(yangType, conflictResolver);
            case DECIMAL64:
            case BITS:
            case BINARY:
                return YANG_TYPES_PKG;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportPackage(referredType, isListAttr, conflictResolver);
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case UNION:
                return getUnionPackage(yangType, conflictResolver);
            case INSTANCE_IDENTIFIER:
                return JAVA_LANG;
            case DERIVED:
                return getTypDefsPackage(yangType, conflictResolver);
            default:
                throw new TranslatorException("given data type is not supported.");
        }
    } else {
        switch(type) {
            case UINT64:
                return JAVA_MATH;
            case STRING:
                return JAVA_LANG;
            case ENUMERATION:
                return getEnumsPackage(yangType, conflictResolver);
            case DECIMAL64:
            case BITS:
            case BINARY:
                return YANG_TYPES_PKG;
            case LEAFREF:
                YangType<?> referredType = getReferredTypeFromLeafref(yangType);
                return getJavaImportPackage(referredType, isListAttr, conflictResolver);
            case IDENTITYREF:
                // TODO:IDENTITYREF
                break;
            case EMPTY:
                return JAVA_LANG;
            case UNION:
                return getUnionPackage(yangType, conflictResolver);
            case INSTANCE_IDENTIFIER:
                return JAVA_LANG;
            case DERIVED:
                return getTypDefsPackage(yangType, conflictResolver);
            default:
                return null;
        }
    }
    return null;
}
#end_block

#method_before
private static YangType<?> getReferredTypeFromLeafref(YangType type) {
    YangType<?> referredType;
    YangLeafRef<?> leafRefInfo = (YangLeafRef<?>) type.getDataTypeExtendedInfo();
    if (leafRefInfo.getReferredLeafOrLeafList() instanceof YangLeaf) {
        YangLeaf leaf = (YangLeaf) leafRefInfo.getReferredLeafOrLeafList();
        referredType = leaf.getDataType();
    } else {
        YangLeafList leafList = (YangLeafList) leafRefInfo.getReferredLeafOrLeafList();
        referredType = leafList.getDataType();
    }
    return referredType;
}
#method_after
private static YangType<?> getReferredTypeFromLeafref(YangType type) {
    YangLeafRef<?> leafRefInfo = (YangLeafRef<?>) type.getDataTypeExtendedInfo();
    return leafRefInfo.getEffectiveDataType();
}
#end_block

#method_before
public static String getValidIdentifierForLeafref(String identifier, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    String identifierString = removeQuotesAndHandleConcat(identifier);
    ParserException parserException;
    if (identifierString.length() > IDENTIFIER_LENGTH) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " is " + "greater than 64 characters.");
    } else if (!IDENTIFIER_PATTERN.matcher(identifierString).matches()) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " is not " + "valid.");
    } else if (identifierString.toLowerCase().startsWith(XML)) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " must not start with (('X'|'x') ('M'|'m') ('L'|'l')).");
    } else {
        return identifierString;
    }
    parserException.setLine(ctx.getStart().getLine());
    parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
    throw parserException;
}
#method_after
public static String getValidIdentifierForLeafref(String identifier, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    String identifierString = removeQuotesAndHandleConcat(identifier);
    ParserException parserException;
    if (identifierString.length() > IDENTIFIER_LENGTH) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " is " + "greater than 64 characters.");
    } else if (!IDENTIFIER_PATTERN.matcher(identifierString).matches()) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " is not " + "valid.");
    } else if (identifierString.toLowerCase().startsWith(XML)) {
        parserException = new ParserException("YANG file error : " + " identifier " + identifierString + " in " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " must not start with (('X'|'x') ('M'|'m') ('L'|'l')).");
    } else {
        return identifierString;
    }
    parserException.setLine(ctx.getStart().getLine());
    parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
    throw parserException;
}
#end_block

#method_before
public static void validatePathArgument(String pathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    String completePathString = removeQuotesAndHandleConcat(pathString);
    if (completePathString.startsWith(SLASH)) {
        yangLeafRef.setPathType(ABSOLUTEPATH);
        List<YangAbsPath> yangAbsoluteList = validateAbsolutePath(completePathString, yangConstruct, ctx, yangLeafRef);
        yangLeafRef.setAbsolutePath(yangAbsoluteList);
    } else if (completePathString.startsWith(ANCESTOR_ACCESSOR)) {
        yangLeafRef.setPathType(RELATIVEPATH);
        validateRelativePath(completePathString, yangConstruct, ctx, yangLeafRef);
    } else {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
}
#method_after
public static void validatePathArgument(String pathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    String completePathString = removeQuotesAndHandleConcat(pathString);
    yangLeafRef.setPath(completePathString);
    if (completePathString.startsWith(SLASH)) {
        yangLeafRef.setPathType(ABSOLUTE_PATH);
        List<YangAtomicPath> yangAtomicPathListList = validateAbsolutePath(completePathString, yangConstruct, ctx, yangLeafRef);
        yangLeafRef.setAtomicPath(yangAtomicPathListList);
    } else if (completePathString.startsWith(ANCESTOR_ACCESSOR)) {
        yangLeafRef.setPathType(RELATIVE_PATH);
        validateRelativePath(completePathString, yangConstruct, ctx, yangLeafRef);
    } else {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
}
#end_block

#method_before
private static void validateRelativePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath relativePath = new YangRelativePath();
    int numberOfAncestors = 0;
    while (completePathString.startsWith(ANCESTOR_ACCESSOR_IN_PATH)) {
        completePathString = completePathString.replaceFirst(ANCESTOR_ACCESSOR_IN_PATH, EMPTY_STRING);
        numberOfAncestors = numberOfAncestors + 1;
    }
    if (completePathString == null || completePathString.length() == 0) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    relativePath.setAncestor(numberOfAncestors);
    List<YangAbsPath> absolutePathList = validateAbsolutePath(SLASH_FOR_STRING + completePathString, yangConstruct, ctx, yangLeafRef);
    relativePath.setAbsolutePath(absolutePathList);
    yangLeafRef.setRelativePath(relativePath);
}
#method_after
private static void validateRelativePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath relativePath = new YangRelativePath();
    int numberOfAncestors = 0;
    while (completePathString.startsWith(ANCESTOR_ACCESSOR_IN_PATH)) {
        completePathString = completePathString.replaceFirst(ANCESTOR_ACCESSOR_IN_PATH, EMPTY_STRING);
        numberOfAncestors = numberOfAncestors + 1;
    }
    if (completePathString == null || completePathString.length() == 0) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    relativePath.setAncestorNodeCount(numberOfAncestors);
    List<YangAtomicPath> atomicPath = validateAbsolutePath(SLASH_FOR_STRING + completePathString, yangConstruct, ctx, yangLeafRef);
    relativePath.setAtomicPathList(atomicPath);
    yangLeafRef.setRelativePath(relativePath);
}
#end_block

#method_before
private static List<YangAbsPath> validateAbsolutePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAbsPath> absolutePathList = new LinkedList<>();
    YangPathPredicate yangPathPredicate = new YangPathPredicate();
    YangNodeIdentifier yangNodeIdentifier;
    while (completePathString != null) {
        String path = completePathString.replaceFirst(SLASH_FOR_STRING, EMPTY_STRING);
        if (path == null || path.length() == 0) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
            parserException.setLine(ctx.getStart().getLine());
            parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw parserException;
        }
        String matchedPathPredicate;
        String nodeIdentifier;
        String[] differentiate = new String[2];
        int forNodeIdentifier = path.indexOf(CHAR_OF_SLASH);
        int forPathPredicate = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
        // Checks if path predicate is present for the node.
        if ((forPathPredicate < forNodeIdentifier) && (forPathPredicate != -1)) {
            List<String> pathPredicate = new ArrayList<>();
            matchedPathPredicate = matchForPathPredicate(path);
            if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            int indexOfMatchedFirstOpenBrace = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
            differentiate[0] = path.substring(0, indexOfMatchedFirstOpenBrace);
            differentiate[1] = path.substring(indexOfMatchedFirstOpenBrace);
            pathPredicate.add(matchedPathPredicate);
            nodeIdentifier = differentiate[0];
            // Starts adding all path predicates of a node into the list.
            if (!differentiate[1].isEmpty()) {
                while (differentiate[1].startsWith(OPEN_SQUARE_BRACKET)) {
                    matchedPathPredicate = matchForPathPredicate(differentiate[1]);
                    if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                        parserException.setLine(ctx.getStart().getLine());
                        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                        throw parserException;
                    }
                    pathPredicate.add(matchedPathPredicate);
                    differentiate[1] = differentiate[1].substring(matchedPathPredicate.length());
                }
            }
            List<YangPathPredicate> pathPredicateList = validatePathPredicate(pathPredicate, yangConstruct, ctx, yangPathPredicate, yangLeafRef);
            YangAbsPath absolutePaths = new YangAbsPath();
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            absolutePaths.setNodeIdentifier(yangNodeIdentifier);
            absolutePaths.setPredicatesExp(pathPredicateList);
            absolutePathList.add(absolutePaths);
        } else {
            if (path.contains(SLASH_FOR_STRING)) {
                nodeIdentifier = path.substring(0, path.indexOf(CHAR_OF_SLASH));
                differentiate[1] = path.substring(path.indexOf(CHAR_OF_SLASH));
            } else {
                nodeIdentifier = path;
                differentiate[1] = null;
            }
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            YangAbsPath absolutePaths = new YangAbsPath();
            absolutePaths.setNodeIdentifier(yangNodeIdentifier);
            absolutePaths.setPredicatesExp(null);
            absolutePathList.add(absolutePaths);
        }
        if (differentiate[1] == null || differentiate[1].length() == 0) {
            completePathString = null;
        } else {
            completePathString = differentiate[1];
        }
    }
    return absolutePathList;
}
#method_after
private static List<YangAtomicPath> validateAbsolutePath(String completePathString, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAtomicPath> absolutePathList = new LinkedList<>();
    YangPathPredicate yangPathPredicate = new YangPathPredicate();
    YangNodeIdentifier yangNodeIdentifier;
    while (completePathString != null) {
        String path = completePathString.replaceFirst(SLASH_FOR_STRING, EMPTY_STRING);
        if (path == null || path.length() == 0) {
            ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
            parserException.setLine(ctx.getStart().getLine());
            parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
            throw parserException;
        }
        String matchedPathPredicate;
        String nodeIdentifier;
        String[] differentiate = new String[2];
        int forNodeIdentifier = path.indexOf(CHAR_OF_SLASH);
        int forPathPredicate = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
        // Checks if path predicate is present for the node.
        if ((forPathPredicate < forNodeIdentifier) && (forPathPredicate != -1)) {
            List<String> pathPredicate = new ArrayList<>();
            matchedPathPredicate = matchForPathPredicate(path);
            if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                parserException.setLine(ctx.getStart().getLine());
                parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                throw parserException;
            }
            int indexOfMatchedFirstOpenBrace = path.indexOf(CHAR_OF_OPEN_SQUARE_BRACKET);
            differentiate[0] = path.substring(0, indexOfMatchedFirstOpenBrace);
            differentiate[1] = path.substring(indexOfMatchedFirstOpenBrace);
            pathPredicate.add(matchedPathPredicate);
            nodeIdentifier = differentiate[0];
            // Starts adding all path predicates of a node into the list.
            if (!differentiate[1].isEmpty()) {
                while (differentiate[1].startsWith(OPEN_SQUARE_BRACKET)) {
                    matchedPathPredicate = matchForPathPredicate(differentiate[1]);
                    if (matchedPathPredicate == null || matchedPathPredicate.length() == 0) {
                        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
                        parserException.setLine(ctx.getStart().getLine());
                        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
                        throw parserException;
                    }
                    pathPredicate.add(matchedPathPredicate);
                    differentiate[1] = differentiate[1].substring(matchedPathPredicate.length());
                }
            }
            List<YangPathPredicate> pathPredicateList = validatePathPredicate(pathPredicate, yangConstruct, ctx, yangPathPredicate, yangLeafRef);
            YangAtomicPath atomicPath = new YangAtomicPath();
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            atomicPath.setNodeIdentifier(yangNodeIdentifier);
            atomicPath.setPathPredicatesList(pathPredicateList);
            absolutePathList.add(atomicPath);
        } else {
            if (path.contains(SLASH_FOR_STRING)) {
                nodeIdentifier = path.substring(0, path.indexOf(CHAR_OF_SLASH));
                differentiate[1] = path.substring(path.indexOf(CHAR_OF_SLASH));
            } else {
                nodeIdentifier = path;
                differentiate[1] = null;
            }
            yangNodeIdentifier = getValidNodeIdentifierForLeafref(nodeIdentifier, yangConstruct, ctx, yangLeafRef);
            YangAtomicPath atomicPath = new YangAtomicPath();
            atomicPath.setNodeIdentifier(yangNodeIdentifier);
            atomicPath.setPathPredicatesList(null);
            absolutePathList.add(atomicPath);
        }
        if (differentiate[1] == null || differentiate[1].length() == 0) {
            completePathString = null;
        } else {
            completePathString = differentiate[1];
        }
    }
    return absolutePathList;
}
#end_block

#method_before
private static List<YangPathPredicate> validatePathPredicate(List<String> pathPredicate, YangConstructType yangConstruct, ParserRuleContext ctx, YangPathPredicate yangPathPredicate, YangLeafRef yangLeafRef) {
    Iterator<String> pathPredicateString = pathPredicate.iterator();
    List<String> pathEqualityExpression = new ArrayList<>();
    while (pathPredicateString.hasNext()) {
        String pathPredicateForNode = pathPredicateString.next();
        pathPredicateForNode = (pathPredicateForNode.substring(1)).trim();
        pathPredicateForNode = pathPredicateForNode.substring(0, pathPredicateForNode.indexOf(CHAR_OF_CLOSE_SQUARE_BRACKET));
        pathEqualityExpression.add(pathPredicateForNode);
    }
    List<YangPathPredicate> validatedPathPreficateList = validatePathEqualityExpression(pathEqualityExpression, yangConstruct, ctx, yangPathPredicate, yangLeafRef);
    return validatedPathPreficateList;
}
#method_after
private static List<YangPathPredicate> validatePathPredicate(List<String> pathPredicate, YangConstructType yangConstruct, ParserRuleContext ctx, YangPathPredicate yangPathPredicate, YangLeafRef yangLeafRef) {
    Iterator<String> pathPredicateString = pathPredicate.iterator();
    List<String> pathEqualityExpression = new ArrayList<>();
    while (pathPredicateString.hasNext()) {
        String pathPredicateForNode = pathPredicateString.next();
        pathPredicateForNode = (pathPredicateForNode.substring(1)).trim();
        pathPredicateForNode = pathPredicateForNode.substring(0, pathPredicateForNode.indexOf(CHAR_OF_CLOSE_SQUARE_BRACKET));
        pathEqualityExpression.add(pathPredicateForNode);
    }
    List<YangPathPredicate> validatedPathPredicateList = validatePathEqualityExpression(pathEqualityExpression, yangConstruct, ctx, yangPathPredicate, yangLeafRef);
    return validatedPathPredicateList;
}
#end_block

#method_before
private static YangRelativePath validatePathKeyExpression(String rightRelativePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath yangRelativePath = new YangRelativePath();
    String[] relativePath = rightRelativePath.split(SLASH_FOR_STRING);
    List<String> rightAbsolutePath = new ArrayList<>();
    int accessAncestor = 0;
    for (String path : relativePath) {
        if (path.trim().equals(ANCESTOR_ACCESSOR)) {
            accessAncestor = accessAncestor + 1;
        } else {
            rightAbsolutePath.add(path);
        }
    }
    List<YangAbsPath> absoluteListInRelativePath = validateRelativePathKeyExpression(rightAbsolutePath, yangConstruct, ctx, yangLeafRef);
    yangRelativePath.setAbsolutePath(absoluteListInRelativePath);
    yangRelativePath.setAncestor(accessAncestor);
    return yangRelativePath;
}
#method_after
private static YangRelativePath validatePathKeyExpression(String rightRelativePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    YangRelativePath yangRelativePath = new YangRelativePath();
    String[] relativePath = rightRelativePath.split(SLASH_FOR_STRING);
    List<String> rightAbsolutePath = new ArrayList<>();
    int accessAncestor = 0;
    for (String path : relativePath) {
        if (path.trim().equals(ANCESTOR_ACCESSOR)) {
            accessAncestor = accessAncestor + 1;
        } else {
            rightAbsolutePath.add(path);
        }
    }
    List<YangAtomicPath> atomicPathInRelativePath = validateRelativePathKeyExpression(rightAbsolutePath, yangConstruct, ctx, yangLeafRef);
    yangRelativePath.setAtomicPathList(atomicPathInRelativePath);
    yangRelativePath.setAncestorNodeCount(accessAncestor);
    return yangRelativePath;
}
#end_block

#method_before
private static List<YangAbsPath> validateRelativePathKeyExpression(List<String> rightAbsolutePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAbsPath> absolutePathList = new ArrayList<>();
    YangNodeIdentifier yangNodeIdentifier;
    Iterator<String> nodes = rightAbsolutePath.iterator();
    String currentInvocationFunction = nodes.next();
    currentInvocationFunction = currentInvocationFunction.trim();
    String[] currentFunction = currentInvocationFunction.split("[(]");
    if (!(currentFunction[0].trim().equals("current")) || !(currentFunction[1].trim().equals(")"))) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    while (nodes.hasNext()) {
        YangAbsPath absolutePath = new YangAbsPath();
        String node = nodes.next();
        yangNodeIdentifier = getValidNodeIdentifierForLeafref(node.trim(), yangConstruct, ctx, yangLeafRef);
        absolutePath.setNodeIdentifier(yangNodeIdentifier);
        absolutePathList.add(absolutePath);
    }
    return absolutePathList;
}
#method_after
private static List<YangAtomicPath> validateRelativePathKeyExpression(List<String> rightAbsolutePath, YangConstructType yangConstruct, ParserRuleContext ctx, YangLeafRef yangLeafRef) {
    List<YangAtomicPath> atomicPathList = new ArrayList<>();
    YangNodeIdentifier yangNodeIdentifier;
    Iterator<String> nodes = rightAbsolutePath.iterator();
    String currentInvocationFunction = nodes.next();
    currentInvocationFunction = currentInvocationFunction.trim();
    String[] currentFunction = currentInvocationFunction.split("[(]");
    if (!(currentFunction[0].trim().equals(CURRENT)) || !(currentFunction[1].trim().equals(CLOSE_PARENTHESIS))) {
        ParserException parserException = new ParserException("YANG file error : " + YangConstructType.getYangConstructType(yangConstruct) + " " + yangLeafRef.getPath() + " does not follow valid path syntax");
        parserException.setLine(ctx.getStart().getLine());
        parserException.setCharPosition(ctx.getStart().getCharPositionInLine());
        throw parserException;
    }
    while (nodes.hasNext()) {
        YangAtomicPath atomicPath = new YangAtomicPath();
        String node = nodes.next();
        yangNodeIdentifier = getValidNodeIdentifierForLeafref(node.trim(), yangConstruct, ctx, yangLeafRef);
        atomicPath.setNodeIdentifier(yangNodeIdentifier);
        atomicPathList.add(atomicPath);
    }
    return atomicPathList;
}
#end_block

#method_before
private static void checkForUnsupportedTypes(String typeName, YangConstructType yangConstruct, ParserRuleContext ctx) {
    if (yangConstruct == YangConstructType.TYPE_DATA) {
        if (typeName.equalsIgnoreCase(IDENTITYREF)) {
            handleUnsupportedYangConstruct(YangConstructType.IDENTITYREF_DATA, ctx, CURRENTLY_UNSUPPORTED);
        } else if (typeName.equalsIgnoreCase(INSTANCE_IDENTIFIER)) {
            handleUnsupportedYangConstruct(YangConstructType.INSTANCE_IDENTIFIER_DATA, ctx, CURRENTLY_UNSUPPORTED);
        }
    }
}
#method_after
private static void checkForUnsupportedTypes(String typeName, YangConstructType yangConstruct, ParserRuleContext ctx) {
    if (yangConstruct == YangConstructType.TYPE_DATA) {
        if (typeName.equalsIgnoreCase(IDENTITYREF)) {
            handleUnsupportedYangConstruct(YangConstructType.IDENTITYREF_DATA, ctx, CURRENTLY_UNSUPPORTED);
        }
    }
}
#end_block

#method_before
private void linkAndResolvePartialResolvedStack() throws DataModelException {
    while (getPartialResolvedStack().size() != 0) {
        // Current node to resolve, it can be a YANG type or YANG uses or YANG if-feature or YANG leafref.
        T entityToResolve = getCurrentEntityToResolveFromStack();
        // Check if linking is already done
        if (entityToResolve instanceof Resolvable) {
            Resolvable resolvable = (Resolvable) entityToResolve;
            switch(resolvable.getResolvableStatus()) {
                case RESOLVED:
                    {
                        /*
                         * If the entity is already resolved in the stack, then pop
                         * it and continue with the remaining stack elements to
                         * resolve
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case LINKED:
                    {
                        /*
                         * If the top of the stack is already linked then resolve
                         * the references and pop the entity and continue with
                         * remaining stack elements to resolve.
                         */
                        resolveTopOfStack(INTRA_FILE);
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTRA_FILE_RESOLVED:
                    {
                        /*
                         * Pop the top of the stack.
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case UNRESOLVED:
                    {
                        linkTopOfStackReferenceUpdateStack();
                        if (resolvable.getResolvableStatus() == UNRESOLVED) {
                            // If current entity is still not resolved, then
                            // linking/resolution has failed.
                            String errorInfo;
                            if (resolvable instanceof YangType) {
                                errorInfo = TYPEDEF_LINKER_ERROR;
                            } else if (resolvable instanceof YangUses) {
                                errorInfo = GROUPING_LINKER_ERROR;
                            } else if (resolvable instanceof YangIfFeature) {
                                errorInfo = FEATURE_LINKER_ERROR;
                            } else {
                                errorInfo = LEAFREF_LINKER_ERROR;
                            }
                            DataModelException dataModelException = new DataModelException(errorInfo);
                            dataModelException.setLine(getLineNumber());
                            dataModelException.setCharPosition(getCharPosition());
                            throw dataModelException;
                        }
                        break;
                    }
                default:
                    {
                        throw new DataModelException("Data Model Exception: Unsupported, linker state");
                    }
            }
        } else {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses/if-feature/leafref");
        }
    }
}
#method_after
private void linkAndResolvePartialResolvedStack() throws DataModelException {
    while (getPartialResolvedStack().size() != 0) {
        // Current node to resolve, it can be a YANG type or YANG uses.
        T entityToResolve = getCurrentEntityToResolveFromStack();
        // Check if linking is already done
        if (entityToResolve instanceof Resolvable) {
            Resolvable resolvable = (Resolvable) entityToResolve;
            switch(resolvable.getResolvableStatus()) {
                case RESOLVED:
                    {
                        /*
                         * If the entity is already resolved in the stack, then pop
                         * it and continue with the remaining stack elements to
                         * resolve
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case LINKED:
                    {
                        /*
                         * If the top of the stack is already linked then resolve
                         * the references and pop the entity and continue with
                         * remaining stack elements to resolve.
                         */
                        resolveTopOfStack(INTRA_FILE);
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTRA_FILE_RESOLVED:
                    {
                        /*
                         * Pop the top of the stack.
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case UNRESOLVED:
                    {
                        linkTopOfStackReferenceUpdateStack();
                        if (resolvable.getResolvableStatus() == UNRESOLVED) {
                            // If current entity is still not resolved, then
                            // linking/resolution has failed.
                            String errorInfo;
                            if (resolvable instanceof YangType) {
                                errorInfo = TYPEDEF_LINKER_ERROR;
                            } else if (resolvable instanceof YangUses) {
                                errorInfo = GROUPING_LINKER_ERROR;
                            } else if (resolvable instanceof YangIfFeature) {
                                errorInfo = FEATURE_LINKER_ERROR;
                            } else {
                                errorInfo = LEAFREF_LINKER_ERROR;
                            }
                            DataModelException dataModelException = new DataModelException(errorInfo);
                            dataModelException.setLine(getLineNumber());
                            dataModelException.setCharPosition(getCharPosition());
                            throw dataModelException;
                        }
                        break;
                    }
                default:
                    {
                        throw new DataModelException("Data Model Exception: Unsupported, linker state");
                    }
            }
        } else {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses/if-feature/leafref");
        }
    }
}
#end_block

#method_before
private void addDerivedRefTypeToRefTypeResolutionList() throws DataModelException {
    YangNode potentialAncestorWithReferredNode = getEntityToResolveInfo().getHolderOfEntityToResolve();
    // If holder is typedef return.
    if (potentialAncestorWithReferredNode instanceof YangTypeDef) {
        return;
    }
    // If entity is not type return.
    if (!(getEntityToResolveInfo().getEntityToResolve() instanceof YangType)) {
        return;
    }
    YangType yangType = (YangType) getEntityToResolveInfo().getEntityToResolve();
    // If type is not resolved return.
    if (yangType.getResolvableStatus() != RESOLVED) {
        return;
    }
    YangDerivedInfo derivedInfo = (YangDerivedInfo) yangType.getDataTypeExtendedInfo();
    /*
         * If the derived types referred type is not leaf ref return
         */
    if (derivedInfo.getEffectiveBuiltInType() != YangDataTypes.LEAFREF) {
        return;
    }
    T extendedInfo = (T) derivedInfo.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    while (extendedInfo instanceof YangDerivedInfo) {
        YangDerivedInfo derivedInfoFromTypedef = (YangDerivedInfo) extendedInfo;
        extendedInfo = (T) derivedInfoFromTypedef.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    }
    /*
         * Backup the derived types leaf ref info, delete all the info in current type,
         * but for resolution status as resolved.
         * Copy the backed up leaf ref to types extended info,
         * create a leaf ref resolution info using the current resolution info and add to leaf ref resolution list.
         */
    YangLeafRef leafRefInTypeDef = (YangLeafRef) extendedInfo;
    yangType.resetYangType();
    yangType.setResolvableStatus(RESOLVED);
    yangType.setDataType(YangDataTypes.LEAFREF);
    yangType.setDataTypeName("leafref");
    yangType.setDataTypeExtendedInfo(leafRefInTypeDef);
    leafRefInTypeDef.setResolvableStatus(UNRESOLVED);
    // Add resolution information to the list.
    YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<>(leafRefInTypeDef, potentialAncestorWithReferredNode, getLineNumber(), getCharPosition());
    getCurReferenceResolver().addToResolutionList(resolutionInfoImpl, ResolvableType.YANG_LEAFREF);
    getCurReferenceResolver().resolveSelfFileLinking(ResolvableType.YANG_LEAFREF);
}
#method_after
private void addDerivedRefTypeToRefTypeResolutionList() throws DataModelException {
    YangNode potentialAncestorWithReferredNode = getEntityToResolveInfo().getHolderOfEntityToResolve();
    // If holder is typedef return.
    if (potentialAncestorWithReferredNode instanceof YangTypeDef) {
        return;
    }
    // If entity is not type return.
    if (!(getEntityToResolveInfo().getEntityToResolve() instanceof YangType)) {
        return;
    }
    YangType yangType = (YangType) getEntityToResolveInfo().getEntityToResolve();
    // If type is not resolved return.
    if (yangType.getResolvableStatus() != RESOLVED) {
        return;
    }
    YangDerivedInfo derivedInfo = (YangDerivedInfo) yangType.getDataTypeExtendedInfo();
    /*
         * If the derived types referred type is not leaf ref return
         */
    if (derivedInfo.getEffectiveBuiltInType() != YangDataTypes.LEAFREF) {
        return;
    }
    T extendedInfo = (T) derivedInfo.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    while (extendedInfo instanceof YangDerivedInfo) {
        YangDerivedInfo derivedInfoFromTypedef = (YangDerivedInfo) extendedInfo;
        extendedInfo = (T) derivedInfoFromTypedef.getReferredTypeDef().getTypeDefBaseType().getDataTypeExtendedInfo();
    }
    /*
         * Backup the derived types leaf ref info, delete all the info in
         * current type, but for resolution status as resolved. Copy the backed
         * up leaf ref to types extended info, create a leaf ref resolution info
         * using the current resolution info and add to leaf ref resolution
         * list.
         */
    YangLeafRef leafRefInTypeDef = (YangLeafRef) extendedInfo;
    yangType.resetYangType();
    yangType.setResolvableStatus(RESOLVED);
    yangType.setDataType(YangDataTypes.LEAFREF);
    yangType.setDataTypeName(LEAFREF);
    yangType.setDataTypeExtendedInfo(leafRefInTypeDef);
    leafRefInTypeDef.setResolvableStatus(UNRESOLVED);
    // Add resolution information to the list.
    YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<>(leafRefInTypeDef, potentialAncestorWithReferredNode, getLineNumber(), getCharPosition());
    getCurReferenceResolver().addToResolutionList(resolutionInfoImpl, ResolvableType.YANG_LEAFREF);
    getCurReferenceResolver().resolveSelfFileLinking(ResolvableType.YANG_LEAFREF);
}
#end_block

#method_before
private void resolveSelfFileLinkingForLeafref(YangNode potentialAncestorWithReferredNode) throws DataModelException {
    YangNode ancestorWithTheReferredNode = potentialAncestorWithReferredNode;
    YangLeafRef leafref = (YangLeafRef) getCurrentEntityToResolveFromStack();
    boolean referredLeafFound = false;
    /*
         * Takes absolute path and takes the root node as module/sub-module, then
         * sends the list of nodes for finding the target leaf.
         */
    if (leafref.getPathType() == YangPathArgType.ABSOLUTEPATH) {
        List<YangAbsPath> absolutePathList = leafref.getAbsolutePath();
        if (absolutePathList != null && !absolutePathList.isEmpty()) {
            Iterator<YangAbsPath> listOfYangAbsolutePath = absolutePathList.listIterator();
            if (getCurReferenceResolver() instanceof YangModule) {
                YangModule rootNode = (YangModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAbsolutePath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            } else if (getCurReferenceResolver() instanceof YangSubModule) {
                YangSubModule rootNode = (YangSubModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAbsolutePath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            }
        }
    /*
         * Takes relative path, goes to the parent node by using the ancestor count
         * and sends the list of nodes for finding the target leaf.
         */
    } else if (leafref.getPathType() == YangPathArgType.RELATIVEPATH) {
        YangRelativePath yangRelativePath = leafref.getRelativePath();
        int parentNodes = yangRelativePath.getAncestor();
        List<YangAbsPath> absolutePathList = yangRelativePath.getAbsolutePath();
        if (absolutePathList != null && !absolutePathList.isEmpty()) {
            Iterator<YangAbsPath> listOfYangAbsolutePath = absolutePathList.listIterator();
            // Gets the root node from ancestor count.
            YangNode rootparentNode = getRootNodeWithAncestorCount(parentNodes, ancestorWithTheReferredNode);
            // Sends list of nodes for finding the target leaf.
            referredLeafFound = isLeafReferenceFound(listOfYangAbsolutePath, rootparentNode, referredLeafFound, potentialAncestorWithReferredNode);
        }
    }
    if (referredLeafFound) {
        return;
    }
    /*
         * In case prefix is not present it's a candidate for inter-file
         * resolution via include list.
         */
    if (getRefPrefix() == null) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTRA_FILE_RESOLVED);
    }
}
#method_after
private void resolveSelfFileLinkingForLeafref(YangNode potentialAncestorWithReferredNode) throws DataModelException {
    YangNode ancestorWithTheReferredNode = potentialAncestorWithReferredNode;
    YangLeafRef leafref = (YangLeafRef) getCurrentEntityToResolveFromStack();
    boolean referredLeafFound = false;
    /*
         * Takes absolute path and takes the root node as module/sub-module,
         * then sends the list of nodes for finding the target leaf.
         */
    if (leafref.getPathType() == YangPathArgType.ABSOLUTE_PATH) {
        List<YangAtomicPath> atomicPathList = leafref.getAtomicPath();
        if (atomicPathList != null && !atomicPathList.isEmpty()) {
            Iterator<YangAtomicPath> listOfYangAtomicPath = atomicPathList.listIterator();
            if (getCurReferenceResolver() instanceof YangModule) {
                YangModule rootNode = (YangModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAtomicPath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            } else if (getCurReferenceResolver() instanceof YangSubModule) {
                YangSubModule rootNode = (YangSubModule) getCurReferenceResolver();
                // Sends list of nodes for finding the target leaf.
                referredLeafFound = isLeafReferenceFound(listOfYangAtomicPath, rootNode, referredLeafFound, potentialAncestorWithReferredNode);
            }
        }
    /*
             * Takes relative path, goes to the parent node by using the
             * ancestor count and sends the list of nodes for finding the target
             * leaf.
             */
    } else if (leafref.getPathType() == YangPathArgType.RELATIVE_PATH) {
        YangRelativePath yangRelativePath = leafref.getRelativePath();
        int parentNodes = yangRelativePath.getAncestorNodeCount();
        List<YangAtomicPath> atomicPathList = yangRelativePath.getAtomicPathList();
        if (atomicPathList != null && !atomicPathList.isEmpty()) {
            Iterator<YangAtomicPath> listOfAtomicPath = atomicPathList.listIterator();
            // Gets the root node from ancestor count.
            YangNode rootparentNode = getRootNodeWithAncestorCount(parentNodes, ancestorWithTheReferredNode);
            // Sends list of nodes for finding the target leaf.
            referredLeafFound = isLeafReferenceFound(listOfAtomicPath, rootparentNode, referredLeafFound, potentialAncestorWithReferredNode);
        }
    }
    if (referredLeafFound) {
        return;
    }
    /*
         * In case prefix is not present it's a candidate for inter-file
         * resolution via include list.
         */
    if (getRefPrefix() == null) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTRA_FILE_RESOLVED);
    }
}
#end_block

#method_before
private YangNode getRootNodeWithAncestorCount(int ancestorCount, YangNode currentParent) throws DataModelException {
    int currentParentCount = 1;
    while (currentParentCount < ancestorCount) {
        if (currentParent.getParent() == null) {
            throw new DataModelException("Yang file error: The target node of leafref is invalid.");
        }
        currentParent = currentParent.getParent();
        currentParentCount = currentParentCount + 1;
    }
    return currentParent;
}
#method_after
private YangNode getRootNodeWithAncestorCount(int ancestorCount, YangNode currentParent) throws DataModelException {
    int currentParentCount = 1;
    while (currentParentCount < ancestorCount) {
        if (currentParent.getParent() == null) {
            throw new DataModelException("YANG file error: The target node of leafref is invalid.");
        }
        currentParent = currentParent.getParent();
        currentParentCount = currentParentCount + 1;
    }
    return currentParent;
}
#end_block

#method_before
private boolean isLeafReferenceFound(Iterator<YangAbsPath> listOfYangAbsolutePath, YangNode ancestorWithTheReferredNode, boolean referredLeafFound, YangNode potentialAncestorWithReferredNode) throws DataModelException {
    while (listOfYangAbsolutePath.hasNext()) {
        YangAbsPath absolutePath = listOfYangAbsolutePath.next();
        String nodeName = absolutePath.getNodeIdentifier().getName();
        // When child is not present, only leaf/leaf-list is available in the node.
        if (ancestorWithTheReferredNode.getChild() == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode, nodeName, (T) LINKED);
            break;
        }
        ancestorWithTheReferredNode = ancestorWithTheReferredNode.getChild();
        // Checks all the siblings under the node and returns the matched node.
        YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(ancestorWithTheReferredNode, nodeName);
        // When node is not found in all the siblings, leaf-list may be the node we have to find.
        if (nodeFound == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode.getParent(), nodeName, (T) LINKED);
        } else {
            ancestorWithTheReferredNode = nodeFound;
            // For the node check if path predicate is present and fill its values.
            List<YangPathPredicate> pathPredicateList = absolutePath.getPredicatesExp();
            if (pathPredicateList != null && !pathPredicateList.isEmpty()) {
                Iterator<YangPathPredicate> listOfYangPathPredicate = pathPredicateList.listIterator();
                fillPathPredicatesForTheNode(ancestorWithTheReferredNode, listOfYangPathPredicate, potentialAncestorWithReferredNode);
            }
        }
        // If leaf is also not found and node is also not found return the status as false.
        if (!referredLeafFound && nodeFound == null) {
            break;
        }
    }
    return referredLeafFound;
}
#method_after
private boolean isLeafReferenceFound(Iterator<YangAtomicPath> listOfYangAtomicPath, YangNode ancestorWithTheReferredNode, boolean referredLeafFound, YangNode potentialAncestorWithReferredNode) throws DataModelException {
    while (listOfYangAtomicPath.hasNext()) {
        YangAtomicPath atomicPath = listOfYangAtomicPath.next();
        String nodeName = atomicPath.getNodeIdentifier().getName();
        // When child is not present, only leaf/leaf-list is available in the node.
        if (ancestorWithTheReferredNode.getChild() == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode, nodeName, (T) LINKED);
            break;
        }
        ancestorWithTheReferredNode = ancestorWithTheReferredNode.getChild();
        // Checks all the siblings under the node and returns the matched node.
        YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(ancestorWithTheReferredNode, nodeName);
        // When node is not found in all the siblings, leaf-list may be the node we have to find.
        if (nodeFound == null) {
            referredLeafFound = isReferredLeafOrLeafListFound(ancestorWithTheReferredNode.getParent(), nodeName, (T) LINKED);
        } else {
            ancestorWithTheReferredNode = nodeFound;
            // For the node check if path predicate is present and fill its values.
            List<YangPathPredicate> pathPredicateList = atomicPath.getPathPredicatesList();
            if (pathPredicateList != null && !pathPredicateList.isEmpty()) {
                Iterator<YangPathPredicate> listOfYangPathPredicate = pathPredicateList.listIterator();
                fillPathPredicatesForTheNode(ancestorWithTheReferredNode, listOfYangPathPredicate, potentialAncestorWithReferredNode);
            }
        }
        // If leaf is also not found and node is also not found return the status as false.
        if (!referredLeafFound && nodeFound == null) {
            break;
        }
    }
    return referredLeafFound;
}
#end_block

#method_before
private void fillPathPredicatesForTheNode(YangNode ancestorWithTheReferredNode, Iterator<YangPathPredicate> listOfYangPathPredicate, YangNode potentialAncestorWithReferredNode) throws DataModelException {
    while (listOfYangPathPredicate.hasNext()) {
        if (!(ancestorWithTheReferredNode instanceof YangList)) {
            throw new DataModelException("Yang file error: The path predicates are applicable only for list");
        }
        YangPathPredicate pathPredicate = listOfYangPathPredicate.next();
        YangNodeIdentifier leftNode = pathPredicate.getNodeIdentifier();
        YangRelativePath relativePath = pathPredicate.getRightRelativePath();
        // Checks that the left axis is filled in the path predicate.
        boolean isLeftLeafOrLeafListSetForLeftAxis = getLeftLeafOrLeafListInPredicate((YangList) ancestorWithTheReferredNode, pathPredicate, leftNode);
        if (!isLeftLeafOrLeafListSetForLeftAxis) {
            throw new DataModelException("Yang file error: The path predicate is not referring to an existing leaf/leaflist");
        }
        int parentNodes = relativePath.getAncestor();
        // Finds the root node for the right relative path.
        YangNode rootParentNode = getRootNodeWithAncestorCount(parentNodes, potentialAncestorWithReferredNode);
        // Finds the leaf/leaf-list from the right side relative path.
        resolveRightAxisNodeInPathPredicate(relativePath, rootParentNode, pathPredicate);
    }
}
#method_after
private void fillPathPredicatesForTheNode(YangNode ancestorWithTheReferredNode, Iterator<YangPathPredicate> listOfYangPathPredicate, YangNode potentialAncestorWithReferredNode) throws DataModelException {
    while (listOfYangPathPredicate.hasNext()) {
        if (!(ancestorWithTheReferredNode instanceof YangList)) {
            throw new DataModelException("YANG file error: The path predicates are applicable only for list");
        }
        YangPathPredicate pathPredicate = listOfYangPathPredicate.next();
        YangNodeIdentifier leftNode = pathPredicate.getNodeIdentifier();
        YangRelativePath relativePath = pathPredicate.getRightRelativePath();
        // Checks that the left axis is filled in the path predicate.
        boolean isLeftLeafOrLeafListSetForLeftAxis = getLeftLeafOrLeafListInPredicate((YangList) ancestorWithTheReferredNode, pathPredicate, leftNode);
        if (!isLeftLeafOrLeafListSetForLeftAxis) {
            throw new DataModelException("YANG file error: The path predicate is not referring to an existing leaf/leaflist");
        }
        int parentNodes = relativePath.getAncestorNodeCount();
        // Finds the root node for the right relative path.
        YangNode rootParentNode = getRootNodeWithAncestorCount(parentNodes, potentialAncestorWithReferredNode);
        // Finds the leaf/leaf-list from the right side relative path.
        resolveRightAxisNodeInPathPredicate(relativePath, rootParentNode, pathPredicate);
    }
}
#end_block

#method_before
private void resolveRightAxisNodeInPathPredicate(YangRelativePath relativePath, YangNode rootParentNode, YangPathPredicate pathPredicate) throws DataModelException {
    List<YangAbsPath> absolutePathList = relativePath.getAbsolutePath();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAbsPath> listOfYangAbsolutePathForRightRelative = absolutePathList.listIterator();
        while (listOfYangAbsolutePathForRightRelative.hasNext()) {
            boolean isRightAxisNodeFound = false;
            YangAbsPath absolutePathInPredicate = listOfYangAbsolutePathForRightRelative.next();
            String nodeNameInAbsolutePath = absolutePathInPredicate.getNodeIdentifier().getName();
            // When child is not there check the leaf/leaf-list.
            if (rootParentNode.getChild() == null) {
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode, nodeNameInAbsolutePath, (T) pathPredicate);
                if (!isRightAxisNodeFound) {
                    throw new DataModelException("Yang file error: The path predicates is not referring to an existing leaf/leaflist");
                }
                break;
            }
            rootParentNode = rootParentNode.getChild();
            YangNode nodeFoundInTheRelativePath = isReferredNodeInSiblingProcessedForLeafref(rootParentNode, nodeNameInAbsolutePath);
            if (nodeFoundInTheRelativePath == null) {
                // When node is not found check the leaf/leaf-list.
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode.getParent(), nodeNameInAbsolutePath, (T) pathPredicate);
            } else {
                rootParentNode = nodeFoundInTheRelativePath;
            }
            if (!isRightAxisNodeFound && nodeFoundInTheRelativePath == null) {
                throw new DataModelException("Yang file error: The path predicates is not referring to an existing leaf/leaflist");
            }
        }
    }
}
#method_after
private void resolveRightAxisNodeInPathPredicate(YangRelativePath relativePath, YangNode rootParentNode, YangPathPredicate pathPredicate) throws DataModelException {
    List<YangAtomicPath> absolutePathList = relativePath.getAtomicPathList();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAtomicPath> listOfYangAtomicPathForRightRelative = absolutePathList.listIterator();
        while (listOfYangAtomicPathForRightRelative.hasNext()) {
            boolean isRightAxisNodeFound = false;
            YangAtomicPath absolutePathInPredicate = listOfYangAtomicPathForRightRelative.next();
            String nodeNameInAtomicPath = absolutePathInPredicate.getNodeIdentifier().getName();
            // When child is not there check the leaf/leaf-list.
            if (rootParentNode.getChild() == null) {
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode, nodeNameInAtomicPath, (T) pathPredicate);
                if (!isRightAxisNodeFound) {
                    throw new DataModelException("YANG file error: The path predicates is not referring to an existing leaf/leaflist");
                }
                break;
            }
            rootParentNode = rootParentNode.getChild();
            YangNode nodeFoundInTheRelativePath = isReferredNodeInSiblingProcessedForLeafref(rootParentNode, nodeNameInAtomicPath);
            if (nodeFoundInTheRelativePath == null) {
                // When node is not found check the leaf/leaf-list.
                isRightAxisNodeFound = isReferredLeafOrLeafListFound(rootParentNode.getParent(), nodeNameInAtomicPath, (T) pathPredicate);
            } else {
                rootParentNode = nodeFoundInTheRelativePath;
            }
            if (!isRightAxisNodeFound && nodeFoundInTheRelativePath == null) {
                throw new DataModelException("YANG file error: The path predicates is not referring to an existing leaf/leaflist");
            }
        }
    }
}
#end_block

#method_before
private boolean isReferredLeafOrLeafListFound(YangNode ancestorWithTheReferredNode, String nodeName, T statusOrPathPredicate) throws DataModelException {
    if (!(ancestorWithTheReferredNode instanceof YangLeavesHolder)) {
        throw new DataModelException("Yang file error: The target node of leafref is invalid.");
    }
    YangLeavesHolder leavesHolder = (YangLeavesHolder) ancestorWithTheReferredNode;
    if (leavesHolder.getListOfLeaf() != null) {
        Iterator<YangLeaf> yangLeavesList = leavesHolder.getListOfLeaf().listIterator();
        while (yangLeavesList.hasNext()) {
            YangLeaf yangleaf = yangLeavesList.next();
            if (yangleaf.getName().contentEquals(nodeName)) {
                if (statusOrPathPredicate instanceof ResolvableStatus) {
                    ResolvableStatus status = (ResolvableStatus) statusOrPathPredicate;
                    // Sets the referred leaf to YANG leafref.
                    ((YangLeafRef) getCurrentEntityToResolveFromStack()).setReferredLeafOrLeafList(yangleaf);
                    // Adds reference link of entity to the node under resolution.
                    addReferredEntityLink(ancestorWithTheReferredNode, status);
                    addUnResolvedLeafRefTypeToStack((T) yangleaf, ancestorWithTheReferredNode);
                    return true;
                } else if (statusOrPathPredicate instanceof YangPathPredicate) {
                    YangPathPredicate pathPredicate = (YangPathPredicate) statusOrPathPredicate;
                    // Sets the right axis node.
                    pathPredicate.setRightAxisNode(yangleaf);
                    return true;
                } else {
                    throw new DataModelException("Yang file error: The target node of leafref is invalid.");
                }
            }
        }
    }
    if (leavesHolder.getListOfLeafList() != null) {
        Iterator<YangLeafList> yangLeafListList = leavesHolder.getListOfLeafList().listIterator();
        while (yangLeafListList.hasNext()) {
            YangLeafList yangLeaflist = yangLeafListList.next();
            if (yangLeaflist.getName().contentEquals(nodeName)) {
                if (statusOrPathPredicate instanceof ResolvableStatus) {
                    ResolvableStatus status = (ResolvableStatus) statusOrPathPredicate;
                    // Sets the referred leaf-list to YANG leafref.
                    ((YangLeafRef) getCurrentEntityToResolveFromStack()).setReferredLeafOrLeafList(yangLeaflist);
                    // Adds reference link of entity to the node under resolution.
                    addReferredEntityLink(ancestorWithTheReferredNode, status);
                    addUnResolvedLeafRefTypeToStack((T) yangLeaflist, ancestorWithTheReferredNode);
                    return true;
                } else if (statusOrPathPredicate instanceof YangPathPredicate) {
                    YangPathPredicate pathPredicate = (YangPathPredicate) statusOrPathPredicate;
                    pathPredicate.setRightAxisNode(yangLeaflist);
                    return true;
                } else {
                    throw new DataModelException("Yang file error: The target node of leafref is invalid.");
                }
            }
        }
    }
    return false;
}
#method_after
private boolean isReferredLeafOrLeafListFound(YangNode ancestorWithTheReferredNode, String nodeName, T statusOrPathPredicate) throws DataModelException {
    if (!(ancestorWithTheReferredNode instanceof YangLeavesHolder)) {
        throw new DataModelException("Yang file error: The target node of leafref is invalid.");
    }
    YangLeavesHolder leavesHolder = (YangLeavesHolder) ancestorWithTheReferredNode;
    if (leavesHolder.getListOfLeaf() != null) {
        Iterator<YangLeaf> yangLeavesList = leavesHolder.getListOfLeaf().listIterator();
        while (yangLeavesList.hasNext()) {
            YangLeaf yangleaf = yangLeavesList.next();
            if (yangleaf.getName().contentEquals(nodeName)) {
                if (statusOrPathPredicate instanceof ResolvableStatus) {
                    ResolvableStatus status = (ResolvableStatus) statusOrPathPredicate;
                    // Sets the referred leaf to YANG leafref.
                    ((YangLeafRef) getCurrentEntityToResolveFromStack()).setReferredLeafOrLeafList(yangleaf);
                    // Adds reference link of entity to the node under resolution.
                    addReferredEntityLink(ancestorWithTheReferredNode, status);
                    addUnResolvedLeafRefTypeToStack((T) yangleaf, ancestorWithTheReferredNode);
                    return true;
                } else if (statusOrPathPredicate instanceof YangPathPredicate) {
                    YangPathPredicate pathPredicate = (YangPathPredicate) statusOrPathPredicate;
                    // Sets the right axis node.
                    pathPredicate.setRightAxisNode(yangleaf);
                    return true;
                } else {
                    throw new DataModelException("YANG file error: The target node of leafref is invalid.");
                }
            }
        }
    }
    if (leavesHolder.getListOfLeafList() != null) {
        Iterator<YangLeafList> yangLeafListList = leavesHolder.getListOfLeafList().listIterator();
        while (yangLeafListList.hasNext()) {
            YangLeafList yangLeaflist = yangLeafListList.next();
            if (yangLeaflist.getName().contentEquals(nodeName)) {
                if (statusOrPathPredicate instanceof ResolvableStatus) {
                    ResolvableStatus status = (ResolvableStatus) statusOrPathPredicate;
                    // Sets the referred leaf-list to YANG leafref.
                    ((YangLeafRef) getCurrentEntityToResolveFromStack()).setReferredLeafOrLeafList(yangLeaflist);
                    // Adds reference link of entity to the node under resolution.
                    addReferredEntityLink(ancestorWithTheReferredNode, status);
                    addUnResolvedLeafRefTypeToStack((T) yangLeaflist, ancestorWithTheReferredNode);
                    return true;
                } else if (statusOrPathPredicate instanceof YangPathPredicate) {
                    YangPathPredicate pathPredicate = (YangPathPredicate) statusOrPathPredicate;
                    pathPredicate.setRightAxisNode(yangLeaflist);
                    return true;
                } else {
                    throw new DataModelException("YANG file error: The target node of leafref is invalid.");
                }
            }
        }
    }
    return false;
}
#end_block

#method_before
private YangNode isReferredNodeInSiblingProcessedForLeafref(YangNode potentialReferredNode, String referredNodeName) throws DataModelException {
    while (potentialReferredNode != null) {
        if (potentialReferredNode instanceof YangInput) {
            if (referredNodeName.equalsIgnoreCase("input")) {
                return potentialReferredNode;
            }
        } else if (potentialReferredNode instanceof YangOutput) {
            if (referredNodeName.equalsIgnoreCase("output")) {
                return potentialReferredNode;
            }
        }
        // Check if the potential referred node is the actual referred node
        if (isReferredNodeForLeafref(potentialReferredNode, referredNodeName)) {
            if (potentialReferredNode instanceof YangGrouping || potentialReferredNode instanceof YangTypeDef) {
                if (potentialReferredNode.getParent() instanceof YangRpc) {
                    potentialReferredNode = potentialReferredNode.getNextSibling();
                } else {
                    throw new DataModelException("Yang file error: The target node of leafref is invalid.");
                }
            }
            return potentialReferredNode;
        }
        potentialReferredNode = potentialReferredNode.getNextSibling();
    }
    return null;
}
#method_after
private YangNode isReferredNodeInSiblingProcessedForLeafref(YangNode potentialReferredNode, String referredNodeName) throws DataModelException {
    while (potentialReferredNode != null) {
        if (potentialReferredNode instanceof YangInput) {
            if (referredNodeName.equalsIgnoreCase(INPUT)) {
                return potentialReferredNode;
            }
        } else if (potentialReferredNode instanceof YangOutput) {
            if (referredNodeName.equalsIgnoreCase(OUTPUT)) {
                return potentialReferredNode;
            }
        }
        // Check if the potential referred node is the actual referred node
        if (isReferredNodeForLeafref(potentialReferredNode, referredNodeName)) {
            if (potentialReferredNode instanceof YangGrouping || potentialReferredNode instanceof YangTypeDef) {
                if (potentialReferredNode.getParent() instanceof YangRpc) {
                    potentialReferredNode = potentialReferredNode.getNextSibling();
                } else {
                    throw new DataModelException("YANG file error: The target node of leafref is invalid.");
                }
            }
            return potentialReferredNode;
        }
        potentialReferredNode = potentialReferredNode.getNextSibling();
    }
    return null;
}
#end_block

#method_before
private boolean isReferredNodeForLeafref(YangNode currentReferredNode, String nameOfNodeinPath) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangLeafRef) {
        /*
             * Check if name of node name matches with the current reference node.
             */
        if (currentReferredNode.getName().contentEquals(nameOfNodeinPath)) {
            return true;
        }
        return false;
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than leafref");
    }
}
#method_after
private boolean isReferredNodeForLeafref(YangNode currentReferredNode, String nameOfNodeinPath) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangLeafRef) {
        /*
             * Check if name of node name matches with the current reference
             * node.
             */
        return currentReferredNode.getName().contentEquals(nameOfNodeinPath);
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than leafref");
    }
}
#end_block

#method_before
private String refPrefixForLeafRef() {
    String refPrefix;
    if (((YangLeafRef) getCurrentEntityToResolveFromStack()).getPathType() == YangPathArgType.ABSOLUTEPATH) {
        List<YangAbsPath> theList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAbsolutePath();
        YangAbsPath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    } else {
        YangRelativePath relativePath = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getRelativePath();
        List<YangAbsPath> theList = relativePath.getAbsolutePath();
        YangAbsPath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    }
    return refPrefix;
}
#method_after
private String refPrefixForLeafRef() {
    String refPrefix;
    if (((YangLeafRef) getCurrentEntityToResolveFromStack()).getPathType() == YangPathArgType.ABSOLUTE_PATH) {
        List<YangAtomicPath> theList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAtomicPath();
        YangAtomicPath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    } else {
        YangRelativePath relativePath = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getRelativePath();
        List<YangAtomicPath> theList = relativePath.getAtomicPathList();
        YangAtomicPath absPath = theList.iterator().next();
        refPrefix = absPath.getNodeIdentifier().getPrefix();
    }
    return refPrefix;
}
#end_block

#method_before
private boolean findRefLeaf(YangNode importedNode) throws DataModelException {
    boolean isReferredNodeFound = false;
    List<YangAbsPath> absolutePathList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAbsolutePath();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAbsPath> listOfYangAbsolutePath = absolutePathList.listIterator();
        while (listOfYangAbsolutePath.hasNext()) {
            YangAbsPath absolutePath = listOfYangAbsolutePath.next();
            String nodeName = absolutePath.getNodeIdentifier().getName();
            if (importedNode.getChild() == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode, nodeName, (T) INTER_FILE_LINKED);
                break;
            }
            importedNode = importedNode.getChild();
            YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(importedNode, nodeName);
            if (nodeFound == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode.getParent(), nodeName, (T) INTER_FILE_LINKED);
            } else {
                importedNode = nodeFound;
            }
        }
    }
    // TODO: Path predicates filling for inter file has to be done.
    return isReferredNodeFound;
}
#method_after
private boolean findRefLeaf(YangNode importedNode) throws DataModelException {
    boolean isReferredNodeFound = false;
    List<YangAtomicPath> absolutePathList = ((YangLeafRef) getCurrentEntityToResolveFromStack()).getAtomicPath();
    if (absolutePathList != null && !absolutePathList.isEmpty()) {
        Iterator<YangAtomicPath> listOfYangAtomicPath = absolutePathList.listIterator();
        while (listOfYangAtomicPath.hasNext()) {
            YangAtomicPath absolutePath = listOfYangAtomicPath.next();
            String nodeName = absolutePath.getNodeIdentifier().getName();
            if (importedNode.getChild() == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode, nodeName, (T) INTER_FILE_LINKED);
                break;
            }
            importedNode = importedNode.getChild();
            YangNode nodeFound = isReferredNodeInSiblingProcessedForLeafref(importedNode, nodeName);
            if (nodeFound == null) {
                isReferredNodeFound = isReferredLeafOrLeafListFound(importedNode.getParent(), nodeName, (T) INTER_FILE_LINKED);
            } else {
                importedNode = nodeFound;
            }
        }
    }
    // TODO: Path predicates filling for inter file has to be done.
    return isReferredNodeFound;
}
#end_block

#method_before
private YangNode findRefFeature(YangNode refNode) {
    YangNodeIdentifier ifFeature = ((YangIfFeature) getCurrentEntityToResolveFromStack()).getName();
    if (refNode == null) {
        System.out.println("refNode is null");
    }
    List<YangFeature> featureList = ((YangFeatureHolder) refNode).getFeatureList();
    if (featureList != null && !featureList.isEmpty()) {
        Iterator<YangFeature> iterator = featureList.iterator();
        while (iterator.hasNext()) {
            YangFeature feature = iterator.next();
            if (ifFeature.getName().equals(feature.getName())) {
                ((YangIfFeature) getCurrentEntityToResolveFromStack()).setReferredFeature(feature);
                return refNode;
            }
        }
    }
    return null;
}
#method_after
private YangNode findRefFeature(YangNode refNode) {
    YangNodeIdentifier ifFeature = ((YangIfFeature) getCurrentEntityToResolveFromStack()).getName();
    List<YangFeature> featureList = ((YangFeatureHolder) refNode).getFeatureList();
    if (featureList != null && !featureList.isEmpty()) {
        Iterator<YangFeature> iterator = featureList.iterator();
        while (iterator.hasNext()) {
            YangFeature feature = iterator.next();
            if (ifFeature.getName().equals(feature.getName())) {
                ((YangIfFeature) getCurrentEntityToResolveFromStack()).setReferredFeature(feature);
                return refNode;
            }
        }
    }
    return null;
}
#end_block

#method_before
public YangDataTypes getEffectiveDataType() {
    return effectiveDataType;
}
#method_after
public YangType getEffectiveDataType() {
    return effectiveDataType;
}
#end_block

#method_before
public void setEffectiveDataType(YangDataTypes effectiveDataType) {
    this.effectiveDataType = effectiveDataType;
}
#method_after
public void setEffectiveDataType(YangType effectiveDataType) {
    this.effectiveDataType = effectiveDataType;
}
#end_block

#method_before
private ResolvableStatus getResolution() throws DataModelException {
    if (getReferredLeafOrLeafList() instanceof YangLeaf) {
        YangType baseType = ((YangLeaf) getReferredLeafOrLeafList()).getDataType();
        if (baseType.getDataType() == YangDataTypes.LEAFREF) {
            YangLeafRef referredLeafRefInfo = (YangLeafRef) ((YangLeaf) getReferredLeafOrLeafList()).getDataType().getDataTypeExtendedInfo();
            /*
                 * Check whether the referred typedef is resolved.
                 */
            if (referredLeafRefInfo.getResolvableStatus() != INTRA_FILE_RESOLVED && referredLeafRefInfo.getResolvableStatus() != RESOLVED) {
                throw new DataModelException("Linker Error: Referred typedef is not resolved for type.");
            }
            /*
                 * Check if the referred typedef is intra file resolved, if yes
                 * sets current status also to intra file resolved .
                 */
            if ((referredLeafRefInfo.getResolvableStatus() == INTRA_FILE_RESOLVED)) {
                return INTRA_FILE_RESOLVED;
            }
            setEffectiveDataType(referredLeafRefInfo.getEffectiveDataType());
        } else if (baseType.getDataType() == YangDataTypes.DERIVED) {
            /*
                 * Check whether the referred typedef is resolved.
                 */
            if (baseType.getResolvableStatus() != INTRA_FILE_RESOLVED && baseType.getResolvableStatus() != RESOLVED) {
                throw new DataModelException("Linker Error: Referred typedef is not resolved for type.");
            }
            /*
                 * Check if the referred typedef is intra file resolved, if yes
                 * sets current status also to intra file resolved .
                 */
            if ((baseType.getResolvableStatus() == INTRA_FILE_RESOLVED)) {
                return INTRA_FILE_RESOLVED;
            }
            YangDerivedInfo referredDerivedInfo = (YangDerivedInfo) ((YangLeaf) getReferredLeafOrLeafList()).getDataType().getDataTypeExtendedInfo();
            setEffectiveDataType(referredDerivedInfo.getEffectiveBuiltInType());
        } else {
            setEffectiveDataType(baseType.getDataType());
        }
        return RESOLVED;
    } else if (getReferredLeafOrLeafList() instanceof YangLeafList) {
        YangType baseType = ((YangLeafList) getReferredLeafOrLeafList()).getDataType();
        if (baseType.getDataType() == YangDataTypes.LEAFREF) {
            YangLeafRef referredLeafRefInfo = (YangLeafRef) ((YangLeafList) getReferredLeafOrLeafList()).getDataType().getDataTypeExtendedInfo();
            /*
                 * Check whether the referred typedef is resolved.
                 */
            if (referredLeafRefInfo.getResolvableStatus() != INTRA_FILE_RESOLVED && referredLeafRefInfo.getResolvableStatus() != RESOLVED) {
                throw new DataModelException("Linker Error: Referred typedef is not resolved for type.");
            }
            /*
                 * Check if the referred typedef is intra file resolved, if yes
                 * sets current status also to intra file resolved .
                 */
            if ((referredLeafRefInfo.getResolvableStatus() == INTRA_FILE_RESOLVED)) {
                return INTRA_FILE_RESOLVED;
            }
            setEffectiveDataType(referredLeafRefInfo.getEffectiveDataType());
        } else if (baseType.getDataType() == YangDataTypes.DERIVED) {
            /*
                 * Check whether the referred typedef is resolved.
                 */
            if (baseType.getResolvableStatus() != INTRA_FILE_RESOLVED && baseType.getResolvableStatus() != RESOLVED) {
                throw new DataModelException("Linker Error: Referred typedef is not resolved for type.");
            }
            /*
                 * Check if the referred typedef is intra file resolved, if yes
                 * sets current status also to intra file resolved .
                 */
            if ((baseType.getResolvableStatus() == INTRA_FILE_RESOLVED)) {
                return INTRA_FILE_RESOLVED;
            }
            YangDerivedInfo referredDerivedInfo = (YangDerivedInfo) ((YangLeafList) getReferredLeafOrLeafList()).getDataType().getDataTypeExtendedInfo();
            setEffectiveDataType(referredDerivedInfo.getEffectiveBuiltInType());
        } else {
            setEffectiveDataType(baseType.getDataType());
        }
        return RESOLVED;
    } else {
        throw new DataModelException("Linker Error: The leafref must refer only to leaf/leaf-list.");
    }
}
#method_after
private ResolvableStatus getResolution() throws DataModelException {
    if (getReferredLeafOrLeafList() instanceof YangLeaf) {
        YangLeaf yangLeaf = ((YangLeaf) getReferredLeafOrLeafList());
        YangType baseType = yangLeaf.getDataType();
        if (baseType.getDataType() == YangDataTypes.LEAFREF) {
            YangLeafRef referredLeafRefInfo = (YangLeafRef) (yangLeaf.getDataType().getDataTypeExtendedInfo());
            /*
                 * Check whether the referred typedef is resolved.
                 */
            if (referredLeafRefInfo.getResolvableStatus() != INTRA_FILE_RESOLVED && referredLeafRefInfo.getResolvableStatus() != RESOLVED) {
                throw new DataModelException("Linker Error: Referred typedef is not resolved for type.");
            }
            /*
                 * Check if the referred typedef is intra file resolved, if yes
                 * sets current status also to intra file resolved .
                 */
            if ((referredLeafRefInfo.getResolvableStatus() == INTRA_FILE_RESOLVED)) {
                return INTRA_FILE_RESOLVED;
            }
            // Add the if-feature list from referred leafref to current leafref.
            List<YangIfFeature> referredLeafIfFeatureListFromLeafref = referredLeafRefInfo.getIfFeatureList();
            if (referredLeafIfFeatureListFromLeafref != null && !referredLeafIfFeatureListFromLeafref.isEmpty()) {
                Iterator<YangIfFeature> referredLeafIfFeature = referredLeafIfFeatureListFromLeafref.iterator();
                while (referredLeafIfFeature.hasNext()) {
                    YangIfFeature ifFeature = referredLeafIfFeature.next();
                    addIfFeatureList(ifFeature);
                }
            }
            setEffectiveDataType(referredLeafRefInfo.getEffectiveDataType());
        } else if (baseType.getDataType() == YangDataTypes.DERIVED) {
            /*
                 * Check whether the referred typedef is resolved.
                 */
            if (baseType.getResolvableStatus() != INTRA_FILE_RESOLVED && baseType.getResolvableStatus() != RESOLVED) {
                throw new DataModelException("Linker Error: Referred typedef is not resolved for type.");
            }
            /*
                 * Check if the referred typedef is intra file resolved, if yes
                 * sets current status also to intra file resolved .
                 */
            if ((baseType.getResolvableStatus() == INTRA_FILE_RESOLVED)) {
                return INTRA_FILE_RESOLVED;
            }
            setEffectiveDataType(baseType);
        } else {
            setEffectiveDataType(baseType);
        }
        // Add the if-feature list from referred leaf to current leafref.
        List<YangIfFeature> referredLeafIfFeatureList = yangLeaf.getIfFeatureList();
        if (referredLeafIfFeatureList != null && !referredLeafIfFeatureList.isEmpty()) {
            Iterator<YangIfFeature> referredLeafIfFeature = referredLeafIfFeatureList.iterator();
            while (referredLeafIfFeature.hasNext()) {
                YangIfFeature ifFeature = referredLeafIfFeature.next();
                addIfFeatureList(ifFeature);
            }
        }
        return RESOLVED;
    } else if (getReferredLeafOrLeafList() instanceof YangLeafList) {
        YangLeafList yangLeafList = ((YangLeafList) getReferredLeafOrLeafList());
        YangType baseType = yangLeafList.getDataType();
        if (baseType.getDataType() == YangDataTypes.LEAFREF) {
            YangLeafRef referredLeafRefInfo = (YangLeafRef) yangLeafList.getDataType().getDataTypeExtendedInfo();
            /*
                 * Check whether the referred typedef is resolved.
                 */
            if (referredLeafRefInfo.getResolvableStatus() != INTRA_FILE_RESOLVED && referredLeafRefInfo.getResolvableStatus() != RESOLVED) {
                throw new DataModelException("Linker Error: Referred typedef is not resolved for type.");
            }
            /*
                 * Check if the referred typedef is intra file resolved, if yes
                 * sets current status also to intra file resolved .
                 */
            if ((referredLeafRefInfo.getResolvableStatus() == INTRA_FILE_RESOLVED)) {
                return INTRA_FILE_RESOLVED;
            }
            // Add the if-feature list from referred leafref to current leafref.
            List<YangIfFeature> referredLeafListIfFeatureListFromLeafref = referredLeafRefInfo.getIfFeatureList();
            if (referredLeafListIfFeatureListFromLeafref != null && !referredLeafListIfFeatureListFromLeafref.isEmpty()) {
                Iterator<YangIfFeature> referredLeafListIfFeature = referredLeafListIfFeatureListFromLeafref.iterator();
                while (referredLeafListIfFeature.hasNext()) {
                    YangIfFeature ifFeature = referredLeafListIfFeature.next();
                    addIfFeatureList(ifFeature);
                }
            }
            setEffectiveDataType(referredLeafRefInfo.getEffectiveDataType());
        } else if (baseType.getDataType() == YangDataTypes.DERIVED) {
            /*
                 * Check whether the referred typedef is resolved.
                 */
            if (baseType.getResolvableStatus() != INTRA_FILE_RESOLVED && baseType.getResolvableStatus() != RESOLVED) {
                throw new DataModelException("Linker Error: Referred typedef is not resolved for type.");
            }
            /*
                 * Check if the referred typedef is intra file resolved, if yes
                 * sets current status also to intra file resolved .
                 */
            if ((baseType.getResolvableStatus() == INTRA_FILE_RESOLVED)) {
                return INTRA_FILE_RESOLVED;
            }
            setEffectiveDataType(baseType);
        } else {
            setEffectiveDataType(baseType);
        }
        // Add the if-feature list from referred leaf-list to current leafref.
        List<YangIfFeature> referredLeafListIfFeatureList = yangLeafList.getIfFeatureList();
        if (referredLeafListIfFeatureList != null && !referredLeafListIfFeatureList.isEmpty()) {
            Iterator<YangIfFeature> referredLeafListIfFeature = referredLeafListIfFeatureList.iterator();
            while (referredLeafListIfFeature.hasNext()) {
                YangIfFeature ifFeature = referredLeafListIfFeature.next();
                addIfFeatureList(ifFeature);
            }
        }
        return RESOLVED;
    } else {
        throw new DataModelException("Linker Error: The leafref must refer only to leaf/leaf-list.");
    }
}
#end_block

#method_before
public void processInterFileLinking(Set<YangNode> yangNodeSet) throws LinkerException {
    for (YangNode yangNode : yangNodeSet) {
        try {
            ((YangReferenceResolver) yangNode).resolveInterFileLinking(ResolvableType.YANG_USES);
            ((YangReferenceResolver) yangNode).resolveInterFileLinking(ResolvableType.YANG_DERIVED_DATA_TYPE);
            ((YangReferenceResolver) yangNode).resolveInterFileLinking(ResolvableType.YANG_IF_FEATURE);
            ((YangReferenceResolver) yangNode).resolveInterFileLinking(ResolvableType.YANG_LEAFREF);
        } catch (DataModelException e) {
            String errorInfo = "Error in file: " + yangNode.getName() + " at line: " + e.getLineNumber() + " at position: " + e.getCharPositionInLine() + NEW_LINE + e.getMessage();
            throw new LinkerException(errorInfo);
        // TODO add file path in exception message in util manager.
        }
    }
}
#method_after
public void processInterFileLinking(Set<YangNode> yangNodeSet) throws LinkerException {
    for (YangNode yangNode : yangNodeSet) {
        try {
            ((YangReferenceResolver) yangNode).resolveInterFileLinking(ResolvableType.YANG_IF_FEATURE);
            ((YangReferenceResolver) yangNode).resolveInterFileLinking(ResolvableType.YANG_USES);
            ((YangReferenceResolver) yangNode).resolveInterFileLinking(ResolvableType.YANG_DERIVED_DATA_TYPE);
            ((YangReferenceResolver) yangNode).resolveInterFileLinking(ResolvableType.YANG_LEAFREF);
        } catch (DataModelException e) {
            String errorInfo = "Error in file: " + yangNode.getName() + " at line: " + e.getLineNumber() + " at position: " + e.getCharPositionInLine() + NEW_LINE + e.getMessage();
            throw new LinkerException(errorInfo);
        // TODO add file path in exception message in util manager.
        }
    }
}
#end_block

#method_before
public static void processModuleExit(TreeWalkListener listener, GeneratedYangParser.ModuleStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, MODULE_DATA, ctx.identifier().getText(), EXIT);
    Parsable tmpNode = listener.getParsedDataStack().peek();
    if (!(tmpNode instanceof YangModule)) {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, MODULE_DATA, ctx.identifier().getText(), EXIT));
    }
    if (((YangModule) tmpNode).getRevision() == null) {
        Date currentDate = getCurrentDateForRevision();
        YangRevision currentRevision = new YangRevision();
        currentRevision.setRevDate(currentDate);
        ((YangModule) tmpNode).setRevision(currentRevision);
    }
    try {
        ((YangReferenceResolver) listener.getParsedDataStack().peek()).resolveSelfFileLinking(ResolvableType.YANG_USES);
        ((YangReferenceResolver) listener.getParsedDataStack().peek()).resolveSelfFileLinking(ResolvableType.YANG_DERIVED_DATA_TYPE);
        ((YangReferenceResolver) listener.getParsedDataStack().peek()).resolveSelfFileLinking(ResolvableType.YANG_IF_FEATURE);
        ((YangReferenceResolver) listener.getParsedDataStack().peek()).resolveSelfFileLinking(ResolvableType.YANG_LEAFREF);
    } catch (DataModelException e) {
        LinkerException linkerException = new LinkerException(e.getMessage());
        linkerException.setLine(e.getLineNumber());
        linkerException.setCharPosition(e.getCharPositionInLine());
        throw linkerException;
    }
}
#method_after
public static void processModuleExit(TreeWalkListener listener, GeneratedYangParser.ModuleStatementContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, MODULE_DATA, ctx.identifier().getText(), EXIT);
    Parsable tmpNode = listener.getParsedDataStack().peek();
    if (!(tmpNode instanceof YangModule)) {
        throw new ParserException(constructListenerErrorMessage(MISSING_CURRENT_HOLDER, MODULE_DATA, ctx.identifier().getText(), EXIT));
    }
    if (((YangModule) tmpNode).getRevision() == null) {
        Date currentDate = getCurrentDateForRevision();
        YangRevision currentRevision = new YangRevision();
        currentRevision.setRevDate(currentDate);
        ((YangModule) tmpNode).setRevision(currentRevision);
    }
    try {
        ((YangReferenceResolver) listener.getParsedDataStack().peek()).resolveSelfFileLinking(ResolvableType.YANG_IF_FEATURE);
        ((YangReferenceResolver) listener.getParsedDataStack().peek()).resolveSelfFileLinking(ResolvableType.YANG_USES);
        ((YangReferenceResolver) listener.getParsedDataStack().peek()).resolveSelfFileLinking(ResolvableType.YANG_DERIVED_DATA_TYPE);
        ((YangReferenceResolver) listener.getParsedDataStack().peek()).resolveSelfFileLinking(ResolvableType.YANG_LEAFREF);
    } catch (DataModelException e) {
        LinkerException linkerException = new LinkerException(e.getMessage());
        linkerException.setLine(e.getLineNumber());
        linkerException.setCharPosition(e.getCharPositionInLine());
        throw linkerException;
    }
}
#end_block

#method_before
@Override
public void enterRequireInstanceStatement(GeneratedYangParser.RequireInstanceStatementContext ctx) {
    handleUnsupportedYangConstruct(YangConstructType.REQUIRE_INSTANCE_DATA, ctx, UNSUPPORTED_YANG_CONSTRUCT);
}
#method_after
@Override
public void enterRequireInstanceStatement(GeneratedYangParser.RequireInstanceStatementContext ctx) {
    RequireInstanceListener.processRequireInstanceEntry(this, ctx);
}
#end_block

#method_before
public static void processLeafrefEntry(TreeWalkListener listener, GeneratedYangParser.LeafrefSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LEAFREF_DATA, "", ENTRY);
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    YangLeafRef<?> leafRef = new YangLeafRef<>();
    Parsable typeData = listener.getParsedDataStack().pop();
    if (!(typeData instanceof YangType)) {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAFREF_DATA, "", ENTRY));
    }
    YangType type = (YangType) typeData;
    type.setDataTypeExtendedInfo(leafRef);
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            // Parent YANG node of leaf to be added in resolution information.
            YangLeaf leaf = (YangLeaf) listener.getParsedDataStack().pop();
            Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
            listener.getParsedDataStack().push(leaf);
            // Verify parent node of leaf.
            if (!(parentNodeOfLeaf instanceof YangNode)) {
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAFREF_DATA, "", ENTRY));
            }
            leafRef.setResolvableStatus(UNRESOLVED);
            // Add resolution information to the list.
            YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangLeafRef>(leafRef, (YangNode) parentNodeOfLeaf, errorLine, errorPosition);
            addToResolutionList(resolutionInfo, ctx);
            break;
        case LEAF_LIST_DATA:
            // Parent YANG node of leaf-list to be added in resolution information.
            YangLeafList leafList = (YangLeafList) listener.getParsedDataStack().pop();
            Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
            listener.getParsedDataStack().push(leafList);
            // Verify parent node of leaf-list.
            if (!(parentNodeOfLeafList instanceof YangNode)) {
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAFREF_DATA, "", ENTRY));
            }
            leafRef.setResolvableStatus(UNRESOLVED);
            // Add resolution information to the list.
            YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<YangLeafRef>(leafRef, (YangNode) parentNodeOfLeafList, errorLine, errorPosition);
            addToResolutionList(resolutionInfoImpl, ctx);
            break;
        case TYPEDEF_DATA:
            /*
                 * Do not add the leaf ref to resolution list.
                 * It needs to be added to resolution list, when leaf/leaf list references to this typedef.
                 * At this time that leaf/leaf-list becomes the parent for the leafref.
                 */
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAFREF_DATA, "", ENTRY));
    }
    listener.getParsedDataStack().push(typeData);
    listener.getParsedDataStack().push(leafRef);
}
#method_after
public static void processLeafrefEntry(TreeWalkListener listener, GeneratedYangParser.LeafrefSpecificationContext ctx) {
    // Check for stack to be non empty.
    checkStackIsNotEmpty(listener, MISSING_HOLDER, LEAFREF_DATA, "", ENTRY);
    int errorLine = ctx.getStart().getLine();
    int errorPosition = ctx.getStart().getCharPositionInLine();
    YangLeafRef<?> leafRef = new YangLeafRef<>();
    Parsable typeData = listener.getParsedDataStack().pop();
    if (!(typeData instanceof YangType)) {
        throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAFREF_DATA, "", ENTRY));
    }
    YangType type = (YangType) typeData;
    type.setDataTypeExtendedInfo(leafRef);
    // Setting by default the value of require-instance as true.
    leafRef.setRequireInstance(true);
    Parsable tmpData = listener.getParsedDataStack().peek();
    switch(tmpData.getYangConstructType()) {
        case LEAF_DATA:
            // Parent YANG node of leaf to be added in resolution information.
            YangLeaf leaf = (YangLeaf) listener.getParsedDataStack().pop();
            Parsable parentNodeOfLeaf = listener.getParsedDataStack().peek();
            listener.getParsedDataStack().push(leaf);
            // Verify parent node of leaf.
            if (!(parentNodeOfLeaf instanceof YangNode)) {
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAFREF_DATA, "", ENTRY));
            }
            leafRef.setResolvableStatus(UNRESOLVED);
            // Add resolution information to the list.
            YangResolutionInfoImpl resolutionInfo = new YangResolutionInfoImpl<YangLeafRef>(leafRef, (YangNode) parentNodeOfLeaf, errorLine, errorPosition);
            addToResolutionList(resolutionInfo);
            break;
        case LEAF_LIST_DATA:
            // Parent YANG node of leaf-list to be added in resolution information.
            YangLeafList leafList = (YangLeafList) listener.getParsedDataStack().pop();
            Parsable parentNodeOfLeafList = listener.getParsedDataStack().peek();
            listener.getParsedDataStack().push(leafList);
            // Verify parent node of leaf-list.
            if (!(parentNodeOfLeafList instanceof YangNode)) {
                throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAFREF_DATA, "", ENTRY));
            }
            leafRef.setResolvableStatus(UNRESOLVED);
            // Add resolution information to the list.
            YangResolutionInfoImpl resolutionInfoImpl = new YangResolutionInfoImpl<YangLeafRef>(leafRef, (YangNode) parentNodeOfLeafList, errorLine, errorPosition);
            addToResolutionList(resolutionInfoImpl);
            break;
        case TYPEDEF_DATA:
            /*
                 * Do not add the leaf ref to resolution list. It needs to be
                 * added to resolution list, when leaf/leaf list references to
                 * this typedef. At this time that leaf/leaf-list becomes the
                 * parent for the leafref.
                 */
            break;
        default:
            throw new ParserException(constructListenerErrorMessage(INVALID_HOLDER, LEAFREF_DATA, "", ENTRY));
    }
    listener.getParsedDataStack().push(typeData);
    listener.getParsedDataStack().push(leafRef);
}
#end_block

#method_before
private static void addToResolutionList(YangResolutionInfoImpl resolutionInfo, GeneratedYangParser.LeafrefSpecificationContext ctx) {
    try {
        addResolutionInfo(resolutionInfo);
    } catch (DataModelException e) {
        throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, LEAFREF_DATA, "", ENTRY, e.getMessage()));
    }
}
#method_after
private static void addToResolutionList(YangResolutionInfoImpl resolutionInfo) {
    try {
        addResolutionInfo(resolutionInfo);
    } catch (DataModelException e) {
        throw new ParserException(constructExtendedListenerErrorMessage(UNHANDLED_PARSED_DATA, LEAFREF_DATA, "", ENTRY, e.getMessage()));
    }
}
#end_block

#method_before
@Test
public void processInstanceIdentifierType() throws IOException, ParserException {
    thrown.expect(ParserException.class);
    thrown.expectMessage("YANG file error : \"instance-identifier\" is not supported in current version," + " please check wiki for YANG utils road map.");
    YangNode node = manager.getDataModel("src/test/resources/InstanceIdentifierInvalidIdentifier.yang");
}
#method_after
@Test
public void processInstanceIdentifierType() throws IOException, ParserException {
    YangNode node = manager.getDataModel("src/test/resources/InstanceIdentifierListener.yang");
    // Check whether the data model tree returned is of type module.
    assertThat((node instanceof YangModule), is(true));
    // Check whether the node type is set properly to module.
    assertThat(node.getNodeType(), is(YangNodeType.MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) node;
    assertThat(yangNode.getName(), is("Test"));
    YangContainer container = (YangContainer) yangNode.getChild();
    ListIterator<YangLeaf> leafIterator = container.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("instance-identifier"));
    assertThat(leafInfo.getDataType().getDataType(), is(YangDataTypes.INSTANCE_IDENTIFIER));
}
#end_block

#method_before
@Test
public void processInterFileLeafrefLinking() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileleafref";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode refNode = null;
    YangNode selfNode = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    Iterator<YangNode> yangNodeIterator = utilManager.getYangNodeSet().iterator();
    YangNode rootNode = yangNodeIterator.next();
    if (rootNode.getName().equals("module1")) {
        selfNode = rootNode;
        refNode = yangNodeIterator.next();
    } else {
        refNode = rootNode;
        selfNode = yangNodeIterator.next();
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("module1"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(LEAFREF));
    // Check whether the data model tree returned is of type module.
    assertThat(refNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(refNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode1 = (YangModule) refNode;
    assertThat(yangNode1.getName(), is("module2"));
    YangLeaf leafInfo1 = yangNode1.getListOfLeaf().listIterator().next();
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafref.getReferredLeafOrLeafList(), is(leafInfo1));
    assertThat(leafref.getResolvableStatus(), is(RESOLVED));
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.STRING));
}
#method_after
@Test
public void processInterFileLeafrefLinking() throws IOException, ParserException, MojoExecutionException {
    String searchDir = "src/test/resources/interfileleafref";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode refNode = null;
    YangNode selfNode = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    Iterator<YangNode> yangNodeIterator = utilManager.getYangNodeSet().iterator();
    YangNode rootNode = yangNodeIterator.next();
    if (rootNode.getName().equals("module1")) {
        selfNode = rootNode;
        refNode = yangNodeIterator.next();
    } else {
        refNode = rootNode;
        selfNode = yangNodeIterator.next();
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("module1"));
    ListIterator<YangLeaf> leafIterator = yangNode.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("invalid-interval"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(LEAFREF));
    // Check whether the data model tree returned is of type module.
    assertThat(refNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(refNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode1 = (YangModule) refNode;
    assertThat(yangNode1.getName(), is("module2"));
    YangLeaf leafInfo1 = yangNode1.getListOfLeaf().listIterator().next();
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    assertThat(leafref.getReferredLeafOrLeafList(), is(leafInfo1));
    assertThat(leafref.getResolvableStatus(), is(RESOLVED));
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.STRING));
}
#end_block

#method_before
@Test
public void processInterFileLeafrefFromGroupingRefersToOtherFile() throws IOException, ParserException {
    String searchDir = "src/test/resources/interfileleafreffromgroupingreferstootherfile";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    Iterator<YangNode> yangNodeIterator = utilManager.getYangNodeSet().iterator();
    YangNode rootNode = yangNodeIterator.next();
    if (rootNode.getName().equals("module1")) {
        selfNode = rootNode;
        refNode = yangNodeIterator.next();
    } else {
        refNode = rootNode;
        selfNode = yangNodeIterator.next();
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("module1"));
    YangList list = (YangList) yangNode.getChild().getChild();
    ListIterator<YangLeaf> leafIterator = list.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("link-tp"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(LEAFREF));
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    YangLeaf leafInfo2 = (YangLeaf) leafref.getReferredLeafOrLeafList();
    assertThat(leafref.getReferredLeafOrLeafList(), is(leafInfo2));
    assertThat(leafref.getResolvableStatus(), is(RESOLVED));
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.STRING));
}
#method_after
@Test
public void processInterFileLeafrefFromGroupingRefersToOtherFile() throws IOException, ParserException {
    String searchDir = "src/test/resources/interfileleafreffromgroupingreferstootherfile";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode selfNode = null;
    YangNode refNode = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    Iterator<YangNode> yangNodeIterator = utilManager.getYangNodeSet().iterator();
    YangNode rootNode = yangNodeIterator.next();
    if (rootNode.getName().equals("module1")) {
        selfNode = rootNode;
        refNode = yangNodeIterator.next();
    } else {
        refNode = rootNode;
        selfNode = yangNodeIterator.next();
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("module1"));
    YangList list = (YangList) yangNode.getChild().getChild();
    ListIterator<YangLeaf> leafIterator = list.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("link-tp"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(LEAFREF));
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    YangLeaf leafInfo2 = (YangLeaf) leafref.getReferredLeafOrLeafList();
    assertThat(leafref.getReferredLeafOrLeafList(), is(leafInfo2));
    assertThat(leafref.getResolvableStatus(), is(RESOLVED));
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.STRING));
}
#end_block

#method_before
@Test
public void processInterFileLeafrefRefersToMultipleLeafrefInMultipleFiles() throws IOException, ParserException {
    String searchDir = "src/test/resources/interfileleafrefreferstomultipleleafrefinmultiplefiles";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    YangNode selfNode = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("ietf-network-topology")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("ietf-network")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("ietf-network-topology"));
    YangList list = (YangList) yangNode.getChild().getChild();
    ListIterator<YangLeaf> leafIterator = list.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("link-tp"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(LEAFREF));
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    YangLeaf leafInfo2 = (YangLeaf) leafref.getReferredLeafOrLeafList();
    assertThat(leafref.getReferredLeafOrLeafList(), is(leafInfo2));
    assertThat(leafref.getResolvableStatus(), is(RESOLVED));
    assertThat(leafref.getEffectiveDataType(), is(YangDataTypes.STRING));
}
#method_after
@Test
public void processInterFileLeafrefRefersToMultipleLeafrefInMultipleFiles() throws IOException, ParserException {
    String searchDir = "src/test/resources/interfileleafrefreferstomultipleleafrefinmultiplefiles";
    utilManager.createYangFileInfoSet(YangFileScanner.getYangFiles(searchDir));
    utilManager.parseYangFileInfoSet();
    utilManager.createYangNodeSet();
    YangNode refNode1 = null;
    YangNode refNode2 = null;
    YangNode selfNode = null;
    // Create YANG node set
    yangLinkerManager.createYangNodeSet(utilManager.getYangNodeSet());
    // Add references to import list.
    yangLinkerManager.addRefToYangFilesImportList(utilManager.getYangNodeSet());
    // Carry out inter-file linking.
    yangLinkerManager.processInterFileLinking(utilManager.getYangNodeSet());
    for (YangNode rootNode : utilManager.getYangNodeSet()) {
        if (rootNode.getName().equals("ietf-network-topology")) {
            selfNode = rootNode;
        } else if (rootNode.getName().equals("ietf-network")) {
            refNode1 = rootNode;
        } else {
            refNode2 = rootNode;
        }
    }
    // Check whether the data model tree returned is of type module.
    assertThat(selfNode instanceof YangModule, is(true));
    // Check whether the node type is set properly to module.
    assertThat(selfNode.getNodeType(), is(MODULE_NODE));
    // Check whether the module name is set correctly.
    YangModule yangNode = (YangModule) selfNode;
    assertThat(yangNode.getName(), is("ietf-network-topology"));
    YangList list = (YangList) yangNode.getChild().getChild();
    ListIterator<YangLeaf> leafIterator = list.getListOfLeaf().listIterator();
    YangLeaf leafInfo = leafIterator.next();
    assertThat(leafInfo.getName(), is("link-tp"));
    assertThat(leafInfo.getDataType().getDataTypeName(), is("leafref"));
    assertThat(leafInfo.getDataType().getDataType(), is(LEAFREF));
    YangLeafRef leafref = (YangLeafRef) leafInfo.getDataType().getDataTypeExtendedInfo();
    YangLeaf leafInfo2 = (YangLeaf) leafref.getReferredLeafOrLeafList();
    assertThat(leafref.getReferredLeafOrLeafList(), is(leafInfo2));
    assertThat(leafref.getResolvableStatus(), is(RESOLVED));
    assertThat(leafref.getEffectiveDataType().getDataType(), is(YangDataTypes.STRING));
}
#end_block

#method_before
@Override
public void event(NetconfDeviceOutputEvent event) {
    if (event.type() == NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION) {
        DeviceId deviceId = event.getDeviceInfo().getDeviceId();
        NetconfAlarmTranslator translator = new NetconfAlarmTranslator();
        Alarm newAlarm = translator.translateToAlarm(deviceId, event.getMessagePayload());
        Set<Alarm> alarmSet = new HashSet<>(alarmService.getActiveAlarms());
        alarmSet.add(newAlarm);
        triggerProbe(deviceId, alarmSet);
    }
}
#method_after
@Override
public void event(NetconfDeviceOutputEvent event) {
    if (event.type() == NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION) {
        DeviceId deviceId = event.getDeviceInfo().getDeviceId();
        NetconfAlarmTranslator translator = new NetconfAlarmTranslator();
        String message = event.getMessagePayload();
        InputStream in = new ByteArrayInputStream(message.getBytes(StandardCharsets.UTF_8));
        Collection<Alarm> newAlarms = translator.translateToAlarm(deviceId, in);
        triggerProbe(deviceId, newAlarms);
    }
}
#end_block

#method_before
@Override
public Alarm translateToAlarm(DeviceId deviceId, String message) {
    try {
        Document doc = createDocFromMessage(message);
        // parse date element value into long
        String date = doc.getElementsByTagName(EVENTTIME_TAGNAME).item(0).getTextContent();
        long timeStamp = parseDate(date);
        // event-specific tag name as alarm description
        Node descriptionNode = doc.getDocumentElement().getChildNodes().item(EVENTSPECIFIC_TAG_NO);
        if (descriptionNode == null) {
            return null;
        }
        String description = descriptionNode.getNodeName();
        return new DefaultAlarm.Builder(deviceId, description, Alarm.SeverityLevel.WARNING, timeStamp).build();
    } catch (Exception e) {
        log.error("Error reading {} from {}.", message, deviceId);
        return null;
    }
}
#method_after
@Override
public Collection<Alarm> translateToAlarm(DeviceId deviceId, InputStream message) {
    try {
        Collection<Alarm> alarms = new ArrayList<>();
        Document doc = createDocFromMessage(message);
        // parse date element value into long
        Node eventTime = doc.getElementsByTagName(EVENTTIME_TAGNAME).item(0);
        String date = eventTime.getTextContent();
        long timeStamp = parseDate(date);
        // event-specific tag names as alarm descriptions
        Node descriptionNode = eventTime.getNextSibling();
        while (descriptionNode != null) {
            if (descriptionNode.getNodeType() == Node.ELEMENT_NODE) {
                String description = nodeToString(descriptionNode);
                alarms.add(new DefaultAlarm.Builder(deviceId, description, Alarm.SeverityLevel.WARNING, timeStamp).build());
                descriptionNode = null;
            } else {
                descriptionNode = descriptionNode.getNextSibling();
            }
        }
        return alarms;
    } catch (SAXException | IOException | ParserConfigurationException | UnsupportedOperationException | IllegalArgumentException | TransformerException e) {
        log.error("Exception thrown translating {} from {}.", message, deviceId);
        return ImmutableSet.of();
    }
}
#end_block

#method_before
private Document createDocFromMessage(String message) throws Exception {
    DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();
    DocumentBuilder builder = dbfactory.newDocumentBuilder();
    InputSource source = new InputSource(new StringReader(message));
    return builder.parse(source);
}
#method_after
private Document createDocFromMessage(InputStream message) throws SAXException, IOException, ParserConfigurationException {
    DocumentBuilderFactory dbfactory = DocumentBuilderFactory.newInstance();
    DocumentBuilder builder = dbfactory.newDocumentBuilder();
    return builder.parse(new InputSource(message));
}
#end_block

#method_before
private long parseDate(String timeStr) throws ParseException {
    SimpleDateFormat dateFormat = new SimpleDateFormat(TIME_FORMAT, Locale.US);
    return dateFormat.parse(timeStr).getTime();
}
#method_after
private long parseDate(String timeStr) throws UnsupportedOperationException, IllegalArgumentException {
    return ISODateTimeFormat.dateTimeNoMillis().parseMillis(timeStr);
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    packetService.addProcessor(internalPacketProcessor, PacketProcessor.director(1));
    deviceService.addListener(internalDeviceListener);
    floatingIpMap = storageService.<String, OpenstackFloatingIP>consistentMapBuilder().withSerializer(Serializer.using(FLOATING_IP_SERIALIZER.build())).withName(FLOATING_IP_MAP_NAME).withApplicationId(appId).build();
    tpPortNumMap = storageService.<Integer, String>consistentMapBuilder().withSerializer(Serializer.using(NUMBER_SERIALIZER.build())).withName(TP_PORT_MAP_NAME).withApplicationId(appId).build();
    routerInterfaceMap = storageService.<String, String>consistentMapBuilder().withSerializer(Serializer.using(ROUTER_INTERFACE_SERIALIZER.build())).withName(ROUTER_INTERFACE_MAP_NAME).withApplicationId(appId).build();
    rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, nodeService);
    openstackIcmpHandler = new OpenstackIcmpHandler(packetService, deviceService, hostService, openstackService, nodeService);
    openstackArpHandler = new OpenstackRoutingArpHandler(packetService, openstackService, nodeService);
    openstackIcmpHandler.requestPacket(appId);
    openstackArpHandler.requestPacket(appId);
    openstackService.floatingIps().stream().forEach(f -> floatingIpMap.put(f.id(), f));
    log.info("started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    hostService.addListener(internalHostListener);
    nodeService.addListener(internalNodeListener);
    hostProviderService = hostProviderRegistry.register(hostProvider);
    floatingIpMap = storageService.<String, OpenstackFloatingIP>consistentMapBuilder().withSerializer(Serializer.using(FLOATING_IP_SERIALIZER.build())).withName(FLOATING_IP_MAP_NAME).withApplicationId(appId).build();
    tpPortNumMap = storageService.<Integer, String>consistentMapBuilder().withSerializer(Serializer.using(NUMBER_SERIALIZER.build())).withName(TP_PORT_MAP_NAME).withApplicationId(appId).build();
    routerInterfaceMap = storageService.<String, String>consistentMapBuilder().withSerializer(Serializer.using(ROUTER_INTERFACE_SERIALIZER.build())).withName(ROUTER_INTERFACE_MAP_NAME).withApplicationId(appId).build();
    log.info("started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(internalPacketProcessor);
    deviceService.removeListener(internalDeviceListener);
    l3EventExecutorService.shutdown();
    icmpEventExecutorService.shutdown();
    arpEventExecutorService.shutdown();
    floatingIpMap.clear();
    tpPortNumMap.clear();
    routerInterfaceMap.clear();
    log.info("stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    packetService.removeProcessor(internalPacketProcessor);
    hostService.removeListener(internalHostListener);
    nodeService.removeListener(internalNodeListener);
    l3EventExecutorService.shutdown();
    icmpEventExecutorService.shutdown();
    arpEventExecutorService.shutdown();
    floatingIpMap.clear();
    tpPortNumMap.clear();
    routerInterfaceMap.clear();
    log.info("stopped");
}
#end_block

#method_before
@Override
public void updateFloatingIP(OpenstackFloatingIP openstackFloatingIp) {
    if (!floatingIpMap.containsKey(openstackFloatingIp.id())) {
        log.warn("There`s no information about {} in FloatingIpMap", openstackFloatingIp.id());
        return;
    }
    if (openstackFloatingIp.portId() == null || openstackFloatingIp.portId().equals("null")) {
        OpenstackFloatingIP floatingIp = floatingIpMap.get(openstackFloatingIp.id()).value();
        // XXX When the VM has been removed, host information has been removed or not already ???
        Optional<Host> host = hostService.getHostsByIp(openstackFloatingIp.fixedIpAddress().getIp4Address()).stream().findFirst();
        if (!host.isPresent()) {
            log.warn("No Host info with the VM IP the Floating IP address {} is found", openstackFloatingIp.floatingIpAddress());
            return;
        }
        l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, floatingIp, Action.DISSASSOCIATE, host.get()));
        floatingIpMap.replace(floatingIp.id(), openstackFloatingIp);
    } else {
        floatingIpMap.put(openstackFloatingIp.id(), openstackFloatingIp);
        l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, openstackFloatingIp, Action.ASSOCIATE, null));
    }
}
#method_after
@Override
public void updateFloatingIP(OpenstackFloatingIP openstackFloatingIp) {
    if (!floatingIpMap.containsKey(openstackFloatingIp.id())) {
        log.warn("There`s no information about {} in FloatingIpMap", openstackFloatingIp.id());
        return;
    }
    if (openstackFloatingIp.portId() == null || openstackFloatingIp.portId().equals("null")) {
        OpenstackFloatingIP floatingIp = floatingIpMap.get(openstackFloatingIp.id()).value();
        // XXX When the VM has been removed, host information has been removed or not ???
        Optional<Host> host = hostService.getHostsByIp(openstackFloatingIp.fixedIpAddress().getIp4Address()).stream().findFirst();
        if (!host.isPresent()) {
            log.warn("No Host info with the VM IP the Floating IP address {} is found", openstackFloatingIp.floatingIpAddress());
            return;
        }
        l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, floatingIp, Action.DISSASSOCIATE, host.get()));
        floatingIpMap.replace(floatingIp.id(), openstackFloatingIp);
        registerFloatingIpToHostService(openstackFloatingIp, Action.DISSASSOCIATE);
    } else {
        floatingIpMap.put(openstackFloatingIp.id(), openstackFloatingIp);
        l3EventExecutorService.execute(new OpenstackFloatingIPHandler(rulePopulator, openstackFloatingIp, Action.ASSOCIATE, null));
        registerFloatingIpToHostService(openstackFloatingIp, Action.ASSOCIATE);
    }
}
#end_block

#method_before
private void removeL3RulesForRouterInterface(OpenstackRouterInterface routerInterface, OpenstackRouter router, List<OpenstackRouterInterface> newList) {
    openstackService.ports(routerInterfaceMap.get(routerInterface.portId()).value()).forEach(p -> {
        Ip4Address vmIp = (Ip4Address) p.fixedIps().values().toArray()[0];
        if (newList == null) {
            rulePopulator.removeL3Rules(vmIp, getL3ConnectionList(p.networkId(), getOpenstackRouterInterface(router)));
        } else {
            rulePopulator.removeL3Rules(vmIp, newList);
        }
    });
}
#method_after
private void removeL3RulesForRouterInterface(OpenstackRouterInterface routerInterface, OpenstackRouter router, List<OpenstackRouterInterface> newList) {
    if (!routerInterfaceMap.containsKey(routerInterface.portId())) {
        log.warn("No router interface information found for {}", routerInterface.portId());
        return;
    }
    openstackService.ports(routerInterfaceMap.get(routerInterface.portId()).value()).forEach(p -> {
        Ip4Address vmIp = (Ip4Address) p.fixedIps().values().toArray()[0];
        if (newList == null) {
            rulePopulator.removeL3Rules(vmIp, getL3ConnectionList(p.networkId(), getOpenstackRouterInterface(router)));
        } else {
            rulePopulator.removeL3Rules(vmIp, newList);
        }
    });
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    DeviceId senderDeviceId = context.inPacket().receivedFrom().deviceId();
    if (context.isHandled()) {
        return;
    } else if (!context.inPacket().receivedFrom().deviceId().toString().equals(nodeService.routerBridge(senderDeviceId))) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    // TODO: Considers IPv6 later.
    if (ethernet == null) {
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 iPacket = (IPv4) ethernet.getPayload();
        switch(iPacket.getProtocol()) {
            case IPv4.PROTOCOL_ICMP:
                icmpEventExecutorService.execute(() -> openstackIcmpHandler.processIcmpPacket(context, ethernet));
                break;
            case IPv4.PROTOCOL_UDP:
                // don't process DHCP
                UDP udpPacket = (UDP) iPacket.getPayload();
                if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                    break;
                }
            default:
                int portNum = getPortNum(ethernet.getSourceMAC(), iPacket.getDestinationAddress());
                Optional<Port> port = getExternalPort(pkt.receivedFrom().deviceId(), org.onosproject.openstacknode.Constants.PATCH_INTG_BRIDGE);
                if (port.isPresent()) {
                    OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                    l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port.get()));
                } else {
                    log.warn("There`s no external interface");
                }
                break;
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpEventExecutorService.execute(() -> openstackArpHandler.processArpPacketFromRouter(context, ethernet));
    }
}
#method_after
@Override
public void process(PacketContext context) {
    DeviceId senderDeviceId = context.inPacket().receivedFrom().deviceId();
    if (!nodeService.routerBridge(senderDeviceId).isPresent()) {
        log.warn("No router bridge for {} is found.", senderDeviceId);
        return;
    }
    if (context.isHandled()) {
        return;
    } else if (!checkGatewayNode(context.inPacket().receivedFrom().deviceId())) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    // TODO: Considers IPv6 later.
    if (ethernet == null) {
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 iPacket = (IPv4) ethernet.getPayload();
        switch(iPacket.getProtocol()) {
            case IPv4.PROTOCOL_ICMP:
                icmpEventExecutorService.execute(() -> openstackIcmpHandler.processIcmpPacket(context, ethernet));
                break;
            case IPv4.PROTOCOL_UDP:
                // don't process DHCP
                UDP udpPacket = (UDP) iPacket.getPayload();
                if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                    break;
                }
            default:
                int portNum = getPortNum(ethernet.getSourceMAC(), iPacket.getDestinationAddress());
                DeviceId deviceId = pkt.receivedFrom().deviceId();
                Port port = null;
                port = deviceService.getPort(deviceId, gatewayService.getGatewayExternalPorts(deviceId).get(0));
                if (port != null) {
                    OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                    l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port));
                } else {
                    log.warn("There`s no external interface");
                }
                break;
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpEventExecutorService.execute(() -> openstackArpHandler.processArpPacketFromRouter(context, ethernet));
    }
}
#end_block

#method_before
public void requestPacket(ApplicationId appId) {
    TrafficSelector arpSelector = DefaultTrafficSelector.builder().matchEthType(EthType.EtherType.ARP.ethType().toShort()).build();
    // TODO Return the correct gateway node
    Optional<OpenstackNode> gwNode = nodeService.nodes().stream().filter(n -> n.type().equals(OpenstackNodeService.NodeType.GATEWAY)).findFirst();
    if (!gwNode.isPresent()) {
        log.warn("No Gateway is defined.");
        return;
    }
    packetService.requestPackets(arpSelector, PacketPriority.CONTROL, appId, Optional.of(gwNode.get().intBridge()));
}
#method_after
public void requestPacket(ApplicationId appId) {
    TrafficSelector arpSelector = DefaultTrafficSelector.builder().matchEthType(EthType.EtherType.ARP.ethType().toShort()).build();
    getExternalInfo().forEach(deviceId -> packetService.requestPackets(arpSelector, PacketPriority.CONTROL, appId, Optional.of(deviceId)));
}
#end_block

#method_before
private void populatePnatOutgoingFlowRules(long vni, Ip4Address externalIp) {
    IPv4 iPacket = (IPv4) inboundPacket.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchTunnelId(vni).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    tBuilder.setEthSrc(externalInterface).setEthDst(externalRouter).setIpSrc(externalIp);
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(TpPort.tpPort(portNum));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(TpPort.tpPort(portNum));
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    Port port = checkNotNull(getPortOfExternalInterface(), PORTNOTNULL);
    tBuilder.setOutput(port.number());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
    flowObjectiveService.forward(inboundPacket.receivedFrom().deviceId(), fo);
}
#method_after
private void populatePnatOutgoingFlowRules(long vni, Ip4Address externalIp) {
    IPv4 iPacket = (IPv4) inboundPacket.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchTunnelId(vni).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(TpPort.tpPort(portNum));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(TpPort.tpPort(portNum));
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    tBuilder.setIpSrc(externalIp);
    gatewayService.getGatewayNodes().forEach(node -> {
        tBuilder.setOutput(gatewayService.getGatewayExternalPorts(node.getGatewayDeviceId()).get(0));
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
        flowObjectiveService.forward(node.getGatewayDeviceId(), fo);
    });
}
#end_block

#method_before
private void populatePnatIncomingFlowRules(long vni, Ip4Address externalIp) {
    IPv4 iPacket = (IPv4) inboundPacket.parsed().getPayload();
    DeviceId deviceId = inboundPacket.receivedFrom().deviceId();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPDst(IpPrefix.valueOf(externalIp, 32)).matchIPSrc(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    tBuilder.setTunnelId(vni).setEthDst(inboundPacket.parsed().getSourceMAC()).setIpDst(IpAddress.valueOf(iPacket.getSourceAddress()));
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getDestinationPort())).matchTcpDst(TpPort.tpPort(portNum));
            tBuilder.setTcpDst(TpPort.tpPort(tcpPacket.getSourcePort()));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getDestinationPort())).matchUdpDst(TpPort.tpPort(portNum));
            tBuilder.setUdpDst(TpPort.tpPort(udpPacket.getSourcePort()));
            break;
        default:
            break;
    }
    tBuilder.extension(buildNiciraExtenstion(deviceId, getHostIpfromOpenstackPort(openstackPort).getIp4Address()), deviceId).setOutput(getTunnelPort(deviceId));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
    flowObjectiveService.forward(inboundPacket.receivedFrom().deviceId(), fo);
}
#method_after
private void populatePnatIncomingFlowRules(long vni, Ip4Address externalIp) {
    IPv4 iPacket = (IPv4) inboundPacket.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPDst(IpPrefix.valueOf(externalIp, 32)).matchIPSrc(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    tBuilder.setTunnelId(vni).setEthDst(inboundPacket.parsed().getSourceMAC()).setIpDst(IpAddress.valueOf(iPacket.getSourceAddress()));
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getDestinationPort())).matchTcpDst(TpPort.tpPort(portNum));
            tBuilder.setTcpDst(TpPort.tpPort(tcpPacket.getSourcePort()));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getDestinationPort())).matchUdpDst(TpPort.tpPort(portNum));
            tBuilder.setUdpDst(TpPort.tpPort(udpPacket.getSourcePort()));
            break;
        default:
            break;
    }
    getGatewayNodeList().forEach(node -> {
        DeviceId deviceId = node.id();
        tBuilder.extension(buildNiciraExtenstion(deviceId, getHostIpfromOpenstackPort(openstackPort).getIp4Address()), deviceId).setOutput(getTunnelPort(deviceId));
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
        flowObjectiveService.forward(deviceId, fo);
    });
}
#end_block

#method_before
private Device getDevicefromOpenstackPort(OpenstackPort openstackPort) {
    String openstackPortName = PORTNAME_PREFIX_VM + openstackPort.id().substring(0, 11);
    Device device = StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> findPortinDevice(d, openstackPortName)).iterator().next();
    checkNotNull(device, DEVICENOTNULL);
    return device;
}
#method_after
private Device getDevicefromOpenstackPort(OpenstackPort openstackPort) {
    String openstackPortName = PORTNAME_PREFIX_VM + openstackPort.id().substring(0, 11);
    Device device = StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> findPortinDevice(d.id(), openstackPortName)).iterator().next();
    checkNotNull(device, DEVICENOTNULL);
    return device;
}
#end_block

#method_before
private boolean findPortinDevice(Device d, String openstackPortName) {
    Port port = deviceService.getPorts(d.id()).stream().filter(p -> p.isEnabled() && p.annotations().value(PORTNAME).equals(openstackPortName)).findAny().orElse(null);
    return port != null;
}
#method_after
private boolean findPortinDevice(DeviceId deviceId, String openstackPortName) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.isEnabled() && p.annotations().value(PORTNAME).equals(openstackPortName)).findAny().orElse(null);
    return port != null;
}
#end_block

#method_before
public ExtensionTreatment buildNiciraExtenstion(DeviceId id, Ip4Address hostIp) {
    Driver driver = driverService.getDriver(id);
    DriverHandler driverHandler = new DefaultDriverHandler(new DefaultDriverData(driver, id));
    ExtensionTreatmentResolver resolver = driverHandler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment extensionInstruction = resolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type());
    try {
        extensionInstruction.setPropertyValue(TUNNEL_DESTINATION, hostIp);
    } catch (ExtensionPropertyException e) {
        log.error("Error setting Nicira extension setting {}", e);
    }
    return extensionInstruction;
}
#method_after
public ExtensionTreatment buildNiciraExtenstion(DeviceId deviceId, Ip4Address hostIp) {
    Driver driver = driverService.getDriver(deviceId);
    DriverHandler driverHandler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
    ExtensionTreatmentResolver resolver = driverHandler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment extensionInstruction = resolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type());
    try {
        extensionInstruction.setPropertyValue(TUNNEL_DESTINATION, hostIp);
    } catch (ExtensionPropertyException e) {
        log.error("Error setting Nicira extension setting {}", e);
    }
    return extensionInstruction;
}
#end_block

#method_before
private void populateRuleGatewaytoController(long vni) {
    Device gatewayDevice = getGatewayNode();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchEthDst(Constants.GATEWAY_MAC);
    tBuilder.setOutput(PortNumber.CONTROLLER);
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(gatewayDevice.id(), fo);
}
#method_after
private void populateRuleGatewaytoController(long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchEthDst(Constants.GATEWAY_MAC);
    tBuilder.setOutput(PortNumber.CONTROLLER);
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).add();
    getGatewayNodeList().forEach(device -> flowObjectiveService.forward(device.id(), fo));
}
#end_block

#method_before
private void populateComputeNodeRules(long vni) {
    Device gatewayDevice = getGatewayNode();
    StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> !checkGatewayNode(d.id())).forEach(d -> populateRuleToGateway(d, gatewayDevice, vni));
}
#method_after
private void populateComputeNodeRules(long vni) {
    StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> isTypeOf(d.id(), OpenstackNodeService.NodeType.COMPUTE)).forEach(d -> populateRuleToGatewayBySgw(d.id(), gatewayService.getGroupIdForGatewayLoadBalance(d.id()), vni));
}
#end_block

#method_before
private Device getGatewayNode() {
    // TODO Return the correct gateway node
    Optional<OpenstackNode> gwNode = nodeService.nodes().stream().filter(n -> n.type().equals(OpenstackNodeService.NodeType.GATEWAY)).findFirst();
    if (!gwNode.isPresent()) {
        log.warn("No Gateway is defined.");
        return null;
    }
    return deviceService.getDevice(gwNode.get().intBridge());
}
#method_after
/*
    private void populateRuleToGateway(DeviceId deviceId, Device gatewayDevice, long vni) {
        TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
        TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();

        sBuilder.matchEthType(Ethernet.TYPE_IPV4)
                .matchTunnelId(vni)
                .matchEthDst(Constants.GATEWAY_MAC);
        tBuilder.extension(buildNiciraExtenstion(deviceId, nodeService.nodes().get(gatewayDevice.id())), deviceId)
                .setOutput(getTunnelPort(deviceId));

        ForwardingObjective fo = DefaultForwardingObjective.builder()
                .withSelector(sBuilder.build())
                .withTreatment(tBuilder.build())
                .withFlag(ForwardingObjective.Flag.SPECIFIC)
                .withPriority(ROUTING_RULE_PRIORITY)
                .fromApp(appId)
                .add();

        flowObjectiveService.forward(deviceId, fo);
    }
    */
private Device getGatewayNode() {
    // TODO Return the correct gateway node
    Optional<OpenstackNode> gwNode = nodeService.nodes().stream().filter(n -> n.type().equals(OpenstackNodeService.NodeType.GATEWAY)).findFirst();
    if (!gwNode.isPresent()) {
        log.warn("No Gateway is defined.");
        return null;
    }
    return deviceService.getDevice(gwNode.get().intBridge());
}
#end_block

#method_before
public void removeExternalRules(OpenstackRouterInterface routerInterface) {
    OpenstackSubnet openstackSubnet = openstackService.subnet(routerInterface.subnetId());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(openstackSubnet.networkId())).matchEthDst(Constants.GATEWAY_MAC);
    StreamSupport.stream(deviceService.getDevices().spliterator(), false).forEach(d -> {
        ForwardingObjective.Flag flag = checkGatewayNode(d.id()) ? ForwardingObjective.Flag.VERSATILE : ForwardingObjective.Flag.SPECIFIC;
        removeRule(d.id(), sBuilder, flag, ROUTING_RULE_PRIORITY);
    });
}
#method_after
public void removeExternalRules(OpenstackRouterInterface routerInterface) {
    OpenstackSubnet openstackSubnet = openstackService.subnet(routerInterface.subnetId());
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(openstackSubnet.networkId())).matchEthDst(Constants.GATEWAY_MAC);
    StreamSupport.stream(deviceService.getDevices().spliterator(), false).forEach(d -> {
        ForwardingObjective.Flag flag = isTypeOf(d.id(), OpenstackNodeService.NodeType.GATEWAY) ? ForwardingObjective.Flag.VERSATILE : ForwardingObjective.Flag.SPECIFIC;
        removeRule(d.id(), sBuilder, flag, ROUTING_RULE_PRIORITY);
    });
}
#end_block

#method_before
private void removeRule(DeviceId id, TrafficSelector.Builder sBuilder, ForwardingObjective.Flag flag, int priority) {
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(flag).withPriority(priority).fromApp(appId).remove();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void removeRule(DeviceId deviceId, TrafficSelector.Builder sBuilder, ForwardingObjective.Flag flag, int priority) {
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(flag).withPriority(priority).fromApp(appId).remove();
    flowObjectiveService.forward(deviceId, fo);
}
#end_block

#method_before
private void populateFloatingIpIncomingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    DeviceId portDeviceId = getDevicefromOpenstackPort(port).id();
    Device gatewayNode = getGatewayNode();
    Device portNode = deviceService.getDevice(portDeviceId);
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), PREFIX_LENGTH));
    Optional<IpAddress> ipAddress = nodeService.dataIp(portNode.id());
    if (!ipAddress.isPresent()) {
        log.warn("No IP address found for device {}", portNode.id());
        return;
    }
    tBuilder.setEthSrc(Constants.GATEWAY_MAC).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(gatewayNode.id(), ipAddress.get().getIp4Address()), gatewayNode.id()).setOutput(getTunnelPort(gatewayNode.id()));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#method_after
private void populateFloatingIpIncomingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), PREFIX_LENGTH));
    DeviceId gatewayDeviceId = DeviceId.deviceId(port.deviceId());
    Optional<IpAddress> ipAddress = nodeService.dataIp(gatewayDeviceId);
    if (!ipAddress.isPresent()) {
        log.warn("No IP address found for device {}", port.deviceId());
        return;
    }
    tBuilder.setEthSrc(Constants.GATEWAY_MAC).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(gatewayDeviceId, ipAddress.get().getIp4Address()), gatewayDeviceId).setOutput(getTunnelPort(gatewayDeviceId));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#end_block

#method_before
private void populateFloatingIpOutgoingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    Port outputPort = checkNotNull(getPortOfExternalInterface(), PORTNOTNULL);
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(port.networkId())).matchIPSrc(IpPrefix.valueOf(floatingIP.fixedIpAddress(), 32));
    // TODO: GW_EXT_INT_MAC and PHY_ROUTER_MAC should be changed correctly - Scalable Gateway
    tBuilder.setIpSrc(floatingIP.floatingIpAddress()).setEthSrc(Constants.GW_EXT_INT_MAC).setEthDst(Constants.PHY_ROUTER_MAC).setOutput(outputPort.number());
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(getGatewayNode().id(), fo);
}
#method_after
private void populateFloatingIpOutgoingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(port.networkId())).matchIPSrc(IpPrefix.valueOf(floatingIP.fixedIpAddress(), 32));
    getGatewayNodeList().forEach(device -> {
        DeviceId deviceId = device.id();
        tBuilder.setIpSrc(floatingIP.floatingIpAddress()).setEthSrc(Constants.GW_EXT_INT_MAC).setEthDst(Constants.PHY_ROUTER_MAC).setOutput(getExternalPortNum(deviceId));
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
        flowObjectiveService.forward(deviceId, fo);
    });
}
#end_block

#method_before
public void removeFloatingIpRules(OpenstackFloatingIP floatingIp, Host host) {
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    // XXX FloatingIp.tenant_id() == host.vxlan_id ???
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Integer.parseInt(host.annotations().value(Constants.VXLAN_ID))).matchIPSrc(IpPrefix.valueOf(floatingIp.fixedIpAddress(), PREFIX_LENGTH));
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIp.floatingIpAddress(), PREFIX_LENGTH));
    removeRule(getGatewayNode().id(), sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
    removeRule(getGatewayNode().id(), sIncomingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
}
#method_after
public void removeFloatingIpRules(OpenstackFloatingIP floatingIp, Host host) {
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    // XXX FloatingIp.tenant_id() == host.vxlan_id ???
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(Integer.parseInt(host.annotations().value(Constants.VXLAN_ID))).matchIPSrc(IpPrefix.valueOf(floatingIp.fixedIpAddress(), PREFIX_LENGTH));
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIp.floatingIpAddress(), PREFIX_LENGTH));
    getGatewayNodeList().forEach(device -> {
        removeRule(device.id(), sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
        removeRule(device.id(), sIncomingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
    });
}
#end_block

#method_before
public void populateL3Rules(OpenstackPort p, List<OpenstackRouterInterface> targetList) {
    Device device = getDevicefromOpenstackPort(p);
    Port port = getPortFromOpenstackPort(device, p);
    Ip4Address vmIp = (Ip4Address) p.fixedIps().values().iterator().next();
    if (port == null) {
        return;
    }
    targetList.forEach(routerInterface -> {
        OpenstackPort openstackPort = openstackService.port(routerInterface.portId());
        long vni = getVni(openstackPort.networkId());
        if (vmIp == null) {
            return;
        }
        populateL3RulestoSameNode(vmIp, p, port, device, vni);
        deviceService.getAvailableDevices().forEach(d -> {
            if (!d.equals(device) && !d.equals(getGatewayNode())) {
                populateL3RulestoDifferentNode(vmIp, vni, d.id(), getHostIpfromOpenstackPort(p).getIp4Address());
            }
        });
    });
}
#method_after
public void populateL3Rules(OpenstackPort openstackPort, List<OpenstackRouterInterface> targetList) {
    Device device = getDevicefromOpenstackPort(openstackPort);
    Port port = getPortFromOpenstackPort(device, openstackPort);
    Ip4Address vmIp = openstackPort.fixedIps().values().iterator().next();
    if (port == null) {
        return;
    }
    targetList.forEach(routerInterface -> {
        long vni = getVni(openstackService.port(routerInterface.portId()).networkId());
        if (vmIp == null) {
            return;
        }
        populateL3RulestoSameNode(vmIp, openstackPort, port, device, vni);
        deviceService.getAvailableDevices().forEach(d -> {
            if (!d.equals(device) && !d.equals(getGatewayNode())) {
                populateL3RulestoDifferentNode(vmIp, vni, d.id(), getHostIpfromOpenstackPort(openstackPort).getIp4Address());
            }
        });
    });
}
#end_block

#method_before
public void removeL3Rules(Ip4Address vmIp, List<OpenstackRouterInterface> routerInterfaces) {
    if (vmIp == null) {
        return;
    }
    OpenstackRoutingService routingService = getService(OpenstackRoutingService.class);
    deviceService.getAvailableDevices().forEach(d -> {
        if (!d.equals(getGatewayNode())) {
            routerInterfaces.forEach(routerInterface -> {
                String networkId = routingService.networkIdForRouterInterface(routerInterface.portId());
                long vni = getVni(networkId);
                TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
                sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(vmIp.toIpPrefix()).matchTunnelId(vni);
                removeRule(d.id(), sBuilder, ForwardingObjective.Flag.SPECIFIC, ROUTING_RULE_PRIORITY);
            });
        }
    });
}
#method_after
public void removeL3Rules(Ip4Address vmIp, List<OpenstackRouterInterface> routerInterfaces) {
    if (vmIp == null) {
        return;
    }
    OpenstackRoutingService routingService = getService(OpenstackRoutingService.class);
    deviceService.getAvailableDevices().forEach(d -> {
        if (isTypeOf(d.id(), OpenstackNodeService.NodeType.COMPUTE)) {
            routerInterfaces.forEach(routerInterface -> {
                String networkId = routingService.networkIdForRouterInterface(routerInterface.portId());
                long vni = getVni(networkId);
                TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
                sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(vmIp.toIpPrefix()).matchTunnelId(vni);
                removeRule(d.id(), sBuilder, ForwardingObjective.Flag.SPECIFIC, ROUTING_RULE_PRIORITY);
            });
        }
    });
}
#end_block

#method_before
@Override
public void run() {
    InboundPacket inboundPacket = context.inPacket();
    Ethernet ethernet = checkNotNull(inboundPacket.parsed());
    // TODO: Considers IPV6
    if (ethernet.getEtherType() != Ethernet.TYPE_IPV4) {
        log.warn("Now, we just consider IP version 4");
        return;
    }
    OpenstackRouter router = getOpenstackRouter(openstackPort);
    // TODO: GW_EXT_INT_MAC and PHY_ROUTER_MAC should be changed correctly - Scalable Gateway
    rulePopulator.populatePnatFlowRules(inboundPacket, openstackPort, portNum, getExternalIp(router), Constants.GW_EXT_INT_MAC, Constants.PHY_ROUTER_MAC);
    packetOut((Ethernet) ethernet.clone(), inboundPacket.receivedFrom().deviceId(), portNum, router);
}
#method_after
@Override
public void run() {
    InboundPacket inboundPacket = context.inPacket();
    Ethernet ethernet = checkNotNull(inboundPacket.parsed());
    // TODO: Considers IPV6
    if (ethernet.getEtherType() != Ethernet.TYPE_IPV4) {
        log.warn("Now, we just consider IP version 4");
        return;
    }
    OpenstackRouter router = getOpenstackRouter(openstackPort);
    MacAddress externalMac = MacAddress.NONE;
    MacAddress routerMac = MacAddress.NONE;
    rulePopulator.populatePnatFlowRules(inboundPacket, openstackPort, portNum, getExternalIp(router), externalMac, routerMac);
    packetOut((Ethernet) ethernet.clone(), inboundPacket.receivedFrom().deviceId(), portNum, router);
}
#end_block

#method_before
private OpenstackRouter getOpenstackRouter(OpenstackPort openstackPort) {
    OpenstackInterfaceService networkingService = getService(OpenstackInterfaceService.class);
    OpenstackNetwork network = networkingService.network(openstackPort.networkId());
    OpenstackPort port = networkingService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).filter(p -> checkSameSubnet(p, openstackPort)).findAny().orElse(null);
    return checkNotNull(networkingService.router(port.deviceId()));
}
#method_after
private OpenstackRouter getOpenstackRouter(OpenstackPort openstackPort) {
    OpenstackInterfaceService networkingService = getService(OpenstackInterfaceService.class);
    OpenstackPort port = networkingService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).filter(p -> checkSameSubnet(p, openstackPort)).findAny().orElse(null);
    return checkNotNull(networkingService.router(port.deviceId()));
}
#end_block

#method_before
private void packetOut(Ethernet ethernet, DeviceId deviceId, int portNum, OpenstackRouter router) {
    PacketService packetService = getService(PacketService.class);
    IPv4 iPacket = (IPv4) ethernet.getPayload();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            tcpPacket.setSourcePort(portNum);
            tcpPacket.resetChecksum();
            tcpPacket.setParent(iPacket);
            iPacket.setPayload(tcpPacket);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            udpPacket.setSourcePort(portNum);
            udpPacket.resetChecksum();
            udpPacket.setParent(iPacket);
            iPacket.setPayload(udpPacket);
            break;
        default:
            log.error("Temporally, this method can process UDP and TCP protocol.");
            return;
    }
    iPacket.setSourceAddress(getExternalIp(router).toString());
    iPacket.resetChecksum();
    iPacket.setParent(ethernet);
    ethernet.setPayload(iPacket);
    // TODO: GW_EXT_INT_MAC and PHY_ROUTER_MAC should be changed correctly - Scalable Gateway
    ethernet.setSourceMACAddress(Constants.GW_EXT_INT_MAC).setDestinationMACAddress(Constants.PHY_ROUTER_MAC);
    ethernet.resetChecksum();
    treatment.setOutput(port.number());
    packetService.emit(new DefaultOutboundPacket(deviceId, treatment.build(), ByteBuffer.wrap(ethernet.serialize())));
}
#method_after
private void packetOut(Ethernet ethernet, DeviceId deviceId, int portNum, OpenstackRouter router) {
    PacketService packetService = getService(PacketService.class);
    IPv4 iPacket = (IPv4) ethernet.getPayload();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            tcpPacket.setSourcePort(portNum);
            tcpPacket.resetChecksum();
            tcpPacket.setParent(iPacket);
            iPacket.setPayload(tcpPacket);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            udpPacket.setSourcePort(portNum);
            udpPacket.resetChecksum();
            udpPacket.setParent(iPacket);
            iPacket.setPayload(udpPacket);
            break;
        default:
            log.error("Temporally, this method can process UDP and TCP protocol.");
            return;
    }
    iPacket.setSourceAddress(getExternalIp(router).toString());
    iPacket.resetChecksum();
    iPacket.setParent(ethernet);
    ethernet.setPayload(iPacket);
    ScalableGatewayService gatewayService = getService(ScalableGatewayService.class);
    GatewayNode gatewayNode = gatewayService.getGatewayNode(deviceId);
    if (gatewayNode.getGatewayExternalInterfaceNames().size() == 0) {
        log.error(EXTERNAL_PORT_NULL, deviceId.toString());
        return;
    }
    treatment.setOutput(gatewayService.getGatewayExternalPorts(deviceId).get(0));
    ethernet.resetChecksum();
    packetService.emit(new DefaultOutboundPacket(deviceId, treatment.build(), ByteBuffer.wrap(ethernet.serialize())));
}
#end_block

#method_before
private Ip4Address pNatIpForPort(Host host) {
    OpenstackPort openstackPort = openstackService.ports().stream().filter(p -> p.deviceOwner().equals(Constants.NETWORK_ROUTER_INTERFACE) && p.networkId().equals(host.annotations().value(Constants.NETWORK_ID))).findAny().orElse(null);
    checkNotNull(openstackPort, "openstackPort can not be null");
    return openstackService.router(openstackPort.deviceId()).gatewayExternalInfo().externalFixedIps().values().stream().findAny().orElse(null);
}
#method_after
private Ip4Address pNatIpForPort(Host host) {
    OpenstackPort openstackPort = openstackService.ports().stream().filter(p -> p.deviceOwner().equals(NETWORK_ROUTER_INTERFACE) && p.networkId().equals(host.annotations().value(Constants.NETWORK_ID))).findAny().orElse(null);
    checkNotNull(openstackPort, "openstackPort can not be null");
    return openstackService.router(openstackPort.deviceId()).gatewayExternalInfo().externalFixedIps().values().stream().findAny().orElse(null);
}
#end_block

#method_before
private PortNumber getPortForAnnotationPortName(DeviceId deviceId, String match) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(Constants.PORTNAME).equals(match)).findAny().orElse(null);
    checkNotNull(port, "port cannot be null");
    return port.number();
}
#method_after
private PortNumber getPortForAnnotationPortName(DeviceId deviceId, String match) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(PORTNAME).equals(match)).findAny().orElse(null);
    checkNotNull(port, "port cannot be null");
    return port.number();
}
#end_block

#method_before
private boolean requestToOpenstackRoutingNetwork(int destAddr) {
    OpenstackPort port = openstackService.ports().stream().filter(p -> p.deviceOwner().equals(Constants.NETWORK_ROUTER_GATEWAY) || p.deviceOwner().equals(Constants.NETWORK_FLOATING_IP)).filter(p -> p.fixedIps().containsValue(Ip4Address.valueOf(destAddr))).findAny().orElse(null);
    if (port == null) {
        return false;
    }
    return true;
}
#method_after
private boolean requestToOpenstackRoutingNetwork(int destAddr) {
    OpenstackPort port = openstackService.ports().stream().filter(p -> p.deviceOwner().equals(NETWORK_ROUTER_GATEWAY) || p.deviceOwner().equals(NETWORK_FLOATING_IP)).filter(p -> p.fixedIps().containsValue(Ip4Address.valueOf(destAddr))).findAny().orElse(null);
    if (port == null) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Activate
protected void activate() {
    coreService.registerApplication(APP_ID);
    deviceService.addListener(internalDeviceListener);
    hostProvider = hostProviderRegistry.register(this);
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    coreService.registerApplication(APP_ID);
    deviceService.addListener(internalDeviceListener);
    openstackNodeService.addListener(internalNodeListener);
    hostProvider = hostProviderRegistry.register(this);
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    hostProviderRegistry.unregister(this);
    deviceService.removeListener(internalDeviceListener);
    deviceEventExecutor.shutdown();
    configEventExecutor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    hostProviderRegistry.unregister(this);
    deviceService.removeListener(internalDeviceListener);
    openstackNodeService.removeListener(internalNodeListener);
    deviceEventExecutor.shutdown();
    configEventExecutor.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
private void processPortAdded(Port port) {
    OpenstackPort osPort = openstackService.port(port);
    if (osPort == null) {
        log.warn("Failed to get OpenStack port for {}", port);
        return;
    }
    OpenstackNetwork osNet = openstackService.network(osPort.networkId());
    if (osNet == null) {
        log.warn("Failed to get OpenStack network {}", osPort.networkId());
        return;
    }
    registerDhcpInfo(osPort);
    ConnectPoint connectPoint = new ConnectPoint(port.element().id(), port.number());
    // TODO remove this and openstackPortInfo
    String gatewayIp = osNet.subnets().stream().findFirst().get().gatewayIp();
    // Added CREATE_TIME intentionally to trigger HOST_UPDATED event for the
    // existing instances.
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(NETWORK_ID, osPort.networkId()).set(PORT_ID, osPort.id()).set(VXLAN_ID, osNet.segmentId()).set(TENANT_ID, osNet.tenantId()).set(GATEWAY_IP, gatewayIp).set(CREATE_TIME, String.valueOf(System.currentTimeMillis()));
    HostDescription hostDesc = new DefaultHostDescription(osPort.macAddress(), VlanId.NONE, new HostLocation(connectPoint, System.currentTimeMillis()), Sets.newHashSet(osPort.fixedIps().values()), annotations.build());
    HostId hostId = HostId.hostId(osPort.macAddress());
    hostProvider.hostDetected(hostId, hostDesc, false);
}
#method_after
private void processPortAdded(Port port) {
    // TODO check the node state is COMPLETE
    OpenstackPort osPort = openstackService.port(port);
    if (osPort == null) {
        log.warn("Failed to get OpenStack port for {}", port);
        return;
    }
    OpenstackNetwork osNet = openstackService.network(osPort.networkId());
    if (osNet == null) {
        log.warn("Failed to get OpenStack network {}", osPort.networkId());
        return;
    }
    registerDhcpInfo(osPort);
    ConnectPoint connectPoint = new ConnectPoint(port.element().id(), port.number());
    // TODO remove this and openstackPortInfo
    String gatewayIp = osNet.subnets().stream().findFirst().get().gatewayIp();
    // Added CREATE_TIME intentionally to trigger HOST_UPDATED event for the
    // existing instances.
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(NETWORK_ID, osPort.networkId()).set(PORT_ID, osPort.id()).set(VXLAN_ID, osNet.segmentId()).set(TENANT_ID, osNet.tenantId()).set(GATEWAY_IP, gatewayIp).set(CREATE_TIME, String.valueOf(System.currentTimeMillis()));
    HostDescription hostDesc = new DefaultHostDescription(osPort.macAddress(), VlanId.NONE, new HostLocation(connectPoint, System.currentTimeMillis()), Sets.newHashSet(osPort.fixedIps().values()), annotations.build());
    HostId hostId = HostId.hostId(osPort.macAddress());
    hostProvider.hostDetected(hostId, hostDesc, false);
}
#end_block

#method_before
private void processPortRemoved(Port port) {
    ConnectPoint connectPoint = new ConnectPoint(port.element().id(), port.number());
    hostService.getConnectedHosts(connectPoint).stream().forEach(host -> {
        dhcpService.removeStaticMapping(host.mac());
        hostProvider.hostVanished(host.id());
    });
}
#method_after
private void processPortRemoved(Port port) {
    ConnectPoint connectPoint = new ConnectPoint(port.element().id(), port.number());
    removeHosts(connectPoint);
}
#end_block

#method_before
@Override
public void resolveLinkingForResolutionInfo(YangReferenceResolver dataModelRootNode) throws DataModelException {
    setCurReferenceResolver(dataModelRootNode);
    // Current node to resolve, it can be a YANG type or YANG uses.
    T entityToResolve = getEntityToResolveInfo().getEntityToResolve();
    // Check if linking is already done
    if (entityToResolve instanceof Resolvable) {
        Resolvable resolvable = (Resolvable) entityToResolve;
        if (resolvable.getResolvableStatus() == RESOLVED) {
            /**
             * entity is already resolved, so nothing to do
             */
            return;
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    // Push the initial entity to resolve in stack.
    addInPartialResolvedStack(getEntityToResolveInfo());
    linkAndResolvePartialResolvedStack();
}
#method_after
@Override
public void resolveLinkingForResolutionInfo(YangReferenceResolver dataModelRootNode) throws DataModelException {
    setCurReferenceResolver(dataModelRootNode);
    // Current node to resolve, it can be a YANG type, YANG uses or YANG if-feature.
    T entityToResolve = getEntityToResolveInfo().getEntityToResolve();
    // Check if linking is already done
    if (entityToResolve instanceof Resolvable) {
        Resolvable resolvable = (Resolvable) entityToResolve;
        if (resolvable.getResolvableStatus() == RESOLVED) {
            /**
             * entity is already resolved, so nothing to do
             */
            return;
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than " + "type/uses/if-feature");
    }
    // Push the initial entity to resolve in stack.
    addInPartialResolvedStack(getEntityToResolveInfo());
    linkAndResolvePartialResolvedStack();
}
#end_block

#method_before
private void linkAndResolvePartialResolvedStack() throws DataModelException {
    while (getPartialResolvedStack().size() != 0) {
        // Current node to resolve, it can be a YANG type or YANG uses.
        T entityToResolve = getCurrentEntityToResolveFromStack();
        // Check if linking is already done
        if (entityToResolve instanceof Resolvable) {
            Resolvable resolvable = (Resolvable) entityToResolve;
            switch(resolvable.getResolvableStatus()) {
                case RESOLVED:
                    {
                        /*
                     * If the entity is already resolved in the stack, then pop
                     * it and continue with the remaining stack elements to
                     * resolve
                     */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case LINKED:
                    {
                        /*
                     * If the top of the stack is already linked then resolve
                     * the references and pop the entity and continue with
                     * remaining stack elements to resolve.
                     */
                        resolveTopOfStack(INTRA_FILE);
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTRA_FILE_RESOLVED:
                    {
                        /*
                     * Pop the top of the stack.
                     */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case UNRESOLVED:
                    {
                        linkTopOfStackReferenceUpdateStack();
                        if (resolvable.getResolvableStatus() == UNRESOLVED) {
                            // If current entity is still not resolved, then
                            // linking/resolution has failed.
                            String errorInfo;
                            if (resolvable instanceof YangType) {
                                errorInfo = TYPEDEF_LINKER_ERROR;
                            } else {
                                errorInfo = GROUPING_LINKER_ERROR;
                            }
                            DataModelException dataModelException = new DataModelException(errorInfo);
                            dataModelException.setLine(getLineNumber());
                            dataModelException.setCharPosition(getCharPosition());
                            throw dataModelException;
                        }
                        break;
                    }
                default:
                    {
                        throw new DataModelException("Data Model Exception: Unsupported, linker state");
                    }
            }
        } else {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
        }
    }
}
#method_after
private void linkAndResolvePartialResolvedStack() throws DataModelException {
    while (getPartialResolvedStack().size() != 0) {
        // Current node to resolve, it can be a YANG type or YANG uses.
        T entityToResolve = getCurrentEntityToResolveFromStack();
        // Check if linking is already done
        if (entityToResolve instanceof Resolvable) {
            Resolvable resolvable = (Resolvable) entityToResolve;
            switch(resolvable.getResolvableStatus()) {
                case RESOLVED:
                    {
                        /*
                         * If the entity is already resolved in the stack, then pop
                         * it and continue with the remaining stack elements to
                         * resolve
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case LINKED:
                    {
                        /*
                         * If the top of the stack is already linked then resolve
                         * the references and pop the entity and continue with
                         * remaining stack elements to resolve.
                         */
                        resolveTopOfStack(INTRA_FILE);
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTRA_FILE_RESOLVED:
                    {
                        /*
                         * Pop the top of the stack.
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case UNRESOLVED:
                    {
                        linkTopOfStackReferenceUpdateStack();
                        if (resolvable.getResolvableStatus() == UNRESOLVED) {
                            // If current entity is still not resolved, then
                            // linking/resolution has failed.
                            String errorInfo;
                            if (resolvable instanceof YangType) {
                                errorInfo = TYPEDEF_LINKER_ERROR;
                            } else if (resolvable instanceof YangUses) {
                                errorInfo = GROUPING_LINKER_ERROR;
                            } else {
                                errorInfo = FEATURE_LINKER_ERROR;
                            }
                            DataModelException dataModelException = new DataModelException(errorInfo);
                            dataModelException.setLine(getLineNumber());
                            dataModelException.setCharPosition(getCharPosition());
                            throw dataModelException;
                        }
                        break;
                    }
                default:
                    {
                        throw new DataModelException("Data Model Exception: Unsupported, linker state");
                    }
            }
        } else {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
        }
    }
}
#end_block

#method_before
private void resolveTopOfStack(YangLinkingPhase linkingPhase) throws DataModelException {
    ((Resolvable) getCurrentEntityToResolveFromStack()).resolve();
    if (((Resolvable) getCurrentEntityToResolveFromStack()).getResolvableStatus() != INTRA_FILE_RESOLVED) {
        // Sets the resolution status in inside the type/uses.
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(RESOLVED);
    }
}
#method_after
private void resolveTopOfStack(YangLinkingPhase linkingPhase) throws DataModelException {
    ((Resolvable) getCurrentEntityToResolveFromStack()).resolve();
    if (((Resolvable) getCurrentEntityToResolveFromStack()).getResolvableStatus() != INTRA_FILE_RESOLVED && ((Resolvable) getCurrentEntityToResolveFromStack()).getResolvableStatus() != UNDEFINED) {
        // Sets the resolution status in inside the type/uses/if-feature.
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(RESOLVED);
    }
}
#end_block

#method_before
private void linkTopOfStackReferenceUpdateStack() throws DataModelException {
    /*
         * Check if self file reference is there, this will not check for the
         * scenario when prefix is not present and type/uses is present in
         * sub-module from include list.
         */
    if (!isCandidateForSelfFileReference()) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTRA_FILE_RESOLVED);
        return;
    }
    /**
     * Try to resolve the top of the stack and update partial resolved stack
     * if there is recursive references
     */
    YangNode potentialAncestorWithReferredNode = getPartialResolvedStack().peek().getHolderOfEntityToResolve();
    /**
     * Traverse up in the ancestor tree to check if the referred node is
     * defined
     */
    while (potentialAncestorWithReferredNode != null) {
        /**
         * Check for the referred node defined in a ancestor scope
         */
        YangNode potentialReferredNode = potentialAncestorWithReferredNode.getChild();
        if (isReferredNodeInSiblingListProcessed(potentialReferredNode)) {
            return;
        }
        potentialAncestorWithReferredNode = potentialAncestorWithReferredNode.getParent();
    }
    /*
         * In case prefix is not present it's a candidate for inter-file
         * resolution via include list.
         */
    if (getRefPrefix() == null) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTRA_FILE_RESOLVED);
    }
}
#method_after
private void linkTopOfStackReferenceUpdateStack() throws DataModelException {
    /*
         * Check if self file reference is there, this will not check for the
         * scenario when prefix is not present and type/uses is present in
         * sub-module from include list.
         */
    if (!isCandidateForSelfFileReference()) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTRA_FILE_RESOLVED);
        return;
    }
    /**
     * Try to resolve the top of the stack and update partial resolved stack
     * if there is recursive references
     */
    YangNode potentialAncestorWithReferredNode = getPartialResolvedStack().peek().getHolderOfEntityToResolve();
    if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
        resolveSelfFileLinkingForIfFeature(potentialAncestorWithReferredNode);
        return;
    } else {
        /**
         * Traverse up in the ancestor tree to check if the referred node is
         * defined
         */
        while (potentialAncestorWithReferredNode != null) {
            /**
             * Check for the referred node defined in a ancestor scope
             */
            YangNode potentialReferredNode = potentialAncestorWithReferredNode.getChild();
            if (isReferredNodeInSiblingListProcessed(potentialReferredNode)) {
                return;
            }
            potentialAncestorWithReferredNode = potentialAncestorWithReferredNode.getParent();
        }
    }
    /*
         * In case prefix is not present it's a candidate for inter-file
         * resolution via include list.
         */
    if (getRefPrefix() == null) {
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTRA_FILE_RESOLVED);
    }
}
#end_block

#method_before
private boolean isReferredNode(YangNode potentialReferredNode) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        if (potentialReferredNode instanceof YangTypeDef) {
            /*
                 * Check if name of node name matches with the entity being
                 * resolved
                 */
            return isNodeNameSameAsResolutionInfoName(potentialReferredNode);
        }
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        if (potentialReferredNode instanceof YangGrouping) {
            /*
                 * Check if name of node name matches with the entity being
                 * resolved
                 */
            return isNodeNameSameAsResolutionInfoName(potentialReferredNode);
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    return false;
}
#method_after
private boolean isReferredNode(YangNode potentialReferredNode) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        if (potentialReferredNode instanceof YangTypeDef) {
            /*
                 * Check if name of node name matches with the entity being
                 * resolved
                 */
            return isNodeNameSameAsResolutionInfoName(potentialReferredNode);
        }
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        if (potentialReferredNode instanceof YangGrouping) {
            /*
                 * Check if name of node name matches with the entity being
                 * resolved
                 */
            return isNodeNameSameAsResolutionInfoName(potentialReferredNode);
        }
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
        if (potentialReferredNode instanceof YangFeatureHolder) {
            /*
                 * Check if name of node name matches with the entity being
                 * resolved
                 */
            return isNodeNameSameAsResolutionInfoName(potentialReferredNode);
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    return false;
}
#end_block

#method_before
/**
 * Checks if node name is same as name in resolution info, i.e. name of
 * typedef/grouping is same as name of type/uses.
 *
 * @param node typedef/grouping node
 * @return true if node name is same as name in resolution info, otherwise
 * false
 * @throws DataModelException a violation of data model rules
 */
private boolean isNodeNameSameAsResolutionInfoName(YangNode node) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        if (node.getName().contentEquals(((YangType<?>) getCurrentEntityToResolveFromStack()).getDataTypeName())) {
            return true;
        }
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        if (node.getName().contentEquals(((YangUses) getCurrentEntityToResolveFromStack()).getName())) {
            return true;
        }
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    return false;
}
#method_after
/**
 * Checks if node name is same as name in resolution info, i.e. name of
 * typedef/grouping is same as name of type/uses.
 *
 * @param node typedef/grouping node
 * @return true if node name is same as name in resolution info, otherwise
 * false
 * @throws DataModelException a violation of data model rules
 */
private boolean isNodeNameSameAsResolutionInfoName(YangNode node) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        if (node.getName().contentEquals(((YangType<?>) getCurrentEntityToResolveFromStack()).getDataTypeName())) {
            return true;
        }
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        if (node.getName().contentEquals(((YangUses) getCurrentEntityToResolveFromStack()).getName())) {
            return true;
        }
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
        return isFeatureDefinedInNode(node);
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    return false;
}
#end_block

#method_before
private void addReferredEntityLink(YangNode referredNode, ResolvableStatus linkedStatus) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) ((YangType<?>) getCurrentEntityToResolveFromStack()).getDataTypeExtendedInfo();
        derivedInfo.setReferredTypeDef((YangTypeDef) referredNode);
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        ((YangUses) getCurrentEntityToResolveFromStack()).setRefGroup((YangGrouping) referredNode);
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    // Sets the resolution status in inside the type/uses.
    ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(linkedStatus);
}
#method_after
private void addReferredEntityLink(YangNode referredNode, ResolvableStatus linkedStatus) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) ((YangType<?>) getCurrentEntityToResolveFromStack()).getDataTypeExtendedInfo();
        derivedInfo.setReferredTypeDef((YangTypeDef) referredNode);
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        ((YangUses) getCurrentEntityToResolveFromStack()).setRefGroup((YangGrouping) referredNode);
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
    // do nothing , referred node is already set
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    // Sets the resolution status in inside the type/uses.
    ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(linkedStatus);
}
#end_block

#method_before
private void addUnresolvedRecursiveReferenceToStack(YangNode referredNode) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        /*
             * Checks if typedef type is derived
             */
        if (((YangTypeDef) referredNode).getTypeDefBaseType().getDataType() == YangDataTypes.DERIVED) {
            YangEntityToResolveInfoImpl<YangType<?>> unResolvedEntityInfo = new YangEntityToResolveInfoImpl<>();
            unResolvedEntityInfo.setEntityToResolve(((YangTypeDef) referredNode).getTypeDefBaseType());
            unResolvedEntityInfo.setHolderOfEntityToResolve(referredNode);
            addInPartialResolvedStack((YangEntityToResolveInfoImpl<T>) unResolvedEntityInfo);
        }
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        /*
             * Search if the grouping has any un resolved uses child, if so
             * return true, else return false.
             */
        addUnResolvedUsesToStack(referredNode);
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
}
#method_after
private void addUnresolvedRecursiveReferenceToStack(YangNode referredNode) throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        /*
             * Checks if typedef type is derived
             */
        if (((YangTypeDef) referredNode).getTypeDefBaseType().getDataType() == YangDataTypes.DERIVED) {
            YangEntityToResolveInfoImpl<YangType<?>> unResolvedEntityInfo = new YangEntityToResolveInfoImpl<>();
            unResolvedEntityInfo.setEntityToResolve(((YangTypeDef) referredNode).getTypeDefBaseType());
            unResolvedEntityInfo.setHolderOfEntityToResolve(referredNode);
            addInPartialResolvedStack((YangEntityToResolveInfoImpl<T>) unResolvedEntityInfo);
        }
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        /*
             * Search if the grouping has any un resolved uses child, if so
             * return true, else return false.
             */
        addUnResolvedUsesToStack(referredNode);
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
        addUnResolvedIfFeatureToStack(referredNode);
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
}
#end_block

#method_before
private String getRefPrefix() throws DataModelException {
    String refPrefix;
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        refPrefix = ((YangType<?>) getCurrentEntityToResolveFromStack()).getPrefix();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        refPrefix = ((YangUses) getCurrentEntityToResolveFromStack()).getPrefix();
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    return refPrefix;
}
#method_after
private String getRefPrefix() throws DataModelException {
    String refPrefix;
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        refPrefix = ((YangType<?>) getCurrentEntityToResolveFromStack()).getPrefix();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        refPrefix = ((YangUses) getCurrentEntityToResolveFromStack()).getPrefix();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
        refPrefix = ((YangIfFeature) getCurrentEntityToResolveFromStack()).getPrefix();
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
    return refPrefix;
}
#end_block

#method_before
private void linkInterFileAndResolve() throws DataModelException {
    while (getPartialResolvedStack().size() != 0) {
        // Current node to resolve, it can be a YANG type or YANG uses.
        T entityToResolve = getCurrentEntityToResolveFromStack();
        // Check if linking is already done
        if (entityToResolve instanceof Resolvable) {
            Resolvable resolvable = (Resolvable) entityToResolve;
            switch(resolvable.getResolvableStatus()) {
                case RESOLVED:
                    {
                        /*
                     * If the entity is already resolved in the stack, then pop
                     * it and continue with the remaining stack elements to
                     * resolve
                     */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTER_FILE_LINKED:
                    {
                        /*
                     * If the top of the stack is already linked then resolve
                     * the references and pop the entity and continue with
                     * remaining stack elements to resolve
                     */
                        resolveTopOfStack(INTER_FILE);
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTRA_FILE_RESOLVED:
                    {
                        /*
                     * If the top of the stack is intra file resolved then check
                     * if top of stack is linked, if not link it using
                     * import/include list and push the linked referred entity
                     * to the stack, otherwise only push it to the stack.
                     */
                        linkInterFileTopOfStackRefUpdateStack();
                        break;
                    }
                default:
                    {
                        throw new DataModelException("Data Model Exception: Unsupported, linker state");
                    }
            }
        } else {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
        }
    }
}
#method_after
private void linkInterFileAndResolve() throws DataModelException {
    while (getPartialResolvedStack().size() != 0) {
        // Current node to resolve, it can be a YANG type or YANG uses.
        T entityToResolve = getCurrentEntityToResolveFromStack();
        // Check if linking is already done
        if (entityToResolve instanceof Resolvable) {
            Resolvable resolvable = (Resolvable) entityToResolve;
            switch(resolvable.getResolvableStatus()) {
                case RESOLVED:
                    {
                        /*
                         * If the entity is already resolved in the stack, then pop
                         * it and continue with the remaining stack elements to
                         * resolve
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTER_FILE_LINKED:
                    {
                        /*
                         * If the top of the stack is already linked then resolve
                         * the references and pop the entity and continue with
                         * remaining stack elements to resolve
                         */
                        resolveTopOfStack(INTER_FILE);
                        getPartialResolvedStack().pop();
                        break;
                    }
                case INTRA_FILE_RESOLVED:
                    {
                        /*
                         * If the top of the stack is intra file resolved then check
                         * if top of stack is linked, if not link it using
                         * import/include list and push the linked referred entity
                         * to the stack, otherwise only push it to the stack.
                         */
                        linkInterFileTopOfStackRefUpdateStack();
                        break;
                    }
                case UNDEFINED:
                    {
                        /*
                         * In case of if-feature resolution, if referred "feature" is not
                         * defined then the resolvable status will be undefined.
                         */
                        getPartialResolvedStack().pop();
                        break;
                    }
                default:
                    {
                        throw new DataModelException("Data Model Exception: Unsupported, linker state");
                    }
            }
        } else {
            throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
        }
    }
}
#end_block

#method_before
private void linkInterFileTopOfStackRefUpdateStack() throws DataModelException {
    /*
         * Obtain the referred node of top of stack entity under resolution
         */
    T referredNode = getRefNode();
    /*
         * Check for null for scenario when it's not linked and inter-file
         * linking is required.
         */
    if (referredNode == null) {
        /*
             * Check if prefix is null or not, to identify whether to search in
             * import list or include list.
             */
        if (getRefPrefix() != null && !getRefPrefix().contentEquals(getCurReferenceResolver().getPrefix())) {
            if (resolveWithImport()) {
                return;
            }
        } else {
            if (resolveWithInclude()) {
                return;
            }
        }
        // Exception when referred typedef/grouping is not found.
        DataModelException dataModelException = new DataModelException("YANG file error: Referred " + "typedef/grouping for a given type/uses can't be found.");
        dataModelException.setLine(getLineNumber());
        dataModelException.setCharPosition(getCharPosition());
        throw dataModelException;
    } else {
        /*
             * If referred node is already linked, then just change the status
             * and push to the stack.
             */
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTER_FILE_LINKED);
        addUnresolvedRecursiveReferenceToStack((YangNode) referredNode);
    }
}
#method_after
private void linkInterFileTopOfStackRefUpdateStack() throws DataModelException {
    /*
         * Obtain the referred node of top of stack entity under resolution
         */
    T referredNode = getRefNode();
    /*
         * Check for null for scenario when it's not linked and inter-file
         * linking is required.
         */
    if (referredNode == null) {
        /*
             * Check if prefix is null or not, to identify whether to search in
             * import list or include list.
             */
        if (getRefPrefix() != null && !getRefPrefix().contentEquals(getCurReferenceResolver().getPrefix())) {
            if (resolveWithImport()) {
                return;
            }
        } else {
            if (resolveWithInclude()) {
                return;
            }
        }
        if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
            ((YangIfFeature) getCurrentEntityToResolveFromStack()).setResolvableStatus(UNDEFINED);
            return;
        }
        // Exception when referred typedef/grouping is not found.
        DataModelException dataModelException = new DataModelException("YANG file error: Referred " + "typedef/grouping for a given type/uses can't be found.");
        dataModelException.setLine(getLineNumber());
        dataModelException.setCharPosition(getCharPosition());
        throw dataModelException;
    } else {
        /*
             * If referred node is already linked, then just change the status
             * and push to the stack.
             */
        ((Resolvable) getCurrentEntityToResolveFromStack()).setResolvableStatus(INTER_FILE_LINKED);
        addUnresolvedRecursiveReferenceToStack((YangNode) referredNode);
    }
}
#end_block

#method_before
private boolean resolveWithInclude() throws DataModelException {
    /*
         * Run through all the nodes in include list and search for referred
         * typedef/grouping at the root level.
         */
    for (YangInclude yangInclude : getCurReferenceResolver().getIncludeList()) {
        YangNode linkedNode = null;
        if (getCurrentEntityToResolveFromStack() instanceof YangType) {
            linkedNode = findRefTypedef(yangInclude.getIncludedNode());
        } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
            linkedNode = findRefGrouping(yangInclude.getIncludedNode());
        }
        if (linkedNode != null) {
            // Add the link to external entity.
            addReferredEntityLink(linkedNode, INTER_FILE_LINKED);
            /*
                 * Update the current reference resolver to external
                 * module/sub-module containing the referred typedef/grouping.
                 */
            setCurReferenceResolver((YangReferenceResolver) yangInclude.getIncludedNode());
            // Add the type/uses of referred typedef/grouping to the stack.
            addUnresolvedRecursiveReferenceToStack(linkedNode);
            return true;
        }
    }
    // If referred node can't be found return false.
    return false;
}
#method_after
private boolean resolveWithInclude() throws DataModelException {
    /*
         * Run through all the nodes in include list and search for referred
         * typedef/grouping at the root level.
         */
    for (YangInclude yangInclude : getCurReferenceResolver().getIncludeList()) {
        YangNode linkedNode = null;
        if (getCurrentEntityToResolveFromStack() instanceof YangType) {
            linkedNode = findRefTypedef(yangInclude.getIncludedNode());
        } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
            linkedNode = findRefGrouping(yangInclude.getIncludedNode());
        } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
            linkedNode = findRefFeature(yangInclude.getIncludedNode());
        }
        if (linkedNode != null) {
            // Add the link to external entity.
            addReferredEntityLink(linkedNode, INTER_FILE_LINKED);
            /*
                 * Update the current reference resolver to external
                 * module/sub-module containing the referred typedef/grouping.
                 */
            setCurReferenceResolver((YangReferenceResolver) yangInclude.getIncludedNode());
            // Add the type/uses of referred typedef/grouping to the stack.
            addUnresolvedRecursiveReferenceToStack(linkedNode);
            return true;
        }
    }
    // If referred node can't be found return false.
    return false;
}
#end_block

#method_before
private boolean resolveWithImport() throws DataModelException {
    /*
         * Run through import list to find the referred typedef/grouping.
         */
    for (YangImport yangImport : getCurReferenceResolver().getImportList()) {
        /*
             * Match the prefix attached to entity under resolution with the
             * imported/included module/sub-module's prefix. If found, search
             * for the referred typedef/grouping at the root level.
             */
        if (yangImport.getPrefixId().contentEquals(getRefPrefix())) {
            YangNode linkedNode = null;
            if (getCurrentEntityToResolveFromStack() instanceof YangType) {
                linkedNode = findRefTypedef(yangImport.getImportedNode());
            } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
                linkedNode = findRefGrouping(yangImport.getImportedNode());
            }
            if (linkedNode != null) {
                // Add the link to external entity.
                addReferredEntityLink(linkedNode, INTER_FILE_LINKED);
                /*
                     * Update the current reference resolver to external
                     * module/sub-module containing the referred
                     * typedef/grouping.
                     */
                setCurReferenceResolver((YangReferenceResolver) yangImport.getImportedNode());
                // Add the type/uses of referred typedef/grouping to the
                // stack.
                addUnresolvedRecursiveReferenceToStack(linkedNode);
                return true;
            }
            /*
                 * If referred node can't be found at root level break for loop,
                 * and return false.
                 */
            break;
        }
    }
    // If referred node can't be found return false.
    return false;
}
#method_after
private boolean resolveWithImport() throws DataModelException {
    /*
         * Run through import list to find the referred typedef/grouping.
         */
    for (YangImport yangImport : getCurReferenceResolver().getImportList()) {
        /*
             * Match the prefix attached to entity under resolution with the
             * imported/included module/sub-module's prefix. If found, search
             * for the referred typedef/grouping at the root level.
             */
        if (yangImport.getPrefixId().contentEquals(getRefPrefix())) {
            YangNode linkedNode = null;
            if (getCurrentEntityToResolveFromStack() instanceof YangType) {
                linkedNode = findRefTypedef(yangImport.getImportedNode());
            } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
                linkedNode = findRefGrouping(yangImport.getImportedNode());
            } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
                linkedNode = findRefFeature(yangImport.getImportedNode());
            }
            if (linkedNode != null) {
                // Add the link to external entity.
                addReferredEntityLink(linkedNode, INTER_FILE_LINKED);
                /*
                     * Update the current reference resolver to external
                     * module/sub-module containing the referred
                     * typedef/grouping.
                     */
                setCurReferenceResolver((YangReferenceResolver) yangImport.getImportedNode());
                // Add the type/uses of referred typedef/grouping to the
                // stack.
                addUnresolvedRecursiveReferenceToStack(linkedNode);
                return true;
            }
            /*
                 * If referred node can't be found at root level break for loop,
                 * and return false.
                 */
            break;
        }
    }
    // If referred node can't be found return false.
    return false;
}
#end_block

#method_before
private T getRefNode() throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) ((YangType<?>) getCurrentEntityToResolveFromStack()).getDataTypeExtendedInfo();
        return (T) derivedInfo.getReferredTypeDef();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        return (T) ((YangUses) getCurrentEntityToResolveFromStack()).getRefGroup();
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
}
#method_after
private T getRefNode() throws DataModelException {
    if (getCurrentEntityToResolveFromStack() instanceof YangType) {
        YangDerivedInfo<?> derivedInfo = (YangDerivedInfo<?>) ((YangType<?>) getCurrentEntityToResolveFromStack()).getDataTypeExtendedInfo();
        return (T) derivedInfo.getReferredTypeDef();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangUses) {
        return (T) ((YangUses) getCurrentEntityToResolveFromStack()).getRefGroup();
    } else if (getCurrentEntityToResolveFromStack() instanceof YangIfFeature) {
        return (T) ((YangIfFeature) getCurrentEntityToResolveFromStack()).getReferredFeatureHolder();
    } else {
        throw new DataModelException("Data Model Exception: Entity to resolved is other than type/uses");
    }
}
#end_block

#method_before
public boolean isValidValue(String value) {
    switch(getDataType()) {
        case INT8:
        case INT16:
        case INT32:
        case INT64:
        case UINT8:
        case UINT16:
        case UINT32:
        case UINT64:
            {
                isValidValueForRangeRestrictedType(value, getDataType());
            }
        case DECIMAL64:
            {
            // TODO
            }
        case STRING:
            {
            // TODO implement in string restriction similar to range restriction
            }
        case ENUMERATION:
            {
            // TODO validate using list of YANG enum of enumeration class in extended info.
            }
        case BINARY:
            {
            // TODO validate based on extended info
            }
        case BITS:
            {
            // TODO validate based on extended info
            }
        case BOOLEAN:
            {
            // TODO true or false
            }
        case LEAFREF:
            {
            // TODO validate based on extended info
            }
        case IDENTITYREF:
            {
            // TODO TBD
            }
        case EMPTY:
            {
            // TODO true or false
            }
        case UNION:
            {
            // TODO validate based on extended info
            }
        case INSTANCE_IDENTIFIER:
            {
            // TODO TBD
            }
        case DERIVED:
            {
                if (isOfRangeRestrictedType(((YangDerivedInfo) getDataTypeExtendedInfo()).getEffectiveBuiltInType())) {
                    try {
                        if (((YangDerivedInfo) getDataTypeExtendedInfo()).getResolvedExtendedInfo() == null) {
                            getDataObjectFromString(value, ((YangDerivedInfo) getDataTypeExtendedInfo()).getEffectiveBuiltInType());
                            return true;
                        } else {
                            return ((YangRangeRestriction) ((YangDerivedInfo) getDataTypeExtendedInfo()).getResolvedExtendedInfo()).isValidValueString(value);
                        }
                    } catch (Exception e) {
                        return false;
                    }
                } else {
                // TODO
                }
            }
        default:
            {
            // TODO
            }
    }
    return true;
}
#method_after
public boolean isValidValue(String value) {
    switch(getDataType()) {
        case INT8:
        case INT16:
        case INT32:
        case INT64:
        case UINT8:
        case UINT16:
        case UINT32:
        case UINT64:
            {
                isValidValueForRangeRestrictedType(value);
            }
        case DECIMAL64:
            {
            // TODO
            }
        case STRING:
            {
            // TODO implement in string restriction similar to range restriction
            }
        case ENUMERATION:
            {
            // TODO validate using list of YANG enum of enumeration class in extended info.
            }
        case BINARY:
            {
            // TODO validate based on extended info
            }
        case BITS:
            {
            // TODO validate based on extended info
            }
        case BOOLEAN:
            {
            // TODO true or false
            }
        case LEAFREF:
            {
            // TODO validate based on extended info
            }
        case IDENTITYREF:
            {
            // TODO TBD
            }
        case EMPTY:
            {
            // TODO true or false
            }
        case UNION:
            {
            // TODO validate based on extended info
            }
        case INSTANCE_IDENTIFIER:
            {
            // TODO TBD
            }
        case DERIVED:
            {
                if (isOfRangeRestrictedType(((YangDerivedInfo) getDataTypeExtendedInfo()).getEffectiveBuiltInType())) {
                    try {
                        if (((YangDerivedInfo) getDataTypeExtendedInfo()).getResolvedExtendedInfo() == null) {
                            getDataObjectFromString(value, ((YangDerivedInfo) getDataTypeExtendedInfo()).getEffectiveBuiltInType());
                            return true;
                        } else {
                            return ((YangRangeRestriction) ((YangDerivedInfo) getDataTypeExtendedInfo()).getResolvedExtendedInfo()).isValidValueString(value);
                        }
                    } catch (Exception e) {
                        return false;
                    }
                } else {
                // TODO
                }
            }
        default:
            {
            // TODO
            }
    }
    return true;
}
#end_block

#method_before
private boolean isValidValueForRangeRestrictedType(String value, YangDataTypes yangDataTypes) {
    try {
        if (getDataTypeExtendedInfo() == null) {
            getDataObjectFromString(value, INT8);
            return true;
        } else {
            return ((YangRangeRestriction) getDataTypeExtendedInfo()).isValidValueString(value);
        }
    } catch (Exception e) {
        return false;
    }
}
#method_after
private boolean isValidValueForRangeRestrictedType(String value) {
    try {
        if (getDataTypeExtendedInfo() == null) {
            getDataObjectFromString(value, getDataType());
            return true;
        } else {
            return ((YangRangeRestriction) getDataTypeExtendedInfo()).isValidValueString(value);
        }
    } catch (Exception e) {
        return false;
    }
}
#end_block

#method_before
private Ethernet processDhcpPacketFrmClient(Ethernet ethernetPacket, String circuitId, byte incomingPacketType) {
    // Ethernet Frame.
    Ethernet ethReply = new Ethernet();
    ethReply.setSourceMACAddress(ethernetPacket.getSourceMAC());
    ethReply.setDestinationMACAddress(ethernetPacket.getDestinationMAC());
    ethReply.setEtherType(Ethernet.TYPE_IPV4);
    ethReply.setVlanID(ethernetPacket.getVlanID());
    // IP Packet
    IPv4 ipv4Packet = (IPv4) ethernetPacket.getPayload();
    IPv4 ipv4Reply = new IPv4();
    ipv4Reply.setSourceAddress(discoverIp.toInt());
    ipv4Reply.setDestinationAddress(discoverIp.toInt());
    ipv4Reply.setTtl(packetTTL);
    // UDP Datagram.
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    UDP udpReply = new UDP();
    udpReply.setSourcePort((byte) UDP.DHCP_CLIENT_PORT);
    udpReply.setDestinationPort((byte) UDP.DHCP_SERVER_PORT);
    // DHCP Payload.
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    DHCP dhcpReply = new DHCP();
    dhcpReply.setOpCode(DHCP.OPCODE_REQUEST);
    dhcpReply.setFlags(dhcpPacket.getFlags());
    dhcpReply.setGatewayIPAddress(dhcpPacket.getGatewayIPAddress());
    dhcpReply.setClientHardwareAddress(dhcpPacket.getClientHardwareAddress());
    dhcpReply.setYourIPAddress(dhcpPacket.getYourIPAddress());
    dhcpReply.setTransactionId(dhcpPacket.getTransactionId());
    dhcpReply.setHardwareType(DHCP.HWTYPE_ETHERNET);
    dhcpReply.setHardwareAddressLength((byte) 6);
    dhcpReply.setServerIPAddress(dhcpPacket.getServerIPAddress());
    // DHCP Options.
    DHCPOption option = new DHCPOption();
    List<DHCPOption> optionList = new ArrayList<>();
    // DHCP Message Type.
    option.setCode(OptionCode_MessageType.getValue());
    option.setLength((byte) 1);
    byte[] optionData = { incomingPacketType };
    option.setData(optionData);
    optionList.add(option);
    byte[] dhcpServerIp = null;
    byte[] requestedIp = null;
    for (DHCPOption optionfrmClient : dhcpPacket.getOptions()) {
        if (optionfrmClient.getCode() == OptionCode_DHCPServerIp.getValue()) {
            dhcpServerIp = optionfrmClient.getData();
        }
        if (optionfrmClient.getCode() == OptionCode_RequestedIP.getValue()) {
            requestedIp = optionfrmClient.getData();
        }
    }
    // DHCP Server Identifier and Requested Ip address for DHCP Request
    if (incomingPacketType == DHCPPacketType.DHCPREQUEST.getValue()) {
        if (dhcpServerIp != null) {
            option = new DHCPOption();
            option.setCode(OptionCode_DHCPServerIp.getValue());
            option.setLength((byte) 4);
            option.setData(dhcpServerIp);
            optionList.add(option);
        }
        if (requestedIp != null) {
            option = new DHCPOption();
            option.setCode(OptionCode_RequestedIP.getValue());
            option.setLength((byte) 4);
            option.setData(requestedIp);
            optionList.add(option);
        }
    }
    // Dhcp SubOption as CircuitID
    option = new DHCPOption();
    option.setCode(OptionCode_CircuitID.getValue());
    option.setLength((byte) 10);
    // start object for suboption circuit id.
    String[] actualDpId = circuitId.split(":", 2);
    DHCPOption subOption = new DHCPOption();
    subOption.setCode((byte) 1);
    byte[] subOptionData = HexString.fromHexString(actualDpId[1], null);
    subOption.setData(subOptionData);
    subOption.setLength((byte) 8);
    // end object for suboption circuit id.
    // converting suboption to byte array
    byte[] data = new byte[10];
    ByteBuffer bb = ByteBuffer.wrap(data);
    DHCP.dhcpOptionToByteArray(subOption, bb);
    option.setData(data);
    optionList.add(option);
    // End Option.
    DHCPOption endOption = new DHCPOption();
    endOption.setCode(DHCP.DHCPOptionCode.OptionCode_END.getValue());
    endOption.setLength((byte) 1);
    optionList.add(endOption);
    dhcpReply.setOptions(optionList);
    udpReply.setPayload(dhcpReply);
    ipv4Reply.setPayload(udpReply);
    ethReply.setPayload(ipv4Reply);
    return ethReply;
}
#method_after
private Ethernet processDhcpPacketFrmClient(Ethernet ethernetPacket, String circuitId, byte incomingPacketType) {
    // get dhcp header.
    Ethernet etherReply = (Ethernet) ethernetPacket.clone();
    IPv4 ipv4Packet = (IPv4) etherReply.getPayload();
    UDP udpPacket = (UDP) ipv4Packet.getPayload();
    DHCP dhcpPacket = (DHCP) udpPacket.getPayload();
    // DHCP Options.
    List<DHCPOption> optionList = dhcpPacket.getOptions();
    // Dhcp SubOption as CircuitID
    DHCPOption option = new DHCPOption();
    option.setCode(OptionCode_CircuitID.getValue());
    option.setLength((byte) 10);
    // start object for suboption circuit id.
    String[] actualDpId = circuitId.split(":", 2);
    DHCPOption subOption = new DHCPOption();
    subOption.setCode((byte) 1);
    byte[] subOptionData = HexString.fromHexString(actualDpId[1], null);
    subOption.setData(subOptionData);
    subOption.setLength((byte) 8);
    // end object for suboption circuit id.
    // converting suboption to byte array
    byte[] data = new byte[10];
    ByteBuffer bb = ByteBuffer.wrap(data);
    DHCP.dhcpOptionToByteArray(subOption, bb);
    option.setData(data);
    optionList.add(optionList.size() - 1, option);
    dhcpPacket.setOptions(optionList);
    udpPacket.setPayload(dhcpPacket);
    ipv4Packet.setPayload(udpPacket);
    etherReply.setPayload(ipv4Packet);
    return etherReply;
}
#end_block

#method_before
@Activate
public void activate() {
    localNodeId = clusterService.getLocalNode().id();
    deviceDescriptions = storageService.<DeviceKey, DeviceDescription>eventuallyConsistentMapBuilder().withName("onos-device-descriptions").withSerializer(SERIALIZER_BUILDER).withTimestampProvider((k, v) -> {
        try {
            return deviceClockService.getTimestamp(k.deviceId());
        } catch (IllegalStateException e) {
            return null;
        }
    }).build();
    portDescriptions = storageService.<PortKey, PortDescription>eventuallyConsistentMapBuilder().withName("onos-port-descriptions").withSerializer(SERIALIZER_BUILDER).withTimestampProvider((k, v) -> {
        try {
            return deviceClockService.getTimestamp(k.deviceId());
        } catch (IllegalStateException e) {
            return null;
        }
    }).build();
    devicePortStats = storageService.<DeviceId, Map<PortNumber, PortStatistics>>eventuallyConsistentMapBuilder().withName("onos-port-stats").withSerializer(SERIALIZER_BUILDER).withAntiEntropyPeriod(5, TimeUnit.SECONDS).withTimestampProvider((k, v) -> new WallClockTimestamp()).withTombstonesDisabled().build();
    devicePortDeltaStats = storageService.<DeviceId, Map<PortNumber, PortStatistics>>eventuallyConsistentMapBuilder().withName("onos-port-stats-delta").withSerializer(SERIALIZER_BUILDER).withAntiEntropyPeriod(5, TimeUnit.SECONDS).withTimestampProvider((k, v) -> new WallClockTimestamp()).withTombstonesDisabled().build();
    clusterCommunicator.addSubscriber(DEVICE_INJECTED, SERIALIZER::decode, this::injectDevice, SERIALIZER::encode, SharedExecutors.getPoolThreadExecutor());
    clusterCommunicator.addSubscriber(PORT_INJECTED, SERIALIZER::decode, this::injectPort, SERIALIZER::encode, SharedExecutors.getPoolThreadExecutor());
    availableDevices = storageService.<DeviceId>setBuilder().withName("onos-online-devices").withSerializer(Serializer.using(KryoNamespaces.API)).withPartitionsDisabled().withRelaxedReadConsistency().build().asDistributedSet();
    deviceDescriptions.addListener(deviceUpdateListener);
    portDescriptions.addListener(portUpdateListener);
    devicePortStats.addListener(portStatsListener);
    availableDevices.addListener(deviceStatusTracker);
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    localNodeId = clusterService.getLocalNode().id();
    deviceDescriptions = storageService.<DeviceKey, DeviceDescription>eventuallyConsistentMapBuilder().withName("onos-device-descriptions").withSerializer(SERIALIZER_BUILDER).withTimestampProvider((k, v) -> {
        try {
            return deviceClockService.getTimestamp(k.deviceId());
        } catch (IllegalStateException e) {
            return null;
        }
    }).build();
    portDescriptions = storageService.<PortKey, PortDescription>eventuallyConsistentMapBuilder().withName("onos-port-descriptions").withSerializer(SERIALIZER_BUILDER).withTimestampProvider((k, v) -> {
        try {
            return deviceClockService.getTimestamp(k.deviceId());
        } catch (IllegalStateException e) {
            return null;
        }
    }).build();
    devicePortStats = storageService.<DeviceId, Map<PortNumber, PortStatistics>>eventuallyConsistentMapBuilder().withName("onos-port-stats").withSerializer(SERIALIZER_BUILDER).withAntiEntropyPeriod(5, TimeUnit.SECONDS).withTimestampProvider((k, v) -> new WallClockTimestamp()).withTombstonesDisabled().build();
    devicePortDeltaStats = storageService.<DeviceId, Map<PortNumber, PortStatistics>>eventuallyConsistentMapBuilder().withName("onos-port-stats-delta").withSerializer(SERIALIZER_BUILDER).withAntiEntropyPeriod(5, TimeUnit.SECONDS).withTimestampProvider((k, v) -> new WallClockTimestamp()).withTombstonesDisabled().build();
    clusterCommunicator.addSubscriber(DEVICE_INJECTED, SERIALIZER::decode, this::injectDevice, SERIALIZER::encode, SharedExecutors.getPoolThreadExecutor());
    clusterCommunicator.addSubscriber(PORT_INJECTED, SERIALIZER::decode, this::injectPort, SERIALIZER::encode, SharedExecutors.getPoolThreadExecutor());
    availableDevices = storageService.<DeviceId>setBuilder().withName("onos-online-devices").withSerializer(Serializer.using(KryoNamespaces.API)).withRelaxedReadConsistency().build().asDistributedSet();
    deviceDescriptions.addListener(deviceUpdateListener);
    portDescriptions.addListener(portUpdateListener);
    devicePortStats.addListener(portStatsListener);
    availableDevices.addListener(deviceStatusTracker);
    log.info("Started");
}
#end_block

#method_before
public boolean markOnline(DeviceId deviceId) {
    return availableDevices.add(deviceId);
}
#method_after
public boolean markOnline(DeviceId deviceId) {
    if (devices.containsKey(deviceId)) {
        return availableDevices.add(deviceId);
    }
    log.warn("Device {} does not exist in store", deviceId);
    return false;
}
#end_block

#method_before
private void mastershipCheck() {
    log.debug("Checking mastership");
    for (Device device : getDevices()) {
        final DeviceId deviceId = device.id();
        log.trace("Checking device {}", deviceId);
        if (!isReachable(deviceId)) {
            continue;
        }
        if (mastershipService.getLocalRole(deviceId) != NONE) {
            continue;
        }
        log.info("{} is reachable but did not have a valid role, reasserting", deviceId);
        // isReachable but was not MASTER or STANDBY, get a role and apply
        // Note: NONE triggers request to MastershipService
        reassertRole(deviceId, NONE);
    }
}
#method_after
private void mastershipCheck() {
    log.debug("Checking mastership");
    for (Device device : getDevices()) {
        final DeviceId deviceId = device.id();
        log.trace("Checking device {}", deviceId);
        if (!isReachable(deviceId)) {
            if (mastershipService.getLocalRole(deviceId) != NONE) {
                // can't be master if device is not reachable
                try {
                    post(store.markOffline(deviceId));
                    // relinquish master role and ability to be backup.
                    mastershipService.relinquishMastership(deviceId).get();
                } catch (InterruptedException e) {
                    log.warn("Interrupted while reliquishing role for {}", deviceId);
                    Thread.currentThread().interrupt();
                } catch (ExecutionException e) {
                    log.error("Exception thrown while relinquishing role for {}", deviceId, e);
                }
            }
            continue;
        }
        if (mastershipService.getLocalRole(deviceId) != NONE) {
            continue;
        }
        log.info("{} is reachable but did not have a valid role, reasserting", deviceId);
        // isReachable but was not MASTER or STANDBY, get a role and apply
        // Note: NONE triggers request to MastershipService
        reassertRole(deviceId, NONE);
    }
}
#end_block

#method_before
private boolean applyRole(DeviceId deviceId, MastershipRole newRole) {
    if (newRole.equals(MastershipRole.NONE)) {
        // no-op
        return true;
    }
    DeviceProvider provider = provider();
    if (provider == null) {
        log.warn("Provider for {} was not found. Cannot apply role {}", deviceId, newRole);
        return false;
    }
    provider.roleChanged(deviceId, newRole);
    return true;
}
#method_after
private boolean applyRole(DeviceId deviceId, MastershipRole newRole) {
    if (newRole.equals(MastershipRole.NONE)) {
        // no-op
        return true;
    }
    DeviceProvider provider = provider();
    if (provider == null) {
        log.warn("Provider for {} was not found. Cannot apply role {}", deviceId, newRole);
        return false;
    }
    provider.roleChanged(deviceId, newRole);
    // not triggering probe when triggered by provider service event
    return true;
}
#end_block

#method_before
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    BasicDeviceConfig cfg = networkConfigService.getConfig(deviceId, BasicDeviceConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Device {} is not allowed", deviceId);
        return;
    }
    // Generate updated description and establish my Role
    deviceDescription = BasicDeviceOperator.combine(cfg, deviceDescription);
    Futures.getUnchecked(mastershipService.requestRoleFor(deviceId).thenAccept(role -> {
        log.info("Local role is {} for {}", role, deviceId);
        applyRole(deviceId, role);
    }));
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    log.info("Device {} connected", deviceId);
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#method_after
@Override
public void deviceConnected(DeviceId deviceId, DeviceDescription deviceDescription) {
    checkNotNull(deviceId, DEVICE_ID_NULL);
    checkNotNull(deviceDescription, DEVICE_DESCRIPTION_NULL);
    checkValidity();
    BasicDeviceConfig cfg = networkConfigService.getConfig(deviceId, BasicDeviceConfig.class);
    if (!isAllowed(cfg)) {
        log.warn("Device {} is not allowed", deviceId);
        return;
    }
    // Generate updated description and establish my Role
    deviceDescription = BasicDeviceOperator.combine(cfg, deviceDescription);
    Futures.getUnchecked(mastershipService.requestRoleFor(deviceId).thenAccept(role -> {
        log.info("Local role is {} for {}", role, deviceId);
        applyRole(deviceId, role);
    }));
    DeviceEvent event = store.createOrUpdateDevice(provider().id(), deviceId, deviceDescription);
    if (deviceDescription.isDefaultAvailable()) {
        log.info("Device {} connected", deviceId);
    } else {
        log.info("Device {} registered", deviceId);
    }
    if (event != null) {
        log.trace("event: {} {}", event.type(), event);
        post(event);
    }
}
#end_block

#method_before
private void reassertRole(final DeviceId did, final MastershipRole nextRole) {
    MastershipRole myNextRole = nextRole;
    if (myNextRole == NONE) {
        try {
            mastershipService.requestRoleFor(did).get();
            MastershipTerm term = termService.getMastershipTerm(did);
            if (term != null && localNodeId.equals(term.master())) {
                myNextRole = MASTER;
            } else {
                myNextRole = STANDBY;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Interrupted waiting for Mastership", e);
        } catch (ExecutionException e) {
            log.error("Encountered an error waiting for Mastership", e);
        }
    }
    switch(myNextRole) {
        case MASTER:
            final Device device = getDevice(did);
            if ((device != null) && !isAvailable(did)) {
                // flag the device as online. Is there a better way to do this?
                DefaultDeviceDescription deviceDescription = new DefaultDeviceDescription(did.uri(), device.type(), device.manufacturer(), device.hwVersion(), device.swVersion(), device.serialNumber(), device.chassisId());
                DeviceEvent devEvent = store.createOrUpdateDevice(device.providerId(), did, deviceDescription);
                post(devEvent);
            }
            // TODO: should apply role only if there is mismatch
            log.debug("Applying role {} to {}", myNextRole, did);
            if (!applyRoleAndProbe(did, MASTER)) {
                log.warn("Unsuccessful applying role {} to {}", myNextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case STANDBY:
            log.debug("Applying role {} to {}", myNextRole, did);
            if (!applyRoleAndProbe(did, STANDBY)) {
                log.warn("Unsuccessful applying role {} to {}", myNextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case NONE:
        default:
            // should never reach here
            log.error("You didn't see anything. I did not exist.");
            break;
    }
}
#method_after
private void reassertRole(final DeviceId did, final MastershipRole nextRole) {
    MastershipRole myNextRole = nextRole;
    if (myNextRole == NONE) {
        try {
            mastershipService.requestRoleFor(did).get();
            MastershipTerm term = termService.getMastershipTerm(did);
            if (term != null && localNodeId.equals(term.master())) {
                myNextRole = MASTER;
            } else {
                myNextRole = STANDBY;
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Interrupted waiting for Mastership", e);
        } catch (ExecutionException e) {
            log.error("Encountered an error waiting for Mastership", e);
        }
    }
    switch(myNextRole) {
        case MASTER:
            final Device device = getDevice(did);
            if ((device != null) && !isAvailable(did)) {
                store.markOnline(did);
            }
            // TODO: should apply role only if there is mismatch
            log.debug("Applying role {} to {}", myNextRole, did);
            if (!applyRoleAndProbe(did, MASTER)) {
                log.warn("Unsuccessful applying role {} to {}", myNextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case STANDBY:
            log.debug("Applying role {} to {}", myNextRole, did);
            if (!applyRoleAndProbe(did, STANDBY)) {
                log.warn("Unsuccessful applying role {} to {}", myNextRole, did);
                // immediately failed to apply role
                mastershipService.relinquishMastership(did);
            // FIXME disconnect?
            }
            break;
        case NONE:
        default:
            // should never reach here
            log.error("You didn't see anything. I did not exist.");
            break;
    }
}
#end_block

#method_before
@Override
public boolean markOnline(DeviceId deviceId) {
    return false;
}
#method_after
@Override
public boolean markOnline(DeviceId deviceId) {
    log.warn("Mark online not supported");
    return false;
}
#end_block

#method_before
@Activate
public void activate() {
    active = true;
    providerService = providerRegistry.register(this);
    appId = coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgListener);
    controller.addDeviceListener(innerNodeListener);
    deviceService.addListener(deviceListener);
    executor.execute(NetconfDeviceProvider.this::connectDevices);
    localNodeId = clusterService.getLocalNode().id();
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    active = true;
    providerService = providerRegistry.register(this);
    appId = coreService.registerApplication(APP_NAME);
    cfgService.registerConfigFactory(factory);
    cfgService.addListener(cfgListener);
    controller.addDeviceListener(innerNodeListener);
    deviceService.addListener(deviceListener);
    executor.execute(NetconfDeviceProvider.this::connectDevices);
    localNodeId = clusterService.getLocalNode().id();
    scheduledTask = schedulePolling();
    log.info("Started");
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    deviceService.removeListener(deviceListener);
    active = false;
    controller.getNetconfDevices().forEach(id -> {
        deviceKeyAdminService.removeKey(DeviceKeyId.deviceKeyId(id.toString()));
        controller.disconnectDevice(id, true);
    });
    controller.removeDeviceListener(innerNodeListener);
    deviceService.removeListener(deviceListener);
    providerRegistry.unregister(this);
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    executor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    deviceService.removeListener(deviceListener);
    active = false;
    controller.getNetconfDevices().forEach(id -> {
        deviceKeyAdminService.removeKey(DeviceKeyId.deviceKeyId(id.toString()));
        controller.disconnectDevice(id, true);
    });
    controller.removeDeviceListener(innerNodeListener);
    deviceService.removeListener(deviceListener);
    providerRegistry.unregister(this);
    providerService = null;
    cfgService.unregisterConfigFactory(factory);
    scheduledTask.cancel(true);
    executor.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void deviceRemoved(DeviceId deviceId) {
    Preconditions.checkNotNull(deviceId, ISNULL);
    log.debug("Netconf device {} removed from Netconf subController", deviceId);
    providerService.deviceDisconnected(deviceId);
}
#method_after
@Override
public void deviceRemoved(DeviceId deviceId) {
    Preconditions.checkNotNull(deviceId, ISNULL);
    if (deviceService.getDevice(deviceId) != null) {
        providerService.deviceDisconnected(deviceId);
        log.debug("Netconf device {} removed from Netconf subController", deviceId);
    } else {
        log.warn("Netconf device {} does not exist in the store, " + "it may already have been removed", deviceId);
    }
}
#end_block

#method_before
private void connectDevices() {
    NetconfProviderConfig cfg = cfgService.getConfig(appId, NetconfProviderConfig.class);
    if (cfg != null) {
        try {
            cfg.getDevicesAddresses().stream().forEach(addr -> {
                DeviceId deviceId = getDeviceId(addr.ip().toString(), addr.port());
                Preconditions.checkNotNull(deviceId, ISNULL);
                // Netconf configuration object
                ChassisId cid = new ChassisId();
                String ipAddress = addr.ip().toString();
                SparseAnnotations annotations = DefaultAnnotations.builder().set(IPADDRESS, ipAddress).set(PORT, String.valueOf(addr.port())).set(AnnotationKeys.PROTOCOL, SCHEME_NAME.toUpperCase()).build();
                DeviceDescription deviceDescription = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid, annotations);
                deviceKeyAdminService.addKey(DeviceKey.createDeviceKeyUsingUsernamePassword(DeviceKeyId.deviceKeyId(deviceId.toString()), null, addr.name(), addr.password()));
                providerService.deviceConnected(deviceId, deviceDescription);
            // providerService.deviceRegistered(deviceId, deviceDescription);
            });
        } catch (ConfigException e) {
            log.error("Cannot read config error " + e);
        }
    }
}
#method_after
private void connectDevices() {
    NetconfProviderConfig cfg = cfgService.getConfig(appId, NetconfProviderConfig.class);
    if (cfg != null) {
        try {
            cfg.getDevicesAddresses().stream().forEach(addr -> {
                DeviceId deviceId = getDeviceId(addr.ip().toString(), addr.port());
                Preconditions.checkNotNull(deviceId, ISNULL);
                // Netconf configuration object
                ChassisId cid = new ChassisId();
                String ipAddress = addr.ip().toString();
                SparseAnnotations annotations = DefaultAnnotations.builder().set(IPADDRESS, ipAddress).set(PORT, String.valueOf(addr.port())).set(AnnotationKeys.PROTOCOL, SCHEME_NAME.toUpperCase()).build();
                DeviceDescription deviceDescription = new DefaultDeviceDescription(deviceId.uri(), Device.Type.SWITCH, UNKNOWN, UNKNOWN, UNKNOWN, UNKNOWN, cid, false, annotations);
                deviceKeyAdminService.addKey(DeviceKey.createDeviceKeyUsingUsernamePassword(DeviceKeyId.deviceKeyId(deviceId.toString()), null, addr.name(), addr.password()));
                if (deviceService.getDevice(deviceId) == null) {
                    providerService.deviceConnected(deviceId, deviceDescription);
                }
                checkAndUpdateDevice(deviceId, deviceDescription);
            });
        } catch (ConfigException e) {
            log.error("Cannot read config error " + e);
        }
    }
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    devicePortStats.destroy();
    devicePortDeltaStats.destroy();
    executor.shutdownNow();
    backgroundExecutor.shutdownNow();
    try {
        if (!backgroundExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
            log.error("Timeout during executor shutdown");
        }
    } catch (InterruptedException e) {
        log.error("Error during executor shutdown", e);
    }
    deviceDescs.clear();
    devices.clear();
    devicePorts.clear();
    availableDevices.clear();
    log.info("Stopped");
}
#method_after
@Deactivate
public void deactivate() {
    devicePortStats.removeListener(portStatsListener);
    devicePortStats.destroy();
    devicePortDeltaStats.destroy();
    executor.shutdownNow();
    backgroundExecutor.shutdownNow();
    try {
        if (!backgroundExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
            log.error("Timeout during executor shutdown");
        }
    } catch (InterruptedException e) {
        log.error("Error during executor shutdown", e);
    }
    deviceDescs.clear();
    devices.clear();
    devicePorts.clear();
    availableDevices.clear();
    clusterCommunicator.removeSubscriber(GossipDeviceStoreMessageSubjects.DEVICE_UPDATE);
    clusterCommunicator.removeSubscriber(GossipDeviceStoreMessageSubjects.DEVICE_OFFLINE);
    clusterCommunicator.removeSubscriber(GossipDeviceStoreMessageSubjects.DEVICE_REMOVE_REQ);
    clusterCommunicator.removeSubscriber(GossipDeviceStoreMessageSubjects.DEVICE_REMOVED);
    clusterCommunicator.removeSubscriber(GossipDeviceStoreMessageSubjects.PORT_UPDATE);
    clusterCommunicator.removeSubscriber(GossipDeviceStoreMessageSubjects.PORT_STATUS_UPDATE);
    clusterCommunicator.removeSubscriber(GossipDeviceStoreMessageSubjects.DEVICE_ADVERTISE);
    clusterCommunicator.removeSubscriber(GossipDeviceStoreMessageSubjects.DEVICE_INJECTED);
    clusterCommunicator.removeSubscriber(GossipDeviceStoreMessageSubjects.PORT_INJECTED);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public synchronized DeviceEvent createOrUpdateDevice(ProviderId providerId, DeviceId deviceId, DeviceDescription deviceDescription) {
    return createOrUpdateDevice(providerId, deviceId, deviceDescription, true);
}
#method_after
@Override
public synchronized DeviceEvent createOrUpdateDevice(ProviderId providerId, DeviceId deviceId, DeviceDescription deviceDescription) {
    NodeId localNode = clusterService.getLocalNode().id();
    NodeId deviceNode = mastershipService.getMasterFor(deviceId);
    // Process device update only if we're the master,
    // otherwise signal the actual master.
    DeviceEvent deviceEvent = null;
    if (localNode.equals(deviceNode)) {
        final Timestamp newTimestamp = deviceClockService.getTimestamp(deviceId);
        final Timestamped<DeviceDescription> deltaDesc = new Timestamped<>(deviceDescription, newTimestamp);
        final Timestamped<DeviceDescription> mergedDesc;
        final Map<ProviderId, DeviceDescriptions> device = getOrCreateDeviceDescriptionsMap(deviceId);
        synchronized (device) {
            deviceEvent = createOrUpdateDeviceInternal(providerId, deviceId, deltaDesc);
            mergedDesc = device.get(providerId).getDeviceDesc();
        }
        if (deviceEvent != null) {
            log.debug("Notifying peers of a device update topology event for providerId: {} and deviceId: {}", providerId, deviceId);
            notifyPeers(new InternalDeviceEvent(providerId, deviceId, mergedDesc));
        }
    } else {
        // Forwarding was added as a workaround for ONOS-490
        if (!providerId.scheme().equals("cfg")) {
            return null;
        }
        // redo ONOS-490
        if (deviceNode == null) {
            // silently ignore
            return null;
        }
        DeviceInjectedEvent deviceInjectedEvent = new DeviceInjectedEvent(providerId, deviceId, deviceDescription);
        // TODO check unicast return value
        clusterCommunicator.unicast(deviceInjectedEvent, DEVICE_INJECTED, SERIALIZER::encode, deviceNode);
    /* error log:
            log.warn("Failed to process injected device id: {} desc: {} " +
                            "(cluster messaging failed: {})",
                    deviceId, deviceDescription, e);
            */
    }
    return deviceEvent;
}
#end_block

#method_before
private DeviceEvent createOrUpdateDeviceInternal(ProviderId providerId, DeviceId deviceId, Timestamped<DeviceDescription> deltaDesc) {
    // Collection of DeviceDescriptions for a Device
    Map<ProviderId, DeviceDescriptions> device = getOrCreateDeviceDescriptionsMap(deviceId);
    synchronized (device) {
        if (isDeviceRemoved(deviceId, deltaDesc.timestamp())) {
            log.debug("Ignoring outdated event: {}", deltaDesc);
            return null;
        }
        DeviceDescriptions descs = getOrCreateProviderDeviceDescriptions(device, providerId, deltaDesc);
        final Device oldDevice = devices.get(deviceId);
        final Device newDevice;
        if (deltaDesc == descs.getDeviceDesc() || deltaDesc.isNewer(descs.getDeviceDesc())) {
            // on new device or valid update
            descs.putDeviceDesc(deltaDesc);
            newDevice = composeDevice(deviceId, device);
        } else {
            // outdated event, ignored.
            return null;
        }
        if (oldDevice == null) {
            // ADD
            return createDevice(providerId, newDevice, deltaDesc.timestamp());
        } else {
            // UPDATE or ignore (no change or stale)
            return updateDevice(providerId, oldDevice, newDevice, deltaDesc.timestamp());
        }
    }
}
#method_after
private DeviceEvent createOrUpdateDeviceInternal(ProviderId providerId, DeviceId deviceId, Timestamped<DeviceDescription> deltaDesc) {
    // Collection of DeviceDescriptions for a Device
    Map<ProviderId, DeviceDescriptions> device = getOrCreateDeviceDescriptionsMap(deviceId);
    synchronized (device) {
        if (isDeviceRemoved(deviceId, deltaDesc.timestamp())) {
            log.debug("Ignoring outdated event: {}", deltaDesc);
            return null;
        }
        DeviceDescriptions descs = getOrCreateProviderDeviceDescriptions(device, providerId, deltaDesc);
        final Device oldDevice = devices.get(deviceId);
        final Device newDevice;
        if (deltaDesc == descs.getDeviceDesc() || deltaDesc.isNewer(descs.getDeviceDesc())) {
            // on new device or valid update
            descs.putDeviceDesc(deltaDesc);
            newDevice = composeDevice(deviceId, device);
        } else {
            // outdated event, ignored.
            return null;
        }
        if (oldDevice == null) {
            // REGISTER
            if (!deltaDesc.value().isDefaultAvailable()) {
                return registerDevice(providerId, newDevice);
            }
            // ADD
            return createDevice(providerId, newDevice, deltaDesc.timestamp());
        } else {
            // UPDATE or ignore (no change or stale)
            return updateDevice(providerId, oldDevice, newDevice, deltaDesc.timestamp(), deltaDesc.value().isDefaultAvailable());
        }
    }
}
#end_block

#method_before
// Updates the device and returns the appropriate event if necessary.
private DeviceEvent updateDevice(ProviderId providerId, Device oldDevice, Device newDevice, Timestamp newTimestamp) {
    // We allow only certain attributes to trigger update
    boolean propertiesChanged = !Objects.equals(oldDevice.hwVersion(), newDevice.hwVersion()) || !Objects.equals(oldDevice.swVersion(), newDevice.swVersion()) || !Objects.equals(oldDevice.providerId(), newDevice.providerId());
    boolean annotationsChanged = !AnnotationsUtil.isEqual(oldDevice.annotations(), newDevice.annotations());
    // Primary providers can respond to all changes, but ancillary ones
    // should respond only to annotation changes.
    DeviceEvent event = null;
    if ((providerId.isAncillary() && annotationsChanged) || (!providerId.isAncillary() && (propertiesChanged || annotationsChanged))) {
        boolean replaced = devices.replace(newDevice.id(), oldDevice, newDevice);
        if (!replaced) {
            verify(replaced, "Replacing devices cache failed. PID:%s [expected:%s, found:%s, new=%s]", providerId, oldDevice, devices.get(newDevice.id()), newDevice);
        }
        event = new DeviceEvent(DeviceEvent.Type.DEVICE_UPDATED, newDevice, null);
    }
    if (!providerId.isAncillary()) {
        boolean wasOnline = availableDevices.contains(newDevice.id());
        markOnline(newDevice.id(), newTimestamp);
        if (!wasOnline) {
            notifyDelegateIfNotNull(new DeviceEvent(DEVICE_AVAILABILITY_CHANGED, newDevice, null));
        }
    }
    return event;
}
#method_after
// Updates the device and returns the appropriate event if necessary.
private DeviceEvent updateDevice(ProviderId providerId, Device oldDevice, Device newDevice, Timestamp newTimestamp, boolean forceAvailable) {
    // We allow only certain attributes to trigger update
    boolean propertiesChanged = !Objects.equals(oldDevice.hwVersion(), newDevice.hwVersion()) || !Objects.equals(oldDevice.swVersion(), newDevice.swVersion()) || !Objects.equals(oldDevice.providerId(), newDevice.providerId());
    boolean annotationsChanged = !AnnotationsUtil.isEqual(oldDevice.annotations(), newDevice.annotations());
    // Primary providers can respond to all changes, but ancillary ones
    // should respond only to annotation changes.
    DeviceEvent event = null;
    if ((providerId.isAncillary() && annotationsChanged) || (!providerId.isAncillary() && (propertiesChanged || annotationsChanged))) {
        boolean replaced = devices.replace(newDevice.id(), oldDevice, newDevice);
        if (!replaced) {
            verify(replaced, "Replacing devices cache failed. PID:%s [expected:%s, found:%s, new=%s]", providerId, oldDevice, devices.get(newDevice.id()), newDevice);
        }
        event = new DeviceEvent(DeviceEvent.Type.DEVICE_UPDATED, newDevice, null);
    }
    if (!providerId.isAncillary() && forceAvailable) {
        boolean wasOnline = availableDevices.contains(newDevice.id());
        markOnline(newDevice.id(), newTimestamp);
        if (!wasOnline) {
            notifyDelegateIfNotNull(new DeviceEvent(DEVICE_AVAILABILITY_CHANGED, newDevice, null));
        }
    }
    return event;
}
#end_block

#method_before
public boolean markOnline(DeviceId deviceId) {
    final Timestamp timestamp = deviceClockService.getTimestamp(deviceId);
    return markOnline(deviceId, timestamp);
}
#method_after
public boolean markOnline(DeviceId deviceId) {
    if (devices.containsKey(deviceId)) {
        final Timestamp timestamp = deviceClockService.getTimestamp(deviceId);
        Map<?, ?> deviceLock = getOrCreateDeviceDescriptionsMap(deviceId);
        synchronized (deviceLock) {
            if (markOnline(deviceId, timestamp)) {
                notifyDelegate(new DeviceEvent(DEVICE_AVAILABILITY_CHANGED, getDevice(deviceId), null));
                return true;
            } else {
                return false;
            }
        }
    }
    log.warn("Device {} does not exist in store", deviceId);
    return false;
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    configRegistry.registerConfigFactory(configFactory);
    configService.addListener(configListener);
    deviceService.addListener(internalDeviceListener);
    selectGroupHandler = new SelectGroupHandler(groupService, deviceService, driverService, appId);
    readConfiguration();
    log.info("started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(APP_ID);
    configRegistry.registerConfigFactory(configFactory);
    configService.addListener(configListener);
    deviceService.addListener(internalDeviceListener);
    selectGroupHandler = new SelectGroupHandler(groupService, deviceService, driverService, appId);
    readConfiguration();
    gatewayNodeMap = storageService.<DeviceId, GatewayNode>consistentMapBuilder().withSerializer(Serializer.using(GATEWAYNODE_SERIALIZER.build())).withName(GATEWAYNODE_MAP_NAME).withApplicationId(appId).build();
    log.info("started");
}
#end_block

#method_before
@Override
public GatewayNode getGatewayNode(DeviceId deviceId) {
    return checkNotNull(gatewayNodeMap.get(deviceId), GATEWAYNODE_CAN_NOT_BE_NULL);
}
#method_after
@Override
public GatewayNode getGatewayNode(DeviceId deviceId) {
    return checkNotNull(gatewayNodeMap.get(deviceId).value(), GATEWAYNODE_CAN_NOT_BE_NULL);
}
#end_block

#method_before
@Override
public List<PortNumber> getGatewayExternalPorts(DeviceId deviceId) {
    GatewayNode gatewayNode = checkNotNull(gatewayNodeMap.get(deviceId), GATEWAYNODE_CAN_NOT_BE_NULL);
    List<PortNumber> portNumbers = Lists.newArrayList();
    gatewayNode.getGatewayExternalInterfaceNames().stream().forEach(name -> portNumbers.add(findPortNumFromPortName(gatewayNode.getGatewayDeviceId(), name)));
    return portNumbers;
}
#method_after
@Override
public List<PortNumber> getGatewayExternalPorts(DeviceId deviceId) {
    GatewayNode gatewayNode = checkNotNull(gatewayNodeMap.get(deviceId).value(), GATEWAYNODE_CAN_NOT_BE_NULL);
    List<PortNumber> portNumbers = Lists.newArrayList();
    gatewayNode.getGatewayExternalInterfaceNames().stream().forEach(name -> portNumbers.add(findPortNumFromPortName(gatewayNode.getGatewayDeviceId(), name)));
    return portNumbers;
}
#end_block

#method_before
@Override
public List<GatewayNode> getGatewayNodes() {
    List<GatewayNode> gatewayNodeList = Lists.newArrayList();
    gatewayNodeMap.values().stream().forEach(gatewayNode -> gatewayNodeList.add(gatewayNode));
    return gatewayNodeList;
}
#method_after
@Override
public List<GatewayNode> getGatewayNodes() {
    List<GatewayNode> gatewayNodeList = Lists.newArrayList();
    gatewayNodeMap.values().stream().map(Versioned::value).forEach(gatewayNode -> gatewayNodeList.add(gatewayNode));
    return gatewayNodeList;
}
#end_block

#method_before
@Override
public List<DeviceId> getGatewayDeviceIds() {
    List<DeviceId> deviceIdList = Lists.newArrayList();
    gatewayNodeMap.values().stream().forEach(gatewayNode -> deviceIdList.add(gatewayNode.getGatewayDeviceId()));
    return deviceIdList;
}
#method_after
@Override
public List<DeviceId> getGatewayDeviceIds() {
    List<DeviceId> deviceIdList = Lists.newArrayList();
    gatewayNodeMap.values().stream().map(Versioned::value).forEach(gatewayNode -> deviceIdList.add(gatewayNode.getGatewayDeviceId()));
    return deviceIdList;
}
#end_block

#method_before
@Override
public boolean addGatewayNode(GatewayNode gatewayNode) {
    gatewayNodeMap.putIfAbsent(gatewayNode.getGatewayDeviceId(), gatewayNode);
    updateGatewayLoadBalance(gatewayNode, true);
    deviceListeners.forEach(deviceListener -> deviceListener.event(new DeviceEvent(DeviceEvent.Type.DEVICE_ADDED, deviceService.getDevice(gatewayNode.getGatewayDeviceId()))));
    return true;
}
#method_after
@Override
public boolean addGatewayNode(GatewayNode gatewayNode) {
    gatewayNodeMap.putIfAbsent(gatewayNode.getGatewayDeviceId(), gatewayNode);
    updateGatewayLoadBalance(gatewayNode, true);
    return true;
}
#end_block

#method_before
@Override
public void event(DeviceEvent deviceEvent) {
    if (deviceEvent.type() == DeviceEvent.Type.DEVICE_SUSPENDED || deviceEvent.type() == DeviceEvent.Type.DEVICE_REMOVED) {
        if (gatewayNodeMap.containsKey(deviceEvent.subject().id())) {
            deleteGatewayNode(getGatewayNode(deviceEvent.subject().id()));
        }
    }
}
#method_after
@Override
public void event(DeviceEvent deviceEvent) {
    if (deviceEvent.type() == DeviceEvent.Type.DEVICE_SUSPENDED || deviceEvent.type() == DeviceEvent.Type.DEVICE_REMOVED) {
        deleteGatewayNode(getGatewayNode(deviceEvent.subject().id()));
    }
}
#end_block

#method_before
@Override
protected void execute() {
    ScalableGatewayService service = get(ScalableGatewayService.class);
    GatewayNode gatewayNode = new GatewayNode.Builder().gatewayDeviceId(DeviceId.deviceId(deviceId)).dataIpAddress(Ip4Address.valueOf(ipAddress)).gatewayExternalInterfaceNames(splitNameList(interfaceName)).build();
    if (service.addGatewayNode(gatewayNode)) {
        print(success);
    } else {
        print(fail);
    }
}
#method_after
@Override
protected void execute() {
    ScalableGatewayService service = get(ScalableGatewayService.class);
    GatewayNode gatewayNode = GatewayNode.builder().gatewayDeviceId(DeviceId.deviceId(deviceId)).dataIpAddress(Ip4Address.valueOf(ipAddress)).gatewayExternalInterfaceNames(splitNameList(interfaceName)).build();
    if (service.addGatewayNode(gatewayNode)) {
        print(SUCCESS);
    } else {
        print(FAIL);
    }
}
#end_block

#method_before
@Override
protected void execute() {
    ScalableGatewayService service = get(ScalableGatewayService.class);
    service.getGatewayNodes().forEach(node -> print(format, node.getGatewayDeviceId().toString(), node.getDataIpAddress().toString(), node.getGatewayExternalInterfaceNames().toString()));
}
#method_after
@Override
protected void execute() {
    ScalableGatewayService service = get(ScalableGatewayService.class);
    service.getGatewayNodes().forEach(node -> print(FORMAT, node.getGatewayDeviceId().toString(), node.getDataIpAddress().toString(), node.getGatewayExternalInterfaceNames().toString()));
}
#end_block

#method_before
@Override
protected void execute() {
    ScalableGatewayService service = get(ScalableGatewayService.class);
    GatewayNode gatewayNode = service.getGatewayNode(DeviceId.deviceId(deviceId));
    if (gatewayNode == null) {
        print(unknown);
        return;
    }
    if (service.deleteGatewayNode(gatewayNode)) {
        print(success);
    } else {
        print(fail);
    }
}
#method_after
@Override
protected void execute() {
    ScalableGatewayService service = get(ScalableGatewayService.class);
    GatewayNode gatewayNode = service.getGatewayNode(DeviceId.deviceId(deviceId));
    if (gatewayNode == null) {
        print(UNKNOWN);
        return;
    }
    if (service.deleteGatewayNode(gatewayNode)) {
        print(SUCCESS);
    } else {
        print(FAIL);
    }
}
#end_block

#method_before
@Override
public GeneratedMessage convertToProtoMessage(Event<?, ?> event) {
    LinkEvent linkEvent = (LinkEvent) event;
    if (!linkEventSubtypeSupported(linkEvent)) {
        log.error("Unsupported Onos Event {}. There is no matching" + "proto Event type", linkEvent.type().toString());
        return null;
    }
    return buildDeviceProtoMessage(linkEvent);
}
#method_after
@Override
public GeneratedMessage convertToProtoMessage(Event<?, ?> event) {
    LinkEvent linkEvent = (LinkEvent) event;
    if (!linkEventTypeSupported(linkEvent)) {
        log.error("Unsupported Onos Event {}. There is no matching" + "proto Event type", linkEvent.type().toString());
        return null;
    }
    return buildDeviceProtoMessage(linkEvent);
}
#end_block

#method_before
@Override
public GeneratedMessage convertToProtoMessage(Event<?, ?> event) {
    DeviceEvent deviceEvent = (DeviceEvent) event;
    if (!deviceEventSubtypeSupported(deviceEvent)) {
        log.error("Unsupported Onos Device Event {}. There is no matching" + "proto Device Event type", deviceEvent.type().toString());
        return null;
    }
    return buildDeviceProtoMessage(deviceEvent);
}
#method_after
@Override
public GeneratedMessage convertToProtoMessage(Event<?, ?> event) {
    DeviceEvent deviceEvent = (DeviceEvent) event;
    if (!deviceEventTypeSupported(deviceEvent)) {
        log.error("Unsupported Onos Device Event {}. There is no matching" + "proto Device Event type", deviceEvent.type().toString());
        return null;
    }
    return buildDeviceProtoMessage(deviceEvent);
}
#end_block

#method_before
private DeviceNotification buildDeviceProtoMessage(DeviceEvent deviceEvent) {
    DeviceNotification notification = DeviceNotification.newBuilder().setDeviceEventType(getProtoType(deviceEvent)).setDevice(DeviceCore.newBuilder().setChassisId(deviceEvent.subject().chassisId().id().toString()).setDeviceId(deviceEvent.subject().id().toString()).setHwVersion(deviceEvent.subject().hwVersion()).setManufacturer(deviceEvent.subject().manufacturer()).setSerialNumber(deviceEvent.subject().serialNumber()).setSwVersion(deviceEvent.subject().swVersion()).setType(DeviceType.valueOf(deviceEvent.subject().type().name())).build()).setPort(PortCore.newBuilder().setIsEnabled(deviceEvent.port().isEnabled()).setPortNumber(deviceEvent.port().number().toString()).setPortSpeed(deviceEvent.port().portSpeed()).setType(PortType.valueOf(deviceEvent.port().type().name())).build()).build();
    return notification;
}
#method_after
private DeviceNotification buildDeviceProtoMessage(DeviceEvent deviceEvent) {
    DeviceNotification.Builder notificationBuilder = DeviceNotification.newBuilder();
    DeviceCore deviceCore = DeviceCore.newBuilder().setChassisId(deviceEvent.subject().chassisId().id().toString()).setDeviceId(deviceEvent.subject().id().toString()).setHwVersion(deviceEvent.subject().hwVersion()).setManufacturer(deviceEvent.subject().manufacturer()).setSerialNumber(deviceEvent.subject().serialNumber()).setSwVersion(deviceEvent.subject().swVersion()).setType(DeviceType.valueOf(deviceEvent.subject().type().name())).build();
    PortCore portCore = null;
    if (deviceEvent.port() != null) {
        portCore = PortCore.newBuilder().setIsEnabled(deviceEvent.port().isEnabled()).setPortNumber(deviceEvent.port().number().toString()).setPortSpeed(deviceEvent.port().portSpeed()).setType(PortType.valueOf(deviceEvent.port().type().name())).build();
        notificationBuilder.setPort(portCore);
    }
    notificationBuilder.setDeviceEventType(getProtoType(deviceEvent)).setDevice(deviceCore);
    return notificationBuilder.build();
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("getKey", key).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(getClass()).add("key", key).toString();
}
#end_block

#method_before
@Override
public void resolve(SerializerRegistry registry) {
    // NOTE the registration values must be unique throughout the
    // project.
    registry.register(ContainsKey.class, -961);
    registry.register(ContainsValue.class, -962);
    registry.register(Get.class, -963);
    registry.register(EntrySet.class, -964);
    registry.register(Values.class, -965);
    registry.register(KeySet.class, -966);
    registry.register(Clear.class, -967);
    registry.register(IsEmpty.class, -968);
    registry.register(Size.class, -969);
    registry.register(Listen.class, -970);
    registry.register(Unlisten.class, -971);
    // Transaction related commands will be added here with numbers
    // -972 to -974
    registry.register(UpdateAndGet.class, -975);
    registry.register(FirstKey.class, -976);
    registry.register(LastKey.class, -977);
    registry.register(FirstEntry.class, -978);
    registry.register(LastEntry.class, -979);
    registry.register(PollFirstEntry.class, -980);
    registry.register(PollLastEntry.class, -981);
    registry.register(LowerEntry.class, -982);
    registry.register(LowerKey.class, -983);
    registry.register(FloorEntry.class, -984);
    registry.register(FloorKey.class, -985);
    registry.register(CeilingEntry.class, -986);
    registry.register(CeilingKey.class, -987);
    registry.register(HigherEntry.class, -988);
    registry.register(HigherKey.class, -989);
    registry.register(SubMap.class, -990);
    registry.register(NavigableKeySet.class, -991);
}
#method_after
@Override
public void resolve(SerializerRegistry registry) {
    // NOTE the registration values must be unique throughout the
    // project.
    registry.register(ContainsKey.class, -1161);
    registry.register(ContainsValue.class, -1162);
    registry.register(Get.class, -1163);
    registry.register(EntrySet.class, -1164);
    registry.register(Values.class, -1165);
    registry.register(KeySet.class, -1166);
    registry.register(Clear.class, -1167);
    registry.register(IsEmpty.class, -1168);
    registry.register(Size.class, -1169);
    registry.register(Listen.class, -1170);
    registry.register(Unlisten.class, -1171);
    // Transaction related commands will be added here with numbers
    // -1172 to -1174
    registry.register(UpdateAndGet.class, -1175);
    registry.register(FirstKey.class, -1176);
    registry.register(LastKey.class, -1177);
    registry.register(FirstEntry.class, -1178);
    registry.register(LastEntry.class, -1179);
    registry.register(PollFirstEntry.class, -1180);
    registry.register(PollLastEntry.class, -1181);
    registry.register(LowerEntry.class, -1182);
    registry.register(LowerKey.class, -1183);
    registry.register(FloorEntry.class, -1184);
    registry.register(FloorKey.class, -1185);
    registry.register(CeilingEntry.class, -1186);
    registry.register(CeilingKey.class, -1187);
    registry.register(HigherEntry.class, -1188);
    registry.register(HigherKey.class, -1189);
    registry.register(SubMap.class, -1190);
    registry.register(NavigableKeySet.class, -1191);
}
#end_block

#method_before
@Override
public String getOvsUuid(String dbName) {
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, DATABASENAME);
    if (rowStore == null) {
        log.debug("The bridge uuid is null");
        return null;
    }
    ConcurrentMap<String, Row> ovsTableRows = rowStore.getRowStore();
    if (ovsTableRows != null) {
        for (String uuid : ovsTableRows.keySet()) {
            Row row = ovsTableRows.get(uuid);
            String tableName = row.tableName();
            if (tableName.equals(dbName)) {
                return uuid;
            }
        }
    }
    return null;
}
#method_after
private String getOvsUuid(String dbName) {
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, DATABASENAME);
    if (rowStore == null) {
        log.debug("The bridge uuid is null");
        return null;
    }
    ConcurrentMap<String, Row> ovsTableRows = rowStore.getRowStore();
    if (ovsTableRows != null) {
        for (String uuid : ovsTableRows.keySet()) {
            Row row = ovsTableRows.get(uuid);
            String tableName = row.tableName();
            if (tableName.equals(dbName)) {
                return uuid;
            }
        }
    }
    return null;
}
#end_block

#method_before
@Override
public void setControllersWithUuid(Uuid bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<Uuid> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(DATABASENAME, CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    removeControllers.forEach(c -> deleteConfig(CONTROLLER, UUID, c.getRow().uuid().value(), BRIDGE, "controller"));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        String uuid = insertConfig(CONTROLLER, UUID, BRIDGE, "controller", bridgeUuid.value(), c.getRow());
        newControllerUuids.add(Uuid.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(BRIDGE, UUID, bridgeUuid.value(), bridge.getRow());
}
#method_after
private void setControllersWithUuid(Uuid bridgeUuid, List<ControllerInfo> controllers) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    if (dbSchema == null) {
        log.debug("There is no schema");
        return;
    }
    List<Controller> oldControllers = getControllers(bridgeUuid);
    if (oldControllers == null) {
        log.warn("There are no controllers");
        return;
    }
    Set<Uuid> newControllerUuids = new HashSet<>();
    Set<ControllerInfo> newControllers = new HashSet<>(controllers);
    List<Controller> removeControllers = new ArrayList<>();
    oldControllers.forEach(controller -> {
        ControllerInfo controllerInfo = new ControllerInfo((String) controller.getTargetColumn().data());
        if (newControllers.contains(controllerInfo)) {
            newControllers.remove(controllerInfo);
            newControllerUuids.add(controller.getRow().uuid());
        } else {
            removeControllers.add(controller);
        }
    });
    OvsdbRowStore controllerRowStore = getRowStore(DATABASENAME, CONTROLLER);
    if (controllerRowStore == null) {
        log.debug("There is no controller table");
        return;
    }
    removeControllers.forEach(c -> deleteConfig(CONTROLLER, UUID, c.getRow().uuid().value(), BRIDGE, "controller"));
    newControllers.stream().map(c -> {
        Controller controller = (Controller) TableGenerator.createTable(dbSchema, OvsdbTable.CONTROLLER);
        controller.setTarget(c.target());
        return controller;
    }).forEach(c -> {
        String uuid = insertConfig(CONTROLLER, UUID, BRIDGE, "controller", bridgeUuid.value(), c.getRow());
        newControllerUuids.add(Uuid.uuid(uuid));
    });
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, BRIDGE);
    if (rowStore == null) {
        log.debug("There is no bridge table");
        return;
    }
    Row bridgeRow = rowStore.getRow(bridgeUuid.value());
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, bridgeRow, OvsdbTable.BRIDGE);
    bridge.setController(OvsdbSet.ovsdbSet(newControllerUuids));
    updateConfig(BRIDGE, UUID, bridgeUuid.value(), bridge.getRow());
}
#end_block

#method_before
@Override
public void dropBridge(String bridgeName) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.warn("Could not find bridge in node", nodeId.getIpAddress());
        return;
    }
    deleteConfig(BRIDGE, UUID, bridgeUuid, DATABASENAME, "bridges");
}
#method_after
@Override
public void dropBridge(String bridgeName) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.warn("Could not find bridge in node", nodeId.getIpAddress());
        return;
    }
    deleteConfig(BRIDGE, UUID, bridgeUuid, DATABASENAME, BRIDGES);
}
#end_block

#method_before
@Override
public boolean createTunnel(String bridgeName, String portName, String tunnelType, Map<String, String> options) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.warn("Couldn't find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return false;
    }
    if (getPortUuid(portName, bridgeUuid) != null) {
        log.warn("Port {} already exists", portName);
        // remove existing one and re-create?
        return false;
    }
    ArrayList<Operation> operations = Lists.newArrayList();
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    // insert a new port to the port table
    Port port = (Port) TableGenerator.createTable(dbSchema, OvsdbTable.PORT);
    port.setName(portName);
    Insert portInsert = new Insert(dbSchema.getTableSchema("Port"), "Port", port.getRow());
    portInsert.getRow().put("interfaces", Uuid.uuid("Interface"));
    operations.add(portInsert);
    // update the bridge table
    Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(bridgeUuid));
    Mutation mutation = MutationUtil.insert(PORTS, Uuid.uuid("Port"));
    List<Condition> conditions = new ArrayList<>(Arrays.asList(condition));
    List<Mutation> mutations = new ArrayList<>(Arrays.asList(mutation));
    operations.add(new Mutate(dbSchema.getTableSchema("Bridge"), conditions, mutations));
    // insert a tunnel interface
    Interface intf = (Interface) TableGenerator.createTable(dbSchema, OvsdbTable.INTERFACE);
    intf.setName(portName);
    intf.setType(tunnelType);
    intf.setOptions(options);
    Insert intfInsert = new Insert(dbSchema.getTableSchema("Interface"), "Interface", intf.getRow());
    operations.add(intfInsert);
    transactConfig(DATABASENAME, operations);
    return true;
}
#method_after
@Deprecated
@Override
public boolean createTunnel(String bridgeName, String ifaceName, String tunnelType, Map<String, String> options) {
    OvsdbInterface ovsdbIface = OvsdbInterface.builder().name(ifaceName).type(Type.valueOf(tunnelType)).options(options).build();
    return createInterface(bridgeName, ovsdbIface);
}
#end_block

#method_before
@Override
public void dropTunnel(IpAddress srcIp, IpAddress dstIp) {
    String bridgeName = INTEGRATION_BRIDGE;
    String portName = getTunnelName(TYPEVXLAN, dstIp);
    String bridgeUuid = getBridgeUuid(INTEGRATION_BRIDGE);
    if (bridgeUuid == null) {
        log.warn("Could not find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return;
    }
    String portUuid = getPortUuid(portName, bridgeUuid);
    if (portUuid != null) {
        log.info("Delete tunnel");
        deleteConfig(PORT, UUID, portUuid, BRIDGE, PORTS);
    }
}
#method_after
@Deprecated
@Override
public void dropTunnel(IpAddress srcIp, IpAddress dstIp) {
}
#end_block

#method_before
private String insertConfig(String childTableName, String childColumnName, String parentTableName, String parentColumnName, String parentUuid, Row row) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    TableSchema tableSchema = dbSchema.getTableSchema(childTableName);
    Insert insert = new Insert(tableSchema, childTableName, row);
    ArrayList<Operation> operations = Lists.newArrayList();
    operations.add(insert);
    if (parentTableName != null && parentColumnName != null) {
        TableSchema parentTableSchema = dbSchema.getTableSchema(parentTableName);
        ColumnSchema parentColumnSchema = parentTableSchema.getColumnSchema(parentColumnName);
        List<Mutation> mutations = Lists.newArrayList();
        Mutation mutation = MutationUtil.insert(parentColumnSchema.name(), Uuid.uuid(childTableName));
        mutations.add(mutation);
        List<Condition> conditions = Lists.newArrayList();
        Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(parentUuid));
        conditions.add(condition);
        Mutate op = new Mutate(parentTableSchema, conditions, mutations);
        operations.add(op);
    }
    if (childTableName.equalsIgnoreCase(PORT)) {
        log.debug("Handle port insert");
        Insert intfInsert = handlePortInsertTable(INTERFACE, row);
        if (intfInsert != null) {
            operations.add(intfInsert);
        }
        Insert ins = (Insert) operations.get(0);
        ins.getRow().put("interfaces", Uuid.uuid(INTERFACE));
    }
    List<OperationResult> results;
    try {
        results = transactConfig(DATABASENAME, operations).get();
        return results.get(0).getUuid().value();
    } catch (InterruptedException e) {
        log.warn("Interrupted while waiting to get result");
        Thread.currentThread().interrupt();
    } catch (ExecutionException e) {
        log.error("Exception thrown while to get result");
    }
    return null;
}
#method_after
private String insertConfig(String childTableName, String childColumnName, String parentTableName, String parentColumnName, String parentUuid, Row row) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    TableSchema tableSchema = dbSchema.getTableSchema(childTableName);
    Insert insert = new Insert(tableSchema, childTableName, row);
    ArrayList<Operation> operations = Lists.newArrayList();
    operations.add(insert);
    if (parentTableName != null && parentColumnName != null) {
        TableSchema parentTableSchema = dbSchema.getTableSchema(parentTableName);
        ColumnSchema parentColumnSchema = parentTableSchema.getColumnSchema(parentColumnName);
        List<Mutation> mutations = Lists.newArrayList();
        Mutation mutation = MutationUtil.insert(parentColumnSchema.name(), Uuid.uuid(childTableName));
        mutations.add(mutation);
        List<Condition> conditions = Lists.newArrayList();
        Condition condition = ConditionUtil.isEqual(UUID, Uuid.uuid(parentUuid));
        conditions.add(condition);
        Mutate op = new Mutate(parentTableSchema, conditions, mutations);
        operations.add(op);
    }
    if (childTableName.equalsIgnoreCase(PORT)) {
        log.debug("Handle port insert");
        Insert intfInsert = handlePortInsertTable(row);
        if (intfInsert != null) {
            operations.add(intfInsert);
        }
        Insert ins = (Insert) operations.get(0);
        ins.getRow().put("interfaces", Uuid.uuid(INTERFACE));
    }
    List<OperationResult> results;
    try {
        results = transactConfig(DATABASENAME, operations).get();
        return results.get(0).getUuid().value();
    } catch (InterruptedException e) {
        log.warn("Interrupted while waiting to get result");
        Thread.currentThread().interrupt();
    } catch (ExecutionException e) {
        log.error("Exception thrown while to get result");
    }
    return null;
}
#end_block

#method_before
private Insert handlePortInsertTable(String tableName, Row portRow) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    TableSchema portTableSchema = dbSchema.getTableSchema(PORT);
    ColumnSchema portColumnSchema = portTableSchema.getColumnSchema("name");
    String portName = (String) portRow.getColumn(portColumnSchema.name()).data();
    Interface inf = (Interface) TableGenerator.createTable(dbSchema, OvsdbTable.INTERFACE);
    inf.setName(portName);
    TableSchema intfTableSchema = dbSchema.getTableSchema(INTERFACE);
    return new Insert(intfTableSchema, INTERFACE, inf.getRow());
}
#method_after
private Insert handlePortInsertTable(Row portRow) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    TableSchema portTableSchema = dbSchema.getTableSchema(PORT);
    ColumnSchema portColumnSchema = portTableSchema.getColumnSchema("name");
    String portName = (String) portRow.getColumn(portColumnSchema.name()).data();
    Interface inf = (Interface) TableGenerator.createTable(dbSchema, OvsdbTable.INTERFACE);
    inf.setName(portName);
    TableSchema intfTableSchema = dbSchema.getTableSchema(INTERFACE);
    return new Insert(intfTableSchema, INTERFACE, inf.getRow());
}
#end_block

#method_before
@Override
public ListenableFuture<List<OperationResult>> transactConfig(String dbName, List<Operation> operations) {
    if (dbName == null) {
        return null;
    }
    DatabaseSchema dbSchema = schema.get(dbName);
    if (dbSchema != null) {
        Function<List<JsonNode>, List<OperationResult>> rowFunction = (input -> {
            log.debug("Get ovsdb operation result");
            List<OperationResult> result = FromJsonUtil.jsonNodeToOperationResult(input, operations);
            if (result == null) {
                log.debug("The operation result is null");
                return null;
            }
            return result;
        });
        return Futures.transform(transact(dbSchema, operations), rowFunction);
    }
    return null;
}
#method_after
private ListenableFuture<List<OperationResult>> transactConfig(String dbName, List<Operation> operations) {
    if (dbName == null) {
        return null;
    }
    DatabaseSchema dbSchema = schema.get(dbName);
    if (dbSchema != null) {
        Function<List<JsonNode>, List<OperationResult>> rowFunction = (input -> {
            log.debug("Get ovsdb operation result");
            List<OperationResult> result = FromJsonUtil.jsonNodeToOperationResult(input, operations);
            if (result == null) {
                log.debug("The operation result is null");
                return null;
            }
            return result;
        });
        return Futures.transform(transact(dbSchema, operations), rowFunction);
    }
    return null;
}
#end_block

#method_before
@Override
public String getPonLinks(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return reply;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(VOLT_NE_OPEN).append(VOLT_NE_NAMESPACE);
        request.append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(VOLT_PORTS));
        if (target != null) {
            try {
                pon = Integer.parseInt(target);
            } catch (NumberFormatException e) {
                log.error("Non-number input");
                return reply;
            }
            request.append(buildStartTag(GPON_PONLINK_PORTS));
            request.append(buildStartTag(GPON_PONLINK_PORT));
            request.append(buildStartTag(PONLINK_ID, false));
            request.append(target);
            request.append(buildEndTag(PONLINK_ID));
            request.append(buildEndTag(GPON_PONLINK_PORT));
            request.append(buildEndTag(GPON_PONLINK_PORTS));
        } else {
            request.append(buildEmptyTag(GPON_PONLINK_PORTS));
        }
        request.append(buildEndTag(VOLT_PORTS));
        request.append(VOLT_NE_CLOSE);
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().get(request.toString(), REPORT_ALL);
    } catch (IOException e) {
        log.error("Cannot communicate to device {} ", ncDeviceId);
    }
    return reply;
}
#method_after
@Override
public String getPonLinks(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    String reply = null;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return reply;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(VOLT_NE_OPEN).append(VOLT_NE_NAMESPACE);
        request.append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(VOLT_PORTS));
        if (target != null) {
            try {
                pon = Integer.parseInt(target);
            } catch (NumberFormatException e) {
                log.error("Non-number input");
                return reply;
            }
            request.append(buildStartTag(GPON_PONLINK_PORTS));
            request.append(buildStartTag(GPON_PONLINK_PORT));
            request.append(buildStartTag(PONLINK_ID, false));
            request.append(target);
            request.append(buildEndTag(PONLINK_ID));
            request.append(buildEndTag(GPON_PONLINK_PORT));
            request.append(buildEndTag(GPON_PONLINK_PORTS));
        } else {
            request.append(buildEmptyTag(GPON_PONLINK_PORTS));
        }
        request.append(buildEndTag(VOLT_PORTS));
        request.append(VOLT_NE_CLOSE);
        reply = controller.getDevicesMap().get(ncDeviceId).getSession().get(request.toString(), REPORT_ALL);
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception ", ncDeviceId, e);
    }
    return reply;
}
#end_block

#method_before
@Override
public void setPonLink(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    int count;
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return;
    }
    String[] data = target.split(COLON);
    if (data.length != 3) {
        log.error("Invalid number of arguments");
        return;
    }
    try {
        pon = Integer.parseInt(data[0]);
    } catch (NumberFormatException e) {
        log.error("Non-number input");
        return;
    }
    for (count = 0; count < PON_LINK_PARAMS.length; count++) {
        if (PON_LINK_PARAMS[count].equals(data[1])) {
            break;
        }
    }
    if (count >= PON_LINK_PARAMS.length) {
        log.error("Unsupported parameter: {} ", data[1]);
        return;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(VOLT_NE_OPEN).append(VOLT_NE_NAMESPACE);
        request.append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(VOLT_PORTS));
        request.append(buildStartTag(GPON_PONLINK_PORTS));
        request.append(buildStartTag(GPON_PONLINK_PORT));
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(data[0]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(data[1], false));
        request.append(data[2]);
        request.append(buildEndTag(data[1]));
        request.append(buildEndTag(GPON_PONLINK_PORT));
        request.append(buildEndTag(GPON_PONLINK_PORTS));
        request.append(buildEndTag(VOLT_PORTS));
        request.append(VOLT_NE_CLOSE);
        controller.getDevicesMap().get(ncDeviceId).getSession().editConfig(RUNNING, null, request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} ", ncDeviceId);
    }
    return;
}
#method_after
@Override
public void setPonLink(String target) {
    DriverHandler handler = handler();
    NetconfController controller = handler.get(NetconfController.class);
    MastershipService mastershipService = handler.get(MastershipService.class);
    DeviceId ncDeviceId = handler.data().deviceId();
    checkNotNull(controller, "Netconf controller is null");
    if (!mastershipService.isLocalMaster(ncDeviceId)) {
        log.warn("Not master for {} Use {} to execute command", ncDeviceId, mastershipService.getMasterFor(ncDeviceId));
        return;
    }
    String[] data = target.split(COLON);
    if (data.length != 3) {
        log.error("Invalid number of arguments");
        return;
    }
    try {
        pon = Integer.parseInt(data[0]);
    } catch (NumberFormatException e) {
        log.error("Non-number input");
        return;
    }
    if (!ponLinkParams.contains(data[1])) {
        log.error("Unsupported parameter: {} ", data[1]);
        return;
    }
    try {
        StringBuilder request = new StringBuilder();
        request.append(VOLT_NE_OPEN).append(VOLT_NE_NAMESPACE);
        request.append(ANGLE_RIGHT).append(NEW_LINE);
        request.append(buildStartTag(VOLT_PORTS));
        request.append(buildStartTag(GPON_PONLINK_PORTS));
        request.append(buildStartTag(GPON_PONLINK_PORT));
        request.append(buildStartTag(PONLINK_ID, false));
        request.append(data[0]);
        request.append(buildEndTag(PONLINK_ID));
        request.append(buildStartTag(data[1], false));
        request.append(data[2]);
        request.append(buildEndTag(data[1]));
        request.append(buildEndTag(GPON_PONLINK_PORT));
        request.append(buildEndTag(GPON_PONLINK_PORTS));
        request.append(buildEndTag(VOLT_PORTS));
        request.append(VOLT_NE_CLOSE);
        controller.getDevicesMap().get(ncDeviceId).getSession().editConfig(RUNNING, null, request.toString());
    } catch (IOException e) {
        log.error("Cannot communicate to device {} exception ", ncDeviceId, e);
    }
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    configRegistry.removeListener(configListener);
    deviceService.removeListener(deviceListener);
    nodeStore.removeListener(nodeStoreListener);
    leadershipService.withdraw(appId.name());
    eventExecutor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    configRegistry.removeListener(configListener);
    deviceService.removeListener(deviceListener);
    nodeStore.removeListener(nodeStoreListener);
    componentConfigService.unregisterProperties(getClass(), true);
    configRegistry.unregisterConfigFactory(configFactory);
    leadershipService.withdraw(appId.name());
    eventExecutor.shutdown();
    log.info("Stopped");
}
#end_block

#method_before
@Override
public boolean isComplete(String hostname) {
    Versioned<OpenstackNode> versionedNode = nodeStore.get(hostname);
    OpenstackNodeState state = versionedNode.value().state();
    return state != null && state.equals(NodeState.COMPLETE);
}
#method_after
@Override
public boolean isComplete(String hostname) {
    Versioned<OpenstackNode> versionedNode = nodeStore.get(hostname);
    if (versionedNode == null) {
        log.warn("Node {} does not exist", hostname);
        return false;
    }
    OpenstackNodeState state = versionedNode.value().state();
    return state != null && state.equals(NodeState.COMPLETE);
}
#end_block

#method_before
@Override
public IpAddress dataIp(DeviceId deviceId) {
    OpenstackNode node = nodeByDeviceId(deviceId);
    if (node == null) {
        log.warn("Failed to get node for {}", deviceId);
        return null;
    }
    return node.dataIp();
}
#method_after
@Override
public Optional<IpAddress> dataIp(DeviceId deviceId) {
    OpenstackNode node = nodeByDeviceId(deviceId);
    if (node == null) {
        log.warn("Failed to get node for {}", deviceId);
        return Optional.empty();
    }
    return Optional.of(node.dataIp());
}
#end_block

#method_before
@Override
public PortNumber tunnelPort(DeviceId deviceId) {
    PortNumber port = deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(PORT_NAME).equals(DEFAULT_TUNNEL) && p.isEnabled()).map(Port::number).findFirst().orElse(null);
    return port == null ? null : port;
}
#method_after
@Override
public Optional<PortNumber> tunnelPort(DeviceId deviceId) {
    return deviceService.getPorts(deviceId).stream().filter(p -> p.annotations().value(PORT_NAME).equals(DEFAULT_TUNNEL) && p.isEnabled()).map(Port::number).findFirst();
}
#end_block

#method_before
@Override
public Optional<PortNumber> externalPort(DeviceId intBridgeId) {
    PortNumber port = deviceService.getPorts(intBridgeId).stream().filter(p -> p.annotations().value(PORT_NAME).equals(PATCH_INTG_BRIDGE) && p.isEnabled()).map(Port::number).findFirst().orElse(null);
    return Optional.ofNullable(port);
}
#method_after
@Override
public Optional<PortNumber> externalPort(DeviceId intBridgeId) {
    return deviceService.getPorts(intBridgeId).stream().filter(p -> p.annotations().value(PORT_NAME).equals(PATCH_INTG_BRIDGE) && p.isEnabled()).map(Port::number).findFirst();
}
#end_block

#method_before
private void createTunnelInterface(OpenstackNode node) {
    Device device = deviceService.getDevice(node.ovsdbId());
    if (device == null || !device.is(InterfaceConfig.class)) {
        log.error("Failed to create tunnel interface on {}", node.ovsdbId());
        return;
    }
    TunnelDescription tunnelDesc = DefaultTunnelDescription.builder().name(DEFAULT_TUNNEL).type(VXLAN).enableFlowDst().enableFlowKey().build();
    InterfaceConfig ifaceConfig = device.as(InterfaceConfig.class);
    ifaceConfig.addTunnelInterface(BridgeName.of(INTEGRATION_BRIDGE), tunnelDesc);
}
#method_after
private void createTunnelInterface(OpenstackNode node) {
    Device device = deviceService.getDevice(node.ovsdbId());
    if (device == null || !device.is(InterfaceConfig.class)) {
        log.error("Failed to create tunnel interface on {}", node.ovsdbId());
        return;
    }
    TunnelDescription tunnelDesc = DefaultTunnelDescription.builder().deviceId(INTEGRATION_BRIDGE).ifaceName(DEFAULT_TUNNEL).type(VXLAN).remote(TunnelEndPoints.flowTunnelEndpoint()).key(TunnelKeys.flowTunnelKey()).build();
    InterfaceConfig ifaceConfig = device.as(InterfaceConfig.class);
    ifaceConfig.addTunnelMode(DEFAULT_TUNNEL, tunnelDesc);
}
#end_block

#method_before
private void createPatchInterface(OpenstackNode node) {
    Device device = deviceService.getDevice(node.ovsdbId());
    if (device == null || !device.is(InterfaceConfig.class)) {
        log.error("Failed to create patch interfaces on {}", node.hostname());
        return;
    }
    PatchDescription patchIntg = DefaultPatchDescription.builder().name(PATCH_INTG_BRIDGE).peer(PATCH_ROUT_BRIDGE).build();
    PatchDescription patchRout = DefaultPatchDescription.builder().name(PATCH_ROUT_BRIDGE).peer(PATCH_INTG_BRIDGE).build();
    InterfaceConfig ifaceConfig = device.as(InterfaceConfig.class);
    ifaceConfig.addPatchInterface(BridgeName.of(INTEGRATION_BRIDGE), patchIntg);
    ifaceConfig.addPatchInterface(BridgeName.of(ROUTER_BRIDGE), patchRout);
}
#method_after
private void createPatchInterface(OpenstackNode node) {
    Device device = deviceService.getDevice(node.ovsdbId());
    if (device == null || !device.is(InterfaceConfig.class)) {
        log.error("Failed to create patch interfaces on {}", node.hostname());
        return;
    }
    PatchDescription patchIntg = DefaultPatchDescription.builder().deviceId(INTEGRATION_BRIDGE).ifaceName(PATCH_INTG_BRIDGE).peer(PATCH_ROUT_BRIDGE).build();
    PatchDescription patchRout = DefaultPatchDescription.builder().deviceId(ROUTER_BRIDGE).ifaceName(PATCH_ROUT_BRIDGE).peer(PATCH_INTG_BRIDGE).build();
    InterfaceConfig ifaceConfig = device.as(InterfaceConfig.class);
    ifaceConfig.addPatchMode(PATCH_INTG_BRIDGE, patchIntg);
    ifaceConfig.addPatchMode(PATCH_ROUT_BRIDGE, patchRout);
}
#end_block

#method_before
@Override
public void event(MapEvent<String, OpenstackNode> event) {
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    if (!Objects.equals(localNodeId, leaderNodeId)) {
        // do not allow to proceed without leadership
        return;
    }
    OpenstackNode oldNode;
    OpenstackNode newNode;
    switch(event.type()) {
        case UPDATE:
            oldNode = event.oldValue().value();
            newNode = event.newValue().value();
            log.info("Reloaded {}", newNode.hostname());
            if (!newNode.equals(oldNode)) {
                log.debug("New node: {}", newNode);
            }
            // performs init procedure even if the node is not changed
            // for robustness since it's no harm to run init procedure
            // multiple times
            eventExecutor.execute(() -> initNode(newNode));
            break;
        case INSERT:
            newNode = event.newValue().value();
            log.info("Added {}", newNode.hostname());
            eventExecutor.execute(() -> initNode(newNode));
            break;
        case REMOVE:
            oldNode = event.oldValue().value();
            log.info("Removed {}", oldNode.hostname());
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(MapEvent<String, OpenstackNode> event) {
    NodeId leaderNodeId = leadershipService.getLeader(appId.name());
    if (!Objects.equals(localNodeId, leaderNodeId)) {
        // do not allow to proceed without leadership
        return;
    }
    OpenstackNode oldNode;
    OpenstackNode newNode;
    switch(event.type()) {
        case UPDATE:
            oldNode = event.oldValue().value();
            newNode = event.newValue().value();
            log.debug("Reloaded {}", newNode.hostname());
            if (!newNode.equals(oldNode)) {
                log.debug("New node: {}", newNode);
            }
            // performs init procedure even if the node is not changed
            // for robustness since it's no harm to run init procedure
            // multiple times
            eventExecutor.execute(() -> initNode(newNode));
            break;
        case INSERT:
            newNode = event.newValue().value();
            log.info("Added {}", newNode.hostname());
            eventExecutor.execute(() -> initNode(newNode));
            break;
        case REMOVE:
            oldNode = event.oldValue().value();
            log.info("Removed {}", oldNode.hostname());
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public boolean isValid() {
    boolean result = hasOnlyFields(NODES);
    if (object.get(NODES) == null || object.get(NODES).size() < 1) {
        final String msg = "No node is present";
        throw new IllegalArgumentException(msg);
    }
    for (JsonNode node : object.get(NODES)) {
        ObjectNode osNode = (ObjectNode) node;
        result = result && hasOnlyFields(osNode, HOST_NAME, TYPE, MANAGEMENT_IP, DATA_IP, INTEGRATION_BRIDGE, ROUTER_BRIDGE);
        result = result && isString(osNode, HOST_NAME, MANDATORY);
        result = result && isString(osNode, TYPE, MANDATORY);
        result = result && isIpAddress(osNode, MANAGEMENT_IP, MANDATORY);
        result = result && isIpAddress(osNode, DATA_IP, MANDATORY);
        result = result && isString(osNode, INTEGRATION_BRIDGE, MANDATORY);
        DeviceId.deviceId(osNode.get(INTEGRATION_BRIDGE).asText());
        NodeType.valueOf(osNode.get(TYPE).asText());
        if (osNode.get(TYPE).asText().equals(GATEWAY.name())) {
            result = result && isString(osNode, ROUTER_BRIDGE, MANDATORY);
            DeviceId.deviceId(osNode.get(ROUTER_BRIDGE).asText());
        }
    }
    return result;
}
#method_after
@Override
public boolean isValid() {
    boolean result = hasOnlyFields(NODES);
    if (object.get(NODES) == null || object.get(NODES).size() < 1) {
        final String msg = "No node is present";
        throw new IllegalArgumentException(msg);
    }
    for (JsonNode node : object.get(NODES)) {
        ObjectNode osNode = (ObjectNode) node;
        result &= hasOnlyFields(osNode, HOST_NAME, TYPE, MANAGEMENT_IP, DATA_IP, INTEGRATION_BRIDGE, ROUTER_BRIDGE);
        result &= isString(osNode, HOST_NAME, MANDATORY);
        result &= isString(osNode, TYPE, MANDATORY);
        result &= isIpAddress(osNode, MANAGEMENT_IP, MANDATORY);
        result &= result && isIpAddress(osNode, DATA_IP, MANDATORY);
        result &= isString(osNode, INTEGRATION_BRIDGE, MANDATORY);
        DeviceId.deviceId(osNode.get(INTEGRATION_BRIDGE).asText());
        NodeType.valueOf(osNode.get(TYPE).asText());
        if (osNode.get(TYPE).asText().equals(GATEWAY.name())) {
            result &= isString(osNode, ROUTER_BRIDGE, MANDATORY);
            DeviceId.deviceId(osNode.get(ROUTER_BRIDGE).asText());
        }
    }
    return result;
}
#end_block

#method_before
public String value() {
    return value.toString();
}
#method_after
public T value() {
    return value;
}
#end_block

#method_before
public String value() {
    return value.toString();
}
#method_after
public T value() {
    return value;
}
#end_block

#method_before
@Deprecated
@Override
public boolean createTunnel(String bridgeName, String ifaceName, String tunnelType, Map<String, String> options) {
    OvsdbInterface ovsdbIface = OvsdbInterface.builder().name(ifaceName).type(OvsdbInterface.Type.valueOf(tunnelType)).options(options).build();
    return createInterface(bridgeName, ovsdbIface);
}
#method_after
@Deprecated
@Override
public boolean createTunnel(String bridgeName, String ifaceName, String tunnelType, Map<String, String> options) {
    OvsdbInterface ovsdbIface = OvsdbInterface.builder().name(ifaceName).type(Type.valueOf(tunnelType)).options(options).build();
    return createInterface(bridgeName, ovsdbIface);
}
#end_block

#method_before
@Override
public boolean dropInterface(String bridgeName, String name) {
    String bridgeUuid = getBridgeUuid(bridgeName);
    if (bridgeUuid == null) {
        log.warn("Could not find bridge {} in {}", bridgeName, nodeId.getIpAddress());
        return false;
    }
    String portUuid = getPortUuid(name, bridgeUuid);
    if (portUuid != null) {
        log.info("Delete interface {}", name);
        deleteConfig(PORT, UUID, portUuid, BRIDGE, PORTS);
        return true;
    }
    return false;
}
#method_after
@Override
public boolean dropInterface(String ifaceName) {
    OvsdbRowStore rowStore = getRowStore(DATABASENAME, BRIDGE);
    if (rowStore == null) {
        log.warn("Failed to get BRIDGE table");
        return false;
    }
    ConcurrentMap<String, Row> bridgeTableRows = rowStore.getRowStore();
    if (bridgeTableRows == null) {
        log.warn("Failed to get BRIDGE table rows");
        return false;
    }
    // interface name is unique
    Optional<String> bridgeId = bridgeTableRows.keySet().stream().filter(uuid -> getPortUuid(ifaceName, uuid) != null).findFirst();
    if (bridgeId.isPresent()) {
        String portId = getPortUuid(ifaceName, bridgeId.get());
        deleteConfig(PORT, UUID, portId, BRIDGE, PORTS);
        return true;
    } else {
        log.warn("Unable to find the interface with name {}", ifaceName);
        return false;
    }
}
#end_block

#method_before
@Override
public boolean addAccessInterface(DeviceId deviceId, String intf, VlanId vlanId) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.requestSync(addAccessInterfaceBuilder(intf, vlanId));
    } catch (NetconfException e) {
        log.error("Failed to configure VLAN ID {} on device {} interface {}.", vlanId, deviceId, intf, e);
        return false;
    }
    return XmlConfigParser.configSuccess(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))));
}
#method_after
@Override
public boolean addAccessInterface(DeviceId deviceId, String intf, VlanId vlanId) {
    return addAccessMode(intf, vlanId);
}
#end_block

#method_before
@Override
public boolean removeAccessInterface(DeviceId deviceId, String intf) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.requestSync(removeAccessInterfaceBuilder(intf));
    } catch (NetconfException e) {
        log.error("Failed to remove access mode from device {} interface {}.", deviceId, intf, e);
        return false;
    }
    return XmlConfigParser.configSuccess(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))));
}
#method_after
@Override
public boolean removeAccessInterface(DeviceId deviceId, String intf) {
    return removeAccessMode(intf);
}
#end_block

#method_before
@Override
public boolean addTrunkInterface(DeviceId deviceId, String intf, List<VlanId> vlanIds) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.requestSync(addTrunkInterfaceBuilder(intf, vlanIds));
    } catch (NetconfException e) {
        log.error("Failed to configure trunk mode for VLAN ID {} on device {} interface {}.", vlanIds, deviceId, intf, e);
        return false;
    }
    return XmlConfigParser.configSuccess(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))));
}
#method_after
@Override
public boolean addTrunkInterface(DeviceId deviceId, String intf, List<VlanId> vlanIds) {
    return addTrunkMode(intf, vlanIds);
}
#end_block

#method_before
@Override
public boolean removeTrunkInterface(DeviceId deviceId, String intf) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.requestSync(removeTrunkInterfaceBuilder(intf));
    } catch (NetconfException e) {
        log.error("Failed to remove trunk mode on device {} interface {}.", deviceId, intf, e);
        return false;
    }
    return XmlConfigParser.configSuccess(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))));
}
#method_after
@Override
public boolean removeTrunkInterface(DeviceId deviceId, String intf) {
    return removeTrunkMode(intf);
}
#end_block

#method_before
@Override
public List<DeviceInterfaceDescription> getInterfaces(DeviceId deviceId) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.requestSync(getConfigBuilder());
    } catch (NetconfException e) {
        log.error("Failed to retrieve configuration from device {}.", deviceId, e);
        return null;
    }
    return XmlParserCisco.getInterfacesFromConfig(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))));
}
#method_after
@Override
public List<DeviceInterfaceDescription> getInterfaces(DeviceId deviceId) {
    return getInterfaces();
}
#end_block

#method_before
@Override
public List<DeviceInterfaceDescription> getInterfaces(DeviceId deviceId) {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.requestSync(getConfigBuilder());
    } catch (NetconfException e) {
        log.error("Failed to retrieve configuration from device {}.", deviceId, e);
        return null;
    }
    return XmlParserCisco.getInterfacesFromConfig(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))));
}
#method_after
@Override
public List<DeviceInterfaceDescription> getInterfaces() {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.requestSync(getConfigBuilder());
    } catch (NetconfException e) {
        log.error("Failed to retrieve configuration from device {}.", handler().data().deviceId(), e);
        return null;
    }
    return XmlParserCisco.getInterfacesFromConfig(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))));
}
#end_block

#method_before
private void createTunnelInterface(OpenstackNode node) {
    if (checkTunnelInterface(node)) {
        return;
    }
    TunnelDescription description = DefaultTunnelDescription.builder().name(DEFAULT_TUNNEL).type(VXLAN).enableFlowDst().enableFlowKey().build();
    try {
        DriverHandler handler = driverService.createHandler(node.ovsdbId());
        InterfaceConfig ifaceConfig = handler.behaviour(InterfaceConfig.class);
        ifaceConfig.addTunnelInterface(BridgeName.of(DEFAULT_BRIDGE), description);
    } catch (ItemNotFoundException e) {
        log.warn("Failed to create tunnel interface on {}", node.ovsdbId());
    }
}
#method_after
private void createTunnelInterface(OpenstackNode node) {
    if (checkTunnelInterface(node)) {
        return;
    }
    TunnelDescription description = DefaultTunnelDescription.builder().deviceId(DEFAULT_BRIDGE).ifaceName(DEFAULT_TUNNEL).type(VXLAN).remote(TunnelEndPoints.flowTunnelEndpoint()).key(TunnelKeys.flowTunnelKey()).build();
    try {
        DriverHandler handler = driverService.createHandler(node.ovsdbId());
        InterfaceConfig ifaceConfig = handler.behaviour(InterfaceConfig.class);
        ifaceConfig.addTunnelMode(DEFAULT_TUNNEL, description);
    } catch (ItemNotFoundException e) {
        log.warn("Failed to create tunnel interface on {}", node.ovsdbId());
    }
}
#end_block

#method_before
@Override
public List<DeviceInterfaceDescription> getInterfaces(BridgeName bridgeName) {
    // TODO implement
    throw new UnsupportedOperationException("Not implemented yet");
}
#method_after
@Override
public List<DeviceInterfaceDescription> getInterfaces() {
    // TODO implement
    throw new UnsupportedOperationException("Not implemented yet");
}
#end_block

#method_before
@Override
public boolean addAccessInterface(BridgeName bridgeName, String ifaceName, VlanId vlanId) {
    // TODO implement
    throw new UnsupportedOperationException("Not implemented yet");
}
#method_after
@Override
public boolean addAccessInterface(DeviceId deviceId, String ifaceName, VlanId vlanId) {
    throw new UnsupportedOperationException("Not implemented yet");
}
#end_block

#method_before
@Override
public boolean removeAccessInterface(BridgeName bridgeName, String ifaceName) {
    // TODO implement
    throw new UnsupportedOperationException("Not implemented yet");
}
#method_after
@Override
public boolean removeAccessInterface(DeviceId deviceId, String ifaceName) {
    throw new UnsupportedOperationException("Not implemented yet");
}
#end_block

#method_before
@Override
public boolean addTrunkInterface(BridgeName bridgeName, String ifaceName, List<VlanId> vlanIds) {
    // TODO implement
    throw new UnsupportedOperationException("Not implemented yet");
}
#method_after
@Override
public boolean addTrunkInterface(DeviceId deviceId, String ifaceName, List<VlanId> vlanIds) {
    throw new UnsupportedOperationException("Not implemented yet");
}
#end_block

#method_before
@Override
public boolean removeTrunkInterface(BridgeName bridgeName, String ifaceName) {
    // TODO implement
    throw new UnsupportedOperationException("Not implemented yet");
}
#method_after
@Override
public boolean removeTrunkInterface(DeviceId deviceId, String ifaceName) {
    throw new UnsupportedOperationException("Not implemented yet");
}
#end_block

#method_before
@Override
public boolean createInterface(String bridgeName, OvsdbInterface ovsdbIface) {
    return false;
}
#method_after
@Override
public boolean createInterface(String bridgeName, OvsdbInterface ovsdbIface) {
    return true;
}
#end_block

#method_before
@Override
public boolean dropInterface(String bridgeName, String name) {
    return false;
}
#method_after
@Override
public boolean dropInterface(String name) {
    return true;
}
#end_block

#method_before
@Override
public Optional<TunnelEndPoint> src() {
    return src;
}
#method_after
@Deprecated
@Override
public TunnelEndPoint src() {
    return local.isPresent() ? local.get() : null;
}
#end_block

#method_before
@Override
public Optional<TunnelEndPoint> dst() {
    return dst;
}
#method_after
@Deprecated
@Override
public TunnelEndPoint dst() {
    return remote.isPresent() ? remote.get() : null;
}
#end_block

#method_before
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("name", name).add("type", type).add("src", src).add("dst", dst).add("key", key).toString();
}
#method_after
@Override
public String toString() {
    return MoreObjects.toStringHelper(this).add("deviceId", deviceId).add("ifaceName", ifaceName).add("type", type).add("local", local).add("remote", remote).add("key", key).toString();
}
#end_block

#method_before
@Override
public TunnelDescription build() {
    return new DefaultTunnelDescription(name, type, src, dst, key);
}
#method_after
@Override
public TunnelDescription build() {
    if (otherConfigs.isPresent()) {
        return new DefaultTunnelDescription(deviceId, ifaceName, type, local, remote, key, otherConfigs.get());
    } else {
        return new DefaultTunnelDescription(deviceId, ifaceName, type, local, remote, key);
    }
}
#end_block

#method_before
@Override
public Builder key(long key) {
    this.key = Optional.of(new TunnelKey(key));
    return this;
}
#method_after
@Override
public Builder key(TunnelKey key) {
    this.key = Optional.ofNullable(key);
    return this;
}
#end_block

#method_before
public static void applyBridgeConfig(DriverHandler handler, String dpid, String exPortName) {
    BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
    BridgeDescription bridgeDesc = DefaultBridgeDescription.builder().name(DEFAULT_BRIDGE_NAME).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().enableLocalController().build();
    bridgeConfig.addBridge(bridgeDesc);
    bridgeConfig.addPort(BridgeName.of(DEFAULT_BRIDGE_NAME), exPortName);
}
#method_after
public static void applyBridgeConfig(DriverHandler handler, String dpid, String exPortName) {
    BridgeConfig bridgeConfig = handler.behaviour(BridgeConfig.class);
    BridgeDescription bridgeDesc = DefaultBridgeDescription.builder().name(DEFAULT_BRIDGE_NAME).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().enableLocalController().build();
    bridgeConfig.addBridge(bridgeDesc);
    bridgeConfig.addPort(BridgeName.bridgeName(DEFAULT_BRIDGE_NAME), exPortName);
}
#end_block

#method_before
public static void applyTunnelConfig(DriverHandler handler, IpAddress srcIp) {
    InterfaceConfig interfaceConfig = handler.behaviour(InterfaceConfig.class);
    TunnelDescription tunnel = DefaultTunnelDescription.builder().name(DEFAULT_TUNNEL).type(TunnelDescription.Type.VXLAN).src(srcIp).enableFlowDst().enableFlowKey().build();
    interfaceConfig.addTunnelInterface(BridgeName.of(DEFAULT_BRIDGE_NAME), tunnel);
}
#method_after
public static void applyTunnelConfig(DriverHandler handler, IpAddress srcIp) {
    DefaultAnnotations.Builder optionBuilder = DefaultAnnotations.builder();
    for (String key : DEFAULT_TUNNEL_OPTIONS.keySet()) {
        optionBuilder.set(key, DEFAULT_TUNNEL_OPTIONS.get(key));
    }
    InterfaceConfig interfaceConfig = handler.behaviour(InterfaceConfig.class);
    TunnelDescription tunnel = DefaultTunnelDescription.builder().deviceId(DEFAULT_BRIDGE_NAME).ifaceName(DEFAULT_TUNNEL).type(TunnelDescription.Type.VXLAN).local(TunnelEndPoints.ipTunnelEndpoint(srcIp)).remote(TunnelEndPoints.flowTunnelEndpoint()).key(TunnelKeys.flowTunnelKey()).otherConfigs(optionBuilder.build()).build();
    interfaceConfig.addTunnelMode(DEFAULT_TUNNEL, tunnel);
}
#end_block

#method_before
public static void removeTunnelConfig(DriverHandler handler) {
    InterfaceConfig interfaceConfig = handler.behaviour(InterfaceConfig.class);
    interfaceConfig.removeTunnelInterface(BridgeName.of(DEFAULT_BRIDGE_NAME), DEFAULT_TUNNEL);
}
#method_after
public static void removeTunnelConfig(DriverHandler handler) {
    InterfaceConfig interfaceConfig = handler.behaviour(InterfaceConfig.class);
    interfaceConfig.removeTunnelMode(DEFAULT_TUNNEL);
}
#end_block

#method_before
public void requestPacket(ApplicationId appId) {
    TrafficSelector arpSelector = DefaultTrafficSelector.builder().matchEthType(EthType.EtherType.ARP.ethType().toShort()).build();
    if (config.getScalableGateway()) {
        gatewayService.getGatewayDeviceIds().forEach(deviceId -> packetService.requestPackets(arpSelector, PacketPriority.CONTROL, appId, Optional.of(deviceId)));
    } else {
        packetService.requestPackets(arpSelector, PacketPriority.CONTROL, appId, Optional.of(DeviceId.deviceId(config.gatewayBridgeId())));
    }
}
#method_after
public void requestPacket(ApplicationId appId) {
    TrafficSelector arpSelector = DefaultTrafficSelector.builder().matchEthType(EthType.EtherType.ARP.ethType().toShort()).build();
    getExternalInfo().forEach(deviceId -> packetService.requestPackets(arpSelector, PacketPriority.CONTROL, appId, Optional.of(deviceId)));
}
#end_block

#method_before
public void processArpPacketFromRouter(PacketContext context, Ethernet ethernet) {
    checkNotNull(context, "context can not be null");
    checkNotNull(ethernet, "ethernet can not be null");
    ARP arp = (ARP) ethernet.getPayload();
    log.debug("arpEvent called from {} to {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
    if (arp.getOpCode() != ARP.OP_REQUEST) {
        return;
    }
    IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    MacAddress targetMac = getTargetMacForTargetIp(targetIp.getIp4Address());
    if (targetMac == MacAddress.NONE) {
        return;
    }
    Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
    packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
}
#method_after
public void processArpPacketFromRouter(PacketContext context, Ethernet ethernet) {
    checkNotNull(context, "context can not be null");
    checkNotNull(ethernet, "ethernet can not be null");
    ARP arp = (ARP) ethernet.getPayload();
    log.debug("arpEvent called from {} to {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
    if (arp.getOpCode() != ARP.OP_REQUEST) {
        return;
    }
    IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    if (getTargetMacForTargetIp(targetIp.getIp4Address()) == MacAddress.NONE) {
        return;
    }
    MacAddress targetMac = MacAddress.valueOf(config.gatewayExternalInterfaceMac());
    Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
    packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
}
#end_block

#method_before
private MacAddress getTargetMacForTargetIp(Ip4Address targetIp) {
    OpenstackPort port = openstackService.ports().stream().filter(p -> p.deviceOwner().equals(NETWORK_ROUTER_GATEWAY)).filter(p -> p.fixedIps().containsValue(targetIp.getIp4Address())).findAny().orElse(null);
    if (port == null) {
        return MacAddress.NONE;
    }
    return port.macAddress();
}
#method_after
private MacAddress getTargetMacForTargetIp(Ip4Address targetIp) {
    OpenstackPort port = openstackService.ports().stream().filter(p -> p.deviceOwner().equals(NETWORK_ROUTER_GATEWAY) || p.deviceOwner().equals(NETWORK_FLOATING_IP)).filter(p -> p.fixedIps().containsValue(targetIp.getIp4Address())).findAny().orElse(null);
    if (port == null) {
        return MacAddress.NONE;
    }
    return port.macAddress();
}
#end_block

#method_before
public void requestPacket(ApplicationId appId) {
    TrafficSelector icmpSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).build();
    if (config.getScalableGateway()) {
        gatewayService.getGatewayDeviceIds().forEach(deviceId -> packetService.requestPackets(icmpSelector, PacketPriority.CONTROL, appId, Optional.of(deviceId)));
    } else {
        packetService.requestPackets(icmpSelector, PacketPriority.CONTROL, appId, Optional.of(DeviceId.deviceId(config.gatewayBridgeId())));
    }
}
#method_after
public void requestPacket(ApplicationId appId) {
    TrafficSelector icmpSelector = DefaultTrafficSelector.builder().matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(IPv4.PROTOCOL_ICMP).build();
    Map<DeviceId, PortNumber> externalInfoMap = getExternalInfo();
    externalInfoMap.keySet().forEach(deviceId -> packetService.requestPackets(icmpSelector, PacketPriority.CONTROL, appId, Optional.of(deviceId)));
}
#end_block

#method_before
public void processIcmpPacket(PacketContext context, Ethernet ethernet) {
    checkNotNull(context, "context can not be null");
    checkNotNull(ethernet, "ethernet can not be null");
    IPv4 ipPacket = (IPv4) ethernet.getPayload();
    log.debug("icmpEvent called from ip {}, mac {}", Ip4Address.valueOf(ipPacket.getSourceAddress()).toString(), ethernet.getSourceMAC().toString());
    ICMP icmp = (ICMP) ipPacket.getPayload();
    short icmpId = getIcmpId(icmp);
    DeviceId deviceId = context.inPacket().receivedFrom().deviceId();
    if (icmp.getIcmpType() == ICMP.TYPE_ECHO_REQUEST) {
        // TODO: Considers icmp between internal subnets which are belonged to the same router.
        OpenstackPortInfo openstackPortInfo = getOpenstackPortInfo(Ip4Address.valueOf(ipPacket.getSourceAddress()), ethernet.getSourceMAC());
        checkNotNull(openstackPortInfo, "openstackPortInfo can not be null");
        if (ipPacket.getDestinationAddress() == openstackPortInfo.gatewayIP().toInt()) {
            processIcmpPacketSentToGateway(ipPacket, icmp, openstackPortInfo);
        } else {
            Ip4Address pNatIpAddress = pNatIpForPort(openstackPortInfo);
            checkNotNull(pNatIpAddress, "pNatIpAddress can not be null");
            sendRequestPacketToExt(ipPacket, icmp, deviceId, pNatIpAddress);
            String icmpInfoKey = String.valueOf(icmpId).concat(String.valueOf(pNatIpAddress.toInt())).concat(String.valueOf(ipPacket.getDestinationAddress()));
            icmpInfoMap.putIfAbsent(icmpInfoKey, openstackPortInfo);
        }
    } else if (icmp.getIcmpType() == ICMP.TYPE_ECHO_REPLY) {
        String icmpInfoKey = String.valueOf(icmpId).concat(String.valueOf(ipPacket.getDestinationAddress())).concat(String.valueOf(ipPacket.getSourceAddress()));
        processResponsePacketFromExternalToHost(ipPacket, icmp, icmpInfoMap.get(icmpInfoKey));
        icmpInfoMap.remove(icmpInfoKey);
    }
}
#method_after
public void processIcmpPacket(PacketContext context, Ethernet ethernet) {
    checkNotNull(context, "context can not be null");
    checkNotNull(ethernet, "ethernet can not be null");
    IPv4 ipPacket = (IPv4) ethernet.getPayload();
    log.debug("icmpEvent called from ip {}, mac {}", Ip4Address.valueOf(ipPacket.getSourceAddress()).toString(), ethernet.getSourceMAC().toString());
    ICMP icmp = (ICMP) ipPacket.getPayload();
    short icmpId = getIcmpId(icmp);
    DeviceId deviceId = context.inPacket().receivedFrom().deviceId();
    PortNumber portNumber = context.inPacket().receivedFrom().port();
    if (icmp.getIcmpType() == ICMP.TYPE_ECHO_REQUEST) {
        // TODO: Considers icmp between internal subnets which are belonged to the same router.
        OpenstackPortInfo openstackPortInfo = getOpenstackPortInfo(Ip4Address.valueOf(ipPacket.getSourceAddress()), ethernet.getSourceMAC());
        // checkNotNull(openstackPortInfo, "openstackPortInfo can not be null");
        if (requestToOpenstackRoutingNetwork(ipPacket.getDestinationAddress())) {
            if (openstackPortInfo == null) {
                if (config.gatewayBridgeId().equals(context.inPacket().receivedFrom().deviceId().toString())) {
                    if (portNumber.equals(getPortForAnnotationPortName(deviceId, config.gatewayExternalInterfaceName()))) {
                        processIcmpPacketSentToExtenal(ipPacket, icmp, ipPacket.getSourceAddress(), ethernet.getSourceMAC(), deviceId, portNumber);
                        return;
                    }
                }
                return;
            } else {
                processIcmpPacketSentToGateway(ipPacket, icmp, openstackPortInfo);
                return;
            }
        }
        if (ipPacket.getDestinationAddress() == openstackPortInfo.gatewayIP().toInt()) {
            processIcmpPacketSentToGateway(ipPacket, icmp, openstackPortInfo);
        } else {
            Ip4Address pNatIpAddress = pNatIpForPort(openstackPortInfo);
            checkNotNull(pNatIpAddress, "pNatIpAddress can not be null");
            sendRequestPacketToExt(ipPacket, icmp, deviceId, pNatIpAddress);
            String icmpInfoKey = String.valueOf(icmpId).concat(String.valueOf(pNatIpAddress.toInt())).concat(String.valueOf(ipPacket.getDestinationAddress()));
            icmpInfoMap.putIfAbsent(icmpInfoKey, openstackPortInfo);
        }
    } else if (icmp.getIcmpType() == ICMP.TYPE_ECHO_REPLY) {
        String icmpInfoKey = String.valueOf(icmpId).concat(String.valueOf(ipPacket.getDestinationAddress())).concat(String.valueOf(ipPacket.getSourceAddress()));
        processResponsePacketFromExternalToHost(ipPacket, icmp, icmpInfoMap.get(icmpInfoKey));
        icmpInfoMap.remove(icmpInfoKey);
    }
}
#end_block

#method_before
private void processIcmpPacketSentToGateway(IPv4 icmpRequestIpv4, ICMP icmpRequest, OpenstackPortInfo openstackPortInfo) {
    icmpRequest.setIcmpType(ICMP.TYPE_ECHO_REPLY).resetChecksum();
    icmpRequestIpv4.setSourceAddress(icmpRequestIpv4.getDestinationAddress()).setDestinationAddress(openstackPortInfo.ip().toInt()).resetChecksum();
    icmpRequestIpv4.setPayload(icmpRequest);
    Ethernet icmpResponseEth = new Ethernet();
    icmpResponseEth.setEtherType(Ethernet.TYPE_IPV4).setSourceMACAddress(GATEWAY_MAC).setDestinationMACAddress(openstackPortInfo.mac()).setPayload(icmpRequestIpv4);
    sendResponsePacketToHost(icmpResponseEth, openstackPortInfo);
}
#method_after
private void processIcmpPacketSentToGateway(IPv4 icmpRequestIpv4, ICMP icmpRequest, OpenstackPortInfo openstackPortInfo) {
    icmpRequest.setChecksum((short) 0);
    icmpRequest.setIcmpType(ICMP.TYPE_ECHO_REPLY).resetChecksum();
    icmpRequestIpv4.setSourceAddress(icmpRequestIpv4.getDestinationAddress()).setDestinationAddress(openstackPortInfo.ip().toInt()).resetChecksum();
    icmpRequestIpv4.setPayload(icmpRequest);
    Ethernet icmpResponseEth = new Ethernet();
    icmpResponseEth.setEtherType(Ethernet.TYPE_IPV4).setSourceMACAddress(GATEWAY_MAC).setDestinationMACAddress(openstackPortInfo.mac()).setPayload(icmpRequestIpv4);
    sendResponsePacketToHost(icmpResponseEth, openstackPortInfo);
}
#end_block

#method_before
private void sendRequestPacketToExt(IPv4 icmpRequestIpv4, ICMP icmpRequest, DeviceId deviceId, Ip4Address pNatIpAddress) {
    icmpRequest.resetChecksum();
    icmpRequestIpv4.setSourceAddress(pNatIpAddress.toInt()).resetChecksum();
    icmpRequestIpv4.setPayload(icmpRequest);
    Ethernet icmpRequestEth = new Ethernet();
    if (config.getScalableGateway()) {
        icmpRequestEth.setEtherType(Ethernet.TYPE_IPV4).setPayload(icmpRequestIpv4);
    } else {
        icmpRequestEth.setEtherType(Ethernet.TYPE_IPV4).setSourceMACAddress(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setDestinationMACAddress(MacAddress.valueOf(config.physicalRouterMac())).setPayload(icmpRequestIpv4);
    }
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    if (config.getScalableGateway()) {
        tBuilder.setOutput(gatewayService.getGatewayExternalPorts(deviceId).get(0));
    } else {
        tBuilder.setOutput(getPortForAnnotationPortName(DeviceId.deviceId(config.gatewayBridgeId()), config.gatewayExternalInterfaceName()));
    }
    TrafficTreatment treatment = tBuilder.build();
    OutboundPacket packet = new DefaultOutboundPacket(deviceId, treatment, ByteBuffer.wrap(icmpRequestEth.serialize()));
    packetService.emit(packet);
}
#method_after
private void sendRequestPacketToExt(IPv4 icmpRequestIpv4, ICMP icmpRequest, DeviceId deviceId, Ip4Address pNatIpAddress) {
    icmpRequest.resetChecksum();
    icmpRequestIpv4.setSourceAddress(pNatIpAddress.toInt()).resetChecksum();
    icmpRequestIpv4.setPayload(icmpRequest);
    Ethernet icmpRequestEth = new Ethernet();
    icmpRequestEth.setEtherType(Ethernet.TYPE_IPV4).setPayload(icmpRequestIpv4);
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    Map<DeviceId, PortNumber> externalInforMap = getExternalInfo();
    if (externalInforMap.size() == 0 || !externalInforMap.containsKey(deviceId)) {
        log.error(EXTERNAL_NODE_NULL, deviceId.toString());
        return;
    }
    tBuilder.setOutput(externalInforMap.get(deviceId));
    TrafficTreatment treatment = tBuilder.build();
    OutboundPacket packet = new DefaultOutboundPacket(deviceId, treatment, ByteBuffer.wrap(icmpRequestEth.serialize()));
    packetService.emit(packet);
}
#end_block

#method_before
private void reloadInitL3Rules() {
    l3EventExecutorService.execute(() -> openstackService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).forEach(p -> updateRouterInterface(portToRouterInterface(p))));
}
#method_after
private void reloadInitL3Rules() {
    l3EventExecutorService.execute(() -> openstackService.ports().stream().forEach(p -> {
        if (p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)) {
            updateRouterInterface(portToRouterInterface(p));
        } else {
            Optional<Ip4Address> vmIp = p.fixedIps().values().stream().findAny();
            if (vmIp.isPresent()) {
                OpenstackFloatingIP floatingIP = getOpenstackFloatingIp(vmIp.get());
                if (floatingIP != null) {
                    updateFloatingIP(floatingIP);
                }
            }
        }
    }));
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!checkGatewayNode(context.inPacket().receivedFrom().deviceId())) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    // TODO: Considers IPv6 later.
    if (ethernet == null) {
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 iPacket = (IPv4) ethernet.getPayload();
        switch(iPacket.getProtocol()) {
            case IPv4.PROTOCOL_ICMP:
                icmpEventExecutorService.execute(() -> openstackIcmpHandler.processIcmpPacket(context, ethernet));
                break;
            case IPv4.PROTOCOL_UDP:
                // don't process DHCP
                UDP udpPacket = (UDP) iPacket.getPayload();
                if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                    break;
                }
            default:
                int portNum = getPortNum(ethernet.getSourceMAC(), iPacket.getDestinationAddress());
                DeviceId deviceId = pkt.receivedFrom().deviceId();
                if (config.getScalableGateway()) {
                    Port port = deviceService.getPort(deviceId, gatewayService.getGatewayExternalPorts(deviceId).get(0));
                    if (port != null) {
                        OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                        l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port, config));
                    } else {
                        log.warn("There`s no external interface");
                    }
                } else {
                    Optional<Port> port = getExternalPort(pkt.receivedFrom().deviceId(), config.gatewayExternalInterfaceName());
                    if (port.isPresent()) {
                        OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                        l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port.get(), config));
                    } else {
                        log.warn("There`s no external interface");
                    }
                }
                break;
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpEventExecutorService.execute(() -> openstackArpHandler.processArpPacketFromRouter(context, ethernet));
    }
}
#method_after
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!checkGatewayNode(context.inPacket().receivedFrom().deviceId())) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    // TODO: Considers IPv6 later.
    if (ethernet == null) {
        return;
    } else if (ethernet.getEtherType() == Ethernet.TYPE_IPV4) {
        IPv4 iPacket = (IPv4) ethernet.getPayload();
        switch(iPacket.getProtocol()) {
            case IPv4.PROTOCOL_ICMP:
                icmpEventExecutorService.execute(() -> openstackIcmpHandler.processIcmpPacket(context, ethernet));
                break;
            case IPv4.PROTOCOL_UDP:
                // don't process DHCP
                UDP udpPacket = (UDP) iPacket.getPayload();
                if (udpPacket.getDestinationPort() == UDP.DHCP_SERVER_PORT && udpPacket.getSourcePort() == UDP.DHCP_CLIENT_PORT) {
                    break;
                }
            default:
                int portNum = getPortNum(ethernet.getSourceMAC(), iPacket.getDestinationAddress());
                DeviceId deviceId = pkt.receivedFrom().deviceId();
                Port port = null;
                port = deviceService.getPort(deviceId, gatewayService.getGatewayExternalPorts(deviceId).get(0));
                if (port != null) {
                    OpenstackPort openstackPort = getOpenstackPort(ethernet.getSourceMAC(), Ip4Address.valueOf(iPacket.getSourceAddress()));
                    l3EventExecutorService.execute(new OpenstackPnatHandler(rulePopulator, context, portNum, openstackPort, port, config));
                } else {
                    log.warn("There`s no external interface");
                }
                break;
        }
    } else if (ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpEventExecutorService.execute(() -> openstackArpHandler.processArpPacketFromRouter(context, ethernet));
    }
}
#end_block

#method_before
private boolean checkGatewayNode(DeviceId deviceId) {
    return gatewayService.getGatewayDeviceIds().stream().anyMatch(id -> id.equals(deviceId));
}
#method_after
private boolean checkGatewayNode(DeviceId deviceId) {
    return gatewayService.getGatewayDeviceIds().contains(deviceId);
}
#end_block

#method_before
private void readConfiguration() {
    config = configService.getConfig("openstacknetworking", OpenstackNetworkingConfig.class);
    if (config == null) {
        log.error("No configuration found");
        return;
    }
    if (config.getScalableGateway()) {
        rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config, gatewayService);
        openstackIcmpHandler = new OpenstackIcmpHandler(packetService, deviceService, openstackService, config, openstackSwitchingService, gatewayService);
        openstackArpHandler = new OpenstackRoutingArpHandler(packetService, openstackService, config, gatewayService);
    } else {
        checkNotNull(config.physicalRouterMac());
        checkNotNull(config.gatewayBridgeId());
        checkNotNull(config.gatewayExternalInterfaceMac());
        checkNotNull(config.gatewayExternalInterfaceName());
        log.warn("Configured info: {}, {}, {}, {}", config.physicalRouterMac(), config.gatewayBridgeId(), config.gatewayExternalInterfaceMac(), config.gatewayExternalInterfaceName());
        rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config, null);
        openstackIcmpHandler = new OpenstackIcmpHandler(packetService, deviceService, openstackService, config, openstackSwitchingService, null);
        openstackArpHandler = new OpenstackRoutingArpHandler(packetService, openstackService, config, null);
        openstackIcmpHandler.requestPacket(appId);
        openstackArpHandler.requestPacket(appId);
        reloadInitL3Rules();
    }
    log.info("OpenstackRouting configured");
}
#method_after
private void readConfiguration() {
    config = configService.getConfig("openstacknetworking", OpenstackNetworkingConfig.class);
    if (config == null) {
        log.error("No configuration found");
        return;
    }
    rulePopulator = new OpenstackRoutingRulePopulator(appId, openstackService, flowObjectiveService, deviceService, driverService, config, gatewayService);
    openstackIcmpHandler = new OpenstackIcmpHandler(packetService, deviceService, openstackService, config, openstackSwitchingService, gatewayService);
    openstackArpHandler = new OpenstackRoutingArpHandler(packetService, openstackService, config, gatewayService);
    openstackIcmpHandler.requestPacket(appId);
    openstackArpHandler.requestPacket(appId);
    openstackService.floatingIps().stream().forEach(f -> floatingIpMap.put(f.id(), f));
    reloadInitL3Rules();
    log.info("OpenstackRouting configured");
}
#end_block

#method_before
@Override
public void run() {
    InboundPacket inboundPacket = context.inPacket();
    Ethernet ethernet = checkNotNull(inboundPacket.parsed());
    // TODO: Considers IPV6
    if (ethernet.getEtherType() != Ethernet.TYPE_IPV4) {
        log.warn("Now, we just consider IP version 4");
        return;
    }
    OpenstackRouter router = getOpenstackRouter(openstackPort);
    if (config.getScalableGateway()) {
        rulePopulator.populatePnatFlowRules(inboundPacket, openstackPort, portNum, getExternalIp(router), null, null);
    } else {
        rulePopulator.populatePnatFlowRules(inboundPacket, openstackPort, portNum, getExternalIp(router), MacAddress.valueOf(config.gatewayExternalInterfaceMac()), MacAddress.valueOf(config.physicalRouterMac()));
    }
    packetOut((Ethernet) ethernet.clone(), inboundPacket.receivedFrom().deviceId(), portNum, router);
}
#method_after
@Override
public void run() {
    InboundPacket inboundPacket = context.inPacket();
    Ethernet ethernet = checkNotNull(inboundPacket.parsed());
    // TODO: Considers IPV6
    if (ethernet.getEtherType() != Ethernet.TYPE_IPV4) {
        log.warn("Now, we just consider IP version 4");
        return;
    }
    OpenstackRouter router = getOpenstackRouter(openstackPort);
    MacAddress externalMac = MacAddress.NONE;
    MacAddress routerMac = MacAddress.NONE;
    rulePopulator.populatePnatFlowRules(inboundPacket, openstackPort, portNum, getExternalIp(router), externalMac, routerMac);
    packetOut((Ethernet) ethernet.clone(), inboundPacket.receivedFrom().deviceId(), portNum, router);
}
#end_block

#method_before
private OpenstackRouter getOpenstackRouter(OpenstackPort openstackPort) {
    OpenstackInterfaceService networkingService = getService(OpenstackInterfaceService.class);
    OpenstackNetwork network = networkingService.network(openstackPort.networkId());
    OpenstackPort port = networkingService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).filter(p -> checkSameSubnet(p, openstackPort)).findAny().orElse(null);
    return checkNotNull(networkingService.router(port.deviceId()));
}
#method_after
private OpenstackRouter getOpenstackRouter(OpenstackPort openstackPort) {
    OpenstackInterfaceService networkingService = getService(OpenstackInterfaceService.class);
    OpenstackPort port = networkingService.ports().stream().filter(p -> p.deviceOwner().equals(DEVICE_OWNER_ROUTER_INTERFACE)).filter(p -> checkSameSubnet(p, openstackPort)).findAny().orElse(null);
    return checkNotNull(networkingService.router(port.deviceId()));
}
#end_block

#method_before
private void packetOut(Ethernet ethernet, DeviceId deviceId, int portNum, OpenstackRouter router) {
    PacketService packetService = getService(PacketService.class);
    IPv4 iPacket = (IPv4) ethernet.getPayload();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            tcpPacket.setSourcePort(portNum);
            tcpPacket.resetChecksum();
            tcpPacket.setParent(iPacket);
            iPacket.setPayload(tcpPacket);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            udpPacket.setSourcePort(portNum);
            udpPacket.resetChecksum();
            udpPacket.setParent(iPacket);
            iPacket.setPayload(udpPacket);
            break;
        default:
            log.error("Temporally, this method can process UDP and TCP protocol.");
            return;
    }
    iPacket.setSourceAddress(getExternalIp(router).toString());
    iPacket.resetChecksum();
    iPacket.setParent(ethernet);
    ethernet.setPayload(iPacket);
    if (config.getScalableGateway()) {
        ScalableGatewayService gatewayService = getService(ScalableGatewayService.class);
        treatment.setOutput(gatewayService.getGatewayExternalPorts(deviceId).get(0));
    } else {
        ethernet.setSourceMACAddress(config.gatewayExternalInterfaceMac()).setDestinationMACAddress(config.physicalRouterMac());
        treatment.setOutput(port.number());
    }
    ethernet.resetChecksum();
    packetService.emit(new DefaultOutboundPacket(deviceId, treatment.build(), ByteBuffer.wrap(ethernet.serialize())));
}
#method_after
private void packetOut(Ethernet ethernet, DeviceId deviceId, int portNum, OpenstackRouter router) {
    PacketService packetService = getService(PacketService.class);
    IPv4 iPacket = (IPv4) ethernet.getPayload();
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            tcpPacket.setSourcePort(portNum);
            tcpPacket.resetChecksum();
            tcpPacket.setParent(iPacket);
            iPacket.setPayload(tcpPacket);
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            udpPacket.setSourcePort(portNum);
            udpPacket.resetChecksum();
            udpPacket.setParent(iPacket);
            iPacket.setPayload(udpPacket);
            break;
        default:
            log.error("Temporally, this method can process UDP and TCP protocol.");
            return;
    }
    iPacket.setSourceAddress(getExternalIp(router).toString());
    iPacket.resetChecksum();
    iPacket.setParent(ethernet);
    ethernet.setPayload(iPacket);
    ScalableGatewayService gatewayService = getService(ScalableGatewayService.class);
    GatewayNode gatewayNode = gatewayService.getGatewayNode(deviceId);
    if (gatewayNode.getGatewayExternalInterfaceNames().size() == 0) {
        log.error(EXTERNAL_PORT_NULL, deviceId.toString());
        return;
    }
    treatment.setOutput(gatewayService.getGatewayExternalPorts(deviceId).get(0));
    ethernet.resetChecksum();
    packetService.emit(new DefaultOutboundPacket(deviceId, treatment.build(), ByteBuffer.wrap(ethernet.serialize())));
}
#end_block

#method_before
private void populatePnatOutgoingFlowRules(long vni, Ip4Address externalIp) {
    IPv4 iPacket = (IPv4) inboundPacket.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchTunnelId(vni).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(TpPort.tpPort(portNum));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(TpPort.tpPort(portNum));
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    if (config.getScalableGateway()) {
        tBuilder.setIpSrc(externalIp);
        gatewayService.getGatewayNodes().forEach(node -> {
            tBuilder.setOutput(gatewayService.getGatewayExternalPorts(node.getGatewayDeviceId()).get(0));
            ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
            flowObjectiveService.forward(node.getGatewayDeviceId(), fo);
        });
    } else {
        Port port = checkNotNull(getPortOfExternalInterface(), PORTNOTNULL);
        tBuilder.setEthSrc(externalInterface).setEthDst(externalRouter).setIpSrc(externalIp).setOutput(port.number());
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
        flowObjectiveService.forward(inboundPacket.receivedFrom().deviceId(), fo);
    }
}
#method_after
private void populatePnatOutgoingFlowRules(long vni, Ip4Address externalIp) {
    IPv4 iPacket = (IPv4) inboundPacket.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchTunnelId(vni).matchIPSrc(IpPrefix.valueOf(iPacket.getSourceAddress(), 32)).matchIPDst(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getSourcePort())).matchTcpDst(TpPort.tpPort(tcpPacket.getDestinationPort()));
            tBuilder.setTcpSrc(TpPort.tpPort(portNum));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getSourcePort())).matchUdpDst(TpPort.tpPort(udpPacket.getDestinationPort()));
            tBuilder.setUdpSrc(TpPort.tpPort(portNum));
            break;
        default:
            log.debug("Unsupported IPv4 protocol {}");
            break;
    }
    tBuilder.setIpSrc(externalIp);
    gatewayService.getGatewayNodes().forEach(node -> {
        tBuilder.setOutput(gatewayService.getGatewayExternalPorts(node.getGatewayDeviceId()).get(0));
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
        flowObjectiveService.forward(node.getGatewayDeviceId(), fo);
    });
}
#end_block

#method_before
private void populatePnatIncomingFlowRules(long vni, Ip4Address externalIp) {
    IPv4 iPacket = (IPv4) inboundPacket.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPDst(IpPrefix.valueOf(externalIp, 32)).matchIPSrc(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    tBuilder.setTunnelId(vni).setEthDst(inboundPacket.parsed().getSourceMAC()).setIpDst(IpAddress.valueOf(iPacket.getSourceAddress()));
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getDestinationPort())).matchTcpDst(TpPort.tpPort(portNum));
            tBuilder.setTcpDst(TpPort.tpPort(tcpPacket.getSourcePort()));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getDestinationPort())).matchUdpDst(TpPort.tpPort(portNum));
            tBuilder.setUdpDst(TpPort.tpPort(udpPacket.getSourcePort()));
            break;
        default:
            break;
    }
    if (config.getScalableGateway()) {
        gatewayService.getGatewayNodes().forEach(node -> {
            DeviceId deviceId = node.getGatewayDeviceId();
            tBuilder.extension(buildNiciraExtenstion(deviceId, getHostIpfromOpenstackPort(openstackPort)), deviceId).setOutput(getTunnelPort(deviceId));
            ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
            flowObjectiveService.forward(deviceId, fo);
        });
    } else {
        DeviceId deviceId = inboundPacket.receivedFrom().deviceId();
        tBuilder.extension(buildNiciraExtenstion(deviceId, getHostIpfromOpenstackPort(openstackPort)), deviceId).setOutput(getTunnelPort(deviceId));
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
        flowObjectiveService.forward(deviceId, fo);
    }
}
#method_after
private void populatePnatIncomingFlowRules(long vni, Ip4Address externalIp) {
    IPv4 iPacket = (IPv4) inboundPacket.parsed().getPayload();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPProtocol(iPacket.getProtocol()).matchIPDst(IpPrefix.valueOf(externalIp, 32)).matchIPSrc(IpPrefix.valueOf(iPacket.getDestinationAddress(), 32));
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    tBuilder.setTunnelId(vni).setEthDst(inboundPacket.parsed().getSourceMAC()).setIpDst(IpAddress.valueOf(iPacket.getSourceAddress()));
    switch(iPacket.getProtocol()) {
        case IPv4.PROTOCOL_TCP:
            TCP tcpPacket = (TCP) iPacket.getPayload();
            sBuilder.matchTcpSrc(TpPort.tpPort(tcpPacket.getDestinationPort())).matchTcpDst(TpPort.tpPort(portNum));
            tBuilder.setTcpDst(TpPort.tpPort(tcpPacket.getSourcePort()));
            break;
        case IPv4.PROTOCOL_UDP:
            UDP udpPacket = (UDP) iPacket.getPayload();
            sBuilder.matchUdpSrc(TpPort.tpPort(udpPacket.getDestinationPort())).matchUdpDst(TpPort.tpPort(portNum));
            tBuilder.setUdpDst(TpPort.tpPort(udpPacket.getSourcePort()));
            break;
        default:
            break;
    }
    getGatewayNodeList().forEach(node -> {
        DeviceId deviceId = node.id();
        tBuilder.extension(buildNiciraExtenstion(deviceId, getHostIpfromOpenstackPort(openstackPort)), deviceId).setOutput(getTunnelPort(deviceId));
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(PNAT_RULE_PRIORITY).makeTemporary(PNAT_TIMEOUT).fromApp(appId).add();
        flowObjectiveService.forward(deviceId, fo);
    });
}
#end_block

#method_before
private Device getDevicefromOpenstackPort(OpenstackPort openstackPort) {
    String openstackPortName = PORTNAME_PREFIX_VM + openstackPort.id().substring(0, 11);
    Device device = StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> findPortinDevice(d, openstackPortName)).iterator().next();
    checkNotNull(device, DEVICENOTNULL);
    return device;
}
#method_after
private Device getDevicefromOpenstackPort(OpenstackPort openstackPort) {
    String openstackPortName = PORTNAME_PREFIX_VM + openstackPort.id().substring(0, 11);
    Device device = StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> findPortinDevice(d.id(), openstackPortName)).iterator().next();
    checkNotNull(device, DEVICENOTNULL);
    return device;
}
#end_block

#method_before
private boolean findPortinDevice(Device d, String openstackPortName) {
    Port port = deviceService.getPorts(d.id()).stream().filter(p -> p.isEnabled() && p.annotations().value(PORTNAME).equals(openstackPortName)).findAny().orElse(null);
    return port != null;
}
#method_after
private boolean findPortinDevice(DeviceId deviceId, String openstackPortName) {
    Port port = deviceService.getPorts(deviceId).stream().filter(p -> p.isEnabled() && p.annotations().value(PORTNAME).equals(openstackPortName)).findAny().orElse(null);
    return port != null;
}
#end_block

#method_before
public ExtensionTreatment buildNiciraExtenstion(DeviceId id, Ip4Address hostIp) {
    Driver driver = driverService.getDriver(id);
    DriverHandler driverHandler = new DefaultDriverHandler(new DefaultDriverData(driver, id));
    ExtensionTreatmentResolver resolver = driverHandler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment extensionInstruction = resolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type());
    try {
        extensionInstruction.setPropertyValue(TUNNEL_DESTINATION, hostIp);
    } catch (ExtensionPropertyException e) {
        log.error("Error setting Nicira extension setting {}", e);
    }
    return extensionInstruction;
}
#method_after
public ExtensionTreatment buildNiciraExtenstion(DeviceId deviceId, Ip4Address hostIp) {
    Driver driver = driverService.getDriver(deviceId);
    DriverHandler driverHandler = new DefaultDriverHandler(new DefaultDriverData(driver, deviceId));
    ExtensionTreatmentResolver resolver = driverHandler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment extensionInstruction = resolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type());
    try {
        extensionInstruction.setPropertyValue(TUNNEL_DESTINATION, hostIp);
    } catch (ExtensionPropertyException e) {
        log.error("Error setting Nicira extension setting {}", e);
    }
    return extensionInstruction;
}
#end_block

#method_before
private void populateRuleGatewaytoController(long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchEthDst(GATEWAYMAC);
    tBuilder.setOutput(PortNumber.CONTROLLER);
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).add();
    if (config.getScalableGateway()) {
        gatewayService.getGatewayNodes().forEach(node -> flowObjectiveService.forward(node.getGatewayDeviceId(), fo));
    } else {
        flowObjectiveService.forward(getGatewayNode().id(), fo);
    }
}
#method_after
private void populateRuleGatewaytoController(long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchEthDst(GATEWAYMAC);
    tBuilder.setOutput(PortNumber.CONTROLLER);
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).add();
    getGatewayNodeList().forEach(device -> flowObjectiveService.forward(device.id(), fo));
}
#end_block

#method_before
private void populateComputeNodeRules(long vni) {
    if (config.getScalableGateway()) {
        StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> !checkGatewayNode(d.id())).forEach(d -> populateRuleToGatewayBySgw(d, gatewayService.getGroupIdForGatewayLoadBalance(d.id()), vni));
    } else {
        Device gatewayDevice = getGatewayNode();
        StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> !checkGatewayNode(d.id())).forEach(d -> populateRuleToGateway(d, gatewayDevice, vni));
    }
}
#method_after
private void populateComputeNodeRules(long vni) {
    StreamSupport.stream(deviceService.getDevices().spliterator(), false).filter(d -> !checkGatewayNode(d.id())).forEach(d -> populateRuleToGatewayBySgw(d.id(), gatewayService.getGroupIdForGatewayLoadBalance(d.id()), vni));
}
#end_block

#method_before
private void populateRuleToGatewayBySgw(Device d, GroupId groupId, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchEthDst(GATEWAYMAC);
    tBuilder.group(groupId);
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(d.id(), fo);
}
#method_after
private void populateRuleToGatewayBySgw(DeviceId deviceId, GroupId groupId, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchEthDst(GATEWAYMAC);
    tBuilder.group(groupId);
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(deviceId, fo);
}
#end_block

#method_before
private void populateRuleToGateway(Device d, Device gatewayDevice, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchEthDst(GATEWAYMAC);
    tBuilder.extension(buildNiciraExtenstion(d.id(), config.nodes().get(gatewayDevice.id())), d.id()).setOutput(getTunnelPort(d.id()));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(d.id(), fo);
}
#method_after
private void populateRuleToGateway(DeviceId deviceId, Device gatewayDevice, long vni) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(vni).matchEthDst(GATEWAYMAC);
    tBuilder.extension(buildNiciraExtenstion(deviceId, config.nodes().get(gatewayDevice.id())), deviceId).setOutput(getTunnelPort(deviceId));
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.SPECIFIC).withPriority(ROUTING_RULE_PRIORITY).fromApp(appId).add();
    flowObjectiveService.forward(deviceId, fo);
}
#end_block

#method_before
private boolean checkGatewayNode(DeviceId deviceId) {
    if (config.getScalableGateway()) {
        return gatewayService.getGatewayDeviceIds().stream().anyMatch(dId -> dId.equals(deviceId));
    }
    return deviceId.toString().equals(config.gatewayBridgeId());
}
#method_after
private boolean checkGatewayNode(DeviceId deviceId) {
    return gatewayService.getGatewayDeviceIds().stream().anyMatch(dId -> dId.equals(deviceId));
}
#end_block

#method_before
private void removeRule(DeviceId id, TrafficSelector.Builder sBuilder, ForwardingObjective.Flag flag, int priority) {
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(flag).withPriority(priority).fromApp(appId).remove();
    flowObjectiveService.forward(id, fo);
}
#method_after
private void removeRule(DeviceId deviceId, TrafficSelector.Builder sBuilder, ForwardingObjective.Flag flag, int priority) {
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(flag).withPriority(priority).fromApp(appId).remove();
    flowObjectiveService.forward(deviceId, fo);
}
#end_block

#method_before
private void populateFloatingIpIncomingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    DeviceId portDeviceId = getDevicefromOpenstackPort(port).id();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), PREFIX_LENGTH));
    if (config.getScalableGateway()) {
        gatewayService.getGatewayNodes().forEach(node -> {
            DeviceId deviceId = node.getGatewayDeviceId();
            tBuilder.setEthSrc(GATEWAYMAC).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(deviceId, config.nodes().get(portDeviceId)), deviceId).setOutput(getTunnelPort(deviceId));
            ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
            flowObjectiveService.forward(deviceId, fo);
        });
    } else {
        Device gatewayNode = getGatewayNode();
        tBuilder.setEthSrc(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(gatewayNode.id(), config.nodes().get(portDeviceId)), gatewayNode.id()).setOutput(getTunnelPort(gatewayNode.id()));
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
        flowObjectiveService.forward(getGatewayNode().id(), fo);
    }
}
#method_after
private void populateFloatingIpIncomingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    DeviceId portDeviceId = getDevicefromOpenstackPort(port).id();
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), PREFIX_LENGTH));
    getGatewayNodeList().forEach(device -> {
        DeviceId deviceId = device.id();
        tBuilder.setEthSrc(GATEWAYMAC).setEthDst(port.macAddress()).setIpDst(floatingIP.fixedIpAddress()).setTunnelId(getVni(port.networkId())).extension(buildNiciraExtenstion(deviceId, config.nodes().get(portDeviceId)), deviceId).setOutput(getTunnelPort(deviceId));
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
        flowObjectiveService.forward(deviceId, fo);
    });
}
#end_block

#method_before
private void populateFloatingIpOutgoingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(port.networkId())).matchIPSrc(IpPrefix.valueOf(floatingIP.fixedIpAddress(), 32));
    if (config.getScalableGateway()) {
        gatewayService.getGatewayNodes().forEach(node -> {
            DeviceId deviceId = node.getGatewayDeviceId();
            tBuilder.setIpSrc(floatingIP.floatingIpAddress()).setOutput(gatewayService.getGatewayExternalPorts(deviceId).get(0));
            ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
            flowObjectiveService.forward(deviceId, fo);
        });
    } else {
        Port outputPort = checkNotNull(getPortOfExternalInterface(), PORTNOTNULL);
        tBuilder.setIpSrc(floatingIP.floatingIpAddress()).setEthSrc(MacAddress.valueOf(config.gatewayExternalInterfaceMac())).setEthDst(MacAddress.valueOf(config.physicalRouterMac())).setOutput(outputPort.number());
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
        flowObjectiveService.forward(getGatewayNode().id(), fo);
    }
}
#method_after
private void populateFloatingIpOutgoingRules(OpenstackFloatingIP floatingIP, OpenstackPort port) {
    TrafficSelector.Builder sBuilder = DefaultTrafficSelector.builder();
    TrafficTreatment.Builder tBuilder = DefaultTrafficTreatment.builder();
    sBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(getVni(port.networkId())).matchIPSrc(IpPrefix.valueOf(floatingIP.fixedIpAddress(), 32));
    getGatewayNodeList().forEach(device -> {
        DeviceId deviceId = device.id();
        tBuilder.setIpSrc(floatingIP.floatingIpAddress()).setOutput(getExternalPortNum(deviceId));
        ForwardingObjective fo = DefaultForwardingObjective.builder().withSelector(sBuilder.build()).withTreatment(tBuilder.build()).withFlag(ForwardingObjective.Flag.VERSATILE).withPriority(FLOATING_RULE_PRIORITY).fromApp(appId).add();
        flowObjectiveService.forward(deviceId, fo);
    });
}
#end_block

#method_before
public void removeFloatingIpRules(OpenstackFloatingIP floatingIP, OpenstackPortInfo portInfo) {
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(portInfo.vni()).matchIPSrc(IpPrefix.valueOf(portInfo.ip(), PREFIX_LENGTH));
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), PREFIX_LENGTH));
    if (config.getScalableGateway()) {
        gatewayService.getGatewayDeviceIds().forEach(deviceId -> {
            removeRule(deviceId, sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
            removeRule(deviceId, sIncomingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
        });
    } else {
        removeRule(getGatewayNode().id(), sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
        removeRule(getGatewayNode().id(), sIncomingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
    }
}
#method_after
public void removeFloatingIpRules(OpenstackFloatingIP floatingIP, OpenstackPortInfo portInfo) {
    TrafficSelector.Builder sOutgoingBuilder = DefaultTrafficSelector.builder();
    TrafficSelector.Builder sIncomingBuilder = DefaultTrafficSelector.builder();
    sOutgoingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchTunnelId(portInfo.vni()).matchIPSrc(IpPrefix.valueOf(portInfo.ip(), PREFIX_LENGTH));
    sIncomingBuilder.matchEthType(Ethernet.TYPE_IPV4).matchIPDst(IpPrefix.valueOf(floatingIP.floatingIpAddress(), PREFIX_LENGTH));
    getGatewayNodeList().forEach(device -> {
        removeRule(device.id(), sOutgoingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
        removeRule(device.id(), sIncomingBuilder, ForwardingObjective.Flag.VERSATILE, FLOATING_RULE_PRIORITY);
    });
}
#end_block

#method_before
public void populateL3Rules(OpenstackPort p, List<OpenstackRouterInterface> targetList) {
    Device device = getDevicefromOpenstackPort(p);
    Port port = getPortFromOpenstackPort(device, p);
    Ip4Address vmIp = (Ip4Address) p.fixedIps().values().iterator().next();
    if (port == null) {
        return;
    }
    targetList.forEach(routerInterface -> {
        OpenstackPort openstackPort = openstackService.port(routerInterface.portId());
        long vni = getVni(openstackPort.networkId());
        if (vmIp == null) {
            return;
        }
        populateL3RulestoSameNode(vmIp, p, port, device, vni);
        deviceService.getAvailableDevices().forEach(d -> {
            if (!d.equals(device) && !checkGatewayNode(d.id())) {
                populateL3RulestoDifferentNode(vmIp, vni, d.id(), getHostIpfromOpenstackPort(p));
            }
        });
    });
}
#method_after
public void populateL3Rules(OpenstackPort openstackPort, List<OpenstackRouterInterface> targetList) {
    Device device = getDevicefromOpenstackPort(openstackPort);
    Port port = getPortFromOpenstackPort(device, openstackPort);
    Ip4Address vmIp = openstackPort.fixedIps().values().iterator().next();
    if (port == null) {
        return;
    }
    targetList.forEach(routerInterface -> {
        long vni = getVni(openstackService.port(routerInterface.portId()).networkId());
        if (vmIp == null) {
            return;
        }
        populateL3RulestoSameNode(vmIp, openstackPort, port, device, vni);
        deviceService.getAvailableDevices().forEach(d -> {
            if (!d.equals(device) && !checkGatewayNode(d.id())) {
                populateL3RulestoDifferentNode(vmIp, vni, d.id(), getHostIpfromOpenstackPort(openstackPort));
            }
        });
    });
}
#end_block

#method_before
@Override
public boolean isValid() {
    return hasOnlyFields(NODES, BRIDGE_ID, DATAPLANE_IP, EXTERNAL_INTERFACE_NAME);
}
#method_after
@Override
public boolean isValid() {
    JsonNode jsonNodes = object.get(NODES);
    if (jsonNodes == null) {
        return false;
    }
    return hasOnlyFields(NODES) && StreamSupport.stream(jsonNodes.spliterator(), false).allMatch(this::checkValid);
}
#end_block

#method_before
@Activate
protected void activate() {
    opticalPathService.addListener(opticalEventListener);
    networkConfigService.addListener(netcfgListener);
}
#method_after
@Activate
protected void activate() {
    opticalPathService.addListener(opticalEventListener);
    networkConfigService.addListener(netcfgListener);
    factories.forEach(cfgRegistry::registerConfigFactory);
}
#end_block

#method_before
public void setupConnectivity(Set<CarrierEthernetNetworkInterface> niSet, CarrierEthernetVirtualConnection evc) {
    boolean allPairsConnected = true;
    HashMap<CarrierEthernetNetworkInterface, HashSet<CarrierEthernetNetworkInterface>> ingressEgressNiMap = new HashMap<>();
    // Temporary set for iterating through NI pairs
    Set<CarrierEthernetNetworkInterface> tempNiSet = new HashSet<>(niSet);
    // Temporary set for indicating which NIs were finally included
    Set<CarrierEthernetNetworkInterface> usedNiSet = new HashSet<>();
    Iterator<CarrierEthernetNetworkInterface> niIt1 = tempNiSet.iterator();
    while (niIt1.hasNext()) {
        CarrierEthernetNetworkInterface ni1 = niIt1.next();
        // Iterate through all the remaining NIs
        Iterator<CarrierEthernetNetworkInterface> niIt2 = tempNiSet.iterator();
        while (niIt2.hasNext()) {
            CarrierEthernetNetworkInterface ni2 = niIt2.next();
            // Skip equals
            if (ni1.equals(ni2)) {
                continue;
            }
            // Do not establish connectivity between leaf NIs (applies to Rooted_Multipoint)
            if (ni1.role().equals(CarrierEthernetUni.Role.LEAF) && ni2.role().equals(CarrierEthernetUni.Role.LEAF)) {
                continue;
            }
            OpticalConnectivityId opticalConnectId = null;
            if (pktOpticalTopo) {
                Bandwidth reqBw;
                if (ni1.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ni1).bwp().cir();
                } else if (ni2.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ni2).bwp().cir();
                } else {
                    reqBw = Bandwidth.bps((double) 0);
                }
                opticalConnectId = setupOpticalConnectivity(ni1.cp(), ni2.cp(), reqBw, evc.latency());
                if (opticalConnectId == null || opticalConnectStatusMap.get(opticalConnectId) != OpticalPathEvent.Type.PATH_INSTALLED) {
                    log.error("Could not establish optical connectivity between {} and {}" + " (optical id and status: {}, {})", ni1.cp(), ni2.cp(), opticalConnectId, (opticalConnectId == null ? "null" : opticalConnectStatusMap.get(opticalConnectId)));
                    allPairsConnected = false;
                    continue;
                }
                if (opticalConnectId != null) {
                    evc.setMetroConnectivityId(opticalConnectId);
                    evc.setMetroConnectivityStatus(opticalConnectStatusMap.get(opticalConnectId));
                }
                log.info("Metro connectivity id and status for EVC {}: {}, {}", evc.id(), evc.metroConnectivity().id(), evc.metroConnectivity().status());
                if (opticalConnectId != null) {
                    // TODO: find vlanIds for both CO and store to service
                    opticalPathService.getPath(opticalConnectId).ifPresent(links -> {
                        getVlanTag(links).ifPresent(vlan -> {
                            log.info("VLAN ID {} is assigned to CE service {}", vlan, evc.id());
                            evc.setVlanId(vlan);
                        });
                    });
                }
            }
            // Update the cpPathHashSet based on the calculated paths
            if (!updateIngressEgressNiMap(ni1, ni2, ingressEgressNiMap, evc.congruentPaths())) {
                removeOpticalConnectivity(opticalConnectId);
                allPairsConnected = false;
                continue;
            }
            // Indicate that connection for at least one NI pair has been established
            evc.setState(CarrierEthernetVirtualConnection.State.ACTIVE);
            // Add NIs to the set of NIs used by the EVC
            usedNiSet.add(ni1);
            usedNiSet.add(ni2);
        }
        // Remove NI from temporary set so that each pair is visited only once
        niIt1.remove();
    }
    // Establish connectivity using the ingressEgressNiMap
    ingressEgressNiMap.keySet().forEach(srcNi -> {
        // Set forwarding only on packet switches
        if (deviceService.getDevice(srcNi.cp().deviceId()).type().equals(Device.Type.SWITCH)) {
            ceOfPktNodeManager.setNodeForwarding(evc, srcNi, ingressEgressNiMap.get(srcNi));
        }
    });
    // Update the NI set, based on the NIs actually used
    evc.setNiSet(usedNiSet);
    if (evc.state().equals(CarrierEthernetVirtualConnection.State.ACTIVE)) {
        if (allPairsConnected) {
            evc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.FULL);
        } else {
            evc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.PARTIAL);
        }
    }
}
#method_after
public void setupConnectivity(Set<CarrierEthernetNetworkInterface> niSet, CarrierEthernetVirtualConnection evc) {
    boolean allPairsConnected = true;
    HashMap<CarrierEthernetNetworkInterface, HashSet<CarrierEthernetNetworkInterface>> ingressEgressNiMap = new HashMap<>();
    // Temporary set for iterating through NI pairs
    Set<CarrierEthernetNetworkInterface> tempNiSet = new HashSet<>(niSet);
    // Temporary set for indicating which NIs were finally included
    Set<CarrierEthernetNetworkInterface> usedNiSet = new HashSet<>();
    Iterator<CarrierEthernetNetworkInterface> niIt1 = tempNiSet.iterator();
    while (niIt1.hasNext()) {
        CarrierEthernetNetworkInterface ni1 = niIt1.next();
        // Iterate through all the remaining NIs
        Iterator<CarrierEthernetNetworkInterface> niIt2 = tempNiSet.iterator();
        while (niIt2.hasNext()) {
            CarrierEthernetNetworkInterface ni2 = niIt2.next();
            // Skip equals
            if (ni1.equals(ni2)) {
                continue;
            }
            // Do not establish connectivity between leaf NIs (applies to Rooted_Multipoint)
            if (ni1.role().equals(CarrierEthernetUni.Role.LEAF) && ni2.role().equals(CarrierEthernetUni.Role.LEAF)) {
                continue;
            }
            OpticalConnectivityId opticalConnectId = null;
            if (pktOpticalTopo) {
                Bandwidth reqBw;
                if (ni1.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ni1).bwp().cir();
                } else if (ni2.type().equals(CarrierEthernetNetworkInterface.Type.UNI)) {
                    reqBw = ((CarrierEthernetUni) ni2).bwp().cir();
                } else {
                    reqBw = Bandwidth.bps((double) 0);
                }
                opticalConnectId = setupOpticalConnectivity(ni1.cp(), ni2.cp(), reqBw, evc.latency());
                if (opticalConnectId == null || opticalConnectStatusMap.get(opticalConnectId) != OpticalPathEvent.Type.PATH_INSTALLED) {
                    log.error("Could not establish optical connectivity between {} and {}" + " (optical id and status: {}, {})", ni1.cp(), ni2.cp(), opticalConnectId, (opticalConnectId == null ? "null" : opticalConnectStatusMap.get(opticalConnectId)));
                    allPairsConnected = false;
                    continue;
                }
                if (opticalConnectId != null) {
                    evc.setMetroConnectivityId(opticalConnectId);
                    evc.setMetroConnectivityStatus(opticalConnectStatusMap.get(opticalConnectId));
                }
                log.info("Metro connectivity id and status for EVC {}: {}, {}", evc.id(), evc.metroConnectivity().id(), evc.metroConnectivity().status());
                if (opticalConnectId != null) {
                    // TODO: find vlanIds for both CO and store to service
                    opticalPathService.getPath(opticalConnectId).ifPresent(links -> {
                        getVlanTag(links).ifPresent(vlan -> {
                            log.info("VLAN ID {} is assigned to CE service {}", vlan, evc.id());
                            evc.setVlanId(vlan);
                        });
                    });
                }
            }
            // Update the cpPathHashSet based on the calculated paths
            if (!updateIngressEgressNiMap(ni1, ni2, ingressEgressNiMap, evc.congruentPaths(), evc.type())) {
                removeOpticalConnectivity(opticalConnectId);
                allPairsConnected = false;
                continue;
            }
            // Indicate that connection for at least one NI pair has been established
            evc.setState(CarrierEthernetVirtualConnection.State.ACTIVE);
            // Add NIs to the set of NIs used by the EVC
            usedNiSet.add(ni1);
            usedNiSet.add(ni2);
        }
        // Remove NI from temporary set so that each pair is visited only once
        niIt1.remove();
    }
    // Establish connectivity using the ingressEgressNiMap
    ingressEgressNiMap.keySet().forEach(srcNi -> {
        // Set forwarding only on packet switches
        if (deviceService.getDevice(srcNi.cp().deviceId()).type().equals(Device.Type.SWITCH)) {
            ceOfPktNodeManager.setNodeForwarding(evc, srcNi, ingressEgressNiMap.get(srcNi));
        }
    });
    // Update the NI set, based on the NIs actually used
    evc.setNiSet(usedNiSet);
    if (evc.state().equals(CarrierEthernetVirtualConnection.State.ACTIVE)) {
        if (allPairsConnected) {
            evc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.FULL);
        } else {
            evc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.PARTIAL);
        }
    }
}
#end_block

#method_before
private boolean updateIngressEgressNiMap(CarrierEthernetNetworkInterface ni1, CarrierEthernetNetworkInterface ni2, HashMap<CarrierEthernetNetworkInterface, HashSet<CarrierEthernetNetworkInterface>> ingressEgressNiMap, boolean congruentPaths) {
    // Find the paths for both directions at the same time, so that we can skip the pair if needed
    List<Link> forwardLinks = generateLinkList(ni1.cp(), ni2.cp());
    List<Link> backwardLinks = congruentPaths ? generateInverseLinkList(forwardLinks) : generateLinkList(ni2.cp(), ni1.cp());
    // Skip this UNI pair if no feasible path could be found
    if (forwardLinks == null || (backwardLinks == null)) {
        log.warn("There are no feasible paths between {} and {}.", ni1.cp().deviceId(), ni2.cp().deviceId());
        return false;
    }
    // Populate the ingress/egress NI map for the forward and backward paths
    populateIngressEgressNiMap(ni1, ni2, forwardLinks, ingressEgressNiMap);
    populateIngressEgressNiMap(ni2, ni1, backwardLinks, ingressEgressNiMap);
    return true;
}
#method_after
private boolean updateIngressEgressNiMap(CarrierEthernetNetworkInterface ni1, CarrierEthernetNetworkInterface ni2, HashMap<CarrierEthernetNetworkInterface, HashSet<CarrierEthernetNetworkInterface>> ingressEgressNiMap, boolean congruentPaths, CarrierEthernetVirtualConnection.Type evcType) {
    // Find the paths for both directions at the same time, so that we can skip the pair if needed
    List<Link> forwardLinks = generateLinkList(ni1.cp(), ni2.cp(), evcType);
    List<Link> backwardLinks = congruentPaths ? generateInverseLinkList(forwardLinks) : generateLinkList(ni2.cp(), ni1.cp(), evcType);
    // Skip this UNI pair if no feasible path could be found
    if (forwardLinks == null || (backwardLinks == null)) {
        log.warn("There are no feasible paths between {} and {}.", ni1.cp().deviceId(), ni2.cp().deviceId());
        return false;
    }
    // Populate the ingress/egress NI map for the forward and backward paths
    populateIngressEgressNiMap(ni1, ni2, forwardLinks, ingressEgressNiMap);
    populateIngressEgressNiMap(ni2, ni1, backwardLinks, ingressEgressNiMap);
    return true;
}
#end_block

#method_before
private List<Link> generateLinkList(ConnectPoint cp1, ConnectPoint cp2) {
    Set<Path> paths = pathService.getPaths(cp1.deviceId(), cp2.deviceId());
    Path path = null;
    for (Path p : paths) {
        // TODO: Select path in more sophisticated way and return null if any of the constraints cannot be met
        path = p;
        break;
    }
    if (path == null) {
        return null;
    }
    List<Link> links = new ArrayList<>();
    links.add(createEdgeLink(cp1, true));
    links.addAll(path.links());
    links.add(createEdgeLink(cp2, false));
    return links;
}
#method_after
private List<Link> generateLinkList(ConnectPoint cp1, ConnectPoint cp2, CarrierEthernetVirtualConnection.Type evcType) {
    Set<Path> paths;
    if (evcType.equals(CarrierEthernetVirtualConnection.Type.POINT_TO_POINT)) {
        // For point-to-point connectivity use the pre-calculated paths to make sure the shortest paths are chosen
        paths = pathService.getPaths(cp1.deviceId(), cp2.deviceId());
    } else {
        // Recalculate path so that it's over the pre-calculated spanning tree
        // FIXME: Find a more efficient way (avoid recalculating paths)
        paths = pathService.getPaths(cp1.deviceId(), cp2.deviceId(), new SpanningTreeWeight());
    }
    // Just select any of the returned paths
    // TODO: Select path in more sophisticated way and return null if any of the constraints cannot be met
    Path path = paths.iterator().hasNext() ? paths.iterator().next() : null;
    if (path == null) {
        return null;
    }
    List<Link> links = new ArrayList<>();
    links.add(createEdgeLink(cp1, true));
    links.addAll(path.links());
    links.add(createEdgeLink(cp2, false));
    return links;
}
#end_block

#method_before
public void installSfcTunnelSendRule(DeviceId deviceId, NshServicePathId nshSpiId, Objective.Operation type) {
    // Prepare selector with nsp, nsi and inport from egress of port pair
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionSelectorResolver selectorResolver = handler.behaviour(ExtensionSelectorResolver.class);
    ExtensionSelector nshSpiSelector = selectorResolver.getExtensionSelector(NICIRA_MATCH_NSH_SPI.type());
    ExtensionSelector nshSiSelector = selectorResolver.getExtensionSelector(NICIRA_MATCH_NSH_SI.type());
    ExtensionSelector encapEthTypeSelector = selectorResolver.getExtensionSelector(NICIRA_MATCH_ENCAP_ETH_TYPE.type());
    try {
        nshSpiSelector.setPropertyValue("nshSpi", nshSpiId);
    } catch (Exception e) {
        log.error("Failed to set extension selector to match Nsh Spi Id for end rule {}", e.getMessage());
    }
    try {
        nshSiSelector.setPropertyValue("nshSi", NshServiceIndex.of(nshSi));
    } catch (Exception e) {
        log.error("Failed to set extension selector to match Nsh Si Id for end rule {}", e.getMessage());
    }
    try {
        encapEthTypeSelector.setPropertyValue("encapEthType", ENCAP_ETH_TYPE);
    } catch (Exception e) {
        log.error("Failed to set extension selector to match encapEthType {}", deviceId);
    }
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.extension(nshSpiSelector, deviceId);
    selector.extension(nshSiSelector, deviceId);
    // selector.extension(encapEthTypeSelector, deviceId);
    ExtensionTreatmentResolver treatmentResolver = handler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment tunGpeNpTreatment = treatmentResolver.getExtensionInstruction(NICIRA_TUN_GPE_NP.type());
    try {
        tunGpeNpTreatment.setPropertyValue("tunGpeNp", ((byte) 4));
    } catch (Exception e) {
        log.error("Failed to get extension instruction to set tunGpeNp {}", deviceId);
    }
    ExtensionTreatment moveC1ToC1 = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C1_TO_C1.type());
    ExtensionTreatment moveC2ToC2 = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C2_TO_C2.type());
    ExtensionTreatment moveC3ToC3 = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C3_TO_C3.type());
    ExtensionTreatment moveC4ToC4 = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C4_TO_C4.type());
    ExtensionTreatment moveTunIpv4DstToTunIpv4Dst = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_IPV4_DST_TO_TUN_IPV4_DST.type());
    ExtensionTreatment moveTunIdToTunId = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_ID_TO_TUN_ID.type());
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.extension(tunGpeNpTreatment, deviceId);
    treatment.extension(moveC1ToC1, deviceId);
    treatment.extension(moveC2ToC2, deviceId);
    treatment.extension(moveC3ToC3, deviceId);
    treatment.extension(moveC4ToC4, deviceId);
    treatment.extension(moveTunIpv4DstToTunIpv4Dst, deviceId);
    treatment.extension(moveTunIdToTunId, deviceId);
    Iterable<Device> devices = deviceService.getAvailableDevices();
    DeviceId localControllerId = getControllerId(deviceService.getDevice(deviceId), devices);
    DriverHandler controllerHandler = driverService.createHandler(localControllerId);
    BridgeConfig bridgeConfig = controllerHandler.behaviour(BridgeConfig.class);
    Set<PortNumber> ports = bridgeConfig.getPortNumbers();
    String tunnelName = "vxlan-" + DEFAULT_IP;
    ports.stream().filter(p -> p.name().equalsIgnoreCase(tunnelName)).forEach(p -> {
        treatment.setOutput(p);
        sendSfcRule(selector, treatment, deviceId, type, TUNNEL_SEND_PRIORITY);
    });
}
#method_after
public void installSfcTunnelSendRule(DeviceId deviceId, NshServicePathId nshSpiId, Objective.Operation type) {
    // Prepare selector with nsp, nsi and inport from egress of port pair
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionSelectorResolver selectorResolver = handler.behaviour(ExtensionSelectorResolver.class);
    ExtensionSelector nshSpiSelector = selectorResolver.getExtensionSelector(NICIRA_MATCH_NSH_SPI.type());
    ExtensionSelector nshSiSelector = selectorResolver.getExtensionSelector(NICIRA_MATCH_NSH_SI.type());
    ExtensionSelector encapEthTypeSelector = selectorResolver.getExtensionSelector(NICIRA_MATCH_ENCAP_ETH_TYPE.type());
    try {
        nshSpiSelector.setPropertyValue("nshSpi", nshSpiId);
    } catch (Exception e) {
        log.error("Failed to set extension selector to match Nsh Spi Id for end rule {}", e.getMessage());
    }
    try {
        nshSiSelector.setPropertyValue("nshSi", NshServiceIndex.of(nshSi));
    } catch (Exception e) {
        log.error("Failed to set extension selector to match Nsh Si Id for end rule {}", e.getMessage());
    }
    try {
        encapEthTypeSelector.setPropertyValue("encapEthType", ENCAP_ETH_TYPE);
    } catch (Exception e) {
        log.error("Failed to set extension selector to match encapEthType {}", deviceId);
    }
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.extension(nshSpiSelector, deviceId);
    selector.extension(nshSiSelector, deviceId);
    ExtensionTreatmentResolver treatmentResolver = handler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment tunGpeNpTreatment = treatmentResolver.getExtensionInstruction(NICIRA_TUN_GPE_NP.type());
    try {
        tunGpeNpTreatment.setPropertyValue("tunGpeNp", ((byte) 4));
    } catch (Exception e) {
        log.error("Failed to get extension instruction to set tunGpeNp {}", deviceId);
    }
    ExtensionTreatment moveC1ToC1 = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C1_TO_C1.type());
    ExtensionTreatment moveC2ToC2 = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C2_TO_C2.type());
    ExtensionTreatment moveC3ToC3 = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C3_TO_C3.type());
    ExtensionTreatment moveC4ToC4 = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C4_TO_C4.type());
    ExtensionTreatment moveTunIpv4DstToTunIpv4Dst = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_IPV4_DST_TO_TUN_IPV4_DST.type());
    ExtensionTreatment moveTunIdToTunId = treatmentResolver.getExtensionInstruction(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_ID_TO_TUN_ID.type());
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.extension(tunGpeNpTreatment, deviceId);
    treatment.extension(moveC1ToC1, deviceId);
    treatment.extension(moveC2ToC2, deviceId);
    treatment.extension(moveC3ToC3, deviceId);
    treatment.extension(moveC4ToC4, deviceId);
    treatment.extension(moveTunIpv4DstToTunIpv4Dst, deviceId);
    treatment.extension(moveTunIdToTunId, deviceId);
    Iterable<Device> devices = deviceService.getAvailableDevices();
    DeviceId localControllerId = getControllerId(deviceService.getDevice(deviceId), devices);
    DriverHandler controllerHandler = driverService.createHandler(localControllerId);
    BridgeConfig bridgeConfig = controllerHandler.behaviour(BridgeConfig.class);
    Set<PortNumber> ports = bridgeConfig.getPortNumbers();
    String tunnelName = "vxlan-" + DEFAULT_IP;
    ports.stream().filter(p -> p.name().equalsIgnoreCase(tunnelName)).forEach(p -> {
        treatment.setOutput(p);
        sendSfcRule(selector, treatment, deviceId, type, TUNNEL_SEND_PRIORITY);
    });
}
#end_block

#method_before
private static String getHwVersion(String version) {
    String[] textStr = version.split(NEWLINE_SPLITTER);
    String processor = SPACE;
    int i;
    for (i = 0; i < textStr.length - 1; i++) {
        if (textStr[i].indexOf(PHRASE) > 0) {
            String[] lineStr = textStr[i].trim().split(SPACE);
            processor = lineStr[1];
            break;
        } else {
            processor = SPACE;
        }
    }
    return processor;
}
#method_after
private static String getHwVersion(String version) {
    String[] textStr = version.split(NEWLINE_SPLITTER);
    String processor = SPACE;
    int i;
    for (i = 0; i < textStr.length; i++) {
        if (textStr[i].indexOf(PHRASE) > 0) {
            String[] lineStr = textStr[i].trim().split(SPACE);
            processor = lineStr[1];
            break;
        } else {
            processor = SPACE;
        }
    }
    return processor;
}
#end_block

#method_before
private static String getSwVersion(String version) {
    String[] textStr = version.split(NEWLINE_SPLITTER);
    int i;
    for (i = 0; i < textStr.length - 1; i++) {
        if (textStr[i].indexOf(VERSION) > 0) {
            break;
        }
    }
    String[] lineStr = textStr[i].trim().split(SPACE);
    StringBuilder sw = new StringBuilder();
    for (int j = 0; j < lineStr.length - 1; j++) {
        if (lineStr[j].equals(EOF_VERSION1) || lineStr[j].equals(EOF_VERSION2)) {
            sw.append(lineStr[j - 1] + SPACE);
        } else if (lineStr[j].equals(EOF_VERSION3)) {
            sw.append(lineStr[j - 1]);
            sw.setLength(sw.length() - 1);
        }
    }
    return sw.toString();
}
#method_after
private static String getSwVersion(String version) {
    String[] textStr = version.split(NEWLINE_SPLITTER);
    int i;
    for (i = 0; i < textStr.length; i++) {
        if (textStr[i].indexOf(VERSION) > 0) {
            break;
        }
    }
    String[] lineStr = textStr[i].trim().split(SPACE);
    StringBuilder sw = new StringBuilder();
    for (int j = 0; j < lineStr.length; j++) {
        if (lineStr[j].equals(EOF_VERSION1) || lineStr[j].equals(EOF_VERSION2)) {
            sw.append(lineStr[j - 1]).append(SPACE);
        } else if (lineStr[j].equals(EOF_VERSION3)) {
            sw.append(lineStr[j - 1]);
            sw.setLength(sw.length() - 1);
        }
    }
    return sw.toString();
}
#end_block

#method_before
private static String serialNumber(String version) {
    String[] textStr = version.split(NEWLINE_SPLITTER);
    int i;
    for (i = 0; i < textStr.length - 1; i++) {
        if (textStr[i].indexOf(PROCESSOR_BOARD) > 0) {
            break;
        }
    }
    return textStr[i].substring(textStr[i].indexOf(PROCESSOR_BOARD) + PROCESSOR_BOARD.length(), textStr[i].length());
}
#method_after
private static String serialNumber(String version) {
    String[] textStr = version.split(NEWLINE_SPLITTER);
    int i;
    for (i = 0; i < textStr.length; i++) {
        if (textStr[i].indexOf(PROCESSOR_BOARD) > 0) {
            break;
        }
    }
    return textStr[i].substring(textStr[i].indexOf(PROCESSOR_BOARD) + PROCESSOR_BOARD.length(), textStr[i].length());
}
#end_block

#method_before
private static DefaultPortDescription findPortInfo(String interfaceTree) {
    String[] textStr = interfaceTree.split(NEWLINE_SPLITTER);
    String[] firstLine = textStr[0].split(SPACE);
    String firstWord = firstLine[0];
    Port.Type type = getPortType(textStr);
    boolean isEnabled = getIsEnabled(textStr);
    String port = getPort(textStr);
    long portSpeed = getPortSpeed(textStr);
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, firstWord);
    return port == "-1" ? null : new DefaultPortDescription(PortNumber.portNumber(port), isEnabled, type, portSpeed, annotations.build());
}
#method_after
private static DefaultPortDescription findPortInfo(String interfaceTree) {
    String[] textStr = interfaceTree.split(NEWLINE_SPLITTER);
    String[] firstLine = textStr[0].split(SPACE);
    String firstWord = firstLine[0];
    Type type = getPortType(textStr);
    boolean isEnabled = getIsEnabled(textStr);
    String port = getPort(textStr);
    long portSpeed = getPortSpeed(textStr);
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, firstWord);
    return port.equals("-1") ? null : new DefaultPortDescription(PortNumber.portNumber(port), isEnabled, type, portSpeed, annotations.build());
}
#end_block

#method_before
private static String parentInterfaceMethod(String interfacesReply) {
    String firstCharacter;
    String first3Characters;
    boolean isChild = false;
    StringBuilder anInterface = new StringBuilder("");
    String[] textStr = interfacesReply.split("\\n");
    int lastLine = textStr.length - 1;
    for (int i = 1; i < lastLine; i++) {
        firstCharacter = textStr[i].substring(0, 1);
        first3Characters = textStr[i].substring(0, 3);
        if (!(firstCharacter.equals(SPACE)) && isChild) {
            break;
        } else if (firstCharacter.equals(SPACE) && isChild) {
            anInterface.append(textStr[i] + NEWLINE_SPLITTER);
        } else if (INTERFACES.contains(first3Characters)) {
            isChild = true;
            anInterface.append(textStr[i] + NEWLINE_SPLITTER);
        }
    }
    return anInterface.toString();
}
#method_after
private static String parentInterfaceMethod(String interfacesReply) {
    String firstCharacter;
    String first3Characters;
    boolean isChild = false;
    StringBuilder anInterface = new StringBuilder("");
    String[] textStr = interfacesReply.split("\\n");
    int lastLine = textStr.length - 1;
    for (int i = 1; i < lastLine; i++) {
        firstCharacter = textStr[i].substring(0, 1);
        first3Characters = textStr[i].substring(0, 3);
        if (!(firstCharacter.equals(SPACE)) && isChild) {
            break;
        } else if (firstCharacter.equals(SPACE) && isChild) {
            anInterface.append(textStr[i]).append(NEWLINE_SPLITTER);
        } else if (INTERFACES.contains(first3Characters)) {
            isChild = true;
            anInterface.append(textStr[i]).append(NEWLINE_SPLITTER);
        }
    }
    return anInterface.toString();
}
#end_block

#method_before
private static Port.Type getPortType(String[] textStr) {
    String first3Characters;
    first3Characters = textStr[0].substring(0, 3);
    return FIBERINTERFACES.contains(first3Characters) ? Port.Type.FIBER : Port.Type.COPPER;
}
#method_after
private static Type getPortType(String[] textStr) {
    String first3Characters;
    first3Characters = textStr[0].substring(0, 3);
    return FIBERINTERFACES.contains(first3Characters) ? Type.FIBER : Type.COPPER;
}
#end_block

#method_before
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (isDisabled) {
        return;
    }
    try {
        switch(msg.getType()) {
            case STATS_REPLY:
                if (((OFStatsReply) msg).getStatsType() == OFStatsType.PORT) {
                    OFPortStatsReply portStatsReply = (OFPortStatsReply) msg;
                    List<OFPortStatsEntry> portStatsReplyList = portStatsReplies.get(dpid);
                    if (portStatsReplyList == null) {
                        portStatsReplyList = Lists.newCopyOnWriteArrayList();
                    }
                    portStatsReplyList.addAll(portStatsReply.getEntries());
                    portStatsReplies.put(dpid, portStatsReplyList);
                    if (!portStatsReply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {
                        List<OFPortStatsEntry> statsEntries = portStatsReplies.get(dpid);
                        if (statsEntries != null) {
                            pushPortMetrics(dpid, statsEntries);
                            statsEntries.clear();
                        }
                    }
                } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.EXPERIMENTER) {
                    OpenFlowSwitch sw = controller.getSwitch(dpid);
                    if (sw instanceof OpenFlowOpticalSwitch) {
                        // Optical switch uses experimenter stats message to update power
                        List<PortDescription> portDescs = ((OpenFlowOpticalSwitch) sw).processExpPortStats(msg);
                        providerService.updatePorts(DeviceId.deviceId(Dpid.uri(dpid)), portDescs);
                    }
                }
                break;
            case ERROR:
                if (((OFErrorMsg) msg).getErrType() == OFErrorType.PORT_MOD_FAILED) {
                    LOG.error("port mod failed");
                }
            default:
                break;
        }
    } catch (IllegalStateException e) {
    // system is shutting down and the providerService is no longer
    // valid. Messages cannot be processed.
    }
}
#method_after
@Override
public void handleMessage(Dpid dpid, OFMessage msg) {
    if (isDisabled) {
        return;
    }
    try {
        switch(msg.getType()) {
            case STATS_REPLY:
                if (((OFStatsReply) msg).getStatsType() == OFStatsType.PORT) {
                    OFPortStatsReply portStatsReply = (OFPortStatsReply) msg;
                    List<OFPortStatsEntry> portStatsReplyList = portStatsReplies.get(dpid);
                    if (portStatsReplyList == null) {
                        portStatsReplyList = Lists.newCopyOnWriteArrayList();
                    }
                    portStatsReplyList.addAll(portStatsReply.getEntries());
                    portStatsReplies.put(dpid, portStatsReplyList);
                    if (!portStatsReply.getFlags().contains(OFStatsReplyFlags.REPLY_MORE)) {
                        List<OFPortStatsEntry> statsEntries = portStatsReplies.get(dpid);
                        if (statsEntries != null) {
                            pushPortMetrics(dpid, statsEntries);
                            statsEntries.clear();
                        }
                    }
                } else if (((OFStatsReply) msg).getStatsType() == OFStatsType.EXPERIMENTER) {
                    OpenFlowSwitch sw = controller.getSwitch(dpid);
                    if (sw instanceof OpenFlowOpticalSwitch) {
                        // Optical switch uses experimenter stats message to update power
                        List<PortDescription> portDescs = ((OpenFlowOpticalSwitch) sw).processExpPortStats(msg);
                        if (!portDescs.isEmpty()) {
                            providerService.updatePorts(DeviceId.deviceId(Dpid.uri(dpid)), portDescs);
                        }
                    }
                }
                break;
            case ERROR:
                if (((OFErrorMsg) msg).getErrType() == OFErrorType.PORT_MOD_FAILED) {
                    LOG.error("port mod failed");
                }
            default:
                break;
        }
    } catch (IllegalStateException e) {
    // system is shutting down and the providerService is no longer
    // valid. Messages cannot be processed.
    }
}
#end_block

#method_before
@Override
public Optional<Long> currentPower(PortNumber portNum, Direction component) {
    DeviceService deviceService = this.handler().get(DeviceService.class);
    Port port = deviceService.getPort(this.data().deviceId(), portNum);
    String currentPower = port.annotations().value(AnnotationKeys.CURRENT_POWER);
    Long returnVal = null;
    if (currentPower != null) {
        returnVal = Long.valueOf(currentPower);
    }
    return Optional.ofNullable(returnVal);
}
#method_after
@Override
public Optional<Long> currentPower(PortNumber portNum, Direction component) {
    Long returnVal = null;
    // which is obsolete.
    if (getOpenFlowDevice() != null) {
        DeviceService deviceService = this.handler().get(DeviceService.class);
        Port port = deviceService.getPort(this.data().deviceId(), portNum);
        if (port != null) {
            String currentPower = port.annotations().value(AnnotationKeys.CURRENT_POWER);
            if (currentPower != null) {
                returnVal = Long.valueOf(currentPower);
            }
        }
    }
    return Optional.ofNullable(returnVal);
}
#end_block

#method_before
@Override
public final void sendMsg(OFMessage m) {
    OFMessage newMsg = m;
    if (m.getType() == OFType.STATS_REQUEST) {
        OFStatsRequest sr = (OFStatsRequest) m;
        log.debug("Oplink rebuilding stats request type {}", sr.getStatsType());
        switch(sr.getStatsType()) {
            case PORT:
                // replace with Oplink experiment stats message to get the port current power
                OFOplinkPortPowerRequest pRequest = this.factory().buildOplinkPortPowerRequest().setXid(sr.getXid()).setFlags(sr.getFlags()).build();
                newMsg = pRequest;
                break;
            default:
                break;
        }
    } else {
        log.warn("send msg:{}, as is", m.getType());
    }
    super.sendMsg(newMsg);
}
#method_after
@Override
public final void sendMsg(OFMessage m) {
    OFMessage newMsg = m;
    if (m.getType() == OFType.STATS_REQUEST) {
        OFStatsRequest sr = (OFStatsRequest) m;
        log.debug("OPLK ROADM rebuilding stats request type {}", sr.getStatsType());
        switch(sr.getStatsType()) {
            case PORT:
                // replace with Oplink experiment stats message to get the port current power
                OFOplinkPortPowerRequest pRequest = this.factory().buildOplinkPortPowerRequest().setXid(sr.getXid()).setFlags(sr.getFlags()).build();
                newMsg = pRequest;
                break;
            default:
                break;
        }
    } else {
        log.debug("OPLK ROADM sends msg:{}, as is", m.getType());
    }
    super.sendMsg(newMsg);
}
#end_block

#method_before
@Override
public List<Intent> compile(VirtualNetworkIntent intent, List<Intent> installable) {
    log.info("Compiling intent: " + intent);
    List<Intent> intents = new ArrayList<>();
    Optional<Path> path = getPaths(intent).stream().findFirst();
    if (path != null && path.isPresent()) {
        path.get().links().forEach(link -> {
            Intent physicalIntent = createPtPtIntent(intent, link);
            intents.add(physicalIntent);
            // store the virtual intent to physical intent tunnelId mapping
            store.addTunnelId(intent, TunnelId.valueOf(physicalIntent.key().toString()));
        });
    } else {
        throw new IntentCompilationException("Unable to find a path for intent " + intent);
    }
    return intents;
}
#method_after
@Override
public List<Intent> compile(VirtualNetworkIntent intent, List<Intent> installable) {
    log.debug("Compiling intent: " + intent);
    List<Intent> intents = new ArrayList<>();
    Optional<Path> path = getPaths(intent).stream().findFirst();
    if (path != null && path.isPresent()) {
        path.get().links().forEach(link -> {
            Intent physicalIntent = createPtPtIntent(intent, link);
            intents.add(physicalIntent);
            // store the virtual intent to physical intent tunnelId mapping
            store.addTunnelId(intent, TunnelId.valueOf(physicalIntent.key().toString()));
        });
    } else {
        throw new IntentCompilationException("Unable to find a path for intent " + intent);
    }
    return intents;
}
#end_block

#method_before
private Intent createPtPtIntent(VirtualNetworkIntent intent, Link link) {
    ConnectPoint ingressPoint = mapVirtualToPhysicalPort(intent.networkId(), link.src());
    ConnectPoint egressPoint = mapVirtualToPhysicalPort(intent.networkId(), link.dst());
    Key intentKey = encodeKey(intent.networkId(), intent.appId(), ingressPoint, egressPoint);
    List<Constraint> constraints = new ArrayList<>();
    constraints.add(new EncapsulationConstraint(EncapsulationType.VLAN));
    // TODO Currently there can only be one intent between the ingress and egress across
    // all virtual networks. We may want to support multiple intents between the same src/dst pairs.
    PointToPointIntent physicalIntent = PointToPointIntent.builder().key(intentKey).appId(intent.appId()).ingressPoint(ingressPoint).egressPoint(egressPoint).constraints(constraints).build();
    log.info("Submitting physical intent: " + physicalIntent);
    intentService.submit(physicalIntent);
    return physicalIntent;
}
#method_after
private Intent createPtPtIntent(VirtualNetworkIntent intent, Link link) {
    ConnectPoint ingressPoint = mapVirtualToPhysicalPort(intent.networkId(), link.src());
    ConnectPoint egressPoint = mapVirtualToPhysicalPort(intent.networkId(), link.dst());
    Key intentKey = encodeKey(intent.networkId(), intent.appId(), ingressPoint, egressPoint);
    List<Constraint> constraints = new ArrayList<>();
    constraints.add(new EncapsulationConstraint(EncapsulationType.VLAN));
    // TODO Currently there can only be one intent between the ingress and egress across
    // all virtual networks. We may want to support multiple intents between the same src/dst pairs.
    PointToPointIntent physicalIntent = PointToPointIntent.builder().key(intentKey).appId(intent.appId()).ingressPoint(ingressPoint).egressPoint(egressPoint).constraints(constraints).build();
    log.debug("Submitting physical intent: " + physicalIntent);
    intentService.submit(physicalIntent);
    return physicalIntent;
}
#end_block

#method_before
@Activate
protected void activate() {
    appId = coreService.registerApplication(PCE_SERVICE_APP);
    crHandler = BasicPceccHandler.getInstance();
    crHandler.initialize(labelRsrcService, flowObjectiveService, appId, pceStore);
    srTeHandler = PceccSrTeBeHandler.getInstance();
    srTeHandler.initialize(labelRsrcAdminService, labelRsrcService, flowObjectiveService, appId, pceStore, deviceService);
    tunnelService.addListener(listener);
    deviceService.addListener(deviceListener);
    linkService.addListener(linkListener);
    netCfgService.addListener(cfgListener);
    tunnelConsumerIdGen = coreService.getIdGenerator(TUNNEL_CONSUMER_ID_GEN_TOPIC);
    localLspIdIdGen = coreService.getIdGenerator(LOCAL_LSP_ID_GEN_TOPIC);
    // To prevent 0, the 1st value generated from being used in protocol.
    localLspIdIdGen.getNewId();
    localLspIdFreeList = storageService.<Short>setBuilder().withName("pcepLocalLspIdDeletedList").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
    packetService.addProcessor(processor, PacketProcessor.director(4));
    topologyService.addListener(topologyListener);
    executor = Executors.newSingleThreadScheduledExecutor();
    // Start a timer when the component is up, with initial delay of 30min and periodic delays at 30min
    executor.scheduleAtFixedRate(new GlobalOptimizationTimer(), INITIAL_DELAY, PERIODIC_DELAY, TimeUnit.MINUTES);
    // Reserve global node pool
    if (!srTeHandler.reserveGlobalPool(GLOBAL_LABEL_SPACE_MIN, GLOBAL_LABEL_SPACE_MAX)) {
        log.debug("Global node pool was already reserved.");
    }
    log.info("Started");
}
#method_after
@Activate
protected void activate() {
    appId = coreService.registerApplication(PCE_SERVICE_APP);
    crHandler = BasicPceccHandler.getInstance();
    crHandler.initialize(labelRsrcService, flowObjectiveService, appId, pceStore);
    srTeHandler = PceccSrTeBeHandler.getInstance();
    srTeHandler.initialize(labelRsrcAdminService, labelRsrcService, flowObjectiveService, appId, pceStore, deviceService);
    tunnelService.addListener(listener);
    deviceService.addListener(deviceListener);
    linkService.addListener(linkListener);
    netCfgService.addListener(cfgListener);
    tunnelConsumerIdGen = coreService.getIdGenerator(TUNNEL_CONSUMER_ID_GEN_TOPIC);
    localLspIdIdGen = coreService.getIdGenerator(LOCAL_LSP_ID_GEN_TOPIC);
    // To prevent 0, the 1st value generated from being used in protocol.
    localLspIdIdGen.getNewId();
    localLspIdFreeList = storageService.<Short>setBuilder().withName("pcepLocalLspIdDeletedList").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
    packetService.addProcessor(processor, PacketProcessor.director(4));
    topologyService.addListener(topologyListener);
    // Reserve global node pool
    if (!srTeHandler.reserveGlobalPool(GLOBAL_LABEL_SPACE_MIN, GLOBAL_LABEL_SPACE_MAX)) {
        log.debug("Global node pool was already reserved.");
    }
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    tunnelService.removeListener(listener);
    deviceService.removeListener(deviceListener);
    linkService.removeListener(linkListener);
    netCfgService.removeListener(cfgListener);
    packetService.removeProcessor(processor);
    topologyService.removeListener(topologyListener);
    // Shutdown the thread when component is deactivated
    executor.shutdown();
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    tunnelService.removeListener(listener);
    deviceService.removeListener(deviceListener);
    linkService.removeListener(linkListener);
    netCfgService.removeListener(cfgListener);
    packetService.removeProcessor(processor);
    topologyService.removeListener(topologyListener);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public LinkProvider provider() {
    // TODO Auto-generated method stub
    return null;
}
#method_after
@Override
public DeviceProvider provider() {
    return null;
}
#end_block

#method_before
@Override
public Iterable<Link> getActiveLinks() {
    return FluentIterable.from(links).filter(input -> input.state() == Link.State.ACTIVE);
}
#method_after
@Override
public Iterable<Link> getActiveLinks() {
    return FluentIterable.from(links).filter(input -> input.state() == ACTIVE);
}
#end_block

#method_before
private void handleRptWithoutSrpId(PcepStateReport stateRpt, PccId pccId) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    String costType = null;
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepEroObject eroObj = msgPath.getEroObject();
    if (eroObj == null) {
        log.error("ERO object is null in report message.");
        return;
    }
    PcepAttribute attributes = msgPath.getPcepAttribute();
    float bandwidth = 0;
    int cost = 0;
    if (attributes != null) {
        if (attributes.getMetricObjectList() != null) {
            ListIterator<PcepMetricObject> iterator = attributes.getMetricObjectList().listIterator();
            PcepMetricObject metricObj = iterator.next();
            while (metricObj != null) {
                if (metricObj.getBType() == IGP_METRIC) {
                    costType = "COST";
                } else if (metricObj.getBType() == TE_METRIC) {
                    costType = "TE_COST";
                }
                if (costType != null) {
                    cost = metricObj.getMetricVal();
                    log.debug("Path cost {}", cost);
                    break;
                }
                metricObj = iterator.next();
            }
        }
        if (attributes.getBandwidthObject() != null) {
            bandwidth = attributes.getBandwidthObject().getBandwidth();
        }
    }
    List<Object> eroSubObjList = buildPathFromEroObj(eroObj, providerId);
    List<Link> links = new ArrayList<>();
    List<LabelResourceId> labels = new ArrayList<>();
    for (Object linkOrLabel : eroSubObjList) {
        if (linkOrLabel instanceof Link) {
            links.add((Link) linkOrLabel);
        } else if (linkOrLabel instanceof Integer) {
            labels.add(LabelResourceId.labelResourceId(((Integer) linkOrLabel).longValue()));
        }
    }
    Path path = new DefaultPath(providerId, links, cost, EMPTY);
    NetworkResource labelStack = new DefaultLabelStack(labels);
    // To carry PST TLV, SRP object can be present with value 0 even when PCRpt is not in response to any action
    // from PCE.
    PcepSrpObject srpObj = stateRpt.getSrpObject();
    LspType lspType = getLspType(srpObj);
    PcepLspObject lspObj = stateRpt.getLspObject();
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv = null;
    SymbolicPathNameTlv pathNameTlv = null;
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        switch(tlv.getType()) {
            case StatefulIPv4LspIdentifiersTlv.TYPE:
                ipv4LspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                break;
            case SymbolicPathNameTlv.TYPE:
                pathNameTlv = (SymbolicPathNameTlv) tlv;
                break;
            default:
                break;
        }
    }
    /*
             * Draft says: The LSP-IDENTIFIERS TLV MUST be included in the LSP object in PCRpt messages for
             * RSVP-signaled LSPs. For ONOS PCECC implementation, it is mandatory.
             */
    if (ipv4LspIdenTlv == null) {
        log.error("Stateful IPv4 identifier TLV is null in PCRpt msg.");
        return;
    }
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4EgressAddress()));
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(tunnelEndPointSrc, tunnelEndPointDst);
    // not present then non-delegated , if present it is delegated.
    if (lspObj.getDFlag()) {
        pcepClientController.getClient(pccId).setLspAndDelegationInfo(new LspKey(lspObj.getPlspId(), ipv4LspIdenTlv.getLspId()), lspObj.getDFlag());
    }
    Tunnel tunnel = null;
    // Asynchronous status change message from PCC for LSP reported earlier.
    for (Tunnel tunnelObj : tunnelQueryResult) {
        if (tunnelObj.annotations().value(PLSP_ID) == null) {
            /*
                     * PLSP_ID is null while Tunnel is created at PCE and PCInit msg carries it as 0. It is allocated by
                     * PCC and in that case it becomes the first PCRpt msg from PCC for this LSP, and hence symbolic
                     * path name must be carried in the PCRpt msg. Draft says: The SYMBOLIC-PATH-NAME TLV "MUST" be
                     * included in the LSP object in the LSP State Report (PCRpt) message when during a given PCEP
                     * session an LSP is "first" reported to a PCE.
                     */
            if ((pathNameTlv != null) && Arrays.equals(tunnelObj.tunnelName().value().getBytes(), pathNameTlv.getValue())) {
                tunnel = tunnelObj;
                break;
            }
            continue;
        }
        if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Integer.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspIdenTlv.getLspId())) {
            tunnel = tunnelObj;
            break;
        }
    }
    DefaultTunnelDescription td;
    SparseAnnotations annotations = null;
    State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
    if (tunnel == null) {
        if (lspObj.getRFlag()) {
            /*
                     * If PCC sends remove message and for any reason PCE does not have that entry, simply discard the
                     * message. Or if PCRpt for initiated LSP received and PCE doesn't know, then too discard.
                     */
            return;
        }
        DeviceId deviceId = getDevice(pccId);
        if (deviceId == null) {
            log.error("Ingress deviceId not found");
            return;
        }
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType, costType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), path, labelStack, annotations);
        // Do not support PCC initiated LSP after LSP DB sync is completed.
        if (!lspObj.getSFlag() && !lspObj.getCFlag()) {
            log.error("Received PCC initiated LSP while not in sync.");
            return;
        }
        /*
                 * If ONOS instance is master for PCC then set delegated flag as annotation and add the tunnel to store.
                 * Because all LSPs need not be delegated, hence mastership for the PCC is confirmed whereas not the
                 * delegation set to all LSPs.If ONOS is not the master for that PCC then check if D flag is set, if yes
                 * wait for 2 seconds [while master has added the tunnel to the store] then update the tunnel. Tunnel is
                 * updated because in case of resilency only delegated LSPs are recomputed and only delegated PCE can
                 * send update message to that client.
                 *
                 * 1)Master can 1st get the Rpt message
                 * a)Master adds the tunnel into core.
                 * b)If a non-master for ingress gets Rpt message with D flag set[as delegation owner]
                 *  after master, then runs timer then update the tunnel with D flag set.
                 * 2)Non-Master can 1st get the Rpt message
                 * a)Non-Master runs the timer check for the tunnel then updates the tunnel with D flag set
                 * b)Master would have got the message while the non-master running timer, hence master adds
                 *  tunnel to core
                 *
                 * In general always master adds the tunnel to the core
                 * while delegated owner [master or non-master with D flag set] always updates the tunnel running timer
                 */
        if (mastershipService.isLocalMaster(deviceId)) {
            TunnelId tId = tunnelAdded(td, tunnelState);
            Tunnel tunnelInserted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, tunnelState, new DefaultGroupId(0), tId, TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, labelStack, annotations);
            PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelInserted, path, LSP_STATE_RPT);
            pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
            pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        } else if (!mastershipService.isLocalMaster(deviceId) && lspObj.getDFlag()) {
            // Start timer then update the tunnel with D flag
            tunnelUpdateInDelegatedCase(pccId, annotations, td, providerId);
        }
        return;
    }
    // delegated owner will update can be a master or non-master
    if (lspObj.getDFlag()) {
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType, costType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), tunnel.path(), labelStack, annotations);
        tunnelUpdateInDelegatedCase(pccId, annotations, td, providerId);
    }
    removeOrUpdatetunnel(tunnel, pccId, lspObj, providerId, tunnelState);
    return;
}
#method_after
private void handleRptWithoutSrpId(PcepStateReport stateRpt, PccId pccId) {
    ProviderId providerId = new ProviderId("pcep", PROVIDER_ID);
    String costType = null;
    PcepStateReport.PcepMsgPath msgPath = stateRpt.getMsgPath();
    checkNotNull(msgPath);
    PcepEroObject eroObj = msgPath.getEroObject();
    if (eroObj == null) {
        log.error("ERO object is null in report message.");
        return;
    }
    PcepAttribute attributes = msgPath.getPcepAttribute();
    float bandwidth = 0;
    int cost = 0;
    if (attributes != null) {
        if (attributes.getMetricObjectList() != null) {
            ListIterator<PcepMetricObject> iterator = attributes.getMetricObjectList().listIterator();
            PcepMetricObject metricObj = iterator.next();
            while (metricObj != null) {
                if (metricObj.getBType() == IGP_METRIC) {
                    costType = "COST";
                } else if (metricObj.getBType() == TE_METRIC) {
                    costType = "TE_COST";
                }
                if (costType != null) {
                    cost = metricObj.getMetricVal();
                    log.debug("Path cost {}", cost);
                    break;
                }
                metricObj = iterator.next();
            }
        }
        if (attributes.getBandwidthObject() != null) {
            bandwidth = attributes.getBandwidthObject().getBandwidth();
        }
    }
    List<Object> eroSubObjList = buildPathFromEroObj(eroObj, providerId);
    List<Link> links = new ArrayList<>();
    List<LabelResourceId> labels = new ArrayList<>();
    for (Object linkOrLabel : eroSubObjList) {
        if (linkOrLabel instanceof Link) {
            links.add((Link) linkOrLabel);
        } else if (linkOrLabel instanceof Integer) {
            labels.add(LabelResourceId.labelResourceId(((Integer) linkOrLabel).longValue()));
        }
    }
    Path path = new DefaultPath(providerId, links, cost, EMPTY);
    NetworkResource labelStack = new DefaultLabelStack(labels);
    // To carry PST TLV, SRP object can be present with value 0 even when PCRpt is not in response to any action
    // from PCE.
    PcepSrpObject srpObj = stateRpt.getSrpObject();
    LspType lspType = getLspType(srpObj);
    PcepLspObject lspObj = stateRpt.getLspObject();
    ListIterator<PcepValueType> listTlvIterator = lspObj.getOptionalTlv().listIterator();
    StatefulIPv4LspIdentifiersTlv ipv4LspIdenTlv = null;
    SymbolicPathNameTlv pathNameTlv = null;
    while (listTlvIterator.hasNext()) {
        PcepValueType tlv = listTlvIterator.next();
        switch(tlv.getType()) {
            case StatefulIPv4LspIdentifiersTlv.TYPE:
                ipv4LspIdenTlv = (StatefulIPv4LspIdentifiersTlv) tlv;
                break;
            case SymbolicPathNameTlv.TYPE:
                pathNameTlv = (SymbolicPathNameTlv) tlv;
                break;
            default:
                break;
        }
    }
    /*
             * Draft says: The LSP-IDENTIFIERS TLV MUST be included in the LSP object in PCRpt messages for
             * RSVP-signaled LSPs. For ONOS PCECC implementation, it is mandatory.
             */
    if (ipv4LspIdenTlv == null) {
        log.error("Stateful IPv4 identifier TLV is null in PCRpt msg.");
        return;
    }
    IpTunnelEndPoint tunnelEndPointSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4IngressAddress()));
    IpTunnelEndPoint tunnelEndPointDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(ipv4LspIdenTlv.getIpv4EgressAddress()));
    Collection<Tunnel> tunnelQueryResult = tunnelService.queryTunnel(tunnelEndPointSrc, tunnelEndPointDst);
    // not present then non-delegated , if present it is delegated.
    if (lspObj.getDFlag()) {
        pcepClientController.getClient(pccId).setLspAndDelegationInfo(new LspKey(lspObj.getPlspId(), ipv4LspIdenTlv.getLspId()), lspObj.getDFlag());
    }
    Tunnel tunnel = null;
    // Asynchronous status change message from PCC for LSP reported earlier.
    for (Tunnel tunnelObj : tunnelQueryResult) {
        if (tunnelObj.annotations().value(PLSP_ID) == null) {
            /*
                     * PLSP_ID is null while Tunnel is created at PCE and PCInit msg carries it as 0. It is allocated by
                     * PCC and in that case it becomes the first PCRpt msg from PCC for this LSP, and hence symbolic
                     * path name must be carried in the PCRpt msg. Draft says: The SYMBOLIC-PATH-NAME TLV "MUST" be
                     * included in the LSP object in the LSP State Report (PCRpt) message when during a given PCEP
                     * session an LSP is "first" reported to a PCE.
                     */
            if ((pathNameTlv != null) && Arrays.equals(tunnelObj.tunnelName().value().getBytes(), pathNameTlv.getValue())) {
                tunnel = tunnelObj;
                break;
            }
            continue;
        }
        if ((Integer.valueOf(tunnelObj.annotations().value(PLSP_ID)) == lspObj.getPlspId()) && (Integer.valueOf(tunnelObj.annotations().value(LOCAL_LSP_ID)) == ipv4LspIdenTlv.getLspId())) {
            tunnel = tunnelObj;
            break;
        }
    }
    DefaultTunnelDescription td;
    SparseAnnotations annotations = null;
    State tunnelState = PcepLspStatus.getTunnelStatusFromLspStatus(PcepLspStatus.values()[lspObj.getOFlag()]);
    if (tunnel == null) {
        if (lspObj.getRFlag()) {
            /*
                     * If PCC sends remove message and for any reason PCE does not have that entry, simply discard the
                     * message. Or if PCRpt for initiated LSP received and PCE doesn't know, then too discard.
                     */
            return;
        }
        DeviceId deviceId = getDevice(pccId);
        if (deviceId == null) {
            log.error("Ingress deviceId not found");
            return;
        }
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType, costType);
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), path, labelStack, annotations);
        // Do not support PCC initiated LSP after LSP DB sync is completed.
        if (!lspObj.getSFlag() && !lspObj.getCFlag()) {
            log.error("Received PCC initiated LSP while not in sync.");
            return;
        }
        /*
                 * If ONOS instance is master for PCC then set delegated flag as annotation and add the tunnel to store.
                 * Because all LSPs need not be delegated, hence mastership for the PCC is confirmed whereas not the
                 * delegation set to all LSPs.If ONOS is not the master for that PCC then check if D flag is set, if yes
                 * wait for 2 seconds [while master has added the tunnel to the store] then update the tunnel. Tunnel is
                 * updated because in case of resilency only delegated LSPs are recomputed and only delegated PCE can
                 * send update message to that client.
                 *
                 * 1)Master can 1st get the Rpt message
                 * a)Master adds the tunnel into core.
                 * b)If a non-master for ingress gets Rpt message with D flag set[as delegation owner]
                 *  after master, then runs timer then update the tunnel with D flag set.
                 * 2)Non-Master can 1st get the Rpt message
                 * a)Non-Master runs the timer check for the tunnel then updates the tunnel with D flag set
                 * b)Master would have got the message while the non-master running timer, hence master adds
                 *  tunnel to core
                 *
                 * In general always master adds the tunnel to the core
                 * while delegated owner [master or non-master with D flag set] always updates the tunnel running timer
                 */
        if (mastershipService.isLocalMaster(deviceId)) {
            TunnelId tId = tunnelAdded(td, tunnelState);
            Tunnel tunnelInserted = new DefaultTunnel(providerId, tunnelEndPointSrc, tunnelEndPointDst, MPLS, tunnelState, new DefaultGroupId(0), tId, TunnelName.tunnelName(String.valueOf(pathNameTlv.getValue())), path, labelStack, annotations);
            PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnelInserted, path, LSP_STATE_RPT);
            pcepTunnelData.setStatefulIpv4IndentifierTlv(ipv4LspIdenTlv);
            pcepTunnelApiMapper.addToTunnelIdMap(pcepTunnelData);
        } else if (!mastershipService.isLocalMaster(deviceId) && lspObj.getDFlag()) {
            // Start timer then update the tunnel with D flag
            tunnelUpdateInDelegatedCase(pccId, annotations, td, providerId);
        }
        return;
    }
    // delegated owner will update can be a master or non-master
    if (lspObj.getDFlag()) {
        if (tunnel.annotations().value(BANDWIDTH) != null) {
            bandwidth = Float.parseFloat(tunnel.annotations().value(BANDWIDTH));
        }
        annotations = getAnnotations(lspObj, ipv4LspIdenTlv, bandwidth, lspType, tunnel.annotations().value(COST_TYPE));
        td = new DefaultTunnelDescription(null, tunnelEndPointSrc, tunnelEndPointDst, MPLS, new DefaultGroupId(0), providerId, TunnelName.tunnelName(new String(pathNameTlv.getValue())), tunnel.path(), labelStack, annotations);
        tunnelUpdateInDelegatedCase(pccId, annotations, td, providerId);
    }
    removeOrUpdatetunnel(tunnel, pccId, lspObj, providerId, tunnelState);
    return;
}
#end_block

#method_before
@Override
public OpticalConnectivityId setupPath(Path path, Bandwidth bandwidth, Duration latency) {
    checkNotNull(path);
    log.info("setupPath({}, {}, {})", path, bandwidth, latency);
    // validate optical path
    List<Pair<ConnectPoint, ConnectPoint>> xcPointPairs = getCrossConnectPoints(path);
    if (!checkXcPoints(xcPointPairs)) {
        // Can't setup path if cross connect points are mismatched
        log.error("Failed to setup path because of mismatched cross connect points.");
        return null;
    }
    OpticalConnectivity connectivity = createConnectivity(path, bandwidth, latency);
    // create intents from cross connect points and set connectivity information
    List<Intent> intents = createIntents(xcPointPairs, connectivity);
    // store cross connect port usage
    path.links().stream().filter(this::isCrossConnectLink).forEach(usedCrossConnectLinkSet::add);
    // Submit the intents
    for (Intent i : intents) {
        intentService.submit(i);
        log.debug("Submitted an intent: {}", i);
    }
    return connectivity.id();
}
#method_after
@Override
public OpticalConnectivityId setupPath(Path path, Bandwidth bandwidth, Duration latency) {
    checkNotNull(path);
    log.info("setupPath({}, {}, {})", path, bandwidth, latency);
    // map of cross connect points (optical port -> packet port)
    Map<ConnectPoint, ConnectPoint> crossConnectPointMap = new HashMap<>();
    // list of (src, dst) pair of optical ports between which optical path should be installed
    List<Pair<ConnectPoint, ConnectPoint>> crossConnectPoints = new ArrayList<>();
    // Scan path to find pairs of connect points between which optical intent is installed
    // opticalSrcPort works as a flag parameter to show scanning status
    ConnectPoint opticalSrcPort = null;
    for (Link link : path.links()) {
        if (!isCrossConnectLink(link)) {
            continue;
        }
        if (opticalSrcPort != null) {
            // opticalSrcPort!=null means src port was already found
            // in this case link.src() is optical layer, and link.dst() is packet layer
            // Check if types of src port and dst port matches
            Device srcDevice = checkNotNull(deviceService.getDevice(opticalSrcPort.deviceId()), "Unknown device ID");
            Device dstDevice = checkNotNull(deviceService.getDevice(link.src().deviceId()), "Unknown device ID");
            if (srcDevice.type() != dstDevice.type()) {
                log.error("Unsupported mix of cross connect points : {}, {}", srcDevice.type(), dstDevice.type());
                return null;
            }
            // Update cross connect points map
            crossConnectPointMap.put(link.src(), link.dst());
            // Add optical ports pair to list
            crossConnectPoints.add(Pair.of(opticalSrcPort, link.src()));
            // Reset flag parameter
            opticalSrcPort = null;
        } else {
            // opticalSrcPort==null means src port was not found yet
            // in this case link.src() is packet layer, and link.dst() is optical layer
            // Update cross connect points map
            crossConnectPointMap.put(link.dst(), link.src());
            // Set opticalSrcPort to src of link (optical port)
            opticalSrcPort = link.dst();
        }
    }
    // create intents from cross connect points
    List<Intent> intents = createIntents(crossConnectPoints);
    // create set of PacketLinkRealizedByOptical
    Set<PacketLinkRealizedByOptical> packetLinks = createPacketLinkSet(crossConnectPoints, intents, crossConnectPointMap);
    // create OpticalConnectivity object and store information to distributed store
    OpticalConnectivity connectivity = createConnectivity(path, bandwidth, latency, packetLinks);
    // store cross connect port usage
    path.links().stream().filter(this::isCrossConnectLink).forEach(usedCrossConnectLinkSet::add);
    // Submit the intents
    for (Intent i : intents) {
        intentService.submit(i);
        log.debug("Submitted an intent: {}", i);
    }
    return connectivity.id();
}
#end_block

#method_before
private OpticalConnectivity createConnectivity(Path path, Bandwidth bandwidth, Duration latency) {
    OpticalConnectivityId id = OpticalConnectivityId.of(idCounter.getAndIncrement());
    OpticalConnectivity connectivity = new OpticalConnectivity(id, path, bandwidth, latency);
    // store connectivity information
    connectivityMap.put(connectivity.id(), connectivity);
    return connectivity;
}
#method_after
private OpticalConnectivity createConnectivity(Path path, Bandwidth bandwidth, Duration latency, Set<PacketLinkRealizedByOptical> links) {
    OpticalConnectivityId id = OpticalConnectivityId.of(idCounter.getAndIncrement());
    OpticalConnectivity connectivity = new OpticalConnectivity(id, path.links(), bandwidth, latency, links, Collections.emptySet());
    links.forEach(l -> linkPathMap.put(l, connectivity));
    // store connectivity information
    connectivityMap.put(connectivity.id(), connectivity);
    return connectivity;
}
#end_block

#method_before
private List<Intent> createIntents(List<Pair<ConnectPoint, ConnectPoint>> xcPointPairs, OpticalConnectivity connectivity) {
    checkArgument(xcPointPairs.size() % 2 == 0);
    List<Intent> intents = new LinkedList<>();
    Iterator<Pair<ConnectPoint, ConnectPoint>> itr = xcPointPairs.iterator();
    while (itr.hasNext()) {
        // checkArgument at start ensures we'll always have pairs of connect points
        Pair<ConnectPoint, ConnectPoint> src = itr.next();
        Pair<ConnectPoint, ConnectPoint> dst = itr.next();
        Port srcPort = deviceService.getPort(src.getKey().deviceId(), src.getKey().port());
        Port dstPort = deviceService.getPort(dst.getKey().deviceId(), dst.getKey().port());
        if (srcPort instanceof OduCltPort && dstPort instanceof OduCltPort) {
            OduCltPort srcOCPort = (OduCltPort) srcPort;
            OduCltPort dstOCPort = (OduCltPort) dstPort;
            if (!srcOCPort.signalType().equals(dstOCPort.signalType())) {
                continue;
            }
            // Create OTN circuit
            OpticalCircuitIntent circuitIntent = OpticalCircuitIntent.builder().appId(appId).src(src.getKey()).dst(dst.getKey()).signalType(srcOCPort.signalType()).bidirectional(true).build();
            intents.add(circuitIntent);
            PacketLinkRealizedByOptical pLink = PacketLinkRealizedByOptical.create(src.getValue(), dst.getValue(), circuitIntent);
            connectivity.addRealizingLink(pLink);
            linkPathMap.put(pLink, connectivity);
        } else if (srcPort instanceof OchPort && dstPort instanceof OchPort) {
            OchPort srcOchPort = (OchPort) srcPort;
            OchPort dstOchPort = (OchPort) dstPort;
            if (!srcOchPort.signalType().equals(dstOchPort.signalType())) {
                continue;
            }
            // Create lightpath
            OpticalConnectivityIntent opticalIntent = OpticalConnectivityIntent.builder().appId(appId).src(src.getKey()).dst(dst.getKey()).signalType(srcOchPort.signalType()).bidirectional(true).build();
            intents.add(opticalIntent);
            PacketLinkRealizedByOptical pLink = PacketLinkRealizedByOptical.create(src.getValue(), dst.getValue(), opticalIntent);
            connectivity.addRealizingLink(pLink);
            linkPathMap.put(pLink, connectivity);
        } else {
            log.warn("Unsupported cross connect point types {} {}", srcPort.type(), dstPort.type());
            return Collections.emptyList();
        }
    }
    return intents;
}
#method_after
private List<Intent> createIntents(List<Pair<ConnectPoint, ConnectPoint>> crossConnectPoints) {
    List<Intent> intents = new LinkedList<>();
    Iterator<Pair<ConnectPoint, ConnectPoint>> itr = crossConnectPoints.iterator();
    while (itr.hasNext()) {
        // checkArgument at start ensures we'll always have pairs of connect points
        Pair<ConnectPoint, ConnectPoint> next = itr.next();
        ConnectPoint src = next.getLeft();
        ConnectPoint dst = next.getRight();
        Port srcPort = deviceService.getPort(src.deviceId(), src.port());
        Port dstPort = deviceService.getPort(dst.deviceId(), dst.port());
        if (srcPort instanceof OduCltPort && dstPort instanceof OduCltPort) {
            OduCltPort srcOCPort = (OduCltPort) srcPort;
            OduCltPort dstOCPort = (OduCltPort) dstPort;
            if (!srcOCPort.signalType().equals(dstOCPort.signalType())) {
                continue;
            }
            // Create OTN circuit
            OpticalCircuitIntent circuitIntent = OpticalCircuitIntent.builder().appId(appId).src(src).dst(dst).signalType(srcOCPort.signalType()).bidirectional(true).build();
            intents.add(circuitIntent);
        } else if (srcPort instanceof OchPort && dstPort instanceof OchPort) {
            OchPort srcOchPort = (OchPort) srcPort;
            OchPort dstOchPort = (OchPort) dstPort;
            if (!srcOchPort.signalType().equals(dstOchPort.signalType())) {
                continue;
            }
            // Create lightpath
            OpticalConnectivityIntent opticalIntent = OpticalConnectivityIntent.builder().appId(appId).src(src).dst(dst).signalType(srcOchPort.signalType()).bidirectional(true).build();
            intents.add(opticalIntent);
        } else {
            log.warn("Unsupported cross connect point types {} {}", srcPort.type(), dstPort.type());
            return Collections.emptyList();
        }
    }
    return intents;
}
#end_block

#method_before
private void updatePortBandwidth(ConnectPoint cp, Bandwidth bandwidth) {
    if (isLocalDevice(cp.deviceId())) {
        log.debug("update Port {} Bandwidth {}", cp, bandwidth);
        BandwidthCapacity bwCapacity = networkConfigService.addConfig(cp, BandwidthCapacity.class);
        bwCapacity.capacity(bandwidth).apply();
    }
}
#method_after
private void updatePortBandwidth(ConnectPoint cp, Bandwidth bandwidth) {
    log.debug("update Port {} Bandwidth {}", cp, bandwidth);
    BandwidthCapacity bwCapacity = networkConfigService.addConfig(cp, BandwidthCapacity.class);
    bwCapacity.capacity(bandwidth).apply();
}
#end_block

#method_before
private void releaseBandwidthUsage(OpticalConnectivity connectivity) {
    if (connectivity.links().isEmpty()) {
        return;
    }
    // release resource only if this node is the master for link head device
    if (isLocalDevice(connectivity.links().get(0).src().deviceId())) {
        OpticalConnectivityId connectivityId = connectivity.id();
        log.debug("releasing bandwidth allocated to {}", connectivityId);
        if (!resourceService.release(connectivityId)) {
            log.warn("Failed to release bandwidth allocated to {}", connectivityId);
        // TODO any recovery?
        }
        log.debug("DONE releasing bandwidth for {}", connectivityId);
    }
}
#method_after
private void releaseBandwidthUsage(OpticalConnectivity connectivity) {
    if (connectivity.links().isEmpty()) {
        return;
    }
    // release resource only if this node is the master for link head device
    if (mastershipService.isLocalMaster(connectivity.links().get(0).src().deviceId())) {
        OpticalConnectivityId connectivityId = connectivity.id();
        log.debug("releasing bandwidth allocated to {}", connectivityId);
        if (!resourceService.release(connectivityId)) {
            log.warn("Failed to release bandwidth allocated to {}", connectivityId);
        // TODO any recovery?
        }
        log.debug("DONE releasing bandwidth for {}", connectivityId);
    }
}
#end_block

#method_before
private void updateCrossConnectLink(Intent intent) {
    linkPathMap.entrySet().stream().filter(e -> e.getKey().realizingIntentKey().equals(intent.key())).forEach(e -> {
        ConnectPoint packetSrc = e.getKey().src();
        ConnectPoint packetDst = e.getKey().dst();
        Bandwidth bw = e.getKey().bandwidth();
        // Updates bandwidth of packet ports
        updatePortBandwidth(packetSrc, bw);
        updatePortBandwidth(packetDst, bw);
        OpticalConnectivity newConnectivity = OpticalConnectivity.copyOf(e.getValue().value());
        newConnectivity.setLinkEstablished(packetSrc, packetDst);
        linkPathMap.put(e.getKey(), newConnectivity);
    });
}
#method_after
private void updateCrossConnectLink(Intent intent) {
    linkPathMap.entrySet().stream().filter(e -> e.getKey().realizingIntentKey().equals(intent.key())).forEach(e -> {
        ConnectPoint packetSrc = e.getKey().src();
        ConnectPoint packetDst = e.getKey().dst();
        Bandwidth bw = e.getKey().bandwidth();
        // reflect modification only if packetSrc is local_
        if (mastershipService.isLocalMaster(packetSrc.deviceId())) {
            // Updates bandwidth of packet ports
            updatePortBandwidth(packetSrc, bw);
            updatePortBandwidth(packetDst, bw);
            // Updates link status in distributed map
            linkPathMap.computeIfPresent(e.getKey(), (link, connectivity) -> e.getValue().value().setLinkEstablished(packetSrc, packetDst, true));
        }
    });
}
#end_block

#method_before
private void removeCrossConnectLinks(Intent intent) {
    ConnectPoint src, dst;
    if (intent instanceof OpticalCircuitIntent) {
        OpticalCircuitIntent circuit = (OpticalCircuitIntent) intent;
        src = circuit.getSrc();
        dst = circuit.getDst();
    } else if (intent instanceof OpticalConnectivityIntent) {
        OpticalConnectivityIntent conn = (OpticalConnectivityIntent) intent;
        src = conn.getSrc();
        dst = conn.getDst();
    } else {
        return;
    }
    removeXcLinkUsage(src);
    removeXcLinkUsage(dst);
    // Set bandwidth of 0 to cross connect ports
    Bandwidth bw = Bandwidth.bps(0);
    linkPathMap.entrySet().stream().filter(e -> e.getKey().realizingIntentKey().equals(intent.key())).forEach(e -> {
        ConnectPoint packetSrc = e.getKey().src();
        ConnectPoint packetDst = e.getKey().dst();
        // Updates bandwidth of packet ports
        updatePortBandwidth(packetSrc, bw);
        updatePortBandwidth(packetDst, bw);
        OpticalConnectivity oldConnectivity = e.getValue().value();
        // reflect modification only if packetSrc is local
        if (isLocalDevice(packetSrc.deviceId())) {
            OpticalConnectivity newConnectivity = OpticalConnectivity.copyOf(oldConnectivity);
            newConnectivity.setLinkRemoved(packetSrc, packetDst);
            linkPathMap.put(e.getKey(), newConnectivity);
        }
    });
}
#method_after
private void removeCrossConnectLinks(Intent intent) {
    ConnectPoint src, dst;
    if (intent instanceof OpticalCircuitIntent) {
        OpticalCircuitIntent circuit = (OpticalCircuitIntent) intent;
        src = circuit.getSrc();
        dst = circuit.getDst();
    } else if (intent instanceof OpticalConnectivityIntent) {
        OpticalConnectivityIntent conn = (OpticalConnectivityIntent) intent;
        src = conn.getSrc();
        dst = conn.getDst();
    } else {
        return;
    }
    removeXcLinkUsage(src);
    removeXcLinkUsage(dst);
    // Set bandwidth of 0 to cross connect ports
    Bandwidth bw = Bandwidth.bps(0);
    linkPathMap.entrySet().stream().filter(e -> e.getKey().realizingIntentKey().equals(intent.key())).forEach(e -> {
        ConnectPoint packetSrc = e.getKey().src();
        ConnectPoint packetDst = e.getKey().dst();
        // reflect modification only if packetSrc is local_
        if (mastershipService.isLocalMaster(packetSrc.deviceId())) {
            // Updates bandwidth of packet ports
            updatePortBandwidth(packetSrc, bw);
            updatePortBandwidth(packetDst, bw);
            // Updates link status in distributed map
            linkPathMap.computeIfPresent(e.getKey(), (link, connectivity) -> e.getValue().value().setLinkEstablished(packetSrc, packetDst, false));
        }
    });
}
#end_block

#method_before
@Override
public void event(LinkEvent event) {
    switch(event.type()) {
        case LINK_REMOVED:
            Link link = event.subject();
            // updates linkPathMap only if src device of link is local
            if (!isLocalDevice(link.src().deviceId())) {
                return;
            }
            Set<PacketLinkRealizedByOptical> pLinks = linkPathMap.keySet().stream().filter(l -> l.isBetween(link.src(), link.dst()) || l.isBetween(link.dst(), link.src())).collect(Collectors.toSet());
            pLinks.forEach(l -> {
                Versioned<OpticalConnectivity> c = linkPathMap.get(l);
                // Notifies listeners if all links are gone
                if (c.value().isAllRealizingLinkNotEstablished()) {
                    post(new OpticalPathEvent(OpticalPathEvent.Type.PATH_REMOVED, c.value().id()));
                }
                linkPathMap.remove(l, c.version());
            });
        default:
            break;
    }
}
#method_after
@Override
public void event(LinkEvent event) {
    switch(event.type()) {
        case LINK_REMOVED:
            Link link = event.subject();
            // updates linkPathMap only if src device of link is local
            if (!mastershipService.isLocalMaster(link.src().deviceId())) {
                return;
            }
            // find all packet links that correspond to removed link
            Set<PacketLinkRealizedByOptical> pLinks = linkPathMap.keySet().stream().filter(l -> l.isBetween(link.src(), link.dst()) || l.isBetween(link.dst(), link.src())).collect(Collectors.toSet());
            pLinks.forEach(l -> {
                // remove found packet links from distributed store
                linkPathMap.computeIfPresent(l, (plink, conn) -> {
                    // Notifies listeners if all packet links are gone
                    if (conn.isAllRealizingLinkNotEstablished()) {
                        post(new OpticalPathEvent(OpticalPathEvent.Type.PATH_REMOVED, conn.id()));
                    }
                    return null;
                });
            });
        default:
            break;
    }
}
#end_block

#method_before
public boolean isAllRealizingLinkEstablished() {
    // Check if all links are established
    return realizingLinks.values().stream().allMatch(established -> established);
}
#method_after
public boolean isAllRealizingLinkEstablished() {
    // Check if all links are established
    return unestablishedLinks.isEmpty();
}
#end_block

#method_before
public boolean isAllRealizingLinkNotEstablished() {
    // Check if any link is not established
    return !realizingLinks.values().stream().anyMatch(established -> established);
}
#method_after
public boolean isAllRealizingLinkNotEstablished() {
    // Check if any link is not established
    return establishedLinks.isEmpty();
}
#end_block

#method_before
public void setLinkEstablished(ConnectPoint src, ConnectPoint dst) {
    realizingLinks.entrySet().stream().filter(l -> l.getKey().isBetween(src, dst)).findAny().ifPresent(l -> realizingLinks.put(l.getKey(), true));
}
#method_after
public OpticalConnectivity setLinkEstablished(ConnectPoint src, ConnectPoint dst, boolean established) {
    Set<PacketLinkRealizedByOptical> newEstablishedLinks;
    Set<PacketLinkRealizedByOptical> newUnestablishedLinks;
    if (established) {
        // move PacketLink from unestablished set to established set
        Optional<PacketLinkRealizedByOptical> link = this.unestablishedLinks.stream().filter(l -> l.isBetween(src, dst)).findAny();
        checkState(link.isPresent());
        newUnestablishedLinks = this.unestablishedLinks.stream().filter(l -> !l.isBetween(src, dst)).collect(Collectors.toSet());
        newEstablishedLinks = ImmutableSet.<PacketLinkRealizedByOptical>builder().addAll(this.establishedLinks).add(link.get()).build();
    } else {
        // move PacketLink from established set to unestablished set
        Optional<PacketLinkRealizedByOptical> link = this.establishedLinks.stream().filter(l -> l.isBetween(src, dst)).findAny();
        checkState(link.isPresent());
        newEstablishedLinks = this.establishedLinks.stream().filter(l -> !l.isBetween(src, dst)).collect(Collectors.toSet());
        newUnestablishedLinks = ImmutableSet.<PacketLinkRealizedByOptical>builder().addAll(this.unestablishedLinks).add(link.get()).build();
    }
    return new OpticalConnectivity(this.id, this.links, this.requestBandwidth, this.requestLatency, newUnestablishedLinks, newEstablishedLinks);
}
#end_block

#method_before
public Set<PacketLinkRealizedByOptical> getRealizingLinks() {
    return ImmutableSet.copyOf(realizingLinks.keySet());
}
#method_after
public Set<PacketLinkRealizedByOptical> getRealizingLinks() {
    return ImmutableSet.<PacketLinkRealizedByOptical>builder().addAll(unestablishedLinks).addAll(establishedLinks).build();
}
#end_block

#method_before
@Before
public void setUp() {
    this.deviceService = new TestDeviceService();
    deviceService.devMap.put(deviceIdOf(1), DEVICE1);
    deviceService.devMap.put(deviceIdOf(2), DEVICE2);
    deviceService.devMap.put(deviceIdOf(3), DEVICE3);
    deviceService.devMap.put(deviceIdOf(4), DEVICE4);
    deviceService.devMap.put(deviceIdOf(5), DEVICE5);
    deviceService.devMap.put(deviceIdOf(6), DEVICE6);
    deviceService.devMap.put(deviceIdOf(7), DEVICE7);
    deviceService.portMap.put(CP11, PORT11);
    deviceService.portMap.put(CP12, PORT12);
    deviceService.portMap.put(CP21, PORT21);
    deviceService.portMap.put(CP22, PORT22);
    deviceService.portMap.put(CP31, PORT31);
    deviceService.portMap.put(CP32, PORT32);
    deviceService.portMap.put(CP41, PORT41);
    deviceService.portMap.put(CP42, PORT42);
    deviceService.portMap.put(CP51, PORT51);
    deviceService.portMap.put(CP52, PORT52);
    deviceService.portMap.put(CP61, PORT61);
    deviceService.portMap.put(CP62, PORT62);
    deviceService.portMap.put(CP71, PORT71);
    deviceService.portMap.put(CP72, PORT72);
    this.linkService = new TestLinkService();
    linkService.links.addAll(Stream.of(LINK1, LINK2, LINK3, LINK4, LINK5, LINK6).collect(Collectors.toList()));
    this.pathService = new TestPathService();
    this.intentService = new TestIntentService();
    this.mastershipService = new TestMastershipService();
    this.clusterService = new TestClusterService();
    clusterService.setLocalNode(LOCALNODE);
    mastershipService.setMastership(DEVICE1.id(), LOCALNODE);
    mastershipService.setMastership(DEVICE2.id(), LOCALNODE);
    mastershipService.setMastership(DEVICE3.id(), LOCALNODE);
    mastershipService.setMastership(DEVICE4.id(), LOCALNODE);
    mastershipService.setMastership(DEVICE5.id(), LOCALNODE);
    mastershipService.setMastership(DEVICE6.id(), LOCALNODE);
    mastershipService.setMastership(DEVICE7.id(), LOCALNODE);
    this.target = new OpticalPathProvisioner();
    target.coreService = new TestCoreService();
    target.intentService = this.intentService;
    target.pathService = this.pathService;
    target.linkService = this.linkService;
    target.mastershipService = this.mastershipService;
    target.clusterService = this.clusterService;
    target.storageService = new TestStorageService();
    target.deviceService = this.deviceService;
    target.networkConfigService = new TestNetworkConfigService();
    target.resourceService = new TestResourceService();
    injectEventDispatcher(target, new TestEventDispatcher());
    target.addListener(listener);
    target.activate();
    // To overwrite opticalView-ed deviceService
    target.deviceService = this.deviceService;
    idGenerator = new IdGenerator() {

        int counter = 1;

        @Override
        public long getNewId() {
            return counter++;
        }
    };
    Intent.bindIdGenerator(idGenerator);
}
#method_after
@Before
public void setUp() {
    this.deviceService = new TestDeviceService();
    deviceService.devMap.put(deviceIdOf(1), DEVICE1);
    deviceService.devMap.put(deviceIdOf(2), DEVICE2);
    deviceService.devMap.put(deviceIdOf(3), DEVICE3);
    deviceService.devMap.put(deviceIdOf(4), DEVICE4);
    deviceService.devMap.put(deviceIdOf(5), DEVICE5);
    deviceService.devMap.put(deviceIdOf(6), DEVICE6);
    deviceService.devMap.put(deviceIdOf(7), DEVICE7);
    deviceService.portMap.put(CP11, PORT11);
    deviceService.portMap.put(CP12, PORT12);
    deviceService.portMap.put(CP21, PORT21);
    deviceService.portMap.put(CP22, PORT22);
    deviceService.portMap.put(CP31, PORT31);
    deviceService.portMap.put(CP32, PORT32);
    deviceService.portMap.put(CP41, PORT41);
    deviceService.portMap.put(CP42, PORT42);
    deviceService.portMap.put(CP51, PORT51);
    deviceService.portMap.put(CP52, PORT52);
    deviceService.portMap.put(CP61, PORT61);
    deviceService.portMap.put(CP62, PORT62);
    deviceService.portMap.put(CP71, PORT71);
    deviceService.portMap.put(CP72, PORT72);
    this.linkService = new TestLinkService();
    linkService.links.addAll(Stream.of(LINK1, LINK2, LINK3, LINK4, LINK5, LINK6).collect(Collectors.toList()));
    this.pathService = new TestPathService();
    this.intentService = new TestIntentService();
    this.mastershipService = new TestMastershipService();
    this.clusterService = new TestClusterService();
    mastershipService.setMastership(DEVICE1.id(), MastershipRole.MASTER);
    mastershipService.setMastership(DEVICE2.id(), MastershipRole.MASTER);
    mastershipService.setMastership(DEVICE3.id(), MastershipRole.MASTER);
    mastershipService.setMastership(DEVICE4.id(), MastershipRole.MASTER);
    mastershipService.setMastership(DEVICE5.id(), MastershipRole.MASTER);
    mastershipService.setMastership(DEVICE6.id(), MastershipRole.MASTER);
    mastershipService.setMastership(DEVICE7.id(), MastershipRole.MASTER);
    this.target = new OpticalPathProvisioner();
    target.coreService = new TestCoreService();
    target.intentService = this.intentService;
    target.pathService = this.pathService;
    target.linkService = this.linkService;
    target.mastershipService = this.mastershipService;
    target.clusterService = this.clusterService;
    target.storageService = new TestStorageService();
    target.deviceService = this.deviceService;
    target.networkConfigService = new TestNetworkConfigService();
    target.resourceService = new TestResourceService();
    injectEventDispatcher(target, new TestEventDispatcher());
    target.addListener(listener);
    target.activate();
    // To overwrite opticalView-ed deviceService
    target.deviceService = this.deviceService;
    idGenerator = new IdGenerator() {

        int counter = 1;

        @Override
        public long getNewId() {
            return counter++;
        }
    };
    Intent.bindIdGenerator(idGenerator);
}
#end_block

#method_before
@Test
public void testInstalledEventRemote() {
    // set the master for ingress device of intent to remote node
    mastershipService.setMastership(DEVICE2.id(), REMOTENODE);
    Bandwidth bandwidth = Bandwidth.bps(100);
    Duration latency = Duration.ofMillis(10);
    OpticalConnectivityId cid = target.setupConnectivity(CP12, CP71, bandwidth, latency);
    // notify all intents are installed
    intentService.notifyInstalled();
    // all nodes must receive an event when the all intents are installed
    assertEquals(1, listener.events.size());
    assertEquals(OpticalPathEvent.Type.PATH_INSTALLED, listener.events.get(0).type());
    assertEquals(cid, listener.events.get(0).subject());
}
#method_after
@Test
public void testInstalledEventRemote() {
    // set the master for ingress device of intent to remote node
    mastershipService.setMastership(DEVICE2.id(), MastershipRole.NONE);
    Bandwidth bandwidth = Bandwidth.bps(100);
    Duration latency = Duration.ofMillis(10);
    OpticalConnectivityId cid = target.setupConnectivity(CP12, CP71, bandwidth, latency);
    // notify all intents are installed
    intentService.notifyInstalled();
    // remote nodes must not receive event before distributed map is updated
    assertEquals(0, listener.events.size());
}
#end_block

#method_before
@Test
public void testRemovedEventRemote() {
    // set the master for ingress device of intent to remote node
    mastershipService.setMastership(DEVICE2.id(), REMOTENODE);
    Bandwidth bandwidth = Bandwidth.bps(100);
    Duration latency = Duration.ofMillis(10);
    OpticalConnectivityId cid = target.setupConnectivity(CP12, CP71, bandwidth, latency);
    // notify all intents are installed
    intentService.notifyInstalled();
    target.removeConnectivity(cid);
    // notify all intents are withdrawn
    intentService.notifyWithdrawn();
    // must have received only "INSTALLED" event because remote node doesn't update the store
    assertEquals(1, listener.events.size());
    assertEquals(OpticalPathEvent.Type.PATH_INSTALLED, listener.events.get(0).type());
    assertEquals(cid, listener.events.get(0).subject());
}
#method_after
@Test
public void testRemovedEventRemote() {
    // set the master for ingress device of intent to remote node
    mastershipService.setMastership(DEVICE2.id(), MastershipRole.NONE);
    Bandwidth bandwidth = Bandwidth.bps(100);
    Duration latency = Duration.ofMillis(10);
    OpticalConnectivityId cid = target.setupConnectivity(CP12, CP71, bandwidth, latency);
    // notify all intents are installed
    intentService.notifyInstalled();
    target.removeConnectivity(cid);
    // notify all intents are withdrawn
    intentService.notifyWithdrawn();
    // remote nodes must not receive event before distributed map is updated
    assertEquals(0, listener.events.size());
}
#end_block

#method_before
public void setMastership(DeviceId deviceId, String nodeIdStr) {
    mastershipMap.put(deviceId, NodeId.nodeId(nodeIdStr));
}
#method_after
public void setMastership(DeviceId deviceId, MastershipRole role) {
    mastershipMap.put(deviceId, role);
}
#end_block

#method_before
@Override
public Group decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    final JsonCodec<GroupBucket> groupBucketCodec = context.codec(GroupBucket.class);
    CoreService coreService = context.getService(CoreService.class);
    // parse group id
    int groupIdInt = nullIsIllegal(json.get(GROUP_ID), GROUP_ID + MISSING_MEMBER_MESSAGE).asInt();
    GroupId groupId = new DefaultGroupId(groupIdInt);
    // parse group key (appCookie)
    String groupKeyStr = nullIsIllegal(json.get(APP_COOKIE), APP_COOKIE + MISSING_MEMBER_MESSAGE).asText();
    GroupKey groupKey = new DefaultGroupKey(groupKeyStr.getBytes());
    // parse device id
    DeviceId deviceId = DeviceId.deviceId(nullIsIllegal(json.get(DEVICE_ID), DEVICE_ID + MISSING_MEMBER_MESSAGE).asText());
    // application id
    ApplicationId appId = coreService.registerApplication(REST_APP_ID);
    // parse group type
    String type = nullIsIllegal(json.get(TYPE), TYPE + MISSING_MEMBER_MESSAGE).asText();
    GroupDescription.Type groupType = null;
    switch(type) {
        case "SELECT":
            groupType = Group.Type.SELECT;
            break;
        case "INDIRECT":
            groupType = Group.Type.INDIRECT;
            break;
        case "ALL":
            groupType = Group.Type.ALL;
            break;
        case "FAILOVER":
            groupType = Group.Type.FAILOVER;
            break;
        default:
            nullIsIllegal(groupType, "The requested Group type " + type + " is not Valid");
    }
    // parse group buckets
    // TODO: make sure that INDIRECT group only has one bucket
    GroupBuckets buckets = null;
    List<GroupBucket> groupBucketList = new ArrayList<>();
    JsonNode bucketsJson = json.get(BUCKETS);
    checkNotNull(bucketsJson);
    if (bucketsJson != null) {
        IntStream.range(0, bucketsJson.size()).forEach(i -> {
            ObjectNode bucketJson = get(bucketsJson, i);
            bucketJson.put("type", type);
            groupBucketList.add(groupBucketCodec.decode(bucketJson, context));
        });
        buckets = new GroupBuckets(groupBucketList);
    }
    GroupDescription groupDescription = new DefaultGroupDescription(deviceId, groupType, buckets, groupKey, groupIdInt, appId);
    return new DefaultGroup(groupId, groupDescription);
}
#method_after
@Override
public Group decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    final JsonCodec<GroupBucket> groupBucketCodec = context.codec(GroupBucket.class);
    CoreService coreService = context.getService(CoreService.class);
    // parse group id
    int groupIdInt = nullIsIllegal(json.get(GROUP_ID), GROUP_ID + MISSING_MEMBER_MESSAGE).asInt();
    GroupId groupId = new DefaultGroupId(groupIdInt);
    // parse group key (appCookie)
    String groupKeyStr = nullIsIllegal(json.get(APP_COOKIE), APP_COOKIE + MISSING_MEMBER_MESSAGE).asText();
    GroupKey groupKey = new DefaultGroupKey(groupKeyStr.getBytes());
    // parse device id
    DeviceId deviceId = DeviceId.deviceId(nullIsIllegal(json.get(DEVICE_ID), DEVICE_ID + MISSING_MEMBER_MESSAGE).asText());
    // application id
    ApplicationId appId = coreService.registerApplication(REST_APP_ID);
    // parse group type
    String type = nullIsIllegal(json.get(TYPE), TYPE + MISSING_MEMBER_MESSAGE).asText();
    GroupDescription.Type groupType = null;
    switch(type) {
        case "SELECT":
            groupType = Group.Type.SELECT;
            break;
        case "INDIRECT":
            groupType = Group.Type.INDIRECT;
            break;
        case "ALL":
            groupType = Group.Type.ALL;
            break;
        case "FAILOVER":
            groupType = Group.Type.FAILOVER;
            break;
        default:
            nullIsIllegal(groupType, "The requested group type " + type + " is not valid");
    }
    // parse group buckets
    // TODO: make sure that INDIRECT group only has one bucket
    GroupBuckets buckets = null;
    List<GroupBucket> groupBucketList = new ArrayList<>();
    JsonNode bucketsJson = json.get(BUCKETS);
    checkNotNull(bucketsJson);
    if (bucketsJson != null) {
        IntStream.range(0, bucketsJson.size()).forEach(i -> {
            ObjectNode bucketJson = get(bucketsJson, i);
            bucketJson.put("type", type);
            groupBucketList.add(groupBucketCodec.decode(bucketJson, context));
        });
        buckets = new GroupBuckets(groupBucketList);
    }
    GroupDescription groupDescription = new DefaultGroupDescription(deviceId, groupType, buckets, groupKey, groupIdInt, appId);
    return new DefaultGroup(groupId, groupDescription);
}
#end_block

#method_before
@Override
public List<DeviceInterfaceDescription> getInterfaces() {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    String reply;
    try {
        reply = session.requestSync(getConfigBuilder());
    } catch (NetconfException e) {
        log.error("Failed to retrieve configuration from device {}.", handler().data().deviceId(), e);
        return null;
    }
    return XmlParserCisco.getInterfacesFromConfig(XmlConfigParser.loadXml(new ByteArrayInputStream(reply.getBytes(StandardCharsets.UTF_8))));
}
#method_after
@Override
public List<DeviceInterfaceDescription> getInterfaces(DeviceId deviceId) {
    return getInterfaces();
}
#end_block

#method_before
public void processArpPacketFromRouter(PacketContext context, Ethernet ethernet) {
    checkNotNull(context, "context can not be null");
    checkNotNull(ethernet, "ethernet can not be null");
    ARP arp = (ARP) ethernet.getPayload();
    log.debug("arpEvent called from {} to {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
    if (arp.getOpCode() != ARP.OP_REQUEST) {
        return;
    }
    IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    if (MacAddress.NONE == getTargetMacForTargetIp(targetIp.getIp4Address())) {
        return;
    }
    MacAddress targetMac = MacAddress.valueOf(config.gatewayExternalInterfaceMac());
    Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
    packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
}
#method_after
public void processArpPacketFromRouter(PacketContext context, Ethernet ethernet) {
    checkNotNull(context, "context can not be null");
    checkNotNull(ethernet, "ethernet can not be null");
    ARP arp = (ARP) ethernet.getPayload();
    log.debug("arpEvent called from {} to {}", Ip4Address.valueOf(arp.getSenderProtocolAddress()).toString(), Ip4Address.valueOf(arp.getTargetProtocolAddress()).toString());
    if (arp.getOpCode() != ARP.OP_REQUEST) {
        return;
    }
    IpAddress targetIp = Ip4Address.valueOf(arp.getTargetProtocolAddress());
    if (getTargetMacForTargetIp(targetIp.getIp4Address()) == MacAddress.NONE) {
        return;
    }
    MacAddress targetMac = MacAddress.valueOf(config.gatewayExternalInterfaceMac());
    Ethernet ethReply = ARP.buildArpReply(targetIp.getIp4Address(), targetMac, ethernet);
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(context.inPacket().receivedFrom().port()).build();
    packetService.emit(new DefaultOutboundPacket(context.inPacket().receivedFrom().deviceId(), treatment, ByteBuffer.wrap(ethReply.serialize())));
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    if (context.isHandled()) {
        return;
    } else if (!SONA_DRIVER_NAME.equals(driverService.getDriver(context.inPacket().receivedFrom().deviceId()).name())) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt, openstackPortInfoMap.values());
    }
}
#method_after
@Override
public void process(PacketContext context) {
    // FIXME: use GatewayNode list to check if the ARP packet is from GatewayNode's
    if (context.isHandled()) {
        return;
    } else if (!SONA_DRIVER_NAME.equals(driverService.getDriver(context.inPacket().receivedFrom().deviceId()).name())) {
        return;
    }
    InboundPacket pkt = context.inPacket();
    Ethernet ethernet = pkt.parsed();
    if (ethernet != null && ethernet.getEtherType() == Ethernet.TYPE_ARP) {
        arpHandler.processPacketIn(pkt, openstackPortInfoMap.values());
    }
}
#end_block

#method_before
public void processIcmpPacket(PacketContext context, Ethernet ethernet) {
    checkNotNull(context, "context can not be null");
    checkNotNull(ethernet, "ethernet can not be null");
    IPv4 ipPacket = (IPv4) ethernet.getPayload();
    log.debug("icmpEvent called from ip {}, mac {}", Ip4Address.valueOf(ipPacket.getSourceAddress()).toString(), ethernet.getSourceMAC().toString());
    ICMP icmp = (ICMP) ipPacket.getPayload();
    short icmpId = getIcmpId(icmp);
    DeviceId deviceId = context.inPacket().receivedFrom().deviceId();
    if (icmp.getIcmpType() == ICMP.TYPE_ECHO_REQUEST) {
        // TODO: Considers icmp between internal subnets which are belonged to the same router.
        OpenstackPortInfo openstackPortInfo = getOpenstackPortInfo(Ip4Address.valueOf(ipPacket.getSourceAddress()), ethernet.getSourceMAC());
        // checkNotNull(openstackPortInfo, "openstackPortInfo can not be null");
        boolean isOpenstackRoutingNetwork = checkOpenstackRoutingNetwork(ipPacket.getDestinationAddress());
        if (isOpenstackRoutingNetwork) {
            if (null == openstackPortInfo) {
                if (config.gatewayBridgeId().equals(context.inPacket().receivedFrom().deviceId().toString())) {
                    if (context.inPacket().receivedFrom().port().equals(getPortForAnnotationPortName(context.inPacket().receivedFrom().deviceId(), config.gatewayExternalInterfaceName()))) {
                        processIcmpPacketSentToExtenal(ipPacket, icmp, ipPacket.getSourceAddress(), ethernet.getSourceMAC(), deviceId, context.inPacket().receivedFrom().port());
                        return;
                    }
                }
                log.debug("openstackPortInfo can not be null");
                return;
            } else {
                processIcmpPacketSentToGateway(ipPacket, icmp, MacAddress.valueOf(config.gatewayExternalInterfaceMac()), openstackPortInfo);
                return;
            }
        }
        if (ipPacket.getDestinationAddress() == openstackPortInfo.gatewayIP().toInt()) {
            processIcmpPacketSentToGateway(ipPacket, icmp, GATEWAY_MAC, openstackPortInfo);
        } else {
            Ip4Address pNatIpAddress = pNatIpForPort(openstackPortInfo);
            checkNotNull(pNatIpAddress, "pNatIpAddress can not be null");
            sendRequestPacketToExt(ipPacket, icmp, deviceId, pNatIpAddress);
            String icmpInfoKey = String.valueOf(icmpId).concat(String.valueOf(pNatIpAddress.toInt())).concat(String.valueOf(ipPacket.getDestinationAddress()));
            icmpInfoMap.putIfAbsent(icmpInfoKey, openstackPortInfo);
        }
    } else if (icmp.getIcmpType() == ICMP.TYPE_ECHO_REPLY) {
        String icmpInfoKey = String.valueOf(icmpId).concat(String.valueOf(ipPacket.getDestinationAddress())).concat(String.valueOf(ipPacket.getSourceAddress()));
        processResponsePacketFromExternalToHost(ipPacket, icmp, icmpInfoMap.get(icmpInfoKey));
        icmpInfoMap.remove(icmpInfoKey);
    }
}
#method_after
public void processIcmpPacket(PacketContext context, Ethernet ethernet) {
    checkNotNull(context, "context can not be null");
    checkNotNull(ethernet, "ethernet can not be null");
    IPv4 ipPacket = (IPv4) ethernet.getPayload();
    log.debug("icmpEvent called from ip {}, mac {}", Ip4Address.valueOf(ipPacket.getSourceAddress()).toString(), ethernet.getSourceMAC().toString());
    ICMP icmp = (ICMP) ipPacket.getPayload();
    short icmpId = getIcmpId(icmp);
    DeviceId deviceId = context.inPacket().receivedFrom().deviceId();
    PortNumber portNumber = context.inPacket().receivedFrom().port();
    if (icmp.getIcmpType() == ICMP.TYPE_ECHO_REQUEST) {
        // TODO: Considers icmp between internal subnets which are belonged to the same router.
        OpenstackPortInfo openstackPortInfo = getOpenstackPortInfo(Ip4Address.valueOf(ipPacket.getSourceAddress()), ethernet.getSourceMAC());
        // checkNotNull(openstackPortInfo, "openstackPortInfo can not be null");
        if (requestToOpenstackRoutingNetwork(ipPacket.getDestinationAddress())) {
            if (openstackPortInfo == null) {
                if (config.gatewayBridgeId().equals(context.inPacket().receivedFrom().deviceId().toString())) {
                    if (portNumber.equals(getPortForAnnotationPortName(deviceId, config.gatewayExternalInterfaceName()))) {
                        processIcmpPacketSentToExtenal(ipPacket, icmp, ipPacket.getSourceAddress(), ethernet.getSourceMAC(), deviceId, portNumber);
                        return;
                    }
                }
                return;
            } else {
                processIcmpPacketSentToGateway(ipPacket, icmp, openstackPortInfo);
                return;
            }
        }
        if (ipPacket.getDestinationAddress() == openstackPortInfo.gatewayIP().toInt()) {
            processIcmpPacketSentToGateway(ipPacket, icmp, openstackPortInfo);
        } else {
            Ip4Address pNatIpAddress = pNatIpForPort(openstackPortInfo);
            checkNotNull(pNatIpAddress, "pNatIpAddress can not be null");
            sendRequestPacketToExt(ipPacket, icmp, deviceId, pNatIpAddress);
            String icmpInfoKey = String.valueOf(icmpId).concat(String.valueOf(pNatIpAddress.toInt())).concat(String.valueOf(ipPacket.getDestinationAddress()));
            icmpInfoMap.putIfAbsent(icmpInfoKey, openstackPortInfo);
        }
    } else if (icmp.getIcmpType() == ICMP.TYPE_ECHO_REPLY) {
        String icmpInfoKey = String.valueOf(icmpId).concat(String.valueOf(ipPacket.getDestinationAddress())).concat(String.valueOf(ipPacket.getSourceAddress()));
        processResponsePacketFromExternalToHost(ipPacket, icmp, icmpInfoMap.get(icmpInfoKey));
        icmpInfoMap.remove(icmpInfoKey);
    }
}
#end_block

#method_before
private void processIcmpPacketSentToGateway(IPv4 icmpRequestIpv4, ICMP icmpRequest, MacAddress srcMac, OpenstackPortInfo openstackPortInfo) {
    icmpRequest.setChecksum((short) 0);
    icmpRequest.setIcmpType(ICMP.TYPE_ECHO_REPLY).resetChecksum();
    icmpRequestIpv4.setSourceAddress(icmpRequestIpv4.getDestinationAddress()).setDestinationAddress(openstackPortInfo.ip().toInt()).resetChecksum();
    icmpRequestIpv4.setPayload(icmpRequest);
    Ethernet icmpResponseEth = new Ethernet();
    icmpResponseEth.setEtherType(Ethernet.TYPE_IPV4).setSourceMACAddress(srcMac).setDestinationMACAddress(openstackPortInfo.mac()).setPayload(icmpRequestIpv4);
    sendResponsePacketToHost(icmpResponseEth, openstackPortInfo);
}
#method_after
private void processIcmpPacketSentToGateway(IPv4 icmpRequestIpv4, ICMP icmpRequest, OpenstackPortInfo openstackPortInfo) {
    icmpRequest.setChecksum((short) 0);
    icmpRequest.setIcmpType(ICMP.TYPE_ECHO_REPLY).resetChecksum();
    icmpRequestIpv4.setSourceAddress(icmpRequestIpv4.getDestinationAddress()).setDestinationAddress(openstackPortInfo.ip().toInt()).resetChecksum();
    icmpRequestIpv4.setPayload(icmpRequest);
    Ethernet icmpResponseEth = new Ethernet();
    icmpResponseEth.setEtherType(Ethernet.TYPE_IPV4).setSourceMACAddress(GATEWAY_MAC).setDestinationMACAddress(openstackPortInfo.mac()).setPayload(icmpRequestIpv4);
    sendResponsePacketToHost(icmpResponseEth, openstackPortInfo);
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    String srcId = string(payload, SRCID);
    ElementId src = elementId(srcId);
    String dstId = string(payload, DSTID);
    ElementId dst = elementId(dstId);
    Device srcDevice = deviceService.getDevice((DeviceId) src);
    Device dstDevice = deviceService.getDevice((DeviceId) dst);
    TunnelEndPoint tunSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(srcDevice.annotations().value("lsrId")));
    TunnelEndPoint tunDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dstDevice.annotations().value("lsrId")));
    Collection<Tunnel> tunnelSet = tunnelService.queryTunnel(tunSrc, tunDst);
    ObjectNode result = objectNode();
    ArrayNode arrayNode = arrayNode();
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.type() == MPLS) {
            if (tunnel.state().equals(Tunnel.State.ACTIVE)) {
                arrayNode.add(tunnel.tunnelId().toString());
                arrayNode.add(tunnel.tunnelName().toString());
            }
        }
    }
    result.putArray(BUFFER_ARRAY).addAll(arrayNode);
    sendMessage(PCEWEB_SHOW_TUNNEL, sid, result);
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    String srcId = string(payload, SRCID);
    ElementId src = elementId(srcId);
    String dstId = string(payload, DSTID);
    ElementId dst = elementId(dstId);
    Device srcDevice = deviceService.getDevice((DeviceId) src);
    Device dstDevice = deviceService.getDevice((DeviceId) dst);
    TunnelEndPoint tunSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(srcDevice.annotations().value("lsrId")));
    TunnelEndPoint tunDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dstDevice.annotations().value("lsrId")));
    Collection<Tunnel> tunnelSet = tunnelService.queryTunnel(tunSrc, tunDst);
    ObjectNode result = objectNode();
    ArrayNode arrayNode = arrayNode();
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.type() == MPLS) {
            if (tunnel.state().equals(ACTIVE)) {
                arrayNode.add(tunnel.tunnelId().toString());
                arrayNode.add(tunnel.tunnelName().toString());
            }
        }
    }
    result.putArray(BUFFER_ARRAY).addAll(arrayNode);
    sendMessage(PCEWEB_SHOW_TUNNEL, sid, result);
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    String tunnelIdStr = string(payload, TUNNEL_ID);
    if (tunnelIdStr == null) {
        log.error("PCE update path is failed.");
    }
    if (tunnelIdStr.equals(STRING_NULL)) {
        log.error("PCE update path is failed.");
        return;
    }
    if (pceService == null) {
        log.error("PCE service is not active");
        return;
    }
    TunnelId tunnelId = TunnelId.valueOf(tunnelIdStr);
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    ObjectNode result = objectNode();
    ArrayNode arrayNode = arrayNode();
    arrayNode.add("Tunnel");
    arrayNode.add(tunnelIdStr);
    arrayNode.add("BandWidth");
    arrayNode.add(tunnel.annotations().value("bandwidth"));
    arrayNode.add("CostType");
    arrayNode.add(tunnel.annotations().value("costType"));
    result.putArray(BUFFER_ARRAY).addAll(arrayNode);
    sendMessage(PCEWEB_TUNNEL_UPDATE_INFO_REPLY, sid, result);
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    String tunnelIdStr = string(payload, TUNNEL_ID);
    if (tunnelIdStr == null) {
        log.error("PCE update path is failed.");
        return;
    }
    if (tunnelIdStr.equals(STRING_NULL)) {
        log.error("PCE update path is failed.");
        return;
    }
    if (pceService == null) {
        log.error("PCE service is not active");
        return;
    }
    TunnelId tunnelId = TunnelId.valueOf(tunnelIdStr);
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    ObjectNode result = objectNode();
    ArrayNode arrayNode = arrayNode();
    arrayNode.add("Tunnel");
    arrayNode.add(tunnelIdStr);
    arrayNode.add("BandWidth");
    arrayNode.add(tunnel.annotations().value("bandwidth"));
    arrayNode.add("CostType");
    arrayNode.add(tunnel.annotations().value("costType"));
    result.putArray(BUFFER_ARRAY).addAll(arrayNode);
    sendMessage(PCEWEB_TUNNEL_UPDATE_INFO_REPLY, sid, result);
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    String srcId = string(payload, SRCID);
    ElementId src = elementId(srcId);
    String dstId = string(payload, DSTID);
    ElementId dst = elementId(dstId);
    Device srcDevice = deviceService.getDevice((DeviceId) src);
    Device dstDevice = deviceService.getDevice((DeviceId) dst);
    TunnelEndPoint tunSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(srcDevice.annotations().value("lsrId")));
    TunnelEndPoint tunDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dstDevice.annotations().value("lsrId")));
    Collection<Tunnel> tunnelSet = tunnelService.queryTunnel(tunSrc, tunDst);
    ObjectNode result = objectNode();
    ArrayNode arrayNode = arrayNode();
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.type() == MPLS) {
            if (tunnel.state().equals(Tunnel.State.ACTIVE)) {
                arrayNode.add(tunnel.tunnelId().toString());
                arrayNode.add(tunnel.tunnelName().toString());
            }
        }
    }
    result.putArray(BUFFER_ARRAY).addAll(arrayNode);
    sendMessage(PCEWEB_SHOW_TUNNEL_REMOVE, sid, result);
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    String srcId = string(payload, SRCID);
    ElementId src = elementId(srcId);
    String dstId = string(payload, DSTID);
    ElementId dst = elementId(dstId);
    Device srcDevice = deviceService.getDevice((DeviceId) src);
    Device dstDevice = deviceService.getDevice((DeviceId) dst);
    TunnelEndPoint tunSrc = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(srcDevice.annotations().value("lsrId")));
    TunnelEndPoint tunDst = IpTunnelEndPoint.ipTunnelPoint(IpAddress.valueOf(dstDevice.annotations().value("lsrId")));
    Collection<Tunnel> tunnelSet = tunnelService.queryTunnel(tunSrc, tunDst);
    ObjectNode result = objectNode();
    ArrayNode arrayNode = arrayNode();
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.type() == MPLS) {
            if (tunnel.state().equals(ACTIVE)) {
                arrayNode.add(tunnel.tunnelId().toString());
                arrayNode.add(tunnel.tunnelName().toString());
            }
        }
    }
    result.putArray(BUFFER_ARRAY).addAll(arrayNode);
    sendMessage(PCEWEB_SHOW_TUNNEL_REMOVE, sid, result);
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    ObjectNode result = objectNode();
    ArrayNode arrayNode = arrayNode();
    Collection<Tunnel> tunnelSet = null;
    tunnelSet = tunnelService.queryTunnel(MPLS);
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.state().equals(Tunnel.State.ACTIVE)) {
            arrayNode.add(tunnel.tunnelId().toString());
            arrayNode.add(tunnel.tunnelName().toString());
        }
    }
    result.putArray(BUFFER_ARRAY).addAll(arrayNode);
    sendMessage(PCEWEB_TUNNEL_QUERY_INFO, sid, result);
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    ObjectNode result = objectNode();
    ArrayNode arrayNode = arrayNode();
    Collection<Tunnel> tunnelSet = null;
    tunnelSet = tunnelService.queryTunnel(MPLS);
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.state().equals(ACTIVE)) {
            arrayNode.add(tunnel.tunnelId().toString());
            arrayNode.add(tunnel.tunnelName().toString());
        }
    }
    result.putArray(BUFFER_ARRAY).addAll(arrayNode);
    sendMessage(PCEWEB_TUNNEL_QUERY_INFO, sid, result);
}
#end_block

#method_before
@Override
public void process(long sid, ObjectNode payload) {
    String tunnelIdStr = string(payload, TUNNEL_ID);
    if (tunnelIdStr == null) {
        log.error("Tunnel Id is NULL.");
    }
    if (tunnelIdStr.equals(STRING_NULL)) {
        log.error("Tunnel Id is NULL.");
        return;
    }
    if (pceService == null) {
        log.error("PCE service is not active");
        return;
    }
    TunnelId tunnelId = TunnelId.valueOf(tunnelIdStr);
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    if (tunnel != null) {
        highlightsForTunnel(tunnel);
    }
}
#method_after
@Override
public void process(long sid, ObjectNode payload) {
    String tunnelIdStr = string(payload, TUNNEL_ID);
    if (tunnelIdStr == null) {
        log.error("Tunnel Id is NULL.");
        return;
    }
    if (tunnelIdStr.equals(STRING_NULL)) {
        log.error("Tunnel Id is NULL.");
        return;
    }
    if (pceService == null) {
        log.error("PCE service is not active");
        return;
    }
    TunnelId tunnelId = TunnelId.valueOf(tunnelIdStr);
    Tunnel tunnel = tunnelService.queryTunnel(tunnelId);
    if (tunnel != null) {
        highlightsForTunnel(tunnel);
    }
}
#end_block

#method_before
private void findTunnelAndHighlights() {
    Collection<Tunnel> tunnelSet = null;
    Highlights highlights = new Highlights();
    paths.removeAll(paths);
    tunnelSet = tunnelService.queryTunnel(MPLS);
    if (tunnelSet.size() == 0) {
        log.warn("Tunnel does not exist");
        sendMessage(TopoJson.highlightsMessage(highlights));
        return;
    }
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.path() == null) {
            log.error("path does not exist");
            sendMessage(TopoJson.highlightsMessage(highlights));
            return;
        }
        if (!tunnel.state().equals(Tunnel.State.ACTIVE)) {
            log.debug("Tunnel state is not active");
            sendMessage(TopoJson.highlightsMessage(highlights));
            return;
        }
        Link firstLink = tunnel.path().links().get(0);
        if (firstLink != null) {
            if (firstLink.src() != null) {
                highlights = addBadge(highlights, firstLink.src().deviceId().toString(), SRC);
            }
        }
        Link lastLink = tunnel.path().links().get(tunnel.path().links().size() - 1);
        if (lastLink != null) {
            if (lastLink.dst() != null) {
                highlights = addBadge(highlights, lastLink.dst().deviceId().toString(), DST);
            }
        }
        paths.add(tunnel.path());
    }
    ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
    allPathLinks = buildPaths(builder).build();
    hilightAndSendPaths(highlights);
}
#method_after
private void findTunnelAndHighlights() {
    Collection<Tunnel> tunnelSet = null;
    Highlights highlights = new Highlights();
    paths.removeAll(paths);
    tunnelSet = tunnelService.queryTunnel(MPLS);
    if (tunnelSet.size() == 0) {
        log.warn("Tunnel does not exist");
        sendMessage(TopoJson.highlightsMessage(highlights));
        return;
    }
    for (Tunnel tunnel : tunnelSet) {
        if (tunnel.path() == null) {
            log.error("path does not exist");
            sendMessage(TopoJson.highlightsMessage(highlights));
            return;
        }
        if (!tunnel.state().equals(ACTIVE)) {
            log.debug("Tunnel state is not active");
            sendMessage(TopoJson.highlightsMessage(highlights));
            return;
        }
        Link firstLink = tunnel.path().links().get(0);
        if (firstLink != null) {
            if (firstLink.src() != null) {
                highlights = addBadge(highlights, firstLink.src().deviceId().toString(), SRC);
            }
        }
        Link lastLink = tunnel.path().links().get(tunnel.path().links().size() - 1);
        if (lastLink != null) {
            if (lastLink.dst() != null) {
                highlights = addBadge(highlights, lastLink.dst().deviceId().toString(), DST);
            }
        }
        paths.add(tunnel.path());
    }
    ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
    allPathLinks = buildPaths(builder).build();
    hilightAndSendPaths(highlights);
}
#end_block

#method_before
private void highlightsForTunnel(Tunnel tunnel) {
    Highlights highlights = new Highlights();
    paths.removeAll(paths);
    if (tunnel.path() == null) {
        log.error("path does not exist");
        sendMessage(TopoJson.highlightsMessage(highlights));
        return;
    }
    if (!tunnel.state().equals(Tunnel.State.ACTIVE)) {
        log.debug("Tunnel state is not active");
        sendMessage(TopoJson.highlightsMessage(highlights));
        return;
    }
    Link firstLink = tunnel.path().links().get(0);
    if (firstLink != null) {
        if (firstLink.src() != null) {
            highlights = addBadge(highlights, firstLink.src().deviceId().toString(), SRC);
        }
    }
    Link lastLink = tunnel.path().links().get(tunnel.path().links().size() - 1);
    if (lastLink != null) {
        if (lastLink.dst() != null) {
            highlights = addBadge(highlights, lastLink.dst().deviceId().toString(), DST);
        }
    }
    paths.add(tunnel.path());
    ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
    allPathLinks = buildPaths(builder).build();
    hilightAndSendPaths(highlights);
}
#method_after
private void highlightsForTunnel(Tunnel tunnel) {
    Highlights highlights = new Highlights();
    paths.removeAll(paths);
    if (tunnel.path() == null) {
        log.error("path does not exist");
        sendMessage(TopoJson.highlightsMessage(highlights));
        return;
    }
    if (!tunnel.state().equals(ACTIVE)) {
        log.debug("Tunnel state is not active");
        sendMessage(TopoJson.highlightsMessage(highlights));
        return;
    }
    Link firstLink = tunnel.path().links().get(0);
    if (firstLink != null) {
        if (firstLink.src() != null) {
            highlights = addBadge(highlights, firstLink.src().deviceId().toString(), SRC);
        }
    }
    Link lastLink = tunnel.path().links().get(tunnel.path().links().size() - 1);
    if (lastLink != null) {
        if (lastLink.dst() != null) {
            highlights = addBadge(highlights, lastLink.dst().deviceId().toString(), DST);
        }
    }
    paths.add(tunnel.path());
    ImmutableSet.Builder<Link> builder = ImmutableSet.builder();
    allPathLinks = buildPaths(builder).build();
    hilightAndSendPaths(highlights);
}
#end_block

#method_before
@Override
public Map<String, String> additionalLinkData(LinkEvent event) {
    Map<String, String> map = new HashMap<>();
    Link link = event.subject();
    long srcPortNo;
    long dstPortNo;
    IpAddress ipDstAddress = null;
    IpAddress ipSrcAddress = null;
    String srcPort;
    String dstPort;
    String bandWidth;
    srcPortNo = link.src().port().toLong();
    if (((srcPortNo & IDENTIFIER_SET) == IDENTIFIER_SET)) {
        log.info("Entered set case: If");
        srcPort = String.valueOf(srcPortNo);
    } else {
        ipSrcAddress = Ip4Address.valueOf((int) srcPortNo);
        srcPort = ipSrcAddress.toString();
    }
    dstPortNo = link.dst().port().toLong();
    if (((dstPortNo & IDENTIFIER_SET) == IDENTIFIER_SET)) {
        dstPort = String.valueOf(dstPortNo);
    } else {
        ipDstAddress = Ip4Address.valueOf((int) dstPortNo);
        dstPort = ipDstAddress.toString();
    }
    map.put("Src Address", srcPort);
    map.put("Dst Address", dstPort);
    map.put("Te metric", link.annotations().value(TE_METRIC));
    ResourceService resService = AbstractShellCommand.get(ResourceService.class);
    DiscreteResource devResource = Resources.discrete(link.src().deviceId(), link.src().port()).resource();
    if (resService == null) {
        log.warn("resource service does not exist ");
        return map;
    }
    if (devResource == null) {
        log.warn("Device resources does not exist ");
        return map;
    }
    double regirtered = 0;
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    Set<Resource> resources = resService.getRegisteredResources(devResource.id());
    for (Resource res : resources) {
        if (res instanceof ContinuousResource) {
            regirtered = ((ContinuousResource) res).value();
            break;
        }
    }
    if (regirtered != 0) {
        bandWidth = String.valueOf(regirtered);
        map.put("Bandwidth", bandWidth);
    }
    return map;
}
#method_after
@Override
public Map<String, String> additionalLinkData(LinkEvent event) {
    Map<String, String> map = new HashMap<>();
    Link link = event.subject();
    long srcPortNo;
    long dstPortNo;
    IpAddress ipDstAddress = null;
    IpAddress ipSrcAddress = null;
    String srcPort;
    String dstPort;
    String bandWidth;
    srcPortNo = link.src().port().toLong();
    if (((srcPortNo & IDENTIFIER_SET) == IDENTIFIER_SET)) {
        srcPort = String.valueOf(srcPortNo);
    } else {
        ipSrcAddress = Ip4Address.valueOf((int) srcPortNo);
        srcPort = ipSrcAddress.toString();
    }
    dstPortNo = link.dst().port().toLong();
    if (((dstPortNo & IDENTIFIER_SET) == IDENTIFIER_SET)) {
        dstPort = String.valueOf(dstPortNo);
    } else {
        ipDstAddress = Ip4Address.valueOf((int) dstPortNo);
        dstPort = ipDstAddress.toString();
    }
    map.put("Src Address", srcPort);
    map.put("Dst Address", dstPort);
    map.put("Te metric", link.annotations().value(TE_METRIC));
    ResourceService resService = AbstractShellCommand.get(ResourceService.class);
    DiscreteResource devResource = Resources.discrete(link.src().deviceId(), link.src().port()).resource();
    if (resService == null) {
        log.warn("resource service does not exist");
        return map;
    }
    if (devResource == null) {
        log.warn("Device resources does not exist");
        return map;
    }
    double regBandwidth = 0;
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
        log.error("Exception occured while getting the bandwidth.");
    }
    Set<Resource> resources = resService.getRegisteredResources(devResource.id());
    for (Resource res : resources) {
        if (res instanceof ContinuousResource) {
            regBandwidth = ((ContinuousResource) res).value();
            break;
        }
    }
    if (regBandwidth != 0) {
        bandWidth = String.valueOf(regBandwidth);
        map.put("Bandwidth", bandWidth);
    }
    return map;
}
#end_block

#method_before
private void startSshSession() throws NetconfException {
    try {
        sshSession = netconfConnection.openSession();
        sshSession.startSubSystem("netconf");
        t = new NetconfStreamThread(sshSession.getStdout(), sshSession.getStdin(), sshSession.getStderr(), deviceInfo, new NetconfSessionDelegateImpl());
        this.addDeviceOutputListener(new NetconfDeviceOutputEventListenerImpl(deviceInfo));
        sendHello();
    } catch (IOException e) {
        log.error("Failed to create ch.ethz.ssh2.Session session." + e.getMessage());
        throw new NetconfException("Failed to create ch.ethz.ssh2.Session session with device" + deviceInfo, e);
    }
}
#method_after
private void startSshSession() throws NetconfException {
    try {
        sshSession = netconfConnection.openSession();
        sshSession.startSubSystem("netconf");
        streamHandler = new NetconfStreamThread(sshSession.getStdout(), sshSession.getStdin(), sshSession.getStderr(), deviceInfo, new NetconfSessionDelegateImpl());
        this.addDeviceOutputListener(new NetconfDeviceOutputEventListenerImpl(deviceInfo));
        sendHello();
    } catch (IOException e) {
        log.error("Failed to create ch.ethz.ssh2.Session session." + e.getMessage());
        throw new NetconfException("Failed to create ch.ethz.ssh2.Session session with device" + deviceInfo, e);
    }
}
#end_block

#method_before
public void startSubscription() throws NetconfException {
    if (deviceCapabilities.contains("interleave")) {
        String reply = sendRequest(createSubscriptionString());
        if (!checkReply(reply)) {
            throw new NetconfException("Subscription not successful with device" + deviceInfo);
        }
    }
// TODO: add else case; to keep one connection without subscription
// or to open another connection
}
#method_after
public void startSubscription() throws NetconfException {
    if (!subscriptionConnected) {
        startSubscriptionConnection();
    }
    streamHandler.setEnableNotifications(true);
}
#end_block

#method_before
private String createSubscriptionString() {
    StringBuilder subscriptionbuffer = new StringBuilder();
    subscriptionbuffer.append(XML_HEADER);
    subscriptionbuffer.append("\n");
    subscriptionbuffer.append("<rpc ");
    subscriptionbuffer.append(MESSAGE_ID_STRING);
    subscriptionbuffer.append(EQUAL);
    subscriptionbuffer.append("\"");
    subscriptionbuffer.append(messageIdInteger.get());
    subscriptionbuffer.append("\" ");
    subscriptionbuffer.append("xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    subscriptionbuffer.append("  <create-subscription\n");
    subscriptionbuffer.append("xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n");
    subscriptionbuffer.append("  </create-subscription>\n");
    subscriptionbuffer.append("</rpc>\n");
    subscriptionbuffer.append(ENDPATTERN);
    return subscriptionbuffer.toString();
}
#method_after
private String createSubscriptionString() {
    StringBuilder subscriptionbuffer = new StringBuilder();
    subscriptionbuffer.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    subscriptionbuffer.append("  <create-subscription\n");
    subscriptionbuffer.append("xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\">\n");
    subscriptionbuffer.append("  </create-subscription>\n");
    subscriptionbuffer.append("</rpc>\n");
    subscriptionbuffer.append(ENDPATTERN);
    return subscriptionbuffer.toString();
}
#end_block

#method_before
private void sendHello() throws NetconfException {
    serverCapabilities = sendRequest(createHelloString());
    log.error(serverCapabilities);
}
#method_after
private void sendHello() throws NetconfException {
    serverCapabilities = sendRequest(createHelloString());
}
#end_block

#method_before
@Override
public CompletableFuture<String> request(String request) {
    CompletableFuture<String> ftrep = t.sendMessage(request);
    replies.put(messageIdInteger.get(), ftrep);
    return ftrep;
}
#method_after
@Override
public CompletableFuture<String> request(String request) {
    CompletableFuture<String> ftrep = streamHandler.sendMessage(request);
    replies.put(messageIdInteger.get(), ftrep);
    return ftrep;
}
#end_block

#method_before
@Override
public String get(String request) throws NetconfException {
    return requestSync(request);
}
#method_after
@Override
public String get(String filterSchema, String withDefaultsMode) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(GET_OPEN).append(NEW_LINE);
    if (filterSchema != null) {
        rpc.append(FILTER_OPEN).append(NEW_LINE);
        rpc.append(filterSchema).append(NEW_LINE);
        rpc.append(FILTER_CLOSE).append(NEW_LINE);
    }
    if (withDefaultsMode != null) {
        rpc.append(WITH_DEFAULT_OPEN).append(NETCONF_WITH_DEFAULTS_NAMESPACE).append(">");
        rpc.append(withDefaultsMode).append(WITH_DEFAULT_CLOSE).append(NEW_LINE);
    }
    rpc.append(GET_CLOSE).append(NEW_LINE);
    rpc.append(RPC_CLOSE).append(NEW_LINE);
    rpc.append(ENDPATTERN);
    String reply = sendRequest(rpc.toString());
    checkReply(reply);
    return reply;
}
#end_block

#method_before
@Override
public boolean lock() throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<lock>");
    rpc.append("<target>");
    rpc.append("<candidate/>");
    rpc.append("</target>");
    rpc.append("</lock>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean lock(String configType) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    rpc.append("<lock>");
    rpc.append("<target>");
    rpc.append("<");
    rpc.append(configType);
    rpc.append("/>");
    rpc.append("</target>");
    rpc.append("</lock>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    String lockReply = sendRequest(rpc.toString());
    return checkReply(lockReply);
}
#end_block

#method_before
@Override
public boolean unlock() throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<unlock>");
    rpc.append("<target>");
    rpc.append("<candidate/>");
    rpc.append("</target>");
    rpc.append("</unlock>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean unlock(String configType) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n");
    rpc.append("<unlock>");
    rpc.append("<target>");
    rpc.append("<");
    rpc.append(configType);
    rpc.append("/>");
    rpc.append("</target>");
    rpc.append("</unlock>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    String unlockReply = sendRequest(rpc.toString());
    return checkReply(unlockReply);
}
#end_block

#method_before
@Override
public boolean lock() throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<lock>");
    rpc.append("<target>");
    rpc.append("<candidate/>");
    rpc.append("</target>");
    rpc.append("</lock>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean lock() throws NetconfException {
    return lock("running");
}
#end_block

#method_before
@Override
public boolean unlock() throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc>");
    rpc.append("<unlock>");
    rpc.append("<target>");
    rpc.append("<candidate/>");
    rpc.append("</target>");
    rpc.append("</unlock>");
    rpc.append("</rpc>");
    rpc.append(ENDPATTERN);
    return checkReply(sendRequest(rpc.toString()));
}
#method_after
@Override
public boolean unlock() throws NetconfException {
    return unlock("running");
}
#end_block

#method_before
@Override
public void addDeviceOutputListener(NetconfDeviceOutputEventListener listener) {
    t.addDeviceEventListener(listener);
}
#method_after
@Override
public void addDeviceOutputListener(NetconfDeviceOutputEventListener listener) {
    streamHandler.addDeviceEventListener(listener);
}
#end_block

#method_before
@Override
public void removeDeviceOutputListener(NetconfDeviceOutputEventListener listener) {
    t.removeDeviceEventListener(listener);
}
#method_after
@Override
public void removeDeviceOutputListener(NetconfDeviceOutputEventListener listener) {
    streamHandler.removeDeviceEventListener(listener);
}
#end_block

#method_before
@Override
public void notify(NetconfDeviceOutputEvent event) {
    Optional<Integer> messageId = event.getMessageID();
    if (event.type() == NetconfDeviceOutputEvent.Type.DEVICE_NOTIFICATION) {
        log.error("Notification {} received from device {}", event.getMessagePayload(), event.getDeviceInfo());
        return;
    }
    if (!messageId.isPresent()) {
        errorReplies.add(event.getMessagePayload());
        log.error("Device {} sent error reply {}", event.getDeviceInfo(), event.getMessagePayload());
        return;
    }
    CompletableFuture<String> completedReply = replies.get(messageId.get());
    completedReply.complete(event.getMessagePayload());
}
#method_after
@Override
public void notify(NetconfDeviceOutputEvent event) {
    Optional<Integer> messageId = event.getMessageID();
    if (!messageId.isPresent()) {
        errorReplies.add(event.getMessagePayload());
        log.error("Device {} sent error reply {}", event.getDeviceInfo(), event.getMessagePayload());
        return;
    }
    CompletableFuture<String> completedReply = replies.get(messageId.get());
    completedReply.complete(event.getMessagePayload());
}
#end_block

#method_before
@Override
public Group decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    final JsonCodec<GroupBucket> groupBucketCodec = context.codec(GroupBucket.class);
    CoreService coreService = context.getService(CoreService.class);
    // parse group id
    int groupIdInt = nullIsIllegal(json.get(GROUP_ID), GROUP_ID + MISSING_MEMBER_MESSAGE).asInt();
    GroupId groupId = new DefaultGroupId(groupIdInt);
    // parse group key (appCookie)
    String groupKeyStr = nullIsIllegal(json.get(APP_COOKIE), APP_COOKIE + MISSING_MEMBER_MESSAGE).asText();
    Integer groupKeyInt;
    try {
        groupKeyInt = Integer.decode(groupKeyStr);
    } catch (NumberFormatException e) {
        log.warn("GroupKey {} has wrong format", groupKeyStr);
        return null;
    }
    GroupKey groupKey = new DefaultGroupKey(ByteBuffer.allocate(Integer.BYTES).putInt(groupKeyInt).array());
    // parse device id
    DeviceId deviceId = DeviceId.deviceId(nullIsIllegal(json.get(DEVICE_ID), DEVICE_ID + MISSING_MEMBER_MESSAGE).asText());
    // application id
    ApplicationId appId = coreService.registerApplication(REST_APP_ID);
    // parse group type
    String type = nullIsIllegal(json.get(TYPE), TYPE + MISSING_MEMBER_MESSAGE).asText();
    GroupDescription.Type groupType = null;
    switch(type) {
        case "SELECT":
            groupType = Group.Type.SELECT;
            break;
        case "INDIRECT":
            groupType = Group.Type.INDIRECT;
            break;
        case "ALL":
            groupType = Group.Type.ALL;
            break;
        case "FAILOVER":
            groupType = Group.Type.FAILOVER;
            break;
        default:
            log.warn("The requested type {} is not defined for group.", type);
            return null;
    }
    // parse group buckets
    // TODO: make sure that INDIRECT group only has one bucket
    GroupBuckets buckets = null;
    List<GroupBucket> groupBucketList = new ArrayList<>();
    JsonNode bucketsJson = json.get(BUCKETS);
    checkNotNull(bucketsJson);
    if (bucketsJson != null) {
        IntStream.range(0, bucketsJson.size()).forEach(i -> {
            ObjectNode bucketJson = get(bucketsJson, i);
            bucketJson.put("type", type);
            groupBucketList.add(groupBucketCodec.decode(bucketJson, context));
        });
        buckets = new GroupBuckets(groupBucketList);
    }
    GroupDescription groupDescription = new DefaultGroupDescription(deviceId, groupType, buckets, groupKey, groupIdInt, appId);
    return new DefaultGroup(groupId, groupDescription);
}
#method_after
@Override
public Group decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    final JsonCodec<GroupBucket> groupBucketCodec = context.codec(GroupBucket.class);
    CoreService coreService = context.getService(CoreService.class);
    // parse group id
    int groupIdInt = nullIsIllegal(json.get(GROUP_ID), GROUP_ID + MISSING_MEMBER_MESSAGE).asInt();
    GroupId groupId = new DefaultGroupId(groupIdInt);
    // parse group key (appCookie)
    String groupKeyStr = nullIsIllegal(json.get(APP_COOKIE), APP_COOKIE + MISSING_MEMBER_MESSAGE).asText();
    if (!groupKeyStr.startsWith("0x")) {
        throw new IllegalArgumentException("APP_COOKIE must be a hex string starts with 0x");
    }
    GroupKey groupKey = new DefaultGroupKey(HexString.fromHexString(groupKeyStr.split("0x")[1], ""));
    // parse device id
    DeviceId deviceId = DeviceId.deviceId(nullIsIllegal(json.get(DEVICE_ID), DEVICE_ID + MISSING_MEMBER_MESSAGE).asText());
    // application id
    ApplicationId appId = coreService.registerApplication(REST_APP_ID);
    // parse group type
    String type = nullIsIllegal(json.get(TYPE), TYPE + MISSING_MEMBER_MESSAGE).asText();
    GroupDescription.Type groupType = null;
    switch(type) {
        case "SELECT":
            groupType = Group.Type.SELECT;
            break;
        case "INDIRECT":
            groupType = Group.Type.INDIRECT;
            break;
        case "ALL":
            groupType = Group.Type.ALL;
            break;
        case "FAILOVER":
            groupType = Group.Type.FAILOVER;
            break;
        default:
            log.warn("The requested type {} is not defined for group.", type);
            return null;
    }
    // parse group buckets
    // TODO: make sure that INDIRECT group only has one bucket
    GroupBuckets buckets = null;
    List<GroupBucket> groupBucketList = new ArrayList<>();
    JsonNode bucketsJson = json.get(BUCKETS);
    checkNotNull(bucketsJson);
    if (bucketsJson != null) {
        IntStream.range(0, bucketsJson.size()).forEach(i -> {
            ObjectNode bucketJson = get(bucketsJson, i);
            bucketJson.put("type", type);
            groupBucketList.add(groupBucketCodec.decode(bucketJson, context));
        });
        buckets = new GroupBuckets(groupBucketList);
    }
    GroupDescription groupDescription = new DefaultGroupDescription(deviceId, groupType, buckets, groupKey, groupIdInt, appId);
    return new DefaultGroup(groupId, groupDescription);
}
#end_block

#method_before
private void checkCommonData(Group group) {
    assertThat(group.appId(), is(APP_ID));
    assertThat(group.deviceId().toString(), is("of:0000000000000001"));
    assertThat(group.type().toString(), is("ALL"));
    assertArrayEquals(group.appCookie().key(), new byte[] { 0x00, 0x00, 0x00, 0x01 });
    assertThat(group.id().id(), is(1));
}
#method_after
private void checkCommonData(Group group) {
    assertThat(group.appId(), is(APP_ID));
    assertThat(group.deviceId().toString(), is("of:0000000000000001"));
    assertThat(group.type().toString(), is("ALL"));
    assertThat(group.appCookie().key(), equalTo(new byte[] { (byte) 0x12, (byte) 0x34, (byte) 0xAB, (byte) 0xCD }));
    assertThat(group.id().id(), is(1));
}
#end_block

#method_before
private PortDescription buildPortDescription(PortDescPropertyType ptype, OFPortOptical port, OpenFlowOpticalSwitch opsw) {
    checkArgument(port.getDesc().size() >= 1);
    // Minimally functional fixture. This needs to be fixed as we add better support.
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    SparseAnnotations annotations = makePortAnnotation(port.getName(), port.getHwAddr().toString());
    if (port.getVersion() == OFVersion.OF_13 && ptype == PortDescPropertyType.OPTICAL_TRANSPORT) {
        // At this point, not much is carried in the optical port message.
        LOG.debug("Optical transport port message {}", port.toString());
    } else {
        // removable once 1.4+ support complete.
        LOG.debug("Unsupported optical port properties");
    }
    OFPortDescPropOpticalTransport desc = port.getDesc().get(0);
    switch(desc.getPortSignalType()) {
        // FIXME: use constants once loxi has full optical extensions
        case // OMS port
        2:
            // Assume complete optical spectrum and 50 GHz grid
            // LINC-OE is only supported optical OF device for now
            Set<OchSignal> signals = null;
            if (opsw instanceof AbstractHandlerBehaviour) {
                DriverHandler driverHandler = ((AbstractHandlerBehaviour) opsw).handler();
                if (driverHandler != null && driverHandler.hasBehaviour(LambdaQuery.class)) {
                    signals = driverHandler.behaviour(LambdaQuery.class).queryLambdas(portNo);
                }
            }
            Frequency minFreq;
            Frequency maxFreq;
            Frequency channelSpacing;
            if (signals == null || signals.isEmpty()) {
                minFreq = Spectrum.U_BAND_MIN;
                maxFreq = Spectrum.O_BAND_MAX;
                channelSpacing = Frequency.ofGHz(50);
            } else {
                Comparator<OchSignal> compare = (OchSignal a, OchSignal b) -> a.spacingMultiplier() - b.spacingMultiplier();
                OchSignal minOch = Collections.min(signals, compare);
                minFreq = minOch.centralFrequency();
                maxFreq = Collections.max(signals, compare).centralFrequency();
                channelSpacing = minOch.channelSpacing().frequency();
            }
            return omsPortDescription(portNo, enabled, minFreq, maxFreq, channelSpacing, annotations);
        case // OCH port
        5:
            OchSignal signal = new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ, 0, 4);
            return ochPortDescription(portNo, enabled, OduSignalType.ODU4, true, signal, annotations);
        default:
            break;
    }
    return new DefaultPortDescription(portNo, enabled, FIBER, 0, annotations);
}
#method_after
private PortDescription buildPortDescription(PortDescPropertyType ptype, OFPortOptical port, OpenFlowOpticalSwitch opsw) {
    checkArgument(port.getDesc().size() >= 1);
    // Minimally functional fixture. This needs to be fixed as we add better support.
    PortNumber portNo = PortNumber.portNumber(port.getPortNo().getPortNumber());
    boolean enabled = !port.getState().contains(OFPortState.LINK_DOWN) && !port.getConfig().contains(OFPortConfig.PORT_DOWN);
    SparseAnnotations annotations = makePortAnnotation(port.getName(), port.getHwAddr().toString());
    if (port.getVersion() == OFVersion.OF_13 && ptype == PortDescPropertyType.OPTICAL_TRANSPORT) {
        // At this point, not much is carried in the optical port message.
        LOG.debug("Optical transport port message {}", port.toString());
    } else {
        // removable once 1.4+ support complete.
        LOG.debug("Unsupported optical port properties");
    }
    OFPortDescPropOpticalTransport desc = port.getDesc().get(0);
    switch(desc.getPortSignalType()) {
        // FIXME: use constants once loxi has full optical extensions
        case // OMS port
        2:
            // Assume complete optical spectrum and 50 GHz grid
            // LINC-OE is only supported optical OF device for now
            Set<OchSignal> signals = null;
            if (opsw instanceof HandlerBehaviour) {
                DriverHandler driverHandler = ((HandlerBehaviour) opsw).handler();
                if (driverHandler != null && driverHandler.hasBehaviour(LambdaQuery.class)) {
                    try {
                        signals = driverHandler.behaviour(LambdaQuery.class).queryLambdas(portNo);
                    } catch (NullPointerException e) {
                        signals = null;
                    }
                }
            }
            Frequency minFreq;
            Frequency maxFreq;
            Frequency channelSpacing;
            if (signals == null || signals.isEmpty()) {
                minFreq = Spectrum.U_BAND_MIN;
                maxFreq = Spectrum.O_BAND_MAX;
                channelSpacing = Frequency.ofGHz(50);
            } else {
                Comparator<OchSignal> compare = (OchSignal a, OchSignal b) -> a.spacingMultiplier() - b.spacingMultiplier();
                OchSignal minOch = Collections.min(signals, compare);
                OchSignal maxOch = Collections.max(signals, compare);
                minFreq = minOch.centralFrequency();
                maxFreq = maxOch.centralFrequency();
                channelSpacing = minOch.channelSpacing().frequency();
            }
            return omsPortDescription(portNo, enabled, minFreq, maxFreq, channelSpacing, annotations);
        case // OCH port
        5:
            OchSignal signal = new OchSignal(GridType.DWDM, ChannelSpacing.CHL_50GHZ, 0, 4);
            return ochPortDescription(portNo, enabled, OduSignalType.ODU4, true, signal, annotations);
        default:
            break;
    }
    return new DefaultPortDescription(portNo, enabled, FIBER, 0, annotations);
}
#end_block

#method_before
public Integer refCount() {
    return refCount;
}
#method_after
public AtomicInteger refCount() {
    return refCount;
}
#end_block

#method_before
@Override
protected void execute() {
    CarrierEthernetManager ceManager = get(CarrierEthernetManager.class);
    CarrierEthernetLogicalTerminationPoint.Type ltpType = null;
    if (!argLtpType.equals("AUTO")) {
        try {
            ltpType = CarrierEthernetLogicalTerminationPoint.Type.fromString(argLtpType);
        } catch (IllegalArgumentException e) {
            log.error("{} is not a valid LTP type, skipping LTP generation.");
            return;
        }
    }
    Iterator<String> cpIt = argConnectPointList.iterator();
    while (cpIt.hasNext()) {
        String argConnectPoint = cpIt.next();
        CarrierEthernetLogicalTerminationPoint ltp = ceManager.generateLtp(ConnectPoint.deviceConnectPoint(argConnectPoint), ltpType);
        if (ltp != null) {
            ceManager.addGlobalLtp(ltp);
        }
    }
}
#method_after
@Override
protected void execute() {
    CarrierEthernetManager ceManager = get(CarrierEthernetManager.class);
    CarrierEthernetLogicalTerminationPoint.Type ltpType = null;
    if (!argLtpType.equals("AUTO")) {
        try {
            ltpType = CarrierEthernetLogicalTerminationPoint.Type.valueOf(argLtpType);
        } catch (IllegalArgumentException e) {
            log.error("{} is not a valid LTP type, skipping LTP generation.");
            return;
        }
    }
    Iterator<String> cpIt = argConnectPointList.iterator();
    while (cpIt.hasNext()) {
        String argConnectPoint = cpIt.next();
        CarrierEthernetLogicalTerminationPoint ltp = ceManager.generateLtp(ConnectPoint.deviceConnectPoint(argConnectPoint), ltpType);
        if (ltp != null) {
            ceManager.addGlobalLtp(ltp);
        }
    }
}
#end_block

#method_before
public CarrierEthernetVirtualConnection establishConnectivity(CarrierEthernetVirtualConnection evc) {
    // If EVC already exists, remove it and reestablish with new parameters
    if (evc.id() != null && evcMap.containsKey(evc.id())) {
        return updateEvc(evc);
    } else {
        evc.setId(null);
    }
    validateEvc(evc);
    if (evc == null) {
        log.error("EVC could not be installed, please check log for details.");
        return null;
    }
    boolean allPairsConnected = true;
    // Temporary set for iterating through EVC UNI pairs
    Set<CarrierEthernetUni> uniSet = new HashSet<>(evc.uniSet());
    // Temporary set for indicating which UNIs were finally included in the EVC
    Set<CarrierEthernetUni> usedUniSet = new HashSet<>();
    Iterator<CarrierEthernetUni> uniIt1 = uniSet.iterator();
    while (uniIt1.hasNext()) {
        CarrierEthernetUni uni1 = uniIt1.next();
        // Iterate through all the remaining UNIs
        Iterator<CarrierEthernetUni> uniIt2 = uniSet.iterator();
        while (uniIt2.hasNext()) {
            CarrierEthernetUni uni2 = uniIt2.next();
            // Skip equals
            if (uni1.equals(uni2)) {
                continue;
            }
            // Do not establish connectivity between leaf UNIs (applies to Rooted_Multipoint)
            if (uni1.role() == CarrierEthernetUni.Role.LEAF && uni2.role() == CarrierEthernetUni.Role.LEAF) {
                continue;
            }
            OpticalConnectivityId opticalConnectId = null;
            if (pktOpticalTopo) {
                opticalConnectId = setupOpticalConnectivity(uni1.cp(), uni2.cp(), uni1.bwp().cir(), evc.latency());
                if (opticalConnectId == null || opticalConnectStatusMap.get(opticalConnectId) != OpticalPathEvent.Type.PATH_INSTALLED) {
                    log.error("Could not establish optical connectivity between {} and {}" + " (optical id and status: {}, {})", uni1.cp(), uni2.cp(), opticalConnectId, (opticalConnectId == null ? "null" : opticalConnectStatusMap.get(opticalConnectId)));
                    allPairsConnected = false;
                    continue;
                }
                if (opticalConnectId != null) {
                    evc.setMetroConnectivityId(opticalConnectId);
                    evc.setMetroConnectivityStatus(opticalConnectStatusMap.get(opticalConnectId));
                }
                log.info("Metro connectivity id and status for EVC {}: {}, {}", evc.id(), evc.metroConnectivity().id(), evc.metroConnectivity().status());
                if (opticalConnectId != null) {
                    // TODO: find vlanIds for both CO and store to service
                    opticalPathService.getPath(opticalConnectId).ifPresent(links -> {
                        getVlanTag(links).ifPresent(vlan -> {
                            log.info("VLAN ID {} is assigned to CE service {}", vlan, evc.id());
                            evc.setVlanId(vlan);
                        });
                    });
                }
            }
            if (!cePktProvisioner.setupConnectivity(uni1, uni2, evc)) {
                log.warn("Could not set up packet connectivity between {} and {}", uni1, uni2);
                removeOpticalConnectivity(opticalConnectId);
                allPairsConnected = false;
                continue;
            }
            // Indicate that connection for at least one UNI pair has been established
            evc.setState(CarrierEthernetVirtualConnection.State.ACTIVE);
            // Add UNIs to the set of UNIs used by the EVC
            usedUniSet.add(uni1);
            usedUniSet.add(uni2);
        }
        // Remove UNI from temporary set so that each pair is visited only once
        uniIt1.remove();
    }
    // Update the global UNI reference count
    usedUniSet.forEach(uni -> uniMap.get(uni.id()).setRefCount(uniMap.get(uni.id()).refCount() + 1));
    // Update the EVC UNI set, based on the UNIs actually used
    evc.setUniSet(usedUniSet);
    // If no pair was connected, do not register the EVC
    if (evc.state().equals(CarrierEthernetVirtualConnection.State.ACTIVE)) {
        evcMap.put(evc.id(), evc);
        cePktProvisioner.applyBandwidthProfiles(evc);
        // Apply the BWPs of the EVC UNI to the global UNIs, creating them if needed
        applyBandwidthProfiles(evc.uniSet());
    }
    if (evc.state().equals(CarrierEthernetVirtualConnection.State.ACTIVE)) {
        if (allPairsConnected) {
            evc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.FULL);
        } else {
            evc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.PARTIAL);
        }
    }
    return evc;
}
#method_after
public CarrierEthernetVirtualConnection establishConnectivity(CarrierEthernetVirtualConnection evc) {
    // If EVC already exists, remove it and reestablish with new parameters
    if (evc.id() != null && evcMap.containsKey(evc.id())) {
        return updateEvc(evc);
    } else {
        evc.setId(null);
    }
    validateEvc(evc);
    if (evc == null) {
        log.error("EVC could not be installed, please check log for details.");
        return null;
    }
    boolean allPairsConnected = true;
    // Temporary set for iterating through EVC UNI pairs
    Set<CarrierEthernetUni> uniSet = new HashSet<>(evc.uniSet());
    // Temporary set for indicating which UNIs were finally included in the EVC
    Set<CarrierEthernetUni> usedUniSet = new HashSet<>();
    Iterator<CarrierEthernetUni> uniIt1 = uniSet.iterator();
    while (uniIt1.hasNext()) {
        CarrierEthernetUni uni1 = uniIt1.next();
        // Iterate through all the remaining UNIs
        Iterator<CarrierEthernetUni> uniIt2 = uniSet.iterator();
        while (uniIt2.hasNext()) {
            CarrierEthernetUni uni2 = uniIt2.next();
            // Skip equals
            if (uni1.equals(uni2)) {
                continue;
            }
            // Do not establish connectivity between leaf UNIs (applies to Rooted_Multipoint)
            if (uni1.role() == CarrierEthernetUni.Role.LEAF && uni2.role() == CarrierEthernetUni.Role.LEAF) {
                continue;
            }
            OpticalConnectivityId opticalConnectId = null;
            if (pktOpticalTopo) {
                opticalConnectId = setupOpticalConnectivity(uni1.cp(), uni2.cp(), uni1.bwp().cir(), evc.latency());
                if (opticalConnectId == null || opticalConnectStatusMap.get(opticalConnectId) != OpticalPathEvent.Type.PATH_INSTALLED) {
                    log.error("Could not establish optical connectivity between {} and {}" + " (optical id and status: {}, {})", uni1.cp(), uni2.cp(), opticalConnectId, (opticalConnectId == null ? "null" : opticalConnectStatusMap.get(opticalConnectId)));
                    allPairsConnected = false;
                    continue;
                }
                if (opticalConnectId != null) {
                    evc.setMetroConnectivityId(opticalConnectId);
                    evc.setMetroConnectivityStatus(opticalConnectStatusMap.get(opticalConnectId));
                }
                log.info("Metro connectivity id and status for EVC {}: {}, {}", evc.id(), evc.metroConnectivity().id(), evc.metroConnectivity().status());
                if (opticalConnectId != null) {
                    // TODO: find vlanIds for both CO and store to service
                    opticalPathService.getPath(opticalConnectId).ifPresent(links -> {
                        getVlanTag(links).ifPresent(vlan -> {
                            log.info("VLAN ID {} is assigned to CE service {}", vlan, evc.id());
                            evc.setVlanId(vlan);
                        });
                    });
                }
            }
            if (!cePktProvisioner.setupConnectivity(uni1, uni2, evc)) {
                log.warn("Could not set up packet connectivity between {} and {}", uni1, uni2);
                removeOpticalConnectivity(opticalConnectId);
                allPairsConnected = false;
                continue;
            }
            // Indicate that connection for at least one UNI pair has been established
            evc.setState(CarrierEthernetVirtualConnection.State.ACTIVE);
            // Add UNIs to the set of UNIs used by the EVC
            usedUniSet.add(uni1);
            usedUniSet.add(uni2);
        }
        // Remove UNI from temporary set so that each pair is visited only once
        uniIt1.remove();
    }
    // Increment the global UNI reference count
    usedUniSet.forEach(uni -> uniMap.get(uni.id()).refCount().incrementAndGet());
    // Update the EVC UNI set, based on the UNIs actually used
    evc.setUniSet(usedUniSet);
    // If no pair was connected, do not register the EVC
    if (evc.state().equals(CarrierEthernetVirtualConnection.State.ACTIVE)) {
        evcMap.put(evc.id(), evc);
        cePktProvisioner.applyBandwidthProfiles(evc);
        // Apply the BWPs of the EVC UNI to the global UNIs, creating them if needed
        applyBandwidthProfiles(evc.uniSet());
    }
    if (evc.state().equals(CarrierEthernetVirtualConnection.State.ACTIVE)) {
        if (allPairsConnected) {
            evc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.FULL);
        } else {
            evc.setActiveState(CarrierEthernetVirtualConnection.ActiveState.PARTIAL);
        }
    }
    return evc;
}
#end_block

#method_before
public void removeAllEvcs() {
    evcMap.keySet().forEach(evcId -> {
        CarrierEthernetVirtualConnection evc = evcMap.get(evcId);
        cePktProvisioner.removeConnectivity(evc);
        cePktProvisioner.removeBandwidthProfiles(evc);
        removeOpticalConnectivity(evc.metroConnectivity().id());
        removeBandwidthProfiles(evcId);
        // Avoid excessively incrementing VLAN ids
        nextVlanId = (evc.vlanId().toShort() < nextVlanId ? evc.vlanId().toShort() : nextVlanId);
        // Update the global UNI and corresponding NI refCount
        // FIXME: Remove this as soon as EVCs are always made of FCs
        evc.uniSet().forEach(uni -> uniMap.get(uni.id()).setRefCount(uniMap.get(uni.id()).refCount() - 1));
    });
    evcMap.clear();
}
#method_after
public void removeAllEvcs() {
    evcMap.keySet().forEach(evcId -> {
        CarrierEthernetVirtualConnection evc = evcMap.get(evcId);
        cePktProvisioner.removeConnectivity(evc);
        cePktProvisioner.removeBandwidthProfiles(evc);
        removeOpticalConnectivity(evc.metroConnectivity().id());
        removeBandwidthProfiles(evcId);
        // Avoid excessively incrementing VLAN ids
        nextVlanId = (evc.vlanId().toShort() < nextVlanId ? evc.vlanId().toShort() : nextVlanId);
        // Decrement the global UNI and corresponding NI refCount
        // FIXME: Remove this as soon as EVCs are always made of FCs
        evc.uniSet().forEach(uni -> uniMap.get(uni.id()).refCount().decrementAndGet());
    });
    evcMap.clear();
}
#end_block

#method_before
public void removeEvc(String evcId) {
    if (evcMap.containsKey(evcId)) {
        CarrierEthernetVirtualConnection evc = evcMap.get(evcId);
        cePktProvisioner.removeConnectivity(evc);
        cePktProvisioner.removeBandwidthProfiles(evc);
        removeOpticalConnectivity(evc.metroConnectivity().id());
        removeBandwidthProfiles(evcId);
        // Avoid excessively incrementing VLAN ids
        nextVlanId = (evc.vlanId().toShort() < nextVlanId ? evc.vlanId().toShort() : nextVlanId);
        // Update the global UNI and corresponding NI refCount
        // FIXME: Remove this as soon as EVCs are always made of FCs
        evc.uniSet().forEach(uni -> uniMap.get(uni.id()).setRefCount(uniMap.get(uni.id()).refCount() - 1));
        evcMap.remove(evcId);
    }
}
#method_after
public void removeEvc(String evcId) {
    if (evcMap.containsKey(evcId)) {
        CarrierEthernetVirtualConnection evc = evcMap.get(evcId);
        cePktProvisioner.removeConnectivity(evc);
        cePktProvisioner.removeBandwidthProfiles(evc);
        removeOpticalConnectivity(evc.metroConnectivity().id());
        removeBandwidthProfiles(evcId);
        // Avoid excessively incrementing VLAN ids
        nextVlanId = (evc.vlanId().toShort() < nextVlanId ? evc.vlanId().toShort() : nextVlanId);
        // Decrement the global UNI and corresponding NI refCount
        // FIXME: Remove this as soon as EVCs are always made of FCs
        evc.uniSet().forEach(uni -> uniMap.get(uni.id()).refCount().decrementAndGet());
        evcMap.remove(evcId);
    }
}
#end_block

#method_before
// FIXME: Rethink this approach
public CarrierEthernetForwardingConstruct installFc(CarrierEthernetForwardingConstruct fc) {
    // If FC already exists, remove it and reestablish with new parameters
    if (fc.id() != null && fcMap.containsKey(fc.id())) {
        return updateFc(fc);
    } else {
        fc.setId(null);
    }
    validateFc(fc);
    if (fc == null) {
        log.error("FC could not be installed, please check log for details.");
        return null;
    }
    boolean allPairsConnected = true;
    // Temporary set for iterating through FC NI pairs
    Set<CarrierEthernetNetworkInterface> niSet = new HashSet<>();
    fc.ltpSet().forEach(ltp -> {
        niSet.add(ltp.ni());
    });
    // Temporary set for indicating which NIs were finally included in the FC
    Set<CarrierEthernetNetworkInterface> usedNiSet = new HashSet<>();
    Iterator<CarrierEthernetNetworkInterface> it1 = niSet.iterator();
    while (it1.hasNext()) {
        CarrierEthernetNetworkInterface ni1 = it1.next();
        // Iterate through all the remaining UNIs
        Iterator<CarrierEthernetNetworkInterface> it2 = niSet.iterator();
        while (it2.hasNext()) {
            CarrierEthernetNetworkInterface ni2 = it2.next();
            // Skip equals
            if (ni1.equals(ni2)) {
                continue;
            }
            // Do not establish connectivity between leaf UNIs (applies to Rooted_Multipoint)
            if (ni1.role() == CarrierEthernetUni.Role.LEAF && ni2.role() == CarrierEthernetUni.Role.LEAF) {
                continue;
            }
            if (!cePktProvisioner.setupConnectivity(ni1, ni2, fc.evcLite())) {
                log.warn("Could not set up packet connectivity between {} and {}", ni1, ni2);
                allPairsConnected = false;
                continue;
            }
            // Indicate that connection for at least one LTP pair has been established
            fc.setState(CarrierEthernetForwardingConstruct.State.ACTIVE);
            // Add UNIs to the set of UNIs used by the EVC
            usedNiSet.add(ni1);
            usedNiSet.add(ni2);
        }
        // Remove NI from temporary set so that each pair is visited only once
        it1.remove();
    }
    // Update the FC LTP set, based on the NIs actually used
    Set<CarrierEthernetLogicalTerminationPoint> usedLtpSet = new HashSet<>();
    fc.ltpSet().forEach(ltp -> {
        if (usedNiSet.contains(ltp.ni())) {
            usedLtpSet.add(ltp);
        }
    });
    fc.setLtpSet(usedLtpSet);
    // Update the global LTP and corresponding NI refCount
    usedLtpSet.forEach(ltp -> ltpMap.get(ltp.id()).setRefCount(ltpMap.get(ltp.id()).refCount() + 1));
    // If no pair was connected, do not register the FC
    if (fc.state().equals(CarrierEthernetForwardingConstruct.State.ACTIVE)) {
        fcMap.put(fc.id(), fc);
        evcMap.put(fc.evcLite().id(), fc.evcLite());
        cePktProvisioner.applyBandwidthProfiles(fc.evcLite());
        // Apply the BWPs of the EVC UNI to the global UNIs, creating them if needed
        applyBandwidthProfiles(fc.evcLite().uniSet());
    }
    if (fc.state().equals(CarrierEthernetForwardingConstruct.State.ACTIVE)) {
        if (allPairsConnected) {
            fc.setActiveState(CarrierEthernetForwardingConstruct.ActiveState.FULL);
        } else {
            fc.setActiveState(CarrierEthernetForwardingConstruct.ActiveState.PARTIAL);
        }
    }
    return fc;
}
#method_after
// FIXME: Rethink this approach
public CarrierEthernetForwardingConstruct installFc(CarrierEthernetForwardingConstruct fc) {
    // If FC already exists, remove it and reestablish with new parameters
    if (fc.id() != null && fcMap.containsKey(fc.id())) {
        return updateFc(fc);
    } else {
        fc.setId(null);
    }
    validateFc(fc);
    if (fc == null) {
        log.error("FC could not be installed, please check log for details.");
        return null;
    }
    boolean allPairsConnected = true;
    // Temporary set for iterating through FC NI pairs
    Set<CarrierEthernetNetworkInterface> niSet = new HashSet<>();
    fc.ltpSet().forEach(ltp -> {
        niSet.add(ltp.ni());
    });
    // Temporary set for indicating which NIs were finally included in the FC
    Set<CarrierEthernetNetworkInterface> usedNiSet = new HashSet<>();
    Iterator<CarrierEthernetNetworkInterface> it1 = niSet.iterator();
    while (it1.hasNext()) {
        CarrierEthernetNetworkInterface ni1 = it1.next();
        // Iterate through all the remaining UNIs
        Iterator<CarrierEthernetNetworkInterface> it2 = niSet.iterator();
        while (it2.hasNext()) {
            CarrierEthernetNetworkInterface ni2 = it2.next();
            // Skip equals
            if (ni1.equals(ni2)) {
                continue;
            }
            // Do not establish connectivity between leaf UNIs (applies to Rooted_Multipoint)
            if (ni1.role() == CarrierEthernetUni.Role.LEAF && ni2.role() == CarrierEthernetUni.Role.LEAF) {
                continue;
            }
            if (!cePktProvisioner.setupConnectivity(ni1, ni2, fc.evcLite())) {
                log.warn("Could not set up packet connectivity between {} and {}", ni1, ni2);
                allPairsConnected = false;
                continue;
            }
            // Indicate that connection for at least one LTP pair has been established
            fc.setState(CarrierEthernetForwardingConstruct.State.ACTIVE);
            // Add UNIs to the set of UNIs used by the EVC
            usedNiSet.add(ni1);
            usedNiSet.add(ni2);
        }
        // Remove NI from temporary set so that each pair is visited only once
        it1.remove();
    }
    // Update the FC LTP set, based on the NIs actually used
    Set<CarrierEthernetLogicalTerminationPoint> usedLtpSet = new HashSet<>();
    fc.ltpSet().forEach(ltp -> {
        if (usedNiSet.contains(ltp.ni())) {
            usedLtpSet.add(ltp);
        }
    });
    fc.setLtpSet(usedLtpSet);
    // Increment the global LTP and corresponding NI refCount
    usedLtpSet.forEach(ltp -> ltpMap.get(ltp.id()).refCount().incrementAndGet());
    // If no pair was connected, do not register the FC
    if (fc.state().equals(CarrierEthernetForwardingConstruct.State.ACTIVE)) {
        fcMap.put(fc.id(), fc);
        evcMap.put(fc.evcLite().id(), fc.evcLite());
        cePktProvisioner.applyBandwidthProfiles(fc.evcLite());
        // Apply the BWPs of the EVC UNI to the global UNIs, creating them if needed
        applyBandwidthProfiles(fc.evcLite().uniSet());
    }
    if (fc.state().equals(CarrierEthernetForwardingConstruct.State.ACTIVE)) {
        if (allPairsConnected) {
            fc.setActiveState(CarrierEthernetForwardingConstruct.ActiveState.FULL);
        } else {
            fc.setActiveState(CarrierEthernetForwardingConstruct.ActiveState.PARTIAL);
        }
    }
    return fc;
}
#end_block

#method_before
// FIXME: Rethink this approach
public void removeFc(String fcId) {
    if (fcMap.containsKey(fcId)) {
        // FIXME: For now, UNI refCount will be updated in removeEvc()
        removeEvc(fcMap.get(fcId).evcLite().id());
        // Update the global LTP and corresponding NI refCount
        // FIXME: Remove the UNI constraint as soon as EVCs are always constructed of FCs
        fcMap.get(fcId).ltpSet().forEach(ltp -> {
            if (!(ltp.ni() instanceof CarrierEthernetUni)) {
                ltpMap.get(ltp.id()).setRefCount(ltpMap.get(ltp.id()).refCount() - 1);
            }
        });
        fcMap.remove(fcId);
    }
}
#method_after
// FIXME: Rethink this approach
public void removeFc(String fcId) {
    if (fcMap.containsKey(fcId)) {
        // FIXME: For now, UNI refCount will be updated in removeEvc()
        removeEvc(fcMap.get(fcId).evcLite().id());
        // Decrement the global LTP and corresponding NI refCount
        // FIXME: Remove the UNI constraint as soon as EVCs are always constructed of FCs
        fcMap.get(fcId).ltpSet().forEach(ltp -> {
            if (!(ltp.ni() instanceof CarrierEthernetUni)) {
                ltpMap.get(ltp.id()).refCount().decrementAndGet();
            }
        });
        fcMap.remove(fcId);
    }
}
#end_block

#method_before
public CarrierEthernetLogicalTerminationPoint removeGlobalLtp(String ltpId) {
    if (!ltpMap.containsKey(ltpId)) {
        log.warn("Could not remove LTP {}: Does not exist", ltpId);
        return null;
    }
    if (ltpMap.get(ltpId).refCount() != 0) {
        log.warn("Could not remove LTP {}: RefCount is not zero", ltpId);
        return null;
    }
    // Remove LTP from ltpMap and (if needed) UNI from uniMap
    CarrierEthernetLogicalTerminationPoint ltp = ltpMap.remove(ltpId);
    if (ltp.ni() instanceof CarrierEthernetUni) {
        removeGlobalUni(ltp.ni().id());
    }
    // Add LTP to removed set
    removedLtpSet.add(ltpId);
    return ltp;
}
#method_after
public CarrierEthernetLogicalTerminationPoint removeGlobalLtp(String ltpId) {
    if (!ltpMap.containsKey(ltpId)) {
        log.warn("Could not remove LTP {}: Does not exist", ltpId);
        return null;
    }
    if (ltpMap.get(ltpId).refCount().get() != 0) {
        log.warn("Could not remove LTP {}: RefCount is not zero", ltpId);
        return null;
    }
    // Remove LTP from ltpMap and (if needed) UNI from uniMap
    CarrierEthernetLogicalTerminationPoint ltp = ltpMap.remove(ltpId);
    if (ltp.ni() instanceof CarrierEthernetUni) {
        removeGlobalUni(ltp.ni().id());
    }
    // Add LTP to removed set
    removedLtpSet.add(ltpId);
    return ltp;
}
#end_block

#method_before
public CarrierEthernetUni removeGlobalUni(String uniId) {
    if (!uniMap.containsKey(uniId)) {
        log.warn("Could not remove UNI {}: Does not exist", uniId);
        return null;
    }
    if (uniMap.get(uniId).refCount() != 0) {
        log.warn("Could not remove UNI {}: RefCount is not zero", uniId);
        return null;
    }
    // Remove UNI from uniMap and corresponding LTP (if any) from ltpMp
    CarrierEthernetUni uni = uniMap.remove(uniId);
    // FIXME: For now, find LTP assuming ltpId is the same as uniId
    // Note: If refCount for UNI is not zero, then it should be for the corresponding LTP as well
    ltpMap.remove(uniId);
    // Add UNI to removed set
    removedUniSet.add(uniId);
    removedLtpSet.add(uniId);
    return uni;
}
#method_after
public CarrierEthernetUni removeGlobalUni(String uniId) {
    if (!uniMap.containsKey(uniId)) {
        log.warn("Could not remove UNI {}: Does not exist", uniId);
        return null;
    }
    if (uniMap.get(uniId).refCount().get() != 0) {
        log.warn("Could not remove UNI {}: RefCount is not zero", uniId);
        return null;
    }
    // Remove UNI from uniMap and corresponding LTP (if any) from ltpMp
    CarrierEthernetUni uni = uniMap.remove(uniId);
    // FIXME: For now, find LTP assuming ltpId is the same as uniId
    // Note: If refCount for UNI is not zero, then it should be for the corresponding LTP as well
    ltpMap.remove(uniId);
    // Add UNI to removed set
    removedUniSet.add(uniId);
    removedLtpSet.add(uniId);
    return uni;
}
#end_block

#method_before
public Integer refCount() {
    return ni().refCount();
}
#method_after
public AtomicInteger refCount() {
    return ni().refCount();
}
#end_block

#method_before
@Test
public void testEncapIngressEgressVlansCompile() {
    sut.activate();
    List<Intent> compiled = sut.compile(constrainIngressEgressVlanIntent, Collections.emptyList());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    assertThat(rules, hasSize(3));
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule1, d1p0.deviceId());
    verifyVlanEncapSelector(rule1.selector(), d1p0, ingressVlan);
    VlanId vlanToEncap = verifyVlanEncapTreatment(rule1.treatment(), d1p1, true, false);
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule2, d2p0.deviceId());
    verifyVlanEncapSelector(rule2.selector(), d2p0, vlanToEncap);
    vlanToEncap = verifyVlanEncapTreatment(rule2.treatment(), d2p1, false, false);
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule3, d3p1.deviceId());
    verifyVlanEncapSelector(rule3.selector(), d3p1, vlanToEncap);
    Set<L2ModificationInstruction.ModVlanIdInstruction> vlanMod = rule3.treatment().allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).map(x -> (L2ModificationInstruction.ModVlanIdInstruction) x).collect(Collectors.toSet());
    assertThat(rule3.treatment().allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).collect(Collectors.toSet()), hasSize(1));
    assertThat(vlanMod.iterator().next().vlanId(), is(egressVlan));
    assertThat(rule3.treatment().allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.PopVlanInstruction).collect(Collectors.toSet()), hasSize(0));
    sut.deactivate();
}
#method_after
@Test
public void testEncapIngressEgressVlansCompile() {
    sut.activate();
    List<Intent> compiled = sut.compile(constrainIngressEgressVlanIntent, Collections.emptyList());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    assertThat(rules, hasSize(3));
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule1, d1p0.deviceId());
    verifyVlanEncapSelector(rule1.selector(), d1p0, ingressVlan);
    VlanId vlanToEncap = verifyVlanEncapTreatment(rule1.treatment(), d1p1, true, false);
    FlowRule rule2 = rules.stream().filter(x -> x.deviceId().equals(d2p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule2, d2p0.deviceId());
    verifyVlanEncapSelector(rule2.selector(), d2p0, vlanToEncap);
    vlanToEncap = verifyVlanEncapTreatment(rule2.treatment(), d2p1, false, false);
    FlowRule rule3 = rules.stream().filter(x -> x.deviceId().equals(d3p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule3, d3p1.deviceId());
    verifyVlanEncapSelector(rule3.selector(), d3p1, vlanToEncap);
    Set<L2ModificationInstruction.ModVlanIdInstruction> vlanMod = rule3.treatment().allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).map(x -> (L2ModificationInstruction.ModVlanIdInstruction) x).collect(Collectors.toSet());
    assertThat(rule3.treatment().allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).collect(Collectors.toSet()), hasSize(1));
    assertThat(vlanMod.iterator().next().vlanId(), is(egressVlan));
    assertThat(rule3.treatment().allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanHeaderInstruction).collect(Collectors.toSet()), hasSize(0));
    sut.deactivate();
}
#end_block

#method_before
@Test
public void testRandomVlanSelection() {
    sut.activate();
    List<Intent> compiled = sut.compile(constraintVlanIntent, Collections.emptyList());
    assertThat(compiled, hasSize(1));
    Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
    assertThat(rules, hasSize(3));
    FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule1, d1p0.deviceId());
    assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
    VlanId vlanToEncap = verifyVlanEncapTreatment(rule1.treatment(), d1p1, true, false);
    assertTrue(VlanId.NO_VID < vlanToEncap.toShort() && vlanToEncap.toShort() < VlanId.MAX_VLAN);
    List<Intent> compiled2 = sut.compile(constraintVlanIntent, Collections.emptyList());
    assertThat(compiled2, hasSize(1));
    Collection<FlowRule> rules2 = ((FlowRuleIntent) compiled2.get(0)).flowRules();
    assertThat(rules2, hasSize(3));
    FlowRule rule2 = rules2.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
    verifyIdAndPriority(rule2, d1p0.deviceId());
    assertThat(rule2.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
    VlanId vlanToEncap2 = verifyVlanEncapTreatment(rule2.treatment(), d1p1, true, false);
    assertTrue(VlanId.NO_VID < vlanToEncap2.toShort() && vlanToEncap2.toShort() < VlanId.MAX_VLAN);
    assertNotEquals(vlanToEncap, vlanToEncap2);
    sut.deactivate();
}
#method_after
@Test
public void testRandomVlanSelection() {
    if (PathCompiler.RANDOM_SELECTION) {
        sut.activate();
        List<Intent> compiled = sut.compile(constraintVlanIntent, Collections.emptyList());
        assertThat(compiled, hasSize(1));
        Collection<FlowRule> rules = ((FlowRuleIntent) compiled.get(0)).flowRules();
        assertThat(rules, hasSize(3));
        FlowRule rule1 = rules.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
        verifyIdAndPriority(rule1, d1p0.deviceId());
        assertThat(rule1.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
        VlanId vlanToEncap = verifyVlanEncapTreatment(rule1.treatment(), d1p1, true, false);
        assertTrue(VlanId.NO_VID < vlanToEncap.toShort() && vlanToEncap.toShort() < VlanId.MAX_VLAN);
        /**
         * This second part is meant to test if the random selection is working properly.
         * We are compiling the same intent in order to verify if the VLAN ID is different
         * from the previous one.
         */
        List<Intent> compiled2 = sut.compile(constraintVlanIntent, Collections.emptyList());
        assertThat(compiled2, hasSize(1));
        Collection<FlowRule> rules2 = ((FlowRuleIntent) compiled2.get(0)).flowRules();
        assertThat(rules2, hasSize(3));
        FlowRule rule2 = rules2.stream().filter(x -> x.deviceId().equals(d1p0.deviceId())).findFirst().get();
        verifyIdAndPriority(rule2, d1p0.deviceId());
        assertThat(rule2.selector(), is(DefaultTrafficSelector.builder(selector).matchInPort(d1p0.port()).build()));
        VlanId vlanToEncap2 = verifyVlanEncapTreatment(rule2.treatment(), d1p1, true, false);
        assertTrue(VlanId.NO_VID < vlanToEncap2.toShort() && vlanToEncap2.toShort() < VlanId.MAX_VLAN);
        assertNotEquals(vlanToEncap, vlanToEncap2);
        sut.deactivate();
    }
}
#end_block

#method_before
private VlanId verifyVlanEncapTreatment(TrafficTreatment trafficTreatment, ConnectPoint egress, boolean isIngress, boolean isEgress) {
    Set<Instructions.OutputInstruction> ruleOutput = trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof Instructions.OutputInstruction).map(treat -> (Instructions.OutputInstruction) treat).collect(Collectors.toSet());
    assertThat(ruleOutput, hasSize(1));
    assertThat((ruleOutput.iterator().next()).port(), is(egress.port()));
    VlanId vlanToEncap = VlanId.NONE;
    if (isIngress && !isEgress) {
        Set<L2ModificationInstruction.ModVlanIdInstruction> vlanRules = trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).map(x -> (L2ModificationInstruction.ModVlanIdInstruction) x).collect(Collectors.toSet());
        assertThat(vlanRules, hasSize(1));
        L2ModificationInstruction.ModVlanIdInstruction vlanRule = vlanRules.iterator().next();
        assertThat(vlanRule.vlanId().toShort(), greaterThan((short) VlanId.NO_VID));
        assertThat(vlanRule.vlanId().toShort(), lessThan((short) VlanId.MAX_VLAN));
        vlanToEncap = vlanRule.vlanId();
    } else if (!isIngress && !isEgress) {
        Set<L2ModificationInstruction.ModVlanIdInstruction> vlanRules = trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).map(x -> (L2ModificationInstruction.ModVlanIdInstruction) x).collect(Collectors.toSet());
        assertThat(vlanRules, hasSize(1));
        L2ModificationInstruction.ModVlanIdInstruction vlanRule = vlanRules.iterator().next();
        assertThat(vlanRule.vlanId().toShort(), greaterThan((short) VlanId.NO_VID));
        assertThat(vlanRule.vlanId().toShort(), lessThan((short) VlanId.MAX_VLAN));
        vlanToEncap = vlanRule.vlanId();
    } else {
        assertThat(trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).collect(Collectors.toSet()), hasSize(0));
        assertThat(trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.PopVlanInstruction).collect(Collectors.toSet()), hasSize(1));
    }
    return vlanToEncap;
}
#method_after
private VlanId verifyVlanEncapTreatment(TrafficTreatment trafficTreatment, ConnectPoint egress, boolean isIngress, boolean isEgress) {
    Set<Instructions.OutputInstruction> ruleOutput = trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof Instructions.OutputInstruction).map(treat -> (Instructions.OutputInstruction) treat).collect(Collectors.toSet());
    assertThat(ruleOutput, hasSize(1));
    assertThat((ruleOutput.iterator().next()).port(), is(egress.port()));
    VlanId vlanToEncap = VlanId.NONE;
    if (isIngress && !isEgress) {
        Set<L2ModificationInstruction.ModVlanIdInstruction> vlanRules = trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).map(x -> (L2ModificationInstruction.ModVlanIdInstruction) x).collect(Collectors.toSet());
        assertThat(vlanRules, hasSize(1));
        L2ModificationInstruction.ModVlanIdInstruction vlanRule = vlanRules.iterator().next();
        assertThat(vlanRule.vlanId().toShort(), greaterThan((short) VlanId.NO_VID));
        assertThat(vlanRule.vlanId().toShort(), lessThan((short) VlanId.MAX_VLAN));
        vlanToEncap = vlanRule.vlanId();
    } else if (!isIngress && !isEgress) {
        Set<L2ModificationInstruction.ModVlanIdInstruction> vlanRules = trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).map(x -> (L2ModificationInstruction.ModVlanIdInstruction) x).collect(Collectors.toSet());
        assertThat(vlanRules, hasSize(1));
        L2ModificationInstruction.ModVlanIdInstruction vlanRule = vlanRules.iterator().next();
        assertThat(vlanRule.vlanId().toShort(), greaterThan((short) VlanId.NO_VID));
        assertThat(vlanRule.vlanId().toShort(), lessThan((short) VlanId.MAX_VLAN));
        vlanToEncap = vlanRule.vlanId();
    } else {
        assertThat(trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanIdInstruction).collect(Collectors.toSet()), hasSize(0));
        assertThat(trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModVlanHeaderInstruction).collect(Collectors.toSet()), hasSize(1));
    }
    return vlanToEncap;
}
#end_block

#method_before
private MplsLabel verifyMplsEncapTreatment(TrafficTreatment trafficTreatment, ConnectPoint egress, boolean isIngress, boolean isEgress) {
    Set<Instructions.OutputInstruction> ruleOutput = trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof Instructions.OutputInstruction).map(treat -> (Instructions.OutputInstruction) treat).collect(Collectors.toSet());
    assertThat(ruleOutput, hasSize(1));
    assertThat((ruleOutput.iterator().next()).port(), is(egress.port()));
    MplsLabel mplsToEncap = MplsLabel.mplsLabel(0);
    if (isIngress && !isEgress) {
        Set<L2ModificationInstruction.ModMplsLabelInstruction> mplsRules = trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModMplsLabelInstruction).map(x -> (L2ModificationInstruction.ModMplsLabelInstruction) x).collect(Collectors.toSet());
        assertThat(mplsRules, hasSize(1));
        L2ModificationInstruction.ModMplsLabelInstruction mplsRule = mplsRules.iterator().next();
        assertThat(mplsRule.mplsLabel().toInt(), greaterThan(0));
        mplsToEncap = mplsRule.mplsLabel();
    } else if (!isIngress && !isEgress) {
        assertThat(trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModMplsLabelInstruction).collect(Collectors.toSet()), hasSize(0));
    } else {
        assertThat(trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModMplsLabelInstruction).collect(Collectors.toSet()), hasSize(0));
        assertThat(trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.PushHeaderInstructions).collect(Collectors.toSet()), hasSize(1));
    }
    return mplsToEncap;
}
#method_after
private MplsLabel verifyMplsEncapTreatment(TrafficTreatment trafficTreatment, ConnectPoint egress, boolean isIngress, boolean isEgress) {
    Set<Instructions.OutputInstruction> ruleOutput = trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof Instructions.OutputInstruction).map(treat -> (Instructions.OutputInstruction) treat).collect(Collectors.toSet());
    assertThat(ruleOutput, hasSize(1));
    assertThat((ruleOutput.iterator().next()).port(), is(egress.port()));
    MplsLabel mplsToEncap = MplsLabel.mplsLabel(0);
    if (isIngress && !isEgress) {
        Set<L2ModificationInstruction.ModMplsLabelInstruction> mplsRules = trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModMplsLabelInstruction).map(x -> (L2ModificationInstruction.ModMplsLabelInstruction) x).collect(Collectors.toSet());
        assertThat(mplsRules, hasSize(1));
        L2ModificationInstruction.ModMplsLabelInstruction mplsRule = mplsRules.iterator().next();
        assertThat(mplsRule.mplsLabel().toInt(), greaterThan(0));
        mplsToEncap = mplsRule.mplsLabel();
    } else if (!isIngress && !isEgress) {
        assertThat(trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModMplsLabelInstruction).collect(Collectors.toSet()), hasSize(0));
    } else {
        assertThat(trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModMplsLabelInstruction).collect(Collectors.toSet()), hasSize(0));
        assertThat(trafficTreatment.allInstructions().stream().filter(treat -> treat instanceof L2ModificationInstruction.ModMplsHeaderInstruction).collect(Collectors.toSet()), hasSize(1));
    }
    return mplsToEncap;
}
#end_block

#method_before
@Override
public List<ResourceAllocation> allocate(ResourceConsumer consumer, List<Resource> resources) {
    assignment.putAll(resources.stream().collect(Collectors.toMap(x -> x, x -> consumer)));
    return resources.stream().map(x -> new ResourceAllocation(x, consumer)).collect(Collectors.toList());
}
#method_after
@Override
public List<ResourceAllocation> allocate(ResourceConsumer consumer, List<Resource> resources) {
    assignment.putAll(resources.stream().collect(Collectors.toMap(Function.identity(), x -> consumer)));
    return resources.stream().map(x -> new ResourceAllocation(x, consumer)).collect(Collectors.toList());
}
#end_block

#method_before
private Collection<Resource> addVlanIds(DiscreteResourceId parent) {
    Collection<Resource> resources = new HashSet<>();
    for (int i = 1; i <= 1000; i++) {
        resources.add(Resources.discrete(parent).resource().child(VlanId.vlanId((short) i)));
    }
    return resources;
}
#method_after
private Collection<Resource> addVlanIds(DiscreteResourceId parent) {
    Collection<Resource> resources = new HashSet<>();
    for (int i = VlanId.NO_VID + 1; i < VlanId.MAX_VLAN; i++) {
        resources.add(Resources.discrete(parent).resource().child(VlanId.vlanId((short) i)));
    }
    return resources;
}
#end_block

#method_before
private VlanId selectVlanId(Set<VlanId> available) {
    if (RANDOM_SELECTION) {
        int size = available.size();
        int index = new Random().nextInt(size);
        int i = 0;
        for (VlanId vlanid : available) {
            if (i == index) {
                return vlanid;
            }
            i = i + 1;
        }
    }
    return available.iterator().next();
}
#method_after
private VlanId selectVlanId(Set<VlanId> available) {
    return RANDOM_SELECTION ? randomSelection(available) : firsFitSelection(available);
}
#end_block

#method_before
private Map<LinkKey, VlanId> findVlanIds(PathCompilerCreateFlow creator, Set<LinkKey> links) {
    Map<LinkKey, VlanId> vlanIds = new HashMap<>();
    for (LinkKey link : links) {
        Set<VlanId> forward = findVlanId(creator, link.src());
        Set<VlanId> backward = findVlanId(creator, link.dst());
        Set<VlanId> common = Sets.intersection(forward, backward);
        if (common.isEmpty()) {
            continue;
        }
        vlanIds.put(link, selectVlanId(common));
    }
    return vlanIds;
}
#method_after
private Map<LinkKey, VlanId> findVlanIds(PathCompilerCreateFlow creator, Set<LinkKey> links) {
    Map<LinkKey, VlanId> vlanIds = new HashMap<>();
    for (LinkKey link : links) {
        Set<VlanId> forward = findVlanId(creator, link.src());
        Set<VlanId> backward = findVlanId(creator, link.dst());
        Set<VlanId> common = Sets.intersection(forward, backward);
        if (common.isEmpty()) {
            continue;
        }
        VlanId selected = selectVlanId(common);
        if (selected.toShort() == VlanId.NO_VID) {
            continue;
        }
        vlanIds.put(link, selected);
    }
    return vlanIds;
}
#end_block

#method_before
private void manageVlanEncap(PathCompilerCreateFlow<T> creator, List<T> flows, List<DeviceId> devices, PathIntent intent) {
    Map<LinkKey, VlanId> vlanIds = assignVlanId(creator, intent);
    Iterator<Link> links = intent.path().links().iterator();
    Link srcLink = links.next();
    Link link = links.next();
    // Ingress traffic
    VlanId vlanId = vlanIds.get(linkKey(link));
    if (vlanId == null) {
        throw new IntentCompilationException("No available VLAN ID for " + link);
    }
    VlanId prevVlanId = vlanId;
    Optional<VlanIdCriterion> vlanCriterion = intent.selector().criteria().stream().filter(criterion -> criterion.type() == Criterion.Type.VLAN_VID).map(criterion -> (VlanIdCriterion) criterion).findAny();
    // Push VLAN if selector does not include VLAN
    TrafficTreatment.Builder treatBuilder = DefaultTrafficTreatment.builder();
    if (!vlanCriterion.isPresent()) {
        treatBuilder.pushVlan();
    }
    // Tag the traffic with the new encapsulation VLAN
    treatBuilder.setVlanId(vlanId);
    creator.createFlow(intent.selector(), treatBuilder.build(), srcLink.dst(), link.src(), intent.priority(), true, flows, devices);
    ConnectPoint prev = link.dst();
    while (links.hasNext()) {
        link = links.next();
        if (links.hasNext()) {
            // Transit traffic
            VlanId egressVlanId = vlanIds.get(linkKey(link));
            if (egressVlanId == null) {
                throw new IntentCompilationException("No available VLAN ID for " + link);
            }
            TrafficSelector transitSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder transitTreat = DefaultTrafficTreatment.builder();
            // Set the new vlanId only if the previous one is different
            if (!prevVlanId.equals(egressVlanId)) {
                transitTreat.setVlanId(egressVlanId);
            }
            creator.createFlow(transitSelector, transitTreat.build(), prev, link.src(), intent.priority(), true, flows, devices);
            /* For the next hop we have to remember
                 * the previous egress VLAN id and the egress
                 * node
                 */
            prevVlanId = egressVlanId;
            prev = link.dst();
        } else {
            // Egress traffic
            TrafficSelector egressSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder egressTreat = DefaultTrafficTreatment.builder(intent.treatment());
            Optional<L2ModificationInstruction.ModVlanIdInstruction> modVlanIdInstruction = intent.treatment().allInstructions().stream().filter(instruction -> instruction instanceof L2ModificationInstruction.ModVlanIdInstruction).map(x -> (L2ModificationInstruction.ModVlanIdInstruction) x).findAny();
            Optional<L2ModificationInstruction.PopVlanInstruction> popVlanInstruction = intent.treatment().allInstructions().stream().filter(instruction -> instruction instanceof L2ModificationInstruction.PopVlanInstruction).map(x -> (L2ModificationInstruction.PopVlanInstruction) x).findAny();
            if (!modVlanIdInstruction.isPresent() && !popVlanInstruction.isPresent()) {
                if (vlanCriterion.isPresent()) {
                    egressTreat.setVlanId(vlanCriterion.get().vlanId());
                } else {
                    egressTreat.popVlan();
                }
            }
            creator.createFlow(egressSelector, egressTreat.build(), prev, link.src(), intent.priority(), true, flows, devices);
        }
    }
}
#method_after
private void manageVlanEncap(PathCompilerCreateFlow<T> creator, List<T> flows, List<DeviceId> devices, PathIntent intent) {
    Map<LinkKey, VlanId> vlanIds = assignVlanId(creator, intent);
    Iterator<Link> links = intent.path().links().iterator();
    Link srcLink = links.next();
    Link link = links.next();
    // Ingress traffic
    VlanId vlanId = vlanIds.get(linkKey(link));
    if (vlanId == null) {
        throw new IntentCompilationException("No available VLAN ID for " + link);
    }
    VlanId prevVlanId = vlanId;
    Optional<VlanIdCriterion> vlanCriterion = intent.selector().criteria().stream().filter(criterion -> criterion.type() == Criterion.Type.VLAN_VID).map(criterion -> (VlanIdCriterion) criterion).findAny();
    // Push VLAN if selector does not include VLAN
    TrafficTreatment.Builder treatBuilder = DefaultTrafficTreatment.builder();
    if (!vlanCriterion.isPresent()) {
        treatBuilder.pushVlan();
    }
    // Tag the traffic with the new encapsulation VLAN
    treatBuilder.setVlanId(vlanId);
    creator.createFlow(intent.selector(), treatBuilder.build(), srcLink.dst(), link.src(), intent.priority(), true, flows, devices);
    ConnectPoint prev = link.dst();
    while (links.hasNext()) {
        link = links.next();
        if (links.hasNext()) {
            // Transit traffic
            VlanId egressVlanId = vlanIds.get(linkKey(link));
            if (egressVlanId == null) {
                throw new IntentCompilationException("No available VLAN ID for " + link);
            }
            TrafficSelector transitSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder transitTreat = DefaultTrafficTreatment.builder();
            // Set the new vlanId only if the previous one is different
            if (!prevVlanId.equals(egressVlanId)) {
                transitTreat.setVlanId(egressVlanId);
            }
            creator.createFlow(transitSelector, transitTreat.build(), prev, link.src(), intent.priority(), true, flows, devices);
            /* For the next hop we have to remember
                 * the previous egress VLAN id and the egress
                 * node
                 */
            prevVlanId = egressVlanId;
            prev = link.dst();
        } else {
            // Egress traffic
            TrafficSelector egressSelector = DefaultTrafficSelector.builder().matchInPort(prev.port()).matchVlanId(prevVlanId).build();
            TrafficTreatment.Builder egressTreat = DefaultTrafficTreatment.builder(intent.treatment());
            Optional<L2ModificationInstruction.ModVlanIdInstruction> modVlanIdInstruction = intent.treatment().allInstructions().stream().filter(instruction -> instruction instanceof L2ModificationInstruction.ModVlanIdInstruction).map(x -> (L2ModificationInstruction.ModVlanIdInstruction) x).findAny();
            Optional<L2ModificationInstruction.ModVlanHeaderInstruction> popVlanInstruction = intent.treatment().allInstructions().stream().filter(instruction -> instruction instanceof L2ModificationInstruction.ModVlanHeaderInstruction).map(x -> (L2ModificationInstruction.ModVlanHeaderInstruction) x).findAny();
            if (!modVlanIdInstruction.isPresent() && !popVlanInstruction.isPresent()) {
                if (vlanCriterion.isPresent()) {
                    egressTreat.setVlanId(vlanCriterion.get().vlanId());
                } else {
                    egressTreat.popVlan();
                }
            }
            creator.createFlow(egressSelector, egressTreat.build(), prev, link.src(), intent.priority(), true, flows, devices);
        }
    }
}
#end_block

#method_before
@Activate
protected void activate() {
    // start the dhcp relay agent
    appId = coreService.registerApplication(DHCP_RELAY_APP);
    cfgService.addListener(cfgListener);
    factories.forEach(cfgService::registerConfigFactory);
    // update the dhcp server configuration.
    updateConfig();
    // add the packet services.
    packetService.addProcessor(dhcpRelayPacketProcessor, PacketProcessor.director(0));
    requestPackets();
    log.info("DHCP-RELAY Started");
}
#method_after
@Activate
protected void activate() {
    // start the dhcp relay agent
    appId = coreService.registerApplication(DHCP_RELAY_APP);
    cfgService.addListener(cfgListener);
    factories.forEach(cfgService::registerConfigFactory);
    // update the dhcp server configuration.
    updateConfig();
    // add the packet services.
    packetService.addProcessor(dhcpRelayPacketProcessor, PacketProcessor.director(0));
    requestPackets();
    log.info("DHCP-RELAY Started");
    log.info("started the apps dhcp relay");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    packetService.removeProcessor(dhcpRelayPacketProcessor);
    cancelPackets();
    log.info("DHCP-RELAY Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    cfgService.removeListener(cfgListener);
    factories.forEach(cfgService::unregisterConfigFactory);
    packetService.removeProcessor(dhcpRelayPacketProcessor);
    cancelPackets();
    log.info("DHCP-RELAY Stopped");
}
#end_block

#method_before
private void updateConfig() {
    DhcpRelayConfig cfg = cfgService.getConfig(appId, DhcpRelayConfig.class);
    if (cfg == null) {
        log.warn("Dhcp Server info not available");
    }
    dhcpServerConnectPoint = cfg.getControlPlaneConnectPoint();
    log.info("Reconfigured the dhcp server info");
    log.info("dhcp server connect points are " + dhcpServerConnectPoint);
}
#method_after
private void updateConfig() {
    DhcpRelayConfig cfg = cfgService.getConfig(appId, DhcpRelayConfig.class);
    if (cfg == null) {
        log.warn("Dhcp Server info not available");
        return;
    }
    dhcpServerConnectPoint = cfg.getDhcpServerConnectPoint();
    log.info("Reconfigured the dhcp server info");
    log.info("dhcp server connect points are " + dhcpServerConnectPoint);
}
#end_block

#method_before
@Override
public String get(String filterSchema, String withDefaultsMode) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append("<rpc ");
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE + ">\n");
    rpc.append("<get>\n");
    if (filterSchema != null) {
        rpc.append("<filter type=\"subtree\">\n");
        rpc.append(filterSchema + NEW_LINE);
        rpc.append("</filter>\n");
    }
    if (withDefaultsMode != null) {
        rpc.append("<with-defaults " + NETCONF_WITH_DEFAULTS_NAMESPACE + ">");
        rpc.append(withDefaultsMode + "</with-defaults>\n");
    }
    rpc.append("</get>\n");
    rpc.append("</rpc>\n");
    rpc.append(ENDPATTERN);
    String reply = sendRequest(rpc.toString());
    checkReply(reply);
    return reply;
}
#method_after
@Override
public String get(String filterSchema, String withDefaultsMode) throws NetconfException {
    StringBuilder rpc = new StringBuilder(XML_HEADER);
    rpc.append(RPC_OPEN);
    rpc.append(MESSAGE_ID_STRING);
    rpc.append(EQUAL);
    rpc.append("\"");
    rpc.append(messageIdInteger.get());
    rpc.append("\"  ");
    rpc.append(NETCONF_BASE_NAMESPACE).append(">\n");
    rpc.append(GET_OPEN).append(NEW_LINE);
    if (filterSchema != null) {
        rpc.append(FILTER_OPEN).append(NEW_LINE);
        rpc.append(filterSchema).append(NEW_LINE);
        rpc.append(FILTER_CLOSE).append(NEW_LINE);
    }
    if (withDefaultsMode != null) {
        rpc.append(WITH_DEFAULT_OPEN).append(NETCONF_WITH_DEFAULTS_NAMESPACE).append(">");
        rpc.append(withDefaultsMode).append(WITH_DEFAULT_CLOSE).append(NEW_LINE);
    }
    rpc.append(GET_CLOSE).append(NEW_LINE);
    rpc.append(RPC_CLOSE).append(NEW_LINE);
    rpc.append(ENDPATTERN);
    String reply = sendRequest(rpc.toString());
    checkReply(reply);
    return reply;
}
#end_block

#method_before
private void handleEvent(List<MapEvent<String, byte[]>> events) {
    events.forEach(event -> ImmutableMap.copyOf(mapEventListeners).forEach((listener, executor) -> executor.execute(() -> listener.event(event))));
}
#method_after
private void handleEvent(List<MapEvent<String, byte[]>> events) {
    events.forEach(event -> mapEventListeners.forEach((listener, executor) -> executor.execute(() -> listener.event(event))));
}
#end_block

#method_before
private Address nextAddress() {
    Address address = new Address("127.0.0.1", port.getAndIncrement());
    members.add(address);
    return address;
}
#method_after
private Address nextAddress() {
    Address address = new Address("127.0.0.1", TestTools.findAvailablePort(port.getAndIncrement()));
    members.add(address);
    return address;
}
#end_block

#method_before
protected List<CopycatServer> createCopycatServers(int nodes) throws Throwable {
    CountDownLatch latch = new CountDownLatch(nodes);
    List<CopycatServer> servers = new ArrayList<>();
    List<Address> members = new ArrayList<>();
    for (int i = 0; i < nodes; i++) {
        members.add(nextAddress());
    }
    for (int i = 0; i < nodes; i++) {
        CopycatServer server = createCopycatServer(members.get(i));
        server.bootstrap(members).thenRun(latch::countDown);
        servers.add(server);
    }
    Uninterruptibles.awaitUninterruptibly(latch);
    return servers;
}
#method_after
protected List<CopycatServer> createCopycatServers(int nodes) throws Throwable {
    CountDownLatch latch = new CountDownLatch(nodes);
    List<CopycatServer> servers = new ArrayList<>();
    List<Address> members = new ArrayList<>();
    for (int i = 0; i < nodes; i++) {
        Address address = nextAddress();
        members.add(address);
        CopycatServer server = createCopycatServer(address);
        if (members.size() <= 1) {
            server.bootstrap().thenRun(latch::countDown).join();
        } else {
            server.join(members).thenRun(latch::countDown);
        }
        servers.add(server);
    }
    Uninterruptibles.awaitUninterruptibly(latch);
    return servers;
}
#end_block

#method_before
protected CopycatServer createCopycatServer(Address address) {
    CopycatServer server = CopycatServer.builder(address).withTransport(NettyTransport.builder().withThreads(1).build()).withStorage(Storage.builder().withStorageLevel(StorageLevel.MEMORY).withDirectory(TEST_DIR + "/" + address.port()).build()).withStateMachine(ResourceManagerState::new).withSerializer(serializer.clone()).withHeartbeatInterval(Duration.ofMillis(25)).withElectionTimeout(Duration.ofMillis(50)).withSessionTimeout(Duration.ofMillis(100)).build();
    copycatServers.add(server);
    return server;
}
#method_after
protected CopycatServer createCopycatServer(Address address) {
    CopycatServer server = CopycatServer.builder(address).withTransport(NettyTransport.builder().withThreads(1).build()).withStorage(Storage.builder().withStorageLevel(StorageLevel.MEMORY).build()).withStateMachine(ResourceManagerState::new).withSerializer(serializer.clone()).withHeartbeatInterval(Duration.ofMillis(25)).withElectionTimeout(Duration.ofMillis(50)).withSessionTimeout(Duration.ofMillis(100)).build();
    copycatServers.add(server);
    return server;
}
#end_block

#method_before
private EventSubscriber parseSubscriptionData(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode node = (ObjectNode) mapper.readTree(input);
    EventSubscriber codec = codec(EventSubscriber.class).decode(node, this);
    checkNotNull(codec, JSON_NOT_NULL);
    return codec;
}
#method_after
private EventSubscriber parseSubscriptionData(InputStream input) throws IOException {
    ObjectMapper mapper = new ObjectMapper();
    ObjectNode node = (ObjectNode) mapper.readTree(input);
    checkNotNull(node, JSON_NOT_NULL);
    EventSubscriber codec = codec(EventSubscriber.class).decode(node, this);
    checkNotNull(codec, JSON_NOT_NULL);
    return codec;
}
#end_block

#method_before
@Override
public EventSubscriber decode(ObjectNode json, CodecContext context) {
    if (json == null || !json.isObject()) {
        return null;
    }
    EventSubscriber.Builder resultBuilder = new DefaultEventSubscriber.Builder();
    String appName = nullIsIllegal(json.get(NAME), NAME + MEMBER_CANNOT_BE_NULL).asText();
    resultBuilder.setAppName(appName);
    /*
        JsonNode appName = json.get(NAME);
        checkNotNull(appName, NAME + MEMBER_CANNOT_BE_NULL);
        resultBuilder.setAppName(appName.asText());

        JsonNode subscriberGroupId = json.get(GROUP_ID);
        checkNotNull(subscriberGroupId, GROUP_ID + MEMBER_CANNOT_BE_NULL);
        resultBuilder.setSubscriberGroupId(new EventSubscriberGroupId(UUID.fromString(subscriberGroupId.asText())));

        JsonNode eventType = json.get(EVENT_TYPE);
        checkNotNull(eventType, EVENT_TYPE + MEMBER_CANNOT_BE_NULL);
        resultBuilder.setEventType(Type.valueOf(eventType.asText()));
        */
    String subscriberGroupId = nullIsIllegal(json.get(GROUP_ID), GROUP_ID + MEMBER_CANNOT_BE_NULL).asText();
    resultBuilder.setSubscriberGroupId(new EventSubscriberGroupId(UUID.fromString(subscriberGroupId)));
    String eventType = nullIsIllegal(json.get(EVENT_TYPE), EVENT_TYPE + MEMBER_CANNOT_BE_NULL).asText();
    resultBuilder.setEventType(Type.valueOf(eventType));
    return resultBuilder.build();
}
#method_after
@Override
public EventSubscriber decode(ObjectNode json, CodecContext context) {
    EventSubscriber.Builder resultBuilder = new DefaultEventSubscriber.Builder();
    String appName = json.get(NAME).asText();
    resultBuilder.setAppName(appName);
    String subscriberGroupId = json.get(GROUP_ID).asText();
    resultBuilder.setSubscriberGroupId(new EventSubscriberGroupId(UUID.fromString(subscriberGroupId)));
    String eventType = json.get(EVENT_TYPE).asText();
    resultBuilder.setEventType(Type.valueOf(eventType));
    return resultBuilder.build();
}
#end_block

#method_before
@Override
public V get(K key) {
    checkState(txContext.isOpen(), TX_CLOSED_ERROR);
    checkNotNull(key, ERROR_NULL_KEY);
    if (deleteSet.contains(key)) {
        return null;
    }
    V latest = writeCache.get(key);
    if (latest != null) {
        return latest;
    } else {
        Versioned<V> v = readCache.computeIfAbsent(key, k -> backingConsitentMap.get(k));
        return v != null ? v.value() : null;
    }
}
#method_after
@Override
public V get(K key) {
    checkState(txContext.isOpen(), TX_CLOSED_ERROR);
    checkNotNull(key, ERROR_NULL_KEY);
    if (deleteSet.contains(key)) {
        return null;
    }
    V latest = writeCache.get(key);
    if (latest != null) {
        return latest;
    } else {
        Versioned<V> v = readCache.computeIfAbsent(key, k -> backingConsistentMap.get(k));
        return v != null ? v.value() : null;
    }
}
#end_block

#method_before
@Override
public boolean containsKey(K key) {
    checkState(txContext.isOpen(), TX_CLOSED_ERROR);
    checkNotNull(key, ERROR_NULL_KEY);
    if (deleteSet.contains(key)) {
        return false;
    }
    if (writeCache.containsKey(key)) {
        return true;
    }
    if (readCache.containsKey(key)) {
        return true;
    }
    return backingConsitentMap.containsKey(key);
}
#method_after
@Override
public boolean containsKey(K key) {
    return get(key) != null;
}
#end_block

#method_before
@Deprecated
@Override
public void addBridge(BridgeName bridgeName, String dpid, String exPortName) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    BridgeDescription bridgeDesc = DefaultBridgeDescription.builder().name(bridgeName.name()).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().enableLocalController().build();
    clientService.createBridge(bridgeDesc);
    clientService.createPort(bridgeName.name(), exPortName);
}
#method_after
@Deprecated
@Override
public void addBridge(BridgeName bridgeName, String dpid, String exPortName) {
    BridgeDescription bridgeDesc = DefaultBridgeDescription.builder().name(bridgeName.name()).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().enableLocalController().build();
    addBridge(bridgeDesc);
    OvsdbClientService client = getOvsdbClientService(handler());
    client.createPort(bridgeName.name(), exPortName);
}
#end_block

#method_before
@Override
public boolean addBridge(BridgeDescription bridgeDescription) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    return clientService.createBridge(bridgeDescription);
}
#method_after
@Override
public boolean addBridge(BridgeDescription bridgeDesc) {
    OvsdbClientService client = getOvsdbClientService(handler());
    OvsdbBridge.Builder bridgeBuilder = OvsdbBridge.builder(bridgeDesc);
    if (bridgeDesc.enableLocalController()) {
        bridgeBuilder.controller(client.localController());
    }
    return client.createBridge(bridgeBuilder.build());
}
#end_block

#method_before
@Override
public void deleteBridge(BridgeName bridgeName) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    clientService.dropBridge(bridgeName.name());
}
#method_after
@Override
public void deleteBridge(BridgeName bridgeName) {
    OvsdbClientService client = getOvsdbClientService(handler());
    client.dropBridge(bridgeName.name());
}
#end_block

#method_before
@Override
public Collection<BridgeDescription> getBridges() {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbBridge> bridges = clientService.getBridges();
    return bridges.stream().map(bridge -> DefaultBridgeDescription.builder().name(bridge.bridgeName().value()).datapathId(bridge.datapathId().id()).build()).collect(Collectors.toSet());
}
#method_after
@Override
public Collection<BridgeDescription> getBridges() {
    OvsdbClientService client = getOvsdbClientService(handler());
    Set<OvsdbBridge> bridges = client.getBridges();
    return bridges.stream().map(bridge -> DefaultBridgeDescription.builder().name(bridge.name()).datapathId(bridge.datapathId().get()).build()).collect(Collectors.toSet());
}
#end_block

#method_before
@Deprecated
@Override
public void addPort(PortDescription port) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbBridge> ovsdbSet = clientService.getBridges();
    if (ovsdbSet != null && ovsdbSet.size() > 0) {
        OvsdbBridge bridge = ovsdbSet.iterator().next();
        clientService.createPort(bridge.bridgeName().value(), port.portNumber().toString());
    }
}
#method_after
@Deprecated
@Override
public void addPort(PortDescription port) {
    OvsdbClientService client = getOvsdbClientService(handler());
    Set<OvsdbBridge> ovsdbSet = client.getBridges();
    if (ovsdbSet != null && ovsdbSet.size() > 0) {
        OvsdbBridge bridge = ovsdbSet.iterator().next();
        client.createPort(bridge.name(), port.portNumber().toString());
    }
}
#end_block

#method_before
@Override
public void addPort(BridgeName bridgeName, String portName) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    clientService.createPort(bridgeName.name(), portName);
}
#method_after
@Override
public void addPort(BridgeName bridgeName, String portName) {
    OvsdbClientService client = getOvsdbClientService(handler());
    client.createPort(bridgeName.name(), portName);
}
#end_block

#method_before
@Deprecated
@Override
public void deletePort(PortDescription port) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbBridge> ovsdbSet = clientService.getBridges();
    if (ovsdbSet != null && ovsdbSet.size() > 0) {
        OvsdbBridge bridge = ovsdbSet.iterator().next();
        clientService.dropPort(bridge.bridgeName().value(), port.portNumber().toString());
    }
}
#method_after
@Deprecated
@Override
public void deletePort(PortDescription port) {
    OvsdbClientService client = getOvsdbClientService(handler());
    Set<OvsdbBridge> ovsdbSet = client.getBridges();
    if (ovsdbSet != null && ovsdbSet.size() > 0) {
        OvsdbBridge bridge = ovsdbSet.iterator().next();
        client.dropPort(bridge.name(), port.portNumber().toString());
    }
}
#end_block

#method_before
@Override
public void deletePort(BridgeName bridgeName, String portName) {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    clientService.dropPort(bridgeName.name(), portName);
}
#method_after
@Override
public void deletePort(BridgeName bridgeName, String portName) {
    OvsdbClientService client = getOvsdbClientService(handler());
    client.dropPort(bridgeName.name(), portName);
}
#end_block

#method_before
@Override
public Collection<PortDescription> getPorts() {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbPort> ports = clientService.getPorts();
    return ports.stream().map(x -> new DefaultPortDescription(PortNumber.portNumber(x.portNumber().value()), true, DefaultAnnotations.builder().set("portName", x.portName().value()).build())).collect(Collectors.toSet());
}
#method_after
@Override
public Collection<PortDescription> getPorts() {
    OvsdbClientService client = getOvsdbClientService(handler());
    Set<OvsdbPort> ports = client.getPorts();
    return ports.stream().map(x -> new DefaultPortDescription(PortNumber.portNumber(x.portNumber().value()), true, DefaultAnnotations.builder().set("portName", x.portName().value()).build())).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public Set<PortNumber> getPortNumbers() {
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbPort> ports = clientService.getPorts();
    return ports.stream().map(x -> PortNumber.portNumber(x.portNumber().value(), x.portName().value())).collect(Collectors.toSet());
}
#method_after
@Override
public Set<PortNumber> getPortNumbers() {
    DriverHandler handler = handler();
    OvsdbClientService client = getOvsdbClientService(handler);
    Set<OvsdbPort> ports = client.getPorts();
    return ports.stream().map(x -> PortNumber.portNumber(x.portNumber().value(), x.portName().value())).collect(Collectors.toSet());
}
#end_block

#method_before
@Override
public List<PortNumber> getLocalPorts(Iterable<String> ifaceIds) {
    List<PortNumber> ports = new ArrayList<>();
    DriverHandler handler = handler();
    OvsdbClientService clientService = getOvsdbClientService(handler);
    Set<OvsdbPort> ovsdbSet = clientService.getLocalPorts(ifaceIds);
    ovsdbSet.forEach(o -> {
        PortNumber port = PortNumber.portNumber(o.portNumber().value(), o.portName().value());
        ports.add(port);
    });
    return ports;
}
#method_after
@Override
public List<PortNumber> getLocalPorts(Iterable<String> ifaceIds) {
    List<PortNumber> ports = new ArrayList<>();
    DriverHandler handler = handler();
    OvsdbClientService client = getOvsdbClientService(handler);
    Set<OvsdbPort> ovsdbSet = client.getLocalPorts(ifaceIds);
    ovsdbSet.forEach(o -> {
        PortNumber port = PortNumber.portNumber(o.portNumber().value(), o.portName().value());
        ports.add(port);
    });
    return ports;
}
#end_block

#method_before
@Deprecated
@Override
public void createBridge(String bridgeName) {
    BridgeDescription bridgeDesc = DefaultBridgeDescription.builder().name(bridgeName).build();
    createBridge(bridgeDesc);
}
#method_after
@Deprecated
@Override
public void createBridge(String bridgeName) {
    OvsdbBridge ovsdbBridge = OvsdbBridge.builder().name(bridgeName).build();
    createBridge(ovsdbBridge);
}
#end_block

#method_before
@Deprecated
@Override
public void createBridge(String bridgeName, String dpid, String exPortName) {
    BridgeDescription bridgeDesc = DefaultBridgeDescription.builder().name(bridgeName).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().enableLocalController().build();
    createBridge(bridgeDesc);
    if (exPortName != null) {
        createPort(bridgeName, exPortName);
    }
}
#method_after
@Deprecated
@Override
public void createBridge(String bridgeName, String dpid, String exPortName) {
    OvsdbBridge ovsdbBridge = OvsdbBridge.builder().name(bridgeName).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().controllers(Lists.newArrayList(localController())).build();
    createBridge(ovsdbBridge);
    if (exPortName != null) {
        createPort(bridgeName, exPortName);
    }
}
#end_block

#method_before
@Deprecated
@Override
public boolean createBridge(String bridgeName, String dpid, List<ControllerInfo> controllers) {
    BridgeDescription bridgeDesc = DefaultBridgeDescription.builder().name(bridgeName).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().controllers(controllers).build();
    return createBridge(bridgeDesc);
}
#method_after
@Deprecated
@Override
public boolean createBridge(String bridgeName, String dpid, List<ControllerInfo> controllers) {
    OvsdbBridge ovsdbBridge = OvsdbBridge.builder().name(bridgeName).failMode(BridgeDescription.FailMode.SECURE).datapathId(dpid).disableInBand().controllers(controllers).build();
    return createBridge(ovsdbBridge);
}
#end_block

#method_before
@Override
public boolean createBridge(BridgeDescription bridgeDesc) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    String ovsUuid = getOvsUuid(DATABASENAME);
    if (dbSchema == null || ovsUuid == null) {
        log.error("Can't find database Open_vSwitch");
        return false;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    if (bridgeDesc.failMode().isPresent()) {
        // STANDALONE is configured by default if the fail mode is not set
        String failMode = bridgeDesc.failMode().get().name().toLowerCase();
        bridge.setFailMode(Sets.newHashSet(failMode));
    }
    Map<String, String> otherConfigs = Maps.newHashMap();
    if (bridgeDesc.datapathId().isPresent()) {
        otherConfigs.put(DATAPATH_ID, bridgeDesc.datapathId().get());
    }
    if (bridgeDesc.disableInBand().isPresent()) {
        otherConfigs.put(DISABLE_INBAND, bridgeDesc.disableInBand().get().toString());
    }
    // add more other configs here
    bridge.setOtherConfig(otherConfigs);
    String bridgeUuid = getBridgeUuid(bridgeDesc.name());
    if (bridgeUuid != null) {
        // update the bridge if it's already existing
        updateConfig(BRIDGE, UUID, bridgeUuid, bridge.getRow());
    } else {
        bridge.setName(bridgeDesc.name());
        bridgeUuid = insertConfig(BRIDGE, UUID, DATABASENAME, BRIDGES, ovsUuid, bridge.getRow());
    }
    if (bridgeUuid == null) {
        log.warn("Failed to create bridge {} on {}", bridgeDesc.name(), nodeId);
        return false;
    }
    createPort(bridgeDesc.name(), bridgeDesc.name());
    if (bridgeDesc.controllers().isEmpty() && bridgeDesc.enableLocalController()) {
        setControllersWithUuid(Uuid.uuid(bridgeUuid), Lists.newArrayList(localController()));
    } else {
        setControllersWithUuid(Uuid.uuid(bridgeUuid), bridgeDesc.controllers());
    }
    log.info("Created bridge {}", bridgeDesc.name());
    return true;
}
#method_after
@Override
public boolean createBridge(OvsdbBridge ovsdbBridge) {
    DatabaseSchema dbSchema = schema.get(DATABASENAME);
    String ovsUuid = getOvsUuid(DATABASENAME);
    if (dbSchema == null || ovsUuid == null) {
        log.error("Can't find database Open_vSwitch");
        return false;
    }
    Bridge bridge = (Bridge) TableGenerator.createTable(dbSchema, OvsdbTable.BRIDGE);
    bridge.setOtherConfig(ovsdbBridge.otherConfigs());
    if (ovsdbBridge.failMode().isPresent()) {
        String failMode = ovsdbBridge.failMode().get().name().toLowerCase();
        bridge.setFailMode(Sets.newHashSet(failMode));
    }
    String bridgeUuid = getBridgeUuid(ovsdbBridge.name());
    if (bridgeUuid == null) {
        bridge.setName(ovsdbBridge.name());
        bridgeUuid = insertConfig(BRIDGE, UUID, DATABASENAME, BRIDGES, ovsUuid, bridge.getRow());
    } else {
        // update the bridge if it's already existing
        updateConfig(BRIDGE, UUID, bridgeUuid, bridge.getRow());
    }
    if (bridgeUuid == null) {
        log.warn("Failed to create bridge {} on {}", ovsdbBridge.name(), nodeId);
        return false;
    }
    createPort(ovsdbBridge.name(), ovsdbBridge.name());
    setControllersWithUuid(Uuid.uuid(bridgeUuid), ovsdbBridge.controllers());
    log.info("Created bridge {}", ovsdbBridge.name());
    return true;
}
#end_block

#method_before
private ControllerInfo localController() {
    IpAddress ipAddress = IpAddress.valueOf(((InetSocketAddress) channel.localAddress()).getAddress());
    return new ControllerInfo(ipAddress, OFPORT, "tcp");
}
#method_after
@Override
public ControllerInfo localController() {
    IpAddress ipAddress = IpAddress.valueOf(((InetSocketAddress) channel.localAddress()).getAddress());
    return new ControllerInfo(ipAddress, OFPORT, "tcp");
}
#end_block

#method_before
private OvsdbBridge getOvsdbBridge(Row row) {
    DatabaseSchema dbSchema = getDatabaseSchema(DATABASENAME);
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, row, OvsdbTable.BRIDGE);
    if (bridge == null) {
        return null;
    }
    OvsdbSet datapathIdSet = (OvsdbSet) bridge.getDatapathIdColumn().data();
    @SuppressWarnings("unchecked")
    Set<String> datapathIds = datapathIdSet.set();
    if (datapathIds == null || datapathIds.size() == 0) {
        return null;
    }
    String datapathId = (String) datapathIds.toArray()[0];
    String bridgeName = bridge.getName();
    if ((datapathId == null) || (bridgeName == null)) {
        return null;
    }
    return new OvsdbBridge(new OvsdbBridgeName(bridgeName), new OvsdbDatapathId(datapathId));
}
#method_after
private OvsdbBridge getOvsdbBridge(Row row) {
    DatabaseSchema dbSchema = getDatabaseSchema(DATABASENAME);
    Bridge bridge = (Bridge) TableGenerator.getTable(dbSchema, row, OvsdbTable.BRIDGE);
    if (bridge == null) {
        return null;
    }
    OvsdbSet datapathIdSet = (OvsdbSet) bridge.getDatapathIdColumn().data();
    @SuppressWarnings("unchecked")
    Set<String> datapathIds = datapathIdSet.set();
    if (datapathIds == null || datapathIds.size() == 0) {
        return null;
    }
    String datapathId = (String) datapathIds.toArray()[0];
    String bridgeName = bridge.getName();
    if ((datapathId == null) || (bridgeName == null)) {
        return null;
    }
    return OvsdbBridge.builder().name(bridgeName).datapathId(datapathId).build();
}
#end_block

#method_before
@Override
public void createBridge(String bridgeName, String dpid, String exPortName) {
}
#method_after
@Override
public boolean createBridge(OvsdbBridge ovsdbBridge) {
    return true;
}
#end_block

#method_before
public static Builder builder() {
    return new Builder();
}
#method_after
public static BridgeDescription.Builder builder() {
    return new Builder();
}
#end_block

#method_before
public DefaultBridgeDescription build() {
    return new DefaultBridgeDescription(name, controllers, enableLocalController, failMode, datapathId, disableInBand);
}
#method_after
@Override
public BridgeDescription build() {
    return new DefaultBridgeDescription(name, controllers, enableLocalController, failMode, datapathId, disableInBand);
}
#end_block

#method_before
public Builder name(String name) {
    checkArgument(!Strings.isNullOrEmpty(name));
    this.name = name;
    return this;
}
#method_after
@Override
public Builder name(String name) {
    checkArgument(!Strings.isNullOrEmpty(name));
    this.name = name;
    return this;
}
#end_block

#method_before
public Builder controllers(List<ControllerInfo> controllers) {
    checkNotNull(controllers);
    this.controllers = controllers;
    return this;
}
#method_after
@Override
public Builder controllers(List<ControllerInfo> controllers) {
    if (controllers != null) {
        this.controllers = Lists.newArrayList(controllers);
    }
    return this;
}
#end_block

#method_before
public Builder enableLocalController() {
    this.enableLocalController = true;
    return this;
}
#method_after
@Override
public Builder enableLocalController() {
    this.enableLocalController = true;
    return this;
}
#end_block

#method_before
public Builder failMode(FailMode failMode) {
    this.failMode = Optional.of(failMode);
    return this;
}
#method_after
@Override
public Builder failMode(FailMode failMode) {
    this.failMode = Optional.ofNullable(failMode);
    return this;
}
#end_block

#method_before
public Builder datapathId(String datapathId) {
    checkArgument(!Strings.isNullOrEmpty(datapathId));
    this.datapathId = Optional.of(datapathId);
    return this;
}
#method_after
@Override
public Builder datapathId(String datapathId) {
    this.datapathId = Optional.ofNullable(datapathId);
    return this;
}
#end_block

#method_before
public Builder disableInBand() {
    this.disableInBand = Optional.of(Boolean.TRUE);
    return this;
}
#method_after
@Override
public Builder disableInBand() {
    this.disableInBand = Optional.of(Boolean.TRUE);
    return this;
}
#end_block

#method_before
@Override
public List<String> getNextMappings() {
    return null;
}
#method_after
@Override
public List<String> getNextMappings() {
    return ImmutableList.of();
}
#end_block

#method_before
@Override
public List<String> getPendingNexts() {
    return null;
}
#method_after
@Override
public List<String> getPendingNexts() {
    return ImmutableList.of();
}
#end_block

#method_before
@Override
protected void execute() {
    FlowObjectiveService service = get(FlowObjectiveService.class);
    printNexts(service.getNextMappings());
}
#method_after
@Override
protected void execute() {
    try {
        FlowObjectiveService service = get(FlowObjectiveService.class);
        printNexts(service.getNextMappings());
    } catch (ServiceNotFoundException e) {
        print(FORMAT_MAPPING, "FlowObjectiveService unavailable");
    }
}
#end_block

#method_before
@Override
protected void execute() {
    FlowObjectiveService service = get(FlowObjectiveService.class);
    printNexts(service.getPendingNexts());
}
#method_after
@Override
protected void execute() {
    try {
        FlowObjectiveService service = get(FlowObjectiveService.class);
        printNexts(service.getPendingNexts());
    } catch (ServiceNotFoundException e) {
        print(FORMAT_MAPPING, "FlowObjectiveService unavailable");
    }
}
#end_block

#method_before
@Override
public List<String> getNextMappings() {
    // TODO Implementation deferred as this is an experimental component.
    return null;
}
#method_after
@Override
public List<String> getNextMappings() {
    // TODO Implementation deferred as this is an experimental component.
    return ImmutableList.of();
}
#end_block

#method_before
@Override
public List<String> getPendingNexts() {
    // TODO Implementation deferred as this is an experimental component.
    return null;
}
#method_after
@Override
public List<String> getPendingNexts() {
    // TODO Implementation deferred as this is an experimental component.
    return ImmutableList.of();
}
#end_block

#method_before
@Override
public List<String> getNextMappings() {
    return null;
}
#method_after
@Override
public List<String> getNextMappings() {
    return ImmutableList.of();
}
#end_block

#method_before
@Override
public List<String> getPendingNexts() {
    return null;
}
#method_after
@Override
public List<String> getPendingNexts() {
    return ImmutableList.of();
}
#end_block

#method_before
private LinkInformation createLinkInformation(LsPdu lsPdu, String linkId, String localRouter, String neighborId) {
    LinkInformation linkInformation = new DefaultIsisLinkInformation();
    IsisRouter isisRouter = isisRouterDetails.get(neighborId);
    for (IsisTlv isisTlv : lsPdu.tlvs()) {
        if (isisTlv instanceof IpExtendedReachabilityTlv) {
            IpExtendedReachabilityTlv ipExtendedReachabilityTlv = (IpExtendedReachabilityTlv) isisTlv;
            List<TrafficEngineeringSubTlv> trafEnginSubTlv = ipExtendedReachabilityTlv.teTlvs();
            for (TrafficEngineeringSubTlv teTlv : trafEnginSubTlv) {
                if (teTlv instanceof InterfaceIpAddress) {
                    InterfaceIpAddress localIpAddress = (InterfaceIpAddress) isisTlv;
                    linkInformation.setInterfaceIp(localIpAddress.localInterfaceIPAddress());
                }
            }
        } else {
            linkInformation.setInterfaceIp(IsisConstants.DEFAULTIP);
            linkInformation.setNeighborIp(IsisConstants.DEFAULTIP);
        }
    }
    linkInformation.setNeighborIp(IsisConstants.DEFAULTIP);
    linkInformation.setLinkId(linkId);
    linkInformation.setAlreadyCreated(false);
    linkInformation.setLinkDestinationId(neighborId);
    linkInformation.setLinkSourceId(localRouter);
    return linkInformation;
}
#method_after
private LinkInformation createLinkInformation(LsPdu lsPdu, String linkId, String localRouter, String neighborId) {
    LinkInformation linkInformation = new DefaultIsisLinkInformation();
    IsisRouter isisRouter = isisRouterDetails.get(neighborId);
    for (IsisTlv isisTlv : lsPdu.tlvs()) {
        if (isisTlv instanceof IsExtendedReachability) {
            IsExtendedReachability isExtendedReachability = (IsExtendedReachability) isisTlv;
            List<NeighborForExtendedIs> neighbours = isExtendedReachability.neighbours();
            for (NeighborForExtendedIs teTlv : neighbours) {
                List<TrafficEngineeringSubTlv> teSubTlvs = teTlv.teSubTlv();
                for (TrafficEngineeringSubTlv teSubTlv : teSubTlvs) {
                    if (teSubTlv instanceof InterfaceIpAddress) {
                        InterfaceIpAddress localIpAddress = (InterfaceIpAddress) teSubTlv;
                        linkInformation.setInterfaceIp(localIpAddress.localInterfaceIPAddress());
                    } else if (teSubTlv instanceof NeighborIpAddress) {
                        NeighborIpAddress neighborIpAddress = (NeighborIpAddress) teSubTlv;
                        linkInformation.setNeighborIp(neighborIpAddress.neighborIPAddress());
                    }
                }
            }
        }
    }
    linkInformation.setLinkId(linkId);
    linkInformation.setAlreadyCreated(false);
    linkInformation.setLinkDestinationId(neighborId);
    linkInformation.setLinkSourceId(localRouter);
    return linkInformation;
}
#end_block

#method_before
private IsisRouter createIsisRouter(LsPdu lsPdu) {
    IsisRouter isisRouter = new DefaultIsisRouter();
    if (IsisUtil.checkIsDis(lsPdu.lspId())) {
        isisRouter.setDis(true);
    } else {
        isisRouter.setDis(false);
    }
    isisRouter.setSystemId(IsisUtil.removeTailingZeros(lsPdu.lspId()));
    for (IsisTlv isisTlv : lsPdu.tlvs()) {
        if (isisTlv instanceof IpExtendedReachabilityTlv) {
            IpExtendedReachabilityTlv ipExtendedReachabilityTlv = (IpExtendedReachabilityTlv) isisTlv;
            List<TrafficEngineeringSubTlv> trafEnginSubTlv = ipExtendedReachabilityTlv.teTlvs();
            for (TrafficEngineeringSubTlv teTlv : trafEnginSubTlv) {
                if (teTlv instanceof InterfaceIpAddress) {
                    InterfaceIpAddress localIpAddress = (InterfaceIpAddress) isisTlv;
                    isisRouter.setInterfaceId(localIpAddress.localInterfaceIPAddress());
                }
                if (teTlv instanceof NeighborIpAddress) {
                    NeighborIpAddress neighborIpAddress = (NeighborIpAddress) isisTlv;
                    isisRouter.setNeighborRouterId(neighborIpAddress.neighborIPAddress());
                }
            }
        } else {
            log.info("Invalid TLV");
        }
    }
    return isisRouter;
}
#method_after
private IsisRouter createIsisRouter(LsPdu lsPdu) {
    IsisRouter isisRouter = new DefaultIsisRouter();
    if (IsisUtil.checkIsDis(lsPdu.lspId())) {
        isisRouter.setDis(true);
    } else {
        isisRouter.setDis(false);
    }
    isisRouter.setSystemId(IsisUtil.removeTailingZeros(lsPdu.lspId()));
    for (IsisTlv isisTlv : lsPdu.tlvs()) {
        if (isisTlv instanceof IsExtendedReachability) {
            IsExtendedReachability isExtendedReachability = (IsExtendedReachability) isisTlv;
            List<NeighborForExtendedIs> neighbours = isExtendedReachability.neighbours();
            for (NeighborForExtendedIs teTlv : neighbours) {
                List<TrafficEngineeringSubTlv> teSubTlvs = teTlv.teSubTlv();
                for (TrafficEngineeringSubTlv teSubTlv : teSubTlvs) {
                    if (teSubTlv instanceof InterfaceIpAddress) {
                        InterfaceIpAddress localIpAddress = (InterfaceIpAddress) teSubTlv;
                        isisRouter.setInterfaceId(localIpAddress.localInterfaceIPAddress());
                    } else if (teSubTlv instanceof NeighborIpAddress) {
                        NeighborIpAddress neighborIpAddress = (NeighborIpAddress) teSubTlv;
                        isisRouter.setNeighborRouterId(neighborIpAddress.neighborIPAddress());
                    }
                }
            }
        }
    }
    return isisRouter;
}
#end_block

#method_before
public IsisLinkTed createIsisLinkTedInfo(LsPdu lsPdu) {
    IsisLinkTed isisLinkTed = new DefaultIsisLinkTed();
    for (IsisTlv isisTlv : lsPdu.tlvs()) {
        if (isisTlv instanceof IpExtendedReachabilityTlv) {
            IpExtendedReachabilityTlv ipExtendedReachabilityTlv = (IpExtendedReachabilityTlv) isisTlv;
            List<TrafficEngineeringSubTlv> trafficEngSubTlv = ipExtendedReachabilityTlv.teTlvs();
            for (TrafficEngineeringSubTlv teTlv : trafficEngSubTlv) {
                if (teTlv instanceof AdministrativeGroup) {
                    AdministrativeGroup ag = (AdministrativeGroup) isisTlv;
                    isisLinkTed.setAdministrativeGroup(ag.administrativeGroup());
                }
                if (teTlv instanceof TrafficEngineeringMetric) {
                    TrafficEngineeringMetric teM = (TrafficEngineeringMetric) isisTlv;
                    isisLinkTed.setTeDefaultMetric(teM.getTrafficEngineeringMetricValue());
                }
                if (teTlv instanceof MaximumReservableBandwidth) {
                    MaximumReservableBandwidth reservableBw = (MaximumReservableBandwidth) isisTlv;
                    isisLinkTed.setMaximumReservableLinkBandwidth(Bandwidth.bps(reservableBw.getMaximumBandwidthValue()));
                }
            }
        } else {
            log.debug("TLV type not supported");
        }
    }
    return isisLinkTed;
}
#method_after
public IsisLinkTed createIsisLinkTedInfo(LsPdu lsPdu) {
    IsisLinkTed isisLinkTed = new DefaultIsisLinkTed();
    for (IsisTlv isisTlv : lsPdu.tlvs()) {
        if (isisTlv instanceof IsExtendedReachability) {
            IsExtendedReachability isExtendedReachability = (IsExtendedReachability) isisTlv;
            List<NeighborForExtendedIs> neighbours = isExtendedReachability.neighbours();
            for (NeighborForExtendedIs teTlv : neighbours) {
                List<TrafficEngineeringSubTlv> teSubTlvs = teTlv.teSubTlv();
                for (TrafficEngineeringSubTlv teSubTlv : teSubTlvs) {
                    if (teSubTlv instanceof AdministrativeGroup) {
                        AdministrativeGroup ag = (AdministrativeGroup) teSubTlv;
                        isisLinkTed.setAdministrativeGroup(ag.administrativeGroup());
                    }
                    if (teSubTlv instanceof InterfaceIpAddress) {
                        InterfaceIpAddress localIpAddress = (InterfaceIpAddress) teSubTlv;
                        isisLinkTed.setIpv4InterfaceAddress(localIpAddress.localInterfaceIPAddress());
                    }
                    if (teSubTlv instanceof NeighborIpAddress) {
                        NeighborIpAddress neighborIpAddress = (NeighborIpAddress) teSubTlv;
                        isisLinkTed.setIpv4NeighborAddress(neighborIpAddress.neighborIPAddress());
                    }
                    if (teSubTlv instanceof TrafficEngineeringMetric) {
                        TrafficEngineeringMetric teM = (TrafficEngineeringMetric) teSubTlv;
                        isisLinkTed.setTeDefaultMetric(teM.getTrafficEngineeringMetricValue());
                    }
                    if (teSubTlv instanceof MaximumBandwidth) {
                        MaximumBandwidth maxLinkBandwidth = (MaximumBandwidth) teSubTlv;
                        isisLinkTed.setMaximumLinkBandwidth(Bandwidth.bps(maxLinkBandwidth.getMaximumBandwidthValue()));
                    }
                    if (teSubTlv instanceof MaximumReservableBandwidth) {
                        MaximumReservableBandwidth maxReservableBw = (MaximumReservableBandwidth) teSubTlv;
                        isisLinkTed.setMaximumReservableLinkBandwidth(Bandwidth.bps(maxReservableBw.getMaximumBandwidthValue()));
                    }
                    if (teSubTlv instanceof UnreservedBandwidth) {
                        UnreservedBandwidth unReservedBandwidth = (UnreservedBandwidth) teSubTlv;
                        List<Bandwidth> bandwidthList = new ArrayList<>();
                        List<Float> unReservedBandwidthList = unReservedBandwidth.unReservedBandwidthValue();
                        for (Float unReservedBandwidthFloatValue : unReservedBandwidthList) {
                            Bandwidth bandwidth = Bandwidth.bps(unReservedBandwidthFloatValue);
                            bandwidthList.add(bandwidth);
                        }
                        isisLinkTed.setUnreservedBandwidth(bandwidthList);
                    }
                }
            }
        }
    }
    return isisLinkTed;
}
#end_block

#method_before
private LinkDescription buildLinkDes(IsisLink isisLink) {
    long srcAddress = 0;
    long dstAddress = 0;
    boolean localPseduo = false;
    boolean remotePseduo = false;
    String localSystemId = isisLink.localSystemId();
    String remoteSystemId = isisLink.remoteSystemId();
    // Changing of port numbers
    srcAddress = isisLink.interfaceIp().toInt();
    dstAddress = isisLink.neighborIp().toInt();
    DeviceId srcId = DeviceId.deviceId(IsisRouterId.uri(localSystemId));
    DeviceId dstId = DeviceId.deviceId(IsisRouterId.uri(remoteSystemId));
    if (localPseduo && srcAddress == 0) {
        srcAddress = PSEUDO_PORT;
    } else if (remotePseduo && dstAddress == 0) {
        dstAddress = PSEUDO_PORT;
    }
    ConnectPoint src = new ConnectPoint(srcId, PortNumber.portNumber(srcAddress));
    ConnectPoint dst = new ConnectPoint(dstId, PortNumber.portNumber(dstAddress));
    DefaultAnnotations.Builder annotationBuilder = DefaultAnnotations.builder();
    if (isisLink != null) {
        annotationBuilder = buildAnnotations(annotationBuilder, isisLink);
    }
    return new DefaultLinkDescription(src, dst, Link.Type.DIRECT, false, annotationBuilder.build());
}
#method_after
private LinkDescription buildLinkDes(IsisLink isisLink) {
    long srcAddress = 0;
    long dstAddress = 0;
    boolean localPseduo = false;
    boolean remotePseduo = false;
    String localSystemId = isisLink.localSystemId();
    String remoteSystemId = isisLink.remoteSystemId();
    // Changing of port numbers
    srcAddress = isisLink.interfaceIp().toInt();
    dstAddress = isisLink.neighborIp().toInt();
    DeviceId srcId = DeviceId.deviceId(IsisRouterId.uri(localSystemId));
    DeviceId dstId = DeviceId.deviceId(IsisRouterId.uri(remoteSystemId));
    if (checkIsDis(isisLink.localSystemId())) {
        localPseduo = true;
    } else if (checkIsDis(isisLink.remoteSystemId())) {
        remotePseduo = true;
    } else {
        log.debug("IsisDeviceProvider::buildLinkDes : unknown type.!");
    }
    if (localPseduo && srcAddress == 0) {
        srcAddress = PSEUDO_PORT;
    } else if (remotePseduo && dstAddress == 0) {
        dstAddress = PSEUDO_PORT;
    }
    ConnectPoint src = new ConnectPoint(srcId, PortNumber.portNumber(srcAddress));
    ConnectPoint dst = new ConnectPoint(dstId, PortNumber.portNumber(dstAddress));
    DefaultAnnotations.Builder annotationBuilder = DefaultAnnotations.builder();
    if (isisLink != null) {
        annotationBuilder = buildAnnotations(annotationBuilder, isisLink);
    }
    return new DefaultLinkDescription(src, dst, Link.Type.DIRECT, false, annotationBuilder.build());
}
#end_block

#method_before
private DefaultAnnotations.Builder buildAnnotations(DefaultAnnotations.Builder annotationBuilder, IsisLink isisLink) {
    int administrativeGroup = 0;
    long teMetric = 0;
    Bandwidth maxReservableBandwidth = Bandwidth.bps(0);
    String routerId = null;
    String neighborId = null;
    // TE Info
    IsisLinkTed isisLinkTed = isisLink.linkTed();
    administrativeGroup = isisLinkTed.administrativeGroup();
    teMetric = isisLinkTed.teDefaultMetric();
    maxReservableBandwidth = isisLinkTed.maximumReservableLinkBandwidth();
    routerId = isisLink.localSystemId();
    neighborId = isisLink.remoteSystemId();
    annotationBuilder.set(ADMINISTRATIVEGROUP, String.valueOf(administrativeGroup));
    annotationBuilder.set(TE_METRIC, String.valueOf(teMetric));
    annotationBuilder.set(MAXRESERVABLEBANDWIDTH, String.valueOf(maxReservableBandwidth));
    annotationBuilder.set(ROUTERID, String.valueOf(routerId));
    annotationBuilder.set(NEIGHBORID, String.valueOf(neighborId));
    return annotationBuilder;
}
#method_after
private DefaultAnnotations.Builder buildAnnotations(DefaultAnnotations.Builder annotationBuilder, IsisLink isisLink) {
    int administrativeGroup = 0;
    long teMetric = 0;
    Bandwidth maxReservableBandwidth = Bandwidth.bps(0);
    String routerId = null;
    String neighborId = null;
    // TE Info
    IsisLinkTed isisLinkTed = isisLink.linkTed();
    log.info("Ted Information:  {}", isisLinkTed.toString());
    administrativeGroup = isisLinkTed.administrativeGroup();
    teMetric = isisLinkTed.teDefaultMetric();
    maxReservableBandwidth = isisLinkTed.maximumReservableLinkBandwidth();
    routerId = isisLink.localSystemId();
    neighborId = isisLink.remoteSystemId();
    annotationBuilder.set(ADMINISTRATIVEGROUP, String.valueOf(administrativeGroup));
    annotationBuilder.set(TE_METRIC, String.valueOf(teMetric));
    annotationBuilder.set(MAXRESERVABLEBANDWIDTH, String.valueOf(maxReservableBandwidth));
    annotationBuilder.set(ROUTERID, String.valueOf(routerId));
    annotationBuilder.set(NEIGHBORID, String.valueOf(neighborId));
    return annotationBuilder;
}
#end_block

#method_before
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    // To get new tunnel ID (modified tunnel ID)
    Collection<Tunnel> tunnels = tunnelService.queryTunnel(tunnel.src(), tunnel.dst());
    for (Tunnel t : tunnels) {
        if (t.state().equals(INIT) && t.tunnelName().equals(tunnel.tunnelName())) {
            tunnel = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), t.state(), tunnel.groupId(), t.tunnelId(), tunnel.tunnelName(), tunnel.path(), tunnel.resource(), tunnel.annotations());
        }
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    // If delegation flag is set then only send update message[means delegated PCE can send update msg for that
    // LSP].If annotation is null D flag is not set else it is set.
    Short localLspId = 0;
    for (Tunnel t : tunnels) {
        if (!t.tunnelId().equals(tunnel.tunnelId()) && t.tunnelName().equals(tunnel.tunnelName())) {
            localLspId = Short.valueOf(t.annotations().value(LOCAL_LSP_ID));
        }
    }
    if (localLspId == 0) {
        log.error("Local LSP ID for old tunnel not found");
        return;
    }
    // PCInitiate tunnels are always have D flag set, else check for tunnels who are delegated via LspKey
    if (pc.capability().statefulPceCapability()) {
        if (tunnel.annotations().value(PCE_INIT) != null && tunnel.annotations().value(PCE_INIT).equals("true")) {
            pcepUpdateTunnel(tunnel, path, pc);
        } else if (pc.delegationInfo(new LspKey(Integer.valueOf(tunnel.annotations().value(PLSP_ID)), localLspId.shortValue())) != null) {
            pcepUpdateTunnel(tunnel, path, pc);
        }
    }
}
#method_after
@Override
public void updateTunnel(Tunnel tunnel, Path path) {
    if (tunnel.type() != MPLS) {
        log.error("Tunnel Type MPLS is only supported");
        return;
    }
    // check for tunnel end points
    if (!(tunnel.src() instanceof IpTunnelEndPoint) || !(tunnel.dst() instanceof IpTunnelEndPoint)) {
        log.error("Tunnel source or destination is not valid");
        return;
    }
    // To get new tunnel ID (modified tunnel ID)
    Collection<Tunnel> tunnels = tunnelService.queryTunnel(tunnel.src(), tunnel.dst());
    for (Tunnel t : tunnels) {
        if (t.state().equals(INIT) && t.tunnelName().equals(tunnel.tunnelName())) {
            tunnel = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), t.state(), tunnel.groupId(), t.tunnelId(), tunnel.tunnelName(), tunnel.path(), tunnel.resource(), tunnel.annotations());
            break;
        }
    }
    PcepClient pc = pcepClientController.getClient(PccId.pccId(((IpTunnelEndPoint) tunnel.src()).ip()));
    if (!(pc instanceof PcepClient)) {
        log.error("There is no PCC connected with ip addresss {}" + ((IpTunnelEndPoint) tunnel.src()).ip().toString());
        return;
    }
    // If delegation flag is set then only send update message[means delegated PCE can send update msg for that
    // LSP].If annotation is null D flag is not set else it is set.
    Short localLspId = 0;
    for (Tunnel t : tunnels) {
        if (!t.tunnelId().equals(tunnel.tunnelId()) && t.tunnelName().equals(tunnel.tunnelName())) {
            localLspId = Short.valueOf(t.annotations().value(LOCAL_LSP_ID));
        }
    }
    if (localLspId == 0) {
        log.error("Local LSP ID for old tunnel not found");
        return;
    }
    // PCInitiate tunnels are always have D flag set, else check for tunnels who are delegated via LspKey
    if (pc.capability().statefulPceCapability()) {
        if (tunnel.annotations().value(PCE_INIT) != null && tunnel.annotations().value(PCE_INIT).equals("true")) {
            pcepUpdateTunnel(tunnel, path, pc);
        } else if (pc.delegationInfo(new LspKey(Integer.valueOf(tunnel.annotations().value(PLSP_ID)), localLspId.shortValue())) != null) {
            pcepUpdateTunnel(tunnel, path, pc);
        }
    }
}
#end_block

#method_before
private void pcepSetupTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        int srpId = SrpIdGenerators.create();
        Collection<Tunnel> tunnels = tunnelService.queryTunnel(tunnel.src(), tunnel.dst());
        for (Tunnel t : tunnels) {
            if (t.tunnelName().equals(tunnel.tunnelName())) {
                tunnel = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), t.state(), tunnel.groupId(), t.tunnelId(), tunnel.tunnelName(), tunnel.path(), tunnel.resource(), tunnel.annotations());
            }
        }
        if (tunnel.tunnelId() == null) {
            log.error("Tunnel ID not found");
            return;
        }
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, CREATE);
        pcepTunnelApiMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = createPcInitiatedLspReqList(tunnel, path, pc, srpId);
        if (llPcInitiatedLspRequestList == null || llPcInitiatedLspRequestList.size() == 0) {
            log.error("Failed to create PcInitiatedLspRequestList");
            return;
        }
        // build PCInitiate message
        PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
        pc.sendMessage(Collections.singletonList(pcInitiateMsg));
        pcepTunnelApiMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing setup tunnel {}", e.getMessage());
    }
}
#method_after
private void pcepSetupTunnel(Tunnel tunnel, Path path, PcepClient pc) {
    try {
        int srpId = SrpIdGenerators.create();
        Collection<Tunnel> tunnels = tunnelService.queryTunnel(tunnel.src(), tunnel.dst());
        for (Tunnel t : tunnels) {
            if (t.tunnelName().equals(tunnel.tunnelName())) {
                tunnel = new DefaultTunnel(tunnel.providerId(), tunnel.src(), tunnel.dst(), tunnel.type(), t.state(), tunnel.groupId(), t.tunnelId(), tunnel.tunnelName(), tunnel.path(), tunnel.resource(), tunnel.annotations());
                break;
            }
        }
        if (tunnel.tunnelId() == null) {
            log.error("Tunnel ID not found");
            return;
        }
        PcepTunnelData pcepTunnelData = new PcepTunnelData(tunnel, path, CREATE);
        pcepTunnelApiMapper.addToCoreTunnelRequestQueue(pcepTunnelData);
        LinkedList<PcInitiatedLspRequest> llPcInitiatedLspRequestList = createPcInitiatedLspReqList(tunnel, path, pc, srpId);
        if (llPcInitiatedLspRequestList == null || llPcInitiatedLspRequestList.size() == 0) {
            log.error("Failed to create PcInitiatedLspRequestList");
            return;
        }
        // build PCInitiate message
        PcepInitiateMsg pcInitiateMsg = pc.factory().buildPcepInitiateMsg().setPcInitiatedLspRequestList(llPcInitiatedLspRequestList).build();
        pc.sendMessage(Collections.singletonList(pcInitiateMsg));
        pcepTunnelApiMapper.addToTunnelRequestQueue(srpId, pcepTunnelData);
    } catch (PcepParseException e) {
        log.error("PcepParseException occurred while processing setup tunnel {}", e.getMessage());
    }
}
#end_block

#method_before
private void setupEnvironment() {
    // Create mocks for configurations
    bgpConfig = createMock(BgpConfig.class);
    providersConfig = createMock(SdxParticipantsConfig.class);
    // Create mocks for services
    coreService = new TestCoreService();
    configService = new TestNetworkConfigService();
    registry = new NetworkConfigRegistryAdapter();
    interfaceService = createMock(InterfaceService.class);
    intentSynchronizer = createMock(IntentSynchronizationService.class);
}
#method_after
private void setupEnvironment() {
    // Create mocks for configurations
    bgpConfig = createMock(BgpConfig.class);
    participantsConfig = createMock(SdxParticipantsConfig.class);
    // Create mocks for services
    coreService = new TestCoreService();
    configService = new TestNetworkConfigService();
    registry = new NetworkConfigRegistryAdapter();
    interfaceService = createMock(InterfaceService.class);
    intentSynchronizer = createMock(IntentSynchronizationService.class);
}
#end_block

#method_before
private void setUpPeers() {
    // Set up the related expectations
    expect(providersConfig.getPortForPeer(IpAddress.valueOf(PEER1_IP))).andReturn(SW1_ETH1).anyTimes();
    expect(providersConfig.getInterfaceNameForPeer(IpAddress.valueOf(PEER1_IP))).andReturn(INTERFACE_SW1_ETH1).anyTimes();
    expect(providersConfig.getPortForPeer(IpAddress.valueOf(PEER2_IP))).andReturn(SW2_ETH1).anyTimes();
    expect(providersConfig.getInterfaceNameForPeer(IpAddress.valueOf(PEER2_IP))).andReturn(INTERFACE_SW2_ETH1).anyTimes();
    expect(providersConfig.getPortForPeer(IpAddress.valueOf(PEER3_IP))).andReturn(null).anyTimes();
    expect(providersConfig.getInterfaceNameForPeer(IpAddress.valueOf(PEER3_IP))).andReturn(null).anyTimes();
    expect(providersConfig.getPortForPeer(IpAddress.valueOf(PEER4_IP))).andReturn(null).anyTimes();
    expect(providersConfig.getInterfaceNameForPeer(IpAddress.valueOf(PEER4_IP))).andReturn(null).anyTimes();
    replay(providersConfig);
}
#method_after
private void setUpPeers() {
    // Set up the related expectations
    expect(participantsConfig.getPortForPeer(IpAddress.valueOf(PEER1_IP))).andReturn(SW1_ETH1).anyTimes();
    expect(participantsConfig.getInterfaceNameForPeer(IpAddress.valueOf(PEER1_IP))).andReturn(INTERFACE_SW1_ETH1).anyTimes();
    expect(participantsConfig.getPortForPeer(IpAddress.valueOf(PEER2_IP))).andReturn(SW2_ETH1).anyTimes();
    expect(participantsConfig.getInterfaceNameForPeer(IpAddress.valueOf(PEER2_IP))).andReturn(INTERFACE_SW2_ETH1).anyTimes();
    expect(participantsConfig.getPortForPeer(IpAddress.valueOf(PEER3_IP))).andReturn(null).anyTimes();
    expect(participantsConfig.getInterfaceNameForPeer(IpAddress.valueOf(PEER3_IP))).andReturn(null).anyTimes();
    expect(participantsConfig.getPortForPeer(IpAddress.valueOf(PEER4_IP))).andReturn(null).anyTimes();
    expect(participantsConfig.getInterfaceNameForPeer(IpAddress.valueOf(PEER4_IP))).andReturn(null).anyTimes();
    replay(participantsConfig);
}
#end_block

#method_before
@Test
public void testNoPeerInterface() {
    IpAddress ip = IpAddress.valueOf("1.1.1.1");
    bgpSpeakers.clear();
    bgpSpeakers.add(new BgpConfig.BgpSpeakerConfig(Optional.of("foo"), VlanId.NONE, SW1_ETH100, Collections.singleton(ip)));
    reset(interfaceService);
    interfaceService.addListener(anyObject(InterfaceListener.class));
    expect(interfaceService.getMatchingInterface(ip)).andReturn(null).anyTimes();
    replay(interfaceService);
    reset(providersConfig);
    expect(providersConfig.getPortForPeer(ip)).andReturn(null);
    expect(providersConfig.getInterfaceNameForPeer(ip)).andReturn(null);
    replay(providersConfig);
    // We don't expect any intents in this case
    reset(intentSynchronizer);
    replay(intentSynchronizer);
    peerManager.activate();
    verify(intentSynchronizer);
}
#method_after
@Test
public void testNoPeerInterface() {
    IpAddress ip = IpAddress.valueOf("1.1.1.1");
    bgpSpeakers.clear();
    bgpSpeakers.add(new BgpConfig.BgpSpeakerConfig(Optional.of("foo"), VlanId.NONE, SW1_ETH100, Collections.singleton(ip)));
    reset(interfaceService);
    interfaceService.addListener(anyObject(InterfaceListener.class));
    expect(interfaceService.getMatchingInterface(ip)).andReturn(null).anyTimes();
    replay(interfaceService);
    reset(participantsConfig);
    expect(participantsConfig.getPortForPeer(ip)).andReturn(null);
    expect(participantsConfig.getInterfaceNameForPeer(ip)).andReturn(null);
    replay(participantsConfig);
    // We don't expect any intents in this case
    reset(intentSynchronizer);
    replay(intentSynchronizer);
    peerManager.activate();
    verify(intentSynchronizer);
}
#end_block

#method_before
private void handleReply(MessageContext context) {
    if (fromPeerToSpeaker(context)) {
        translateVlanAndSend(context);
    }
}
#method_after
private void handleReply(MessageContext context) {
    if (fromPeerToSpeaker(context)) {
        translateVlanAndSendToSpeaker(context);
    } else if (fromPeerToPeer(context)) {
        translateVlanAndSendToPeer(context);
    }
}
#end_block

#method_before
private void handleRequest(MessageContext context) {
    if (hasIpAddress(context.inPort())) {
        // If the request came from outside the network, only reply if it was
        // for one of our external addresses.
        interfaceService.getInterfacesByPort(context.inPort()).stream().filter(intf -> intf.ipAddressesList().stream().anyMatch(ia -> ia.ipAddress().equals(context.target()))).forEach(intf -> buildAndSendReply(context, intf.mac()));
        if (!isPeerAddress(context.sender()) || !isPeerAddress(context.target())) {
            // Only care about requests from/towards external BGP peers
            return;
        }
    }
    // See if we have the target host in the host store
    Set<Host> hosts = hostService.getHostsByIp(context.target());
    Host dst = null;
    Host src = hostService.getHost(hostId(context.srcMac(), context.vlan()));
    VlanId destinationVlan = context.vlan();
    // BGP speaker, VLAN translation may be necessary on the ARP request.
    if (fromSpeakerToPeer(context)) {
        destinationVlan = getPeerVlan(context);
    }
    for (Host host : hosts) {
        if (host.vlan().equals(destinationVlan)) {
            dst = host;
            break;
        }
    }
    if (src != null && dst != null) {
        // We know the target host so we can respond
        buildAndSendReply(context, dst.mac());
        return;
    }
    // If the source address matches one of our external addresses
    // it could be a request from an internal host to an external
    // address. Forward it over to the correct connectPoint.
    boolean matched = false;
    Set<Interface> interfaces = interfaceService.getInterfacesByIp(context.sender());
    for (Interface intf : interfaces) {
        if (intf.vlan().equals(destinationVlan)) {
            matched = true;
            context.setVlan(destinationVlan);
            sendTo(context.packet(), intf.connectPoint());
        // Forward to all matching interfaces.
        }
    }
    if (matched) {
        return;
    }
    // If the packets has a vlanId look if there are some other
    // interfaces in the configuration on the same vlan and broadcast
    // the packet out just of through those interfaces.
    Set<Interface> filteredVlanInterfaces = filterVlanInterfacesNoIp(interfaceService.getInterfacesByVlan(destinationVlan));
    if (destinationVlan != null && !destinationVlan.equals(VlanId.NONE) && confContainsVlans(destinationVlan, context.inPort())) {
        vlanFlood(context.packet(), filteredVlanInterfaces, context.inPort);
        return;
    }
    // The request couldn't be resolved.
    // Flood the request on all ports except the incoming connectPoint.
    flood(context.packet(), context.inPort());
}
#method_after
private void handleRequest(MessageContext context) {
    if (hasIpAddress(context.inPort())) {
        // If the request came from outside the network, only reply if it was
        // for one of our external addresses.
        interfaceService.getInterfacesByPort(context.inPort()).stream().filter(intf -> intf.ipAddressesList().stream().anyMatch(ia -> ia.ipAddress().equals(context.target()))).forEach(intf -> buildAndSendReply(context, intf.mac()));
        if (!fromPeerToPeer(context)) {
            // Only care about requests from/towards external BGP peers
            return;
        }
    }
    // See if we have the target host in the host store
    Set<Host> hosts = hostService.getHostsByIp(context.target());
    Host dst = null;
    Host src = hostService.getHost(hostId(context.srcMac(), context.vlan()));
    // necessary on the ARP request.
    if (fromSpeakerToPeer(context) || fromPeerToPeer(context)) {
        translateVlanAndSendToPeer(context);
        return;
    }
    for (Host host : hosts) {
        if (host.vlan().equals(context.vlan())) {
            dst = host;
            break;
        }
    }
    if (src != null && dst != null) {
        // We know the target host so we can respond
        buildAndSendReply(context, dst.mac());
        return;
    }
    // If the source address matches one of our external addresses
    // it could be a request from an internal host to an external
    // address. Forward it over to the correct connectPoint.
    boolean matched = false;
    Set<Interface> interfaces = interfaceService.getInterfacesByIp(context.sender());
    for (Interface intf : interfaces) {
        if (intf.vlan().equals(context.vlan())) {
            matched = true;
            sendTo(context.packet(), intf.connectPoint());
            break;
        }
    }
    if (matched) {
        return;
    }
    // If the packets has a vlanId look if there are some other
    // interfaces in the configuration on the same vlan and broadcast
    // the packet out just of through those interfaces.
    VlanId vlanId = context.vlan();
    Set<Interface> filteredVlanInterfaces = filterVlanInterfacesNoIp(interfaceService.getInterfacesByVlan(vlanId));
    if (vlanId != null && !vlanId.equals(VlanId.NONE) && confContainsVlans(vlanId, context.inPort())) {
        vlanFlood(context.packet(), filteredVlanInterfaces, context.inPort);
        return;
    }
    // The request couldn't be resolved.
    // Flood the request on all ports except the incoming connectPoint.
    flood(context.packet(), context.inPort());
}
#end_block

#method_before
private void setupEnvironment() {
    // Create mocks for configurations
    bgpConfig = createMock(BgpConfig.class);
    providersConfig = createMock(SdxParticipantsConfig.class);
    // Create mocks for services
    coreService = new TestCoreService();
    configService = new TestNetworkConfigService();
    registry = new NetworkConfigRegistryAdapter();
    interfaceService = createMock(InterfaceService.class);
    intentSynchronizer = createMock(IntentSynchronizationService.class);
}
#method_after
private void setupEnvironment() {
    // Create mocks for configurations
    bgpConfig = createMock(BgpConfig.class);
    participantsConfig = createMock(SdxParticipantsConfig.class);
    // Create mocks for services
    coreService = new TestCoreService();
    configService = new TestNetworkConfigService();
    registry = new NetworkConfigRegistryAdapter();
    interfaceService = createMock(InterfaceService.class);
    intentSynchronizer = createMock(IntentSynchronizationService.class);
}
#end_block

#method_before
private void setUpPeers() {
    SdxParticipantsConfig.PeerConfig peer1 = new SdxParticipantsConfig.PeerConfig(Optional.of(PEER1_NAME), IpAddress.valueOf(PEER_IP), SW1_ETH1, INTERFACE_SW1_ETH1);
    // Set up the related expectations
    expect(providersConfig.getPortForPeer(IpAddress.valueOf(PEER_IP))).andReturn(SW1_ETH1).anyTimes();
    expect(providersConfig.getInterfaceNameForPeer(IpAddress.valueOf(PEER_IP))).andReturn(INTERFACE_SW1_ETH1).anyTimes();
    expect(providersConfig.getPeerForName(Optional.of(PEER1_NAME))).andReturn(peer1).anyTimes();
    expect(providersConfig.getPeerForIp(IpAddress.valueOf(PEER_IP))).andReturn(peer1).anyTimes();
    // Set up expectations for peers that will be added
    expect(providersConfig.getInterfaceNameForPeer(IpAddress.valueOf(NEW_PEER1_IP))).andReturn(null).anyTimes();
    expect(providersConfig.getPortForPeer(IpAddress.valueOf(NEW_PEER1_IP))).andReturn(null).anyTimes();
    expect(providersConfig.getPeerForIp(IpAddress.valueOf(NEW_PEER1_IP))).andReturn(null).anyTimes();
    expect(providersConfig.getInterfaceNameForPeer(IpAddress.valueOf(NEW_PEER2_IP))).andReturn(null).anyTimes();
    expect(providersConfig.getPortForPeer(IpAddress.valueOf(NEW_PEER2_IP))).andReturn(null).anyTimes();
    expect(providersConfig.getPeerForName(Optional.of(NEW_PEER_NAME))).andReturn(null).anyTimes();
    expect(providersConfig.node()).andReturn(null).anyTimes();
}
#method_after
private void setUpPeers() {
    SdxParticipantsConfig.PeerConfig peer1 = new SdxParticipantsConfig.PeerConfig(Optional.of(PEER1_NAME), IpAddress.valueOf(PEER_IP), SW1_ETH1, INTERFACE_SW1_ETH1);
    // Set up the related expectations
    expect(participantsConfig.getPortForPeer(IpAddress.valueOf(PEER_IP))).andReturn(SW1_ETH1).anyTimes();
    expect(participantsConfig.getInterfaceNameForPeer(IpAddress.valueOf(PEER_IP))).andReturn(INTERFACE_SW1_ETH1).anyTimes();
    expect(participantsConfig.getPeerForName(Optional.of(PEER1_NAME))).andReturn(peer1).anyTimes();
    expect(participantsConfig.getPeerForIp(IpAddress.valueOf(PEER_IP))).andReturn(peer1).anyTimes();
    // Set up expectations for peers that will be added
    expect(participantsConfig.getInterfaceNameForPeer(IpAddress.valueOf(NEW_PEER1_IP))).andReturn(null).anyTimes();
    expect(participantsConfig.getPortForPeer(IpAddress.valueOf(NEW_PEER1_IP))).andReturn(null).anyTimes();
    expect(participantsConfig.getPeerForIp(IpAddress.valueOf(NEW_PEER1_IP))).andReturn(null).anyTimes();
    expect(participantsConfig.getInterfaceNameForPeer(IpAddress.valueOf(NEW_PEER2_IP))).andReturn(null).anyTimes();
    expect(participantsConfig.getPortForPeer(IpAddress.valueOf(NEW_PEER2_IP))).andReturn(null).anyTimes();
    expect(participantsConfig.getPeerForName(Optional.of(NEW_PEER_NAME))).andReturn(null).anyTimes();
    expect(participantsConfig.node()).andReturn(null).anyTimes();
}
#end_block

#method_before
@Test(expected = ItemNotFoundException.class)
public void testAddPeerWithNoBgpConfig() {
    replay(providersConfig);
    // Reset NetworkConfigService
    peerManager.configService = new NetworkConfigServiceAdapter();
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), newPeer.ip(), newPeer.connectPoint(), newPeer.interfaceName());
}
#method_after
@Test(expected = ItemNotFoundException.class)
public void testAddPeerWithNoBgpConfig() {
    replay(participantsConfig);
    // Reset NetworkConfigService
    peerManager.configService = new NetworkConfigServiceAdapter();
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), newPeer.ip(), newPeer.connectPoint(), newPeer.interfaceName());
}
#end_block

#method_before
@Test(expected = ItemNotFoundException.class)
public void testAddPeerUknownIp() {
    replay(providersConfig);
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), IpAddress.valueOf(NEW_PEER2_IP), newPeer.connectPoint(), newPeer.interfaceName());
}
#method_after
@Test(expected = ItemNotFoundException.class)
public void testAddPeerUknownIp() {
    replay(participantsConfig);
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), IpAddress.valueOf(NEW_PEER2_IP), newPeer.connectPoint(), newPeer.interfaceName());
}
#end_block

#method_before
@Test(expected = ItemNotFoundException.class)
public void testAddPeerToUnknownInterface() {
    replay(providersConfig);
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), newPeer.ip(), newPeer.connectPoint(), "dummy-interface");
}
#method_after
@Test(expected = ItemNotFoundException.class)
public void testAddPeerToUnknownInterface() {
    replay(participantsConfig);
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), newPeer.ip(), newPeer.connectPoint(), "dummy-interface");
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void testAddPeerToNonMatchingInterface() {
    replay(providersConfig);
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), newPeer.ip(), SW3_ETH1, INTERFACE_SW3_ETH1);
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void testAddPeerToNonMatchingInterface() {
    replay(participantsConfig);
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), newPeer.ip(), SW3_ETH1, INTERFACE_SW3_ETH1);
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void testAddAlreadyRegisteredPeer() {
    replay(providersConfig);
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), IpAddress.valueOf(PEER_IP), newPeer.connectPoint(), newPeer.interfaceName());
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void testAddAlreadyRegisteredPeer() {
    replay(participantsConfig);
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), IpAddress.valueOf(PEER_IP), newPeer.connectPoint(), newPeer.interfaceName());
}
#end_block

#method_before
@Test(expected = IllegalArgumentException.class)
public void testAddPeerWithNameInUse() {
    replay(providersConfig);
    peerManager.activate();
    peerManager.addPeerDetails(PEER1_NAME, newPeer.ip(), newPeer.connectPoint(), newPeer.interfaceName());
}
#method_after
@Test(expected = IllegalArgumentException.class)
public void testAddPeerWithNameInUse() {
    replay(participantsConfig);
    peerManager.activate();
    peerManager.addPeerDetails(PEER1_NAME, newPeer.ip(), newPeer.connectPoint(), newPeer.interfaceName());
}
#end_block

#method_before
@Test
public void testAddPeerDetailsSuccess() {
    providersConfig.addPeer(newPeer);
    expectLastCall().once();
    replay(providersConfig);
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), newPeer.ip(), newPeer.connectPoint(), newPeer.interfaceName());
    verify(providersConfig);
}
#method_after
@Test
public void testAddPeerDetailsSuccess() {
    participantsConfig.addPeer(newPeer);
    expectLastCall().once();
    replay(participantsConfig);
    peerManager.activate();
    peerManager.addPeerDetails(newPeer.name().get(), newPeer.ip(), newPeer.connectPoint(), newPeer.interfaceName());
    verify(participantsConfig);
}
#end_block

#method_before
@Test(expected = ItemNotFoundException.class)
public void testRemovePeerWithNoBgpConfig() {
    replay(providersConfig);
    // Reset NetworkConfigService
    peerManager.configService = new NetworkConfigServiceAdapter();
    peerManager.activate();
    peerManager.removePeerDetails(IpAddress.valueOf(PEER_IP));
}
#method_after
@Test(expected = ItemNotFoundException.class)
public void testRemovePeerWithNoBgpConfig() {
    replay(participantsConfig);
    // Reset NetworkConfigService
    peerManager.configService = new NetworkConfigServiceAdapter();
    peerManager.activate();
    peerManager.removePeerDetails(IpAddress.valueOf(PEER_IP));
}
#end_block

#method_before
@Test(expected = ItemNotFoundException.class)
public void testRemoveNonFoundPeer() {
    replay(providersConfig);
    peerManager.activate();
    peerManager.removePeerDetails(IpAddress.valueOf(NEW_PEER1_IP));
}
#method_after
@Test(expected = ItemNotFoundException.class)
public void testRemoveNonFoundPeer() {
    replay(participantsConfig);
    peerManager.activate();
    peerManager.removePeerDetails(IpAddress.valueOf(NEW_PEER1_IP));
}
#end_block

#method_before
@Test
public void testRemovePeerDetailsSuccess() {
    providersConfig.removePeer(IpAddress.valueOf(PEER_IP));
    expectLastCall().once();
    replay(providersConfig);
    peerManager.activate();
    peerManager.removePeerDetails(IpAddress.valueOf(PEER_IP));
    verify(providersConfig);
}
#method_after
@Test
public void testRemovePeerDetailsSuccess() {
    participantsConfig.removePeer(IpAddress.valueOf(PEER_IP));
    expectLastCall().once();
    replay(participantsConfig);
    peerManager.activate();
    peerManager.removePeerDetails(IpAddress.valueOf(PEER_IP));
    verify(participantsConfig);
}
#end_block

#method_before
@Test
public void testGetPeerAddresses() {
    replay(providersConfig);
    peerManager.activate();
    List<IpAddress> expectedAddresses = new ArrayList<>();
    expectedAddresses.add(IpAddress.valueOf(PEER_IP));
    expectedAddresses.add(IpAddress.valueOf(NEW_PEER1_IP));
    Collections.sort(expectedAddresses);
    List<IpAddress> actualAddresses = peerManager.getPeerAddresses(bgpConfig);
    Collections.sort(actualAddresses);
    assertEquals(expectedAddresses, actualAddresses);
}
#method_after
@Test
public void testGetPeerAddresses() {
    replay(participantsConfig);
    peerManager.activate();
    List<IpAddress> expectedAddresses = new ArrayList<>();
    expectedAddresses.add(IpAddress.valueOf(PEER_IP));
    expectedAddresses.add(IpAddress.valueOf(NEW_PEER1_IP));
    Collections.sort(expectedAddresses);
    List<IpAddress> actualAddresses = peerManager.getPeerAddresses(bgpConfig);
    Collections.sort(actualAddresses);
    assertEquals(expectedAddresses, actualAddresses);
}
#end_block

#method_before
@Test
public void testGetInterfaceForPeer() {
    replay(providersConfig);
    peerManager.activate();
    assertEquals(intfSw1Eth1, peerManager.getInterfaceForPeer(IpAddress.valueOf(PEER_IP)));
}
#method_after
@Test
public void testGetInterfaceForPeer() {
    replay(participantsConfig);
    peerManager.activate();
    assertEquals(intfSw1Eth1, peerManager.getInterfaceForPeer(IpAddress.valueOf(PEER_IP)));
}
#end_block

#method_before
private void addIntfConfig() {
    Set<Interface> interfaces = Sets.newHashSet();
    Set<Interface> vlanOneSet = new HashSet<>();
    for (int i = 1; i <= LAST_CONF_DEVICE_INTF_VLAN_IP; i++) {
        ConnectPoint cp = new ConnectPoint(getDeviceId(i), P1);
        // Interface addresses for IPv4
        Ip4Prefix prefix1 = Ip4Prefix.valueOf("10.0." + (2 * i - 1) + ".0/24");
        Ip4Address addr1 = Ip4Address.valueOf("10.0." + (2 * i - 1) + ".1");
        Ip4Prefix prefix2 = Ip4Prefix.valueOf("10.0." + (2 * i) + ".0/24");
        Ip4Address addr2 = Ip4Address.valueOf("10.0." + (2 * i) + ".1");
        InterfaceIpAddress ia1 = new InterfaceIpAddress(addr1, prefix1);
        InterfaceIpAddress ia2 = new InterfaceIpAddress(addr2, prefix2);
        // Interface addresses for IPv6
        Ip6Prefix prefix3 = Ip6Prefix.valueOf((2 * i - 1) + "000::0/64");
        Ip6Address addr3 = Ip6Address.valueOf((2 * i - 1) + "000::1");
        Ip6Prefix prefix4 = Ip6Prefix.valueOf((2 * i) + "000::0/64");
        Ip6Address addr4 = Ip6Address.valueOf((2 * i) + "000::2");
        InterfaceIpAddress ia3 = new InterfaceIpAddress(addr3, prefix3);
        InterfaceIpAddress ia4 = new InterfaceIpAddress(addr4, prefix4);
        // Setting up interfaces
        Interface intf1 = new Interface(INTF1_NAME, cp, Lists.newArrayList(ia1, ia3), MacAddress.valueOf(2 * i - 1), VlanId.vlanId((short) 1));
        Interface intf2 = new Interface(INTF2_NAME, cp, Lists.newArrayList(ia2, ia4), MacAddress.valueOf(2 * i), VlanId.NONE);
        interfaces.add(intf1);
        interfaces.add(intf2);
        vlanOneSet.add(intf1);
        expect(interfaceService.getInterfacesByPort(cp)).andReturn(Sets.newHashSet(intf1, intf2)).anyTimes();
    }
    for (int i = LAST_CONF_DEVICE_INTF_VLAN_IP + 1; i <= LAST_CONF_DEVICE_INTF_VLAN; i++) {
        ConnectPoint cp = new ConnectPoint(getDeviceId(i), P1);
        Interface intf = new Interface(INTF_NAME_PREFIX + i, cp, Collections.emptyList(), MacAddress.NONE, VlanId.vlanId((short) 1));
        interfaces.add(intf);
        vlanOneSet.add(intf);
        expect(interfaceService.getInterfacesByPort(cp)).andReturn(Sets.newHashSet(intf)).anyTimes();
    }
    expect(interfaceService.getInterfacesByPort(CP3)).andReturn(Collections.emptySet()).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VLAN1)).andReturn(vlanOneSet).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VLAN10)).andReturn(Collections.emptySet()).anyTimes();
    expect(interfaceService.getInterfaces()).andReturn(interfaces).anyTimes();
    for (int i = LAST_CONF_DEVICE_INTF_VLAN + 1; i <= NUM_DEVICES; i++) {
        ConnectPoint cp = new ConnectPoint(getDeviceId(i), P1);
        expect(interfaceService.getInterfacesByPort(cp)).andReturn(Collections.emptySet()).anyTimes();
    }
}
#method_after
private void addIntfConfig() {
    Set<Interface> interfaces = Sets.newHashSet();
    Set<Interface> vlanOneSet = new HashSet<>();
    Set<Interface> vlanTwoSet = new HashSet<>();
    for (int i = 1; i <= LAST_CONF_DEVICE_INTF_VLAN_IP; i++) {
        ConnectPoint cp = new ConnectPoint(getDeviceId(i), P1);
        // Interface addresses for IPv4
        Ip4Prefix prefix1 = Ip4Prefix.valueOf("10.0." + (2 * i - 1) + ".0/24");
        Ip4Address addr1 = Ip4Address.valueOf("10.0." + (2 * i - 1) + ".1");
        Ip4Prefix prefix2 = Ip4Prefix.valueOf("10.0." + (2 * i) + ".0/24");
        Ip4Address addr2 = Ip4Address.valueOf("10.0." + (2 * i) + ".1");
        InterfaceIpAddress ia1 = new InterfaceIpAddress(addr1, prefix1);
        InterfaceIpAddress ia2 = new InterfaceIpAddress(addr2, prefix2);
        // Interface addresses for IPv6
        Ip6Prefix prefix3 = Ip6Prefix.valueOf((2 * i - 1) + "000::0/64");
        Ip6Address addr3 = Ip6Address.valueOf((2 * i - 1) + "000::1");
        Ip6Prefix prefix4 = Ip6Prefix.valueOf((2 * i) + "000::0/64");
        Ip6Address addr4 = Ip6Address.valueOf((2 * i) + "000::2");
        InterfaceIpAddress ia3 = new InterfaceIpAddress(addr3, prefix3);
        InterfaceIpAddress ia4 = new InterfaceIpAddress(addr4, prefix4);
        // Setting up interfaces
        Interface intf1 = new Interface(INTF1_NAME, cp, Lists.newArrayList(ia1, ia3), MacAddress.valueOf(2 * i - 1), VLAN1);
        Interface intf2 = new Interface(INTF2_NAME, cp, Lists.newArrayList(ia2, ia4), MacAddress.valueOf(2 * i), VLAN2);
        interfaces.add(intf1);
        interfaces.add(intf2);
        vlanOneSet.add(intf1);
        vlanTwoSet.add(intf2);
        expect(interfaceService.getInterfacesByPort(cp)).andReturn(Sets.newHashSet(intf1, intf2)).anyTimes();
    }
    for (int i = LAST_CONF_DEVICE_INTF_VLAN_IP + 1; i <= LAST_CONF_DEVICE_INTF_VLAN; i++) {
        ConnectPoint cp = new ConnectPoint(getDeviceId(i), P1);
        Interface intf = new Interface(INTF_NAME_PREFIX + i, cp, Collections.emptyList(), MacAddress.NONE, VlanId.vlanId((short) 1));
        interfaces.add(intf);
        vlanOneSet.add(intf);
        expect(interfaceService.getInterfacesByPort(cp)).andReturn(Sets.newHashSet(intf)).anyTimes();
    }
    expect(interfaceService.getInterfacesByPort(CP3)).andReturn(Collections.emptySet()).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VlanId.NONE)).andReturn(vlanTwoSet).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VLAN1)).andReturn(vlanOneSet).anyTimes();
    expect(interfaceService.getInterfacesByVlan(VLAN10)).andReturn(Collections.emptySet()).anyTimes();
    expect(interfaceService.getInterfaces()).andReturn(interfaces).anyTimes();
    for (int i = LAST_CONF_DEVICE_INTF_VLAN + 1; i <= NUM_DEVICES; i++) {
        ConnectPoint cp = new ConnectPoint(getDeviceId(i), P1);
        expect(interfaceService.getInterfacesByPort(cp)).andReturn(Collections.emptySet()).anyTimes();
    }
}
#end_block

#method_before
@Override
public boolean isLatest(Topology topology) {
    return defaultTopology(topology).equals(currentTopology());
}
#method_after
@Override
public boolean isLatest(Topology topology) {
    Topology currentTopology = currentTopology();
    return defaultTopology(topology).getGraph().equals(defaultTopology(currentTopology).getGraph());
}
#end_block

#method_before
public GroupDescription createSelectGroupInVxlan(DeviceId srcDeviceId, List<GatewayNode> nodeList) {
    List<GroupBucket> bucketList = Lists.newArrayList();
    nodeList.forEach(node -> {
        TrafficTreatment tBuilder = DefaultTrafficTreatment.builder().extension(buildNiciraExtenstion(srcDeviceId, node.getDataIpAddress()), srcDeviceId).setOutput(getTunnelPort(srcDeviceId)).build();
        bucketList.add(DefaultGroupBucket.createSelectGroupBucket(tBuilder));
    });
    GroupKey key = generateGroupKey(srcDeviceId, nodeList);
    return new DefaultGroupDescription(srcDeviceId, GroupDescription.Type.SELECT, new GroupBuckets(bucketList), key, null, appId);
}
#method_after
public GroupDescription createSelectGroupInVxlan(DeviceId srcDeviceId, List<GatewayNode> nodeList) {
    List<GroupBucket> bucketList = generateBucketsForSelectGroup(srcDeviceId, nodeList);
    GroupKey key = generateGroupKey(srcDeviceId, nodeList);
    return new DefaultGroupDescription(srcDeviceId, GroupDescription.Type.SELECT, new GroupBuckets(bucketList), key, null, appId);
}
#end_block

#method_before
public boolean populateRouterMacVlanFilters(DeviceId deviceId) {
    log.debug("Installing per-port filtering objective for untagged " + "packets in device {}", deviceId);
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterMacVlanFilters.");
        return false;
    }
    List<Port> devPorts = srManager.deviceService.getPorts(deviceId);
    if (devPorts != null && devPorts.size() == 0) {
        log.warn("Device {} ports not available. Unable to add MacVlan filters", deviceId);
        return false;
    }
    int disabledPorts = 0, suppressedPorts = 0, filteredPorts = 0;
    for (Port port : devPorts) {
        ConnectPoint connectPoint = new ConnectPoint(deviceId, port.number());
        // TODO: Handles dynamic port events when we are ready for dynamic config
        SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
        if (!port.isEnabled()) {
            disabledPorts++;
            continue;
        }
        if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
            suppressedPorts++;
            continue;
        }
        Ip4Prefix portSubnet = config.getPortSubnet(deviceId, port.number());
        VlanId assignedVlan = (portSubnet == null) ? VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET) : srManager.getSubnetAssignedVlanId(deviceId, portSubnet);
        FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
        fob.withKey(Criteria.matchInPort(port.number())).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
        // vlan assignment is valid only if this instance is master
        if (srManager.mastershipService.isLocalMaster(deviceId)) {
            TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
            fob.withMeta(tt);
        }
        fob.permit().fromApp(srManager.appId);
        log.debug("Sending filtering objective for dev/port:{}/{}", deviceId, port);
        filteredPorts++;
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {} populated", connectPoint), (objective, error) -> log.warn("Failed to populate filter for {}: {}", connectPoint, error));
        srManager.flowObjectiveService.filter(deviceId, fob.add(context));
    }
    log.info("Filtering on dev:{}, disabledPorts:{}, suppressedPorts:{}, filteredPorts:{}", deviceId, disabledPorts, suppressedPorts, filteredPorts);
    return (filteredPorts > 0) ? true : false;
}
#method_after
public boolean populateRouterMacVlanFilters(DeviceId deviceId) {
    log.debug("Installing per-port filtering objective for untagged " + "packets in device {}", deviceId);
    MacAddress deviceMac;
    try {
        deviceMac = config.getDeviceMac(deviceId);
    } catch (DeviceConfigNotFoundException e) {
        log.warn(e.getMessage() + " Aborting populateRouterMacVlanFilters.");
        return false;
    }
    List<Port> devPorts = srManager.deviceService.getPorts(deviceId);
    if (devPorts != null && devPorts.size() == 0) {
        log.warn("Device {} ports not available. Unable to add MacVlan filters", deviceId);
        return false;
    }
    int disabledPorts = 0, suppressedPorts = 0, filteredPorts = 0;
    for (Port port : devPorts) {
        ConnectPoint connectPoint = new ConnectPoint(deviceId, port.number());
        // TODO: Handles dynamic port events when we are ready for dynamic config
        SegmentRoutingAppConfig appConfig = srManager.cfgService.getConfig(srManager.appId, SegmentRoutingAppConfig.class);
        if (!port.isEnabled()) {
            disabledPorts++;
            continue;
        }
        if (appConfig != null && appConfig.suppressSubnet().contains(connectPoint)) {
            suppressedPorts++;
            continue;
        }
        Ip4Prefix portSubnet = config.getPortSubnet(deviceId, port.number());
        VlanId assignedVlan = (portSubnet == null) ? VlanId.vlanId(SegmentRoutingManager.ASSIGNED_VLAN_NO_SUBNET) : srManager.getSubnetAssignedVlanId(deviceId, portSubnet);
        FilteringObjective.Builder fob = DefaultFilteringObjective.builder();
        fob.withKey(Criteria.matchInPort(port.number())).addCondition(Criteria.matchEthDst(deviceMac)).addCondition(Criteria.matchVlanId(VlanId.NONE)).withPriority(SegmentRoutingService.DEFAULT_PRIORITY);
        // vlan assignment is valid only if this instance is master
        if (srManager.mastershipService.isLocalMaster(deviceId)) {
            TrafficTreatment tt = DefaultTrafficTreatment.builder().pushVlan().setVlanId(assignedVlan).build();
            fob.withMeta(tt);
        }
        fob.permit().fromApp(srManager.appId);
        log.debug("Sending filtering objective for dev/port:{}/{}", deviceId, port);
        filteredPorts++;
        ObjectiveContext context = new DefaultObjectiveContext((objective) -> log.debug("Filter for {} populated", connectPoint), (objective, error) -> log.warn("Failed to populate filter for {}: {}", connectPoint, error));
        srManager.flowObjectiveService.filter(deviceId, fob.add(context));
    }
    log.info("Filtering on dev:{}, disabledPorts:{}, suppressedPorts:{}, filteredPorts:{}", deviceId, disabledPorts, suppressedPorts, filteredPorts);
    // enabled is possibly not atomic.
    return (filteredPorts > 0) ? true : false;
}
#end_block

#method_before
@Override
public void event(MapEvent<Integer, byte[]> event) {
    switch(event.type()) {
        case INSERT:
            eventQ.add(new ObjectiveEvent(ObjectiveEvent.Type.ADD, event.key()));
            break;
        case REMOVE:
            eventQ.add(new ObjectiveEvent(ObjectiveEvent.Type.REMOVE, event.key()));
            break;
        case UPDATE:
            break;
        default:
            break;
    }
}
#method_after
@Override
public void event(MapEvent<Integer, byte[]> event) {
    switch(event.type()) {
        case INSERT:
            eventQ.add(new ObjectiveEvent(ObjectiveEvent.Type.ADD, event.key()));
            break;
        case REMOVE:
            eventQ.add(new ObjectiveEvent(ObjectiveEvent.Type.REMOVE, event.key()));
            break;
        case UPDATE:
            // TODO Introduce UPDATE ObjectiveEvent when the map is being updated
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Activate
public void activate() {
    this.appId = coreService.registerApplication(APP_NAME);
    deviceService.addListener(deviceListener);
    networkConfigService.addListener(networkConfigListener);
    hostService.addListener(hostListener);
    interfaceService.addListener(interfaceListener);
    updateConfig(true);
}
#method_after
@Activate
public void activate() {
    this.appId = coreService.registerApplication(APP_NAME);
    deviceService.addListener(deviceListener);
    networkConfigService.addListener(networkConfigListener);
    hostService.addListener(hostListener);
    interfaceService.addListener(interfaceListener);
    updateConfig(true);
    applicationService.registerDeactivateHook(this.appId, () -> {
        this.updateConfig(false);
    });
}
#end_block

#method_before
@Deactivate
public void deactivate() {
    updateConfig(false);
    deviceService.removeListener(deviceListener);
    networkConfigService.removeListener(networkConfigListener);
    hostService.removeListener(hostListener);
    interfaceService.removeListener(interfaceListener);
}
#method_after
@Deactivate
public void deactivate() {
    deviceService.removeListener(deviceListener);
    networkConfigService.removeListener(networkConfigListener);
    hostService.removeListener(hostListener);
    interfaceService.removeListener(interfaceListener);
}
#end_block

#method_before
private void updateConfig(boolean install) {
    ApplicationId routingAppId = coreService.registerApplication(RoutingService.ROUTER_APP_ID);
    RouterConfig config = networkConfigService.getConfig(routingAppId, RoutingService.ROUTER_CONFIG_CLASS);
    if (config == null) {
        log.warn("Router config not available");
        return;
    }
    controlPlaneConnectPoint = config.getControlPlaneConnectPoint();
    ospfEnabled = config.getOspfEnabled();
    interfaces = config.getInterfaces();
    updateDevice(install);
}
#method_after
private void updateConfig(boolean operation) {
    ApplicationId routingAppId = coreService.registerApplication(RoutingService.ROUTER_APP_ID);
    RouterConfig config = networkConfigService.getConfig(routingAppId, RoutingService.ROUTER_CONFIG_CLASS);
    if (config == null) {
        log.warn("Router config not available");
        return;
    }
    controlPlaneConnectPoint = config.getControlPlaneConnectPoint();
    ospfEnabled = config.getOspfEnabled();
    interfaces = config.getInterfaces();
    updateDevice(operation);
}
#end_block

#method_before
private void updateDevice(boolean install) {
    if (controlPlaneConnectPoint != null && deviceService.isAvailable(controlPlaneConnectPoint.deviceId())) {
        DeviceId deviceId = controlPlaneConnectPoint.deviceId();
        interfaceService.getInterfaces().stream().filter(intf -> intf.connectPoint().deviceId().equals(deviceId)).filter(intf -> interfaces.isEmpty() || interfaces.contains(intf.name())).forEach(install ? this::provisionInterface : this::removeInterface);
        log.info("Set up interfaces on {}", controlPlaneConnectPoint.deviceId());
    }
}
#method_after
private void updateDevice(boolean operation) {
    if (controlPlaneConnectPoint != null && deviceService.isAvailable(controlPlaneConnectPoint.deviceId())) {
        DeviceId deviceId = controlPlaneConnectPoint.deviceId();
        interfaceService.getInterfaces().stream().filter(intf -> intf.connectPoint().deviceId().equals(deviceId)).filter(intf -> interfaces.isEmpty() || interfaces.contains(intf.name())).forEach(operation ? this::provisionInterface : this::removeInterface);
        log.info("Set up interfaces on {}", controlPlaneConnectPoint.deviceId());
    }
}
#end_block

#method_before
@Override
public String requestSync(String request) throws NetconfException {
    if (!request.contains(ENDPATTERN)) {
        request = request + NEW_LINE + ENDPATTERN;
    }
    return sendRequest(request);
}
#method_after
@Override
public String requestSync(String request) throws NetconfException {
    if (!request.contains(ENDPATTERN)) {
        request = request + NEW_LINE + ENDPATTERN;
    }
    String reply = sendRequest(request);
    checkReply(reply);
    return reply;
}
#end_block

#method_before
@Override
public List<PortDescription> getPorts() {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        interfaces = session.get(showInterfacesRequestBuilder());
    } catch (IOException e) {
        throw new RuntimeException(new NetconfException("Failed to retrieve interfaces.", e));
    }
    List<PortDescription> descriptions = TextBlockParserCisco.parseCiscoIosPorts(interfaces);
    return descriptions;
}
#method_after
@Override
public List<PortDescription> getPorts() {
    NetconfController controller = checkNotNull(handler().get(NetconfController.class));
    NetconfSession session = controller.getDevicesMap().get(handler().data().deviceId()).getSession();
    try {
        interfaces = session.get(showInterfacesRequestBuilder());
    } catch (IOException e) {
        log.error("Failed to retrieve Interfaces");
        return ImmutableList.of();
    }
    return ImmutableList.copyOf(TextBlockParserCisco.parseCiscoIosPorts(interfaces));
}
#end_block

#method_before
private String showInterfacesRequestBuilder() {
    StringBuilder rpc = new StringBuilder("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
    // Message ID is injected later.
    rpc.append("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">");
    rpc.append("<get>");
    rpc.append("<filter>");
    rpc.append("<config-format-text-block>");
    rpc.append("<text-filter-spec> | include exp_to_match_run_conf </text-filter-spec>");
    rpc.append("</config-format-text-block>");
    rpc.append("<oper-data-format-text-block>");
    rpc.append("<show>interfaces</show>");
    rpc.append("</oper-data-format-text-block>");
    rpc.append("</filter>");
    rpc.append("</get>");
    rpc.append("</rpc>]]>]]>");
    return rpc.toString();
}
#method_after
private String showInterfacesRequestBuilder() {
    // Message ID is injected later.
    StringBuilder rpc = new StringBuilder("<rpc xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">");
    rpc.append("<get>");
    rpc.append("<filter>");
    rpc.append("<config-format-text-block>");
    rpc.append("<text-filter-spec> | include exp_to_match_run_conf </text-filter-spec>");
    rpc.append("</config-format-text-block>");
    rpc.append("<oper-data-format-text-block>");
    rpc.append("<show>interfaces</show>");
    rpc.append("</oper-data-format-text-block>");
    rpc.append("</filter>");
    rpc.append("</get>");
    rpc.append("</rpc>]]>]]>");
    return rpc.toString();
}
#end_block

#method_before
public static List<PortDescription> parseCiscoIosPorts(String interfacesReply) {
    long portSpeed;
    int interfacesCounter;
    String parentInterface;
    String[] parentArray;
    String tempString;
    List<PortDescription> portDesc = Lists.newArrayList();
    interfacesCounter = interfacesCounterMethod(interfacesReply);
    for (int i = 0; i < interfacesCounter; i++) {
        parentInterface = parentInterfaceMethod(interfacesReply);
        portDesc.add(findPortInfo(parentInterface));
        parentArray = parentInterface.split(SPACE);
        tempString = parentArray[0] + SPACE;
        interfacesReply = interfacesReply.replace(tempString, SPACE + tempString);
    }
    return portDesc;
}
#method_after
public static List<PortDescription> parseCiscoIosPorts(String interfacesReply) {
    String parentInterface;
    String[] parentArray;
    String tempString;
    List<PortDescription> portDesc = Lists.newArrayList();
    int interfacesCounter = interfacesCounterMethod(interfacesReply);
    for (int i = 0; i < interfacesCounter; i++) {
        parentInterface = parentInterfaceMethod(interfacesReply);
        portDesc.add(findPortInfo(parentInterface));
        parentArray = parentInterface.split(SPACE);
        tempString = parentArray[0] + SPACE;
        interfacesReply = interfacesReply.replace(tempString, SPACE + tempString);
    }
    return portDesc;
}
#end_block

#method_before
private static DefaultPortDescription findPortInfo(String interfaceTree) {
    long portSpeed;
    String port;
    String[] textStr = interfaceTree.split(NEWLINE_SPLITTER);
    String[] firstLine = textStr[0].split(SPACE);
    String firstWord = firstLine[0];
    type = getPortType(textStr);
    isEnabled = getIsEnabled(textStr);
    port = getPort(textStr);
    portSpeed = getPortSpeed(textStr);
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, firstWord);
    return new DefaultPortDescription(PortNumber.portNumber(port), isEnabled, type, portSpeed, annotations.build());
}
#method_after
private static DefaultPortDescription findPortInfo(String interfaceTree) {
    String[] textStr = interfaceTree.split(NEWLINE_SPLITTER);
    String[] firstLine = textStr[0].split(SPACE);
    String firstWord = firstLine[0];
    Type type = getPortType(textStr);
    boolean isEnabled = getIsEnabled(textStr);
    String port = getPort(textStr);
    long portSpeed = getPortSpeed(textStr);
    DefaultAnnotations.Builder annotations = DefaultAnnotations.builder().set(AnnotationKeys.PORT_NAME, firstWord);
    return port == "-1" ? null : new DefaultPortDescription(PortNumber.portNumber(port), isEnabled, type, portSpeed, annotations.build());
}
#end_block

#method_before
private static Port.Type getPortType(String[] textStr) {
    String first3Characters;
    first3Characters = textStr[0].substring(0, 3);
    if (FIBERINTERFACES.contains(first3Characters)) {
        type = Port.Type.FIBER;
    } else {
        type = Port.Type.COPPER;
    }
    return type;
}
#method_after
private static Type getPortType(String[] textStr) {
    String first3Characters;
    first3Characters = textStr[0].substring(0, 3);
    return FIBERINTERFACES.contains(first3Characters) ? Type.FIBER : Type.COPPER;
}
#end_block

#method_before
private static boolean getIsEnabled(String[] textStr) {
    if (textStr[0].contains(IS_UP)) {
        isEnabled = true;
    } else {
        isEnabled = false;
    }
    return isEnabled;
}
#method_after
private static boolean getIsEnabled(String[] textStr) {
    return textStr[0].contains(IS_UP);
}
#end_block

#method_before
private static String getPort(String[] textStr) {
    String port = "";
    if (textStr[0].indexOf(PORT_DELIMITER) > 0) {
        port = textStr[0].substring(textStr[0].lastIndexOf(PORT_DELIMITER) + 1, textStr[0].indexOf(SPACE));
    }
    return port;
}
#method_after
private static String getPort(String[] textStr) {
    String port;
    try {
        if (textStr[0].indexOf(PORT_DELIMITER) > 0) {
            port = textStr[0].substring(textStr[0].lastIndexOf(PORT_DELIMITER) + 1, textStr[0].indexOf(SPACE));
        } else {
            port = "-1";
        }
    } catch (RuntimeException e) {
        port = "-1";
    }
    return port;
}
#end_block

#method_before
private static long getPortSpeed(String[] textStr) {
    long portSpeed = 0;
    String result = "";
    int lastLine = textStr.length - 1;
    for (int i = 1; i < lastLine; i++) {
        if ((textStr[i].indexOf(BANDWIDTH) > 0) && (textStr[i].indexOf(SPEED) > 0)) {
            result = textStr[i].substring(textStr[i].indexOf(BANDWIDTH) + 3, textStr[i].indexOf(SPEED));
            portSpeed = Long.valueOf(result).longValue();
            break;
        }
    }
    return portSpeed;
}
#method_after
private static long getPortSpeed(String[] textStr) {
    long portSpeed = 0;
    String result;
    int lastLine = textStr.length - 1;
    for (int i = 0; i < lastLine; i++) {
        if ((textStr[i].indexOf(BANDWIDTH) > 0) && (textStr[i].indexOf(SPEED) > 0)) {
            result = textStr[i].substring(textStr[i].indexOf(BANDWIDTH) + 3, textStr[i].indexOf(SPEED));
            portSpeed = Long.valueOf(result);
            break;
        }
    }
    return portSpeed;
}
#end_block

#method_before
@Activate
protected void activate(ComponentContext context) {
    componentConfigService.registerProperties(getClass());
    modified(context);
    coreAppId = coreService.registerApplication(CoreService.CORE_APP_NAME);
    routerAppId = coreService.registerApplication(RoutingService.ROUTER_APP_ID);
    networkConfigRegistry.registerConfigFactory(mcastConfigFactory);
    deviceListener = new InternalDeviceListener();
    deviceService.addListener(deviceListener);
    interfaceService.addListener(internalInterfaceList);
    updateConfig();
    log.info("Started");
}
#method_after
@Activate
protected void activate(ComponentContext context) {
    componentConfigService.registerProperties(getClass());
    modified(context);
    coreAppId = coreService.registerApplication(CoreService.CORE_APP_NAME);
    routerAppId = coreService.registerApplication(RoutingService.ROUTER_APP_ID);
    vrouterAppId = coreService.registerApplication(APP_NAME);
    networkConfigRegistry.registerConfigFactory(mcastConfigFactory);
    deviceListener = new InternalDeviceListener();
    deviceService.addListener(deviceListener);
    interfaceService.addListener(internalInterfaceList);
    updateConfig();
    applicationService.registerDeactivateHook(vrouterAppId, () -> {
        this.cleanUp();
    });
    log.info("Started");
}
#end_block

#method_before
@Deactivate
protected void deactivate() {
    routeService.removeListener(routeListener);
    deviceService.removeListener(deviceListener);
    interfaceService.removeListener(internalInterfaceList);
    // clean up the routes.
    for (Map.Entry<IpPrefix, IpAddress> routes : prefixToNextHop.entrySet()) {
        deleteRoute(new ResolvedRoute(routes.getKey(), null, null));
    }
    // clean up the filtering objective for interfaces.
    Set<Interface> intfs = getInterfaces();
    processIntfFilters(false, intfs);
    componentConfigService.unregisterProperties(getClass(), false);
    log.info("Stopped");
}
#method_after
@Deactivate
protected void deactivate() {
    routeService.removeListener(routeListener);
    deviceService.removeListener(deviceListener);
    interfaceService.removeListener(internalInterfaceList);
    // processIntfFilters(false, configService.getInterfaces()); //TODO necessary?
    componentConfigService.unregisterProperties(getClass(), false);
    log.info("Stopped");
}
#end_block

#method_before
@Override
public void addDevicePcepConfig(PcepClient pc) {
    if (netConfigRegistry == null) {
        log.error("Cannot add PCEP device capability as network config service is not available.");
        return;
    }
    DeviceCapability deviceCap = netConfigRegistry.addConfig(pc.getPccId().ipAddress(), DeviceCapability.class);
    deviceCap.setLabelStackCap(pc.capability().labelStackCapability()).setLocalLabelCap(pc.capability().pceccCapability()).setSrCap(pc.capability().srCapability()).apply();
}
#method_after
@Override
public void addDevicePcepConfig(PcepClient pc) {
    if (netConfigRegistry == null) {
        log.error("Cannot add PCEP device capability as network config service is not available.");
        return;
    }
    DeviceId pccDeviceId = DeviceId.deviceId(String.valueOf(pc.getPccId().ipAddress()));
    DeviceCapability deviceCap = netConfigService.addConfig(pccDeviceId, DeviceCapability.class);
    deviceCap.setLabelStackCap(pc.capability().labelStackCapability()).setLocalLabelCap(pc.capability().pceccCapability()).setSrCap(pc.capability().srCapability()).apply();
}
#end_block

#method_before
@Override
public void deleteDevicePcepConfig(PccId pccId) {
    if (netConfigRegistry == null) {
        log.error("Cannot remove PCEP device capability as network config service is not available.");
        return;
    }
    netConfigRegistry.removeConfig(pccId.ipAddress(), DeviceCapability.class);
}
#method_after
@Override
public void deleteDevicePcepConfig(PccId pccId) {
    if (netConfigRegistry == null) {
        log.error("Cannot remove PCEP device capability as network config service is not available.");
        return;
    }
    DeviceId pccDeviceId = DeviceId.deviceId(String.valueOf(pccId.ipAddress()));
    netConfigService.removeConfig(pccDeviceId, DeviceCapability.class);
}
#end_block

#method_before
@Before
public void startUp() {
    provider.pcepClientController = clientController;
    provider.deviceProviderRegistry = nodeRegistry;
    provider.linkProviderRegistry = linkRegistry;
    provider.controller = controller;
    provider.deviceService = deviceService;
    provider.netConfigRegistry = netConfigRegistry;
    provider.activate();
}
#method_after
@Before
public void startUp() {
    provider.pcepClientController = clientController;
    provider.deviceProviderRegistry = nodeRegistry;
    provider.linkProviderRegistry = linkRegistry;
    provider.controller = controller;
    provider.deviceService = deviceService;
    provider.netConfigRegistry = netConfigRegistry;
    provider.netConfigService = netConfigRegistry;
    provider.activate();
}
#end_block

#method_before
@After
public void tearDown() {
    provider.deactivate();
    provider.deviceProviderRegistry = null;
    provider.pcepClientController = null;
    provider.linkProviderRegistry = null;
    provider.controller = null;
    provider.deviceService = null;
    provider.netConfigRegistry = null;
}
#method_after
@After
public void tearDown() {
    provider.deactivate();
    provider.deviceProviderRegistry = null;
    provider.pcepClientController = null;
    provider.linkProviderRegistry = null;
    provider.controller = null;
    provider.deviceService = null;
    provider.netConfigRegistry = null;
    provider.netConfigService = null;
}
#end_block

#method_before
@Override
public DeviceProvider provider() {
    return null;
}
#method_after
@Override
public LinkProvider provider() {
    // TODO Auto-generated method stub
    return null;
}
#end_block

#method_before
@Override
public <S, C extends Config<S>> C addConfig(S subject, Class<C> configClass) {
    if (configClass == DeviceCapability.class) {
        DeviceCapability devCap = new DeviceCapability();
        classConfig.put((IpAddress) subject, devCap);
        JsonNode node = new ObjectNode(new MockJsonNode());
        ObjectMapper mapper = new ObjectMapper();
        ConfigApplyDelegate delegate = new InternalApplyDelegate();
        devCap.init((IpAddress) subject, null, node, mapper, delegate);
        return (C) devCap;
    }
    return null;
}
#method_after
@Override
public <S, C extends Config<S>> C addConfig(S subject, Class<C> configClass) {
    if (configClass == DeviceCapability.class) {
        DeviceCapability devCap = new DeviceCapability();
        classConfig.put((DeviceId) subject, devCap);
        JsonNode node = new ObjectNode(new MockJsonNode());
        ObjectMapper mapper = new ObjectMapper();
        ConfigApplyDelegate delegate = new InternalApplyDelegate();
        devCap.init((DeviceId) subject, null, node, mapper, delegate);
        return (C) devCap;
    }
    return null;
}
#end_block

#method_before
@Test
public void testPcepTopologyProviderTestAddDevice1() {
    PcepClient pc = clientController.getClient(PccId.pccId(IpAddress.valueOf("1.1.1.1")));
    for (PcepNodeListener l : clientController.pcepNodeListener) {
        pc.setCapability(new ClientCapability(true, true, false, true, true));
        l.addDevicePcepConfig(pc);
        DeviceCapability deviceCap = netConfigRegistry.getConfig(pc.getPccId().id(), DeviceCapability.class);
        assertThat(deviceCap.srCap(), is(true));
        assertThat(deviceCap.labelStackCap(), is(true));
        assertThat(deviceCap.localLabelCap(), is(true));
        l.deleteDevicePcepConfig(pc.getPccId());
        deviceCap = netConfigRegistry.getConfig(pc.getPccId().id(), DeviceCapability.class);
        assertThat(deviceCap, is(nullValue()));
    }
}
#method_after
@Test
public void testPcepTopologyProviderTestAddDevice1() {
    PcepClient pc = clientController.getClient(PccId.pccId(IpAddress.valueOf("1.1.1.1")));
    for (PcepNodeListener l : clientController.pcepNodeListener) {
        pc.setCapability(new ClientCapability(true, true, false, true, true));
        l.addDevicePcepConfig(pc);
        DeviceId pccDeviceId = DeviceId.deviceId(String.valueOf(pc.getPccId().ipAddress()));
        DeviceCapability deviceCap = netConfigRegistry.getConfig(pccDeviceId, DeviceCapability.class);
        assertThat(deviceCap.srCap(), is(true));
        assertThat(deviceCap.labelStackCap(), is(true));
        assertThat(deviceCap.localLabelCap(), is(true));
        l.deleteDevicePcepConfig(pc.getPccId());
        deviceCap = netConfigRegistry.getConfig(pccDeviceId, DeviceCapability.class);
        assertThat(deviceCap, is(nullValue()));
    }
}
#end_block

#method_before
@Test
public void testPcepTopologyProviderTestAddDevice2() {
    PcepClient pc = clientController.getClient(PccId.pccId(IpAddress.valueOf("1.1.1.1")));
    for (PcepNodeListener l : clientController.pcepNodeListener) {
        pc.setCapability(new ClientCapability(true, true, false, false, true));
        l.addDevicePcepConfig(pc);
        DeviceCapability deviceCap = netConfigRegistry.getConfig(pc.getPccId().id(), DeviceCapability.class);
        assertThat(deviceCap.srCap(), is(true));
        assertThat(deviceCap.labelStackCap(), is(false));
        assertThat(deviceCap.localLabelCap(), is(true));
        l.deleteDevicePcepConfig(pc.getPccId());
        deviceCap = netConfigRegistry.getConfig(pc.getPccId().id(), DeviceCapability.class);
        assertThat(deviceCap, is(nullValue()));
    }
}
#method_after
@Test
public void testPcepTopologyProviderTestAddDevice2() {
    PcepClient pc = clientController.getClient(PccId.pccId(IpAddress.valueOf("1.1.1.1")));
    for (PcepNodeListener l : clientController.pcepNodeListener) {
        pc.setCapability(new ClientCapability(true, true, false, false, true));
        l.addDevicePcepConfig(pc);
        DeviceId pccDeviceId = DeviceId.deviceId(String.valueOf(pc.getPccId().ipAddress()));
        DeviceCapability deviceCap = netConfigRegistry.getConfig(pccDeviceId, DeviceCapability.class);
        assertThat(deviceCap.srCap(), is(true));
        assertThat(deviceCap.labelStackCap(), is(false));
        assertThat(deviceCap.localLabelCap(), is(true));
        l.deleteDevicePcepConfig(pc.getPccId());
        deviceCap = netConfigRegistry.getConfig(pccDeviceId, DeviceCapability.class);
        assertThat(deviceCap, is(nullValue()));
    }
}
#end_block

#method_before
@Activate
public void activate() {
    KryoNamespace.Builder intentSerializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(IntentData.class).register(MultiValuedTimestamp.class).register(WallClockTimestamp.class);
    currentMap = storageService.<Key, IntentData>eventuallyConsistentMapBuilder().withName("intent-current").withSerializer(intentSerializer).withTimestampProvider((key, intentData) -> new MultiValuedTimestamp<>(intentData.version(), sequenceNumber.getAndIncrement())).withPeerUpdateFunction((key, intentData) -> getPeerNodes(key, intentData)).build();
    pendingMap = storageService.<Key, IntentData>eventuallyConsistentMapBuilder().withName("intent-pending").withSerializer(intentSerializer).withTimestampProvider((key, intentData) -> new MultiValuedTimestamp<>(intentData.version(), System.nanoTime())).withPeerUpdateFunction((key, intentData) -> getPeerNodes(key, intentData)).build();
    currentMap.addListener(new InternalCurrentListener());
    pendingMap.addListener(new InternalPendingListener());
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    KryoNamespace.Builder intentSerializer = KryoNamespace.newBuilder().register(KryoNamespaces.API).register(IntentData.class).register(MultiValuedTimestamp.class);
    currentMap = storageService.<Key, IntentData>eventuallyConsistentMapBuilder().withName("intent-current").withSerializer(intentSerializer).withTimestampProvider((key, intentData) -> new MultiValuedTimestamp<>(intentData.version(), sequenceNumber.getAndIncrement())).withPeerUpdateFunction((key, intentData) -> getPeerNodes(key, intentData)).build();
    pendingMap = storageService.<Key, IntentData>eventuallyConsistentMapBuilder().withName("intent-pending").withSerializer(intentSerializer).withTimestampProvider((key, intentData) -> intentData == null ? new MultiValuedTimestamp<>(new WallClockTimestamp(), System.nanoTime()) : new MultiValuedTimestamp<>(intentData.version(), System.nanoTime())).withPeerUpdateFunction((key, intentData) -> getPeerNodes(key, intentData)).build();
    currentMap.addListener(new InternalCurrentListener());
    pendingMap.addListener(new InternalPendingListener());
    log.info("Started");
}
#end_block

#method_before
@Override
public void write(IntentData newData) {
    checkNotNull(newData);
    IntentData currentData = currentMap.get(newData.key());
    if (IntentData.isUpdateAcceptable(currentData, newData)) {
        // this always succeeds
        if (newData.state() == PURGE_REQ) {
            currentMap.remove(newData.key(), currentData);
        } else {
            currentMap.put(newData.key(), new IntentData(newData));
        }
        // if current.put succeeded
        IntentData pendingIntentData = pendingMap.get(newData.key());
        if (pendingIntentData != null) {
            pendingMap.remove(newData.key(), pendingIntentData);
        }
    }
}
#method_after
@Override
public void write(IntentData newData) {
    checkNotNull(newData);
    IntentData currentData = currentMap.get(newData.key());
    if (IntentData.isUpdateAcceptable(currentData, newData)) {
        // this always succeeds
        if (newData.state() == PURGE_REQ) {
            currentMap.remove(newData.key(), currentData);
        } else {
            currentMap.put(newData.key(), new IntentData(newData));
        }
        // Remove the intent data from the pending map if the newData is more
        // recent or equal to the existing entry.
        pendingMap.compute(newData.key(), (key, existingValue) -> {
            if (existingValue == null || !existingValue.version().isNewerThan(newData.version())) {
                return null;
            } else {
                return existingValue;
            }
        });
    }
}
#end_block

#method_before
@Test
public void testInstallLoadBalancedFlowRules() {
    ApplicationId appId = new DefaultApplicationId(1, "test");
    SfcFlowRuleInstallerImpl flowRuleInstaller = new SfcFlowRuleInstallerImpl();
    flowRuleInstaller.virtualPortService = virtualPortService;
    flowRuleInstaller.vtnRscService = vtnRscService;
    flowRuleInstaller.portPairService = portPairService;
    flowRuleInstaller.portPairGroupService = portPairGroupService;
    flowRuleInstaller.flowClassifierService = flowClassifierService;
    flowRuleInstaller.driverService = driverService;
    flowRuleInstaller.deviceService = deviceService;
    flowRuleInstaller.hostService = hostService;
    flowRuleInstaller.flowObjectiveService = flowObjectiveService;
    flowRuleInstaller.tenantNetworkService = tenantNetworkService;
    flowRuleInstaller.appId = appId;
    final PortChain portChain = createPortChain();
    final String ppName1 = "PortPair1";
    final String ppDescription1 = "PortPair1";
    final String ingress1 = "d3333333-24fc-4fae-af4b-321c5e2eb3d1";
    final String egress1 = "a4444444-4a56-2a6e-cd3a-9dee4e2ec345";
    DefaultPortPair.Builder portPairBuilder = new DefaultPortPair.Builder();
    PortPair portPair1 = portPairBuilder.setId(portPairId1).setName(ppName1).setTenantId(tenantId).setDescription(ppDescription1).setIngress(ingress1).setEgress(egress1).build();
    final String ppName2 = "PortPair2";
    final String ppDescription2 = "PortPair2";
    final String ingress2 = "d5555555-24fc-4fae-af4b-321c5e2eb3d1";
    final String egress2 = "a6666666-4a56-2a6e-cd3a-9dee4e2ec345";
    PortPair portPair2 = portPairBuilder.setId(portPairId2).setName(ppName2).setTenantId(tenantId).setDescription(ppDescription2).setIngress(ingress2).setEgress(egress2).build();
    portPairService.createPortPair(portPair1);
    portPairService.createPortPair(portPair2);
    FlowClassifier fc1 = createFlowClassifier(flowClassifierId1);
    FlowClassifier fc2 = createFlowClassifier(flowClassifierId2);
    flowClassifierService.createFlowClassifier(fc1);
    flowClassifierService.createFlowClassifier(fc2);
    NshServicePathId nshSpiId = NshServicePathId.of(10);
    FiveTuple fiveTuple = DefaultFiveTuple.builder().setIpSrc(IpAddress.valueOf("3.3.3.3")).setIpDst(IpAddress.valueOf("4.4.4.4")).setPortSrc(PortNumber.portNumber(1500)).setPortDst(PortNumber.portNumber(2000)).setProtocol(IPv4.PROTOCOL_UDP).setTenantId(TenantId.tenantId("bbb")).build();
    LoadBalanceId id = LoadBalanceId.of((byte) 1);
    List<PortPairId> path = Lists.newArrayList();
    path.add(portPairId1);
    path.add(portPairId2);
    List<VirtualPort> virtualPortList = Lists.newArrayList();
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(ingress1)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(egress1)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(ingress2)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(egress2)));
    virtualPortService.createPorts(virtualPortList);
    portChain.addLoadBalancePath(fiveTuple, id, path);
    String physicalNetworkStr = "1234";
    String segmentationIdStr = "1";
    SegmentationId segmentationID = SegmentationId.segmentationId(segmentationIdStr);
    TenantNetworkId networkid1 = TenantNetworkId.networkId(networkIdStr);
    PhysicalNetwork physicalNetwork = PhysicalNetwork.physicalNetwork(physicalNetworkStr);
    TenantNetwork p1 = new DefaultTenantNetwork(networkid1, name, false, TenantNetwork.State.ACTIVE, false, tenantId, false, TenantNetwork.Type.LOCAL, physicalNetwork, segmentationID);
    tenantNetworkService.createNetworks(Collections.singletonList(p1));
    expect(driverService.createHandler(deviceId)).andReturn(driverHandler).anyTimes();
    replay(driverService);
// TODO : this code will be uncommented once the loxi changes are effective
/*
        flowRuleInstaller.installLoadBalancedFlowRules(portChain, fiveTuple, nshSpiId);

        ForwardingObjective forObj = ((FlowObjectiveAdapter) flowObjectiveService).forwardingObjective();

        // Check for Selector
        assertThat(forObj.selector().getCriterion(Criterion.Type.IN_PORT), instanceOf(PortCriterion.class));

        // Check for treatment
        List<Instruction> instructions = forObj.treatment().allInstructions();
        for (Instruction instruction : instructions) {
            if (instruction.type() == Instruction.Type.OUTPUT) {
                assertThat(((OutputInstruction) instruction).port(), is(PortNumber.P0));
            }
        }
        */
}
#method_after
@Test
public void testInstallLoadBalancedFlowRules() {
    ApplicationId appId = new DefaultApplicationId(1, "test");
    SfcFlowRuleInstallerImpl flowRuleInstaller = new SfcFlowRuleInstallerImpl();
    flowRuleInstaller.virtualPortService = virtualPortService;
    flowRuleInstaller.vtnRscService = vtnRscService;
    flowRuleInstaller.portPairService = portPairService;
    flowRuleInstaller.portPairGroupService = portPairGroupService;
    flowRuleInstaller.flowClassifierService = flowClassifierService;
    flowRuleInstaller.driverService = driverService;
    flowRuleInstaller.deviceService = deviceService;
    flowRuleInstaller.hostService = hostService;
    flowRuleInstaller.flowObjectiveService = flowObjectiveService;
    flowRuleInstaller.tenantNetworkService = tenantNetworkService;
    flowRuleInstaller.appId = appId;
    final PortChain portChain = createPortChain();
    final String ppName1 = "PortPair1";
    final String ppDescription1 = "PortPair1";
    final String ingress1 = "d3333333-24fc-4fae-af4b-321c5e2eb3d1";
    final String egress1 = "a4444444-4a56-2a6e-cd3a-9dee4e2ec345";
    DefaultPortPair.Builder portPairBuilder = new DefaultPortPair.Builder();
    PortPair portPair1 = portPairBuilder.setId(portPairId1).setName(ppName1).setTenantId(tenantId).setDescription(ppDescription1).setIngress(ingress1).setEgress(egress1).build();
    final String ppName2 = "PortPair2";
    final String ppDescription2 = "PortPair2";
    final String ingress2 = "d5555555-24fc-4fae-af4b-321c5e2eb3d1";
    final String egress2 = "a6666666-4a56-2a6e-cd3a-9dee4e2ec345";
    PortPair portPair2 = portPairBuilder.setId(portPairId2).setName(ppName2).setTenantId(tenantId).setDescription(ppDescription2).setIngress(ingress2).setEgress(egress2).build();
    portPairService.createPortPair(portPair1);
    portPairService.createPortPair(portPair2);
    FlowClassifier fc1 = createFlowClassifier(flowClassifierId1);
    FlowClassifier fc2 = createFlowClassifier(flowClassifierId2);
    flowClassifierService.createFlowClassifier(fc1);
    flowClassifierService.createFlowClassifier(fc2);
    NshServicePathId nshSpiId = NshServicePathId.of(10);
    FiveTuple fiveTuple = DefaultFiveTuple.builder().setIpSrc(IpAddress.valueOf("3.3.3.3")).setIpDst(IpAddress.valueOf("4.4.4.4")).setPortSrc(PortNumber.portNumber(1500)).setPortDst(PortNumber.portNumber(2000)).setProtocol(IPv4.PROTOCOL_UDP).setTenantId(TenantId.tenantId("bbb")).build();
    LoadBalanceId id = LoadBalanceId.of((byte) 1);
    List<PortPairId> path = Lists.newArrayList();
    path.add(portPairId1);
    path.add(portPairId2);
    List<VirtualPort> virtualPortList = Lists.newArrayList();
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(ingress1)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(egress1)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(ingress2)));
    virtualPortList.add(createVirtualPort(VirtualPortId.portId(egress2)));
    virtualPortService.createPorts(virtualPortList);
    portChain.addLoadBalancePath(fiveTuple, id, path);
    String physicalNetworkStr = "1234";
    String segmentationIdStr = "1";
    SegmentationId segmentationID = SegmentationId.segmentationId(segmentationIdStr);
    TenantNetworkId networkid1 = TenantNetworkId.networkId(networkIdStr);
    PhysicalNetwork physicalNetwork = PhysicalNetwork.physicalNetwork(physicalNetworkStr);
    TenantNetwork p1 = new DefaultTenantNetwork(networkid1, name, false, TenantNetwork.State.ACTIVE, false, tenantId, false, TenantNetwork.Type.LOCAL, physicalNetwork, segmentationID);
    tenantNetworkService.createNetworks(Collections.singletonList(p1));
    expect(driverService.createHandler(deviceId)).andReturn(driverHandler).anyTimes();
    replay(driverService);
    flowRuleInstaller.installLoadBalancedFlowRules(portChain, fiveTuple, nshSpiId);
    ForwardingObjective forObj = ((FlowObjectiveAdapter) flowObjectiveService).forwardingObjective();
    // Check for Selector
    assertThat(forObj.selector().getCriterion(Criterion.Type.IN_PORT), instanceOf(PortCriterion.class));
    // Check for treatment
    List<Instruction> instructions = forObj.treatment().allInstructions();
    for (Instruction instruction : instructions) {
        if (instruction.type() == Instruction.Type.OUTPUT) {
            assertThat(((OutputInstruction) instruction).port(), is(PortNumber.P0));
        }
    }
}
#end_block

#method_before
@Override
public boolean createPortChain(PortChain portChain) {
    checkNotNull(portChain, PORT_CHAIN_NULL);
    if (portChainStore.containsKey(portChain.portChainId())) {
        portChainStore.remove(portChain.portChainId());
    }
    portChainStore.put(portChain.portChainId(), portChain);
    if (!portChainStore.containsKey(portChain.portChainId())) {
        log.error("The portChain created is failed which identifier was {}", portChain.portChainId().toString());
        return false;
    }
    return true;
}
#method_after
@Override
public boolean createPortChain(PortChain portChain) {
    checkNotNull(portChain, PORT_CHAIN_NULL);
    portChainStore.put(portChain.portChainId(), portChain);
    if (!portChainStore.containsKey(portChain.portChainId())) {
        log.error("The portChain created is failed which identifier was {}", portChain.portChainId().toString());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean updatePortChain(PortChain portChain) {
    checkNotNull(portChain, PORT_CHAIN_NULL);
    if (!portChainStore.containsKey(portChain.portChainId())) {
        log.debug("The portChain is not exist whose identifier was {} ", portChain.portChainId().toString());
    } else {
        portChainStore.remove(portChain.portChainId());
    }
    portChainStore.put(portChain.portChainId(), portChain);
    if (!portChain.equals(portChainStore.get(portChain.portChainId()))) {
        log.debug("The portChain is updated failed whose identifier was {} ", portChain.portChainId().toString());
        return false;
    }
    return true;
}
#method_after
@Override
public boolean updatePortChain(PortChain portChain) {
    checkNotNull(portChain, PORT_CHAIN_NULL);
    PortChain oldPortChain = null;
    if (!portChainStore.containsKey(portChain.portChainId())) {
        log.warn("The portChain is not exist whose identifier was {} ", portChain.portChainId().toString());
        return false;
    } else {
        oldPortChain = portChainStore.get(portChain.portChainId());
    }
    PortChain newPortChain = DefaultPortChain.create(portChain, oldPortChain);
    portChainStore.put(newPortChain.portChainId(), newPortChain);
    if (!newPortChain.equals(portChainStore.get(newPortChain.portChainId()))) {
        log.debug("The portChain is updated failed whose identifier was {} ", newPortChain.portChainId().toString());
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public PortChain build() {
    checkNotNull(portChainId, "Port chain id cannot be null");
    checkNotNull(tenantId, "Tenant id cannot be null");
    checkNotNull(portPairGroupList, "Port pair groups cannot be null");
    return new DefaultPortChain(portChainId, tenantId, name, description, portPairGroupList, flowClassifierList);
}
#method_after
@Override
public PortChain build() {
    checkNotNull(portChainId, "Port chain id cannot be null");
    checkNotNull(tenantId, "Tenant id cannot be null");
    checkNotNull(portPairGroupList, "Port pair groups cannot be null");
    return new DefaultPortChain(portChainId, tenantId, name, description, portPairGroupList, flowClassifierList, portChain);
}
#end_block

#method_before
@Override
public OFOxm<?> mapSelector(OFFactory factory, ExtensionSelector extensionSelector) {
    ExtensionSelectorType type = extensionSelector.type();
    /*
        if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_SPI.type())) {
            NiciraMatchNshSpi niciraNshSpi = (NiciraMatchNshSpi) extensionSelector;
            return factory.oxms().nsp(U32.of(niciraNshSpi.nshSpi().servicePathId()));
        }
        if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_SI.type())) {
            NiciraMatchNshSi niciraNshSi = (NiciraMatchNshSi) extensionSelector;
            return factory.oxms().nsi(U8.of(niciraNshSi.nshSi().serviceIndex()));
        }
        if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_ENCAP_ETH_TYPE.type())) {
            NiciraMatchEncapEthType niciraEncapEthType = (NiciraMatchEncapEthType) extensionSelector;
            return factory.oxms().encapEthType(U16.of(niciraEncapEthType.encapEthType()));
        }*/
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_CH1.type())) {
    // TODO
    }
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_CH2.type())) {
    // TODO
    }
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_CH3.type())) {
    // TODO
    }
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_CH4.type())) {
    // TODO
    }
    return null;
}
#method_after
@Override
public OFOxm<?> mapSelector(OFFactory factory, ExtensionSelector extensionSelector) {
    ExtensionSelectorType type = extensionSelector.type();
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_SPI.type())) {
        NiciraMatchNshSpi niciraNshSpi = (NiciraMatchNshSpi) extensionSelector;
        return factory.oxms().nsp(U32.of(niciraNshSpi.nshSpi().servicePathId()));
    }
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_SI.type())) {
        NiciraMatchNshSi niciraNshSi = (NiciraMatchNshSi) extensionSelector;
        return factory.oxms().nsi(U8.of(niciraNshSi.nshSi().serviceIndex()));
    }
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_ENCAP_ETH_TYPE.type())) {
        NiciraMatchEncapEthType niciraEncapEthType = (NiciraMatchEncapEthType) extensionSelector;
        return factory.oxms().encapEthType(U16.of(niciraEncapEthType.encapEthType()));
    }
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_CH1.type())) {
    // TODO
    }
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_CH2.type())) {
    // TODO
    }
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_CH3.type())) {
    // TODO
    }
    if (type.equals(ExtensionSelectorType.ExtensionSelectorTypes.NICIRA_MATCH_NSH_CH4.type())) {
    // TODO
    }
    return null;
}
#end_block

#method_before
@Override
public ExtensionSelector mapOxm(OFOxm<?> oxm) {
    /*
        if (oxm.getMatchField() == MatchField.NSP) {
            OFOxmNsp oxmField = (OFOxmNsp) oxm;
            return new NiciraMatchNshSpi(NshServicePathId.of(oxmField.getValue().getRaw()));
        }
        if (oxm.getMatchField() == MatchField.NSI) {
            OFOxmNsi oxmField = (OFOxmNsi) oxm;
            return new NiciraMatchNshSi(NshServiceIndex.of(oxmField.getValue().getRaw()));
        }
        if (oxm.getMatchField() == MatchField.ENCAP_ETH_TYPE) {
            OFOxmEncapEthType oxmField = (OFOxmEncapEthType) oxm;
            return new NiciraMatchEncapEthType(oxmField.getValue().getRaw());
        }
        */
    return null;
}
#method_after
@Override
public ExtensionSelector mapOxm(OFOxm<?> oxm) {
    if (oxm.getMatchField() == MatchField.NSP) {
        OFOxmNsp oxmField = (OFOxmNsp) oxm;
        return new NiciraMatchNshSpi(NshServicePathId.of(oxmField.getValue().getRaw()));
    }
    if (oxm.getMatchField() == MatchField.NSI) {
        OFOxmNsi oxmField = (OFOxmNsi) oxm;
        return new NiciraMatchNshSi(NshServiceIndex.of(oxmField.getValue().getRaw()));
    }
    if (oxm.getMatchField() == MatchField.ENCAP_ETH_TYPE) {
        OFOxmEncapEthType oxmField = (OFOxmEncapEthType) oxm;
        return new NiciraMatchEncapEthType(oxmField.getValue().getRaw());
    }
    return null;
}
#end_block

#method_before
private static void handleSetField(TrafficTreatment.Builder builder, OFActionSetField action, DriverHandler driverHandler, DeviceId deviceId) {
    ExtensionTreatmentInterpreter treatmentInterpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        treatmentInterpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        treatmentInterpreter = null;
    }
    OFOxm<?> oxm = action.getField();
    switch(oxm.getMatchField().id) {
        case VLAN_PCP:
            @SuppressWarnings("unchecked")
            OFOxm<VlanPcp> vlanpcp = (OFOxm<VlanPcp>) oxm;
            builder.setVlanPcp(vlanpcp.getValue().getValue());
            break;
        case VLAN_VID:
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                    break;
                } catch (UnsupportedOperationException e) {
                    log.debug("Unsupported action extension; defaulting to native OF");
                }
            }
            @SuppressWarnings("unchecked")
            OFOxm<OFVlanVidMatch> vlanvid = (OFOxm<OFVlanVidMatch>) oxm;
            builder.setVlanId(VlanId.vlanId(vlanvid.getValue().getVlan()));
            break;
        case ETH_DST:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethdst = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthDst(MacAddress.valueOf(ethdst.getValue().getLong()));
            break;
        case ETH_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethsrc = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthSrc(MacAddress.valueOf(ethsrc.getValue().getLong()));
            break;
        case IPV4_DST:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4dst = (OFOxm<IPv4Address>) oxm;
            builder.setIpDst(Ip4Address.valueOf(ip4dst.getValue().getInt()));
            break;
        case IPV4_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4src = (OFOxm<IPv4Address>) oxm;
            builder.setIpSrc(Ip4Address.valueOf(ip4src.getValue().getInt()));
            break;
        case MPLS_LABEL:
            @SuppressWarnings("unchecked")
            OFOxm<U32> labelId = (OFOxm<U32>) oxm;
            builder.setMpls(MplsLabel.mplsLabel((int) labelId.getValue().getValue()));
            break;
        case MPLS_BOS:
            @SuppressWarnings("unchecked")
            OFOxm<U8> mplsBos = (OFOxm<U8>) oxm;
            builder.setMplsBos(mplsBos.getValue() == U8.ZERO ? false : true);
            break;
        case TUNNEL_ID:
            @SuppressWarnings("unchecked")
            OFOxm<U64> tunnelId = (OFOxm<U64>) oxm;
            builder.setTunnelId(tunnelId.getValue().getValue());
            break;
        case TCP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpdst = (OFOxm<TransportPort>) oxm;
            builder.setTcpDst(TpPort.tpPort(tcpdst.getValue().getPort()));
            break;
        case TCP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpsrc = (OFOxm<TransportPort>) oxm;
            builder.setTcpSrc(TpPort.tpPort(tcpsrc.getValue().getPort()));
            break;
        case UDP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpdst = (OFOxm<TransportPort>) oxm;
            builder.setUdpDst(TpPort.tpPort(udpdst.getValue().getPort()));
            break;
        case UDP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpsrc = (OFOxm<TransportPort>) oxm;
            builder.setUdpSrc(TpPort.tpPort(udpsrc.getValue().getPort()));
            break;
        case TUNNEL_IPV4_DST:
            /*
        case NSP:
        case NSI:
        case NSH_C1:
        case NSH_C2:
        case NSH_C3:
        case NSH_C4:
        case NSH_MDTYPE:
        case NSH_NP:
        case ENCAP_ETH_SRC:
        case ENCAP_ETH_DST:
        case ENCAP_ETH_TYPE:
        case TUN_GPE_NP:*/
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                } catch (UnsupportedOperationException e) {
                    log.debug(e.getMessage());
                }
            }
            break;
        case EXP_ODU_SIG_ID:
            @SuppressWarnings("unchecked")
            OFOxm<OduSignalID> oduID = (OFOxm<OduSignalID>) oxm;
            OduSignalID oduSignalID = oduID.getValue();
            OduSignalId oduSignalId = OduSignalId.oduSignalId(oduSignalID.getTpn(), oduSignalID.getTslen(), oduSignalID.getTsmap());
            builder.add(modL1OduSignalId(oduSignalId));
            break;
        case EXP_OCH_SIG_ID:
            try {
                @SuppressWarnings("unchecked")
                OFOxm<CircuitSignalID> ochId = (OFOxm<CircuitSignalID>) oxm;
                CircuitSignalID circuitSignalID = ochId.getValue();
                builder.add(modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
            } catch (NoMappingFoundException e) {
                log.warn(e.getMessage());
                break;
            }
            break;
        case ARP_OP:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.ArpOpcode> arpop = (OFOxm<org.projectfloodlight.openflow.types.ArpOpcode>) oxm;
            builder.setArpOp((short) arpop.getValue().getOpcode());
            break;
        case ARP_SHA:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> arpsha = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setArpSha(MacAddress.valueOf(arpsha.getValue().getLong()));
            break;
        case ARP_SPA:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> arpspa = (OFOxm<IPv4Address>) oxm;
            builder.setArpSpa(Ip4Address.valueOf(arpspa.getValue().getInt()));
            break;
        case ARP_THA:
        case ARP_TPA:
        case BSN_EGR_PORT_GROUP_ID:
        case BSN_GLOBAL_VRF_ALLOWED:
        case BSN_IN_PORTS_128:
        case BSN_L3_DST_CLASS_ID:
        case BSN_L3_INTERFACE_CLASS_ID:
        case BSN_L3_SRC_CLASS_ID:
        case BSN_LAG_ID:
        case BSN_TCP_FLAGS:
        case BSN_UDF0:
        case BSN_UDF1:
        case BSN_UDF2:
        case BSN_UDF3:
        case BSN_UDF4:
        case BSN_UDF5:
        case BSN_UDF6:
        case BSN_UDF7:
        case BSN_VLAN_XLATE_PORT_GROUP_ID:
        case BSN_VRF:
        case ETH_TYPE:
        case ICMPV4_CODE:
        case ICMPV4_TYPE:
        case ICMPV6_CODE:
        case ICMPV6_TYPE:
        case IN_PHY_PORT:
        case IN_PORT:
        case IPV6_DST:
        case IPV6_FLABEL:
        case IPV6_ND_SLL:
        case IPV6_ND_TARGET:
        case IPV6_ND_TLL:
        case IPV6_SRC:
        case IP_DSCP:
        case IP_ECN:
        case IP_PROTO:
        case METADATA:
        case MPLS_TC:
        case OCH_SIGID:
        case OCH_SIGID_BASIC:
        case OCH_SIGTYPE:
        case OCH_SIGTYPE_BASIC:
        case SCTP_DST:
        case SCTP_SRC:
        case EXP_ODU_SIGTYPE:
        case EXP_OCH_SIGTYPE:
        default:
            log.warn("Set field type {} not yet implemented.", oxm.getMatchField().id);
            break;
    }
}
#method_after
private static void handleSetField(TrafficTreatment.Builder builder, OFActionSetField action, DriverHandler driverHandler, DeviceId deviceId) {
    ExtensionTreatmentInterpreter treatmentInterpreter;
    if (driverHandler.hasBehaviour(ExtensionTreatmentInterpreter.class)) {
        treatmentInterpreter = driverHandler.behaviour(ExtensionTreatmentInterpreter.class);
    } else {
        treatmentInterpreter = null;
    }
    OFOxm<?> oxm = action.getField();
    switch(oxm.getMatchField().id) {
        case VLAN_PCP:
            @SuppressWarnings("unchecked")
            OFOxm<VlanPcp> vlanpcp = (OFOxm<VlanPcp>) oxm;
            builder.setVlanPcp(vlanpcp.getValue().getValue());
            break;
        case VLAN_VID:
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                    break;
                } catch (UnsupportedOperationException e) {
                    log.debug("Unsupported action extension; defaulting to native OF");
                }
            }
            @SuppressWarnings("unchecked")
            OFOxm<OFVlanVidMatch> vlanvid = (OFOxm<OFVlanVidMatch>) oxm;
            builder.setVlanId(VlanId.vlanId(vlanvid.getValue().getVlan()));
            break;
        case ETH_DST:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethdst = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthDst(MacAddress.valueOf(ethdst.getValue().getLong()));
            break;
        case ETH_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> ethsrc = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setEthSrc(MacAddress.valueOf(ethsrc.getValue().getLong()));
            break;
        case IPV4_DST:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4dst = (OFOxm<IPv4Address>) oxm;
            builder.setIpDst(Ip4Address.valueOf(ip4dst.getValue().getInt()));
            break;
        case IPV4_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> ip4src = (OFOxm<IPv4Address>) oxm;
            builder.setIpSrc(Ip4Address.valueOf(ip4src.getValue().getInt()));
            break;
        case MPLS_LABEL:
            @SuppressWarnings("unchecked")
            OFOxm<U32> labelId = (OFOxm<U32>) oxm;
            builder.setMpls(MplsLabel.mplsLabel((int) labelId.getValue().getValue()));
            break;
        case MPLS_BOS:
            @SuppressWarnings("unchecked")
            OFOxm<U8> mplsBos = (OFOxm<U8>) oxm;
            builder.setMplsBos(mplsBos.getValue() == U8.ZERO ? false : true);
            break;
        case TUNNEL_ID:
            @SuppressWarnings("unchecked")
            OFOxm<U64> tunnelId = (OFOxm<U64>) oxm;
            builder.setTunnelId(tunnelId.getValue().getValue());
            break;
        case TCP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpdst = (OFOxm<TransportPort>) oxm;
            builder.setTcpDst(TpPort.tpPort(tcpdst.getValue().getPort()));
            break;
        case TCP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> tcpsrc = (OFOxm<TransportPort>) oxm;
            builder.setTcpSrc(TpPort.tpPort(tcpsrc.getValue().getPort()));
            break;
        case UDP_DST:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpdst = (OFOxm<TransportPort>) oxm;
            builder.setUdpDst(TpPort.tpPort(udpdst.getValue().getPort()));
            break;
        case UDP_SRC:
            @SuppressWarnings("unchecked")
            OFOxm<TransportPort> udpsrc = (OFOxm<TransportPort>) oxm;
            builder.setUdpSrc(TpPort.tpPort(udpsrc.getValue().getPort()));
            break;
        case TUNNEL_IPV4_DST:
        case NSP:
        case NSI:
        case NSH_C1:
        case NSH_C2:
        case NSH_C3:
        case NSH_C4:
        case NSH_MDTYPE:
        case NSH_NP:
        case ENCAP_ETH_SRC:
        case ENCAP_ETH_DST:
        case ENCAP_ETH_TYPE:
        case TUN_GPE_NP:
            if (treatmentInterpreter != null) {
                try {
                    builder.extension(treatmentInterpreter.mapAction(action), deviceId);
                } catch (UnsupportedOperationException e) {
                    log.debug(e.getMessage());
                }
            }
            break;
        case EXP_ODU_SIG_ID:
            @SuppressWarnings("unchecked")
            OFOxm<OduSignalID> oduID = (OFOxm<OduSignalID>) oxm;
            OduSignalID oduSignalID = oduID.getValue();
            OduSignalId oduSignalId = OduSignalId.oduSignalId(oduSignalID.getTpn(), oduSignalID.getTslen(), oduSignalID.getTsmap());
            builder.add(modL1OduSignalId(oduSignalId));
            break;
        case EXP_OCH_SIG_ID:
            try {
                @SuppressWarnings("unchecked")
                OFOxm<CircuitSignalID> ochId = (OFOxm<CircuitSignalID>) oxm;
                CircuitSignalID circuitSignalID = ochId.getValue();
                builder.add(modL0Lambda(Lambda.ochSignal(lookupGridType(circuitSignalID.getGridType()), lookupChannelSpacing(circuitSignalID.getChannelSpacing()), circuitSignalID.getChannelNumber(), circuitSignalID.getSpectralWidth())));
            } catch (NoMappingFoundException e) {
                log.warn(e.getMessage());
                break;
            }
            break;
        case ARP_OP:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.ArpOpcode> arpop = (OFOxm<org.projectfloodlight.openflow.types.ArpOpcode>) oxm;
            builder.setArpOp((short) arpop.getValue().getOpcode());
            break;
        case ARP_SHA:
            @SuppressWarnings("unchecked")
            OFOxm<org.projectfloodlight.openflow.types.MacAddress> arpsha = (OFOxm<org.projectfloodlight.openflow.types.MacAddress>) oxm;
            builder.setArpSha(MacAddress.valueOf(arpsha.getValue().getLong()));
            break;
        case ARP_SPA:
            @SuppressWarnings("unchecked")
            OFOxm<IPv4Address> arpspa = (OFOxm<IPv4Address>) oxm;
            builder.setArpSpa(Ip4Address.valueOf(arpspa.getValue().getInt()));
            break;
        case ARP_THA:
        case ARP_TPA:
        case BSN_EGR_PORT_GROUP_ID:
        case BSN_GLOBAL_VRF_ALLOWED:
        case BSN_IN_PORTS_128:
        case BSN_L3_DST_CLASS_ID:
        case BSN_L3_INTERFACE_CLASS_ID:
        case BSN_L3_SRC_CLASS_ID:
        case BSN_LAG_ID:
        case BSN_TCP_FLAGS:
        case BSN_UDF0:
        case BSN_UDF1:
        case BSN_UDF2:
        case BSN_UDF3:
        case BSN_UDF4:
        case BSN_UDF5:
        case BSN_UDF6:
        case BSN_UDF7:
        case BSN_VLAN_XLATE_PORT_GROUP_ID:
        case BSN_VRF:
        case ETH_TYPE:
        case ICMPV4_CODE:
        case ICMPV4_TYPE:
        case ICMPV6_CODE:
        case ICMPV6_TYPE:
        case IN_PHY_PORT:
        case IN_PORT:
        case IPV6_DST:
        case IPV6_FLABEL:
        case IPV6_ND_SLL:
        case IPV6_ND_TARGET:
        case IPV6_ND_TLL:
        case IPV6_SRC:
        case IP_DSCP:
        case IP_ECN:
        case IP_PROTO:
        case METADATA:
        case MPLS_TC:
        case OCH_SIGID:
        case OCH_SIGID_BASIC:
        case OCH_SIGTYPE:
        case OCH_SIGTYPE_BASIC:
        case SCTP_DST:
        case SCTP_SRC:
        case EXP_ODU_SIGTYPE:
        case EXP_OCH_SIGTYPE:
        default:
            log.warn("Set field type {} not yet implemented.", oxm.getMatchField().id);
            break;
    }
}
#end_block

#method_before
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    Ip4Address ip;
    DriverHandler driverHandler = getDriver(deviceId);
    ExtensionSelectorInterpreter selectorInterpreter;
    if (driverHandler.hasBehaviour(ExtensionSelectorInterpreter.class)) {
        selectorInterpreter = driverHandler.behaviour(ExtensionSelectorInterpreter.class);
    } else {
        selectorInterpreter = null;
    }
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                if (match.isPartiallyMasked(MatchField.ETH_DST)) {
                    Masked<org.projectfloodlight.openflow.types.MacAddress> maskedMac = match.getMasked(MatchField.ETH_DST);
                    builder.matchEthDstMasked(MacAddress.valueOf(maskedMac.getValue().getLong()), MacAddress.valueOf(maskedMac.getMask().getLong()));
                } else {
                    mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                    builder.matchEthDst(mac);
                }
                break;
            case ETH_SRC:
                if (match.isPartiallyMasked(MatchField.ETH_SRC)) {
                    Masked<org.projectfloodlight.openflow.types.MacAddress> maskedMac = match.getMasked(MatchField.ETH_SRC);
                    builder.matchEthSrcMasked(MacAddress.valueOf(maskedMac.getValue().getLong()), MacAddress.valueOf(maskedMac.getMask().getLong()));
                } else {
                    mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                    builder.matchEthSrc(mac);
                }
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case VLAN_VID:
                if (selectorInterpreter != null && selectorInterpreter.supported(ExtensionSelectorTypes.OFDPA_MATCH_VLAN_VID.type())) {
                    if (match.getVersion().equals(OFVersion.OF_13)) {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.VLAN_VID);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } else {
                        break;
                    }
                } else {
                    VlanId vlanId = null;
                    if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                        Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                        if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                            vlanId = VlanId.ANY;
                        }
                    } else {
                        if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                            vlanId = VlanId.NONE;
                        } else {
                            vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                        }
                    }
                    if (vlanId != null) {
                        builder.matchVlanId(vlanId);
                    }
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc(TpPort.tpPort(match.get(MatchField.TCP_SRC).getPort()));
                break;
            case TCP_DST:
                builder.matchTcpDst(TpPort.tpPort(match.get(MatchField.TCP_DST).getPort()));
                break;
            case UDP_SRC:
                builder.matchUdpSrc(TpPort.tpPort(match.get(MatchField.UDP_SRC).getPort()));
                break;
            case UDP_DST:
                builder.matchUdpDst(TpPort.tpPort(match.get(MatchField.UDP_DST).getPort()));
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc(TpPort.tpPort(match.get(MatchField.SCTP_SRC).getPort()));
                break;
            case SCTP_DST:
                builder.matchSctpDst(TpPort.tpPort(match.get(MatchField.SCTP_DST).getPort()));
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case EXP_OCH_SIG_ID:
                try {
                    CircuitSignalID expSigId = match.get(MatchField.EXP_OCH_SIG_ID);
                    builder.add(matchLambda(Lambda.ochSignal(lookupGridType(expSigId.getGridType()), lookupChannelSpacing(expSigId.getChannelSpacing()), expSigId.getChannelNumber(), expSigId.getSpectralWidth())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_OCH_SIGTYPE:
                try {
                    U8 expOchSigType = match.get(MatchField.EXP_OCH_SIGTYPE);
                    builder.add(matchOchSignalType(lookupOchSignalType((byte) expOchSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_ODU_SIG_ID:
                OduSignalId oduSignalId = OduSignalId.oduSignalId(match.get(MatchField.EXP_ODU_SIG_ID).getTpn(), match.get(MatchField.EXP_ODU_SIG_ID).getTslen(), match.get(MatchField.EXP_ODU_SIG_ID).getTsmap());
                builder.add(matchOduSignalId(oduSignalId));
                break;
            case EXP_ODU_SIGTYPE:
                try {
                    U8 oduSigType = match.get(MatchField.EXP_ODU_SIGTYPE);
                    builder.add(matchOduSignalType(lookupOduSignalType((byte) oduSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
                int arpOp = match.get(MatchField.ARP_OP).getOpcode();
                builder.matchArpOp(arpOp);
                break;
            case ARP_SHA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_SHA).getLong());
                builder.matchArpSha(mac);
                break;
            case ARP_SPA:
                ip = Ip4Address.valueOf(match.get(MatchField.ARP_SPA).getInt());
                builder.matchArpSpa(ip);
                break;
            case ARP_THA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_THA).getLong());
                builder.matchArpTha(mac);
                break;
            case ARP_TPA:
                ip = Ip4Address.valueOf(match.get(MatchField.ARP_TPA).getInt());
                builder.matchArpTpa(ip);
                break;
            /*
            case NSP:
                if (selectorInterpreter != null) {
                    try {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.NSP);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } catch (UnsupportedOperationException e) {
                        log.debug(e.getMessage());
                    }
                }
                break;
            case NSI:
                if (selectorInterpreter != null) {
                    try {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.NSI);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } catch (UnsupportedOperationException e) {
                        log.debug(e.getMessage());
                    }
                }
                break;
            case ENCAP_ETH_TYPE:
                if (selectorInterpreter != null) {
                    try {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.ENCAP_ETH_TYPE);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } catch (UnsupportedOperationException e) {
                        log.debug(e.getMessage());
                    }
                }
                break;*/
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#method_after
private TrafficSelector buildSelector() {
    MacAddress mac;
    Ip4Prefix ip4Prefix;
    Ip6Address ip6Address;
    Ip6Prefix ip6Prefix;
    Ip4Address ip;
    DriverHandler driverHandler = getDriver(deviceId);
    ExtensionSelectorInterpreter selectorInterpreter;
    if (driverHandler.hasBehaviour(ExtensionSelectorInterpreter.class)) {
        selectorInterpreter = driverHandler.behaviour(ExtensionSelectorInterpreter.class);
    } else {
        selectorInterpreter = null;
    }
    TrafficSelector.Builder builder = DefaultTrafficSelector.builder();
    for (MatchField<?> field : match.getMatchFields()) {
        switch(field.id) {
            case IN_PORT:
                builder.matchInPort(PortNumber.portNumber(match.get(MatchField.IN_PORT).getPortNumber()));
                break;
            case IN_PHY_PORT:
                builder.matchInPhyPort(PortNumber.portNumber(match.get(MatchField.IN_PHY_PORT).getPortNumber()));
                break;
            case METADATA:
                long metadata = match.get(MatchField.METADATA).getValue().getValue();
                builder.matchMetadata(metadata);
                break;
            case ETH_DST:
                if (match.isPartiallyMasked(MatchField.ETH_DST)) {
                    Masked<org.projectfloodlight.openflow.types.MacAddress> maskedMac = match.getMasked(MatchField.ETH_DST);
                    builder.matchEthDstMasked(MacAddress.valueOf(maskedMac.getValue().getLong()), MacAddress.valueOf(maskedMac.getMask().getLong()));
                } else {
                    mac = MacAddress.valueOf(match.get(MatchField.ETH_DST).getLong());
                    builder.matchEthDst(mac);
                }
                break;
            case ETH_SRC:
                if (match.isPartiallyMasked(MatchField.ETH_SRC)) {
                    Masked<org.projectfloodlight.openflow.types.MacAddress> maskedMac = match.getMasked(MatchField.ETH_SRC);
                    builder.matchEthSrcMasked(MacAddress.valueOf(maskedMac.getValue().getLong()), MacAddress.valueOf(maskedMac.getMask().getLong()));
                } else {
                    mac = MacAddress.valueOf(match.get(MatchField.ETH_SRC).getLong());
                    builder.matchEthSrc(mac);
                }
                break;
            case ETH_TYPE:
                int ethType = match.get(MatchField.ETH_TYPE).getValue();
                builder.matchEthType((short) ethType);
                break;
            case VLAN_VID:
                if (selectorInterpreter != null && selectorInterpreter.supported(ExtensionSelectorTypes.OFDPA_MATCH_VLAN_VID.type())) {
                    if (match.getVersion().equals(OFVersion.OF_13)) {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.VLAN_VID);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } else {
                        break;
                    }
                } else {
                    VlanId vlanId = null;
                    if (match.isPartiallyMasked(MatchField.VLAN_VID)) {
                        Masked<OFVlanVidMatch> masked = match.getMasked(MatchField.VLAN_VID);
                        if (masked.getValue().equals(OFVlanVidMatch.PRESENT) && masked.getMask().equals(OFVlanVidMatch.PRESENT)) {
                            vlanId = VlanId.ANY;
                        }
                    } else {
                        if (!match.get(MatchField.VLAN_VID).isPresentBitSet()) {
                            vlanId = VlanId.NONE;
                        } else {
                            vlanId = VlanId.vlanId(match.get(MatchField.VLAN_VID).getVlan());
                        }
                    }
                    if (vlanId != null) {
                        builder.matchVlanId(vlanId);
                    }
                }
                break;
            case VLAN_PCP:
                byte vlanPcp = match.get(MatchField.VLAN_PCP).getValue();
                builder.matchVlanPcp(vlanPcp);
                break;
            case IP_DSCP:
                byte ipDscp = match.get(MatchField.IP_DSCP).getDscpValue();
                builder.matchIPDscp(ipDscp);
                break;
            case IP_ECN:
                byte ipEcn = match.get(MatchField.IP_ECN).getEcnValue();
                builder.matchIPEcn(ipEcn);
                break;
            case IP_PROTO:
                short proto = match.get(MatchField.IP_PROTO).getIpProtocolNumber();
                builder.matchIPProtocol((byte) proto);
                break;
            case IPV4_SRC:
                if (match.isPartiallyMasked(MatchField.IPV4_SRC)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_SRC);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_SRC).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPSrc(ip4Prefix);
                break;
            case IPV4_DST:
                if (match.isPartiallyMasked(MatchField.IPV4_DST)) {
                    Masked<IPv4Address> maskedIp = match.getMasked(MatchField.IPV4_DST);
                    ip4Prefix = Ip4Prefix.valueOf(maskedIp.getValue().getInt(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip4Prefix = Ip4Prefix.valueOf(match.get(MatchField.IPV4_DST).getInt(), Ip4Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPDst(ip4Prefix);
                break;
            case TCP_SRC:
                builder.matchTcpSrc(TpPort.tpPort(match.get(MatchField.TCP_SRC).getPort()));
                break;
            case TCP_DST:
                builder.matchTcpDst(TpPort.tpPort(match.get(MatchField.TCP_DST).getPort()));
                break;
            case UDP_SRC:
                builder.matchUdpSrc(TpPort.tpPort(match.get(MatchField.UDP_SRC).getPort()));
                break;
            case UDP_DST:
                builder.matchUdpDst(TpPort.tpPort(match.get(MatchField.UDP_DST).getPort()));
                break;
            case MPLS_LABEL:
                builder.matchMplsLabel(MplsLabel.mplsLabel((int) match.get(MatchField.MPLS_LABEL).getValue()));
                break;
            case MPLS_BOS:
                builder.matchMplsBos(match.get(MatchField.MPLS_BOS).getValue());
                break;
            case SCTP_SRC:
                builder.matchSctpSrc(TpPort.tpPort(match.get(MatchField.SCTP_SRC).getPort()));
                break;
            case SCTP_DST:
                builder.matchSctpDst(TpPort.tpPort(match.get(MatchField.SCTP_DST).getPort()));
                break;
            case ICMPV4_TYPE:
                byte icmpType = (byte) match.get(MatchField.ICMPV4_TYPE).getType();
                builder.matchIcmpType(icmpType);
                break;
            case ICMPV4_CODE:
                byte icmpCode = (byte) match.get(MatchField.ICMPV4_CODE).getCode();
                builder.matchIcmpCode(icmpCode);
                break;
            case IPV6_SRC:
                if (match.isPartiallyMasked(MatchField.IPV6_SRC)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_SRC);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_SRC).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Src(ip6Prefix);
                break;
            case IPV6_DST:
                if (match.isPartiallyMasked(MatchField.IPV6_DST)) {
                    Masked<IPv6Address> maskedIp = match.getMasked(MatchField.IPV6_DST);
                    ip6Prefix = Ip6Prefix.valueOf(maskedIp.getValue().getBytes(), maskedIp.getMask().asCidrMaskLength());
                } else {
                    ip6Prefix = Ip6Prefix.valueOf(match.get(MatchField.IPV6_DST).getBytes(), Ip6Prefix.MAX_MASK_LENGTH);
                }
                builder.matchIPv6Dst(ip6Prefix);
                break;
            case IPV6_FLABEL:
                int flowLabel = match.get(MatchField.IPV6_FLABEL).getIPv6FlowLabelValue();
                builder.matchIPv6FlowLabel(flowLabel);
                break;
            case ICMPV6_TYPE:
                byte icmpv6type = (byte) match.get(MatchField.ICMPV6_TYPE).getValue();
                builder.matchIcmpv6Type(icmpv6type);
                break;
            case ICMPV6_CODE:
                byte icmpv6code = (byte) match.get(MatchField.ICMPV6_CODE).getValue();
                builder.matchIcmpv6Code(icmpv6code);
                break;
            case IPV6_ND_TARGET:
                ip6Address = Ip6Address.valueOf(match.get(MatchField.IPV6_ND_TARGET).getBytes());
                builder.matchIPv6NDTargetAddress(ip6Address);
                break;
            case IPV6_ND_SLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_SLL).getLong());
                builder.matchIPv6NDSourceLinkLayerAddress(mac);
                break;
            case IPV6_ND_TLL:
                mac = MacAddress.valueOf(match.get(MatchField.IPV6_ND_TLL).getLong());
                builder.matchIPv6NDTargetLinkLayerAddress(mac);
                break;
            case IPV6_EXTHDR:
                builder.matchIPv6ExthdrFlags((short) match.get(MatchField.IPV6_EXTHDR).getValue());
                break;
            case OCH_SIGID:
                CircuitSignalID sigId = match.get(MatchField.OCH_SIGID);
                builder.add(matchLambda(Lambda.ochSignal(lookupGridType(sigId.getGridType()), lookupChannelSpacing(sigId.getChannelSpacing()), sigId.getChannelNumber(), sigId.getSpectralWidth())));
                break;
            case OCH_SIGTYPE:
                U8 sigType = match.get(MatchField.OCH_SIGTYPE);
                builder.add(matchOchSignalType(lookupOchSignalType((byte) sigType.getValue())));
                break;
            case EXP_OCH_SIG_ID:
                try {
                    CircuitSignalID expSigId = match.get(MatchField.EXP_OCH_SIG_ID);
                    builder.add(matchLambda(Lambda.ochSignal(lookupGridType(expSigId.getGridType()), lookupChannelSpacing(expSigId.getChannelSpacing()), expSigId.getChannelNumber(), expSigId.getSpectralWidth())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_OCH_SIGTYPE:
                try {
                    U8 expOchSigType = match.get(MatchField.EXP_OCH_SIGTYPE);
                    builder.add(matchOchSignalType(lookupOchSignalType((byte) expOchSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case EXP_ODU_SIG_ID:
                OduSignalId oduSignalId = OduSignalId.oduSignalId(match.get(MatchField.EXP_ODU_SIG_ID).getTpn(), match.get(MatchField.EXP_ODU_SIG_ID).getTslen(), match.get(MatchField.EXP_ODU_SIG_ID).getTsmap());
                builder.add(matchOduSignalId(oduSignalId));
                break;
            case EXP_ODU_SIGTYPE:
                try {
                    U8 oduSigType = match.get(MatchField.EXP_ODU_SIGTYPE);
                    builder.add(matchOduSignalType(lookupOduSignalType((byte) oduSigType.getValue())));
                } catch (NoMappingFoundException e) {
                    log.warn(e.getMessage());
                    break;
                }
                break;
            case TUNNEL_ID:
                long tunnelId = match.get(MatchField.TUNNEL_ID).getValue();
                builder.matchTunnelId(tunnelId);
                break;
            case ARP_OP:
                int arpOp = match.get(MatchField.ARP_OP).getOpcode();
                builder.matchArpOp(arpOp);
                break;
            case ARP_SHA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_SHA).getLong());
                builder.matchArpSha(mac);
                break;
            case ARP_SPA:
                ip = Ip4Address.valueOf(match.get(MatchField.ARP_SPA).getInt());
                builder.matchArpSpa(ip);
                break;
            case ARP_THA:
                mac = MacAddress.valueOf(match.get(MatchField.ARP_THA).getLong());
                builder.matchArpTha(mac);
                break;
            case ARP_TPA:
                ip = Ip4Address.valueOf(match.get(MatchField.ARP_TPA).getInt());
                builder.matchArpTpa(ip);
                break;
            case NSP:
                if (selectorInterpreter != null) {
                    try {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.NSP);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } catch (UnsupportedOperationException e) {
                        log.debug(e.getMessage());
                    }
                }
                break;
            case NSI:
                if (selectorInterpreter != null) {
                    try {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.NSI);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } catch (UnsupportedOperationException e) {
                        log.debug(e.getMessage());
                    }
                }
                break;
            case ENCAP_ETH_TYPE:
                if (selectorInterpreter != null) {
                    try {
                        OFOxm oxm = ((OFMatchV3) match).getOxmList().get(MatchField.ENCAP_ETH_TYPE);
                        builder.extension(selectorInterpreter.mapOxm(oxm), deviceId);
                    } catch (UnsupportedOperationException e) {
                        log.debug(e.getMessage());
                    }
                }
                break;
            case MPLS_TC:
            default:
                log.warn("Match type {} not yet implemented.", field.id);
        }
    }
    return builder.build();
}
#end_block

#method_before
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    flowRuleInstaller = new SfcFlowRuleInstallerImpl(appId);
    nshSpiIdGenerator = coreService.getIdGenerator(nshSpiIdTopic);
    vtnRscService.addListener(vtnRscListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(PortChainId.class, UUID.class, FiveTuple.class, IpAddress.class, PortNumber.class, DefaultFiveTuple.class, IpAddress.Version.class, TenantId.class);
    nshSpiPortChainMap = storageService.<PortChainId, Integer>eventuallyConsistentMapBuilder().withName("nshSpiPortChainMap").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    portChainFiveTupleMap = storageService.<PortChainId, List<FiveTuple>>eventuallyConsistentMapBuilder().withName("portChainFiveTupleMap").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    nshSpiIdFreeList = storageService.<Integer>setBuilder().withName("nshSpiIdDeletedList").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
    packetService.addProcessor(processor, PacketProcessor.director(SFC_PRIORITY));
    log.info("Started");
}
#method_after
@Activate
public void activate() {
    appId = coreService.registerApplication(APP_ID);
    nshSpiIdGenerator = coreService.getIdGenerator(nshSpiIdTopic);
    vtnRscService.addListener(vtnRscListener);
    KryoNamespace.Builder serializer = KryoNamespace.newBuilder().register(PortChainId.class, UUID.class, FiveTuple.class, IpAddress.class, PortNumber.class, DefaultFiveTuple.class, IpAddress.Version.class, TenantId.class);
    nshSpiPortChainMap = storageService.<PortChainId, Integer>eventuallyConsistentMapBuilder().withName("nshSpiPortChainMap").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    portChainFiveTupleMap = storageService.<PortChainId, List<FiveTuple>>eventuallyConsistentMapBuilder().withName("portChainFiveTupleMap").withSerializer(serializer).withTimestampProvider((k, v) -> new WallClockTimestamp()).build();
    nshSpiIdFreeList = storageService.<Integer>setBuilder().withName("nshSpiIdDeletedList").withSerializer(Serializer.using(KryoNamespaces.API)).build().asDistributedSet();
    packetService.addProcessor(processor, PacketProcessor.director(SFC_PRIORITY));
    log.info("Started");
}
#end_block

#method_before
@Override
public void event(VtnRscEvent event) {
    if (VtnRscEvent.Type.PORT_PAIR_PUT == event.type()) {
        PortPair portPair = ((VtnRscEventFeedback) event.subject()).portPair();
        onPortPairCreated(portPair);
    } else if (VtnRscEvent.Type.PORT_PAIR_DELETE == event.type()) {
        PortPair portPair = ((VtnRscEventFeedback) event.subject()).portPair();
        onPortPairDeleted(portPair);
    } else if (VtnRscEvent.Type.PORT_PAIR_UPDATE == event.type()) {
        PortPair portPair = ((VtnRscEventFeedback) event.subject()).portPair();
        onPortPairDeleted(portPair);
        onPortPairCreated(portPair);
    } else if (VtnRscEvent.Type.PORT_PAIR_GROUP_PUT == event.type()) {
        PortPairGroup portPairGroup = ((VtnRscEventFeedback) event.subject()).portPairGroup();
        onPortPairGroupCreated(portPairGroup);
    } else if (VtnRscEvent.Type.PORT_PAIR_GROUP_DELETE == event.type()) {
        PortPairGroup portPairGroup = ((VtnRscEventFeedback) event.subject()).portPairGroup();
        onPortPairGroupDeleted(portPairGroup);
    } else if (VtnRscEvent.Type.PORT_PAIR_GROUP_UPDATE == event.type()) {
        PortPairGroup portPairGroup = ((VtnRscEventFeedback) event.subject()).portPairGroup();
        onPortPairGroupDeleted(portPairGroup);
        onPortPairGroupCreated(portPairGroup);
    } else if (VtnRscEvent.Type.FLOW_CLASSIFIER_PUT == event.type()) {
        FlowClassifier flowClassifier = ((VtnRscEventFeedback) event.subject()).flowClassifier();
        onFlowClassifierCreated(flowClassifier);
    } else if (VtnRscEvent.Type.FLOW_CLASSIFIER_DELETE == event.type()) {
        FlowClassifier flowClassifier = ((VtnRscEventFeedback) event.subject()).flowClassifier();
        onFlowClassifierDeleted(flowClassifier);
    } else if (VtnRscEvent.Type.FLOW_CLASSIFIER_UPDATE == event.type()) {
        FlowClassifier flowClassifier = ((VtnRscEventFeedback) event.subject()).flowClassifier();
        onFlowClassifierDeleted(flowClassifier);
        onFlowClassifierCreated(flowClassifier);
    } else if (VtnRscEvent.Type.PORT_CHAIN_PUT == event.type()) {
        PortChain portChain = (PortChain) ((VtnRscEventFeedback) event.subject()).portChain();
        onPortChainCreated(portChain);
    } else if (VtnRscEvent.Type.PORT_CHAIN_DELETE == event.type()) {
        PortChain portChain = (PortChain) ((VtnRscEventFeedback) event.subject()).portChain();
        onPortChainDeleted(portChain);
    } else if (VtnRscEvent.Type.PORT_CHAIN_UPDATE == event.type()) {
        PortChain portChain = (PortChain) ((VtnRscEventFeedback) event.subject()).portChain();
        onPortChainDeleted(portChain);
        onPortChainCreated(portChain);
    }
}
#method_after
@Override
public void event(VtnRscEvent event) {
    if (VtnRscEvent.Type.PORT_PAIR_PUT == event.type()) {
        PortPair portPair = event.subject().portPair();
        onPortPairCreated(portPair);
    } else if (VtnRscEvent.Type.PORT_PAIR_DELETE == event.type()) {
        PortPair portPair = event.subject().portPair();
        onPortPairDeleted(portPair);
    } else if (VtnRscEvent.Type.PORT_PAIR_UPDATE == event.type()) {
        PortPair portPair = event.subject().portPair();
        onPortPairDeleted(portPair);
        onPortPairCreated(portPair);
    } else if (VtnRscEvent.Type.PORT_PAIR_GROUP_PUT == event.type()) {
        PortPairGroup portPairGroup = event.subject().portPairGroup();
        onPortPairGroupCreated(portPairGroup);
    } else if (VtnRscEvent.Type.PORT_PAIR_GROUP_DELETE == event.type()) {
        PortPairGroup portPairGroup = event.subject().portPairGroup();
        onPortPairGroupDeleted(portPairGroup);
    } else if (VtnRscEvent.Type.PORT_PAIR_GROUP_UPDATE == event.type()) {
        PortPairGroup portPairGroup = event.subject().portPairGroup();
        onPortPairGroupDeleted(portPairGroup);
        onPortPairGroupCreated(portPairGroup);
    } else if (VtnRscEvent.Type.FLOW_CLASSIFIER_PUT == event.type()) {
        FlowClassifier flowClassifier = event.subject().flowClassifier();
        onFlowClassifierCreated(flowClassifier);
    } else if (VtnRscEvent.Type.FLOW_CLASSIFIER_DELETE == event.type()) {
        FlowClassifier flowClassifier = event.subject().flowClassifier();
        onFlowClassifierDeleted(flowClassifier);
    } else if (VtnRscEvent.Type.FLOW_CLASSIFIER_UPDATE == event.type()) {
        FlowClassifier flowClassifier = event.subject().flowClassifier();
        onFlowClassifierDeleted(flowClassifier);
        onFlowClassifierCreated(flowClassifier);
    } else if (VtnRscEvent.Type.PORT_CHAIN_PUT == event.type()) {
        PortChain portChain = event.subject().portChain();
        if (portChain.oldPortChain() != null) {
            onPortChainDeleted(portChain.oldPortChain());
        }
        onPortChainCreated(portChain);
    } else if (VtnRscEvent.Type.PORT_CHAIN_DELETE == event.type()) {
        PortChain portChain = event.subject().portChain();
        onPortChainDeleted(portChain);
        portChainFiveTupleMap.remove(portChain.portChainId());
    } else if (VtnRscEvent.Type.PORT_CHAIN_UPDATE == event.type()) {
        PortChain portChain = event.subject().portChain();
        onPortChainDeleted(portChain);
        onPortChainCreated(portChain);
    }
}
#end_block

#method_before
@Override
public void onPortPairCreated(PortPair portPair) {
    log.debug("onPortPairCreated");
// TODO: Modify forwarding rule on port-pair creation.
}
#method_after
@Override
public void onPortPairCreated(PortPair portPair) {
    log.debug("onPortPairCreated");
// Do nothing
}
#end_block

#method_before
@Override
public void onPortPairDeleted(PortPair portPair) {
    log.debug("onPortPairDeleted");
// TODO: Modify forwarding rule on port-pair deletion.
}
#method_after
@Override
public void onPortPairDeleted(PortPair portPair) {
    log.debug("onPortPairDeleted");
// Do nothing
}
#end_block

#method_before
@Override
public void onPortPairGroupCreated(PortPairGroup portPairGroup) {
    log.debug("onPortPairGroupCreated");
// TODO: Modify forwarding rule on port-pair-group creation.
}
#method_after
@Override
public void onPortPairGroupCreated(PortPairGroup portPairGroup) {
    log.debug("onPortPairGroupCreated");
// Do nothing
}
#end_block

#method_before
@Override
public void onPortPairGroupDeleted(PortPairGroup portPairGroup) {
    log.debug("onPortPairGroupDeleted");
// TODO: Modify forwarding rule on port-pair-group deletion.
}
#method_after
@Override
public void onPortPairGroupDeleted(PortPairGroup portPairGroup) {
    log.debug("onPortPairGroupDeleted");
// Do nothing
}
#end_block

#method_before
@Override
public void onFlowClassifierCreated(FlowClassifier flowClassifier) {
    log.debug("onFlowClassifierCreated");
// TODO: Modify forwarding rule on flow-classifier creation.
}
#method_after
@Override
public void onFlowClassifierCreated(FlowClassifier flowClassifier) {
    log.debug("onFlowClassifierCreated");
// Do nothing
}
#end_block

#method_before
@Override
public void onFlowClassifierDeleted(FlowClassifier flowClassifier) {
    log.debug("onFlowClassifierDeleted");
// TODO: Modify forwarding rule on flow-classifier deletion.
}
#method_after
@Override
public void onFlowClassifierDeleted(FlowClassifier flowClassifier) {
    log.debug("onFlowClassifierDeleted");
// Do nothing
}
#end_block

#method_before
@Override
public void onPortChainCreated(PortChain portChain) {
    NshServicePathId nshSpi;
    log.info("On port chain created");
    int spi = getNextNshSpi();
    if (spi > MAX_NSH_SPI_ID) {
        log.error("Reached max limit of service path index." + "Failed to install SFC for port chain {}", portChain.portChainId().toString());
        return;
    }
    nshSpi = NshServicePathId.of(spi);
    nshSpiPortChainMap.put(portChain.portChainId(), new Integer(spi));
    if (!portChainFiveTupleMap.containsKey(portChain.portChainId())) {
        portChainFiveTupleMap.put(portChain.portChainId(), Lists.newArrayList());
    }
    // Install classifier rule to send the packet to controller
    flowRuleInstaller.installFlowClassifier(portChain, nshSpi);
    // Install rules for already identified five tuples.
    List<FiveTuple> list = portChainFiveTupleMap.get(portChain.portChainId());
    for (FiveTuple fiveTuple : list) {
        LoadBalanceId id = loadBalanceSfc(portChain.portChainId(), fiveTuple);
        // Get nsh service path index
        nshSpi = NshServicePathId.of(getNshServicePathId(id, spi));
        // download the required flow rules for classifier and
        // forwarding
        flowRuleInstaller.installLoadBalancedFlowRules(portChain, fiveTuple, nshSpi);
    }
}
#method_after
@Override
public void onPortChainCreated(PortChain portChain) {
    NshServicePathId nshSpi;
    log.info("On port chain created");
    int spi = getNextNshSpi();
    if (spi > MAX_NSH_SPI_ID) {
        log.error("Reached max limit of service path index." + "Failed to install SFC for port chain {}", portChain.portChainId().toString());
        return;
    }
    nshSpi = NshServicePathId.of(spi);
    nshSpiPortChainMap.put(portChain.portChainId(), new Integer(spi));
    if (!portChainFiveTupleMap.containsKey(portChain.portChainId())) {
        portChainFiveTupleMap.put(portChain.portChainId(), Lists.newArrayList());
    }
    // Install classifier rule to send the packet to controller
    SfcFlowRuleInstallerImpl flowRuleInstaller = new SfcFlowRuleInstallerImpl(appId);
    flowRuleInstaller.installFlowClassifier(portChain, nshSpi);
    // Install rules for already identified five tuples.
    List<FiveTuple> list = portChainFiveTupleMap.get(portChain.portChainId());
    for (FiveTuple fiveTuple : list) {
        LoadBalanceId id = loadBalanceSfc(portChain.portChainId(), fiveTuple);
        // Get nsh service path index
        nshSpi = NshServicePathId.of(getNshServicePathId(id, spi));
        // download the required flow rules for classifier and
        // forwarding
        flowRuleInstaller.installLoadBalancedFlowRules(portChain, fiveTuple, nshSpi);
    }
}
#end_block

#method_before
@Override
public void onPortChainDeleted(PortChain portChain) {
    log.info("onPortChainDeleted");
    if (!nshSpiPortChainMap.containsKey(portChain.portChainId())) {
        throw new ItemNotFoundException("Unable to find NSH SPI");
    }
    int nshSpiId = nshSpiPortChainMap.get(portChain.portChainId());
    // Uninstall classifier rules
    flowRuleInstaller.unInstallFlowClassifier(portChain, NshServicePathId.of(nshSpiId));
    // remove from nshSpiPortChainMap and add to nshSpiIdFreeList
    nshSpiPortChainMap.remove(portChain.portChainId());
    nshSpiIdFreeList.add(nshSpiId);
    // Uninstall load balanced classifier and forwarding rules.
    NshServicePathId nshSpi;
    LoadBalanceId id;
    List<LoadBalanceId> processedIdList = Lists.newArrayList();
    Set<FiveTuple> fiveTupleSet = portChain.getLoadBalanceIdMapKeys();
    for (FiveTuple fiveTuple : fiveTupleSet) {
        id = portChain.getLoadBalanceId(fiveTuple);
        if (processedIdList.contains(id)) {
            // multiple five tuple can have single path.
            continue;
        } else {
            processedIdList.add(id);
        }
        nshSpi = NshServicePathId.of(getNshServicePathId(id, nshSpiId));
        flowRuleInstaller.unInstallLoadBalancedFlowRules(portChain, fiveTuple, nshSpi);
    }
    // Reset load for all the port pairs
    List<PortPairGroupId> ppgIdlist = portChain.portPairGroups();
    ListIterator<PortPairGroupId> ppgIdListIterator = ppgIdlist.listIterator();
    while (ppgIdListIterator.hasNext()) {
        PortPairGroupId portPairGroupId = ppgIdListIterator.next();
        PortPairGroup ppg = portPairGroupService.getPortPairGroup(portPairGroupId);
        ppg.resetLoad();
    }
}
#method_after
@Override
public void onPortChainDeleted(PortChain portChain) {
    log.info("onPortChainDeleted");
    if (!nshSpiPortChainMap.containsKey(portChain.portChainId())) {
        throw new ItemNotFoundException("Unable to find NSH SPI");
    }
    int nshSpiId = nshSpiPortChainMap.get(portChain.portChainId());
    // Uninstall classifier rules
    SfcFlowRuleInstallerImpl flowRuleInstaller = new SfcFlowRuleInstallerImpl(appId);
    flowRuleInstaller.unInstallFlowClassifier(portChain, NshServicePathId.of(nshSpiId));
    // remove from nshSpiPortChainMap and add to nshSpiIdFreeList
    nshSpiPortChainMap.remove(portChain.portChainId());
    nshSpiIdFreeList.add(nshSpiId);
    // Uninstall load balanced classifier and forwarding rules.
    NshServicePathId nshSpi;
    LoadBalanceId id;
    List<LoadBalanceId> processedIdList = Lists.newArrayList();
    Set<FiveTuple> fiveTupleSet = portChain.getLoadBalanceIdMapKeys();
    for (FiveTuple fiveTuple : fiveTupleSet) {
        id = portChain.getLoadBalanceId(fiveTuple);
        if (processedIdList.contains(id)) {
            // multiple five tuple can have single path.
            continue;
        } else {
            processedIdList.add(id);
        }
        nshSpi = NshServicePathId.of(getNshServicePathId(id, nshSpiId));
        flowRuleInstaller.unInstallLoadBalancedFlowRules(portChain, fiveTuple, nshSpi);
    }
    // Reset load for all the port pairs
    List<PortPairGroupId> ppgIdlist = portChain.portPairGroups();
    ListIterator<PortPairGroupId> ppgIdListIterator = ppgIdlist.listIterator();
    while (ppgIdListIterator.hasNext()) {
        PortPairGroupId portPairGroupId = ppgIdListIterator.next();
        PortPairGroup ppg = portPairGroupService.getPortPairGroup(portPairGroupId);
        ppg.resetLoad();
    }
}
#end_block

#method_before
@Override
public void process(PacketContext context) {
    Ethernet packet = context.inPacket().parsed();
    if (packet == null || portChainService.getPortChainCount() == 0) {
        return;
    }
    // get the five tuple parameters for the packet
    short ethType = packet.getEtherType();
    IpAddress ipSrc = null;
    IpAddress ipDst = null;
    int portSrc = 0;
    int portDst = 0;
    byte protocol = 0;
    MacAddress macSrc = packet.getSourceMAC();
    TenantId tenantId = getTenantId(macSrc);
    if (ethType == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        ipSrc = IpAddress.valueOf(ipv4Packet.getSourceAddress());
        ipDst = IpAddress.valueOf(ipv4Packet.getDestinationAddress());
        protocol = ipv4Packet.getProtocol();
        if (protocol == IPv4.PROTOCOL_TCP) {
            TCP tcpPacket = (TCP) ipv4Packet.getPayload();
            portSrc = tcpPacket.getSourcePort();
            portDst = tcpPacket.getDestinationPort();
        } else if (protocol == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            portSrc = udpPacket.getSourcePort();
            portDst = udpPacket.getDestinationPort();
        } else if (protocol == IPv4.PROTOCOL_ICMP) {
        // do nothing
        } else {
            // No need to process other packets received by controller.
            return;
        }
    } else if (ethType == Ethernet.TYPE_IPV6) {
        return;
    }
    FiveTuple fiveTuple = DefaultFiveTuple.builder().setIpSrc(ipSrc).setIpDst(ipDst).setPortSrc(PortNumber.portNumber(portSrc)).setPortDst(PortNumber.portNumber(portDst)).setProtocol(protocol).setTenantId(tenantId).build();
    PortChainId portChainId = findPortChainFromFiveTuple(fiveTuple);
    if (portChainId == null) {
        log.error("Packet does not match with any classifier");
        return;
    }
    // Once the 5 tuple and port chain are identified, give this input for load balancing
    addToPortChainIdFiveTupleMap(portChainId, fiveTuple);
    LoadBalanceId id = loadBalanceSfc(portChainId, fiveTuple);
    // Get nsh service path index
    NshServicePathId nshSpi;
    PortChain portChain = portChainService.getPortChain(portChainId);
    if (nshSpiPortChainMap.containsKey(portChain.portChainId())) {
        int nshSpiId = nshSpiPortChainMap.get(portChain.portChainId());
        nshSpi = NshServicePathId.of(getNshServicePathId(id, nshSpiId));
    } else {
        int nshSpiId = getNextNshSpi();
        if (nshSpiId > MAX_NSH_SPI_ID) {
            log.error("Reached max limit of service path index." + "Failed to install SFC for port chain {}", portChain.portChainId());
            return;
        }
        nshSpi = NshServicePathId.of(getNshServicePathId(id, nshSpiId));
        nshSpiPortChainMap.put(portChain.portChainId(), new Integer(nshSpiId));
    }
    // download the required flow rules for classifier and forwarding
    // install in OVS.
    ConnectPoint connectPoint = flowRuleInstaller.installLoadBalancedFlowRules(portChain, fiveTuple, nshSpi);
    sendPacket(context, connectPoint);
}
#method_after
@Override
public void process(PacketContext context) {
    Ethernet packet = context.inPacket().parsed();
    if (packet == null || portChainService.getPortChainCount() == 0) {
        return;
    }
    // get the five tuple parameters for the packet
    short ethType = packet.getEtherType();
    IpAddress ipSrc = null;
    IpAddress ipDst = null;
    int portSrc = 0;
    int portDst = 0;
    byte protocol = 0;
    MacAddress macSrc = packet.getSourceMAC();
    TenantId tenantId = getTenantId(macSrc);
    if (ethType == Ethernet.TYPE_IPV4) {
        IPv4 ipv4Packet = (IPv4) packet.getPayload();
        ipSrc = IpAddress.valueOf(ipv4Packet.getSourceAddress());
        ipDst = IpAddress.valueOf(ipv4Packet.getDestinationAddress());
        protocol = ipv4Packet.getProtocol();
        if (protocol == IPv4.PROTOCOL_TCP) {
            TCP tcpPacket = (TCP) ipv4Packet.getPayload();
            portSrc = tcpPacket.getSourcePort();
            portDst = tcpPacket.getDestinationPort();
        } else if (protocol == IPv4.PROTOCOL_UDP) {
            UDP udpPacket = (UDP) ipv4Packet.getPayload();
            portSrc = udpPacket.getSourcePort();
            portDst = udpPacket.getDestinationPort();
        } else if (protocol == IPv4.PROTOCOL_ICMP) {
        // do nothing
        } else {
            // No need to process other packets received by controller.
            return;
        }
    } else {
        return;
    }
    FiveTuple fiveTuple = DefaultFiveTuple.builder().setIpSrc(ipSrc).setIpDst(ipDst).setPortSrc(PortNumber.portNumber(portSrc)).setPortDst(PortNumber.portNumber(portDst)).setProtocol(protocol).setTenantId(tenantId).build();
    PortChainId portChainId = findPortChainFromFiveTuple(fiveTuple);
    if (portChainId == null) {
        return;
    }
    // Once the 5 tuple and port chain are identified, give this input for load balancing
    addToPortChainIdFiveTupleMap(portChainId, fiveTuple);
    LoadBalanceId id = loadBalanceSfc(portChainId, fiveTuple);
    // Get nsh service path index
    NshServicePathId nshSpi;
    PortChain portChain = portChainService.getPortChain(portChainId);
    if (nshSpiPortChainMap.containsKey(portChain.portChainId())) {
        int nshSpiId = nshSpiPortChainMap.get(portChain.portChainId());
        nshSpi = NshServicePathId.of(getNshServicePathId(id, nshSpiId));
    } else {
        int nshSpiId = getNextNshSpi();
        if (nshSpiId > MAX_NSH_SPI_ID) {
            log.error("Reached max limit of service path index." + "Failed to install SFC for port chain {}", portChain.portChainId());
            return;
        }
        nshSpi = NshServicePathId.of(getNshServicePathId(id, nshSpiId));
        nshSpiPortChainMap.put(portChain.portChainId(), new Integer(nshSpiId));
    }
    // download the required flow rules for classifier and forwarding
    // install in OVS.
    SfcFlowRuleInstallerImpl flowRuleInstaller = new SfcFlowRuleInstallerImpl(appId);
    flowRuleInstaller.installLoadBalancedFlowRules(portChain, fiveTuple, nshSpi);
    sendPacket(context);
}
#end_block

#method_before
private void sendPacket(PacketContext context, ConnectPoint connectPoint) {
    ConnectPoint sourcePoint = context.inPacket().receivedFrom();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(sourcePoint.port()).build();
    OutboundPacket packet = new DefaultOutboundPacket(sourcePoint.deviceId(), treatment, context.inPacket().unparsed());
    packetService.emit(packet);
    log.trace("Sending packet: {}", packet);
}
#method_after
private void sendPacket(PacketContext context) {
    ConnectPoint sourcePoint = context.inPacket().receivedFrom();
    TrafficTreatment treatment = DefaultTrafficTreatment.builder().setOutput(sourcePoint.port()).build();
    OutboundPacket packet = new DefaultOutboundPacket(sourcePoint.deviceId(), treatment, context.inPacket().unparsed());
    packetService.emit(packet);
    log.trace("Sending packet: {}", packet);
}
#end_block

#method_before
@Override
public ConnectPoint installLoadBalancedFlowRules(PortChain portChain, FiveTuple fiveTuple, NshServicePathId nshSpiId) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    nshSi = 0xff;
    return installSfcFlowRules(portChain, fiveTuple, nshSpiId, Objective.Operation.ADD);
}
#method_after
@Override
public ConnectPoint installLoadBalancedFlowRules(PortChain portChain, FiveTuple fiveTuple, NshServicePathId nshSpiId) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    return installSfcFlowRules(portChain, fiveTuple, nshSpiId, Objective.Operation.ADD);
}
#end_block

#method_before
@Override
public ConnectPoint unInstallLoadBalancedFlowRules(PortChain portChain, FiveTuple fiveTuple, NshServicePathId nshSpiId) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    nshSi = 0xff;
    return installSfcFlowRules(portChain, fiveTuple, nshSpiId, Objective.Operation.REMOVE);
}
#method_after
@Override
public ConnectPoint unInstallLoadBalancedFlowRules(PortChain portChain, FiveTuple fiveTuple, NshServicePathId nshSpiId) {
    checkNotNull(portChain, PORT_CHAIN_NOT_NULL);
    return installSfcFlowRules(portChain, fiveTuple, nshSpiId, Objective.Operation.REMOVE);
}
#end_block

#method_before
public void installSfcEncapOutputRule(PortPair portPair, NshServicePathId nshSpiId, Objective.Operation type) {
    DeviceId deviceId = vtnRscService.getSfToSffMaping(VirtualPortId.portId(portPair.ingress()));
    MacAddress srcMacAddress = virtualPortService.getPort(VirtualPortId.portId(portPair.ingress())).macAddress();
    Host host = hostService.getHost(HostId.hostId(srcMacAddress));
    PortNumber port = host.location().port();
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionSelectorResolver resolver = handler.behaviour(ExtensionSelectorResolver.class);
    // Prepare selector with nsp, nsi and encap eth type
    ExtensionSelector nshSpiSelector = resolver.getExtensionSelector(NICIRA_MATCH_NSH_SPI.type());
    ExtensionSelector nshSiSelector = resolver.getExtensionSelector(NICIRA_MATCH_NSH_SI.type());
    ExtensionSelector nshEncapEthTypeSelector = resolver.getExtensionSelector(NICIRA_MATCH_ENCAP_ETH_TYPE.type());
    try {
        nshSpiSelector.setPropertyValue("nshSpi", nshSpiId);
    } catch (Exception e) {
        log.error("Failed to set extension selector to match Nsh Spi Id for encap rule {}", e.getMessage());
    }
    try {
        nshSiSelector.setPropertyValue("nshSi", NshServiceIndex.of(nshSi));
    } catch (Exception e) {
        log.error("Failed to set extension selector to match Nsh Si Id for encap rule {}", e.getMessage());
    }
    try {
        nshEncapEthTypeSelector.setPropertyValue("encapEthType", ENCAP_ETH_TYPE);
    } catch (Exception e) {
        log.error("Failed to set extension selector to match Nsh Si Id {}", deviceId);
    }
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    // selector.extension(nshEncapEthTypeSelector, deviceId);
    selector.extension(nshSpiSelector, deviceId);
    selector.extension(nshSiSelector, deviceId);
    ExtensionTreatmentResolver treatmentResolver = handler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment encapEthSrcTreatment = treatmentResolver.getExtensionInstruction(NICIRA_ENCAP_ETH_SRC.type());
    ExtensionTreatment encapEthDstTreatment = treatmentResolver.getExtensionInstruction(NICIRA_ENCAP_ETH_DST.type());
    try {
        encapEthDstTreatment.setPropertyValue("encapEthDst", srcMacAddress);
    } catch (Exception e) {
        log.error("Failed to set extension treatment to set encap eth dst {}", deviceId);
    }
    // TODO: move from packet source mac address
    try {
        encapEthSrcTreatment.setPropertyValue("encapEthSrc", srcMacAddress);
    } catch (Exception e) {
        log.error("Failed to set extension treatment to set encap eth src {}", deviceId);
    }
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.extension(encapEthSrcTreatment, deviceId);
    treatment.extension(encapEthDstTreatment, deviceId);
    treatment.setOutput(port);
    sendSfcRule(selector, treatment, deviceId, type, ENCAP_OUTPUT_PRIORITY);
    forwarderList.add(deviceId);
}
#method_after
public void installSfcEncapOutputRule(PortPair portPair, NshServicePathId nshSpiId, Objective.Operation type) {
    DeviceId deviceId = vtnRscService.getSfToSffMaping(VirtualPortId.portId(portPair.ingress()));
    MacAddress srcMacAddress = virtualPortService.getPort(VirtualPortId.portId(portPair.ingress())).macAddress();
    Host host = hostService.getHost(HostId.hostId(srcMacAddress));
    PortNumber port = host.location().port();
    DriverHandler handler = driverService.createHandler(deviceId);
    ExtensionSelectorResolver resolver = handler.behaviour(ExtensionSelectorResolver.class);
    // Prepare selector with nsp, nsi and encap eth type
    ExtensionSelector nshSpiSelector = resolver.getExtensionSelector(NICIRA_MATCH_NSH_SPI.type());
    ExtensionSelector nshSiSelector = resolver.getExtensionSelector(NICIRA_MATCH_NSH_SI.type());
    ExtensionSelector nshEncapEthTypeSelector = resolver.getExtensionSelector(NICIRA_MATCH_ENCAP_ETH_TYPE.type());
    try {
        nshSpiSelector.setPropertyValue("nshSpi", nshSpiId);
    } catch (Exception e) {
        log.error("Failed to set extension selector to match Nsh Spi Id for encap rule {}", e.getMessage());
    }
    try {
        nshSiSelector.setPropertyValue("nshSi", NshServiceIndex.of(nshSi));
    } catch (Exception e) {
        log.error("Failed to set extension selector to match Nsh Si Id for encap rule {}", e.getMessage());
    }
    try {
        nshEncapEthTypeSelector.setPropertyValue("encapEthType", ENCAP_ETH_TYPE);
    } catch (Exception e) {
        log.error("Failed to set extension selector to match Nsh Si Id {}", deviceId);
    }
    TrafficSelector.Builder selector = DefaultTrafficSelector.builder();
    selector.extension(nshSpiSelector, deviceId);
    selector.extension(nshSiSelector, deviceId);
    ExtensionTreatmentResolver treatmentResolver = handler.behaviour(ExtensionTreatmentResolver.class);
    ExtensionTreatment encapEthSrcTreatment = treatmentResolver.getExtensionInstruction(NICIRA_ENCAP_ETH_SRC.type());
    ExtensionTreatment encapEthDstTreatment = treatmentResolver.getExtensionInstruction(NICIRA_ENCAP_ETH_DST.type());
    try {
        encapEthDstTreatment.setPropertyValue("encapEthDst", srcMacAddress);
    } catch (Exception e) {
        log.error("Failed to set extension treatment to set encap eth dst {}", deviceId);
    }
    // TODO: move from packet source mac address
    try {
        encapEthSrcTreatment.setPropertyValue("encapEthSrc", srcMacAddress);
    } catch (Exception e) {
        log.error("Failed to set extension treatment to set encap eth src {}", deviceId);
    }
    TrafficTreatment.Builder treatment = DefaultTrafficTreatment.builder();
    treatment.extension(encapEthSrcTreatment, deviceId);
    treatment.extension(encapEthDstTreatment, deviceId);
    treatment.setOutput(port);
    sendSfcRule(selector, treatment, deviceId, type, ENCAP_OUTPUT_PRIORITY);
    forwarderList.add(deviceId);
}
#end_block

#method_before
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        NiciraResubmit resubmit = (NiciraResubmit) extensionTreatment;
        return factory.actions().niciraResubmit((int) resubmit.inPort().toLong(), resubmit.table());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        NiciraResubmitTable resubmitTable = (NiciraResubmitTable) extensionTreatment;
        return factory.actions().niciraResubmitTable((int) resubmitTable.inPort().toLong(), resubmitTable.table());
    }
    /*
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
            NiciraSetNshSpi niciraNshSpi = (NiciraSetNshSpi) extensionTreatment;
            return factory.actions().setField(factory.oxms().nsp(U32.of(niciraNshSpi.nshSpi().servicePathId())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
            NiciraSetNshSi niciraNshSi = (NiciraSetNshSi) extensionTreatment;
            return factory.actions().setField(factory.oxms().nsi(U8.of(niciraNshSi.nshSi().serviceIndex())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
            NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
            return factory.actions().setField(factory.oxms().nshC1(U32.of(niciraNshch.nshCh().nshContextHeader())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type())) {
            NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
            return factory.actions().setField(factory.oxms().nshC2(U32.of(niciraNshch.nshCh().nshContextHeader())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type())) {
            NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
            return factory.actions().setField(factory.oxms().nshC3(U32.of(niciraNshch.nshCh().nshContextHeader())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
            NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
            return factory.actions().setField(factory.oxms().nshC4(U32.of(niciraNshch.nshCh().nshContextHeader())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NSH_MDTYPE.type())) {
            NiciraNshMdType niciraNshMdType = (NiciraNshMdType) extensionTreatment;
            return factory.actions().setField(factory.oxms().nshMdtype(U8.of(niciraNshMdType.nshMdType())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NSH_NP.type())) {
            NiciraNshNp niciraNshNp = (NiciraNshNp) extensionTreatment;
            return factory.actions().setField(factory.oxms().nshNp(U8.of(niciraNshNp.nshNp())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_SRC.type())) {
            NiciraEncapEthSrc niciraEncapEthSrc = (NiciraEncapEthSrc) extensionTreatment;
            return factory.actions().setField(factory.oxms().encapEthSrc(MacAddress.of(niciraEncapEthSrc.encapEthSrc()
                    .toBytes())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_DST.type())) {
            NiciraEncapEthDst niciraEncapEthDst = (NiciraEncapEthDst) extensionTreatment;
            return factory.actions().setField(factory.oxms().encapEthDst(MacAddress.of(niciraEncapEthDst.encapEthDst()
                    .toBytes())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_TYPE.type())) {
            NiciraEncapEthType niciraEncapEthType = (NiciraEncapEthType) extensionTreatment;
            return factory.actions().setField(factory.oxms().encapEthType(U16.of(niciraEncapEthType.encapEthType())));
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_PUSH_NSH.type())) {
            return factory.actions().niciraPushNsh();
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_POP_NSH.type())) {
            return factory.actions().niciraPopNsh();
        }
        if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_TUN_GPE_NP.type())) {
            NiciraTunGpeNp niciraTunGpeNp = (NiciraTunGpeNp) extensionTreatment;
            return factory.actions().setField(factory.oxms().tunGpeNp(U8.of(niciraTunGpeNp.tunGpeNp())));
        } */
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C1_TO_C1.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C2_TO_C2.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C3_TO_C3.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C4_TO_C4.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_IPV4_DST_TO_TUN_IPV4_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_ID_TO_TUN_ID.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C2_TO_TUN_ID.type())) {
        MoveExtensionTreatment mov = (MoveExtensionTreatment) extensionTreatment;
        OFActionNiciraMove.Builder action = factory.actions().buildNiciraMove();
        action.setDstOfs(mov.dstOffset());
        action.setSrcOfs(mov.srcOffset());
        action.setNBits(mov.nBits());
        action.setSrc(mov.src());
        action.setDst(mov.dst());
        return action.build();
    }
    return null;
}
#method_after
@Override
public OFAction mapInstruction(OFFactory factory, ExtensionTreatment extensionTreatment) {
    ExtensionTreatmentType type = extensionTreatment.type();
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_TUNNEL_DST.type())) {
        NiciraSetTunnelDst tunnelDst = (NiciraSetTunnelDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunnelIpv4Dst(IPv4Address.of(tunnelDst.tunnelDst().toInt())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT.type())) {
        NiciraResubmit resubmit = (NiciraResubmit) extensionTreatment;
        return factory.actions().niciraResubmit((int) resubmit.inPort().toLong(), resubmit.table());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_RESUBMIT_TABLE.type())) {
        NiciraResubmitTable resubmitTable = (NiciraResubmitTable) extensionTreatment;
        return factory.actions().niciraResubmitTable((int) resubmitTable.inPort().toLong(), resubmitTable.table());
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SPI.type())) {
        NiciraSetNshSpi niciraNshSpi = (NiciraSetNshSpi) extensionTreatment;
        return factory.actions().setField(factory.oxms().nsp(U32.of(niciraNshSpi.nshSpi().servicePathId())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_SI.type())) {
        NiciraSetNshSi niciraNshSi = (NiciraSetNshSi) extensionTreatment;
        return factory.actions().setField(factory.oxms().nsi(U8.of(niciraNshSi.nshSi().serviceIndex())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC1(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC2(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC3(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type())) {
        NiciraSetNshContextHeader niciraNshch = (NiciraSetNshContextHeader) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshC4(U32.of(niciraNshch.nshCh().nshContextHeader())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NSH_MDTYPE.type())) {
        NiciraNshMdType niciraNshMdType = (NiciraNshMdType) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshMdtype(U8.of(niciraNshMdType.nshMdType())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_NSH_NP.type())) {
        NiciraNshNp niciraNshNp = (NiciraNshNp) extensionTreatment;
        return factory.actions().setField(factory.oxms().nshNp(U8.of(niciraNshNp.nshNp())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_SRC.type())) {
        NiciraEncapEthSrc niciraEncapEthSrc = (NiciraEncapEthSrc) extensionTreatment;
        return factory.actions().setField(factory.oxms().encapEthSrc(MacAddress.of(niciraEncapEthSrc.encapEthSrc().toBytes())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_DST.type())) {
        NiciraEncapEthDst niciraEncapEthDst = (NiciraEncapEthDst) extensionTreatment;
        return factory.actions().setField(factory.oxms().encapEthDst(MacAddress.of(niciraEncapEthDst.encapEthDst().toBytes())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_ENCAP_ETH_TYPE.type())) {
        NiciraEncapEthType niciraEncapEthType = (NiciraEncapEthType) extensionTreatment;
        return factory.actions().setField(factory.oxms().encapEthType(U16.of(niciraEncapEthType.encapEthType())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_PUSH_NSH.type())) {
        return factory.actions().niciraPushNsh();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_POP_NSH.type())) {
        return factory.actions().niciraPopNsh();
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_TUN_GPE_NP.type())) {
        NiciraTunGpeNp niciraTunGpeNp = (NiciraTunGpeNp) extensionTreatment;
        return factory.actions().setField(factory.oxms().tunGpeNp(U8.of(niciraTunGpeNp.tunGpeNp())));
    }
    if (type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SHA_TO_THA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ARP_SPA_TO_TPA.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_ETH_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_IP_SRC_TO_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C1_TO_C1.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C2_TO_C2.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C3_TO_C3.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C4_TO_C4.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_IPV4_DST_TO_TUN_IPV4_DST.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_TUN_ID_TO_TUN_ID.type()) || type.equals(ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_MOV_NSH_C2_TO_TUN_ID.type())) {
        MoveExtensionTreatment mov = (MoveExtensionTreatment) extensionTreatment;
        OFActionNiciraMove.Builder action = factory.actions().buildNiciraMove();
        action.setDstOfs(mov.dstOffset());
        action.setSrcOfs(mov.srcOffset());
        action.setNBits(mov.nBits());
        action.setSrc(mov.src());
        action.setDst(mov.dst());
        return action.build();
    }
    return null;
}
#end_block

#method_before
@Override
public ExtensionTreatment mapAction(OFAction action) throws UnsupportedOperationException {
    if (action.getType().equals(OFActionType.SET_FIELD)) {
        OFActionSetField setFieldAction = (OFActionSetField) action;
        OFOxm<?> oxm = setFieldAction.getField();
        switch(oxm.getMatchField().id) {
            case TUNNEL_IPV4_DST:
                OFOxmTunnelIpv4Dst tunnelIpv4Dst = (OFOxmTunnelIpv4Dst) oxm;
                return new NiciraSetTunnelDst(Ip4Address.valueOf(tunnelIpv4Dst.getValue().getInt()));
            /*
            case NSP:
                OFOxmNsp nsp = (OFOxmNsp) oxm;
                return new NiciraSetNshSpi(NshServicePathId.of((nsp.getValue().getRaw())));
            case NSI:
                OFOxmNsi nsi = (OFOxmNsi) oxm;
                return new NiciraSetNshSi(NshServiceIndex.of((nsi.getValue().getRaw())));
            case NSH_C1:
                OFOxmNshC1 nshC1 = (OFOxmNshC1) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC1.getValue().getRaw())),
                                                     ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1
                                                     .type());
            case NSH_C2:
                OFOxmNshC2 nshC2 = (OFOxmNshC2) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC2.getValue().getRaw())),
                                                     ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2
                                                     .type());
            case NSH_C3:
                OFOxmNshC3 nshC3 = (OFOxmNshC3) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC3.getValue().getRaw())),
                                                     ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3
                                                     .type());
            case NSH_C4:
                OFOxmNshC4 nshC4 = (OFOxmNshC4) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC4.getValue().getRaw())),
                                                     ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4
                                                     .type());
            case NSH_MDTYPE:
                OFOxmNshMdtype nshMdType = (OFOxmNshMdtype) oxm;
                return new NiciraNshMdType((nshMdType.getValue().getRaw()));
            case NSH_NP:
                OFOxmNshNp nshNp = (OFOxmNshNp) oxm;
                return new NiciraNshNp((nshNp.getValue().getRaw()));
            case ENCAP_ETH_SRC:
                OFOxmEncapEthSrc encapEthSrc = (OFOxmEncapEthSrc) oxm;
                return new NiciraEncapEthSrc(org.onlab.packet.MacAddress.valueOf((encapEthSrc.getValue().getBytes())));
            case ENCAP_ETH_DST:
                OFOxmEncapEthDst encapEthDst = (OFOxmEncapEthDst) oxm;
                return new NiciraEncapEthDst(org.onlab.packet.MacAddress.valueOf((encapEthDst.getValue().getBytes())));
            case ENCAP_ETH_TYPE:
                OFOxmEncapEthType encapEthType = (OFOxmEncapEthType) oxm;
                return new NiciraEncapEthType((encapEthType.getValue().getRaw()));
            case TUN_GPE_NP:
                OFOxmTunGpeNp tunGpeNp = (OFOxmTunGpeNp) oxm;
                return new NiciraTunGpeNp((tunGpeNp.getValue().getRaw()));
            */
            default:
                throw new UnsupportedOperationException("Driver does not support extension type " + oxm.getMatchField().id);
        }
    }
    if (action.getType().equals(OFActionType.EXPERIMENTER)) {
        OFActionExperimenter experimenter = (OFActionExperimenter) action;
        if (Long.valueOf(experimenter.getExperimenter()).intValue() == TYPE_NICIRA) {
            OFActionNicira nicira = (OFActionNicira) experimenter;
            switch(nicira.getSubtype()) {
                case SUB_TYPE_MOVE:
                    OFActionNiciraMove moveAction = (OFActionNiciraMove) nicira;
                    switch(Long.valueOf(moveAction.getSrc()).intValue()) {
                        case SRC_ARP_SHA:
                            return NiciraMoveTreatmentFactory.createNiciraMovArpShaToTha();
                        case SRC_ETH:
                            return NiciraMoveTreatmentFactory.createNiciraMovEthSrcToDst();
                        case SRC_IP:
                            return NiciraMoveTreatmentFactory.createNiciraMovIpSrcToDst();
                        case SRC_ARP_SPA:
                            return NiciraMoveTreatmentFactory.createNiciraMovArpSpaToTpa();
                        case NSH_C1:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC1ToC1();
                        case NSH_C2:
                            if (Long.valueOf(moveAction.getDst()).intValue() == TUN_ID) {
                                return NiciraMoveTreatmentFactory.createNiciraMovNshC2ToTunId();
                            }
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC2ToC2();
                        case NSH_C3:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC3ToC3();
                        case NSH_C4:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC4ToC4();
                        case TUN_IPV4_DST:
                            return NiciraMoveTreatmentFactory.createNiciraMovTunDstToTunDst();
                        case TUN_ID:
                            return NiciraMoveTreatmentFactory.createNiciraMovTunIdToTunId();
                        default:
                            throw new UnsupportedOperationException("Driver does not support move from " + moveAction.getSrc() + " to " + moveAction.getDst() + "of length " + moveAction.getNBits());
                    }
                case SUB_TYPE_RESUBMIT:
                    OFActionNiciraResubmit resubmitAction = (OFActionNiciraResubmit) nicira;
                    return new NiciraResubmit(PortNumber.portNumber(resubmitAction.getInPort()));
                case SUB_TYPE_PUSH_NSH:
                    return new NiciraPushNsh();
                case SUB_TYPE_POP_NSH:
                    return new NiciraPopNsh();
                case SUB_TYPE_RESUBMIT_TABLE:
                    OFActionNiciraResubmitTable resubmitTable = (OFActionNiciraResubmitTable) nicira;
                    return new NiciraResubmitTable(PortNumber.portNumber(resubmitTable.getInPort()), resubmitTable.getTable());
                default:
                    throw new UnsupportedOperationException("Driver does not support extension subtype " + nicira.getSubtype());
            }
        }
    }
    return null;
}
#method_after
@Override
public ExtensionTreatment mapAction(OFAction action) throws UnsupportedOperationException {
    if (action.getType().equals(OFActionType.SET_FIELD)) {
        OFActionSetField setFieldAction = (OFActionSetField) action;
        OFOxm<?> oxm = setFieldAction.getField();
        switch(oxm.getMatchField().id) {
            case TUNNEL_IPV4_DST:
                OFOxmTunnelIpv4Dst tunnelIpv4Dst = (OFOxmTunnelIpv4Dst) oxm;
                return new NiciraSetTunnelDst(Ip4Address.valueOf(tunnelIpv4Dst.getValue().getInt()));
            case NSP:
                OFOxmNsp nsp = (OFOxmNsp) oxm;
                return new NiciraSetNshSpi(NshServicePathId.of((nsp.getValue().getRaw())));
            case NSI:
                OFOxmNsi nsi = (OFOxmNsi) oxm;
                return new NiciraSetNshSi(NshServiceIndex.of((nsi.getValue().getRaw())));
            case NSH_C1:
                OFOxmNshC1 nshC1 = (OFOxmNshC1) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC1.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH1.type());
            case NSH_C2:
                OFOxmNshC2 nshC2 = (OFOxmNshC2) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC2.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH2.type());
            case NSH_C3:
                OFOxmNshC3 nshC3 = (OFOxmNshC3) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC3.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH3.type());
            case NSH_C4:
                OFOxmNshC4 nshC4 = (OFOxmNshC4) oxm;
                return new NiciraSetNshContextHeader(NshContextHeader.of((nshC4.getValue().getRaw())), ExtensionTreatmentType.ExtensionTreatmentTypes.NICIRA_SET_NSH_CH4.type());
            case NSH_MDTYPE:
                OFOxmNshMdtype nshMdType = (OFOxmNshMdtype) oxm;
                return new NiciraNshMdType((nshMdType.getValue().getRaw()));
            case NSH_NP:
                OFOxmNshNp nshNp = (OFOxmNshNp) oxm;
                return new NiciraNshNp((nshNp.getValue().getRaw()));
            case ENCAP_ETH_SRC:
                OFOxmEncapEthSrc encapEthSrc = (OFOxmEncapEthSrc) oxm;
                return new NiciraEncapEthSrc(org.onlab.packet.MacAddress.valueOf((encapEthSrc.getValue().getBytes())));
            case ENCAP_ETH_DST:
                OFOxmEncapEthDst encapEthDst = (OFOxmEncapEthDst) oxm;
                return new NiciraEncapEthDst(org.onlab.packet.MacAddress.valueOf((encapEthDst.getValue().getBytes())));
            case ENCAP_ETH_TYPE:
                OFOxmEncapEthType encapEthType = (OFOxmEncapEthType) oxm;
                return new NiciraEncapEthType((encapEthType.getValue().getRaw()));
            case TUN_GPE_NP:
                OFOxmTunGpeNp tunGpeNp = (OFOxmTunGpeNp) oxm;
                return new NiciraTunGpeNp((tunGpeNp.getValue().getRaw()));
            default:
                throw new UnsupportedOperationException("Driver does not support extension type " + oxm.getMatchField().id);
        }
    }
    if (action.getType().equals(OFActionType.EXPERIMENTER)) {
        OFActionExperimenter experimenter = (OFActionExperimenter) action;
        if (Long.valueOf(experimenter.getExperimenter()).intValue() == TYPE_NICIRA) {
            OFActionNicira nicira = (OFActionNicira) experimenter;
            switch(nicira.getSubtype()) {
                case SUB_TYPE_MOVE:
                    OFActionNiciraMove moveAction = (OFActionNiciraMove) nicira;
                    switch(Long.valueOf(moveAction.getSrc()).intValue()) {
                        case SRC_ARP_SHA:
                            return NiciraMoveTreatmentFactory.createNiciraMovArpShaToTha();
                        case SRC_ETH:
                            return NiciraMoveTreatmentFactory.createNiciraMovEthSrcToDst();
                        case SRC_IP:
                            return NiciraMoveTreatmentFactory.createNiciraMovIpSrcToDst();
                        case SRC_ARP_SPA:
                            return NiciraMoveTreatmentFactory.createNiciraMovArpSpaToTpa();
                        case NSH_C1:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC1ToC1();
                        case NSH_C2:
                            if (Long.valueOf(moveAction.getDst()).intValue() == TUN_ID) {
                                return NiciraMoveTreatmentFactory.createNiciraMovNshC2ToTunId();
                            }
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC2ToC2();
                        case NSH_C3:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC3ToC3();
                        case NSH_C4:
                            return NiciraMoveTreatmentFactory.createNiciraMovNshC4ToC4();
                        case TUN_IPV4_DST:
                            return NiciraMoveTreatmentFactory.createNiciraMovTunDstToTunDst();
                        case TUN_ID:
                            return NiciraMoveTreatmentFactory.createNiciraMovTunIdToTunId();
                        default:
                            throw new UnsupportedOperationException("Driver does not support move from " + moveAction.getSrc() + " to " + moveAction.getDst() + "of length " + moveAction.getNBits());
                    }
                case SUB_TYPE_RESUBMIT:
                    OFActionNiciraResubmit resubmitAction = (OFActionNiciraResubmit) nicira;
                    return new NiciraResubmit(PortNumber.portNumber(resubmitAction.getInPort()));
                case SUB_TYPE_PUSH_NSH:
                    return new NiciraPushNsh();
                case SUB_TYPE_POP_NSH:
                    return new NiciraPopNsh();
                case SUB_TYPE_RESUBMIT_TABLE:
                    OFActionNiciraResubmitTable resubmitTable = (OFActionNiciraResubmitTable) nicira;
                    return new NiciraResubmitTable(PortNumber.portNumber(resubmitTable.getInPort()), resubmitTable.getTable());
                default:
                    throw new UnsupportedOperationException("Driver does not support extension subtype " + nicira.getSubtype());
            }
        }
    }
    return null;
}
#end_block

