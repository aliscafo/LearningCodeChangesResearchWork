236
#method_before
@Override
public void onCreate() {
    if (DEBUG)
        Log.d(mTag, "onCreate");
    super.onCreate();
    if (getApplication() instanceof SystemUIApplication) {
        final SystemUIApplication app = (SystemUIApplication) getApplication();
        mHost = app.getComponent(DozeHost.class);
    }
    if (mHost == null)
        Log.w(TAG, "No doze service host found.");
    setWindowless(true);
    mSensors = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);
    mUseAccelerometer = mDozeParameters.setUsingAccelerometerAsSensorPickUp();
    if (!mUseAccelerometer) {
        mSigMotionSensor = new TriggerSensor(Sensor.TYPE_SIGNIFICANT_MOTION, mDozeParameters.getPulseOnSigMotion(), mDozeParameters.getVibrateOnSigMotion());
        mPickupSensor = new TriggerSensor(Sensor.TYPE_PICK_UP_GESTURE, mDozeParameters.getPulseOnPickup(), mDozeParameters.getVibrateOnPickup());
    } else {
        mShakeThreshold = mDozeParameters.getShakeAccelerometerThreshold();
        mProximitySensorManager = new ProximitySensorManager(mContext, this);
        mShakeSensorManager = new ShakeSensorManager(mContext, this);
    }
    mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, mTag);
    mWakeLock.setReferenceCounted(true);
    mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
    mDisplayStateSupported = mDozeParameters.getDisplayStateSupported();
    mUiModeManager = (UiModeManager) mContext.getSystemService(Context.UI_MODE_SERVICE);
    turnDisplayOff();
}
#method_after
@Override
public void onCreate() {
    if (DEBUG)
        Log.d(mTag, "onCreate");
    super.onCreate();
    if (getApplication() instanceof SystemUIApplication) {
        final SystemUIApplication app = (SystemUIApplication) getApplication();
        mHost = app.getComponent(DozeHost.class);
    }
    if (mHost == null)
        Log.w(TAG, "No doze service host found.");
    setWindowless(true);
    mSensors = (SensorManager) mContext.getSystemService(Context.SENSOR_SERVICE);
    mUseAccelerometer = mDozeParameters.setUsingAccelerometerAsSensorPickUp();
    if (!mUseAccelerometer) {
        mSigMotionSensor = new TriggerSensor(Sensor.TYPE_SIGNIFICANT_MOTION, mDozeParameters.getPulseOnSigMotion(), mDozeParameters.getVibrateOnSigMotion());
        mPickupSensor = new TriggerSensor(Sensor.TYPE_PICK_UP_GESTURE, mDozeParameters.getPulseOnPickup(), mDozeParameters.getVibrateOnPickup());
    } else {
        mProximitySensorManager = new ProximitySensorManager(mContext, this);
        mShakeSensorManager = new ShakeSensorManager(mContext, this);
    }
    mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, mTag);
    mWakeLock.setReferenceCounted(true);
    mAlarmManager = (AlarmManager) mContext.getSystemService(Context.ALARM_SERVICE);
    mDisplayStateSupported = mDozeParameters.getDisplayStateSupported();
    mUiModeManager = (UiModeManager) mContext.getSystemService(Context.UI_MODE_SERVICE);
    turnDisplayOff();
}
#end_block

#method_before
@Override
public synchronized void onShake() {
    startPulsingFromSensor();
}
#method_after
@Override
public synchronized void onShake() {
    if (mDozeParameters.getPocketMode()) {
        startPulsingFromSensor();
    } else {
        requestPulse();
    }
}
#end_block

#method_before
@Override
public synchronized void onNear() {
    if (mIsFar) {
        mIsFar = false;
        mShakeSensorManager.disable();
    }
}
#method_after
@Override
public synchronized void onNear() {
    if (mIsFar) {
        mIsFar = false;
        if (mDozeParameters.getShakeMode()) {
            mShakeSensorManager.disable();
        }
    }
}
#end_block

#method_before
@Override
public synchronized void onFar() {
    if (!mIsFar) {
        mIsFar = true;
        mShakeSensorManager.enable(mShakeThreshold);
        startPulsingFromSensor();
    }
}
#method_after
@Override
public synchronized void onFar() {
    if (!mIsFar) {
        mIsFar = true;
        if (mDozeParameters.getShakeMode()) {
            mShakeSensorManager.enable(mDozeParameters.getShakeAccelerometerThreshold());
        }
        startPulsingFromSensor();
    }
}
#end_block

#method_before
private void requestPulse() {
    if (mHost != null && mDreaming && !mPulsing) {
        // Let the host know we want to pulse.  Wait for it to be ready, then
        // turn the screen on.  When finished, turn the screen off again.
        // Here we need a wakelock to stay awake until the pulse is finished.
        mWakeLock.acquire();
        mPulsing = true;
        final long start = SystemClock.uptimeMillis();
        new ProximityCheck() {

            @Override
            public void onProximityResult(int result) {
                // avoid pulsing in pockets
                final boolean isNear = result == RESULT_NEAR;
                DozeLog.traceProximityResult(isNear, SystemClock.uptimeMillis() - start);
                if (isNear) {
                    mPulsing = false;
                    mWakeLock.release();
                    return;
                }
                // not in-pocket, continue pulsing
                mHost.pulseWhileDozing(new DozeHost.PulseCallback() {

                    @Override
                    public void onPulseStarted() {
                        if (mPulsing && mDreaming) {
                            turnDisplayOn();
                        }
                    }

                    @Override
                    public void onPulseFinished() {
                        if (mPulsing && mDreaming) {
                            mPulsing = false;
                            turnDisplayOff();
                        }
                        // needs to be unconditional to balance acquire
                        mWakeLock.release();
                    }
                });
            }
        }.check();
    }
}
#method_after
private void requestPulse() {
    if (mHost != null && mDreaming && !mPulsing) {
        // Let the host know we want to pulse.  Wait for it to be ready, then
        // turn the screen on.  When finished, turn the screen off again.
        // Here we need a wakelock to stay awake until the pulse is finished.
        mWakeLock.acquire();
        mPulsing = true;
        final long start = SystemClock.uptimeMillis();
        new ProximityCheck() {

            @Override
            public void onProximityResult(int result) {
                // avoid pulsing in pockets
                final boolean isNear = result == RESULT_NEAR;
                final boolean isAccSensor = mUseAccelerometer && mDozeParameters.getShakeMode();
                DozeLog.traceProximityResult(isNear, SystemClock.uptimeMillis() - start);
                if (isNear) {
                    mPulsing = false;
                    mWakeLock.release();
                    if (isAccSensor) {
                        mShakeSensorManager.disable();
                    }
                    return;
                }
                if (isAccSensor) {
                    mShakeSensorManager.enable(mDozeParameters.getShakeAccelerometerThreshold());
                }
                // not in-pocket, continue pulsing
                mHost.pulseWhileDozing(new DozeHost.PulseCallback() {

                    @Override
                    public void onPulseStarted() {
                        if (mPulsing && mDreaming) {
                            turnDisplayOn();
                        }
                    }

                    @Override
                    public void onPulseFinished() {
                        if (mPulsing && mDreaming) {
                            mPulsing = false;
                            turnDisplayOff();
                        }
                        // needs to be unconditional to balance acquire
                        mWakeLock.release();
                    }
                });
            }
        }.check();
    }
}
#end_block

#method_before
private void listenForSignalsSensor(boolean listen) {
    if (listen) {
        mProximitySensorManager.enable();
    } else {
        mProximitySensorManager.disable(true);
    }
}
#method_after
private void listenForSignalsSensor(boolean listen) {
    if (listen && mDozeParameters.getFullMode()) {
        mProximitySensorManager.enable();
    } else {
        // its safe to call this everytime
        mProximitySensorManager.disable(true);
        mShakeSensorManager.disable();
    }
}
#end_block

#method_before
public void check() {
    if (mFinished || mRegistered)
        return;
    final Sensor sensor = mSensors.getDefaultSensor(Sensor.TYPE_PROXIMITY);
    if (sensor == null) {
        if (DEBUG)
            Log.d(mTag, "No sensor found");
        finishWithResult(RESULT_UNKNOWN);
        return;
    }
    // the pickup sensor interferes with the prox event, disable it until we have a result
    mPickupSensor.setDisabled(true);
    mMaxRange = sensor.getMaximumRange();
    mSensors.registerListener(this, sensor, SensorManager.SENSOR_DELAY_NORMAL, 0, mHandler);
    mHandler.postDelayed(this, TIMEOUT_DELAY_MS);
    mRegistered = true;
}
#method_after
public void check() {
    if (mFinished || mRegistered)
        return;
    final Sensor sensor = mSensors.getDefaultSensor(Sensor.TYPE_PROXIMITY);
    if (sensor == null) {
        if (DEBUG)
            Log.d(mTag, "No sensor found");
        finishWithResult(RESULT_UNKNOWN);
        return;
    }
    // the pickup sensor interferes with the prox event, disable it until we have a result
    if (!mUseAccelerometer) {
        mPickupSensor.setDisabled(true);
    }
    mMaxRange = sensor.getMaximumRange();
    mSensors.registerListener(this, sensor, SensorManager.SENSOR_DELAY_NORMAL, 0, mHandler);
    mHandler.postDelayed(this, TIMEOUT_DELAY_MS);
    mRegistered = true;
}
#end_block

#method_before
private void finishWithResult(int result) {
    if (mFinished)
        return;
    if (mRegistered) {
        mHandler.removeCallbacks(this);
        mSensors.unregisterListener(this);
        // we're done - reenable the pickup sensor
        mPickupSensor.setDisabled(false);
        mRegistered = false;
    }
    onProximityResult(result);
    mFinished = true;
}
#method_after
private void finishWithResult(int result) {
    if (mFinished)
        return;
    if (mRegistered) {
        mHandler.removeCallbacks(this);
        mSensors.unregisterListener(this);
        // we're done - reenable the pickup sensor
        if (!mUseAccelerometer) {
            mPickupSensor.setDisabled(false);
        }
        mRegistered = false;
    }
    onProximityResult(result);
    mFinished = true;
}
#end_block

#method_before
public int getPulseInDuration() {
    return getInt("doze.pulse.duration.in", R.integer.doze_pulse_duration_in);
}
#method_after
public int getPulseInDuration() {
    if (getOverwriteValue()) {
        return Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.DOZE_PULSE_DURATION_IN, R.integer.doze_pulse_duration_in, UserHandle.USER_CURRENT);
    }
    return getInt("doze.pulse.duration.in", R.integer.doze_pulse_duration_in);
}
#end_block

#method_before
public int getPulseVisibleDuration() {
    return getInt("doze.pulse.duration.visible", R.integer.doze_pulse_duration_visible);
}
#method_after
public int getPulseVisibleDuration() {
    if (getOverwriteValue()) {
        return Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.DOZE_PULSE_DURATION_VISIBLE, R.integer.doze_pulse_duration_visible, UserHandle.USER_CURRENT);
    }
    return getInt("doze.pulse.duration.visible", R.integer.doze_pulse_duration_visible);
}
#end_block

#method_before
public int getPulseOutDuration() {
    return getInt("doze.pulse.duration.out", R.integer.doze_pulse_duration_out);
}
#method_after
public int getPulseOutDuration() {
    if (getOverwriteValue()) {
        return Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.DOZE_PULSE_DURATION_OUT, R.integer.doze_pulse_duration_out, UserHandle.USER_CURRENT);
    }
    return getInt("doze.pulse.duration.out", R.integer.doze_pulse_duration_out);
}
#end_block

#method_before
public boolean getPulseOnNotifications() {
    return getBoolean("doze.pulse.notifications", R.bool.doze_pulse_on_notifications);
}
#method_after
public boolean getPulseOnNotifications() {
    if (getOverwriteValue() || setUsingAccelerometerAsSensorPickUp()) {
        final int values = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.DOZE_PULSE_ON_NOTIFICATIONS, 1, UserHandle.USER_CURRENT);
        return values != 0;
    }
    return getBoolean("doze.pulse.notifications", R.bool.doze_pulse_on_notifications);
}
#end_block

#method_before
public int getShakeAccelerometerThreshold() {
    return getInt("doze.shake.acc.threshold", R.integer.doze_shake_accelerometer_threshold);
}
#method_after
public int getShakeAccelerometerThreshold() {
    if (getOverwriteValue()) {
        return Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.DOZE_SHAKE_ACC_THRESHOLD, R.integer.doze_shake_accelerometer_threshold, UserHandle.USER_CURRENT);
    }
    return getInt("doze.shake.acc.threshold", R.integer.doze_shake_accelerometer_threshold);
}
#end_block

#method_before
@Override
protected void onFinishInflate() {
    mPasswordEntry = (PasswordTextView) findViewById(getPasswordTextViewId());
    mPasswordEntry.setOnKeyListener(this);
    // Set selected property on so the view can send accessibility events.
    mPasswordEntry.setSelected(true);
    // Poke the wakelock any time the text is selected or modified
    mPasswordEntry.setOnClickListener(new OnClickListener() {

        public void onClick(View v) {
            mCallback.userActivity();
        }
    });
    final boolean quickUnlockEnabled = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.KEYGUARD_QUICK_UNLOCK, 0, UserHandle.USER_CURRENT) == 1;
    if (quickUnlockEnabled) {
        mPasswordEntry.setChangeListener(new PasswordTextView.ChangeListener() {

            public void onPasswordChanged() {
                quickVerifyPasswordAndUnlock();
            }
        });
    }
    mOkButton = findViewById(R.id.key_enter);
    if (mOkButton != null) {
        mOkButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                doHapticKeyClick();
                if (mPasswordEntry.isEnabled()) {
                    verifyPasswordAndUnlock();
                }
            }
        });
        mOkButton.setOnHoverListener(new LiftToActivateListener(getContext()));
    }
    final int randomDigitMode = Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.LOCK_NUMPAD_RANDOM, 0, UserHandle.USER_CURRENT);
    if (randomDigitMode > 0) {
        final View randomButton = findViewById(R.id.key_random);
        if (randomDigitMode == 1) {
            buildRandomNumPadKey();
        }
        if (randomButton != null) {
            randomButton.setVisibility(View.VISIBLE);
            randomButton.setOnClickListener(new View.OnClickListener() {

                @Override
                public void onClick(View v) {
                    doHapticKeyClick();
                    buildRandomNumPadKey();
                }
            });
        }
    }
    mDeleteButton = findViewById(R.id.delete_button);
    mDeleteButton.setVisibility(View.VISIBLE);
    mDeleteButton.setOnClickListener(new OnClickListener() {

        public void onClick(View v) {
            // check for time-based lockouts
            if (mPasswordEntry.isEnabled()) {
                mPasswordEntry.deleteLastChar();
            }
            doHapticKeyClick();
        }
    });
    mDeleteButton.setOnLongClickListener(new View.OnLongClickListener() {

        public boolean onLongClick(View v) {
            // check for time-based lockouts
            if (mPasswordEntry.isEnabled()) {
                resetPasswordText(true);
            }
            doHapticKeyClick();
            return true;
        }
    });
    mButton0 = findViewById(R.id.key0);
    mButton1 = findViewById(R.id.key1);
    mButton2 = findViewById(R.id.key2);
    mButton3 = findViewById(R.id.key3);
    mButton4 = findViewById(R.id.key4);
    mButton5 = findViewById(R.id.key5);
    mButton6 = findViewById(R.id.key6);
    mButton7 = findViewById(R.id.key7);
    mButton8 = findViewById(R.id.key8);
    mButton9 = findViewById(R.id.key9);
    mPasswordEntry.requestFocus();
    super.onFinishInflate();
}
#method_after
@Override
protected void onFinishInflate() {
    mPasswordEntry = (PasswordTextView) findViewById(getPasswordTextViewId());
    mPasswordEntry.setOnKeyListener(this);
    // Set selected property on so the view can send accessibility events.
    mPasswordEntry.setSelected(true);
    // Poke the wakelock any time the text is selected or modified
    mPasswordEntry.setOnClickListener(new OnClickListener() {

        public void onClick(View v) {
            mCallback.userActivity();
        }
    });
    final boolean quickUnlockEnabled = Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.KEYGUARD_QUICK_UNLOCK, 0, UserHandle.USER_CURRENT) == 1;
    if (quickUnlockEnabled) {
        mPasswordEntry.setChangeListener(new PasswordTextView.ChangeListener() {

            public void onPasswordChanged() {
                quickVerifyPasswordAndUnlock();
            }
        });
    }
    mOkButton = findViewById(R.id.key_enter);
    if (mOkButton != null) {
        mOkButton.setOnClickListener(new View.OnClickListener() {

            @Override
            public void onClick(View v) {
                doHapticKeyClick();
                if (mPasswordEntry.isEnabled()) {
                    verifyPasswordAndUnlock();
                }
            }
        });
        mOkButton.setOnHoverListener(new LiftToActivateListener(getContext()));
    }
    final int randomDigitMode = Settings.Secure.getIntForUser(mContext.getContentResolver(), Settings.Secure.LOCK_NUMPAD_RANDOM, 0, UserHandle.USER_CURRENT);
    if (randomDigitMode > 0) {
        final View randomButton = findViewById(R.id.key_random);
        if (randomDigitMode == 1) {
            buildRandomNumPadKey();
        }
        if (randomButton != null) {
            randomButton.setVisibility(View.VISIBLE);
            randomButton.setOnClickListener(new View.OnClickListener() {

                @Override
                public void onClick(View v) {
                    doHapticKeyClick();
                    buildRandomNumPadKey();
                }
            });
        }
    }
    mDeleteButton = findViewById(R.id.delete_button);
    mDeleteButton.setVisibility(View.VISIBLE);
    mDeleteButton.setOnClickListener(new OnClickListener() {

        public void onClick(View v) {
            // check for time-based lockouts
            if (mPasswordEntry.isEnabled()) {
                mPasswordEntry.deleteLastChar();
            }
            doHapticKeyClick();
        }
    });
    mDeleteButton.setOnLongClickListener(new View.OnLongClickListener() {

        public boolean onLongClick(View v) {
            // check for time-based lockouts
            if (mPasswordEntry.isEnabled()) {
                resetPasswordText(true);
            }
            doHapticKeyClick();
            return true;
        }
    });
    mButton0 = findViewById(R.id.key0);
    mButton1 = findViewById(R.id.key1);
    mButton2 = findViewById(R.id.key2);
    mButton3 = findViewById(R.id.key3);
    mButton4 = findViewById(R.id.key4);
    mButton5 = findViewById(R.id.key5);
    mButton6 = findViewById(R.id.key6);
    mButton7 = findViewById(R.id.key7);
    mButton8 = findViewById(R.id.key8);
    mButton9 = findViewById(R.id.key9);
    mPasswordEntry.requestFocus();
    super.onFinishInflate();
}
#end_block

#method_before
public static ArrayList<DictionaryInfo> getCurrentDictionaryFileNameAndVersionInfo(final Context context) {
    final ArrayList<DictionaryInfo> dictList = new ArrayList<>();
    // Retrieve downloaded dictionaries
    final File[] directoryList = getCachedDirectoryList(context);
    if (null != directoryList) {
        for (final File directory : directoryList) {
            final String localeString = getWordListIdFromFileName(directory.getName());
            File[] dicts = BinaryDictionaryGetter.getCachedWordLists(localeString, context);
            for (final File dict : dicts) {
                final String wordListId = getWordListIdFromFileName(dict.getName());
                if (!DictionaryInfoUtils.isMainWordListId(wordListId))
                    continue;
                final Locale locale = LocaleUtils.constructLocaleFromString(localeString);
                final AssetFileAddress fileAddress = AssetFileAddress.makeFromFile(dict);
                final DictionaryInfo dictionaryInfo = createDictionaryInfoFromFileAddress(fileAddress);
                // should be used for en_US but discounted for listing purposes.
                if (dictionaryInfo == null || dictionaryInfo.mLocale == null || !dictionaryInfo.mLocale.equals(locale)) {
                    continue;
                }
                addOrUpdateDictInfo(dictList, dictionaryInfo);
            }
        }
    }
    // Retrieve files from assets
    final Resources resources = context.getResources();
    final AssetManager assets = resources.getAssets();
    for (final String localeString : assets.getLocales()) {
        final Locale locale = LocaleUtils.constructLocaleFromString(localeString);
        final int resourceId = DictionaryInfoUtils.getMainDictionaryResourceIdIfAvailableForLocale(context.getResources(), locale);
        if (0 == resourceId)
            continue;
        final AssetFileAddress fileAddress = BinaryDictionaryGetter.loadFallbackResource(context, resourceId);
        final DictionaryInfo dictionaryInfo = createDictionaryInfoFromFileAddress(fileAddress);
        // should be used for en_US but discounted for listing purposes.
        if (dictionaryInfo.mLocale == null || !dictionaryInfo.mLocale.equals(locale))
            continue;
        addOrUpdateDictInfo(dictList, dictionaryInfo);
    }
    return dictList;
}
#method_after
public static ArrayList<DictionaryInfo> getCurrentDictionaryFileNameAndVersionInfo(final Context context) {
    final ArrayList<DictionaryInfo> dictList = new ArrayList<>();
    // Retrieve downloaded dictionaries
    final File[] directoryList = getCachedDirectoryList(context);
    if (null != directoryList) {
        for (final File directory : directoryList) {
            final String localeString = getWordListIdFromFileName(directory.getName());
            File[] dicts = BinaryDictionaryGetter.getCachedWordLists(localeString, context);
            for (final File dict : dicts) {
                final String wordListId = getWordListIdFromFileName(dict.getName());
                if (!DictionaryInfoUtils.isMainWordListId(wordListId))
                    continue;
                final Locale locale = LocaleUtils.constructLocaleFromString(localeString);
                final AssetFileAddress fileAddress = AssetFileAddress.makeFromFile(dict);
                final DictionaryInfo dictionaryInfo = createDictionaryInfoFromFileAddress(fileAddress);
                // should be used for en_US but discounted for listing purposes.
                if (dictionaryInfo == null || dictionaryInfo.mLocale == null || !dictionaryInfo.mLocale.equals(locale)) {
                    continue;
                }
                addOrUpdateDictInfo(dictList, dictionaryInfo);
            }
        }
    }
    // Retrieve files from assets
    final Resources resources = context.getResources();
    final AssetManager assets = resources.getAssets();
    for (final String localeString : assets.getLocales()) {
        final Locale locale = LocaleUtils.constructLocaleFromString(localeString);
        final int resourceId = DictionaryInfoUtils.getMainDictionaryResourceIdIfAvailableForLocale(context.getResources(), locale);
        if (0 == resourceId)
            continue;
        final AssetFileAddress fileAddress = BinaryDictionaryGetter.loadFallbackResource(context, resourceId);
        final DictionaryInfo dictionaryInfo = createDictionaryInfoFromFileAddress(fileAddress);
        // should be used for en_US but discounted for listing purposes.
        if (dictionaryInfo == null || dictionaryInfo.mLocale == null || !dictionaryInfo.mLocale.equals(locale)) {
            continue;
        }
        addOrUpdateDictInfo(dictList, dictionaryInfo);
    }
    return dictList;
}
#end_block

#method_before
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_ACTIVITY_MANAGER_READY) {
        // check our power situation now that it is safe to display the shutdown dialog.
        synchronized (mLock) {
            ContentObserver obs = new ContentObserver(mHandler) {

                @Override
                public void onChange(boolean selfChange) {
                    synchronized (mLock) {
                        updateBatteryWarningLevelLocked();
                    }
                }
            };
            final ContentResolver resolver = mContext.getContentResolver();
            resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL), false, obs, UserHandle.USER_ALL);
            updateBatteryWarningLevelLocked();
        }
    } else if (phase == PHASE_BOOT_COMPLETED) {
        SettingsObserver observer = new SettingsObserver(new Handler());
        observer.observe();
    }
}
#method_after
@Override
public void onBootPhase(int phase) {
    if (phase == PHASE_ACTIVITY_MANAGER_READY) {
        // check our power situation now that it is safe to display the shutdown dialog.
        synchronized (mLock) {
            ContentObserver obs = new ContentObserver(mHandler) {

                @Override
                public void onChange(boolean selfChange) {
                    synchronized (mLock) {
                        updateBatteryWarningLevelLocked();
                    }
                }
            };
            final ContentResolver resolver = mContext.getContentResolver();
            resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL), false, obs, UserHandle.USER_ALL);
            updateBatteryWarningLevelLocked();
        }
    } else if (phase == PHASE_BOOT_COMPLETED) {
        SettingsObserver observer = new SettingsObserver(mHandler);
        observer.observe();
    }
}
#end_block

#method_before
public void updateLightsLocked() {
    final int level = mBatteryProps.batteryLevel;
    final int status = mBatteryProps.batteryStatus;
    if (!mLightEnabled) {
        // No lights if explicitly disabled
        mBatteryLight.turnOff();
    } else if (level < mLowBatteryWarningLevel) {
        if (status == BatteryManager.BATTERY_STATUS_CHARGING) {
            // Solid red when battery is charging
            mBatteryLight.setColor(mBatteryLowARGB);
        } else {
            // Flash red when battery is low and not charging
            mBatteryLight.setFlashing(mBatteryLowARGB, Light.LIGHT_FLASH_TIMED, mBatteryLedOn, mBatteryLedOff);
        }
    } else if (status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL) {
        if (status == BatteryManager.BATTERY_STATUS_FULL || level >= 90) {
            // Solid green when full or charging and nearly full
            mBatteryLight.setColor(mBatteryFullARGB);
        } else {
            // Solid orange when charging and halfway full
            mBatteryLight.setColor(mBatteryMediumARGB);
        }
    } else {
        // No lights if not charging and not low
        mBatteryLight.turnOff();
    }
}
#method_after
public void updateLightsLocked() {
    final int level = mBatteryProps.batteryLevel;
    final int status = mBatteryProps.batteryStatus;
    if (!mLightEnabled) {
        // No lights if explicitly disabled
        mBatteryLight.turnOff();
    } else if (level < mLowBatteryWarningLevel) {
        if (status == BatteryManager.BATTERY_STATUS_CHARGING) {
            // Solid red when battery is charging
            mBatteryLight.setColor(mBatteryLowARGB);
        } else {
            // Flash red when battery is low and not charging
            mBatteryLight.setFlashing(mBatteryLowARGB, Light.LIGHT_FLASH_TIMED, mBatteryLedOn, mBatteryLedOff);
        }
    } else if (status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL) {
        if (status == BatteryManager.BATTERY_STATUS_FULL || level >= 90) {
            if (level == 100) {
                // Battery is really full
                mBatteryLight.setColor(mBatteryReallyFullARGB);
            } else {
                // Battery is full or charging and nearly full
                mBatteryLight.setColor(mBatteryFullARGB);
            }
        } else {
            // Battery is charging and halfway full
            mBatteryLight.setColor(mBatteryMediumARGB);
        }
    } else {
        // No lights if not charging and not low
        mBatteryLight.turnOff();
    }
}
#end_block

#method_before
private void performKeyAction(int behavior) {
    if (DEBUG_INPUT) {
        Slog.d(TAG, "performKeyAction " + behavior);
    }
    switch(behavior) {
        case KEY_ACTION_NOTHING:
            break;
        case KEY_ACTION_MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case KEY_ACTION_BACK:
            triggerVirtualKeypress(KeyEvent.KEYCODE_BACK);
            break;
        case KEY_ACTION_APP_SWITCH:
            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_RECENT_APPS);
            try {
                IStatusBarService statusbar = getStatusBarService();
                if (statusbar != null) {
                    statusbar.toggleRecentApps();
                    mRecentAppsPreloaded = false;
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "RemoteException when showing recent apps", e);
                // re-acquire status bar service next time it is needed.
                mStatusBarService = null;
            }
            break;
        case KEY_ACTION_SEARCH:
            launchAssistAction();
            break;
        case KEY_ACTION_VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case KEY_ACTION_IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case KEY_ACTION_HOME:
            launchHomeFromHotKey();
            break;
        case KEY_ACTION_KILL_APP:
            mHandler.postDelayed(mKillTask, mBackKillTimeout);
            mBackKillPending = true;
            break;
        case KEY_ACTION_LAST_APP:
            TaskUtils.switchToLastApp(mContext, mCurrentUserId);
            break;
        case KEY_ACTION_SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        case KEY_ACTION_OMNISWITCH:
            Intent showIntent = new Intent(OmniSwitchConstants.ACTION_TOGGLE_OVERLAY);
            mContext.sendBroadcastAsUser(showIntent, UserHandle.CURRENT);
            break;
        default:
            break;
    }
}
#method_after
private void performKeyAction(int behavior) {
    if (DEBUG_INPUT) {
        Slog.d(TAG, "performKeyAction " + behavior);
    }
    switch(behavior) {
        case KEY_ACTION_NOTHING:
            break;
        case KEY_ACTION_MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case KEY_ACTION_BACK:
            triggerVirtualKeypress(KeyEvent.KEYCODE_BACK);
            break;
        case KEY_ACTION_APP_SWITCH:
            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_RECENT_APPS);
            try {
                IStatusBarService statusbar = getStatusBarService();
                if (statusbar != null) {
                    statusbar.toggleRecentApps();
                    mRecentAppsPreloaded = false;
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "RemoteException when showing recent apps", e);
                // re-acquire status bar service next time it is needed.
                mStatusBarService = null;
            }
            break;
        case KEY_ACTION_SEARCH:
            launchAssistAction();
            break;
        case KEY_ACTION_VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case KEY_ACTION_IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case KEY_ACTION_HOME:
            launchHomeFromHotKey();
            break;
        case KEY_ACTION_KILL_APP:
            mHandler.postDelayed(mKillTask, mBackKillTimeout);
            mBackKillPending = true;
            break;
        case KEY_ACTION_LAST_APP:
            TaskUtils.toggleLastApp(mContext, mCurrentUserId);
            break;
        case KEY_ACTION_SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        case KEY_ACTION_OMNISWITCH:
            Intent showIntent = new Intent(OmniSwitchConstants.ACTION_TOGGLE_OVERLAY);
            mContext.sendBroadcastAsUser(showIntent, UserHandle.CURRENT);
            break;
        default:
            break;
    }
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENRECORD_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mVolumeUpKeyConsumedByScreenrecordChord) {
            if (!down) {
                mVolumeUpKeyConsumedByScreenrecordChord = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // stop the kill action
    if (mBackKillPending && !down) {
        mHandler.removeCallbacks(mKillTask);
        mBackKillPending = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            if (mRecentAppsPreloaded) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                if (mRingHomeBehavior != 0) {
                    Log.i(TAG, "Answering with HOME button.");
                    telecomManager.acceptRingingCall();
                    return -1;
                } else {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // but don't actually go home.
            if (mDreamManagerInternal != null && mDreamManagerInternal.isDreaming()) {
                mDreamManagerInternal.stopDream(false);
                return -1;
            }
            if (mPressOnHomeBehavior != KEY_ACTION_HOME) {
                performKeyAction(mPressOnHomeBehavior);
            } else {
                launchHomeFromHotKey();
            }
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            if (down) {
                mHomePressed = true;
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeConsumed = true;
                performKeyAction(mDoubleTapOnHomeBehavior);
            } else if (!mRecentAppsPreloaded && (mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehavior == KEY_ACTION_APP_SWITCH || mPressOnHomeBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
                preloadRecentApps();
            }
            if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                mHomeConsumed = true;
                performKeyAction(mLongPressOnHomeBehavior);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcast(intent, null);
                    return -1;
                } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                    Intent service = new Intent();
                    service.setClassName(mContext, "com.android.server.LoadAverageService");
                    ContentResolver res = mContext.getContentResolver();
                    boolean shown = Settings.System.getInt(res, Settings.System.SHOW_PROCESSES, 0) != 0;
                    if (!shown) {
                        mContext.startService(service);
                    } else {
                        mContext.stopService(service);
                    }
                    Settings.System.putInt(res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
                    return -1;
                } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !virtualKey) {
                    mMenuDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnMenuBehavior);
                    // Do not perform action when key is released
                    mMenuDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mMenuDoCustomAction) {
                mMenuDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnMenuBehavior);
                    return -1;
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAppSwitchBehavior);
                    mAppSwitchLongPressed = true;
                }
            }
        } else {
            if (mAppSwitchLongPressed) {
                mAppSwitchLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAssistBehavior);
                    mAssistKeyLongPressed = true;
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAssistBehavior);
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            mContext.startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            mContext.startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnBackBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    mBackDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnBackBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnBackBehavior);
                    // Do not perform action when key is released
                    mBackDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnBackBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnBackBehavior);
                    return -1;
                }
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENRECORD_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mVolumeUpKeyConsumedByScreenrecordChord) {
            if (!down) {
                mVolumeUpKeyConsumedByScreenrecordChord = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // stop the kill action
    if (mBackKillPending && !down) {
        mHandler.removeCallbacks(mKillTask);
        mBackKillPending = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            if (mRecentAppsPreloaded) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                if (mRingHomeBehavior != 0) {
                    Log.i(TAG, "Answering with HOME button.");
                    telecomManager.acceptRingingCall();
                    return -1;
                } else {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // but don't actually go home.
            if (mDreamManagerInternal != null && mDreamManagerInternal.isDreaming()) {
                mDreamManagerInternal.stopDream(false);
                return -1;
            }
            if (mPressOnHomeBehavior != KEY_ACTION_HOME) {
                performKeyAction(mPressOnHomeBehavior);
            } else {
                launchHomeFromHotKey();
            }
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            if (down) {
                mHomePressed = true;
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeConsumed = true;
                performKeyAction(mDoubleTapOnHomeBehavior);
            } else if (!mRecentAppsPreloaded && (mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehavior == KEY_ACTION_APP_SWITCH || mPressOnHomeBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
                preloadRecentApps();
            }
            if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                mHomeConsumed = true;
                performKeyAction(mLongPressOnHomeBehavior);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcast(intent, null);
                    return -1;
                } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                    Intent service = new Intent();
                    service.setClassName(mContext, "com.android.server.LoadAverageService");
                    ContentResolver res = mContext.getContentResolver();
                    boolean shown = Settings.System.getInt(res, Settings.System.SHOW_PROCESSES, 0) != 0;
                    if (!shown) {
                        mContext.startService(service);
                    } else {
                        mContext.stopService(service);
                    }
                    Settings.System.putInt(res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
                    return -1;
                } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !virtualKey) {
                    mMenuDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn) {
                    // check for locked mode
                    if (stopLockTaskMode()) {
                        // Do not perform action when key is released
                        mMenuDoCustomAction = false;
                        return -1;
                    }
                    if (mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mLongPressOnMenuBehavior);
                        // Do not perform action when key is released
                        mMenuDoCustomAction = false;
                        return -1;
                    }
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mMenuDoCustomAction) {
                mMenuDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnMenuBehavior);
                    return -1;
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAppSwitchBehavior);
                    mAppSwitchLongPressed = true;
                }
            }
        } else {
            if (mAppSwitchLongPressed) {
                mAppSwitchLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAssistBehavior);
                    mAssistKeyLongPressed = true;
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAssistBehavior);
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            mContext.startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            mContext.startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnBackBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    mBackDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn) {
                    if (mLongPressOnBackBehavior != KEY_ACTION_NOTHING) {
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mLongPressOnBackBehavior);
                        // Do not perform action when key is released
                        mBackDoCustomAction = false;
                        return -1;
                    }
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnBackBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnBackBehavior);
                    return -1;
                }
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    switch(msg.what) {
        case MSG_START_DOZING:
            handleStartDozing((Runnable) msg.obj);
            break;
        case MSG_PULSE_WHILE_DOZING:
            handlePulseWhileDozing((PulseCallback) msg.obj);
            break;
        case MSG_STOP_DOZING:
            handleStopDozing();
            break;
    }
}
#method_after
public void handleMessage(Message m) {
    super.handleMessage(m);
    switch(m.what) {
        case MSG_OPEN_NOTIFICATION_PANEL:
            animateExpandNotificationsPanel();
            break;
        case MSG_OPEN_SETTINGS_PANEL:
            animateExpandSettingsPanel();
            break;
        case MSG_CLOSE_PANELS:
            animateCollapsePanels();
            break;
        case MSG_SHOW_HEADS_UP:
            setHeadsUpVisibility(true);
            break;
        case MSG_DECAY_HEADS_UP:
            mHeadsUpNotificationView.release();
            setHeadsUpVisibility(false);
            break;
        case MSG_HIDE_HEADS_UP:
            mHeadsUpNotificationView.release();
            setHeadsUpVisibility(false);
            break;
        case MSG_ESCALATE_HEADS_UP:
            escalateHeadsUp();
            setHeadsUpVisibility(false);
            break;
    }
}
#end_block

#method_before
private void handleLongPressBackRecents(View v) {
    try {
        boolean sendBackLongPress = false;
        boolean hijackRecentsLongPress = false;
        IActivityManager activityManager = ActivityManagerNative.getDefault();
        boolean isAccessiblityEnabled = mAccessibilityManager.isEnabled();
        if (activityManager.isInLockTaskMode() && !isAccessiblityEnabled) {
            long time = System.currentTimeMillis();
            // long-pressed 'together'
            if ((time - mLastLockToAppLongPress) < LOCK_TO_APP_GESTURE_TOLERENCE) {
                activityManager.stopLockTaskModeOnCurrent();
            } else if ((v.getId() == R.id.back) && !mNavigationBarView.getRecentsButton().isPressed()) {
                // If we aren't pressing recents right now then they presses
                // won't be together, so send the standard long-press action.
                sendBackLongPress = true;
            } else if ((v.getId() == R.id.recent_apps) && !activityManager.isInLockTaskMode()) {
                hijackRecentsLongPress = true;
            }
            mLastLockToAppLongPress = time;
        } else {
            // If this is back still need to handle sending the long-press event.
            if (v.getId() == R.id.back) {
                sendBackLongPress = true;
            } else if ((v.getId() == R.id.recent_apps) && !activityManager.isInLockTaskMode()) {
                hijackRecentsLongPress = true;
            } else if (isAccessiblityEnabled && activityManager.isInLockTaskMode()) {
                // When in accessibility mode a long press that is recents (not back)
                // should stop lock task.
                activityManager.stopLockTaskModeOnCurrent();
            }
        }
        if (sendBackLongPress) {
            KeyButtonView keyButtonView = (KeyButtonView) v;
            keyButtonView.sendEvent(KeyEvent.ACTION_DOWN, KeyEvent.FLAG_LONG_PRESS);
            keyButtonView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
        }
        if (hijackRecentsLongPress) {
            TaskUtils.switchToLastApp(mContext, mCurrentUserId);
        }
    } catch (RemoteException e) {
        Log.d(TAG, "Unable to reach activity manager", e);
    }
}
#method_after
private void handleLongPressBackRecents(View v) {
    try {
        boolean sendBackLongPress = false;
        boolean hijackRecentsLongPress = false;
        IActivityManager activityManager = ActivityManagerNative.getDefault();
        boolean isAccessiblityEnabled = mAccessibilityManager.isEnabled();
        if (activityManager.isInLockTaskMode() && !isAccessiblityEnabled) {
            long time = System.currentTimeMillis();
            // long-pressed 'together'
            if ((time - mLastLockToAppLongPress) < LOCK_TO_APP_GESTURE_TOLERENCE) {
                activityManager.stopLockTaskModeOnCurrent();
            } else if ((v.getId() == R.id.back) && !mNavigationBarView.getRecentsButton().isPressed()) {
                // If we aren't pressing recents right now then they presses
                // won't be together, so send the standard long-press action.
                sendBackLongPress = true;
            } else if ((v.getId() == R.id.recent_apps) && !activityManager.isInLockTaskMode()) {
                hijackRecentsLongPress = true;
            }
            mLastLockToAppLongPress = time;
        } else {
            // If this is back still need to handle sending the long-press event.
            if (v.getId() == R.id.back) {
                sendBackLongPress = true;
            } else if ((v.getId() == R.id.recent_apps) && !activityManager.isInLockTaskMode()) {
                hijackRecentsLongPress = true;
            } else if (isAccessiblityEnabled && activityManager.isInLockTaskMode()) {
                // When in accessibility mode a long press that is recents (not back)
                // should stop lock task.
                activityManager.stopLockTaskModeOnCurrent();
            }
        }
        if (sendBackLongPress) {
            KeyButtonView keyButtonView = (KeyButtonView) v;
            keyButtonView.sendEvent(KeyEvent.ACTION_DOWN, KeyEvent.FLAG_LONG_PRESS);
            keyButtonView.sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED);
        }
        if (hijackRecentsLongPress) {
            TaskUtils.toggleLastApp(mContext, mCurrentUserId);
        }
    } catch (RemoteException e) {
        Log.d(TAG, "Unable to reach activity manager", e);
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.button_settings);
    final ContentResolver resolver = getContentResolver();
    final PreferenceScreen prefScreen = getPreferenceScreen();
    final Resources res = getResources();
    final PreferenceCategory volumeCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_VOLUME);
    if (hasVolumeRocker()) {
        mVolumeWake = (CheckBoxPreference) findPreference(BUTTON_VOLUME_WAKE);
        // mVolumeDefault = (ListPreference) findPreference(BUTTON_VOLUME_DEFAULT);
        if (!res.getBoolean(R.bool.config_show_volumeRockerWake)) {
            volumeCategory.removePreference(mVolumeWake);
        } else {
            mVolumeWake.setChecked(Settings.System.getInt(resolver, Settings.System.VOLUME_BUTTON_WAKE, 0) != 0);
        }
        // int currentDefault = Settings.System.getInt(resolver, Settings.System.VOLUME_KEYS_DEFAULT,
        // Utils.isVoiceCapable(getActivity()) ? AudioSystem.STREAM_RING : AudioSystem.STREAM_MUSIC);
        // 
        // if (!Utils.isVoiceCapable(getActivity())) {
        // removeListEntry(mVolumeDefault, Integer.toString(AudioSystem.STREAM_RING));
        // }
        // 
        // mVolumeDefault.setValue(Integer.toString(currentDefault));
        // mVolumeDefault.setOnPreferenceChangeListener(this);
        // 
        // mVolumeMusicControl = (CheckBoxPreference) findPreference(BUTTON_VOLUME_MUSIC_CONTROL);
        // mVolumeMusicControl.setChecked(Settings.System.getInt(resolver,
        // Settings.System.VOLUME_MUSIC_CONTROL, 0) != 0);
        // 
        mSwapVolumeButtons = (CheckBoxPreference) findPreference(SWAP_VOLUME_BUTTONS);
        mSwapVolumeButtons.setChecked(Settings.System.getInt(resolver, Settings.System.SWAP_VOLUME_BUTTONS, 0) != 0);
    // 
    // mVolumeKeyCursorControl = (ListPreference) findPreference(VOLUME_KEY_CURSOR_CONTROL);
    // if (mVolumeKeyCursorControl != null) {
    // mVolumeKeyCursorControl.setValue(Integer.toString(Settings.System.getInt(
    // getContentResolver(), Settings.System.VOLUME_KEY_CURSOR_CONTROL, 0)));
    // mVolumeKeyCursorControl.setSummary(mVolumeKeyCursorControl.getEntry());
    // mVolumeKeyCursorControl.setOnPreferenceChangeListener(this);
    // }
    // 
    } else {
        prefScreen.removePreference(volumeCategory);
    }
    final int deviceKeys = getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    final boolean hasBackKey = (deviceKeys & KEY_MASK_BACK) != 0;
    final boolean hasHomeKey = (deviceKeys & KEY_MASK_HOME) != 0;
    final boolean hasMenuKey = (deviceKeys & KEY_MASK_MENU) != 0;
    final boolean hasAssistKey = (deviceKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitchKey = (deviceKeys & KEY_MASK_APP_SWITCH) != 0;
    final PreferenceCategory keysCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_KEYS);
    mKeysBackCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_BACK);
    mKeysHomeCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_HOME);
    mKeysMenuCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_MENU);
    mKeysAssistCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_ASSIST);
    mKeysAppSwitchCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_APPSWITCH);
    if (deviceKeys == 0) {
        prefScreen.removePreference(keysCategory);
        prefScreen.removePreference(mKeysBackCategory);
        prefScreen.removePreference(mKeysHomeCategory);
        prefScreen.removePreference(mKeysMenuCategory);
        prefScreen.removePreference(mKeysAssistCategory);
        prefScreen.removePreference(mKeysAppSwitchCategory);
    } else {
        mEnableCustomBindings = (SwitchPreference) prefScreen.findPreference(KEYS_ENABLE_CUSTOM);
        mBackPressAction = (ListPreference) prefScreen.findPreference(KEYS_BACK_PRESS);
        mBackLongPressAction = (ListPreference) prefScreen.findPreference(KEYS_BACK_LONG_PRESS);
        mHomePressAction = (ListPreference) prefScreen.findPreference(KEYS_HOME_PRESS);
        mHomeLongPressAction = (ListPreference) prefScreen.findPreference(KEYS_HOME_LONG_PRESS);
        mHomeDoubleTapAction = (ListPreference) prefScreen.findPreference(KEYS_HOME_DOUBLE_TAP);
        mMenuPressAction = (ListPreference) prefScreen.findPreference(KEYS_MENU_PRESS);
        mMenuLongPressAction = (ListPreference) prefScreen.findPreference(KEYS_MENU_LONG_PRESS);
        mAssistPressAction = (ListPreference) prefScreen.findPreference(KEYS_ASSIST_PRESS);
        mAssistLongPressAction = (ListPreference) prefScreen.findPreference(KEYS_ASSIST_LONG_PRESS);
        mAppSwitchPressAction = (ListPreference) prefScreen.findPreference(KEYS_APP_SWITCH_PRESS);
        mAppSwitchLongPressAction = (ListPreference) prefScreen.findPreference(KEYS_APP_SWITCH_LONG_PRESS);
        if (hasBackKey) {
            int backPressAction = Settings.System.getInt(resolver, Settings.System.KEY_BACK_ACTION, ACTION_BACK);
            mBackPressAction.setValue(Integer.toString(backPressAction));
            mBackPressAction.setSummary(mBackPressAction.getEntry());
            mBackPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_BACK_ACTION, backPressAction);
            int backLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_BACK_LONG_PRESS_ACTION, ACTION_NOTHING);
            mBackLongPressAction.setValue(Integer.toString(backLongPressAction));
            mBackLongPressAction.setSummary(mBackLongPressAction.getEntry());
            mBackLongPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_BACK_LONG_PRESS_ACTION, backLongPressAction);
        } else {
            prefScreen.removePreference(mKeysBackCategory);
        }
        if (hasHomeKey) {
            int homePressAction = Settings.System.getInt(resolver, Settings.System.KEY_HOME_ACTION, ACTION_HOME);
            mHomePressAction.setValue(Integer.toString(homePressAction));
            mHomePressAction.setSummary(mHomePressAction.getEntry());
            mHomePressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_HOME_ACTION, homePressAction);
            int homeLongPressAction;
            int longPressOnHomeBehavior = getResources().getInteger(com.android.internal.R.integer.config_longPressOnHomeBehavior);
            if (longPressOnHomeBehavior == 1) {
                longPressOnHomeBehavior = ACTION_APP_SWITCH;
            } else if (longPressOnHomeBehavior == 2) {
                longPressOnHomeBehavior = ACTION_SEARCH;
            } else {
                longPressOnHomeBehavior = ACTION_NOTHING;
            }
            if (hasAppSwitchKey) {
                homeLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_HOME_LONG_PRESS_ACTION, ACTION_NOTHING);
            } else {
                int defaultAction = ACTION_NOTHING;
                homeLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_HOME_LONG_PRESS_ACTION, longPressOnHomeBehavior);
            }
            mHomeLongPressAction.setValue(Integer.toString(homeLongPressAction));
            mHomeLongPressAction.setSummary(mHomeLongPressAction.getEntry());
            mHomeLongPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_HOME_LONG_PRESS_ACTION, homeLongPressAction);
            int doubleTapOnHomeBehavior = getResources().getInteger(com.android.internal.R.integer.config_doubleTapOnHomeBehavior);
            int homeDoubleTapAction = Settings.System.getInt(resolver, Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, doubleTapOnHomeBehavior == 1 ? ACTION_APP_SWITCH : ACTION_NOTHING);
            mHomeDoubleTapAction.setValue(Integer.toString(homeDoubleTapAction));
            mHomeDoubleTapAction.setSummary(mHomeDoubleTapAction.getEntry());
            mHomeDoubleTapAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, homeDoubleTapAction);
            if (Utils.isVoiceCapable(getActivity())) {
                mHomeAnswerCall = (CheckBoxPreference) findPreference(KEYS_HOME_ANSWERS_CALL);
                final int incallHomeBehavior = Settings.Secure.getInt(getContentResolver(), Settings.Secure.RING_HOME_BUTTON_BEHAVIOR, Settings.Secure.RING_HOME_BUTTON_BEHAVIOR_DEFAULT);
                final boolean homeButtonAnswersCall = (incallHomeBehavior == Settings.Secure.RING_HOME_BUTTON_BEHAVIOR_ANSWER);
                mHomeAnswerCall.setChecked(homeButtonAnswersCall);
            } else {
                mKeysHomeCategory.removePreference(mHomeAnswerCall);
                mHomeAnswerCall = null;
            }
        } else {
            prefScreen.removePreference(mKeysHomeCategory);
        }
        if (hasMenuKey) {
            int menuPressAction = Settings.System.getInt(resolver, Settings.System.KEY_MENU_ACTION, ACTION_MENU);
            mMenuPressAction.setValue(Integer.toString(menuPressAction));
            mMenuPressAction.setSummary(mMenuPressAction.getEntry());
            mMenuPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_MENU_ACTION, menuPressAction);
            int menuLongPressAction = ACTION_NOTHING;
            if (!hasAssistKey) {
                menuLongPressAction = ACTION_SEARCH;
            }
            menuLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_MENU_LONG_PRESS_ACTION, menuLongPressAction);
            mMenuLongPressAction.setValue(Integer.toString(menuLongPressAction));
            mMenuLongPressAction.setSummary(mMenuLongPressAction.getEntry());
            mMenuLongPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_MENU_LONG_PRESS_ACTION, menuLongPressAction);
        } else {
            prefScreen.removePreference(mKeysMenuCategory);
        }
        if (hasAssistKey) {
            int assistPressAction = Settings.System.getInt(resolver, Settings.System.KEY_ASSIST_ACTION, ACTION_SEARCH);
            mAssistPressAction.setValue(Integer.toString(assistPressAction));
            mAssistPressAction.setSummary(mAssistPressAction.getEntry());
            mAssistPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_ASSIST_ACTION, assistPressAction);
            int assistLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_ASSIST_LONG_PRESS_ACTION, ACTION_VOICE_SEARCH);
            mAssistLongPressAction.setValue(Integer.toString(assistLongPressAction));
            mAssistLongPressAction.setSummary(mAssistLongPressAction.getEntry());
            mAssistLongPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION, assistLongPressAction);
        } else {
            prefScreen.removePreference(mKeysAssistCategory);
        }
        if (hasAppSwitchKey) {
            int appSwitchPressAction = Settings.System.getInt(resolver, Settings.System.KEY_APP_SWITCH_ACTION, ACTION_APP_SWITCH);
            mAppSwitchPressAction.setValue(Integer.toString(appSwitchPressAction));
            mAppSwitchPressAction.setSummary(mAppSwitchPressAction.getEntry());
            mAppSwitchPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_APP_SWITCH_ACTION, appSwitchPressAction);
            int appSwitchLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, ACTION_NOTHING);
            mAppSwitchLongPressAction.setValue(Integer.toString(appSwitchLongPressAction));
            mAppSwitchLongPressAction.setSummary(mAppSwitchLongPressAction.getEntry());
            mAppSwitchLongPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, appSwitchLongPressAction);
        } else {
            prefScreen.removePreference(mKeysAppSwitchCategory);
        }
        mEnableCustomBindings.setChecked((Settings.System.getInt(resolver, Settings.System.HARDWARE_KEY_REBINDING, 0) == 1));
        mEnableCustomBindings.setOnPreferenceChangeListener(this);
    // Vibrator vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
    // if (vibrator == null || !vibrator.hasVibrator()) {
    // removePreference(VIRTUAL_KEY_HAPTIC_FEEDBACK);
    // } else {
    // mVirtualKeyHapticFeedback.setChecked(Settings.System.getInt(resolver,
    // Settings.System.VIRTUAL_KEYS_HAPTIC_FEEDBACK, 1) == 1);
    // }
    // 
    // boolean hasNavBar = getResources().getBoolean(
    // com.android.internal.R.bool.config_showNavigationBar);
    // mForceShowOverflowMenu.setChecked(Settings.System.getInt(resolver,
    // Settings.System.FORCE_SHOW_OVERFLOW_MENU, (!hasNavBar && hasMenuKey) ? 0 : 1) == 1);
    // 
    // boolean harwareKeysDisable = Settings.System.getInt(resolver,
    // Settings.System.HARDWARE_KEYS_DISABLE, 0) == 1;
    // mDisabkeHWKeys.setChecked(harwareKeysDisable);
    // 
    // if (!mButtonBrightnessSupport) {
    // keysCategory.removePreference(mButtonBrightness);
    // }
    // updateDisableHWKeyEnablement(harwareKeysDisable);
    }
// final PreferenceCategory headsethookCategory =
// (PreferenceCategory) prefScreen.findPreference(CATEGORY_HEADSETHOOK);
// mHeadsetHookLaunchVoice = (CheckBoxPreference) findPreference(BUTTON_HEADSETHOOK_LAUNCH_VOICE);
// mHeadsetHookLaunchVoice.setChecked(Settings.System.getInt(resolver,
// Settings.System.HEADSETHOOK_LAUNCH_VOICE, 1) == 1);
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.button_settings);
    final ContentResolver resolver = getContentResolver();
    final PreferenceScreen prefScreen = getPreferenceScreen();
    final Resources res = getResources();
    final PreferenceCategory volumeCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_VOLUME);
    if (hasVolumeRocker()) {
        mVolumeWake = (CheckBoxPreference) findPreference(BUTTON_VOLUME_WAKE);
        // mVolumeDefault = (ListPreference) findPreference(BUTTON_VOLUME_DEFAULT);
        if (!res.getBoolean(R.bool.config_show_volumeRockerWake)) {
            volumeCategory.removePreference(mVolumeWake);
        } else {
            mVolumeWake.setChecked(Settings.System.getInt(resolver, Settings.System.VOLUME_BUTTON_WAKE, 0) != 0);
        }
        // int currentDefault = Settings.System.getInt(resolver, Settings.System.VOLUME_KEYS_DEFAULT,
        // Utils.isVoiceCapable(getActivity()) ? AudioSystem.STREAM_RING : AudioSystem.STREAM_MUSIC);
        // 
        // if (!Utils.isVoiceCapable(getActivity())) {
        // removeListEntry(mVolumeDefault, Integer.toString(AudioSystem.STREAM_RING));
        // }
        // 
        // mVolumeDefault.setValue(Integer.toString(currentDefault));
        // mVolumeDefault.setOnPreferenceChangeListener(this);
        // 
        // mVolumeMusicControl = (CheckBoxPreference) findPreference(BUTTON_VOLUME_MUSIC_CONTROL);
        // mVolumeMusicControl.setChecked(Settings.System.getInt(resolver,
        // Settings.System.VOLUME_MUSIC_CONTROL, 0) != 0);
        // 
        mSwapVolumeButtons = (CheckBoxPreference) findPreference(SWAP_VOLUME_BUTTONS);
        mSwapVolumeButtons.setChecked(Settings.System.getInt(resolver, Settings.System.SWAP_VOLUME_BUTTONS, 0) != 0);
    // 
    // mVolumeKeyCursorControl = (ListPreference) findPreference(VOLUME_KEY_CURSOR_CONTROL);
    // if (mVolumeKeyCursorControl != null) {
    // mVolumeKeyCursorControl.setValue(Integer.toString(Settings.System.getInt(
    // getContentResolver(), Settings.System.VOLUME_KEY_CURSOR_CONTROL, 0)));
    // mVolumeKeyCursorControl.setSummary(mVolumeKeyCursorControl.getEntry());
    // mVolumeKeyCursorControl.setOnPreferenceChangeListener(this);
    // }
    // 
    } else {
        prefScreen.removePreference(volumeCategory);
    }
    final int deviceKeys = getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    final boolean hasBackKey = (deviceKeys & KEY_MASK_BACK) != 0;
    final boolean hasHomeKey = (deviceKeys & KEY_MASK_HOME) != 0;
    final boolean hasMenuKey = (deviceKeys & KEY_MASK_MENU) != 0;
    final boolean hasAssistKey = (deviceKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitchKey = (deviceKeys & KEY_MASK_APP_SWITCH) != 0;
    final PreferenceCategory keysCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_KEYS);
    mKeysBackCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_BACK);
    mKeysHomeCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_HOME);
    mKeysMenuCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_MENU);
    mKeysAssistCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_ASSIST);
    mKeysAppSwitchCategory = (PreferenceCategory) prefScreen.findPreference(CATEGORY_APPSWITCH);
    if (deviceKeys == 0) {
        prefScreen.removePreference(keysCategory);
        prefScreen.removePreference(mKeysBackCategory);
        prefScreen.removePreference(mKeysHomeCategory);
        prefScreen.removePreference(mKeysMenuCategory);
        prefScreen.removePreference(mKeysAssistCategory);
        prefScreen.removePreference(mKeysAppSwitchCategory);
    } else {
        mEnableCustomBindings = (SwitchPreference) prefScreen.findPreference(KEYS_ENABLE_CUSTOM);
        mBackPressAction = (ListPreference) prefScreen.findPreference(KEYS_BACK_PRESS);
        mBackLongPressAction = (ListPreference) prefScreen.findPreference(KEYS_BACK_LONG_PRESS);
        mHomePressAction = (ListPreference) prefScreen.findPreference(KEYS_HOME_PRESS);
        mHomeLongPressAction = (ListPreference) prefScreen.findPreference(KEYS_HOME_LONG_PRESS);
        mHomeDoubleTapAction = (ListPreference) prefScreen.findPreference(KEYS_HOME_DOUBLE_TAP);
        mMenuPressAction = (ListPreference) prefScreen.findPreference(KEYS_MENU_PRESS);
        mMenuLongPressAction = (ListPreference) prefScreen.findPreference(KEYS_MENU_LONG_PRESS);
        mAssistPressAction = (ListPreference) prefScreen.findPreference(KEYS_ASSIST_PRESS);
        mAssistLongPressAction = (ListPreference) prefScreen.findPreference(KEYS_ASSIST_LONG_PRESS);
        mAppSwitchPressAction = (ListPreference) prefScreen.findPreference(KEYS_APP_SWITCH_PRESS);
        mAppSwitchLongPressAction = (ListPreference) prefScreen.findPreference(KEYS_APP_SWITCH_LONG_PRESS);
        if (hasBackKey) {
            int backPressAction = Settings.System.getInt(resolver, Settings.System.KEY_BACK_ACTION, ACTION_BACK);
            mBackPressAction.setValue(Integer.toString(backPressAction));
            mBackPressAction.setSummary(mBackPressAction.getEntry());
            mBackPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_BACK_ACTION, backPressAction);
            int backLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_BACK_LONG_PRESS_ACTION, ACTION_NOTHING);
            mBackLongPressAction.setValue(Integer.toString(backLongPressAction));
            mBackLongPressAction.setSummary(mBackLongPressAction.getEntry());
            mBackLongPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_BACK_LONG_PRESS_ACTION, backLongPressAction);
        } else {
            prefScreen.removePreference(mKeysBackCategory);
        }
        if (hasHomeKey) {
            int homePressAction = Settings.System.getInt(resolver, Settings.System.KEY_HOME_ACTION, ACTION_HOME);
            mHomePressAction.setValue(Integer.toString(homePressAction));
            mHomePressAction.setSummary(mHomePressAction.getEntry());
            mHomePressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_HOME_ACTION, homePressAction);
            int homeLongPressAction;
            int longPressOnHomeBehavior = getResources().getInteger(com.android.internal.R.integer.config_longPressOnHomeBehavior);
            if (longPressOnHomeBehavior == 1) {
                longPressOnHomeBehavior = ACTION_APP_SWITCH;
            } else if (longPressOnHomeBehavior == 2) {
                longPressOnHomeBehavior = ACTION_SEARCH;
            } else {
                longPressOnHomeBehavior = ACTION_NOTHING;
            }
            if (hasAppSwitchKey) {
                homeLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_HOME_LONG_PRESS_ACTION, ACTION_NOTHING);
            } else {
                int defaultAction = ACTION_NOTHING;
                homeLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_HOME_LONG_PRESS_ACTION, longPressOnHomeBehavior);
            }
            mHomeLongPressAction.setValue(Integer.toString(homeLongPressAction));
            mHomeLongPressAction.setSummary(mHomeLongPressAction.getEntry());
            mHomeLongPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_HOME_LONG_PRESS_ACTION, homeLongPressAction);
            int doubleTapOnHomeBehavior = getResources().getInteger(com.android.internal.R.integer.config_doubleTapOnHomeBehavior);
            int homeDoubleTapAction = Settings.System.getInt(resolver, Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, doubleTapOnHomeBehavior == 1 ? ACTION_APP_SWITCH : ACTION_NOTHING);
            mHomeDoubleTapAction.setValue(Integer.toString(homeDoubleTapAction));
            mHomeDoubleTapAction.setSummary(mHomeDoubleTapAction.getEntry());
            mHomeDoubleTapAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, homeDoubleTapAction);
            mHomeWake = (CheckBoxPreference) findPreference(BUTTON_HOME_WAKE);
            if (!res.getBoolean(R.bool.config_show_homeWake)) {
                mKeysHomeCategory.removePreference(mHomeWake);
            } else {
                mHomeWake.setChecked(Settings.System.getInt(resolver, Settings.System.HOME_BUTTON_WAKE, 0) != 0);
            }
            mHomeAnswerCall = (CheckBoxPreference) findPreference(BUTTON_HOME_ANSWERS_CALL);
            if (!Utils.isVoiceCapable(getActivity())) {
                mKeysHomeCategory.removePreference(mHomeAnswerCall);
            } else {
                mHomeAnswerCall.setChecked(Settings.System.getInt(resolver, Settings.System.HOME_BUTTON_ANSWER, 0) != 0);
            }
        } else {
            prefScreen.removePreference(mKeysHomeCategory);
        }
        if (hasMenuKey) {
            int menuPressAction = Settings.System.getInt(resolver, Settings.System.KEY_MENU_ACTION, ACTION_MENU);
            mMenuPressAction.setValue(Integer.toString(menuPressAction));
            mMenuPressAction.setSummary(mMenuPressAction.getEntry());
            mMenuPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_MENU_ACTION, menuPressAction);
            int menuLongPressAction = ACTION_NOTHING;
            if (!hasAssistKey) {
                menuLongPressAction = ACTION_SEARCH;
            }
            menuLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_MENU_LONG_PRESS_ACTION, menuLongPressAction);
            mMenuLongPressAction.setValue(Integer.toString(menuLongPressAction));
            mMenuLongPressAction.setSummary(mMenuLongPressAction.getEntry());
            mMenuLongPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_MENU_LONG_PRESS_ACTION, menuLongPressAction);
        } else {
            prefScreen.removePreference(mKeysMenuCategory);
        }
        if (hasAssistKey) {
            int assistPressAction = Settings.System.getInt(resolver, Settings.System.KEY_ASSIST_ACTION, ACTION_SEARCH);
            mAssistPressAction.setValue(Integer.toString(assistPressAction));
            mAssistPressAction.setSummary(mAssistPressAction.getEntry());
            mAssistPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_ASSIST_ACTION, assistPressAction);
            int assistLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_ASSIST_LONG_PRESS_ACTION, ACTION_VOICE_SEARCH);
            mAssistLongPressAction.setValue(Integer.toString(assistLongPressAction));
            mAssistLongPressAction.setSummary(mAssistLongPressAction.getEntry());
            mAssistLongPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION, assistLongPressAction);
        } else {
            prefScreen.removePreference(mKeysAssistCategory);
        }
        if (hasAppSwitchKey) {
            int appSwitchPressAction = Settings.System.getInt(resolver, Settings.System.KEY_APP_SWITCH_ACTION, ACTION_APP_SWITCH);
            mAppSwitchPressAction.setValue(Integer.toString(appSwitchPressAction));
            mAppSwitchPressAction.setSummary(mAppSwitchPressAction.getEntry());
            mAppSwitchPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_APP_SWITCH_ACTION, appSwitchPressAction);
            int appSwitchLongPressAction = Settings.System.getInt(resolver, Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, ACTION_NOTHING);
            mAppSwitchLongPressAction.setValue(Integer.toString(appSwitchLongPressAction));
            mAppSwitchLongPressAction.setSummary(mAppSwitchLongPressAction.getEntry());
            mAppSwitchLongPressAction.setOnPreferenceChangeListener(this);
            mKeySettings.put(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, appSwitchLongPressAction);
        } else {
            prefScreen.removePreference(mKeysAppSwitchCategory);
        }
        mEnableCustomBindings.setChecked((Settings.System.getInt(resolver, Settings.System.HARDWARE_KEY_REBINDING, 0) == 1));
        mEnableCustomBindings.setOnPreferenceChangeListener(this);
    // Vibrator vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
    // if (vibrator == null || !vibrator.hasVibrator()) {
    // removePreference(VIRTUAL_KEY_HAPTIC_FEEDBACK);
    // } else {
    // mVirtualKeyHapticFeedback.setChecked(Settings.System.getInt(resolver,
    // Settings.System.VIRTUAL_KEYS_HAPTIC_FEEDBACK, 1) == 1);
    // }
    // 
    // boolean hasNavBar = getResources().getBoolean(
    // com.android.internal.R.bool.config_showNavigationBar);
    // mForceShowOverflowMenu.setChecked(Settings.System.getInt(resolver,
    // Settings.System.FORCE_SHOW_OVERFLOW_MENU, (!hasNavBar && hasMenuKey) ? 0 : 1) == 1);
    // 
    // boolean harwareKeysDisable = Settings.System.getInt(resolver,
    // Settings.System.HARDWARE_KEYS_DISABLE, 0) == 1;
    // mDisabkeHWKeys.setChecked(harwareKeysDisable);
    // 
    // if (!mButtonBrightnessSupport) {
    // keysCategory.removePreference(mButtonBrightness);
    // }
    // updateDisableHWKeyEnablement(harwareKeysDisable);
    }
// final PreferenceCategory headsethookCategory =
// (PreferenceCategory) prefScreen.findPreference(CATEGORY_HEADSETHOOK);
// mHeadsetHookLaunchVoice = (CheckBoxPreference) findPreference(BUTTON_HEADSETHOOK_LAUNCH_VOICE);
// mHeadsetHookLaunchVoice.setChecked(Settings.System.getInt(resolver,
// Settings.System.HEADSETHOOK_LAUNCH_VOICE, 1) == 1);
}
#end_block

#method_before
@Override
public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
    if (preference == mVolumeWake) {
        boolean checked = ((CheckBoxPreference) preference).isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.VOLUME_BUTTON_WAKE, checked ? 1 : 0);
        return true;
    // else if (preference == mHeadsetHookLaunchVoice) {
    // boolean checked = ((CheckBoxPreference)preference).isChecked();
    // Settings.System.putInt(getContentResolver(),
    // Settings.System.HEADSETHOOK_LAUNCH_VOICE, checked ? 1:0);
    // 
    // return true;
    // } else if (preference == mVirtualKeyHapticFeedback) {
    // boolean checked = ((CheckBoxPreference)preference).isChecked();
    // Settings.System.putInt(getContentResolver(),
    // Settings.System.VIRTUAL_KEYS_HAPTIC_FEEDBACK, checked ? 1:0);
    // return true;
    // } else if (preference == mVolumeMusicControl) {
    // boolean checked = ((CheckBoxPreference)preference).isChecked();
    // Settings.System.putInt(getActivity().getContentResolver(),
    // Settings.System.VOLUME_MUSIC_CONTROL, checked ? 1:0);
    // return true;
    // } else if (preference == mForceShowOverflowMenu) {
    // boolean checked = ((CheckBoxPreference)preference).isChecked();
    // Settings.System.putInt(getContentResolver(),
    // Settings.System.FORCE_SHOW_OVERFLOW_MENU, checked ? 1:0);
    // return true;
    // } else if (preference == mDisabkeHWKeys) {
    // boolean checked = ((CheckBoxPreference)preference).isChecked();
    // Settings.System.putInt(getContentResolver(),
    // Settings.System.HARDWARE_KEYS_DISABLE, checked ? 1:0);
    // updateDisableHWKeyEnablement(checked);
    } else if (preference == mSwapVolumeButtons) {
        boolean checked = ((CheckBoxPreference) preference).isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.SWAP_VOLUME_BUTTONS, checked ? 1 : 0);
        return true;
    } else if (preference == mHomeAnswerCall) {
        boolean checked = ((CheckBoxPreference) preference).isChecked();
        Settings.Secure.putInt(getContentResolver(), Settings.Secure.RING_HOME_BUTTON_BEHAVIOR, checked ? Settings.Secure.RING_HOME_BUTTON_BEHAVIOR_ANSWER : Settings.Secure.RING_HOME_BUTTON_BEHAVIOR_DO_NOTHING);
        return true;
    }
    return super.onPreferenceTreeClick(preferenceScreen, preference);
}
#method_after
@Override
public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
    if (preference == mVolumeWake) {
        boolean checked = ((CheckBoxPreference) preference).isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.VOLUME_BUTTON_WAKE, checked ? 1 : 0);
        return true;
    // else if (preference == mHeadsetHookLaunchVoice) {
    // boolean checked = ((CheckBoxPreference)preference).isChecked();
    // Settings.System.putInt(getContentResolver(),
    // Settings.System.HEADSETHOOK_LAUNCH_VOICE, checked ? 1:0);
    // 
    // return true;
    // } else if (preference == mVirtualKeyHapticFeedback) {
    // boolean checked = ((CheckBoxPreference)preference).isChecked();
    // Settings.System.putInt(getContentResolver(),
    // Settings.System.VIRTUAL_KEYS_HAPTIC_FEEDBACK, checked ? 1:0);
    // return true;
    // } else if (preference == mVolumeMusicControl) {
    // boolean checked = ((CheckBoxPreference)preference).isChecked();
    // Settings.System.putInt(getActivity().getContentResolver(),
    // Settings.System.VOLUME_MUSIC_CONTROL, checked ? 1:0);
    // return true;
    // } else if (preference == mForceShowOverflowMenu) {
    // boolean checked = ((CheckBoxPreference)preference).isChecked();
    // Settings.System.putInt(getContentResolver(),
    // Settings.System.FORCE_SHOW_OVERFLOW_MENU, checked ? 1:0);
    // return true;
    // } else if (preference == mDisabkeHWKeys) {
    // boolean checked = ((CheckBoxPreference)preference).isChecked();
    // Settings.System.putInt(getContentResolver(),
    // Settings.System.HARDWARE_KEYS_DISABLE, checked ? 1:0);
    // updateDisableHWKeyEnablement(checked);
    } else if (preference == mSwapVolumeButtons) {
        boolean checked = ((CheckBoxPreference) preference).isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.SWAP_VOLUME_BUTTONS, checked ? 1 : 0);
        return true;
    } else if (preference == mHomeWake) {
        boolean checked = ((CheckBoxPreference) preference).isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.HOME_BUTTON_WAKE, checked ? 1 : 0);
        return true;
    } else if (preference == mHomeAnswerCall) {
        boolean checked = ((CheckBoxPreference) preference).isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.HOME_BUTTON_ANSWER, checked ? 1 : 0);
        return true;
    }
    return super.onPreferenceTreeClick(preferenceScreen, preference);
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.RING_HOME_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLUME_BUTTON_WAKE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HOME_BUTTON_WAKE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HARDWARE_KEY_REBINDING), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.WAKE_GESTURE_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Global.getUriFor(Settings.Global.POLICY_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLUME_BUTTON_WAKE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HOME_BUTTON_WAKE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HARDWARE_KEY_REBINDING), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION_ANGLES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HOME_BUTTON_ANSWER), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context, mHandler);
    mShortcutManager.observe();
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    mBackKillTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_backKillTimeout);
    updateKeyAssignments();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && !mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mScreenrecordChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenrecordChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        goingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    String deviceKeyHandlerLib = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerLib);
    String deviceKeyHandlerClass = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerClass);
    if (!deviceKeyHandlerLib.isEmpty() && !deviceKeyHandlerClass.isEmpty()) {
        DexClassLoader loader = new DexClassLoader(deviceKeyHandlerLib, new ContextWrapper(mContext).getCacheDir().getAbsolutePath(), null, ClassLoader.getSystemClassLoader());
        try {
            Class<?> klass = loader.loadClass(deviceKeyHandlerClass);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandler = (DeviceKeyHandler) constructor.newInstance(mContext);
            if (DEBUG)
                Slog.d(TAG, "Device key handler " + deviceKeyHandlerClass + " from class " + deviceKeyHandlerLib);
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerClass + " from class " + deviceKeyHandlerLib, e);
        }
    }
}
#method_after
@Override
public void init(Context context, IWindowManager windowManager, WindowManagerFuncs windowManagerFuncs) {
    mContext = context;
    mWindowManager = windowManager;
    mWindowManagerFuncs = windowManagerFuncs;
    mWindowManagerInternal = LocalServices.getService(WindowManagerInternal.class);
    mDreamManagerInternal = LocalServices.getService(DreamManagerInternal.class);
    mHandler = new PolicyHandler();
    mWakeGestureListener = new MyWakeGestureListener(mContext, mHandler);
    mOrientationListener = new MyOrientationListener(mContext, mHandler);
    try {
        mOrientationListener.setCurrentRotation(windowManager.getRotation());
    } catch (RemoteException ex) {
    }
    mSettingsObserver = new SettingsObserver(mHandler);
    mSettingsObserver.observe();
    mShortcutManager = new ShortcutManager(context, mHandler);
    mShortcutManager.observe();
    mUiMode = context.getResources().getInteger(com.android.internal.R.integer.config_defaultUiModeType);
    mHomeIntent = new Intent(Intent.ACTION_MAIN, null);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mCarDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mCarDockIntent.addCategory(Intent.CATEGORY_CAR_DOCK);
    mCarDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mDeskDockIntent = new Intent(Intent.ACTION_MAIN, null);
    mDeskDockIntent.addCategory(Intent.CATEGORY_DESK_DOCK);
    mDeskDockIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    mBroadcastWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "PhoneWindowManager.mBroadcastWakeLock");
    mEnableShiftMenuBugReports = "1".equals(SystemProperties.get("ro.debuggable"));
    mSupportAutoRotation = mContext.getResources().getBoolean(com.android.internal.R.bool.config_supportAutoRotation);
    mLidOpenRotation = readRotation(com.android.internal.R.integer.config_lidOpenRotation);
    mCarDockRotation = readRotation(com.android.internal.R.integer.config_carDockRotation);
    mDeskDockRotation = readRotation(com.android.internal.R.integer.config_deskDockRotation);
    mUndockedHdmiRotation = readRotation(com.android.internal.R.integer.config_undockedHdmiRotation);
    mCarDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_carDockEnablesAccelerometer);
    mDeskDockEnablesAccelerometer = mContext.getResources().getBoolean(com.android.internal.R.bool.config_deskDockEnablesAccelerometer);
    mLidKeyboardAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidKeyboardAccessibility);
    mLidNavigationAccessibility = mContext.getResources().getInteger(com.android.internal.R.integer.config_lidNavigationAccessibility);
    mLidControlsSleep = mContext.getResources().getBoolean(com.android.internal.R.bool.config_lidControlsSleep);
    mTranslucentDecorEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableTranslucentDecor);
    mDeviceHardwareKeys = mContext.getResources().getInteger(com.android.internal.R.integer.config_deviceHardwareKeys);
    mHasRemovableLid = mContext.getResources().getBoolean(com.android.internal.R.bool.config_hasRemovableLid);
    mBackKillTimeout = mContext.getResources().getInteger(com.android.internal.R.integer.config_backKillTimeout);
    updateKeyAssignments();
    mAccessibilityManager = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    // register for dock events
    IntentFilter filter = new IntentFilter();
    filter.addAction(UiModeManager.ACTION_ENTER_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_CAR_MODE);
    filter.addAction(UiModeManager.ACTION_ENTER_DESK_MODE);
    filter.addAction(UiModeManager.ACTION_EXIT_DESK_MODE);
    filter.addAction(Intent.ACTION_DOCK_EVENT);
    Intent intent = context.registerReceiver(mDockReceiver, filter);
    if (intent != null) {
        // Retrieve current sticky dock event broadcast.
        mDockMode = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
    }
    // register for dream-related broadcasts
    filter = new IntentFilter();
    filter.addAction(Intent.ACTION_DREAMING_STARTED);
    filter.addAction(Intent.ACTION_DREAMING_STOPPED);
    context.registerReceiver(mDreamReceiver, filter);
    // register for multiuser-relevant broadcasts
    filter = new IntentFilter(Intent.ACTION_USER_SWITCHED);
    context.registerReceiver(mMultiuserReceiver, filter);
    // monitor for system gestures
    mSystemGestures = new SystemGesturesPointerEventListener(context, new SystemGesturesPointerEventListener.Callbacks() {

        @Override
        public void onSwipeFromTop() {
            if (mStatusBar != null) {
                requestTransientBars(mStatusBar);
            }
        }

        @Override
        public void onSwipeFromBottom() {
            if (mNavigationBar != null && mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onSwipeFromRight() {
            if (mNavigationBar != null && !mNavigationBarOnBottom) {
                requestTransientBars(mNavigationBar);
            }
        }

        @Override
        public void onDebug() {
        // no-op
        }
    });
    mImmersiveModeConfirmation = new ImmersiveModeConfirmation(mContext);
    mWindowManagerFuncs.registerPointerEventListener(mSystemGestures);
    mVibrator = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
    mLongPressVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_longPressVibePattern);
    mVirtualKeyVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_virtualKeyVibePattern);
    mKeyboardTapVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_keyboardTapVibePattern);
    mClockTickVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_clockTickVibePattern);
    mCalendarDateVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_calendarDateVibePattern);
    mSafeModeDisabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeDisabledVibePattern);
    mSafeModeEnabledVibePattern = getLongIntArray(mContext.getResources(), com.android.internal.R.array.config_safeModeEnabledVibePattern);
    mScreenshotChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenshotChord);
    mScreenrecordChordEnabled = mContext.getResources().getBoolean(com.android.internal.R.bool.config_enableScreenrecordChord);
    mGlobalKeyManager = new GlobalKeyManager(mContext);
    // Controls rotation and the like.
    initializeHdmiState();
    // Match current screen state.
    if (!mPowerManager.isInteractive()) {
        goingToSleep(WindowManagerPolicy.OFF_BECAUSE_OF_USER);
    }
    String deviceKeyHandlerLib = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerLib);
    String deviceKeyHandlerClass = mContext.getResources().getString(com.android.internal.R.string.config_deviceKeyHandlerClass);
    if (!deviceKeyHandlerLib.isEmpty() && !deviceKeyHandlerClass.isEmpty()) {
        DexClassLoader loader = new DexClassLoader(deviceKeyHandlerLib, new ContextWrapper(mContext).getCacheDir().getAbsolutePath(), null, ClassLoader.getSystemClassLoader());
        try {
            Class<?> klass = loader.loadClass(deviceKeyHandlerClass);
            Constructor<?> constructor = klass.getConstructor(Context.class);
            mDeviceKeyHandler = (DeviceKeyHandler) constructor.newInstance(mContext);
            if (DEBUG)
                Slog.d(TAG, "Device key handler " + deviceKeyHandlerClass + " from class " + deviceKeyHandlerLib);
        } catch (Exception e) {
            Slog.w(TAG, "Could not instantiate device key handler " + deviceKeyHandlerClass + " from class " + deviceKeyHandlerLib, e);
        }
    }
}
#end_block

#method_before
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mRingHomeBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.RING_HOME_BUTTON_BEHAVIOR, Settings.Secure.RING_HOME_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1, UserHandle.USER_CURRENT);
        updateKeyAssignments();
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
        PolicyControl.reloadFromSetting(mContext);
        mVolumeWakeSupport = Settings.System.getIntForUser(resolver, Settings.System.VOLUME_BUTTON_WAKE, 0, UserHandle.USER_CURRENT) != 0;
        mHomeWakeSupport = Settings.System.getIntForUser(resolver, Settings.System.HOME_BUTTON_WAKE, 0, UserHandle.USER_CURRENT) != 0;
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#method_after
public void updateSettings() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean updateRotation = false;
    synchronized (mLock) {
        mEndcallBehavior = Settings.System.getIntForUser(resolver, Settings.System.END_BUTTON_BEHAVIOR, Settings.System.END_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mIncallPowerBehavior = Settings.Secure.getIntForUser(resolver, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR, Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_DEFAULT, UserHandle.USER_CURRENT);
        mRingHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.HOME_BUTTON_ANSWER, 0, UserHandle.USER_CURRENT);
        // Configure wake gesture.
        boolean wakeGestureEnabledSetting = Settings.Secure.getIntForUser(resolver, Settings.Secure.WAKE_GESTURE_ENABLED, 0, UserHandle.USER_CURRENT) != 0;
        if (mWakeGestureEnabledSetting != wakeGestureEnabledSetting) {
            mWakeGestureEnabledSetting = wakeGestureEnabledSetting;
            updateWakeGestureListenerLp();
        }
        // Configure rotation lock.
        int userRotation = Settings.System.getIntForUser(resolver, Settings.System.USER_ROTATION, Surface.ROTATION_0, UserHandle.USER_CURRENT);
        if (mUserRotation != userRotation) {
            mUserRotation = userRotation;
            updateRotation = true;
        }
        int userRotationMode = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION, 0, UserHandle.USER_CURRENT) != 0 ? WindowManagerPolicy.USER_ROTATION_FREE : WindowManagerPolicy.USER_ROTATION_LOCKED;
        if (mUserRotationMode != userRotationMode) {
            mUserRotationMode = userRotationMode;
            updateRotation = true;
            updateOrientationListenerLp();
        }
        mUserRotationAngles = Settings.System.getIntForUser(resolver, Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1, UserHandle.USER_CURRENT);
        updateKeyAssignments();
        if (mSystemReady) {
            int pointerLocation = Settings.System.getIntForUser(resolver, Settings.System.POINTER_LOCATION, 0, UserHandle.USER_CURRENT);
            if (mPointerLocationMode != pointerLocation) {
                mPointerLocationMode = pointerLocation;
                mHandler.sendEmptyMessage(pointerLocation != 0 ? MSG_ENABLE_POINTER_LOCATION : MSG_DISABLE_POINTER_LOCATION);
            }
        }
        // use screen off timeout setting as the timeout for the lockscreen
        mLockScreenTimeout = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_OFF_TIMEOUT, 0, UserHandle.USER_CURRENT);
        String imId = Settings.Secure.getStringForUser(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, UserHandle.USER_CURRENT);
        boolean hasSoftInput = imId != null && imId.length() > 0;
        if (mHasSoftInput != hasSoftInput) {
            mHasSoftInput = hasSoftInput;
            updateRotation = true;
        }
        if (mImmersiveModeConfirmation != null) {
            mImmersiveModeConfirmation.loadSetting(mCurrentUserId);
        }
        PolicyControl.reloadFromSetting(mContext);
        mVolumeWakeSupport = Settings.System.getIntForUser(resolver, Settings.System.VOLUME_BUTTON_WAKE, 0, UserHandle.USER_CURRENT) != 0;
        mHomeWakeSupport = Settings.System.getIntForUser(resolver, Settings.System.HOME_BUTTON_WAKE, 0, UserHandle.USER_CURRENT) != 0;
    }
    if (updateRotation) {
        updateRotation(true);
    }
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENRECORD_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mVolumeUpKeyConsumedByScreenrecordChord) {
            if (!down) {
                mVolumeUpKeyConsumedByScreenrecordChord = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // stop the kill action
    if (mBackKillPending && !down) {
        mHandler.removeCallbacks(mKillTask);
        mBackKillPending = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            if (mRecentAppsPreloaded) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                if ((mRingHomeBehavior & Settings.Secure.RING_HOME_BUTTON_BEHAVIOR_ANSWER) != 0) {
                    Log.i(TAG, "Answering with HOME button.");
                    telecomManager.acceptRingingCall();
                    return -1;
                } else {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // but don't actually go home.
            if (mDreamManagerInternal != null && mDreamManagerInternal.isDreaming()) {
                mDreamManagerInternal.stopDream(false);
                return -1;
            }
            if (mPressOnHomeBehavior != KEY_ACTION_HOME) {
                performKeyAction(mPressOnHomeBehavior);
            } else {
                launchHomeFromHotKey();
            }
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            if (down) {
                mHomePressed = true;
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeConsumed = true;
                performKeyAction(mDoubleTapOnHomeBehavior);
            } else if (!mRecentAppsPreloaded && (mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehavior == KEY_ACTION_APP_SWITCH || mPressOnHomeBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
                preloadRecentApps();
            }
            if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                mHomeConsumed = true;
                performKeyAction(mLongPressOnHomeBehavior);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcast(intent, null);
                    return -1;
                } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                    Intent service = new Intent();
                    service.setClassName(mContext, "com.android.server.LoadAverageService");
                    ContentResolver res = mContext.getContentResolver();
                    boolean shown = Settings.System.getInt(res, Settings.System.SHOW_PROCESSES, 0) != 0;
                    if (!shown) {
                        mContext.startService(service);
                    } else {
                        mContext.stopService(service);
                    }
                    Settings.System.putInt(res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
                    return -1;
                } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !virtualKey) {
                    mMenuDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnMenuBehavior);
                    // Do not perform action when key is released
                    mMenuDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mMenuDoCustomAction) {
                mMenuDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnMenuBehavior);
                    return -1;
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAppSwitchBehavior);
                    mAppSwitchLongPressed = true;
                }
            }
        } else {
            if (mAppSwitchLongPressed) {
                mAppSwitchLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAssistBehavior);
                    mAssistKeyLongPressed = true;
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAssistBehavior);
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            mContext.startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            mContext.startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnBackBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    mBackDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnBackBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnBackBehavior);
                    // Do not perform action when key is released
                    mBackDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnBackBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnBackBehavior);
                    return -1;
                }
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENRECORD_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mVolumeUpKeyConsumedByScreenrecordChord) {
            if (!down) {
                mVolumeUpKeyConsumedByScreenrecordChord = false;
            }
            return -1;
        }
    }
    // of the meta key and its corresponding up.
    if (mPendingMetaAction && !KeyEvent.isMetaKey(keyCode)) {
        mPendingMetaAction = false;
    }
    // stop the kill action
    if (mBackKillPending && !down) {
        mHandler.removeCallbacks(mKillTask);
        mBackKillPending = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            if (mRecentAppsPreloaded) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // If an incoming call is ringing, HOME is totally disabled.
            // (The user is already on the InCallUI at this point,
            // and his ONLY options are to answer or reject the call.)
            TelecomManager telecomManager = getTelecommService();
            if (telecomManager != null && telecomManager.isRinging()) {
                if (mRingHomeBehavior != 0) {
                    Log.i(TAG, "Answering with HOME button.");
                    telecomManager.acceptRingingCall();
                    return -1;
                } else {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // but don't actually go home.
            if (mDreamManagerInternal != null && mDreamManagerInternal.isDreaming()) {
                mDreamManagerInternal.stopDream(false);
                return -1;
            }
            if (mPressOnHomeBehavior != KEY_ACTION_HOME) {
                performKeyAction(mPressOnHomeBehavior);
            } else {
                launchHomeFromHotKey();
            }
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG || (attrs.privateFlags & PRIVATE_FLAG_KEYGUARD) != 0) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            if (down) {
                mHomePressed = true;
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeConsumed = true;
                performKeyAction(mDoubleTapOnHomeBehavior);
            } else if (!mRecentAppsPreloaded && (mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehavior == KEY_ACTION_APP_SWITCH || mPressOnHomeBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
                preloadRecentApps();
            }
            if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                mHomeConsumed = true;
                performKeyAction(mLongPressOnHomeBehavior);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcast(intent, null);
                    return -1;
                } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                    Intent service = new Intent();
                    service.setClassName(mContext, "com.android.server.LoadAverageService");
                    ContentResolver res = mContext.getContentResolver();
                    boolean shown = Settings.System.getInt(res, Settings.System.SHOW_PROCESSES, 0) != 0;
                    if (!shown) {
                        mContext.startService(service);
                    } else {
                        mContext.stopService(service);
                    }
                    Settings.System.putInt(res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
                    return -1;
                } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !virtualKey) {
                    mMenuDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnMenuBehavior);
                    // Do not perform action when key is released
                    mMenuDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mMenuDoCustomAction) {
                mMenuDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnMenuBehavior);
                    return -1;
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAppSwitchBehavior);
                    mAppSwitchLongPressed = true;
                }
            }
        } else {
            if (mAppSwitchLongPressed) {
                mAppSwitchLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAssistBehavior);
                    mAssistKeyLongPressed = true;
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAssistBehavior);
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_VOICE_ASSIST) {
        if (!down) {
            Intent voiceIntent;
            if (!keyguardOn) {
                voiceIntent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
            } else {
                voiceIntent = new Intent(RecognizerIntent.ACTION_VOICE_SEARCH_HANDS_FREE);
                voiceIntent.putExtra(RecognizerIntent.EXTRA_SECURE, true);
            }
            mContext.startActivityAsUser(voiceIntent, UserHandle.CURRENT_OR_SELF);
        }
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            mContext.startActivityAsUser(new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG), UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (KeyEvent.isMetaKey(keyCode)) {
        if (down) {
            mPendingMetaAction = true;
        } else if (mPendingMetaAction) {
            launchAssistAction(Intent.EXTRA_ASSIST_INPUT_HINT_KEYBOARD);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnBackBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    mBackDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnBackBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnBackBehavior);
                    // Do not perform action when key is released
                    mBackDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnBackBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnBackBehavior);
                    return -1;
                }
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON)) {
                mRecentAppsHeldModifiers = shiftlessModifiers;
                showRecentApps(true);
                return -1;
            }
        }
    } else if (!down && mRecentAppsHeldModifiers != 0 && (metaState & mRecentAppsHeldModifiers) == 0) {
        mRecentAppsHeldModifiers = 0;
        hideRecentApps(true, false);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Specific device key handling
    if (mDeviceKeyHandler != null) {
        try {
            // The device only should consume known keys.
            if (mDeviceKeyHandler.handleKeyEvent(event)) {
                return -1;
            }
        } catch (Exception e) {
            Slog.w(TAG, "Could not dispatch event to device key handler", e);
        }
    }
    // Reserve all the META modifier combos for system behavior
    if ((metaState & KeyEvent.META_META_ON) != 0) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
@Override
public int rotationForOrientationLw(int orientation, int lastRotation) {
    if (false) {
        Slog.v(TAG, "rotationForOrientationLw(orient=" + orientation + ", last=" + lastRotation + "); user=" + mUserRotation + " " + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED) ? "USER_ROTATION_LOCKED" : ""));
    }
    if (mForceDefaultOrientation) {
        return Surface.ROTATION_0;
    }
    synchronized (mLock) {
        // may be -1
        int sensorRotation = mOrientationListener.getProposedRotation();
        if (sensorRotation < 0) {
            sensorRotation = lastRotation;
        }
        final int preferredRotation;
        if (mLidState == LID_OPEN && mLidOpenRotation >= 0) {
            // Ignore sensor when lid switch is open and rotation is forced.
            preferredRotation = mLidOpenRotation;
        } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
            // Ignore sensor when in car dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mCarDockEnablesAccelerometer ? sensorRotation : mCarDockRotation;
        } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK) && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
            // Ignore sensor when in desk dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mDeskDockEnablesAccelerometer ? sensorRotation : mDeskDockRotation;
        } else if (mHdmiPlugged && mDemoHdmiRotationLock) {
            // Ignore sensor when plugged into HDMI when demo HDMI rotation lock enabled.
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mDemoHdmiRotation;
        } else if (mHdmiPlugged && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED && mUndockedHdmiRotation >= 0) {
            // Ignore sensor when plugged into HDMI and an undocked orientation has
            // been specified in the configuration (only for legacy devices without
            // full multi-display support).
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mUndockedHdmiRotation;
        } else if (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {
            // Application just wants to remain locked in the last rotation.
            preferredRotation = lastRotation;
        } else if (!mSupportAutoRotation) {
            // If we don't support auto-rotation then bail out here and ignore
            // the sensor and any rotation lock settings.
            preferredRotation = -1;
        } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER)) || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
            // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
            if (mAllowAllRotations < 0) {
                // Can't read this during init() because the context doesn't
                // have display metrics at that time so we cannot determine
                // tablet vs. phone then.
                mAllowAllRotations = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
            }
            // 1=0 2=90 4=180 8=270
            if (mUserRotationAngles < 0) {
                // defaults
                mUserRotationAngles = mAllowAllRotations == 1 ? // All angles
                (ROTATION_0_MODE | ROTATION_90_MODE | ROTATION_180_MODE | ROTATION_270_MODE) : // All except 180
                (ROTATION_0_MODE | ROTATION_90_MODE | ROTATION_270_MODE);
            }
            boolean allowed = true;
            switch(sensorRotation) {
                case Surface.ROTATION_0:
                    allowed = (mUserRotationAngles & ROTATION_0_MODE) != 0;
                    break;
                case Surface.ROTATION_90:
                    allowed = (mUserRotationAngles & ROTATION_90_MODE) != 0;
                    break;
                case Surface.ROTATION_180:
                    allowed = (mUserRotationAngles & ROTATION_180_MODE) != 0;
                    break;
                case Surface.ROTATION_270:
                    allowed = (mUserRotationAngles & ROTATION_270_MODE) != 0;
                    break;
            }
            if (allowed) {
                preferredRotation = sensorRotation;
            } else {
                preferredRotation = lastRotation;
            }
        } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
            // Apply rotation lock.  Does not apply to NOSENSOR.
            // The idea is that the user rotation expresses a weak preference for the direction
            // of gravity and as NOSENSOR is never affected by gravity, then neither should
            // NOSENSOR be affected by rotation lock (although it will be affected by docks).
            preferredRotation = mUserRotation;
        } else {
            // No overriding preference.
            // We will do exactly what the application asked us to do.
            preferredRotation = -1;
        }
        switch(orientation) {
            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                // Return portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mPortraitRotation;
            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
                // Return landscape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
                // Return reverse portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mUpsideDownRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
                // Return seascape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mSeascapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
            case ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE:
                // Return either landscape rotation.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                if (isLandscapeOrSeascape(lastRotation)) {
                    return lastRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
            case ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT:
                // Return either portrait rotation.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                if (isAnyPortrait(lastRotation)) {
                    return lastRotation;
                }
                return mPortraitRotation;
            default:
                // just return the preferred orientation we already calculated.
                if (preferredRotation >= 0) {
                    return preferredRotation;
                }
                return Surface.ROTATION_0;
        }
    }
}
#method_after
@Override
public int rotationForOrientationLw(int orientation, int lastRotation) {
    if (false) {
        Slog.v(TAG, "rotationForOrientationLw(orient=" + orientation + ", last=" + lastRotation + "); user=" + mUserRotation + " " + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED) ? "USER_ROTATION_LOCKED" : ""));
    }
    if (mForceDefaultOrientation) {
        return Surface.ROTATION_0;
    }
    synchronized (mLock) {
        // may be -1
        int sensorRotation = mOrientationListener.getProposedRotation();
        if (sensorRotation < 0) {
            sensorRotation = lastRotation;
        }
        final int preferredRotation;
        if ((mLidState == LID_OPEN && mLidOpenRotation >= 0) && !(mHasRemovableLid && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED)) {
            // Ignore sensor when lid switch is open and rotation is forced
            // and a removable lid was not undocked.
            preferredRotation = mLidOpenRotation;
        } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
            // Ignore sensor when in car dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mCarDockEnablesAccelerometer ? sensorRotation : mCarDockRotation;
        } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK) && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
            // Ignore sensor when in desk dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mDeskDockEnablesAccelerometer ? sensorRotation : mDeskDockRotation;
        } else if (mHdmiPlugged && mDemoHdmiRotationLock) {
            // Ignore sensor when plugged into HDMI when demo HDMI rotation lock enabled.
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mDemoHdmiRotation;
        } else if (mHdmiPlugged && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED && mUndockedHdmiRotation >= 0) {
            // Ignore sensor when plugged into HDMI and an undocked orientation has
            // been specified in the configuration (only for legacy devices without
            // full multi-display support).
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mUndockedHdmiRotation;
        } else if (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {
            // Application just wants to remain locked in the last rotation.
            preferredRotation = lastRotation;
        } else if (!mSupportAutoRotation) {
            // If we don't support auto-rotation then bail out here and ignore
            // the sensor and any rotation lock settings.
            preferredRotation = -1;
        } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER)) || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
            // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
            if (mAllowAllRotations < 0) {
                // Can't read this during init() because the context doesn't
                // have display metrics at that time so we cannot determine
                // tablet vs. phone then.
                mAllowAllRotations = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
            }
            // 1=0 2=90 4=180 8=270
            if (mUserRotationAngles < 0) {
                // defaults
                mUserRotationAngles = mAllowAllRotations == 1 ? // All angles
                (ROTATION_0_MODE | ROTATION_90_MODE | ROTATION_180_MODE | ROTATION_270_MODE) : // All except 180
                (ROTATION_0_MODE | ROTATION_90_MODE | ROTATION_270_MODE);
            }
            boolean allowed = true;
            switch(sensorRotation) {
                case Surface.ROTATION_0:
                    allowed = (mUserRotationAngles & ROTATION_0_MODE) != 0;
                    break;
                case Surface.ROTATION_90:
                    allowed = (mUserRotationAngles & ROTATION_90_MODE) != 0;
                    break;
                case Surface.ROTATION_180:
                    allowed = (mUserRotationAngles & ROTATION_180_MODE) != 0;
                    break;
                case Surface.ROTATION_270:
                    allowed = (mUserRotationAngles & ROTATION_270_MODE) != 0;
                    break;
            }
            if (allowed) {
                preferredRotation = sensorRotation;
            } else {
                preferredRotation = lastRotation;
            }
        } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
            // Apply rotation lock.  Does not apply to NOSENSOR.
            // The idea is that the user rotation expresses a weak preference for the direction
            // of gravity and as NOSENSOR is never affected by gravity, then neither should
            // NOSENSOR be affected by rotation lock (although it will be affected by docks).
            preferredRotation = mUserRotation;
        } else {
            // No overriding preference.
            // We will do exactly what the application asked us to do.
            preferredRotation = -1;
        }
        switch(orientation) {
            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                // Return portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mPortraitRotation;
            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
                // Return landscape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
                // Return reverse portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mUpsideDownRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
                // Return seascape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mSeascapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
            case ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE:
                // Return either landscape rotation.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                if (isLandscapeOrSeascape(lastRotation)) {
                    return lastRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
            case ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT:
                // Return either portrait rotation.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                if (isAnyPortrait(lastRotation)) {
                    return lastRotation;
                }
                return mPortraitRotation;
            default:
                // just return the preferred orientation we already calculated.
                if (preferredRotation >= 0) {
                    return preferredRotation;
                }
                return Surface.ROTATION_0;
        }
    }
}
#end_block

#method_before
private void onConnect(ConnectionParams cp) {
    if (DBG)
        log("onConnect: carrier='" + mApnSetting.carrier + "' APN='" + mApnSetting.apn + "' proxy='" + mApnSetting.proxy + "' port='" + mApnSetting.port + "'");
    // Check if we should fake an error.
    if (mDcTesterFailBringUpAll.getDcFailBringUp().mCounter > 0) {
        DataCallResponse response = new DataCallResponse();
        response.version = mPhone.mCi.getRilVersion();
        response.status = mDcTesterFailBringUpAll.getDcFailBringUp().mFailCause.getErrorCode();
        response.cid = 0;
        response.active = 0;
        response.type = "";
        response.ifname = "";
        response.addresses = new String[0];
        response.dnses = new String[0];
        response.gateways = new String[0];
        response.suggestedRetryTime = mDcTesterFailBringUpAll.getDcFailBringUp().mSuggestedRetryTime;
        response.pcscf = new String[0];
        response.mtu = PhoneConstants.UNSET_MTU;
        Message msg = obtainMessage(EVENT_SETUP_DATA_CONNECTION_DONE, cp);
        AsyncResult.forMessage(msg, response, null);
        sendMessage(msg);
        if (DBG) {
            log("onConnect: FailBringUpAll=" + mDcTesterFailBringUpAll.getDcFailBringUp() + " send error response=" + response);
        }
        mDcTesterFailBringUpAll.getDcFailBringUp().mCounter -= 1;
        return;
    }
    mCreateTime = -1;
    mLastFailTime = -1;
    mLastFailCause = DcFailCause.NONE;
    // msg.obj will be returned in AsyncResult.userObj;
    Message msg = obtainMessage(EVENT_SETUP_DATA_CONNECTION_DONE, cp);
    msg.obj = cp;
    int authType = mApnSetting.authType;
    if (authType == -1) {
        authType = TextUtils.isEmpty(mApnSetting.user) ? RILConstants.SETUP_DATA_AUTH_NONE : RILConstants.SETUP_DATA_AUTH_PAP_CHAP;
    }
    String protocol;
    if (mPhone.getServiceState().getRoaming()) {
        protocol = mApnSetting.roamingProtocol;
    } else {
        protocol = mApnSetting.protocol;
    }
    mPhone.mCi.setupDataCall(Integer.toString(getSetupRilRadioTechnology()), Integer.toString(cp.mProfileId), mApnSetting.apn, mApnSetting.user, mApnSetting.password, Integer.toString(authType), protocol, msg);
}
#method_after
private void onConnect(ConnectionParams cp) {
    if (DBG)
        log("onConnect: carrier='" + mApnSetting.carrier + "' APN='" + mApnSetting.apn + "' proxy='" + mApnSetting.proxy + "' port='" + mApnSetting.port + "'");
    // Check if we should fake an error.
    if (mDcTesterFailBringUpAll.getDcFailBringUp().mCounter > 0) {
        DataCallResponse response = new DataCallResponse();
        response.version = mPhone.mCi.getRilVersion();
        response.status = mDcTesterFailBringUpAll.getDcFailBringUp().mFailCause.getErrorCode();
        response.cid = 0;
        response.active = 0;
        response.type = "";
        response.ifname = "";
        response.addresses = new String[0];
        response.dnses = new String[0];
        response.gateways = new String[0];
        response.suggestedRetryTime = mDcTesterFailBringUpAll.getDcFailBringUp().mSuggestedRetryTime;
        response.pcscf = new String[0];
        response.mtu = PhoneConstants.UNSET_MTU;
        Message msg = obtainMessage(EVENT_SETUP_DATA_CONNECTION_DONE, cp);
        AsyncResult.forMessage(msg, response, null);
        sendMessage(msg);
        if (DBG) {
            log("onConnect: FailBringUpAll=" + mDcTesterFailBringUpAll.getDcFailBringUp() + " send error response=" + response);
        }
        mDcTesterFailBringUpAll.getDcFailBringUp().mCounter -= 1;
        return;
    }
    mCreateTime = -1;
    mLastFailTime = -1;
    mLastFailCause = DcFailCause.NONE;
    // msg.obj will be returned in AsyncResult.userObj;
    Message msg = obtainMessage(EVENT_SETUP_DATA_CONNECTION_DONE, cp);
    msg.obj = cp;
    int authType = mApnSetting.authType;
    if (authType == -1) {
        authType = TextUtils.isEmpty(mApnSetting.user) ? RILConstants.SETUP_DATA_AUTH_NONE : RILConstants.SETUP_DATA_AUTH_PAP_CHAP;
    }
    String protocol;
    if (mPhone.getServiceState().getRoaming()) {
        protocol = mApnSetting.roamingProtocol;
    } else {
        protocol = mApnSetting.protocol;
    }
    mPhone.mCi.setupDataCall(Integer.toString(getSetupRilRadioTechnology(cp.mRilRat)), Integer.toString(cp.mProfileId), mApnSetting.apn, mApnSetting.user, mApnSetting.password, Integer.toString(authType), protocol, msg);
}
#end_block

#method_before
private int getSetupRilRadioTechnology() {
    if (mPhone.mCi.getRilVersion() < 6) {
        int phoneType = mPhone.getPhoneType();
        if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
            return RILConstants.SETUP_DATA_TECH_GSM;
        } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
            return RILConstants.SETUP_DATA_TECH_CDMA;
        } else {
            throw new RuntimeException("Unknown phoneType " + phoneType + ", should not happen");
        }
    } else {
        return mRilRat + 2;
    }
}
#method_after
private int getSetupRilRadioTechnology(int rilRadioTechnology) {
    if (mPhone.mCi.getRilVersion() < 6) {
        int phoneType = mPhone.getPhoneType();
        if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
            return RILConstants.SETUP_DATA_TECH_GSM;
        } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
            return RILConstants.SETUP_DATA_TECH_CDMA;
        } else {
            throw new RuntimeException("Unknown phoneType " + phoneType + ", should not happen");
        }
    } else {
        return rilRadioTechnology + 2;
    }
}
#end_block

#method_before
protected DataCallResponse getDataCallResponse(Parcel p, int version) {
    DataCallResponse dataCall = new DataCallResponse();
    dataCall.version = version;
    if (version < 5) {
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        if (version < 4 || needsOldRilFeature("datacallapn")) {
            // APN - not used
            p.readString();
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        // DataCallState needs an ifname. Since we don't have one use the name from the ThrottleService resource (default=rmnet0).
        dataCall.ifname = Resources.getSystem().getString(com.android.internal.R.string.config_datause_iface);
    } else {
        dataCall.status = p.readInt();
        if (needsOldRilFeature("usehcradio"))
            dataCall.suggestedRetryTime = -1;
        else
            dataCall.suggestedRetryTime = p.readInt();
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        dataCall.ifname = p.readString();
        if ((dataCall.status == DcFailCause.NONE.getErrorCode()) && TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("getDataCallResponse, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        String dnses = p.readString();
        if (!TextUtils.isEmpty(dnses)) {
            dataCall.dnses = dnses.split(" ");
        }
        String gateways = p.readString();
        if (!TextUtils.isEmpty(gateways)) {
            dataCall.gateways = gateways.split(" ");
        }
        if (version >= 10) {
            String pcscf = p.readString();
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
        if (version >= 11) {
            dataCall.mtu = p.readInt();
        }
    }
    return dataCall;
}
#method_after
protected DataCallResponse getDataCallResponse(Parcel p, int version) {
    DataCallResponse dataCall = new DataCallResponse();
    dataCall.version = version;
    if (version < 5) {
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        if (version < 4 || needsOldRilFeature("datacallapn")) {
            // APN - not used
            p.readString();
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        // DataCallState needs an ifname. Since we don't have one use the name from the ThrottleService resource (default=rmnet0).
        dataCall.ifname = Resources.getSystem().getString(com.android.internal.R.string.config_datause_iface);
    } else {
        dataCall.status = p.readInt();
        if (needsOldRilFeature("usehcradio")) {
            dataCall.suggestedRetryTime = -1;
        } else {
            dataCall.suggestedRetryTime = p.readInt();
        }
        dataCall.cid = p.readInt();
        dataCall.active = p.readInt();
        dataCall.type = p.readString();
        dataCall.ifname = p.readString();
        if ((dataCall.status == DcFailCause.NONE.getErrorCode()) && TextUtils.isEmpty(dataCall.ifname)) {
            throw new RuntimeException("getDataCallResponse, no ifname");
        }
        String addresses = p.readString();
        if (!TextUtils.isEmpty(addresses)) {
            dataCall.addresses = addresses.split(" ");
        }
        String dnses = p.readString();
        if (!TextUtils.isEmpty(dnses)) {
            dataCall.dnses = dnses.split(" ");
        }
        String gateways = p.readString();
        if (!TextUtils.isEmpty(gateways)) {
            dataCall.gateways = gateways.split(" ");
        }
        if (version >= 10) {
            String pcscf = p.readString();
            if (!TextUtils.isEmpty(pcscf)) {
                dataCall.pcscf = pcscf.split(" ");
            }
        }
        if (version >= 11) {
            dataCall.mtu = p.readInt();
        }
    }
    return dataCall;
}
#end_block

#method_before
private PreferenceScreen createCustomView() {
    addPreferencesFromResource(R.xml.status_bar_clock_style);
    PreferenceScreen prefSet = getPreferenceScreen();
    mClockStyle = (ListPreference) findPreference(PREF_ENABLE);
    mClockStyle.setOnPreferenceChangeListener(this);
    mClockStyle.setValue(Integer.toString(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_STYLE, 0)));
    mClockStyle.setSummary(mClockStyle.getEntry());
    mClockAmPmStyle = (ListPreference) prefSet.findPreference(PREF_AM_PM_STYLE);
    mClockAmPmStyle.setOnPreferenceChangeListener(this);
    mClockAmPmStyle.setValue(Integer.toString(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_AM_PM_STYLE, 0)));
    boolean is24hour = DateFormat.is24HourFormat(getActivity());
    if (is24hour) {
        mClockAmPmStyle.setSummary(R.string.status_bar_am_pm_info);
    } else {
        mClockAmPmStyle.setSummary(mClockAmPmStyle.getEntry());
    }
    mClockAmPmStyle.setEnabled(!is24hour);
    mClockDateDisplay = (ListPreference) findPreference(PREF_CLOCK_DATE_DISPLAY);
    mClockDateDisplay.setOnPreferenceChangeListener(this);
    mClockDateDisplay.setValue(Integer.toString(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_DISPLAY, 0)));
    mClockDateDisplay.setSummary(mClockDateDisplay.getEntry());
    mClockDateStyle = (ListPreference) findPreference(PREF_CLOCK_DATE_STYLE);
    mClockDateStyle.setOnPreferenceChangeListener(this);
    mClockDateStyle.setValue(Integer.toString(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_STYLE, 2)));
    mClockDateStyle.setSummary(mClockDateStyle.getEntry());
    mClockDateFormat = (ListPreference) findPreference(PREF_CLOCK_DATE_FORMAT);
    mClockDateFormat.setOnPreferenceChangeListener(this);
    String clockDateFormat = Settings.System.getString(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_FORMAT);
    if (clockDateFormat == null) {
        mClockDateFormat.setValue("EEE");
    } else {
        mClockDateFormat.setValue(clockDateFormat);
    }
    parseClockDateFormats();
    mClockDateFormat.setSummary(mClockDateFormat.getEntry());
    mStatusBarClock = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_CLOCK);
    mStatusBarClock.setChecked((Settings.System.getInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.STATUS_BAR_CLOCK, 1) == 1));
    mStatusBarClock.setOnPreferenceChangeListener(this);
    mStatusBarClockLockscreen = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_CLOCK_LOCKSCREEN);
    mStatusBarClockLockscreen.setChecked((Settings.System.getInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.STATUS_BAR_CLOCK_LOCKSCREEN, 0) == 1));
    mStatusBarClockLockscreen.setOnPreferenceChangeListener(this);
    try {
        if (Settings.System.getInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.TIME_12_24) == 24) {
            mClockAmPmStyle.setEnabled(false);
            mClockAmPmStyle.setSummary(R.string.status_bar_am_pm_info);
        }
    } catch (SettingNotFoundException e) {
    }
    boolean mClockDateToggle = Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_DISPLAY, 0) != 0;
    if (!mClockDateToggle) {
        mClockDateStyle.setEnabled(false);
        mClockDateFormat.setEnabled(false);
    }
    return prefSet;
}
#method_after
private PreferenceScreen createCustomView() {
    addPreferencesFromResource(R.xml.status_bar_clock_style);
    PreferenceScreen prefSet = getPreferenceScreen();
    mClockStyle = (ListPreference) findPreference(PREF_ENABLE);
    mClockStyle.setOnPreferenceChangeListener(this);
    mClockStyle.setValue(Integer.toString(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_STYLE, 0)));
    mClockStyle.setSummary(mClockStyle.getEntry());
    mClockAmPmStyle = (ListPreference) prefSet.findPreference(PREF_AM_PM_STYLE);
    mClockAmPmStyle.setOnPreferenceChangeListener(this);
    mClockAmPmStyle.setValue(Integer.toString(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_AM_PM_STYLE, 0)));
    boolean is24hour = DateFormat.is24HourFormat(getActivity());
    if (is24hour) {
        mClockAmPmStyle.setSummary(R.string.status_bar_am_pm_info);
    } else {
        mClockAmPmStyle.setSummary(mClockAmPmStyle.getEntry());
    }
    mClockAmPmStyle.setEnabled(!is24hour);
    mClockDateDisplay = (ListPreference) findPreference(PREF_CLOCK_DATE_DISPLAY);
    mClockDateDisplay.setOnPreferenceChangeListener(this);
    mClockDateDisplay.setValue(Integer.toString(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_DISPLAY, 0)));
    mClockDateDisplay.setSummary(mClockDateDisplay.getEntry());
    mClockDateStyle = (ListPreference) findPreference(PREF_CLOCK_DATE_STYLE);
    mClockDateStyle.setOnPreferenceChangeListener(this);
    mClockDateStyle.setValue(Integer.toString(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_STYLE, 2)));
    mClockDateStyle.setSummary(mClockDateStyle.getEntry());
    mClockDateFormat = (ListPreference) findPreference(PREF_CLOCK_DATE_FORMAT);
    mClockDateFormat.setOnPreferenceChangeListener(this);
    String clockDateFormat = Settings.System.getString(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_FORMAT);
    if (clockDateFormat == null) {
        mClockDateFormat.setValue("EEE");
    } else {
        mClockDateFormat.setValue(clockDateFormat);
    }
    parseClockDateFormats();
    mClockDateFormat.setSummary(mClockDateFormat.getEntry());
    mStatusBarClock = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_CLOCK);
    mStatusBarClock.setChecked((Settings.System.getInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.STATUS_BAR_CLOCK, 1) == 1));
    mStatusBarClock.setOnPreferenceChangeListener(this);
    try {
        if (Settings.System.getInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.TIME_12_24) == 24) {
            mClockAmPmStyle.setEnabled(false);
            mClockAmPmStyle.setSummary(R.string.status_bar_am_pm_info);
        }
    } catch (SettingNotFoundException e) {
    }
    boolean mClockDateToggle = Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_DISPLAY, 0) != 0;
    if (!mClockDateToggle) {
        mClockDateStyle.setEnabled(false);
        mClockDateFormat.setEnabled(false);
    }
    mForceClockLockscreen = (CheckBoxPreference) findPreference(STATUS_BAR_FORCE_CLOCK_LOCKSCREEN);
    mForceClockLockscreen.setChecked(Settings.System.getInt(getActivity().getContentResolver(), Settings.System.STATUS_BAR_FORCE_CLOCK_LOCKSCREEN, 0) != 0);
    mForceClockLockscreen.setOnPreferenceChangeListener(this);
    return prefSet;
}
#end_block

#method_before
public boolean onPreferenceChange(Preference preference, Object newValue) {
    if (preference == mClockAmPmStyle) {
        int val = Integer.parseInt((String) newValue);
        int index = mClockAmPmStyle.findIndexOfValue((String) newValue);
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_AM_PM_STYLE, val);
        mClockAmPmStyle.setSummary(mClockAmPmStyle.getEntries()[index]);
        return true;
    } else if (preference == mClockStyle) {
        int val = Integer.parseInt((String) newValue);
        int index = mClockStyle.findIndexOfValue((String) newValue);
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_STYLE, val);
        mClockStyle.setSummary(mClockStyle.getEntries()[index]);
        return true;
    } else if (preference == mClockDateDisplay) {
        int val = Integer.parseInt((String) newValue);
        int index = mClockDateDisplay.findIndexOfValue((String) newValue);
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_DISPLAY, val);
        mClockDateDisplay.setSummary(mClockDateDisplay.getEntries()[index]);
        if (val == 0) {
            mClockDateStyle.setEnabled(false);
            mClockDateFormat.setEnabled(false);
        } else {
            mClockDateStyle.setEnabled(true);
            mClockDateFormat.setEnabled(true);
        }
        return true;
    } else if (preference == mClockDateStyle) {
        int val = Integer.parseInt((String) newValue);
        int index = mClockDateStyle.findIndexOfValue((String) newValue);
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_STYLE, val);
        mClockDateStyle.setSummary(mClockDateStyle.getEntries()[index]);
        parseClockDateFormats();
        return true;
    } else if (preference == mStatusBarClock) {
        Settings.System.putInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.STATUS_BAR_CLOCK, (Boolean) newValue ? 1 : 0);
        return true;
    } else if (preference == mStatusBarClockLockscreen) {
        Settings.System.putInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.STATUS_BAR_CLOCK_LOCKSCREEN, (Boolean) newValue ? 1 : 0);
        return true;
    } else if (preference == mClockDateFormat) {
        if ((String) newValue != null) {
            Settings.System.putString(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_FORMAT, (String) newValue);
            int idx = mClockDateFormat.findIndexOfValue((String) newValue);
            mClockDateFormat.setSummary(mClockDateFormat.getEntries()[idx]);
        }
        return true;
    }
    return false;
}
#method_after
public boolean onPreferenceChange(Preference preference, Object newValue) {
    if (preference == mClockAmPmStyle) {
        int val = Integer.parseInt((String) newValue);
        int index = mClockAmPmStyle.findIndexOfValue((String) newValue);
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_AM_PM_STYLE, val);
        mClockAmPmStyle.setSummary(mClockAmPmStyle.getEntries()[index]);
        return true;
    } else if (preference == mClockStyle) {
        int val = Integer.parseInt((String) newValue);
        int index = mClockStyle.findIndexOfValue((String) newValue);
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_STYLE, val);
        mClockStyle.setSummary(mClockStyle.getEntries()[index]);
        return true;
    } else if (preference == mClockDateDisplay) {
        int val = Integer.parseInt((String) newValue);
        int index = mClockDateDisplay.findIndexOfValue((String) newValue);
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_DISPLAY, val);
        mClockDateDisplay.setSummary(mClockDateDisplay.getEntries()[index]);
        if (val == 0) {
            mClockDateStyle.setEnabled(false);
            mClockDateFormat.setEnabled(false);
        } else {
            mClockDateStyle.setEnabled(true);
            mClockDateFormat.setEnabled(true);
        }
        return true;
    } else if (preference == mClockDateStyle) {
        int val = Integer.parseInt((String) newValue);
        int index = mClockDateStyle.findIndexOfValue((String) newValue);
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_STYLE, val);
        mClockDateStyle.setSummary(mClockDateStyle.getEntries()[index]);
        parseClockDateFormats();
        return true;
    } else if (preference == mStatusBarClock) {
        Settings.System.putInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.STATUS_BAR_CLOCK, (Boolean) newValue ? 1 : 0);
        return true;
    } else if (preference == mClockDateFormat) {
        if ((String) newValue != null) {
            Settings.System.putString(getActivity().getContentResolver(), Settings.System.STATUSBAR_CLOCK_DATE_FORMAT, (String) newValue);
            int idx = mClockDateFormat.findIndexOfValue((String) newValue);
            mClockDateFormat.setSummary(mClockDateFormat.getEntries()[idx]);
        }
        return true;
    } else if (preference == mForceClockLockscreen) {
        Settings.System.putInt(getActivity().getContentResolver(), Settings.System.STATUS_BAR_FORCE_CLOCK_LOCKSCREEN, (Boolean) newValue ? 1 : 0);
        return true;
    }
    return false;
}
#end_block

#method_before
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    boolean autoBrightness = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, 0, UserHandle.USER_CURRENT) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC;
    mBrightnessControl = !autoBrightness && Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0, UserHandle.USER_CURRENT) == 1;
    mCustomHeader = Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_CUSTOM_HEADER, 0, UserHandle.USER_CURRENT) == 1;
    int showNavBar = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_SHOW, -1, UserHandle.USER_CURRENT);
    forceShowClockOnLockscreen = Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_FORCE_CLOCK_LOCKSCREEN, 0, UserHandle.USER_CURRENT) == 1;
    if (showNavBar != -1) {
        boolean showNavBarBool = showNavBar == 1;
        if (showNavBarBool != mShowNavBar) {
            updateNavigationBar();
        }
    }
    updateCustomHeaderStatus();
}
#method_after
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    boolean autoBrightness = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, 0, UserHandle.USER_CURRENT) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC;
    mBrightnessControl = !autoBrightness && Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0, UserHandle.USER_CURRENT) == 1;
    mCustomHeader = Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_CUSTOM_HEADER, 0, UserHandle.USER_CURRENT) == 1;
    int showNavBar = Settings.System.getIntForUser(resolver, Settings.System.NAVIGATION_BAR_SHOW, -1, UserHandle.USER_CURRENT);
    mForceShowClockOnLockscreen = Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_FORCE_CLOCK_LOCKSCREEN, 0, UserHandle.USER_CURRENT) == 1;
    if (showNavBar != -1) {
        boolean showNavBarBool = showNavBar == 1;
        if (showNavBarBool != mShowNavBar) {
            updateNavigationBar();
        }
    }
    updateCustomHeaderStatus();
}
#end_block

#method_before
public void showClock(boolean show) {
    if (mStatusBarView == null)
        return;
    if (mClock != null) {
        mClock.updateVisibilityFromStatusBar(show);
    }
    if (mClockCenter != null) {
        mClockCenter.updateVisibilityFromStatusBar(show);
    }
}
#method_after
public void showClock(boolean show) {
    if (mStatusBarView == null)
        return;
    if (mForceShowClockOnLockscreen) {
        show = true;
    }
    if (mClock != null) {
        mClock.updateVisibilityFromStatusBar(show);
    }
    if (mClockCenter != null) {
        mClockCenter.updateVisibilityFromStatusBar(show);
    }
}
#end_block

#method_before
public void disable(int state) {
    final int old = mDisabled;
    final int diff = state ^ old;
    mDisabled = state;
    if (DEBUG) {
        Log.d(TAG, String.format("disable: 0x%08x -> 0x%08x (diff: 0x%08x)", old, state, diff));
        StringBuilder flagdbg = new StringBuilder();
        flagdbg.append("disable: < ");
        flagdbg.append(((state & StatusBarManager.DISABLE_EXPAND) != 0) ? "EXPAND" : "expand");
        flagdbg.append(((diff & StatusBarManager.DISABLE_EXPAND) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) ? "ICONS" : "icons");
        flagdbg.append(((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_NOTIFICATION_ALERTS) != 0) ? "ALERTS" : "alerts");
        flagdbg.append(((diff & StatusBarManager.DISABLE_NOTIFICATION_ALERTS) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_NOTIFICATION_TICKER) != 0) ? "TICKER" : "ticker");
        flagdbg.append(((diff & StatusBarManager.DISABLE_NOTIFICATION_TICKER) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_SYSTEM_INFO) != 0) ? "SYSTEM_INFO" : "system_info");
        flagdbg.append(((diff & StatusBarManager.DISABLE_SYSTEM_INFO) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_BACK) != 0) ? "BACK" : "back");
        flagdbg.append(((diff & StatusBarManager.DISABLE_BACK) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_HOME) != 0) ? "HOME" : "home");
        flagdbg.append(((diff & StatusBarManager.DISABLE_HOME) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_RECENT) != 0) ? "RECENT" : "recent");
        flagdbg.append(((diff & StatusBarManager.DISABLE_RECENT) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_CLOCK) != 0) ? "CLOCK" : "clock");
        flagdbg.append(((diff & StatusBarManager.DISABLE_CLOCK) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_SEARCH) != 0) ? "SEARCH" : "search");
        flagdbg.append(((diff & StatusBarManager.DISABLE_SEARCH) != 0) ? "* " : " ");
        flagdbg.append(">");
        Log.d(TAG, flagdbg.toString());
    }
    if ((diff & StatusBarManager.DISABLE_SYSTEM_INFO) != 0) {
        mSystemIconArea.animate().cancel();
        if ((state & StatusBarManager.DISABLE_SYSTEM_INFO) != 0) {
            mSystemIconArea.animate().alpha(0f).translationY(mNaturalBarHeight * 0.5f).setDuration(175).setInterpolator(new DecelerateInterpolator(1.5f)).setListener(mMakeIconsInvisible).start();
        } else {
            mSystemIconArea.setVisibility(View.VISIBLE);
            mSystemIconArea.animate().alpha(1f).translationY(0).setStartDelay(0).setInterpolator(new DecelerateInterpolator(1.5f)).setDuration(175).start();
        }
    }
    if ((diff & StatusBarManager.DISABLE_CLOCK) != 0) {
        boolean show = ((state & StatusBarManager.DISABLE_CLOCK) == 0) || forceShowClockOnLockscreen;
        showClock(show);
    }
    if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
        if ((state & StatusBarManager.DISABLE_EXPAND) != 0) {
            animateCollapsePanels();
        }
    }
    if ((diff & (StatusBarManager.DISABLE_HOME | StatusBarManager.DISABLE_RECENT | StatusBarManager.DISABLE_BACK | StatusBarManager.DISABLE_SEARCH)) != 0) {
        // the nav bar will take care of these
        if (mNavigationBarView != null)
            mNavigationBarView.setDisabledFlags(state);
        if ((state & StatusBarManager.DISABLE_RECENT) != 0) {
            // close recents if it's visible
            mHandler.removeMessages(MSG_CLOSE_RECENTS_PANEL);
            mHandler.sendEmptyMessage(MSG_CLOSE_RECENTS_PANEL);
        }
    }
    if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
        if ((state & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
            if (mTicking) {
                haltTicker();
            }
            mNotificationIcons.animate().alpha(0f).translationY(mNaturalBarHeight * 0.5f).setDuration(175).setInterpolator(new DecelerateInterpolator(1.5f)).setListener(mMakeIconsInvisible).start();
        } else {
            mNotificationIcons.setVisibility(View.VISIBLE);
            mNotificationIcons.animate().alpha(1f).translationY(0).setStartDelay(0).setInterpolator(new DecelerateInterpolator(1.5f)).setDuration(175).start();
        }
    } else if ((diff & StatusBarManager.DISABLE_NOTIFICATION_TICKER) != 0) {
        if (mTicking && (state & StatusBarManager.DISABLE_NOTIFICATION_TICKER) != 0) {
            haltTicker();
        }
    }
}
#method_after
public void disable(int state) {
    final int old = mDisabled;
    final int diff = state ^ old;
    mDisabled = state;
    if (DEBUG) {
        Log.d(TAG, String.format("disable: 0x%08x -> 0x%08x (diff: 0x%08x)", old, state, diff));
        StringBuilder flagdbg = new StringBuilder();
        flagdbg.append("disable: < ");
        flagdbg.append(((state & StatusBarManager.DISABLE_EXPAND) != 0) ? "EXPAND" : "expand");
        flagdbg.append(((diff & StatusBarManager.DISABLE_EXPAND) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) ? "ICONS" : "icons");
        flagdbg.append(((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_NOTIFICATION_ALERTS) != 0) ? "ALERTS" : "alerts");
        flagdbg.append(((diff & StatusBarManager.DISABLE_NOTIFICATION_ALERTS) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_NOTIFICATION_TICKER) != 0) ? "TICKER" : "ticker");
        flagdbg.append(((diff & StatusBarManager.DISABLE_NOTIFICATION_TICKER) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_SYSTEM_INFO) != 0) ? "SYSTEM_INFO" : "system_info");
        flagdbg.append(((diff & StatusBarManager.DISABLE_SYSTEM_INFO) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_BACK) != 0) ? "BACK" : "back");
        flagdbg.append(((diff & StatusBarManager.DISABLE_BACK) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_HOME) != 0) ? "HOME" : "home");
        flagdbg.append(((diff & StatusBarManager.DISABLE_HOME) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_RECENT) != 0) ? "RECENT" : "recent");
        flagdbg.append(((diff & StatusBarManager.DISABLE_RECENT) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_CLOCK) != 0) ? "CLOCK" : "clock");
        flagdbg.append(((diff & StatusBarManager.DISABLE_CLOCK) != 0) ? "* " : " ");
        flagdbg.append(((state & StatusBarManager.DISABLE_SEARCH) != 0) ? "SEARCH" : "search");
        flagdbg.append(((diff & StatusBarManager.DISABLE_SEARCH) != 0) ? "* " : " ");
        flagdbg.append(">");
        Log.d(TAG, flagdbg.toString());
    }
    if ((diff & StatusBarManager.DISABLE_SYSTEM_INFO) != 0) {
        mSystemIconArea.animate().cancel();
        if ((state & StatusBarManager.DISABLE_SYSTEM_INFO) != 0) {
            mSystemIconArea.animate().alpha(0f).translationY(mNaturalBarHeight * 0.5f).setDuration(175).setInterpolator(new DecelerateInterpolator(1.5f)).setListener(mMakeIconsInvisible).start();
        } else {
            mSystemIconArea.setVisibility(View.VISIBLE);
            mSystemIconArea.animate().alpha(1f).translationY(0).setStartDelay(0).setInterpolator(new DecelerateInterpolator(1.5f)).setDuration(175).start();
        }
    }
    if ((diff & StatusBarManager.DISABLE_CLOCK) != 0) {
        boolean show = (state & StatusBarManager.DISABLE_CLOCK) == 0;
        showClock(show);
    }
    if ((diff & StatusBarManager.DISABLE_EXPAND) != 0) {
        if ((state & StatusBarManager.DISABLE_EXPAND) != 0) {
            animateCollapsePanels();
        }
    }
    if ((diff & (StatusBarManager.DISABLE_HOME | StatusBarManager.DISABLE_RECENT | StatusBarManager.DISABLE_BACK | StatusBarManager.DISABLE_SEARCH)) != 0) {
        // the nav bar will take care of these
        if (mNavigationBarView != null)
            mNavigationBarView.setDisabledFlags(state);
        if ((state & StatusBarManager.DISABLE_RECENT) != 0) {
            // close recents if it's visible
            mHandler.removeMessages(MSG_CLOSE_RECENTS_PANEL);
            mHandler.sendEmptyMessage(MSG_CLOSE_RECENTS_PANEL);
        }
    }
    if ((diff & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
        if ((state & StatusBarManager.DISABLE_NOTIFICATION_ICONS) != 0) {
            if (mTicking) {
                haltTicker();
            }
            mNotificationIcons.animate().alpha(0f).translationY(mNaturalBarHeight * 0.5f).setDuration(175).setInterpolator(new DecelerateInterpolator(1.5f)).setListener(mMakeIconsInvisible).start();
        } else {
            mNotificationIcons.setVisibility(View.VISIBLE);
            mNotificationIcons.animate().alpha(1f).translationY(0).setStartDelay(0).setInterpolator(new DecelerateInterpolator(1.5f)).setDuration(175).start();
        }
    } else if ((diff & StatusBarManager.DISABLE_NOTIFICATION_TICKER) != 0) {
        if (mTicking && (state & StatusBarManager.DISABLE_NOTIFICATION_TICKER) != 0) {
            haltTicker();
        }
    }
}
#end_block

#method_before
@Override
public void setImeWindowStatus(IBinder token, int vis, int backDisposition) {
    final boolean altBack = (backDisposition == InputMethodService.BACK_DISPOSITION_WILL_DISMISS) || ((vis & InputMethodService.IME_VISIBLE) != 0);
    setNavigationIconHints(altBack ? (mNavigationIconHints | NAVIGATION_HINT_BACK_ALT) : (mNavigationIconHints & ~NAVIGATION_HINT_BACK_ALT));
    if (mQS != null)
        mQS.setImeWindowStatus(vis > 0);
    if (mCurrentColorProgress != 0) {
        if (mImeStatusShow) {
            mImeStatusShow = altBack;
            setSystemUIBackgroundColor(300);
        } else {
            mHandler.postDelayed(new Runnable() {

                @Override
                public void run() {
                    mImeStatusShow = altBack;
                }
            }, AUTOHIDE_TIMEOUT_MS);
        }
    }
}
#method_after
@Override
public void setImeWindowStatus(IBinder token, int vis, int backDisposition) {
    boolean altBack = (backDisposition == InputMethodService.BACK_DISPOSITION_WILL_DISMISS) || ((vis & InputMethodService.IME_VISIBLE) != 0);
    setNavigationIconHints(altBack ? (mNavigationIconHints | NAVIGATION_HINT_BACK_ALT) : (mNavigationIconHints & ~NAVIGATION_HINT_BACK_ALT));
    if (mQS != null)
        mQS.setImeWindowStatus(vis > 0);
    setSystemUIBackgroundColorOnIme(altBack);
}
#end_block

#method_before
private void resetSystemUIBackgroundColor() {
    if (!mTintedNeedReset) {
        return;
    }
    mTintedNeedReset = false;
    mHandler.removeCallbacks(mSetColorFromScreenShotRunnable);
    mHandler.removeCallbacks(mTintedStatusbarRunnable);
    mPackageActbar = mPackageSt = mPackageNv = mPackageIcSt = -3;
    mStatusbarIsReset = mNavbarIsReset = true;
    if (mStatusBarView != null) {
        mStatusBarView.getBarTransitions().changeColorIconBackground(mPackageSt, mPackageIcSt);
    }
    if (mNavigationBarView != null) {
        mNavigationBarView.getBarTransitions().changeColorIconBackground(mPackageNv, mPackageIcSt);
    }
    if (mBattery != null) {
        mBattery.updateSettings(mPackageIcSt);
    }
    if (mCircleBattery != null) {
        mCircleBattery.updateSettings();
    }
    if (mPercentBattery != null) {
        mPercentBattery.updateSettings();
    }
    Log.w(TAG, "Reset tinted statusbar");
}
#method_after
private void resetSystemUIBackgroundColor() {
    if (!mTintedNeedReset) {
        return;
    }
    Log.w(TAG, "Reset tinted statusbar");
    mTintedNeedReset = false;
    mHandler.removeCallbacks(mSetColorFromScreenShotRunnable);
    mHandler.removeCallbacks(mTintedStatusbarRunnable);
    mPackageActbar = mPackageSt = mPackageNv = mPackageIcSt = -3;
    mStatusbarIsReset = mNavbarIsReset = true;
    if (mStatusBarView != null) {
        mStatusBarView.getBarTransitions().changeColorIconBackground(mPackageSt, mPackageIcSt);
    }
    if (mNavigationBarView != null) {
        mNavigationBarView.getBarTransitions().changeColorIconBackground(mPackageNv, mPackageIcSt);
    }
    if (mBattery != null) {
        mBattery.updateSettings(mPackageIcSt);
    }
    if (mCircleBattery != null) {
        mCircleBattery.updateSettings();
    }
    if (mPercentBattery != null) {
        mPercentBattery.updateSettings();
    }
}
#end_block

#method_before
private void tintedStatusbarProgress() {
    if ((mCurrentTintedProgress == 0 || mCurrentTintedProgress == 2) && mStatBackgroundMode) {
        mStatusbarIsReset = false;
        if (mColorFilterEnabled) {
            mPackageSt = ColorUtils.opposeColor(mPackageSt);
        }
        if (mStatusbarTransparent < 100) {
            mPackageSt = ColorUtils.changeColorTransparency(mPackageSt, mStatusbarTransparent);
        }
        Log.w(TAG, "process statusbar color");
        mStatusBarView.getBarTransitions().changeColorIconBackground(mPackageSt, mPackageIcSt);
        int colorFromStatusbar = mStatusBarView.getPhoneStatusBarTransitions().getCurrentIconColor();
        boolean shouldChange = (colorFromStatusbar != -3);
        if (mBattery != null) {
            mBattery.updateSettings(shouldChange ? colorFromStatusbar : -3);
        }
        if (mCircleBattery != null) {
            if (shouldChange) {
                mCircleBattery.updateSettings(colorFromStatusbar);
            } else {
                mCircleBattery.updateSettings();
            }
        }
        if (mPercentBattery != null) {
            if (shouldChange) {
                mPercentBattery.updateSettings(colorFromStatusbar);
            } else {
                mPercentBattery.updateSettings();
            }
        }
    }
    if (mNavigationBarView != null && mNavBackgroundMode && (mCurrentTintedProgress == 1 || mCurrentTintedProgress == 2)) {
        mNavbarIsReset = false;
        if (mColorFilterEnabled) {
            mPackageNv = ColorUtils.opposeColor(mPackageNv);
        }
        if (mNavbarTransparent < 100) {
            mPackageNv = ColorUtils.changeColorTransparency(mPackageNv, mNavbarTransparent);
        }
        Log.w(TAG, "process navbar color");
        mNavigationBarView.getBarTransitions().changeColorIconBackground(mPackageNv, mPackageIcSt);
    }
    if (mStatBackgroundMode || mNavBackgroundMode) {
        mTintedNeedReset = true;
    }
}
#method_after
private void tintedStatusbarProgress() {
    if ((mCurrentTintedProgress == 0 || mCurrentTintedProgress == 2) && mStatBackgroundMode) {
        mStatusbarIsReset = false;
        if (mColorFilterEnabled) {
            mPackageSt = ColorUtils.opposeColor(mPackageSt);
        }
        if (mStatusbarTransparent < 100) {
            mPackageSt = ColorUtils.changeColorTransparency(mPackageSt, mStatusbarTransparent);
        }
        mStatusBarView.getBarTransitions().changeColorIconBackground(mPackageSt, mPackageIcSt);
        int colorFromStatusbar = mStatusBarView.getPhoneStatusBarTransitions().getCurrentIconColor();
        boolean shouldChange = (colorFromStatusbar != -3);
        if (mBattery != null) {
            mBattery.updateSettings(shouldChange ? colorFromStatusbar : -3);
        }
        if (mCircleBattery != null) {
            if (shouldChange) {
                mCircleBattery.updateSettings(colorFromStatusbar);
            } else {
                mCircleBattery.updateSettings();
            }
        }
        if (mPercentBattery != null) {
            if (shouldChange) {
                mPercentBattery.updateSettings(colorFromStatusbar);
            } else {
                mPercentBattery.updateSettings();
            }
        }
    }
    if (mNavigationBarView != null && mNavBackgroundMode && (mCurrentTintedProgress == 1 || mCurrentTintedProgress == 2)) {
        mNavbarIsReset = false;
        if (mColorFilterEnabled) {
            mPackageNv = ColorUtils.opposeColor(mPackageNv);
        }
        if (mNavbarTransparent < 100) {
            mPackageNv = ColorUtils.changeColorTransparency(mPackageNv, mNavbarTransparent);
        }
        mNavigationBarView.getBarTransitions().changeColorIconBackground(mPackageNv, mPackageIcSt);
    }
    if (mStatBackgroundMode || mNavBackgroundMode) {
        mTintedNeedReset = true;
    }
}
#end_block

#method_before
@Override
public void setImeWindowStatus(IBinder token, int vis, int backDisposition) {
    final boolean altBack = (backDisposition == InputMethodService.BACK_DISPOSITION_WILL_DISMISS) || ((vis & InputMethodService.IME_VISIBLE) != 0);
    setNavigationIconHints(altBack ? (mNavigationIconHints | NAVIGATION_HINT_BACK_ALT) : (mNavigationIconHints & ~NAVIGATION_HINT_BACK_ALT));
    if (mQS != null)
        mQS.setImeWindowStatus(vis > 0);
    if (mCurrentColorProgress != 0) {
        if (mImeStatusShow) {
            mImeStatusShow = altBack;
            setSystemUIBackgroundColor(300);
        } else {
            mHandler.postDelayed(new Runnable() {

                @Override
                public void run() {
                    mImeStatusShow = altBack;
                }
            }, AUTOHIDE_TIMEOUT_MS);
        }
    }
}
#method_after
@Override
public void setImeWindowStatus(IBinder token, int vis, int backDisposition) {
    boolean altBack = (backDisposition == InputMethodService.BACK_DISPOSITION_WILL_DISMISS) || ((vis & InputMethodService.IME_VISIBLE) != 0);
    setNavigationIconHints(altBack ? (mNavigationIconHints | NAVIGATION_HINT_BACK_ALT) : (mNavigationIconHints & ~NAVIGATION_HINT_BACK_ALT));
    if (mQS != null)
        mQS.setImeWindowStatus(vis > 0);
    setSystemUIBackgroundColorOnIme(altBack);
}
#end_block

#method_before
// CommandQueue
@Override
public void sendActionColorBroadcast(int st_color, int ic_color) {
    if (mCurrentColorProgress != 0) {
        mPackageActbar = st_color;
        if (st_color != -3) {
            mPackageIcSt = ic_color;
        }
    }
}
#method_after
// CommandQueue
@Override
public void sendActionColorBroadcast(int st_color, int ic_color) {
    if (mCurrentColorProgress != 0) {
        mPackageActbar = st_color;
        mPackageIcSt = ic_color;
    }
}
#end_block

#method_before
private void updateAvatarView() {
    Drawable avatarDrawable;
    if (mConversation.getRecipients().size() == 1) {
        Contact contact = mConversation.getRecipients().get(0);
        avatarDrawable = contact.getAvatar(mContext, null);
        if (contact.existsInDatabase()) {
            mAvatarView.assignContactUri(contact.getUri());
        } else {
            mAvatarView.assignContactFromPhone(contact.getNumber(), true);
        }
        if (avatarDrawable == null) {
            // (Alternative: ContactPhotoManager.TYPE_PERSON - need to try out)
            DefaultImageRequest defaultImageRequest = new DefaultImageRequest(contact.getName(), ContactPhotoManager.TYPE_DEFAULT);
            avatarDrawable = LetterTileDefaultImageProvider.getDefaultImageForContact(mContext.getResources(), defaultImageRequest);
        }
    } else {
        // TODO get a multiple recipients asset (or do something else)
        avatarDrawable = sDefaultContactImage;
        mAvatarView.assignContactUri(null);
    }
    mAvatarView.setImageDrawable(avatarDrawable);
    mAvatarView.setVisibility(View.VISIBLE);
}
#method_after
private void updateAvatarView() {
    Drawable avatarDrawable;
    if (mConversation.getRecipients().size() == 1) {
        Contact contact = mConversation.getRecipients().get(0);
        avatarDrawable = contact.getAvatar(mContext, null);
        if (contact.existsInDatabase()) {
            mAvatarView.assignContactUri(contact.getUri());
        } else {
            mAvatarView.assignContactFromPhone(contact.getNumber(), true);
        }
        if (avatarDrawable == null) {
            DefaultImageRequest defaultImageRequest = new DefaultImageRequest(contact.getName(), contact.getLookupKey() + "");
            avatarDrawable = ContactPhotoManager.getDefaultAvatarDrawableForContact(mContext.getResources(), false, defaultImageRequest);
        }
    } else {
        // TODO get a multiple recipients asset (or do something else)
        avatarDrawable = sDefaultContactImage;
        mAvatarView.assignContactUri(null);
    }
    mAvatarView.setImageDrawable(avatarDrawable);
    mAvatarView.setVisibility(View.VISIBLE);
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    int device;
    int state;
    if (action.equals(Intent.ACTION_DOCK_EVENT)) {
        int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
        int config;
        switch(dockState) {
            case Intent.EXTRA_DOCK_STATE_DESK:
                config = AudioSystem.FORCE_BT_DESK_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_CAR:
                config = AudioSystem.FORCE_BT_CAR_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_LE_DESK:
                config = AudioSystem.FORCE_ANALOG_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_HE_DESK:
                config = AudioSystem.FORCE_DIGITAL_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
            default:
                config = AudioSystem.FORCE_NONE;
        }
        // (see mDockAudioMediaEnabled)
        if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
            AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
        }
        mDockState = dockState;
    } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
        state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED);
        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
        String address = null;
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (btDevice == null) {
            return;
        }
        address = btDevice.getAddress();
        BluetoothClass btClass = btDevice.getBluetoothClass();
        if (btClass != null) {
            switch(btClass.getDeviceClass()) {
                case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                    break;
                case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                    break;
            }
        }
        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
            address = "";
        }
        boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
        if (handleDeviceConnection(connected, device, address)) {
            synchronized (mScoClients) {
                if (connected) {
                    mBluetoothHeadsetDevice = btDevice;
                } else {
                    mBluetoothHeadsetDevice = null;
                    resetBluetoothSco();
                }
            }
        }
    } else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) || action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
        state = intent.getIntExtra("state", 0);
        int alsaCard = intent.getIntExtra("card", -1);
        int alsaDevice = intent.getIntExtra("device", -1);
        String params = (alsaCard == -1 && alsaDevice == -1 ? "" : "card=" + alsaCard + ";device=" + alsaDevice);
        device = action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
        Log.v(TAG, "Broadcast Receiver: Got " + (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? "ACTION_USB_AUDIO_ACCESSORY_PLUG" : "ACTION_USB_AUDIO_DEVICE_PLUG") + ", state = " + state + ", card: " + alsaCard + ", device: " + alsaDevice);
        setWiredDeviceConnectionState(device, state, params);
    } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
        boolean broadcast = false;
        int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
        synchronized (mScoClients) {
            int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
            // broadcast intent if the connection was initated by AudioService
            if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
                broadcast = true;
            }
            switch(btState) {
                case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                    break;
                case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                    mScoAudioState = SCO_STATE_INACTIVE;
                    clearAllScoClients(0, false);
                    break;
                case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                default:
                    // do not broadcast CONNECTING or invalid state
                    broadcast = false;
                    break;
            }
        }
        if (broadcast) {
            broadcastScoConnectionState(scoAudioState);
            // FIXME: this is to maintain compatibility with deprecated intent
            // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
            sendStickyBroadcastToAll(newIntent);
        }
    } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        mBootCompleted = true;
        sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, null, 0);
        mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
        mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
        resetBluetoothSco();
        getBluetoothHeadset();
        // FIXME: this is to maintain compatibility with deprecated intent
        // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
        Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
        newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        sendStickyBroadcastToAll(newIntent);
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.A2DP);
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED, SENDMSG_REPLACE, 0, 0, null, SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
    } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
        AudioSystem.setParameters("screen_state=on");
    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
        AudioSystem.setParameters("screen_state=off");
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        handleConfigurationChanged(context);
    } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
        // attempt to stop music playback for background user
        sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
        // the current audio focus owner is no longer valid
        mMediaFocusControl.discardAudioFocusOwner();
        // load volume settings for new user
        readAudioSettings(true);
        // preserve STREAM_MUSIC volume from one user to the next.
        sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_MUSIC], 0);
    } else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
        // Only run when headset is inserted and is enabled at settings
        int plugged = intent.getIntExtra("state", 0);
        String headsetPlugIntenatUri = Settings.System.getStringForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, UserHandle.USER_CURRENT);
        boolean stopApp = Settings.System.getIntForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_STOP_APP, 0, UserHandle.USER_CURRENT) == 1;
        Intent headsetPlugIntent = null;
        if (plugged == 1 && headsetPlugIntenatUri != null) {
            // Run default music app
            if (headsetPlugIntenatUri.equals(Settings.System.HEADSET_PLUG_SYSTEM_DEFAULT)) {
                headsetPlugIntent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MUSIC);
                headsetPlugIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT);
            } else {
                try {
                    headsetPlugIntent = Intent.parseUri(headsetPlugIntenatUri, 0);
                } catch (URISyntaxException e) {
                    headsetPlugIntent = null;
                }
                if (headsetPlugIntent != null) {
                    String mPackage = headsetPlugIntent.getComponent().getPackageName();
                    if (isAvailableApp(mPackage)) {
                        headsetPlugIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT);
                    } else {
                        // Disable setting
                        Settings.System.putStringForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, null, UserHandle.USER_CURRENT);
                    }
                }
            }
        } else if (plugged == 0 && stopApp && headsetPlugIntenatUri != null) {
            String mKillAppName = null;
            if (headsetPlugIntenatUri.equals(Settings.System.HEADSET_PLUG_SYSTEM_DEFAULT)) {
                headsetPlugIntent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MUSIC);
                ResolveInfo da = mContext.getPackageManager().resolveActivity(headsetPlugIntent, PackageManager.MATCH_DEFAULT_ONLY);
                mKillAppName = da.activityInfo.packageName;
            } else {
                try {
                    headsetPlugIntent = Intent.parseUri(headsetPlugIntenatUri, 0);
                } catch (URISyntaxException e) {
                    headsetPlugIntent = null;
                }
                if (headsetPlugIntent != null) {
                    mKillAppName = headsetPlugIntent.getComponent().getPackageName();
                }
            }
            if (mKillAppName != null) {
                killApp(mKillAppName);
            }
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    int device;
    int state;
    if (action.equals(Intent.ACTION_DOCK_EVENT)) {
        int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
        int config;
        switch(dockState) {
            case Intent.EXTRA_DOCK_STATE_DESK:
                config = AudioSystem.FORCE_BT_DESK_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_CAR:
                config = AudioSystem.FORCE_BT_CAR_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_LE_DESK:
                config = AudioSystem.FORCE_ANALOG_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_HE_DESK:
                config = AudioSystem.FORCE_DIGITAL_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
            default:
                config = AudioSystem.FORCE_NONE;
        }
        // (see mDockAudioMediaEnabled)
        if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
            AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
        }
        mDockState = dockState;
    } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
        state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED);
        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
        String address = null;
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (btDevice == null) {
            return;
        }
        address = btDevice.getAddress();
        BluetoothClass btClass = btDevice.getBluetoothClass();
        if (btClass != null) {
            switch(btClass.getDeviceClass()) {
                case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                    break;
                case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                    break;
            }
        }
        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
            address = "";
        }
        boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
        if (handleDeviceConnection(connected, device, address)) {
            synchronized (mScoClients) {
                if (connected) {
                    mBluetoothHeadsetDevice = btDevice;
                } else {
                    mBluetoothHeadsetDevice = null;
                    resetBluetoothSco();
                }
            }
        }
    } else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) || action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
        state = intent.getIntExtra("state", 0);
        int alsaCard = intent.getIntExtra("card", -1);
        int alsaDevice = intent.getIntExtra("device", -1);
        String params = (alsaCard == -1 && alsaDevice == -1 ? "" : "card=" + alsaCard + ";device=" + alsaDevice);
        device = action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
        Log.v(TAG, "Broadcast Receiver: Got " + (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? "ACTION_USB_AUDIO_ACCESSORY_PLUG" : "ACTION_USB_AUDIO_DEVICE_PLUG") + ", state = " + state + ", card: " + alsaCard + ", device: " + alsaDevice);
        setWiredDeviceConnectionState(device, state, params);
    } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
        boolean broadcast = false;
        int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
        synchronized (mScoClients) {
            int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
            // broadcast intent if the connection was initated by AudioService
            if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
                broadcast = true;
            }
            switch(btState) {
                case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                    break;
                case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                    mScoAudioState = SCO_STATE_INACTIVE;
                    clearAllScoClients(0, false);
                    break;
                case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                default:
                    // do not broadcast CONNECTING or invalid state
                    broadcast = false;
                    break;
            }
        }
        if (broadcast) {
            broadcastScoConnectionState(scoAudioState);
            // FIXME: this is to maintain compatibility with deprecated intent
            // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
            sendStickyBroadcastToAll(newIntent);
        }
    } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        mBootCompleted = true;
        sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, null, 0);
        mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
        mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
        resetBluetoothSco();
        getBluetoothHeadset();
        // FIXME: this is to maintain compatibility with deprecated intent
        // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
        Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
        newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        sendStickyBroadcastToAll(newIntent);
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.A2DP);
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED, SENDMSG_REPLACE, 0, 0, null, SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
    } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
        AudioSystem.setParameters("screen_state=on");
    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
        AudioSystem.setParameters("screen_state=off");
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        handleConfigurationChanged(context);
    } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
        // attempt to stop music playback for background user
        sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
        // the current audio focus owner is no longer valid
        mMediaFocusControl.discardAudioFocusOwner();
        // load volume settings for new user
        readAudioSettings(true);
        // preserve STREAM_MUSIC volume from one user to the next.
        sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_MUSIC], 0);
    } else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
        String mAppName = null;
        int mPersistentId = -1;
        int plugged = intent.getIntExtra("state", 0);
        String headsetPlugIntenatUri = Settings.System.getStringForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, UserHandle.USER_CURRENT);
        boolean disableMusicActive = Settings.System.getIntForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_MUSIC_ACTIVE, 1, UserHandle.USER_CURRENT) == 1;
        int mHeadsetAction = Settings.System.getIntForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ACTIONS, 0, UserHandle.USER_CURRENT);
        int mHeadsetAppRunning = Settings.System.getIntForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_APP_RUNNING, 0, UserHandle.USER_CURRENT);
        boolean mHeadsetForceActions = Settings.System.getIntForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_FORCE_ACTIONS, 0, UserHandle.USER_CURRENT) == 1;
        Intent headsetPlugIntent = null;
        // If is not enabled at settings
        if (headsetPlugIntenatUri == null) {
            return;
        }
        // Let's found package name
        if (headsetPlugIntenatUri.equals(Settings.System.HEADSET_PLUG_SYSTEM_DEFAULT)) {
            headsetPlugIntent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MUSIC);
            ResolveInfo da = mContext.getPackageManager().resolveActivity(headsetPlugIntent, PackageManager.MATCH_DEFAULT_ONLY);
            mAppName = da.activityInfo.packageName;
        } else {
            try {
                headsetPlugIntent = Intent.parseUri(headsetPlugIntenatUri, 0);
            } catch (URISyntaxException e) {
                headsetPlugIntent = null;
            }
            if (headsetPlugIntent != null) {
                mAppName = headsetPlugIntent.getComponent().getPackageName();
            }
        }
        // Let's found task id
        if (mAppName != null) {
            mPersistentId = TaskUtils.getPackagePersistentId(mAppName, context);
        }
        if (plugged == 1) {
            // The app is already running
            if (mPersistentId != -1) {
                if (mHeadsetAppRunning == HEADSET_APP_TOFRONT) {
                    TaskUtils.movePackageToFront(mPersistentId, context);
                }
                // The same as mHeadsetAppRunning == HEADSET_APP_DONOTHING
                return;
            } else if (disableMusicActive && isLocalOrRemoteMusicActive()) {
                // The app is not running, but other app is playing music
                return;
            }
            // Run default music app
            if (headsetPlugIntenatUri.equals(Settings.System.HEADSET_PLUG_SYSTEM_DEFAULT)) {
                // Here headsetPlugIntent is never null
                headsetPlugIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT);
                mHeadsetAppStartedByShortcut = true;
            } else {
                // Try open a custom app
                if (headsetPlugIntent != null) {
                    if (PackageUtils.isAvailableApp(mAppName, context)) {
                        headsetPlugIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT);
                        mHeadsetAppStartedByShortcut = true;
                    } else {
                        // Disable setting
                        Settings.System.putStringForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, null, UserHandle.USER_CURRENT);
                    }
                }
            }
        } else if (// Run when removed
        plugged == 0 && // Enabled at settings
        mHeadsetAction != HEADSET_NONE_ACTION && // App is runnig
        mPersistentId != -1 && // App is started by us or actions are forced
        (mHeadsetAppStartedByShortcut || mHeadsetForceActions)) {
            if (mHeadsetAction == HEADSET_FRONT_ACTION) {
                TaskUtils.movePackageToFront(mPersistentId, context);
            } else if (mHeadsetAction == HEADSET_KILL_ACTION) {
                TaskUtils.killPackageProcess(mPersistentId, context);
            }
            mHeadsetAppStartedByShortcut = false;
        }
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    int device;
    int state;
    if (action.equals(Intent.ACTION_DOCK_EVENT)) {
        int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
        int config;
        switch(dockState) {
            case Intent.EXTRA_DOCK_STATE_DESK:
                config = AudioSystem.FORCE_BT_DESK_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_CAR:
                config = AudioSystem.FORCE_BT_CAR_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_LE_DESK:
                config = AudioSystem.FORCE_ANALOG_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_HE_DESK:
                config = AudioSystem.FORCE_DIGITAL_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
            default:
                config = AudioSystem.FORCE_NONE;
        }
        // (see mDockAudioMediaEnabled)
        if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
            AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
        }
        mDockState = dockState;
    } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
        state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED);
        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
        String address = null;
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (btDevice == null) {
            return;
        }
        address = btDevice.getAddress();
        BluetoothClass btClass = btDevice.getBluetoothClass();
        if (btClass != null) {
            switch(btClass.getDeviceClass()) {
                case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                    break;
                case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                    break;
            }
        }
        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
            address = "";
        }
        boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
        if (handleDeviceConnection(connected, device, address)) {
            synchronized (mScoClients) {
                if (connected) {
                    mBluetoothHeadsetDevice = btDevice;
                } else {
                    mBluetoothHeadsetDevice = null;
                    resetBluetoothSco();
                }
            }
        }
    } else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) || action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
        state = intent.getIntExtra("state", 0);
        int alsaCard = intent.getIntExtra("card", -1);
        int alsaDevice = intent.getIntExtra("device", -1);
        String params = (alsaCard == -1 && alsaDevice == -1 ? "" : "card=" + alsaCard + ";device=" + alsaDevice);
        device = action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
        Log.v(TAG, "Broadcast Receiver: Got " + (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? "ACTION_USB_AUDIO_ACCESSORY_PLUG" : "ACTION_USB_AUDIO_DEVICE_PLUG") + ", state = " + state + ", card: " + alsaCard + ", device: " + alsaDevice);
        setWiredDeviceConnectionState(device, state, params);
    } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
        boolean broadcast = false;
        int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
        synchronized (mScoClients) {
            int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
            // broadcast intent if the connection was initated by AudioService
            if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
                broadcast = true;
            }
            switch(btState) {
                case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                    break;
                case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                    mScoAudioState = SCO_STATE_INACTIVE;
                    clearAllScoClients(0, false);
                    break;
                case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                default:
                    // do not broadcast CONNECTING or invalid state
                    broadcast = false;
                    break;
            }
        }
        if (broadcast) {
            broadcastScoConnectionState(scoAudioState);
            // FIXME: this is to maintain compatibility with deprecated intent
            // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
            sendStickyBroadcastToAll(newIntent);
        }
    } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        mBootCompleted = true;
        sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, null, 0);
        mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
        mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
        resetBluetoothSco();
        getBluetoothHeadset();
        // FIXME: this is to maintain compatibility with deprecated intent
        // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
        Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
        newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        sendStickyBroadcastToAll(newIntent);
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.A2DP);
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED, SENDMSG_REPLACE, 0, 0, null, SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
    } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
        AudioSystem.setParameters("screen_state=on");
    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
        AudioSystem.setParameters("screen_state=off");
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        handleConfigurationChanged(context);
    } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
        // attempt to stop music playback for background user
        sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
        // the current audio focus owner is no longer valid
        mMediaFocusControl.discardAudioFocusOwner();
        // load volume settings for new user
        readAudioSettings(true);
        // preserve STREAM_MUSIC volume from one user to the next.
        sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_MUSIC], 0);
    } else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
        // Only run when headset is inserted and is enabled at settings
        int plugged = intent.getIntExtra("state", 0);
        String headsetPlugIntenatUri = Settings.System.getStringForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, UserHandle.USER_CURRENT);
        boolean musicActive = Settings.System.getIntForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_MUSIC_ACTIVE, 1, UserHandle.USER_CURRENT) == 1;
        Intent headsetPlugIntent = null;
        if (plugged == 1 && headsetPlugIntenatUri != null && (!musicActive || !isLocalOrRemoteMusicActive())) {
            // Run default music app
            if (headsetPlugIntenatUri.equals(Settings.System.HEADSET_PLUG_SYSTEM_DEFAULT)) {
                headsetPlugIntent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MUSIC);
                headsetPlugIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT);
            } else {
                try {
                    headsetPlugIntent = Intent.parseUri(headsetPlugIntenatUri, 0);
                } catch (URISyntaxException e) {
                    headsetPlugIntent = null;
                }
                if (headsetPlugIntent != null) {
                    String mPackage = headsetPlugIntent.getComponent().getPackageName();
                    if (isAvailableApp(mPackage)) {
                        headsetPlugIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT);
                    } else {
                        // Disable setting
                        Settings.System.putStringForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, null, UserHandle.USER_CURRENT);
                    }
                }
            }
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    int device;
    int state;
    if (action.equals(Intent.ACTION_DOCK_EVENT)) {
        int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
        int config;
        switch(dockState) {
            case Intent.EXTRA_DOCK_STATE_DESK:
                config = AudioSystem.FORCE_BT_DESK_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_CAR:
                config = AudioSystem.FORCE_BT_CAR_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_LE_DESK:
                config = AudioSystem.FORCE_ANALOG_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_HE_DESK:
                config = AudioSystem.FORCE_DIGITAL_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
            default:
                config = AudioSystem.FORCE_NONE;
        }
        // (see mDockAudioMediaEnabled)
        if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
            AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
        }
        mDockState = dockState;
    } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
        state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED);
        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
        String address = null;
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (btDevice == null) {
            return;
        }
        address = btDevice.getAddress();
        BluetoothClass btClass = btDevice.getBluetoothClass();
        if (btClass != null) {
            switch(btClass.getDeviceClass()) {
                case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                    break;
                case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                    break;
            }
        }
        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
            address = "";
        }
        boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
        if (handleDeviceConnection(connected, device, address)) {
            synchronized (mScoClients) {
                if (connected) {
                    mBluetoothHeadsetDevice = btDevice;
                } else {
                    mBluetoothHeadsetDevice = null;
                    resetBluetoothSco();
                }
            }
        }
    } else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) || action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
        state = intent.getIntExtra("state", 0);
        int alsaCard = intent.getIntExtra("card", -1);
        int alsaDevice = intent.getIntExtra("device", -1);
        String params = (alsaCard == -1 && alsaDevice == -1 ? "" : "card=" + alsaCard + ";device=" + alsaDevice);
        device = action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
        Log.v(TAG, "Broadcast Receiver: Got " + (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? "ACTION_USB_AUDIO_ACCESSORY_PLUG" : "ACTION_USB_AUDIO_DEVICE_PLUG") + ", state = " + state + ", card: " + alsaCard + ", device: " + alsaDevice);
        setWiredDeviceConnectionState(device, state, params);
    } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
        boolean broadcast = false;
        int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
        synchronized (mScoClients) {
            int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
            // broadcast intent if the connection was initated by AudioService
            if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
                broadcast = true;
            }
            switch(btState) {
                case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                    break;
                case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                    mScoAudioState = SCO_STATE_INACTIVE;
                    clearAllScoClients(0, false);
                    break;
                case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                default:
                    // do not broadcast CONNECTING or invalid state
                    broadcast = false;
                    break;
            }
        }
        if (broadcast) {
            broadcastScoConnectionState(scoAudioState);
            // FIXME: this is to maintain compatibility with deprecated intent
            // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
            sendStickyBroadcastToAll(newIntent);
        }
    } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        mBootCompleted = true;
        sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, null, 0);
        mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
        mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
        resetBluetoothSco();
        getBluetoothHeadset();
        // FIXME: this is to maintain compatibility with deprecated intent
        // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
        Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
        newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        sendStickyBroadcastToAll(newIntent);
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.A2DP);
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED, SENDMSG_REPLACE, 0, 0, null, SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
    } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
        AudioSystem.setParameters("screen_state=on");
    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
        AudioSystem.setParameters("screen_state=off");
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        handleConfigurationChanged(context);
    } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
        // attempt to stop music playback for background user
        sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
        // the current audio focus owner is no longer valid
        mMediaFocusControl.discardAudioFocusOwner();
        // load volume settings for new user
        readAudioSettings(true);
        // preserve STREAM_MUSIC volume from one user to the next.
        sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_MUSIC], 0);
    } else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
        // Only run when headset is inserted and is enabled at settings
        int plugged = intent.getIntExtra("state", 0);
        String headsetPlugIntenatUri = Settings.System.getStringForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, UserHandle.USER_CURRENT);
        boolean disableMusicActive = Settings.System.getIntForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_MUSIC_ACTIVE, 1, UserHandle.USER_CURRENT) == 1;
        Intent headsetPlugIntent = null;
        if (plugged == 1 && headsetPlugIntenatUri != null) {
            if (disableMusicActive && isLocalOrRemoteMusicActive()) {
                return;
            }
            // Run default music app
            if (headsetPlugIntenatUri.equals(Settings.System.HEADSET_PLUG_SYSTEM_DEFAULT)) {
                headsetPlugIntent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MUSIC);
                headsetPlugIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT);
            } else {
                try {
                    headsetPlugIntent = Intent.parseUri(headsetPlugIntenatUri, 0);
                } catch (URISyntaxException e) {
                    headsetPlugIntent = null;
                }
                if (headsetPlugIntent != null) {
                    String mPackage = headsetPlugIntent.getComponent().getPackageName();
                    if (PackageUtils.isAvailableApp(mPackage, context)) {
                        headsetPlugIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT);
                    } else {
                        // Disable setting
                        Settings.System.putStringForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, null, UserHandle.USER_CURRENT);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    int device;
    int state;
    if (action.equals(Intent.ACTION_DOCK_EVENT)) {
        int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
        int config;
        switch(dockState) {
            case Intent.EXTRA_DOCK_STATE_DESK:
                config = AudioSystem.FORCE_BT_DESK_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_CAR:
                config = AudioSystem.FORCE_BT_CAR_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_LE_DESK:
                config = AudioSystem.FORCE_ANALOG_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_HE_DESK:
                config = AudioSystem.FORCE_DIGITAL_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
            default:
                config = AudioSystem.FORCE_NONE;
        }
        // (see mDockAudioMediaEnabled)
        if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
            AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
        }
        mDockState = dockState;
    } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
        state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED);
        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
        String address = null;
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (btDevice == null) {
            return;
        }
        address = btDevice.getAddress();
        BluetoothClass btClass = btDevice.getBluetoothClass();
        if (btClass != null) {
            switch(btClass.getDeviceClass()) {
                case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                    break;
                case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                    break;
            }
        }
        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
            address = "";
        }
        boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
        if (handleDeviceConnection(connected, device, address)) {
            synchronized (mScoClients) {
                if (connected) {
                    mBluetoothHeadsetDevice = btDevice;
                } else {
                    mBluetoothHeadsetDevice = null;
                    resetBluetoothSco();
                }
            }
        }
    } else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) || action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
        state = intent.getIntExtra("state", 0);
        int alsaCard = intent.getIntExtra("card", -1);
        int alsaDevice = intent.getIntExtra("device", -1);
        String params = (alsaCard == -1 && alsaDevice == -1 ? "" : "card=" + alsaCard + ";device=" + alsaDevice);
        device = action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
        Log.v(TAG, "Broadcast Receiver: Got " + (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? "ACTION_USB_AUDIO_ACCESSORY_PLUG" : "ACTION_USB_AUDIO_DEVICE_PLUG") + ", state = " + state + ", card: " + alsaCard + ", device: " + alsaDevice);
        setWiredDeviceConnectionState(device, state, params);
    } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
        boolean broadcast = false;
        int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
        synchronized (mScoClients) {
            int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
            // broadcast intent if the connection was initated by AudioService
            if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
                broadcast = true;
            }
            switch(btState) {
                case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                    break;
                case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                    mScoAudioState = SCO_STATE_INACTIVE;
                    clearAllScoClients(0, false);
                    break;
                case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                default:
                    // do not broadcast CONNECTING or invalid state
                    broadcast = false;
                    break;
            }
        }
        if (broadcast) {
            broadcastScoConnectionState(scoAudioState);
            // FIXME: this is to maintain compatibility with deprecated intent
            // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
            sendStickyBroadcastToAll(newIntent);
        }
    } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        mBootCompleted = true;
        sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, null, 0);
        mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
        mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
        resetBluetoothSco();
        getBluetoothHeadset();
        // FIXME: this is to maintain compatibility with deprecated intent
        // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
        Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
        newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        sendStickyBroadcastToAll(newIntent);
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.A2DP);
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED, SENDMSG_REPLACE, 0, 0, null, SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
    } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
        AudioSystem.setParameters("screen_state=on");
    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
        AudioSystem.setParameters("screen_state=off");
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        handleConfigurationChanged(context);
    } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
        // attempt to stop music playback for background user
        sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
        // the current audio focus owner is no longer valid
        mMediaFocusControl.discardAudioFocusOwner();
        // load volume settings for new user
        readAudioSettings(true);
        // preserve STREAM_MUSIC volume from one user to the next.
        sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_MUSIC], 0);
    } else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
        int plugged = intent.getIntExtra("state", 0);
        boolean headsetPlugEnabled = Settings.System.getInt(mContext.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, 0) != 0;
        if (plugged == 1 && headsetPlugEnabled) {
            Intent headset = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MUSIC);
            headset.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(headset);
        }
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    String action = intent.getAction();
    int device;
    int state;
    if (action.equals(Intent.ACTION_DOCK_EVENT)) {
        int dockState = intent.getIntExtra(Intent.EXTRA_DOCK_STATE, Intent.EXTRA_DOCK_STATE_UNDOCKED);
        int config;
        switch(dockState) {
            case Intent.EXTRA_DOCK_STATE_DESK:
                config = AudioSystem.FORCE_BT_DESK_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_CAR:
                config = AudioSystem.FORCE_BT_CAR_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_LE_DESK:
                config = AudioSystem.FORCE_ANALOG_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_HE_DESK:
                config = AudioSystem.FORCE_DIGITAL_DOCK;
                break;
            case Intent.EXTRA_DOCK_STATE_UNDOCKED:
            default:
                config = AudioSystem.FORCE_NONE;
        }
        // (see mDockAudioMediaEnabled)
        if (!((dockState == Intent.EXTRA_DOCK_STATE_LE_DESK) || ((dockState == Intent.EXTRA_DOCK_STATE_UNDOCKED) && (mDockState == Intent.EXTRA_DOCK_STATE_LE_DESK)))) {
            AudioSystem.setForceUse(AudioSystem.FOR_DOCK, config);
        }
        mDockState = dockState;
    } else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) {
        state = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, BluetoothProfile.STATE_DISCONNECTED);
        device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO;
        String address = null;
        BluetoothDevice btDevice = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
        if (btDevice == null) {
            return;
        }
        address = btDevice.getAddress();
        BluetoothClass btClass = btDevice.getBluetoothClass();
        if (btClass != null) {
            switch(btClass.getDeviceClass()) {
                case BluetoothClass.Device.AUDIO_VIDEO_WEARABLE_HEADSET:
                case BluetoothClass.Device.AUDIO_VIDEO_HANDSFREE:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_HEADSET;
                    break;
                case BluetoothClass.Device.AUDIO_VIDEO_CAR_AUDIO:
                    device = AudioSystem.DEVICE_OUT_BLUETOOTH_SCO_CARKIT;
                    break;
            }
        }
        if (!BluetoothAdapter.checkBluetoothAddress(address)) {
            address = "";
        }
        boolean connected = (state == BluetoothProfile.STATE_CONNECTED);
        if (handleDeviceConnection(connected, device, address)) {
            synchronized (mScoClients) {
                if (connected) {
                    mBluetoothHeadsetDevice = btDevice;
                } else {
                    mBluetoothHeadsetDevice = null;
                    resetBluetoothSco();
                }
            }
        }
    } else if (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) || action.equals(Intent.ACTION_USB_AUDIO_DEVICE_PLUG)) {
        state = intent.getIntExtra("state", 0);
        int alsaCard = intent.getIntExtra("card", -1);
        int alsaDevice = intent.getIntExtra("device", -1);
        String params = (alsaCard == -1 && alsaDevice == -1 ? "" : "card=" + alsaCard + ";device=" + alsaDevice);
        device = action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? AudioSystem.DEVICE_OUT_USB_ACCESSORY : AudioSystem.DEVICE_OUT_USB_DEVICE;
        Log.v(TAG, "Broadcast Receiver: Got " + (action.equals(Intent.ACTION_USB_AUDIO_ACCESSORY_PLUG) ? "ACTION_USB_AUDIO_ACCESSORY_PLUG" : "ACTION_USB_AUDIO_DEVICE_PLUG") + ", state = " + state + ", card: " + alsaCard + ", device: " + alsaDevice);
        setWiredDeviceConnectionState(device, state, params);
    } else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) {
        boolean broadcast = false;
        int scoAudioState = AudioManager.SCO_AUDIO_STATE_ERROR;
        synchronized (mScoClients) {
            int btState = intent.getIntExtra(BluetoothProfile.EXTRA_STATE, -1);
            // broadcast intent if the connection was initated by AudioService
            if (!mScoClients.isEmpty() && (mScoAudioState == SCO_STATE_ACTIVE_INTERNAL || mScoAudioState == SCO_STATE_ACTIVATE_REQ || mScoAudioState == SCO_STATE_DEACTIVATE_REQ)) {
                broadcast = true;
            }
            switch(btState) {
                case BluetoothHeadset.STATE_AUDIO_CONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_CONNECTED;
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                    break;
                case BluetoothHeadset.STATE_AUDIO_DISCONNECTED:
                    scoAudioState = AudioManager.SCO_AUDIO_STATE_DISCONNECTED;
                    mScoAudioState = SCO_STATE_INACTIVE;
                    clearAllScoClients(0, false);
                    break;
                case BluetoothHeadset.STATE_AUDIO_CONNECTING:
                    if (mScoAudioState != SCO_STATE_ACTIVE_INTERNAL && mScoAudioState != SCO_STATE_DEACTIVATE_REQ && mScoAudioState != SCO_STATE_DEACTIVATE_EXT_REQ) {
                        mScoAudioState = SCO_STATE_ACTIVE_EXTERNAL;
                    }
                default:
                    // do not broadcast CONNECTING or invalid state
                    broadcast = false;
                    break;
            }
        }
        if (broadcast) {
            broadcastScoConnectionState(scoAudioState);
            // FIXME: this is to maintain compatibility with deprecated intent
            // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
            Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
            newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, scoAudioState);
            sendStickyBroadcastToAll(newIntent);
        }
    } else if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {
        mBootCompleted = true;
        sendMsg(mAudioHandler, MSG_LOAD_SOUND_EFFECTS, SENDMSG_QUEUE, 0, 0, null, 0);
        mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
        mScoConnectionState = AudioManager.SCO_AUDIO_STATE_ERROR;
        resetBluetoothSco();
        getBluetoothHeadset();
        // FIXME: this is to maintain compatibility with deprecated intent
        // AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED. Remove when appropriate.
        Intent newIntent = new Intent(AudioManager.ACTION_SCO_AUDIO_STATE_CHANGED);
        newIntent.putExtra(AudioManager.EXTRA_SCO_AUDIO_STATE, AudioManager.SCO_AUDIO_STATE_DISCONNECTED);
        sendStickyBroadcastToAll(newIntent);
        BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
        if (adapter != null) {
            adapter.getProfileProxy(mContext, mBluetoothProfileServiceListener, BluetoothProfile.A2DP);
        }
        sendMsg(mAudioHandler, MSG_CONFIGURE_SAFE_MEDIA_VOLUME_FORCED, SENDMSG_REPLACE, 0, 0, null, SAFE_VOLUME_CONFIGURE_TIMEOUT_MS);
    } else if (action.equals(Intent.ACTION_SCREEN_ON)) {
        AudioSystem.setParameters("screen_state=on");
    } else if (action.equals(Intent.ACTION_SCREEN_OFF)) {
        AudioSystem.setParameters("screen_state=off");
    } else if (action.equals(Intent.ACTION_CONFIGURATION_CHANGED)) {
        handleConfigurationChanged(context);
    } else if (action.equals(Intent.ACTION_USER_SWITCHED)) {
        // attempt to stop music playback for background user
        sendMsg(mAudioHandler, MSG_BROADCAST_AUDIO_BECOMING_NOISY, SENDMSG_REPLACE, 0, 0, null, 0);
        // the current audio focus owner is no longer valid
        mMediaFocusControl.discardAudioFocusOwner();
        // load volume settings for new user
        readAudioSettings(true);
        // preserve STREAM_MUSIC volume from one user to the next.
        sendMsg(mAudioHandler, MSG_SET_ALL_VOLUMES, SENDMSG_QUEUE, 0, 0, mStreamStates[AudioSystem.STREAM_MUSIC], 0);
    } else if (action.equals(Intent.ACTION_HEADSET_PLUG)) {
        // Only run when headset is inserted and is enabled at settings
        int plugged = intent.getIntExtra("state", 0);
        String headsetPlugIntenatUri = Settings.System.getStringForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, UserHandle.USER_CURRENT);
        Intent headsetPlugIntent = null;
        if (plugged == 1 && headsetPlugIntenatUri != null) {
            // Run default music app
            if (headsetPlugIntenatUri.equals(Settings.System.HEADSET_PLUG_SYSTEM_DEFAULT)) {
                headsetPlugIntent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, Intent.CATEGORY_APP_MUSIC);
                headsetPlugIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT);
            } else {
                try {
                    headsetPlugIntent = Intent.parseUri(headsetPlugIntenatUri, 0);
                } catch (URISyntaxException e) {
                    headsetPlugIntent = null;
                }
                if (headsetPlugIntent != null) {
                    String mPackage = headsetPlugIntent.getComponent().getPackageName();
                    if (isAvailableApp(mPackage)) {
                        headsetPlugIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        context.startActivityAsUser(headsetPlugIntent, UserHandle.CURRENT);
                    } else {
                        // Disable setting
                        Settings.System.putStringForUser(context.getContentResolver(), Settings.System.HEADSET_PLUG_ENABLED, null, UserHandle.USER_CURRENT);
                    }
                }
            }
        }
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ContentResolver resolver = getContentResolver();
    int activePhoneType = TelephonyManager.getDefault().getCurrentPhoneType();
    mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
    addPreferencesFromResource(R.xml.sound_settings);
    if (TelephonyManager.PHONE_TYPE_CDMA != activePhoneType) {
        // device is not CDMA, do not display CDMA emergency_tone
        getPreferenceScreen().removePreference(findPreference(KEY_EMERGENCY_TONE));
    }
    if (!getResources().getBoolean(R.bool.has_silent_mode)) {
        findPreference(KEY_RING_VOLUME).setDependency(null);
    }
    mVolumePanelStyle = (ListPreference) findPreference(KEY_VOLUME_PANEL_STYLE);
    mVolumeWarning = (CheckBoxPreference) findPreference(KEY_SAFE_HEADSET_VOLUME_WARNING);
    if (getResources().getBoolean(com.android.internal.R.bool.config_useFixedVolume)) {
        // device with fixed volume policy, do not display volumes submenu
        getPreferenceScreen().removePreference(findPreference(KEY_RING_VOLUME));
        getPreferenceScreen().removePreference(findPreference(KEY_VOLUME_PANEL_STYLE));
        getPreferenceScreen().removePreference(findPreference(KEY_SAFE_HEADSET_VOLUME_WARNING));
    } else {
        int statusVolumePanelStyle = Settings.System.getInt(resolver, Settings.System.MODE_VOLUME_OVERLAY, 1);
        mVolumePanelStyle.setValue(String.valueOf(statusVolumePanelStyle));
        mVolumePanelStyle.setOnPreferenceChangeListener(this);
        mVolumeWarning.setChecked(Settings.System.getInt(resolver, Settings.System.MANUAL_SAFE_MEDIA_VOLUME, 1) == 1);
        mVolumeWarning.setOnPreferenceChangeListener(this);
    }
    mVibrateWhenRinging = (CheckBoxPreference) findPreference(KEY_VIBRATE);
    mVibrateWhenRinging.setPersistent(false);
    mVibrateWhenRinging.setChecked(Settings.System.getInt(resolver, Settings.System.VIBRATE_WHEN_RINGING, 0) != 0);
    mDtmfTone = (CheckBoxPreference) findPreference(KEY_DTMF_TONE);
    mDtmfTone.setPersistent(false);
    mDtmfTone.setChecked(Settings.System.getInt(resolver, Settings.System.DTMF_TONE_WHEN_DIALING, 1) != 0);
    mSoundEffects = (CheckBoxPreference) findPreference(KEY_SOUND_EFFECTS);
    mSoundEffects.setPersistent(false);
    mSoundEffects.setChecked(Settings.System.getInt(resolver, Settings.System.SOUND_EFFECTS_ENABLED, 1) != 0);
    mHapticFeedback = (CheckBoxPreference) findPreference(KEY_HAPTIC_FEEDBACK);
    mHapticFeedback.setPersistent(false);
    mHapticFeedback.setChecked(Settings.System.getInt(resolver, Settings.System.HAPTIC_FEEDBACK_ENABLED, 1) != 0);
    mLockSounds = (CheckBoxPreference) findPreference(KEY_LOCK_SOUNDS);
    mLockSounds.setPersistent(false);
    mLockSounds.setChecked(Settings.System.getInt(resolver, Settings.System.LOCKSCREEN_SOUNDS_ENABLED, 1) != 0);
    mRingtonePreference = findPreference(KEY_RINGTONE);
    mNotificationPreference = findPreference(KEY_NOTIFICATION_SOUND);
    mAlarmPreference = findPreference(KEY_ALARM_SOUND);
    Vibrator vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
    if (vibrator == null || !vibrator.hasVibrator()) {
        removePreference(KEY_VIBRATE);
        removePreference(KEY_HAPTIC_FEEDBACK);
    }
    if (TelephonyManager.PHONE_TYPE_CDMA == activePhoneType) {
        ListPreference emergencyTonePreference = (ListPreference) findPreference(KEY_EMERGENCY_TONE);
        emergencyTonePreference.setValue(String.valueOf(Settings.Global.getInt(resolver, Settings.Global.EMERGENCY_TONE, FALLBACK_EMERGENCY_TONE_VALUE)));
        emergencyTonePreference.setOnPreferenceChangeListener(this);
    }
    mSoundSettings = (PreferenceGroup) findPreference(KEY_SOUND_SETTINGS);
    mMusicFx = mSoundSettings.findPreference(KEY_MUSICFX);
    Intent i = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);
    PackageManager p = getPackageManager();
    List<ResolveInfo> ris = p.queryIntentActivities(i, PackageManager.GET_DISABLED_COMPONENTS);
    if (ris.size() <= 2) {
        // no need to show the item if there is no choice for the user to make
        // note: the built in musicfx panel has two activities (one being a
        // compatibility shim that launches either the other activity, or a
        // third party one), hence the check for <=2. If the implementation
        // of the compatbility layer changes, this check may need to be updated.
        mSoundSettings.removePreference(mMusicFx);
    }
    if (!Utils.isVoiceCapable(getActivity())) {
        for (String prefKey : NEED_VOICE_CAPABILITY) {
            Preference pref = findPreference(prefKey);
            if (pref != null) {
                getPreferenceScreen().removePreference(pref);
            }
        }
    }
    mRingtoneLookupRunnable = new Runnable() {

        public void run() {
            if (mRingtonePreference != null) {
                updateRingtoneName(RingtoneManager.TYPE_RINGTONE, mRingtonePreference, MSG_UPDATE_RINGTONE_SUMMARY);
            }
            if (mNotificationPreference != null) {
                updateRingtoneName(RingtoneManager.TYPE_NOTIFICATION, mNotificationPreference, MSG_UPDATE_NOTIFICATION_SUMMARY);
            }
            if (mAlarmPreference != null) {
                updateRingtoneName(RingtoneManager.TYPE_ALARM, mAlarmPreference, MSG_UPDATE_ALARM_SUMMARY);
            }
        }
    };
    initDockSettings();
    mVolumeAdustSound = (CheckBoxPreference) findPreference(KEY_VOLUME_ADJUST_SOUNDS);
    mVolumeAdustSound.setPersistent(false);
    mVolumeAdustSound.setChecked(Settings.System.getInt(resolver, Settings.System.VOLUME_ADJUST_SOUNDS_ENABLED, 1) == 1);
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    ContentResolver resolver = getContentResolver();
    int activePhoneType = TelephonyManager.getDefault().getCurrentPhoneType();
    mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
    addPreferencesFromResource(R.xml.sound_settings);
    if (TelephonyManager.PHONE_TYPE_CDMA != activePhoneType) {
        // device is not CDMA, do not display CDMA emergency_tone
        getPreferenceScreen().removePreference(findPreference(KEY_EMERGENCY_TONE));
    }
    if (!getResources().getBoolean(R.bool.has_silent_mode)) {
        findPreference(KEY_RING_VOLUME).setDependency(null);
    }
    mVolumePanelStyle = (ListPreference) findPreference(KEY_VOLUME_PANEL_STYLE);
    mVolumeWarning = (CheckBoxPreference) findPreference(KEY_SAFE_HEADSET_VOLUME_WARNING);
    mVolumePanelTimeout = (SeekBarPreference) findPreference(KEY_VOLUME_PANEL_TIMEOUT);
    if (getResources().getBoolean(com.android.internal.R.bool.config_useFixedVolume)) {
        // device with fixed volume policy, do not display volumes submenu
        getPreferenceScreen().removePreference(findPreference(KEY_RING_VOLUME));
        getPreferenceScreen().removePreference(findPreference(KEY_VOLUME_PANEL_STYLE));
        getPreferenceScreen().removePreference(findPreference(KEY_SAFE_HEADSET_VOLUME_WARNING));
        getPreferenceScreen().removePreference(findPreference(KEY_VOLUME_PANEL_TIMEOUT));
    } else {
        int statusVolumePanelStyle = Settings.System.getInt(resolver, Settings.System.MODE_VOLUME_OVERLAY, 1);
        mVolumePanelStyle.setValue(String.valueOf(statusVolumePanelStyle));
        mVolumePanelStyle.setSummary(mVolumePanelStyle.getEntry());
        mVolumePanelStyle.setOnPreferenceChangeListener(this);
        mVolumeWarning.setChecked(Settings.System.getInt(resolver, Settings.System.MANUAL_SAFE_MEDIA_VOLUME, 1) == 1);
        mVolumeWarning.setOnPreferenceChangeListener(this);
        int statusVolumePanelTimeout = Settings.System.getInt(resolver, Settings.System.VOLUME_PANEL_TIMEOUT, 3000);
        mVolumePanelTimeout.setValue(statusVolumePanelTimeout / 1000);
        mVolumePanelTimeout.setOnPreferenceChangeListener(this);
    }
    mVibrateWhenRinging = (CheckBoxPreference) findPreference(KEY_VIBRATE);
    mVibrateWhenRinging.setPersistent(false);
    mVibrateWhenRinging.setChecked(Settings.System.getInt(resolver, Settings.System.VIBRATE_WHEN_RINGING, 0) != 0);
    mDtmfTone = (CheckBoxPreference) findPreference(KEY_DTMF_TONE);
    mDtmfTone.setPersistent(false);
    mDtmfTone.setChecked(Settings.System.getInt(resolver, Settings.System.DTMF_TONE_WHEN_DIALING, 1) != 0);
    mSoundEffects = (CheckBoxPreference) findPreference(KEY_SOUND_EFFECTS);
    mSoundEffects.setPersistent(false);
    mSoundEffects.setChecked(Settings.System.getInt(resolver, Settings.System.SOUND_EFFECTS_ENABLED, 1) != 0);
    mHapticFeedback = (CheckBoxPreference) findPreference(KEY_HAPTIC_FEEDBACK);
    mHapticFeedback.setPersistent(false);
    mHapticFeedback.setChecked(Settings.System.getInt(resolver, Settings.System.HAPTIC_FEEDBACK_ENABLED, 1) != 0);
    mLockSounds = (CheckBoxPreference) findPreference(KEY_LOCK_SOUNDS);
    mLockSounds.setPersistent(false);
    mLockSounds.setChecked(Settings.System.getInt(resolver, Settings.System.LOCKSCREEN_SOUNDS_ENABLED, 1) != 0);
    mRingtonePreference = findPreference(KEY_RINGTONE);
    mNotificationPreference = findPreference(KEY_NOTIFICATION_SOUND);
    mAlarmPreference = findPreference(KEY_ALARM_SOUND);
    Vibrator vibrator = (Vibrator) getSystemService(Context.VIBRATOR_SERVICE);
    if (vibrator == null || !vibrator.hasVibrator()) {
        removePreference(KEY_VIBRATE);
        removePreference(KEY_HAPTIC_FEEDBACK);
    }
    if (TelephonyManager.PHONE_TYPE_CDMA == activePhoneType) {
        ListPreference emergencyTonePreference = (ListPreference) findPreference(KEY_EMERGENCY_TONE);
        emergencyTonePreference.setValue(String.valueOf(Settings.Global.getInt(resolver, Settings.Global.EMERGENCY_TONE, FALLBACK_EMERGENCY_TONE_VALUE)));
        emergencyTonePreference.setOnPreferenceChangeListener(this);
    }
    mSoundSettings = (PreferenceGroup) findPreference(KEY_SOUND_SETTINGS);
    mMusicFx = mSoundSettings.findPreference(KEY_MUSICFX);
    Intent i = new Intent(AudioEffect.ACTION_DISPLAY_AUDIO_EFFECT_CONTROL_PANEL);
    PackageManager p = getPackageManager();
    List<ResolveInfo> ris = p.queryIntentActivities(i, PackageManager.GET_DISABLED_COMPONENTS);
    if (ris.size() <= 2) {
        // no need to show the item if there is no choice for the user to make
        // note: the built in musicfx panel has two activities (one being a
        // compatibility shim that launches either the other activity, or a
        // third party one), hence the check for <=2. If the implementation
        // of the compatbility layer changes, this check may need to be updated.
        mSoundSettings.removePreference(mMusicFx);
    }
    if (!Utils.isVoiceCapable(getActivity())) {
        for (String prefKey : NEED_VOICE_CAPABILITY) {
            Preference pref = findPreference(prefKey);
            if (pref != null) {
                getPreferenceScreen().removePreference(pref);
            }
        }
    }
    mRingtoneLookupRunnable = new Runnable() {

        public void run() {
            if (mRingtonePreference != null) {
                updateRingtoneName(RingtoneManager.TYPE_RINGTONE, mRingtonePreference, MSG_UPDATE_RINGTONE_SUMMARY);
            }
            if (mNotificationPreference != null) {
                updateRingtoneName(RingtoneManager.TYPE_NOTIFICATION, mNotificationPreference, MSG_UPDATE_NOTIFICATION_SUMMARY);
            }
            if (mAlarmPreference != null) {
                updateRingtoneName(RingtoneManager.TYPE_ALARM, mAlarmPreference, MSG_UPDATE_ALARM_SUMMARY);
            }
        }
    };
    initDockSettings();
    mVolumeAdustSound = (CheckBoxPreference) findPreference(KEY_VOLUME_ADJUST_SOUNDS);
    mVolumeAdustSound.setPersistent(false);
    mVolumeAdustSound.setChecked(Settings.System.getInt(resolver, Settings.System.VOLUME_ADJUST_SOUNDS_ENABLED, 1) == 1);
}
#end_block

#method_before
public boolean onPreferenceChange(Preference preference, Object objValue) {
    final String key = preference.getKey();
    if (KEY_EMERGENCY_TONE.equals(key)) {
        try {
            int value = Integer.parseInt((String) objValue);
            Settings.Global.putInt(getContentResolver(), Settings.Global.EMERGENCY_TONE, value);
        } catch (NumberFormatException e) {
            Log.e(TAG, "could not persist emergency tone setting", e);
        }
    } else if (preference == mVolumePanelStyle) {
        int volumePanelStyle = Integer.valueOf((String) objValue);
        Settings.System.putInt(getContentResolver(), Settings.System.MODE_VOLUME_OVERLAY, volumePanelStyle);
    } else if (preference == mVolumeWarning) {
        int volumeWarning = (Boolean) objValue ? 1 : 0;
        Settings.System.putInt(getContentResolver(), Settings.System.MANUAL_SAFE_MEDIA_VOLUME, volumeWarning);
    }
    return true;
}
#method_after
public boolean onPreferenceChange(Preference preference, Object objValue) {
    final String key = preference.getKey();
    if (KEY_EMERGENCY_TONE.equals(key)) {
        try {
            int value = Integer.parseInt((String) objValue);
            Settings.Global.putInt(getContentResolver(), Settings.Global.EMERGENCY_TONE, value);
        } catch (NumberFormatException e) {
            Log.e(TAG, "could not persist emergency tone setting", e);
        }
    } else if (preference == mVolumePanelStyle) {
        int volumePanelStyle = Integer.valueOf((String) objValue);
        Settings.System.putInt(getContentResolver(), Settings.System.MODE_VOLUME_OVERLAY, volumePanelStyle);
        int idx = mVolumePanelStyle.findIndexOfValue((String) objValue);
        mVolumePanelStyle.setSummary(mVolumePanelStyle.getEntries()[idx]);
    } else if (preference == mVolumeWarning) {
        int volumeWarning = (Boolean) objValue ? 1 : 0;
        Settings.System.putInt(getContentResolver(), Settings.System.MANUAL_SAFE_MEDIA_VOLUME, volumeWarning);
    } else if (preference == mVolumePanelTimeout) {
        int volumePanelTimeout = (Integer) objValue;
        Settings.System.putInt(getContentResolver(), Settings.System.VOLUME_PANEL_TIMEOUT, volumePanelTimeout * 1000);
    }
    return true;
}
#end_block

#method_before
void postSetVolume(int progress) {
    // Do the volume changing separately to give responsive UI
    mLastProgress = progress;
    mHandler.removeMessages(MSG_SET_STREAM_VOLUME);
    mHandler.sendMessage(mHandler.obtainMessage(MSG_SET_STREAM_VOLUME));
    if (onVolumeChange(this, progress)) {
        mLastProgress = progress;
        mHandler.removeMessages(MSG_SET_STREAM_VOLUME);
        mHandler.sendMessage(mHandler.obtainMessage(MSG_SET_STREAM_VOLUME));
    } else {
        mSeekBar.setProgress(mLastProgress);
    }
}
#method_after
void postSetVolume(int progress) {
    if (onVolumeChange(this, progress)) {
        // Do the volume changing separately to give responsive UI
        mLastProgress = progress;
        mHandler.removeMessages(MSG_SET_STREAM_VOLUME);
        mHandler.sendMessage(mHandler.obtainMessage(MSG_SET_STREAM_VOLUME));
    } else {
        mSeekBar.setProgress(mLastProgress);
    }
}
#end_block

#method_before
@Override
public void onNotificationPosted(StatusBarNotification sbn) {
    if (shouldShowNotification() && isValidNotification(sbn) && !shouldDisableActiveDisplay()) {
        // viewing the notifications
        if (getVisibility() == View.VISIBLE || !isScreenOn()) {
            showNotification(sbn, true);
        }
    }
}
#method_after
@Override
public void onNotificationPosted(StatusBarNotification sbn) {
    if (shouldShowNotification() && isValidNotification(sbn) && !shouldDisableActiveDisplay()) {
        // viewing the notifications
        if (getVisibility() == View.VISIBLE || !isScreenOn()) {
            if (mEnableShakeForce) {
                if ((mShakeTimeout > 0) && !inQuietHours()) {
                    enableShakeSensor();
                    updateShakeTimer();
                    Log.i(TAG, "Shake enable by force option.");
                }
            } else {
                showNotification(sbn, true);
            }
        }
    }
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ENABLE_ACTIVE_DISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TEXT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_POCKET_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_REDISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BRIGHTNESS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_PRIVACY_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TIMEOUT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_THRESHOLD), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_CONTENT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BYPASS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_AROUND_LOCKSCREEN_RING), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_NOTIF_COUNT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_ANNOYING), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_DOUBLE_TAP), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SHAKE_EVENT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SHAKE_QUITE_HOURS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SHAKE_THRESHOLD), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SHAKE_LONGTHRESHOLD), false, this);
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ENABLE_ACTIVE_DISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TEXT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_POCKET_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_REDISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BRIGHTNESS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_PRIVACY_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TIMEOUT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_THRESHOLD), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_CONTENT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BYPASS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_AROUND_LOCKSCREEN_RING), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_NOTIF_COUNT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_ANNOYING), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_DOUBLE_TAP), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SHAKE_EVENT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SHAKE_FORCE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SHAKE_QUITE_HOURS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SHAKE_THRESHOLD), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SHAKE_LONGTHRESHOLD), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SHAKE_TIMEOUT), false, this);
    update();
}
#end_block

#method_before
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    mActiveDisplayEnabled = Settings.System.getIntForUser(resolver, Settings.System.ENABLE_ACTIVE_DISPLAY, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mDisplayNotificationText = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_TEXT, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mShowAllNotifications = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mHideLowPriorityNotifications = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mPocketMode = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_POCKET_MODE, POCKET_MODE_OFF, UserHandle.USER_CURRENT_OR_SELF);
    mRedisplayTimeout = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_REDISPLAY, 0L, UserHandle.USER_CURRENT_OR_SELF);
    mInitialBrightness = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_BRIGHTNESS, mMaximumBacklight, UserHandle.USER_CURRENT_OR_SELF);
    mSunlightModeEnabled = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    String excludedApps = Settings.System.getStringForUser(resolver, Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS, UserHandle.USER_CURRENT_OR_SELF);
    String privacyApps = Settings.System.getStringForUser(resolver, Settings.System.ACTIVE_DISPLAY_PRIVACY_APPS, UserHandle.USER_CURRENT_OR_SELF);
    mDisplayTimeout = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_TIMEOUT, mDisplayTimeout, UserHandle.USER_CURRENT_OR_SELF);
    mTurnOffModeEnabled = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mProximityThreshold = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_THRESHOLD, mProximityThreshold, UserHandle.USER_CURRENT_OR_SELF);
    mUseActiveDisplayContent = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_CONTENT, 1, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mBypassActiveDisplay = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_BYPASS, 1, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mBatteryLockscreen = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_AROUND_LOCKSCREEN_RING, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mShowNotificationCount = Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mIsAnnoyingThreshold = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_ANNOYING, 0, UserHandle.USER_CURRENT_OR_SELF);
    mEnableDoubleTap = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_DOUBLE_TAP, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mEnableShake = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SHAKE_EVENT, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mDisableShakeQuite = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SHAKE_QUITE_HOURS, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mShakeThreshold = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SHAKE_THRESHOLD, mShakeThreshold, UserHandle.USER_CURRENT_OR_SELF);
    mShakeLongThreshold = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SHAKE_LONGTHRESHOLD, mShakeLongThreshold, UserHandle.USER_CURRENT_OR_SELF);
    createExcludedAppsSet(excludedApps);
    createPrivacyAppsSet(privacyApps);
    int brightnessMode = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, -1, UserHandle.USER_CURRENT_OR_SELF);
    if (mBrightnessMode != brightnessMode) {
        mBrightnessMode = brightnessMode;
        mUserBrightnessLevel = -1;
    }
    if (!mActiveDisplayEnabled || mRedisplayTimeout <= 0) {
        cancelRedisplayTimer();
    }
    if (mActiveDisplayEnabled) {
        registerCallbacks();
    } else {
        unregisterCallbacks();
    }
}
#method_after
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    mActiveDisplayEnabled = Settings.System.getIntForUser(resolver, Settings.System.ENABLE_ACTIVE_DISPLAY, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mDisplayNotificationText = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_TEXT, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mShowAllNotifications = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mHideLowPriorityNotifications = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mPocketMode = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_POCKET_MODE, POCKET_MODE_OFF, UserHandle.USER_CURRENT_OR_SELF);
    mRedisplayTimeout = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_REDISPLAY, 0L, UserHandle.USER_CURRENT_OR_SELF);
    mInitialBrightness = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_BRIGHTNESS, mMaximumBacklight, UserHandle.USER_CURRENT_OR_SELF);
    mSunlightModeEnabled = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    String excludedApps = Settings.System.getStringForUser(resolver, Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS, UserHandle.USER_CURRENT_OR_SELF);
    String privacyApps = Settings.System.getStringForUser(resolver, Settings.System.ACTIVE_DISPLAY_PRIVACY_APPS, UserHandle.USER_CURRENT_OR_SELF);
    mDisplayTimeout = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_TIMEOUT, mDisplayTimeout, UserHandle.USER_CURRENT_OR_SELF);
    mTurnOffModeEnabled = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mProximityThreshold = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_THRESHOLD, mProximityThreshold, UserHandle.USER_CURRENT_OR_SELF);
    mUseActiveDisplayContent = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_CONTENT, 1, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mBypassActiveDisplay = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_BYPASS, 1, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mBatteryLockscreen = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_AROUND_LOCKSCREEN_RING, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mShowNotificationCount = Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mIsAnnoyingThreshold = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_ANNOYING, 0, UserHandle.USER_CURRENT_OR_SELF);
    mEnableDoubleTap = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_DOUBLE_TAP, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mEnableShake = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SHAKE_EVENT, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mEnableShakeForce = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SHAKE_FORCE, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mDisableShakeQuite = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SHAKE_QUITE_HOURS, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mShakeThreshold = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SHAKE_THRESHOLD, mShakeThreshold, UserHandle.USER_CURRENT_OR_SELF);
    mShakeLongThreshold = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SHAKE_LONGTHRESHOLD, mShakeLongThreshold, UserHandle.USER_CURRENT_OR_SELF);
    mShakeTimeout = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SHAKE_TIMEOUT, mShakeTimeout, UserHandle.USER_CURRENT_OR_SELF);
    createExcludedAppsSet(excludedApps);
    createPrivacyAppsSet(privacyApps);
    int brightnessMode = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, -1, UserHandle.USER_CURRENT_OR_SELF);
    if (mBrightnessMode != brightnessMode) {
        mBrightnessMode = brightnessMode;
        mUserBrightnessLevel = -1;
    }
    if (!mActiveDisplayEnabled || mRedisplayTimeout <= 0) {
        cancelRedisplayTimer();
    }
    if (mActiveDisplayEnabled) {
        registerCallbacks();
    } else {
        unregisterCallbacks();
    }
}
#end_block

#method_before
private void onScreenTurnedOff() {
    enableProximitySensor();
    enableShakeSensor();
    mWakedByPocketMode = false;
    mWakedByShakeMode = false;
    hideNotificationView();
    cancelTimeoutTimer();
    if (mRedisplayTimeout > 0) {
        updateRedisplayTimer();
    }
}
#method_after
private void onScreenTurnedOff() {
    enableProximitySensor();
    if (mShakeTimeout == 0) {
        enableShakeSensor();
        Log.i(TAG, "Shake always enable.");
    }
    mWakedByPocketMode = false;
    mWakedByShakeMode = false;
    hideNotificationView();
    cancelTimeoutTimer();
    if (mRedisplayTimeout > 0) {
        updateRedisplayTimer();
    }
}
#end_block

#method_before
private void turnScreenOffTimeOut() {
    if (getVisibility() != View.VISIBLE || mIsUnlockByUser) {
        return;
    }
    Log.i(TAG, "ActiveDisplay: Screen Timeout");
    mWakedByPocketMode = false;
    mWakedByShakeMode = false;
    try {
        mPM.goToSleep(SystemClock.uptimeMillis(), GO_TO_SLEEP_REASON_TIMEOUT);
    } catch (RemoteException e) {
    }
}
#method_after
private void turnScreenOffTimeOut() {
    if (getVisibility() != View.VISIBLE || mIsUnlockByUser) {
        return;
    }
    Log.i(TAG, "ActiveDisplay: Screen Timeout");
    mWakedByPocketMode = false;
    mWakedByShakeMode = false;
    if (mShakeTimeout > 0) {
        enableShakeSensor();
        updateShakeTimer();
        Log.i(TAG, "Shake enable by screen time out.");
    }
    try {
        mPM.goToSleep(SystemClock.uptimeMillis(), GO_TO_SLEEP_REASON_TIMEOUT);
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
private void turnScreenOffbySensor() {
    mIsTurnOffBySensor = true;
    KeyguardTouchDelegate.getInstance(mContext).onScreenTurnedOff(OFF_BECAUSE_OF_PROX_SENSOR);
    turnScreenOff();
}
#method_after
private void turnScreenOffbySensor() {
    mIsTurnOffBySensor = true;
    KeyguardTouchDelegate.getInstance(mContext).onScreenTurnedOff(OFF_BECAUSE_OF_PROX_SENSOR);
    if (mShakeTimeout > 0) {
        enableShakeSensor();
        updateShakeTimer();
        Log.i(TAG, "Shake enable by sensor.");
    }
    turnScreenOff();
}
#end_block

#method_before
private void registerBroadcastReceiver() {
    IntentFilter filter = new IntentFilter();
    filter.addAction(ACTION_REDISPLAY_NOTIFICATION);
    filter.addAction(ACTION_DISPLAY_TIMEOUT);
    filter.addAction(ACTION_PHONE_STATE);
    filter.addAction(ACTION_UNLOCK_DEVICE);
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    mContext.registerReceiver(mBroadcastReceiver, filter);
}
#method_after
private void registerBroadcastReceiver() {
    IntentFilter filter = new IntentFilter();
    filter.addAction(ACTION_REDISPLAY_NOTIFICATION);
    filter.addAction(ACTION_SHAKE_TIMEOUT);
    filter.addAction(ACTION_DISPLAY_TIMEOUT);
    filter.addAction(ACTION_PHONE_STATE);
    filter.addAction(ACTION_UNLOCK_DEVICE);
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    mContext.registerReceiver(mBroadcastReceiver, filter);
}
#end_block

#method_before
private void updateWithLocked(Collection<DownloadInfo> downloads) {
    final Resources res = mContext.getResources();
    // Cluster downloads together
    final Multimap<String, DownloadInfo> clustered = ArrayListMultimap.create();
    for (DownloadInfo info : downloads) {
        final String tag = buildNotificationTag(info);
        if (tag != null) {
            clustered.put(tag, info);
        }
    }
    // Build notification for each cluster
    for (String tag : clustered.keySet()) {
        final int type = getNotificationTagType(tag);
        final Collection<DownloadInfo> cluster = clustered.get(tag);
        final Notification.Builder builder = new Notification.Builder(mContext);
        // Use time when cluster was first shown to avoid shuffling
        final long firstShown;
        if (mActiveNotifs.containsKey(tag)) {
            firstShown = mActiveNotifs.get(tag);
        } else {
            firstShown = System.currentTimeMillis();
            mActiveNotifs.put(tag, firstShown);
        }
        builder.setWhen(firstShown);
        // Check error status about downloads. If error exists, will
        // update icon and content title/content text in notification.
        boolean hasErrorStatus = false;
        for (DownloadInfo info : cluster) {
            if (isErrorStatus(info.mStatus)) {
                hasErrorStatus = true;
                break;
            }
        }
        // Show relevant icon
        if (type == TYPE_ACTIVE) {
            if (hasErrorStatus) {
                builder.setSmallIcon(android.R.drawable.stat_sys_warning);
            } else {
                builder.setSmallIcon(android.R.drawable.stat_sys_download);
            }
        } else if (type == TYPE_WAITING || type == TYPE_PAUSED) {
            builder.setSmallIcon(android.R.drawable.stat_sys_warning);
        } else if (type == TYPE_COMPLETE) {
            builder.setSmallIcon(android.R.drawable.stat_sys_download_done);
        }
        // Build action intents
        if (type == TYPE_ACTIVE || type == TYPE_WAITING || type == TYPE_PAUSED) {
            // build a synthetic uri for intent identification purposes
            final Uri uri = new Uri.Builder().scheme("active-dl").appendPath(tag).build();
            final Intent intent = new Intent(Constants.ACTION_LIST, uri, mContext, DownloadReceiver.class);
            intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT));
            builder.setOngoing(true);
        } else if (type == TYPE_COMPLETE) {
            final DownloadInfo info = cluster.iterator().next();
            final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, info.mId);
            builder.setAutoCancel(true);
            final String action;
            if (hasErrorStatus) {
                action = Constants.ACTION_LIST;
            } else {
                if (info.mDestination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {
                    action = Constants.ACTION_OPEN;
                } else {
                    action = Constants.ACTION_LIST;
                }
            }
            final Intent intent = new Intent(action, uri, mContext, DownloadReceiver.class);
            intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT));
            final Intent hideIntent = new Intent(Constants.ACTION_HIDE, uri, mContext, DownloadReceiver.class);
            builder.setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, hideIntent, 0));
        }
        // Calculate and show progress
        String remainingText = null;
        String durationText = null;
        String percentText = null;
        String speedText = null;
        if (type == TYPE_ACTIVE) {
            long current = 0;
            long total = 0;
            long speed = 0;
            synchronized (mDownloadSpeed) {
                for (DownloadInfo info : cluster) {
                    if (info.mTotalBytes != -1) {
                        current += info.mCurrentBytes;
                        total += info.mTotalBytes;
                        speed += mDownloadSpeed.get(info.mId);
                    }
                }
            }
            if (total > 0) {
                final int percent = (int) ((current * 100) / total);
                percentText = res.getString(R.string.download_percent, percent);
                if (speed > 0) {
                    // Decide prefix character for speed string
                    char preFix;
                    double speedNormalized = speed;
                    if (speed < SPEED_KB) {
                        preFix = '\0';
                    } else if (speed < SPEED_MB) {
                        preFix = 'K';
                        speedNormalized /= SPEED_KB;
                    } else if (speed < SPEED_GB) {
                        preFix = 'M';
                        speedNormalized /= SPEED_MB;
                    } else {
                        preFix = 'G';
                        speedNormalized /= SPEED_GB;
                    }
                    // Format the String
                    speedText = String.format(SPEED_PLACEHOLDER, mFormatter.format(speedNormalized).toString(), preFix);
                    final long remainingMillis = ((total - current) * 1000) / speed;
                    if (remainingMillis >= DateUtils.HOUR_IN_MILLIS) {
                        final int hours = (int) ((remainingMillis + 1800000) / DateUtils.HOUR_IN_MILLIS);
                        durationText = res.getQuantityString(R.plurals.duration_hours, hours, hours);
                    } else if (remainingMillis >= DateUtils.MINUTE_IN_MILLIS) {
                        final int minutes = (int) ((remainingMillis + 30000) / DateUtils.MINUTE_IN_MILLIS);
                        durationText = res.getQuantityString(R.plurals.duration_minutes, minutes, minutes);
                    } else {
                        final int seconds = (int) ((remainingMillis + 500) / DateUtils.SECOND_IN_MILLIS);
                        durationText = res.getQuantityString(R.plurals.duration_seconds, seconds, seconds);
                    }
                    remainingText = res.getString(R.string.download_remaining, durationText);
                }
                builder.setProgress(100, percent, false);
            } else {
                builder.setProgress(100, 0, true);
            }
        }
        // Build titles and description
        final Notification notif;
        String contentText = null;
        if (cluster.size() == 1) {
            final Notification.InboxStyle inboxStyle = new Notification.InboxStyle(builder);
            final DownloadInfo info = cluster.iterator().next();
            final Uri uris = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, info.mId);
            builder.setContentTitle(getDownloadTitle(res, info));
            final Intent stopIntent = new Intent(Constants.ACTION_NOTIFICATION_STOP, uris, mContext, DownloadReceiver.class);
            stopIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent pauseIntent = new Intent(Constants.ACTION_NOTIFICATION_PAUSE, uris, mContext, DownloadReceiver.class);
            pauseIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent resumeIntent = new Intent(Constants.ACTION_NOTIFICATION_RESUME, uris, mContext, DownloadReceiver.class);
            resumeIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent retryIntent = new Intent(Constants.ACTION_NOTIFICATION_RETRY, uris, mContext, DownloadReceiver.class);
            retryIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            if (!TextUtils.isEmpty(info.mDescription)) {
                inboxStyle.addLine(info.mDescription);
            } else if (!TextUtils.isEmpty(info.mPackage)) {
                inboxStyle.addLine(info.mPackage);
            }
            if (type == TYPE_ACTIVE) {
                if (hasErrorStatus) {
                    contentText = res.getString(R.string.notification_download_failed);
                } else if (TextUtils.isEmpty(speedText) && TextUtils.isEmpty(remainingText)) {
                    contentText = res.getString(R.string.download_running);
                } else if (!TextUtils.isEmpty(remainingText) && TextUtils.isEmpty(speedText)) {
                    contentText = remainingText;
                } else if (TextUtils.isEmpty(remainingText) && !TextUtils.isEmpty(speedText)) {
                    contentText = speedText;
                } else {
                    contentText = speedText + ", " + remainingText;
                }
                if (hasErrorStatus) {
                    builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_retry), PendingIntent.getBroadcast(mContext, 0, retryIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                } else {
                    builder.addAction(com.android.internal.R.drawable.ic_media_pause, res.getString(R.string.download_pause), PendingIntent.getBroadcast(mContext, 0, pauseIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                }
                builder.addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop), PendingIntent.getBroadcast(mContext, 0, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_WAITING) {
                contentText = res.getString(R.string.notification_need_wifi_for_size);
                builder.addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop), PendingIntent.getBroadcast(mContext, 0, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_PAUSED) {
                contentText = res.getString(R.string.notification_paused_in_background);
                builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_resume), PendingIntent.getBroadcast(mContext, 0, resumeIntent, PendingIntent.FLAG_UPDATE_CURRENT)).addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop), PendingIntent.getBroadcast(mContext, 0, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_COMPLETE) {
                if (hasErrorStatus) {
                    contentText = res.getString(R.string.notification_download_failed);
                    builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_retry), PendingIntent.getBroadcast(mContext, 0, retryIntent, PendingIntent.FLAG_UPDATE_CURRENT)).addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop), PendingIntent.getBroadcast(mContext, 0, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                } else if (Downloads.Impl.isStatusSuccess(info.mStatus)) {
                    contentText = res.getString(R.string.notification_download_complete);
                }
            }
            inboxStyle.setSummaryText(contentText);
            builder.setContentText(contentText);
            builder.setContentInfo(percentText);
            notif = inboxStyle.build();
        } else {
            final Notification.InboxStyle inboxStyle = new Notification.InboxStyle(builder);
            final Uri uris = new Uri.Builder().scheme("active-dl").appendPath(tag).build();
            for (DownloadInfo info : cluster) {
                inboxStyle.addLine(getDownloadTitle(res, info));
            }
            final Intent stopAllIntent = new Intent(Constants.ACTION_NOTIFICATION_STOP_ALL, uris, mContext, DownloadReceiver.class);
            stopAllIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent pauseAllIntent = new Intent(Constants.ACTION_NOTIFICATION_PAUSE_ALL, uris, mContext, DownloadReceiver.class);
            pauseAllIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent resumeAllIntent = new Intent(Constants.ACTION_NOTIFICATION_RESUME_ALL, uris, mContext, DownloadReceiver.class);
            resumeAllIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent retryAllIntent = new Intent(Constants.ACTION_NOTIFICATION_RETRY_ALL, uris, mContext, DownloadReceiver.class);
            retryAllIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            if (type == TYPE_ACTIVE) {
                if (hasErrorStatus) {
                    builder.setContentTitle(res.getString(R.string.notification_download_failed));
                } else {
                    builder.setContentTitle(res.getQuantityString(R.plurals.notif_summary_active, cluster.size(), cluster.size()));
                }
                if (TextUtils.isEmpty(speedText) && TextUtils.isEmpty(remainingText)) {
                    contentText = res.getString(R.string.download_running);
                } else if (!TextUtils.isEmpty(remainingText) && TextUtils.isEmpty(speedText)) {
                    contentText = remainingText;
                } else if (TextUtils.isEmpty(remainingText) && !TextUtils.isEmpty(speedText)) {
                    contentText = speedText;
                } else {
                    contentText = speedText + ", " + remainingText;
                }
                if (hasErrorStatus) {
                    builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_retry_all), PendingIntent.getBroadcast(mContext, 0, retryAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                } else {
                    builder.addAction(com.android.internal.R.drawable.ic_media_pause, res.getString(R.string.download_pause_all), PendingIntent.getBroadcast(mContext, 0, pauseAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                }
                builder.addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop), PendingIntent.getBroadcast(mContext, 0, stopAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_WAITING) {
                builder.setContentTitle(res.getQuantityString(R.plurals.notif_summary_waiting, cluster.size(), cluster.size()));
                contentText = res.getString(R.string.notification_need_wifi_for_size);
                builder.addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop_all), PendingIntent.getBroadcast(mContext, 0, stopAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_PAUSED) {
                builder.setContentTitle(res.getQuantityString(R.plurals.notif_summary_waiting, cluster.size(), cluster.size()));
                contentText = res.getString(R.string.notification_paused_in_background);
                builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_resume_all), PendingIntent.getBroadcast(mContext, 0, resumeAllIntent, PendingIntent.FLAG_UPDATE_CURRENT)).addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop_all), PendingIntent.getBroadcast(mContext, 0, stopAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_COMPLETE) {
                if (hasErrorStatus) {
                    contentText = res.getString(R.string.notification_download_failed);
                    builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_retry_all), PendingIntent.getBroadcast(mContext, 0, retryAllIntent, PendingIntent.FLAG_UPDATE_CURRENT)).addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop_all), PendingIntent.getBroadcast(mContext, 0, stopAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                }
            }
            inboxStyle.setSummaryText(contentText);
            builder.setContentText(contentText);
            builder.setContentInfo(percentText);
            notif = inboxStyle.build();
        }
        mNotifManager.notify(tag, 0, notif);
    }
    // Remove stale tags that weren't renewed
    final Iterator<String> it = mActiveNotifs.keySet().iterator();
    while (it.hasNext()) {
        final String tag = it.next();
        if (!clustered.containsKey(tag)) {
            mNotifManager.cancel(tag, 0);
            it.remove();
        }
    }
}
#method_after
private void updateWithLocked(Collection<DownloadInfo> downloads) {
    final Resources res = mContext.getResources();
    // Cluster downloads together
    final Multimap<String, DownloadInfo> clustered = ArrayListMultimap.create();
    for (DownloadInfo info : downloads) {
        final String tag = buildNotificationTag(info);
        if (tag != null) {
            clustered.put(tag, info);
        }
    }
    // Build notification for each cluster
    for (String tag : clustered.keySet()) {
        final int type = getNotificationTagType(tag);
        final Collection<DownloadInfo> cluster = clustered.get(tag);
        final Notification.Builder builder = new Notification.Builder(mContext);
        // Use time when cluster was first shown to avoid shuffling
        final long firstShown;
        if (mActiveNotifs.containsKey(tag)) {
            firstShown = mActiveNotifs.get(tag);
        } else {
            firstShown = System.currentTimeMillis();
            mActiveNotifs.put(tag, firstShown);
        }
        builder.setWhen(firstShown);
        // Check error status about downloads. If error exists, will
        // update icon and content title/content text in notification.
        boolean hasErrorStatus = false;
        for (DownloadInfo info : cluster) {
            if (isErrorStatus(info.mStatus)) {
                hasErrorStatus = true;
                break;
            }
        }
        // Show relevant icon
        if (type == TYPE_ACTIVE) {
            if (hasErrorStatus) {
                builder.setSmallIcon(android.R.drawable.stat_sys_warning);
            } else {
                builder.setSmallIcon(android.R.drawable.stat_sys_download);
            }
        } else if (type == TYPE_WAITING) {
            builder.setSmallIcon(android.R.drawable.stat_sys_warning);
        } else if (type == TYPE_PAUSED) {
            builder.setSmallIcon(com.android.internal.R.drawable.ic_media_pause);
        } else if (type == TYPE_COMPLETE) {
            builder.setSmallIcon(android.R.drawable.stat_sys_download_done);
        }
        // Build action intents
        if (type == TYPE_ACTIVE || type == TYPE_WAITING || type == TYPE_PAUSED) {
            // build a synthetic uri for intent identification purposes
            final Uri uri = new Uri.Builder().scheme("active-dl").appendPath(tag).build();
            final Intent intent = new Intent(Constants.ACTION_LIST, uri, mContext, DownloadReceiver.class);
            intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT));
            builder.setOngoing(true);
        } else if (type == TYPE_COMPLETE) {
            final DownloadInfo info = cluster.iterator().next();
            final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, info.mId);
            builder.setAutoCancel(true);
            final String action;
            if (hasErrorStatus) {
                action = Constants.ACTION_LIST;
            } else {
                if (info.mDestination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {
                    action = Constants.ACTION_OPEN;
                } else {
                    action = Constants.ACTION_LIST;
                }
            }
            final Intent intent = new Intent(action, uri, mContext, DownloadReceiver.class);
            intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT));
            final Intent hideIntent = new Intent(Constants.ACTION_HIDE, uri, mContext, DownloadReceiver.class);
            builder.setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, hideIntent, 0));
        }
        // Calculate and show progress
        String remainingText = null;
        String durationText = null;
        String percentText = null;
        String speedText = null;
        if (type == TYPE_ACTIVE) {
            long current = 0;
            long total = 0;
            long speed = 0;
            synchronized (mDownloadSpeed) {
                for (DownloadInfo info : cluster) {
                    if (info.mTotalBytes != -1) {
                        current += info.mCurrentBytes;
                        total += info.mTotalBytes;
                        speed += mDownloadSpeed.get(info.mId);
                    }
                }
            }
            if (total > 0) {
                final int percent = (int) ((current * 100) / total);
                percentText = res.getString(R.string.download_percent, percent);
                if (speed > 0) {
                    // Decide prefix character for speed string
                    char preFix;
                    double speedNormalized = speed;
                    if (speed < SPEED_KB) {
                        preFix = '\0';
                    } else if (speed < SPEED_MB) {
                        preFix = (res.getString(R.string.kilo_bytes)).charAt(0);
                        speedNormalized /= SPEED_KB;
                    } else if (speed < SPEED_GB) {
                        preFix = (res.getString(R.string.mega_bytes)).charAt(0);
                        speedNormalized /= SPEED_MB;
                    } else {
                        preFix = (res.getString(R.string.giga_bytes)).charAt(0);
                        speedNormalized /= SPEED_GB;
                    }
                    // Format the String
                    speedText = String.format(SPEED_PLACEHOLDER, mFormatter.format(speedNormalized).toString(), preFix);
                    final long remainingMillis = ((total - current) * 1000) / speed;
                    if (remainingMillis >= DateUtils.HOUR_IN_MILLIS) {
                        final int hours = (int) ((remainingMillis + 1800000) / DateUtils.HOUR_IN_MILLIS);
                        durationText = res.getQuantityString(R.plurals.duration_hours, hours, hours);
                    } else if (remainingMillis >= DateUtils.MINUTE_IN_MILLIS) {
                        final int minutes = (int) ((remainingMillis + 30000) / DateUtils.MINUTE_IN_MILLIS);
                        durationText = res.getQuantityString(R.plurals.duration_minutes, minutes, minutes);
                    } else {
                        final int seconds = (int) ((remainingMillis + 500) / DateUtils.SECOND_IN_MILLIS);
                        durationText = res.getQuantityString(R.plurals.duration_seconds, seconds, seconds);
                    }
                    remainingText = res.getString(R.string.download_remaining, durationText);
                }
                builder.setProgress(100, percent, false);
            } else {
                builder.setProgress(100, 0, true);
            }
        }
        // Build titles and description
        final Notification notif;
        String contentText = null;
        if (cluster.size() == 1) {
            final Notification.InboxStyle inboxStyle = new Notification.InboxStyle(builder);
            final DownloadInfo info = cluster.iterator().next();
            final Uri uris = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, info.mId);
            builder.setContentTitle(getDownloadTitle(res, info));
            final Intent stopIntent = new Intent(Constants.ACTION_NOTIFICATION_STOP, uris, mContext, DownloadReceiver.class);
            stopIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent pauseIntent = new Intent(Constants.ACTION_NOTIFICATION_PAUSE, uris, mContext, DownloadReceiver.class);
            pauseIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent resumeIntent = new Intent(Constants.ACTION_NOTIFICATION_RESUME, uris, mContext, DownloadReceiver.class);
            resumeIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent retryIntent = new Intent(Constants.ACTION_NOTIFICATION_RETRY, uris, mContext, DownloadReceiver.class);
            retryIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            if (!TextUtils.isEmpty(info.mDescription)) {
                inboxStyle.addLine(info.mDescription);
            } else if (!TextUtils.isEmpty(info.mPackage)) {
                final PackageManager pm = mContext.getApplicationContext().getPackageManager();
                ApplicationInfo ai;
                try {
                    ai = pm.getApplicationInfo(info.mPackage, 0);
                } catch (final PackageManager.NameNotFoundException e) {
                    ai = null;
                }
                final String packageName = (String) (ai != null ? pm.getApplicationLabel(ai) : "(unknown)");
                if (!TextUtils.isEmpty(packageName)) {
                    inboxStyle.addLine(packageName);
                }
            }
            if (type == TYPE_ACTIVE) {
                if (hasErrorStatus) {
                    contentText = res.getString(R.string.notification_download_failed);
                } else if (TextUtils.isEmpty(speedText) && TextUtils.isEmpty(remainingText)) {
                    contentText = res.getString(R.string.download_running);
                } else if (!TextUtils.isEmpty(remainingText) && TextUtils.isEmpty(speedText)) {
                    contentText = remainingText;
                } else if (TextUtils.isEmpty(remainingText) && !TextUtils.isEmpty(speedText)) {
                    contentText = speedText;
                } else {
                    contentText = speedText + ", " + remainingText;
                }
                if (hasErrorStatus) {
                    builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_retry), PendingIntent.getBroadcast(mContext, 0, retryIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                } else {
                    builder.addAction(com.android.internal.R.drawable.ic_media_pause, res.getString(R.string.download_pause), PendingIntent.getBroadcast(mContext, 0, pauseIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                }
                builder.addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop), PendingIntent.getBroadcast(mContext, 0, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_WAITING) {
                contentText = res.getString(R.string.notification_need_wifi_for_size);
                builder.addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop), PendingIntent.getBroadcast(mContext, 0, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_PAUSED) {
                contentText = res.getString(R.string.notification_paused_in_background);
                builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_resume), PendingIntent.getBroadcast(mContext, 0, resumeIntent, PendingIntent.FLAG_UPDATE_CURRENT)).addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop), PendingIntent.getBroadcast(mContext, 0, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_COMPLETE) {
                if (hasErrorStatus) {
                    contentText = res.getString(R.string.notification_download_failed);
                    builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_retry), PendingIntent.getBroadcast(mContext, 0, retryIntent, PendingIntent.FLAG_UPDATE_CURRENT)).addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop), PendingIntent.getBroadcast(mContext, 0, stopIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                } else if (Downloads.Impl.isStatusSuccess(info.mStatus)) {
                    contentText = res.getString(R.string.notification_download_complete);
                }
            }
            inboxStyle.setSummaryText(contentText);
            builder.setContentText(contentText);
            builder.setContentInfo(percentText);
            notif = inboxStyle.build();
        } else {
            final Notification.InboxStyle inboxStyle = new Notification.InboxStyle(builder);
            final Uri uris = new Uri.Builder().scheme("active-dl").appendPath(tag).build();
            for (DownloadInfo info : cluster) {
                inboxStyle.addLine(getDownloadTitle(res, info));
            }
            final Intent stopAllIntent = new Intent(Constants.ACTION_NOTIFICATION_STOP_ALL, uris, mContext, DownloadReceiver.class);
            stopAllIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent pauseAllIntent = new Intent(Constants.ACTION_NOTIFICATION_PAUSE_ALL, uris, mContext, DownloadReceiver.class);
            pauseAllIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent resumeAllIntent = new Intent(Constants.ACTION_NOTIFICATION_RESUME_ALL, uris, mContext, DownloadReceiver.class);
            resumeAllIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            final Intent retryAllIntent = new Intent(Constants.ACTION_NOTIFICATION_RETRY_ALL, uris, mContext, DownloadReceiver.class);
            retryAllIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, getDownloadIds(cluster));
            if (type == TYPE_ACTIVE) {
                if (hasErrorStatus) {
                    builder.setContentTitle(res.getString(R.string.notification_download_failed));
                } else {
                    builder.setContentTitle(res.getQuantityString(R.plurals.notif_summary_active, cluster.size(), cluster.size()));
                }
                if (TextUtils.isEmpty(speedText) && TextUtils.isEmpty(remainingText)) {
                    contentText = res.getString(R.string.download_running);
                } else if (!TextUtils.isEmpty(remainingText) && TextUtils.isEmpty(speedText)) {
                    contentText = remainingText;
                } else if (TextUtils.isEmpty(remainingText) && !TextUtils.isEmpty(speedText)) {
                    contentText = speedText;
                } else {
                    contentText = speedText + ", " + remainingText;
                }
                if (hasErrorStatus) {
                    builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_retry_all), PendingIntent.getBroadcast(mContext, 0, retryAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                } else {
                    builder.addAction(com.android.internal.R.drawable.ic_media_pause, res.getString(R.string.download_pause_all), PendingIntent.getBroadcast(mContext, 0, pauseAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                }
                builder.addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop), PendingIntent.getBroadcast(mContext, 0, stopAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_WAITING) {
                builder.setContentTitle(res.getQuantityString(R.plurals.notif_summary_waiting, cluster.size(), cluster.size()));
                contentText = res.getString(R.string.notification_need_wifi_for_size);
                builder.addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop_all), PendingIntent.getBroadcast(mContext, 0, stopAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_PAUSED) {
                builder.setContentTitle(res.getQuantityString(R.plurals.notif_summary_waiting, cluster.size(), cluster.size()));
                contentText = res.getString(R.string.notification_paused_in_background);
                builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_resume_all), PendingIntent.getBroadcast(mContext, 0, resumeAllIntent, PendingIntent.FLAG_UPDATE_CURRENT)).addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop_all), PendingIntent.getBroadcast(mContext, 0, stopAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
            } else if (type == TYPE_COMPLETE) {
                if (hasErrorStatus) {
                    contentText = res.getString(R.string.notification_download_failed);
                    builder.addAction(com.android.internal.R.drawable.ic_media_play, res.getString(R.string.download_retry_all), PendingIntent.getBroadcast(mContext, 0, retryAllIntent, PendingIntent.FLAG_UPDATE_CURRENT)).addAction(com.android.internal.R.drawable.ic_media_stop, res.getString(R.string.download_stop_all), PendingIntent.getBroadcast(mContext, 0, stopAllIntent, PendingIntent.FLAG_UPDATE_CURRENT));
                }
            }
            inboxStyle.setSummaryText(contentText);
            builder.setContentText(contentText);
            builder.setContentInfo(percentText);
            notif = inboxStyle.build();
        }
        mNotifManager.notify(tag, 0, notif);
    }
    // Remove stale tags that weren't renewed
    final Iterator<String> it = mActiveNotifs.keySet().iterator();
    while (it.hasNext()) {
        final String tag = it.next();
        if (!clustered.containsKey(tag)) {
            mNotifManager.cancel(tag, 0);
            it.remove();
        }
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.notification_panel_settings);
    PreferenceScreen prefSet = getPreferenceScreen();
    ContentResolver resolver = getActivity().getContentResolver();
    mStatusBarCustomHeader = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_CUSTOM_HEADER);
    mStatusBarCustomHeader.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_CUSTOM_HEADER, 0) == 1);
    mStatusBarCustomHeader.setOnPreferenceChangeListener(this);
    mQuickSwipe = (CheckBoxPreference) prefSet.findPreference(QUICK_SWIPE);
    mQuickSwipe.setChecked(Settings.System.getInt(resolver, Settings.System.QUICK_SWIPE, 1) == 1);
    mQuickSwipe.setOnPreferenceChangeListener(this);
    mClockShortcut = prefSet.findPreference(CLOCK_SHORTCUT);
    Intent clockShortcutIntent = null;
    String clockShortcutIntentUri = Settings.System.getString(getContentResolver(), Settings.System.CLOCK_SHORTCUT);
    if (clockShortcutIntentUri != null) {
        try {
            clockShortcutIntent = Intent.parseUri(clockShortcutIntentUri, 0);
        } catch (URISyntaxException e) {
            clockShortcutIntent = null;
        }
    }
    if (clockShortcutIntent != null) {
        PackageManager packageManager = getPackageManager();
        ResolveInfo info = packageManager.resolveActivity(clockShortcutIntent, 0);
        if (info != null) {
            mClockShortcut.setSummary(info.loadLabel(packageManager));
        } else {
            mClockShortcut.setSummary(R.string.clock_shortcut_default);
        }
    } else {
        mClockShortcut.setSummary(R.string.clock_shortcut_default);
    }
    mCalendarShortcut = prefSet.findPreference(CALENDAR_SHORTCUT);
    Intent calendarShortcutIntent = null;
    String calendarShortcutIntentUri = Settings.System.getString(getContentResolver(), Settings.System.CALENDAR_SHORTCUT);
    if (calendarShortcutIntentUri != null) {
        try {
            calendarShortcutIntent = Intent.parseUri(calendarShortcutIntentUri, 0);
        } catch (URISyntaxException e) {
            calendarShortcutIntent = null;
        }
    }
    if (calendarShortcutIntent != null) {
        PackageManager packageManager = getPackageManager();
        ResolveInfo info = packageManager.resolveActivity(calendarShortcutIntent, 0);
        if (info != null) {
            mCalendarShortcut.setSummary(info.loadLabel(packageManager));
        } else {
            mCalendarShortcut.setSummary(R.string.calendar_shortcut_default);
        }
    } else {
        mCalendarShortcut.setSummary(R.string.calendar_shortcut_default);
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.notification_panel_settings);
    PreferenceScreen prefSet = getPreferenceScreen();
    ContentResolver resolver = getActivity().getContentResolver();
    mStatusBarCustomHeader = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_CUSTOM_HEADER);
    mStatusBarCustomHeader.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_CUSTOM_HEADER, 0) == 1);
    mStatusBarCustomHeader.setOnPreferenceChangeListener(this);
    mQuickSwipe = (CheckBoxPreference) prefSet.findPreference(QUICK_SWIPE);
    mQuickSwipe.setChecked(Settings.System.getInt(resolver, Settings.System.QUICK_SWIPE, 1) == 1);
    mQuickSwipe.setOnPreferenceChangeListener(this);
    mClockShortcut = (AppSelectListPreference) prefSet.findPreference(CLOCK_SHORTCUT);
    mClockShortcut.setOnPreferenceChangeListener(this);
    mCalendarShortcut = (AppSelectListPreference) prefSet.findPreference(CALENDAR_SHORTCUT);
    mCalendarShortcut.setOnPreferenceChangeListener(this);
    updateClockCalendarSummary();
}
#end_block

#method_before
public boolean onPreferenceChange(Preference preference, Object objValue) {
    ContentResolver resolver = getActivity().getContentResolver();
    if (preference == mStatusBarCustomHeader) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_CUSTOM_HEADER, value ? 1 : 0);
    } else if (preference == mQuickSwipe) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.QUICK_SWIPE, value ? 1 : 0);
    } else {
        return false;
    }
    return true;
}
#method_after
public boolean onPreferenceChange(Preference preference, Object objValue) {
    ContentResolver resolver = getActivity().getContentResolver();
    if (preference == mStatusBarCustomHeader) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_CUSTOM_HEADER, value ? 1 : 0);
    } else if (preference == mQuickSwipe) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.QUICK_SWIPE, value ? 1 : 0);
    } else if (preference == mClockShortcut) {
        String value = (String) objValue;
        // a value of null means to use the default
        Settings.System.putString(resolver, Settings.System.CLOCK_SHORTCUT, value);
        updateClockCalendarSummary();
    } else if (preference == mCalendarShortcut) {
        String value = (String) objValue;
        // a value of null means to use the default
        Settings.System.putString(resolver, Settings.System.CALENDAR_SHORTCUT, value);
        updateClockCalendarSummary();
    } else {
        return false;
    }
    return true;
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_CUSTOM_HEADER), false, this);
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_CUSTOM_HEADER), false, this, UserHandle.USER_ALL);
    update();
}
#end_block

#method_before
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    boolean autoBrightness = Settings.System.getInt(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, 0) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC;
    mBrightnessControl = !autoBrightness && Settings.System.getInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0) == 1;
    mCustomHeader = Settings.System.getInt(resolver, Settings.System.STATUS_BAR_CUSTOM_HEADER, 0) == 1;
    updateCustomHeaderStatus();
}
#method_after
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    boolean autoBrightness = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, 0, UserHandle.USER_CURRENT) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC;
    mBrightnessControl = !autoBrightness && Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0, UserHandle.USER_CURRENT) == 1;
    mCustomHeader = Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_CUSTOM_HEADER, 0, UserHandle.USER_CURRENT) == 1;
    updateCustomHeaderStatus();
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUICK_SETTINGS_TILES), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUICK_SETTINGS_TILES_ROW), false, this);
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUICK_SETTINGS_TILES), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUICK_SETTINGS_TILES_ROW), false, this, UserHandle.USER_ALL);
    update();
}
#end_block

#method_before
void observe() {
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_BATTERY_STYLE), false, this);
}
#method_after
void observe() {
    mContext.getContentResolver().registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_BATTERY_STYLE), false, this, UserHandle.USER_ALL);
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange) {
    updateBatteryIcons();
}
#method_after
@Override
public void onChange(boolean selfChange) {
    update();
}
#end_block

#method_before
@Override
public void start() {
    mDisplay = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
    updateDisplaySize();
    // calls createAndAddWindows()
    super.start();
    addNavigationBar();
    SettingsObserver observer = new SettingsObserver(mHandler);
    observer.observe();
    BatteryIconSettingsObserver batteryIconObserver = new BatteryIconSettingsObserver(mHandler);
    batteryIconObserver.observe();
    TilesChangedObserver tilesChangedObserver = new TilesChangedObserver(mHandler);
    tilesChangedObserver.observe();
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP), true, mHeadsUpObserver);
    }
}
#method_after
@Override
public void start() {
    mDisplay = ((WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
    updateDisplaySize();
    // calls createAndAddWindows()
    super.start();
    addNavigationBar();
    mSettingsObserver.observe();
    mBatteryIconSettingsObserver.observe();
    mTilesChangedObserver.observe();
    // Lastly, call to the icon policy to install/update all the icons.
    mIconPolicy = new PhoneStatusBarPolicy(mContext);
    // set up
    mHeadsUpObserver.onChange(true);
    if (ENABLE_HEADS_UP) {
        mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(SETTING_HEADS_UP), true, mHeadsUpObserver);
    }
}
#end_block

#method_before
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    mScreenWidth = (float) context.getResources().getDisplayMetrics().widthPixels;
    mMinBrightness = context.getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
    // populates mDisplayMetrics
    updateDisplaySize();
    loadDimens();
    mIconSize = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_icon_size);
    mStatusBarWindow = (StatusBarWindowView) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.mService = this;
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    mNotificationPanelIsFullScreenWidth = (mNotificationPanel.getLayoutParams().width == ViewGroup.LayoutParams.MATCH_PARENT);
    // make the header non-responsive to clicks
    mNotificationPanel.findViewById(R.id.header).setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            // e eats everything
            return true;
        }
    });
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
    }
    if (ENABLE_HEADS_UP) {
        mHeadsUpNotificationView = (HeadsUpNotificationView) View.inflate(context, R.layout.heads_up, null);
        mHeadsUpNotificationView.setVisibility(View.GONE);
        mHeadsUpNotificationView.setBar(this);
    }
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    updateShowSearchHoldoff();
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav) {
            mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
            mNavigationBarView.setDisabledFlags(mDisabled);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    if (mRecreating) {
    } else {
        addActiveDisplayView();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mSystemIconArea = (LinearLayout) mStatusBarView.findViewById(R.id.system_icon_area);
    mStatusIcons = (LinearLayout) mStatusBarView.findViewById(R.id.statusIcons);
    mStatusBarContents = (LinearLayout) mStatusBarView.findViewById(R.id.status_bar_contents);
    mCenterSpacer = (View) mStatusBarView.findViewById(R.id.center_spacer);
    mCenterClockLayout = (LinearLayout) mStatusBarView.findViewById(R.id.center_clock_layout);
    mClock = (Clock) mStatusBarView.findViewById(R.id.clock);
    mClockCenter = (ClockCenter) mStatusBarView.findViewById(R.id.center_clock);
    mNotificationIcons = (IconMerger) mStatusBarView.findViewById(R.id.notificationIcons);
    mMoreIcon = mStatusBarView.findViewById(R.id.moreIcon);
    mNotificationIcons.setOverflowIndicator(mMoreIcon);
    mNotificationIcons.setClockCenter(mClockCenter);
    mNotificationIcons.setCenterSpacer(mCenterSpacer);
    mTickerView = mStatusBarView.findViewById(R.id.ticker);
    mPile = (NotificationRowLayout) mStatusBarWindow.findViewById(R.id.latestItems);
    mPile.setLayoutTransitionsEnabled(false);
    mPile.setLongPressListener(getNotificationLongClicker());
    // was: expanded.findViewById(R.id.notificationLinearLayout);
    mExpandedContents = mPile;
    mNotificationPanelHeader = mStatusBarWindow.findViewById(R.id.header);
    mStatusHeaderMachine = new StatusHeaderMachine(mContext);
    mStatusHeaderImage = (ImageView) mNotificationPanelHeader.findViewById(R.id.header_background_image);
    mHeaderOverlay = res.getDrawable(R.drawable.bg_custom_header_overlay);
    updateCustomHeaderStatus();
    mClearButton = mStatusBarWindow.findViewById(R.id.clear_all_button);
    mClearButton.setOnClickListener(mClearButtonListener);
    mClearButton.setAlpha(0f);
    mClearButton.setVisibility(View.INVISIBLE);
    mClearButton.setEnabled(false);
    mDateView = (DateView) mStatusBarWindow.findViewById(R.id.date);
    if (mDateView != null) {
        mDateView.setOnClickListener(mCalendarClickListener);
        mDateView.setEnabled(true);
    }
    mClockView = mNotificationPanelHeader.findViewById(R.id.clock);
    if (mClockView != null) {
        mClockView.setOnClickListener(mClockClickListener);
        mClockView.setEnabled(true);
    }
    mHasSettingsPanel = res.getBoolean(R.bool.config_hasSettingsPanel);
    mHasFlipSettings = res.getBoolean(R.bool.config_hasFlipSettingsPanel);
    // Notifications date time
    mDateTimeView = mNotificationPanelHeader.findViewById(R.id.datetime);
    mSettingsButton = (ImageView) mStatusBarWindow.findViewById(R.id.settings_button);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
        if (mHasSettingsPanel) {
            if (mStatusBarView.hasFullWidthNotifications()) {
                // the settings panel is hiding behind this button
                mSettingsButton.setImageResource(R.drawable.ic_notify_quicksettings);
                mSettingsButton.setVisibility(View.VISIBLE);
            } else {
                // there is a settings panel, but it's on the other side of the (large) screen
                final View buttonHolder = mStatusBarWindow.findViewById(R.id.settings_button_holder);
                if (buttonHolder != null) {
                    buttonHolder.setVisibility(View.GONE);
                }
            }
        } else {
            // no settings panel, go straight to settings
            mSettingsButton.setVisibility(View.VISIBLE);
            mSettingsButton.setImageResource(R.drawable.ic_notify_settings);
        }
    }
    if (mHasFlipSettings) {
        mNotificationButton = (ImageView) mStatusBarWindow.findViewById(R.id.notification_button);
        if (mNotificationButton != null) {
            mNotificationButton.setOnClickListener(mNotificationButtonListener);
        }
    }
    mScrollView = (ScrollView) mStatusBarWindow.findViewById(R.id.scroll);
    // less drawing during pulldowns
    mScrollView.setVerticalScrollBarEnabled(false);
    if (!mNotificationPanelIsFullScreenWidth) {
        mScrollView.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_NOTIFICATION_ICONS | View.STATUS_BAR_DISABLE_CLOCK);
    }
    mTicker = new MyTicker(context, mStatusBarView);
    TickerView tickerView = (TickerView) mStatusBarView.findViewById(R.id.tickerText);
    tickerView.mTicker = mTicker;
    mEdgeBorder = res.getDimensionPixelSize(R.dimen.status_bar_edge_ignore);
    // set the inital view visibility
    setAreThereNotifications();
    // Other icons
    // will post a notification
    mLocationController = new LocationController(mContext);
    mBatteryController = new BatteryController(mContext);
    mNetworkController = new NetworkController(mContext);
    mBluetoothController = new BluetoothController(mContext);
    mRotationLockController = new RotationLockController(mContext);
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCluster(signalCluster);
    signalCluster.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mEmergencyCallLabel = (TextView) mStatusBarWindow.findViewById(R.id.emergency_calls_only);
        if (mEmergencyCallLabel != null) {
            mNetworkController.addEmergencyLabelView(mEmergencyCallLabel);
            mEmergencyCallLabel.setOnClickListener(new View.OnClickListener() {

                public void onClick(View v) {
                }
            });
            mEmergencyCallLabel.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {

                @Override
                public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
                    updateCarrierLabelVisibility(false);
                }
            });
        }
    }
    mCarrierLabel = (TextView) mStatusBarWindow.findViewById(R.id.carrier_label);
    mShowCarrierInPanel = (mCarrierLabel != null);
    if (DEBUG)
        Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" + mShowCarrierInPanel);
    if (mShowCarrierInPanel) {
        mCarrierLabel.setVisibility(mCarrierLabelVisible ? View.VISIBLE : View.INVISIBLE);
        // for other devices, we show whatever network is connected
        if (mNetworkController.hasMobileDataFeature()) {
            mNetworkController.addMobileLabelView(mCarrierLabel);
        } else {
            mNetworkController.addCombinedLabelView(mCarrierLabel);
        }
        // set up the dynamic hide/show of the label
        mPile.setOnSizeChangedListener(new OnSizeChangedListener() {

            @Override
            public void onSizeChanged(View view, int w, int h, int oldw, int oldh) {
                updateCarrierLabelVisibility(false);
            }
        });
    }
    // Quick Settings (where available, some restrictions apply)
    if (mHasSettingsPanel) {
        // first, figure out where quick settings should be inflated
        final View settings_stub;
        if (mHasFlipSettings) {
            // a version of quick settings that flips around behind the notifications
            settings_stub = mStatusBarWindow.findViewById(R.id.flip_settings_stub);
            if (settings_stub != null) {
                mFlipSettingsView = ((ViewStub) settings_stub).inflate();
                mFlipSettingsView.setVisibility(View.GONE);
                mFlipSettingsView.setVerticalScrollBarEnabled(false);
                mEditModeButton = (ImageView) mStatusBarWindow.findViewById(R.id.edit_mode_button);
                mEditModeButton.setVisibility(View.INVISIBLE);
            }
        } else {
            // full quick settings panel
            settings_stub = mStatusBarWindow.findViewById(R.id.quick_settings_stub);
            if (settings_stub != null) {
                mSettingsPanel = (SettingsPanelView) ((ViewStub) settings_stub).inflate();
            } else {
                mSettingsPanel = (SettingsPanelView) mStatusBarWindow.findViewById(R.id.settings_panel);
            }
            if (mSettingsPanel != null) {
                if (!ActivityManager.isHighEndGfx()) {
                    mSettingsPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
                }
                mEditModeButton = (ImageView) mSettingsPanel.findViewById(R.id.edit_mode_button);
            }
        }
        // wherever you find it, Quick Settings needs a container to survive
        mSettingsContainer = (QuickSettingsContainerView) mStatusBarWindow.findViewById(R.id.quick_settings_container);
        if (mSettingsContainer != null) {
            mQS = new QuickSettings(mContext, mSettingsContainer);
            if (!mNotificationPanelIsFullScreenWidth) {
                mSettingsContainer.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_SYSTEM_INFO);
            }
            if (mSettingsPanel != null) {
                mSettingsPanel.setQuickSettings(mQS);
            }
            mQS.setService(this);
            mQS.setBar(mStatusBarView);
            mQS.setup(mNetworkController, mBluetoothController, mBatteryController, mLocationController, mRotationLockController);
            if (mEditModeButton != null) {
                mEditModeButton.setOnClickListener(mEditModeButtonListener);
                mEditModeButton.setOnLongClickListener(mEditModeLongButtonListener);
                mEditModeButton.setEnabled(true);
            }
            // set edit mode changed listener
            mSettingsContainer.setOnEditModeChangedListener(new QuickSettingsContainerView.EditModeChangedListener() {

                @Override
                public void onEditModeChanged(final boolean enabled) {
                    mEditModeButton.setImageResource(enabled ? R.drawable.ic_notify_edit_save : R.drawable.ic_notify_edit_normal);
                }
            });
        } else {
            // fly away, be free
            mQS = null;
        }
    }
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(ACTION_DEMO);
    context.registerReceiver(mBroadcastReceiver, filter);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    mVelocityTracker = VelocityTracker.obtain();
    mBattery = (BatteryMeterView) mStatusBarView.findViewById(R.id.battery);
    mCircleBattery = (BatteryCircleMeterView) mStatusBarView.findViewById(R.id.circle_battery);
    mPercentBattery = (BatteryPercentMeterView) mStatusBarView.findViewById(R.id.percent_battery);
    return mStatusBarView;
}
#method_after
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    mScreenWidth = (float) context.getResources().getDisplayMetrics().widthPixels;
    mMinBrightness = context.getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
    // populates mDisplayMetrics
    updateDisplaySize();
    loadDimens();
    mIconSize = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_icon_size);
    mStatusBarWindow = (StatusBarWindowView) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.mService = this;
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    mNotificationPanelIsFullScreenWidth = (mNotificationPanel.getLayoutParams().width == ViewGroup.LayoutParams.MATCH_PARENT);
    // make the header non-responsive to clicks
    mNotificationPanel.findViewById(R.id.header).setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            // e eats everything
            return true;
        }
    });
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
    }
    if (ENABLE_HEADS_UP) {
        mHeadsUpNotificationView = (HeadsUpNotificationView) View.inflate(context, R.layout.heads_up, null);
        mHeadsUpNotificationView.setVisibility(View.GONE);
        mHeadsUpNotificationView.setBar(this);
    }
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    updateShowSearchHoldoff();
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav) {
            mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
            mNavigationBarView.setDisabledFlags(mDisabled);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    if (mRecreating) {
    } else {
        addActiveDisplayView();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mSystemIconArea = (LinearLayout) mStatusBarView.findViewById(R.id.system_icon_area);
    mStatusIcons = (LinearLayout) mStatusBarView.findViewById(R.id.statusIcons);
    mStatusBarContents = (LinearLayout) mStatusBarView.findViewById(R.id.status_bar_contents);
    mCenterSpacer = (View) mStatusBarView.findViewById(R.id.center_spacer);
    mCenterClockLayout = (LinearLayout) mStatusBarView.findViewById(R.id.center_clock_layout);
    mClock = (Clock) mStatusBarView.findViewById(R.id.clock);
    mClockCenter = (ClockCenter) mStatusBarView.findViewById(R.id.center_clock);
    mNotificationIcons = (IconMerger) mStatusBarView.findViewById(R.id.notificationIcons);
    mMoreIcon = mStatusBarView.findViewById(R.id.moreIcon);
    mNotificationIcons.setOverflowIndicator(mMoreIcon);
    mNotificationIcons.setClockCenter(mClockCenter);
    mNotificationIcons.setCenterSpacer(mCenterSpacer);
    mTickerView = mStatusBarView.findViewById(R.id.ticker);
    mNetworkTraffic = (NetworkTraffic) mStatusBarView.findViewById(R.id.networkTraffic);
    mPile = (NotificationRowLayout) mStatusBarWindow.findViewById(R.id.latestItems);
    mPile.setLayoutTransitionsEnabled(false);
    mPile.setLongPressListener(getNotificationLongClicker());
    // was: expanded.findViewById(R.id.notificationLinearLayout);
    mExpandedContents = mPile;
    mNotificationPanelHeader = mStatusBarWindow.findViewById(R.id.header);
    mStatusHeaderMachine = new StatusHeaderMachine(mContext);
    mStatusHeaderImage = (ImageView) mNotificationPanelHeader.findViewById(R.id.header_background_image);
    mHeaderOverlay = res.getDrawable(R.drawable.bg_custom_header_overlay);
    updateCustomHeaderStatus();
    mClearButton = mStatusBarWindow.findViewById(R.id.clear_all_button);
    mClearButton.setOnClickListener(mClearButtonListener);
    mClearButton.setAlpha(0f);
    mClearButton.setVisibility(View.INVISIBLE);
    mClearButton.setEnabled(false);
    mDateView = (DateView) mStatusBarWindow.findViewById(R.id.date);
    if (mDateView != null) {
        mDateView.setOnClickListener(mCalendarClickListener);
        mDateView.setEnabled(true);
    }
    mClockView = mNotificationPanelHeader.findViewById(R.id.clock);
    if (mClockView != null) {
        mClockView.setOnClickListener(mClockClickListener);
        mClockView.setEnabled(true);
    }
    mHasSettingsPanel = res.getBoolean(R.bool.config_hasSettingsPanel);
    mHasFlipSettings = res.getBoolean(R.bool.config_hasFlipSettingsPanel);
    // Notifications date time
    mDateTimeView = mNotificationPanelHeader.findViewById(R.id.datetime);
    mSettingsButton = (ImageView) mStatusBarWindow.findViewById(R.id.settings_button);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
        if (mHasSettingsPanel) {
            if (mStatusBarView.hasFullWidthNotifications()) {
                // the settings panel is hiding behind this button
                mSettingsButton.setImageResource(R.drawable.ic_notify_quicksettings);
                mSettingsButton.setVisibility(View.VISIBLE);
            } else {
                // there is a settings panel, but it's on the other side of the (large) screen
                final View buttonHolder = mStatusBarWindow.findViewById(R.id.settings_button_holder);
                if (buttonHolder != null) {
                    buttonHolder.setVisibility(View.GONE);
                }
            }
        } else {
            // no settings panel, go straight to settings
            mSettingsButton.setVisibility(View.VISIBLE);
            mSettingsButton.setImageResource(R.drawable.ic_notify_settings);
        }
    }
    if (mHasFlipSettings) {
        mNotificationButton = (ImageView) mStatusBarWindow.findViewById(R.id.notification_button);
        if (mNotificationButton != null) {
            mNotificationButton.setOnClickListener(mNotificationButtonListener);
        }
    }
    mScrollView = (ScrollView) mStatusBarWindow.findViewById(R.id.scroll);
    // less drawing during pulldowns
    mScrollView.setVerticalScrollBarEnabled(false);
    if (!mNotificationPanelIsFullScreenWidth) {
        mScrollView.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_NOTIFICATION_ICONS | View.STATUS_BAR_DISABLE_CLOCK);
    }
    mTicker = new MyTicker(context, mStatusBarView);
    TickerView tickerView = (TickerView) mStatusBarView.findViewById(R.id.tickerText);
    tickerView.mTicker = mTicker;
    mEdgeBorder = res.getDimensionPixelSize(R.dimen.status_bar_edge_ignore);
    // set the inital view visibility
    setAreThereNotifications();
    // Other icons
    // will post a notification
    mLocationController = new LocationController(mContext);
    mBatteryController = new BatteryController(mContext);
    mNetworkController = new NetworkController(mContext);
    mBluetoothController = new BluetoothController(mContext);
    mRotationLockController = new RotationLockController(mContext);
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCluster(signalCluster);
    signalCluster.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mEmergencyCallLabel = (TextView) mStatusBarWindow.findViewById(R.id.emergency_calls_only);
        if (mEmergencyCallLabel != null) {
            mNetworkController.addEmergencyLabelView(mEmergencyCallLabel);
            mEmergencyCallLabel.setOnClickListener(new View.OnClickListener() {

                public void onClick(View v) {
                }
            });
            mEmergencyCallLabel.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {

                @Override
                public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
                    updateCarrierLabelVisibility(false);
                }
            });
        }
    }
    mCarrierLabel = (TextView) mStatusBarWindow.findViewById(R.id.carrier_label);
    mShowCarrierInPanel = (mCarrierLabel != null);
    if (DEBUG)
        Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" + mShowCarrierInPanel);
    if (mShowCarrierInPanel) {
        mCarrierLabel.setVisibility(mCarrierLabelVisible ? View.VISIBLE : View.INVISIBLE);
        // for other devices, we show whatever network is connected
        if (mNetworkController.hasMobileDataFeature()) {
            mNetworkController.addMobileLabelView(mCarrierLabel);
        } else {
            mNetworkController.addCombinedLabelView(mCarrierLabel);
        }
        // set up the dynamic hide/show of the label
        mPile.setOnSizeChangedListener(new OnSizeChangedListener() {

            @Override
            public void onSizeChanged(View view, int w, int h, int oldw, int oldh) {
                updateCarrierLabelVisibility(false);
            }
        });
    }
    // Quick Settings (where available, some restrictions apply)
    if (mHasSettingsPanel) {
        // first, figure out where quick settings should be inflated
        final View settings_stub;
        if (mHasFlipSettings) {
            // a version of quick settings that flips around behind the notifications
            settings_stub = mStatusBarWindow.findViewById(R.id.flip_settings_stub);
            if (settings_stub != null) {
                mFlipSettingsView = ((ViewStub) settings_stub).inflate();
                mFlipSettingsView.setVisibility(View.GONE);
                mFlipSettingsView.setVerticalScrollBarEnabled(false);
                mEditModeButton = (ImageView) mStatusBarWindow.findViewById(R.id.edit_mode_button);
                mEditModeButton.setVisibility(View.INVISIBLE);
            }
        } else {
            // full quick settings panel
            settings_stub = mStatusBarWindow.findViewById(R.id.quick_settings_stub);
            if (settings_stub != null) {
                mSettingsPanel = (SettingsPanelView) ((ViewStub) settings_stub).inflate();
            } else {
                mSettingsPanel = (SettingsPanelView) mStatusBarWindow.findViewById(R.id.settings_panel);
            }
            if (mSettingsPanel != null) {
                if (!ActivityManager.isHighEndGfx()) {
                    mSettingsPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
                }
                mEditModeButton = (ImageView) mSettingsPanel.findViewById(R.id.edit_mode_button);
            }
        }
        // wherever you find it, Quick Settings needs a container to survive
        mSettingsContainer = (QuickSettingsContainerView) mStatusBarWindow.findViewById(R.id.quick_settings_container);
        if (mSettingsContainer != null) {
            mQS = new QuickSettings(mContext, mSettingsContainer);
            if (!mNotificationPanelIsFullScreenWidth) {
                mSettingsContainer.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_SYSTEM_INFO);
            }
            if (mSettingsPanel != null) {
                mSettingsPanel.setQuickSettings(mQS);
            }
            mQS.setService(this);
            mQS.setBar(mStatusBarView);
            mQS.setup(mNetworkController, mBluetoothController, mBatteryController, mLocationController, mRotationLockController);
            if (mEditModeButton != null) {
                mEditModeButton.setOnClickListener(mEditModeButtonListener);
                mEditModeButton.setOnLongClickListener(mEditModeLongButtonListener);
                mEditModeButton.setEnabled(true);
            }
            // set edit mode changed listener
            mSettingsContainer.setOnEditModeChangedListener(new QuickSettingsContainerView.EditModeChangedListener() {

                @Override
                public void onEditModeChanged(final boolean enabled) {
                    mEditModeButton.setImageResource(enabled ? R.drawable.ic_notify_edit_save : R.drawable.ic_notify_edit_normal);
                }
            });
        } else {
            // fly away, be free
            mQS = null;
        }
    }
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(ACTION_DEMO);
    context.registerReceiver(mBroadcastReceiver, filter);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    mVelocityTracker = VelocityTracker.obtain();
    mBattery = (BatteryMeterView) mStatusBarView.findViewById(R.id.battery);
    mCircleBattery = (BatteryCircleMeterView) mStatusBarView.findViewById(R.id.circle_battery);
    mPercentBattery = (BatteryPercentMeterView) mStatusBarView.findViewById(R.id.percent_battery);
    return mStatusBarView;
}
#end_block

#method_before
@Override
public void userSwitched(int newUserId) {
    if (MULTIUSER_DEBUG)
        mNotificationPanelDebugText.setText("USER " + newUserId);
    animateCollapsePanels();
    updateNotificationIcons();
    resetUserSetupObserver();
    if (mNavigationBarView != null) {
        mNavigationBarView.updateSettings();
    }
    super.userSwitched(newUserId);
}
#method_after
@Override
public void userSwitched(int newUserId) {
    if (MULTIUSER_DEBUG)
        mNotificationPanelDebugText.setText("USER " + newUserId);
    animateCollapsePanels();
    updateNotificationIcons();
    resetUserSetupObserver();
    if (mNavigationBarView != null) {
        mNavigationBarView.updateSettings();
    }
    mSettingsObserver.update();
    mBatteryIconSettingsObserver.update();
    mTilesChangedObserver.update();
    mNotificationIcons.updateSettings();
    mNetworkTraffic.updateSettings();
    mClock.updateSettings();
    mClockCenter.updateSettings();
    super.userSwitched(newUserId);
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.display_rotation);
    PreferenceScreen prefSet = getPreferenceScreen();
    mAccelerometer = (CheckBoxPreference) findPreference(KEY_ACCELEROMETER);
    mAccelerometer.setPersistent(false);
    mLockScreenRotationPref = (CheckBoxPreference) prefSet.findPreference(LOCKSCREEN_ROTATION);
    mRotation0Pref = (CheckBoxPreference) prefSet.findPreference(ROTATION_0_PREF);
    mRotation90Pref = (CheckBoxPreference) prefSet.findPreference(ROTATION_90_PREF);
    mRotation180Pref = (CheckBoxPreference) prefSet.findPreference(ROTATION_180_PREF);
    mRotation270Pref = (CheckBoxPreference) prefSet.findPreference(ROTATION_270_PREF);
    int allowAllRotations = getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
    int mode = Settings.System.getInt(getContentResolver(), Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
    if (mode < 0) {
        // defaults
        mode = allowAllRotations == 1 ? // All angles
        (ROTATION_0_MODE | ROTATION_90_MODE | ROTATION_180_MODE | ROTATION_270_MODE) : // All except 180
        (ROTATION_0_MODE | ROTATION_90_MODE | ROTATION_270_MODE);
    }
    mRotation0Pref.setChecked((mode & ROTATION_0_MODE) != 0);
    mRotation90Pref.setChecked((mode & ROTATION_90_MODE) != 0);
    mRotation180Pref.setChecked((mode & ROTATION_180_MODE) != 0);
    mRotation270Pref.setChecked((mode & ROTATION_270_MODE) != 0);
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.display_rotation);
    PreferenceScreen prefSet = getPreferenceScreen();
    mAccelerometer = (CheckBoxPreference) findPreference(KEY_ACCELEROMETER);
    mAccelerometer.setPersistent(false);
    mLockScreenRotationPref = (CheckBoxPreference) prefSet.findPreference(LOCKSCREEN_ROTATION);
    mRotation0Pref = (CheckBoxPreference) prefSet.findPreference(ROTATION_0_PREF);
    mRotation90Pref = (CheckBoxPreference) prefSet.findPreference(ROTATION_90_PREF);
    mRotation180Pref = (CheckBoxPreference) prefSet.findPreference(ROTATION_180_PREF);
    mRotation270Pref = (CheckBoxPreference) prefSet.findPreference(ROTATION_270_PREF);
    int allowAllRotations = getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
    int mode = Settings.System.getInt(getContentResolver(), Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
    boolean configEnableLockRotation = getResources().getBoolean(com.android.internal.R.bool.config_enableLockScreenRotation);
    Boolean lockScreenRotationEnabled = Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_ROTATION, configEnableLockRotation ? 1 : 0) != 0;
    if (mode < 0) {
        // defaults
        mode = allowAllRotations == 1 ? // All angles
        (ROTATION_0_MODE | ROTATION_90_MODE | ROTATION_180_MODE | ROTATION_270_MODE) : // All except 180
        (ROTATION_0_MODE | ROTATION_90_MODE | ROTATION_270_MODE);
    }
    mRotation0Pref.setChecked((mode & ROTATION_0_MODE) != 0);
    mRotation90Pref.setChecked((mode & ROTATION_90_MODE) != 0);
    mRotation180Pref.setChecked((mode & ROTATION_180_MODE) != 0);
    mRotation270Pref.setChecked((mode & ROTATION_270_MODE) != 0);
    mLockScreenRotationPref.setChecked(lockScreenRotationEnabled);
}
#end_block

#method_before
private void updateDisplayRotationPreferenceDescription() {
    if (mDisplayRotationPreference == null) {
        return;
    }
    PreferenceScreen preference = mDisplayRotationPreference;
    StringBuilder summary = new StringBuilder();
    Boolean rotationEnabled = Settings.System.getInt(getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 0) != 0;
    Boolean lockScreenRotationEnabled = Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_ROTATION, 0) != 0;
    int allowAllRotations = getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
    int mode = Settings.System.getInt(getContentResolver(), Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
    if (mode < 0) {
        // defaults
        mode = allowAllRotations == 1 ? (DisplayRotation.ROTATION_0_MODE | DisplayRotation.ROTATION_90_MODE | DisplayRotation.ROTATION_180_MODE | // All angles
        DisplayRotation.ROTATION_270_MODE) : (DisplayRotation.ROTATION_0_MODE | DisplayRotation.ROTATION_90_MODE | // All except 180
        DisplayRotation.ROTATION_270_MODE);
    }
    if (mLockScreenRotation != null) {
        if (!getResources().getBoolean(com.android.internal.R.bool.config_enableLockScreenRotation)) {
            getPreferenceScreen().removePreference(mLockScreenRotation);
        } else {
            mLockScreenRotation.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_ROTATION, 0) != 1);
        }
    }
    if (!rotationEnabled) {
        summary.append(getString(R.string.display_rotation_disabled));
    } else {
        ArrayList<String> rotationList = new ArrayList<String>();
        String delim = "";
        if ((mode & DisplayRotation.ROTATION_0_MODE) != 0) {
            rotationList.add(ROTATION_ANGLE_0);
        }
        if ((mode & DisplayRotation.ROTATION_90_MODE) != 0) {
            rotationList.add(ROTATION_ANGLE_90);
        }
        if ((mode & DisplayRotation.ROTATION_180_MODE) != 0) {
            rotationList.add(ROTATION_ANGLE_180);
        }
        if ((mode & DisplayRotation.ROTATION_270_MODE) != 0) {
            rotationList.add(ROTATION_ANGLE_270);
        }
        if (lockScreenRotationEnabled) {
            rotationList.add(LOCKSCREEN_ROTATION_MODE);
        }
        for (int i = 0; i < rotationList.size(); i++) {
            summary.append(delim).append(rotationList.get(i));
            if ((rotationList.size() - i) > 2) {
                delim = ", ";
            } else {
                delim = " & ";
            }
        }
        summary.append(" " + getString(R.string.display_rotation_unit));
    }
    preference.setSummary(summary);
}
#method_after
private void updateDisplayRotationPreferenceDescription() {
    if (mDisplayRotationPreference == null) {
        return;
    }
    PreferenceScreen preference = mDisplayRotationPreference;
    StringBuilder summary = new StringBuilder();
    Boolean rotationEnabled = Settings.System.getInt(getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 0) != 0;
    boolean configEnableLockRotation = getResources().getBoolean(com.android.internal.R.bool.config_enableLockScreenRotation);
    Boolean lockScreenRotationEnabled = Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_ROTATION, configEnableLockRotation ? 1 : 0) != 0;
    int allowAllRotations = getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
    int mode = Settings.System.getInt(getContentResolver(), Settings.System.ACCELEROMETER_ROTATION_ANGLES, -1);
    if (mode < 0) {
        // defaults
        mode = allowAllRotations == 1 ? (DisplayRotation.ROTATION_0_MODE | DisplayRotation.ROTATION_90_MODE | DisplayRotation.ROTATION_180_MODE | // All angles
        DisplayRotation.ROTATION_270_MODE) : (DisplayRotation.ROTATION_0_MODE | DisplayRotation.ROTATION_90_MODE | // All except 180
        DisplayRotation.ROTATION_270_MODE);
    }
    if (mLockScreenRotation != null) {
        if (!configEnableLockRotation) {
            getPreferenceScreen().removePreference(mLockScreenRotation);
        } else {
            mLockScreenRotation.setChecked(lockScreenRotationEnabled);
        }
    }
    if (!rotationEnabled) {
        summary.append(getString(R.string.display_rotation_disabled));
    } else {
        ArrayList<String> rotationList = new ArrayList<String>();
        String delim = "";
        if ((mode & DisplayRotation.ROTATION_0_MODE) != 0) {
            rotationList.add(ROTATION_ANGLE_0);
        }
        if ((mode & DisplayRotation.ROTATION_90_MODE) != 0) {
            rotationList.add(ROTATION_ANGLE_90);
        }
        if ((mode & DisplayRotation.ROTATION_180_MODE) != 0) {
            rotationList.add(ROTATION_ANGLE_180);
        }
        if ((mode & DisplayRotation.ROTATION_270_MODE) != 0) {
            rotationList.add(ROTATION_ANGLE_270);
        }
        for (int i = 0; i < rotationList.size(); i++) {
            summary.append(delim).append(rotationList.get(i));
            if ((rotationList.size() - i) > 2) {
                delim = ", ";
            } else {
                delim = " & ";
            }
        }
        summary.append(" " + getString(R.string.display_rotation_unit));
    }
    preference.setSummary(summary);
}
#end_block

#method_before
private boolean shouldEnableScreenRotation() {
    Resources res = mContext.getResources();
    boolean enableLockScreenRotation = Settings.System.getInt(mContext.getContentResolver(), Settings.System.LOCKSCREEN_ROTATION, 0) != 0;
    boolean enableAccelerometerRotation = Settings.System.getInt(mContext.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 1) != 0;
    return SystemProperties.getBoolean("lockscreen.rot_override", false) || (enableLockScreenRotation && enableAccelerometerRotation);
}
#method_after
private boolean shouldEnableScreenRotation() {
    Resources res = mContext.getResources();
    final boolean configLockRotationValue = res.getBoolean(R.bool.config_enableLockScreenRotation);
    boolean enableLockScreenRotation = Settings.System.getInt(mContext.getContentResolver(), Settings.System.LOCKSCREEN_ROTATION, configLockRotationValue ? 1 : 0) != 0;
    boolean enableAccelerometerRotation = Settings.System.getInt(mContext.getContentResolver(), Settings.System.ACCELEROMETER_ROTATION, 0) != 0;
    return SystemProperties.getBoolean("lockscreen.rot_override", false) || (enableLockScreenRotation && enableAccelerometerRotation);
}
#end_block

#method_before
private void updateBatteryIcons() {
    if (mQS != null) {
        mQS.updateBattery();
    }
    if (mBattery != null && mCircleBattery != null) {
        mBattery.updateSettings();
        mCircleBattery.updateSettings();
    }
}
#method_after
private void updateBatteryIcons() {
    if (mQS != null) {
        mQS.updateBattery();
    }
    if (mBattery != null && mCircleBattery != null && mPercentBattery != null) {
        mBattery.updateSettings();
        mCircleBattery.updateSettings();
        mPercentBattery.updateSettings();
    }
}
#end_block

#method_before
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    mScreenWidth = (float) context.getResources().getDisplayMetrics().widthPixels;
    mMinBrightness = context.getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
    // populates mDisplayMetrics
    updateDisplaySize();
    loadDimens();
    mIconSize = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_icon_size);
    mStatusBarWindow = (StatusBarWindowView) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.mService = this;
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    mNotificationPanelIsFullScreenWidth = (mNotificationPanel.getLayoutParams().width == ViewGroup.LayoutParams.MATCH_PARENT);
    // make the header non-responsive to clicks
    mNotificationPanel.findViewById(R.id.header).setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            // e eats everything
            return true;
        }
    });
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
    }
    if (ENABLE_HEADS_UP) {
        mHeadsUpNotificationView = (HeadsUpNotificationView) View.inflate(context, R.layout.heads_up, null);
        mHeadsUpNotificationView.setVisibility(View.GONE);
        mHeadsUpNotificationView.setBar(this);
    }
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    updateShowSearchHoldoff();
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav) {
            mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
            mNavigationBarView.setDisabledFlags(mDisabled);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    if (mRecreating) {
    } else {
        addActiveDisplayView();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mSystemIconArea = (LinearLayout) mStatusBarView.findViewById(R.id.system_icon_area);
    mStatusIcons = (LinearLayout) mStatusBarView.findViewById(R.id.statusIcons);
    mStatusBarContents = (LinearLayout) mStatusBarView.findViewById(R.id.status_bar_contents);
    mCenterSpacer = (View) mStatusBarView.findViewById(R.id.center_spacer);
    mCenterClockLayout = (LinearLayout) mStatusBarView.findViewById(R.id.center_clock_layout);
    mClockCenter = (ClockCenter) mStatusBarView.findViewById(R.id.center_clock);
    mNotificationIcons = (IconMerger) mStatusBarView.findViewById(R.id.notificationIcons);
    mMoreIcon = mStatusBarView.findViewById(R.id.moreIcon);
    mNotificationIcons.setOverflowIndicator(mMoreIcon);
    mNotificationIcons.setClockCenter(mClockCenter);
    mNotificationIcons.setCenterSpacer(mCenterSpacer);
    mTickerView = mStatusBarView.findViewById(R.id.ticker);
    mPile = (NotificationRowLayout) mStatusBarWindow.findViewById(R.id.latestItems);
    mPile.setLayoutTransitionsEnabled(false);
    mPile.setLongPressListener(getNotificationLongClicker());
    // was: expanded.findViewById(R.id.notificationLinearLayout);
    mExpandedContents = mPile;
    mNotificationPanelHeader = mStatusBarWindow.findViewById(R.id.header);
    mStatusHeaderMachine = new StatusHeaderMachine(mContext);
    mStatusHeaderImage = (ImageView) mNotificationPanelHeader.findViewById(R.id.header_background_image);
    mHeaderOverlay = res.getDrawable(R.drawable.bg_custom_header_overlay);
    updateCustomHeaderStatus();
    mClearButton = mStatusBarWindow.findViewById(R.id.clear_all_button);
    mClearButton.setOnClickListener(mClearButtonListener);
    mClearButton.setAlpha(0f);
    mClearButton.setVisibility(View.INVISIBLE);
    mClearButton.setEnabled(false);
    mDateView = (DateView) mStatusBarWindow.findViewById(R.id.date);
    if (mDateView != null) {
        mDateView.setOnClickListener(mCalendarClickListener);
        mDateView.setEnabled(true);
    }
    mClockView = mNotificationPanelHeader.findViewById(R.id.clock);
    if (mClockView != null) {
        mClockView.setOnClickListener(mClockClickListener);
        mClockView.setEnabled(true);
    }
    mHasSettingsPanel = res.getBoolean(R.bool.config_hasSettingsPanel);
    mHasFlipSettings = res.getBoolean(R.bool.config_hasFlipSettingsPanel);
    // Notifications date time
    mDateTimeView = mNotificationPanelHeader.findViewById(R.id.datetime);
    mSettingsButton = (ImageView) mStatusBarWindow.findViewById(R.id.settings_button);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
        if (mHasSettingsPanel) {
            if (mStatusBarView.hasFullWidthNotifications()) {
                // the settings panel is hiding behind this button
                mSettingsButton.setImageResource(R.drawable.ic_notify_quicksettings);
                mSettingsButton.setVisibility(View.VISIBLE);
            } else {
                // there is a settings panel, but it's on the other side of the (large) screen
                final View buttonHolder = mStatusBarWindow.findViewById(R.id.settings_button_holder);
                if (buttonHolder != null) {
                    buttonHolder.setVisibility(View.GONE);
                }
            }
        } else {
            // no settings panel, go straight to settings
            mSettingsButton.setVisibility(View.VISIBLE);
            mSettingsButton.setImageResource(R.drawable.ic_notify_settings);
        }
    }
    if (mHasFlipSettings) {
        mNotificationButton = (ImageView) mStatusBarWindow.findViewById(R.id.notification_button);
        if (mNotificationButton != null) {
            mNotificationButton.setOnClickListener(mNotificationButtonListener);
        }
    }
    mScrollView = (ScrollView) mStatusBarWindow.findViewById(R.id.scroll);
    // less drawing during pulldowns
    mScrollView.setVerticalScrollBarEnabled(false);
    if (!mNotificationPanelIsFullScreenWidth) {
        mScrollView.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_NOTIFICATION_ICONS | View.STATUS_BAR_DISABLE_CLOCK);
    }
    mTicker = new MyTicker(context, mStatusBarView);
    TickerView tickerView = (TickerView) mStatusBarView.findViewById(R.id.tickerText);
    tickerView.mTicker = mTicker;
    mEdgeBorder = res.getDimensionPixelSize(R.dimen.status_bar_edge_ignore);
    // set the inital view visibility
    setAreThereNotifications();
    // Other icons
    // will post a notification
    mLocationController = new LocationController(mContext);
    mBatteryController = new BatteryController(mContext);
    mNetworkController = new NetworkController(mContext);
    mBluetoothController = new BluetoothController(mContext);
    mRotationLockController = new RotationLockController(mContext);
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCluster(signalCluster);
    signalCluster.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mEmergencyCallLabel = (TextView) mStatusBarWindow.findViewById(R.id.emergency_calls_only);
        if (mEmergencyCallLabel != null) {
            mNetworkController.addEmergencyLabelView(mEmergencyCallLabel);
            mEmergencyCallLabel.setOnClickListener(new View.OnClickListener() {

                public void onClick(View v) {
                }
            });
            mEmergencyCallLabel.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {

                @Override
                public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
                    updateCarrierLabelVisibility(false);
                }
            });
        }
    }
    mCarrierLabel = (TextView) mStatusBarWindow.findViewById(R.id.carrier_label);
    mShowCarrierInPanel = (mCarrierLabel != null);
    if (DEBUG)
        Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" + mShowCarrierInPanel);
    if (mShowCarrierInPanel) {
        mCarrierLabel.setVisibility(mCarrierLabelVisible ? View.VISIBLE : View.INVISIBLE);
        // for other devices, we show whatever network is connected
        if (mNetworkController.hasMobileDataFeature()) {
            mNetworkController.addMobileLabelView(mCarrierLabel);
        } else {
            mNetworkController.addCombinedLabelView(mCarrierLabel);
        }
        // set up the dynamic hide/show of the label
        mPile.setOnSizeChangedListener(new OnSizeChangedListener() {

            @Override
            public void onSizeChanged(View view, int w, int h, int oldw, int oldh) {
                updateCarrierLabelVisibility(false);
            }
        });
    }
    // Quick Settings (where available, some restrictions apply)
    if (mHasSettingsPanel) {
        // first, figure out where quick settings should be inflated
        final View settings_stub;
        if (mHasFlipSettings) {
            // a version of quick settings that flips around behind the notifications
            settings_stub = mStatusBarWindow.findViewById(R.id.flip_settings_stub);
            if (settings_stub != null) {
                mFlipSettingsView = ((ViewStub) settings_stub).inflate();
                mFlipSettingsView.setVisibility(View.GONE);
                mFlipSettingsView.setVerticalScrollBarEnabled(false);
                mEditModeButton = (ImageView) mStatusBarWindow.findViewById(R.id.edit_mode_button);
                mEditModeButton.setVisibility(View.INVISIBLE);
            }
        } else {
            // full quick settings panel
            settings_stub = mStatusBarWindow.findViewById(R.id.quick_settings_stub);
            if (settings_stub != null) {
                mSettingsPanel = (SettingsPanelView) ((ViewStub) settings_stub).inflate();
            } else {
                mSettingsPanel = (SettingsPanelView) mStatusBarWindow.findViewById(R.id.settings_panel);
            }
            if (mSettingsPanel != null) {
                if (!ActivityManager.isHighEndGfx()) {
                    mSettingsPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
                }
                mEditModeButton = (ImageView) mSettingsPanel.findViewById(R.id.edit_mode_button);
            }
        }
        // wherever you find it, Quick Settings needs a container to survive
        mSettingsContainer = (QuickSettingsContainerView) mStatusBarWindow.findViewById(R.id.quick_settings_container);
        if (mSettingsContainer != null) {
            mQS = new QuickSettings(mContext, mSettingsContainer);
            if (!mNotificationPanelIsFullScreenWidth) {
                mSettingsContainer.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_SYSTEM_INFO);
            }
            if (mSettingsPanel != null) {
                mSettingsPanel.setQuickSettings(mQS);
            }
            mQS.setService(this);
            mQS.setBar(mStatusBarView);
            mQS.setup(mNetworkController, mBluetoothController, mBatteryController, mLocationController, mRotationLockController);
            if (mEditModeButton != null) {
                mEditModeButton.setOnClickListener(mEditModeButtonListener);
                mEditModeButton.setOnLongClickListener(mEditModeLongButtonListener);
                mEditModeButton.setEnabled(true);
            }
            // set edit mode changed listener
            mSettingsContainer.setOnEditModeChangedListener(new QuickSettingsContainerView.EditModeChangedListener() {

                @Override
                public void onEditModeChanged(final boolean enabled) {
                    mEditModeButton.setImageResource(enabled ? R.drawable.ic_notify_edit_save : R.drawable.ic_notify_edit_normal);
                }
            });
        } else {
            // fly away, be free
            mQS = null;
        }
    }
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(ACTION_DEMO);
    context.registerReceiver(mBroadcastReceiver, filter);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    mVelocityTracker = VelocityTracker.obtain();
    mBattery = (BatteryMeterView) mStatusBarView.findViewById(R.id.battery);
    mCircleBattery = (BatteryCircleMeterView) mStatusBarView.findViewById(R.id.circle_battery);
    return mStatusBarView;
}
#method_after
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    mScreenWidth = (float) context.getResources().getDisplayMetrics().widthPixels;
    mMinBrightness = context.getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
    // populates mDisplayMetrics
    updateDisplaySize();
    loadDimens();
    mIconSize = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_icon_size);
    mStatusBarWindow = (StatusBarWindowView) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.mService = this;
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    mNotificationPanelIsFullScreenWidth = (mNotificationPanel.getLayoutParams().width == ViewGroup.LayoutParams.MATCH_PARENT);
    // make the header non-responsive to clicks
    mNotificationPanel.findViewById(R.id.header).setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            // e eats everything
            return true;
        }
    });
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
    }
    if (ENABLE_HEADS_UP) {
        mHeadsUpNotificationView = (HeadsUpNotificationView) View.inflate(context, R.layout.heads_up, null);
        mHeadsUpNotificationView.setVisibility(View.GONE);
        mHeadsUpNotificationView.setBar(this);
    }
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    updateShowSearchHoldoff();
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav) {
            mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
            mNavigationBarView.setDisabledFlags(mDisabled);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    if (mRecreating) {
    } else {
        addActiveDisplayView();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mSystemIconArea = (LinearLayout) mStatusBarView.findViewById(R.id.system_icon_area);
    mStatusIcons = (LinearLayout) mStatusBarView.findViewById(R.id.statusIcons);
    mStatusBarContents = (LinearLayout) mStatusBarView.findViewById(R.id.status_bar_contents);
    mCenterSpacer = (View) mStatusBarView.findViewById(R.id.center_spacer);
    mCenterClockLayout = (LinearLayout) mStatusBarView.findViewById(R.id.center_clock_layout);
    mClock = (Clock) mStatusBarView.findViewById(R.id.clock);
    mClockCenter = (ClockCenter) mStatusBarView.findViewById(R.id.center_clock);
    mNotificationIcons = (IconMerger) mStatusBarView.findViewById(R.id.notificationIcons);
    mMoreIcon = mStatusBarView.findViewById(R.id.moreIcon);
    mNotificationIcons.setOverflowIndicator(mMoreIcon);
    mNotificationIcons.setClockCenter(mClockCenter);
    mNotificationIcons.setCenterSpacer(mCenterSpacer);
    mTickerView = mStatusBarView.findViewById(R.id.ticker);
    mPile = (NotificationRowLayout) mStatusBarWindow.findViewById(R.id.latestItems);
    mPile.setLayoutTransitionsEnabled(false);
    mPile.setLongPressListener(getNotificationLongClicker());
    // was: expanded.findViewById(R.id.notificationLinearLayout);
    mExpandedContents = mPile;
    mNotificationPanelHeader = mStatusBarWindow.findViewById(R.id.header);
    mStatusHeaderMachine = new StatusHeaderMachine(mContext);
    mStatusHeaderImage = (ImageView) mNotificationPanelHeader.findViewById(R.id.header_background_image);
    mHeaderOverlay = res.getDrawable(R.drawable.bg_custom_header_overlay);
    updateCustomHeaderStatus();
    mClearButton = mStatusBarWindow.findViewById(R.id.clear_all_button);
    mClearButton.setOnClickListener(mClearButtonListener);
    mClearButton.setAlpha(0f);
    mClearButton.setVisibility(View.INVISIBLE);
    mClearButton.setEnabled(false);
    mDateView = (DateView) mStatusBarWindow.findViewById(R.id.date);
    if (mDateView != null) {
        mDateView.setOnClickListener(mCalendarClickListener);
        mDateView.setEnabled(true);
    }
    mClockView = mNotificationPanelHeader.findViewById(R.id.clock);
    if (mClockView != null) {
        mClockView.setOnClickListener(mClockClickListener);
        mClockView.setEnabled(true);
    }
    mHasSettingsPanel = res.getBoolean(R.bool.config_hasSettingsPanel);
    mHasFlipSettings = res.getBoolean(R.bool.config_hasFlipSettingsPanel);
    // Notifications date time
    mDateTimeView = mNotificationPanelHeader.findViewById(R.id.datetime);
    mSettingsButton = (ImageView) mStatusBarWindow.findViewById(R.id.settings_button);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
        if (mHasSettingsPanel) {
            if (mStatusBarView.hasFullWidthNotifications()) {
                // the settings panel is hiding behind this button
                mSettingsButton.setImageResource(R.drawable.ic_notify_quicksettings);
                mSettingsButton.setVisibility(View.VISIBLE);
            } else {
                // there is a settings panel, but it's on the other side of the (large) screen
                final View buttonHolder = mStatusBarWindow.findViewById(R.id.settings_button_holder);
                if (buttonHolder != null) {
                    buttonHolder.setVisibility(View.GONE);
                }
            }
        } else {
            // no settings panel, go straight to settings
            mSettingsButton.setVisibility(View.VISIBLE);
            mSettingsButton.setImageResource(R.drawable.ic_notify_settings);
        }
    }
    if (mHasFlipSettings) {
        mNotificationButton = (ImageView) mStatusBarWindow.findViewById(R.id.notification_button);
        if (mNotificationButton != null) {
            mNotificationButton.setOnClickListener(mNotificationButtonListener);
        }
    }
    mScrollView = (ScrollView) mStatusBarWindow.findViewById(R.id.scroll);
    // less drawing during pulldowns
    mScrollView.setVerticalScrollBarEnabled(false);
    if (!mNotificationPanelIsFullScreenWidth) {
        mScrollView.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_NOTIFICATION_ICONS | View.STATUS_BAR_DISABLE_CLOCK);
    }
    mTicker = new MyTicker(context, mStatusBarView);
    TickerView tickerView = (TickerView) mStatusBarView.findViewById(R.id.tickerText);
    tickerView.mTicker = mTicker;
    mEdgeBorder = res.getDimensionPixelSize(R.dimen.status_bar_edge_ignore);
    // set the inital view visibility
    setAreThereNotifications();
    // Other icons
    // will post a notification
    mLocationController = new LocationController(mContext);
    mBatteryController = new BatteryController(mContext);
    mNetworkController = new NetworkController(mContext);
    mBluetoothController = new BluetoothController(mContext);
    mRotationLockController = new RotationLockController(mContext);
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCluster(signalCluster);
    signalCluster.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mEmergencyCallLabel = (TextView) mStatusBarWindow.findViewById(R.id.emergency_calls_only);
        if (mEmergencyCallLabel != null) {
            mNetworkController.addEmergencyLabelView(mEmergencyCallLabel);
            mEmergencyCallLabel.setOnClickListener(new View.OnClickListener() {

                public void onClick(View v) {
                }
            });
            mEmergencyCallLabel.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {

                @Override
                public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
                    updateCarrierLabelVisibility(false);
                }
            });
        }
    }
    mCarrierLabel = (TextView) mStatusBarWindow.findViewById(R.id.carrier_label);
    mShowCarrierInPanel = (mCarrierLabel != null);
    if (DEBUG)
        Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" + mShowCarrierInPanel);
    if (mShowCarrierInPanel) {
        mCarrierLabel.setVisibility(mCarrierLabelVisible ? View.VISIBLE : View.INVISIBLE);
        // for other devices, we show whatever network is connected
        if (mNetworkController.hasMobileDataFeature()) {
            mNetworkController.addMobileLabelView(mCarrierLabel);
        } else {
            mNetworkController.addCombinedLabelView(mCarrierLabel);
        }
        // set up the dynamic hide/show of the label
        mPile.setOnSizeChangedListener(new OnSizeChangedListener() {

            @Override
            public void onSizeChanged(View view, int w, int h, int oldw, int oldh) {
                updateCarrierLabelVisibility(false);
            }
        });
    }
    // Quick Settings (where available, some restrictions apply)
    if (mHasSettingsPanel) {
        // first, figure out where quick settings should be inflated
        final View settings_stub;
        if (mHasFlipSettings) {
            // a version of quick settings that flips around behind the notifications
            settings_stub = mStatusBarWindow.findViewById(R.id.flip_settings_stub);
            if (settings_stub != null) {
                mFlipSettingsView = ((ViewStub) settings_stub).inflate();
                mFlipSettingsView.setVisibility(View.GONE);
                mFlipSettingsView.setVerticalScrollBarEnabled(false);
                mEditModeButton = (ImageView) mStatusBarWindow.findViewById(R.id.edit_mode_button);
                mEditModeButton.setVisibility(View.INVISIBLE);
            }
        } else {
            // full quick settings panel
            settings_stub = mStatusBarWindow.findViewById(R.id.quick_settings_stub);
            if (settings_stub != null) {
                mSettingsPanel = (SettingsPanelView) ((ViewStub) settings_stub).inflate();
            } else {
                mSettingsPanel = (SettingsPanelView) mStatusBarWindow.findViewById(R.id.settings_panel);
            }
            if (mSettingsPanel != null) {
                if (!ActivityManager.isHighEndGfx()) {
                    mSettingsPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
                }
                mEditModeButton = (ImageView) mSettingsPanel.findViewById(R.id.edit_mode_button);
            }
        }
        // wherever you find it, Quick Settings needs a container to survive
        mSettingsContainer = (QuickSettingsContainerView) mStatusBarWindow.findViewById(R.id.quick_settings_container);
        if (mSettingsContainer != null) {
            mQS = new QuickSettings(mContext, mSettingsContainer);
            if (!mNotificationPanelIsFullScreenWidth) {
                mSettingsContainer.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_SYSTEM_INFO);
            }
            if (mSettingsPanel != null) {
                mSettingsPanel.setQuickSettings(mQS);
            }
            mQS.setService(this);
            mQS.setBar(mStatusBarView);
            mQS.setup(mNetworkController, mBluetoothController, mBatteryController, mLocationController, mRotationLockController);
            if (mEditModeButton != null) {
                mEditModeButton.setOnClickListener(mEditModeButtonListener);
                mEditModeButton.setOnLongClickListener(mEditModeLongButtonListener);
                mEditModeButton.setEnabled(true);
            }
            // set edit mode changed listener
            mSettingsContainer.setOnEditModeChangedListener(new QuickSettingsContainerView.EditModeChangedListener() {

                @Override
                public void onEditModeChanged(final boolean enabled) {
                    mEditModeButton.setImageResource(enabled ? R.drawable.ic_notify_edit_save : R.drawable.ic_notify_edit_normal);
                }
            });
        } else {
            // fly away, be free
            mQS = null;
        }
    }
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(ACTION_DEMO);
    context.registerReceiver(mBroadcastReceiver, filter);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    mVelocityTracker = VelocityTracker.obtain();
    mBattery = (BatteryMeterView) mStatusBarView.findViewById(R.id.battery);
    mCircleBattery = (BatteryCircleMeterView) mStatusBarView.findViewById(R.id.circle_battery);
    mPercentBattery = (BatteryPercentMeterView) mStatusBarView.findViewById(R.id.percent_battery);
    return mStatusBarView;
}
#end_block

#method_before
public void showClock(boolean show) {
    if (mStatusBarView == null)
        return;
    ContentResolver resolver = mContext.getContentResolver();
    View clock = mStatusBarView.findViewById(R.id.clock);
    View cclock = mStatusBarView.findViewById(R.id.center_clock);
    boolean showClock = (Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_CLOCK, 1, UserHandle.USER_CURRENT) == 1);
    int clockLocation = Settings.System.getIntForUser(resolver, Settings.System.STATUSBAR_CLOCK_STYLE, 0, UserHandle.USER_CURRENT);
    if (clockLocation == 0 && clock != null) {
        clock.setVisibility(show ? (showClock ? View.VISIBLE : View.GONE) : View.GONE);
    }
    if (clockLocation == 1 && cclock != null) {
        cclock.setVisibility(show ? (showClock ? View.VISIBLE : View.GONE) : View.GONE);
    }
}
#method_after
public void showClock(boolean show) {
    if (mStatusBarView == null)
        return;
    if (mClock != null) {
        mClock.updateVisibilityFromStatusBar(show);
    }
    if (mClockCenter != null) {
        mClockCenter.updateVisibilityFromStatusBar(show);
    }
}
#end_block

#method_before
private void brightnessControl(MotionEvent event) {
    if (mBrightnessControl) {
        final int action = event.getAction();
        final int x = (int) event.getRawX();
        final int y = (int) event.getRawY();
        if (action == MotionEvent.ACTION_DOWN) {
            mLinger = 0;
            mInitialTouchX = x;
            mInitialTouchY = y;
            mHandler.removeCallbacks(mLongPressBrightnessChange);
            if (y < mNotificationHeaderHeight) {
                mHandler.postDelayed(mLongPressBrightnessChange, BRIGHTNESS_CONTROL_LONG_PRESS_TIMEOUT);
            }
        } else if (action == MotionEvent.ACTION_MOVE) {
            if (y < mNotificationHeaderHeight) {
                mVelocityTracker.computeCurrentVelocity(1000);
                float yVel = mVelocityTracker.getYVelocity();
                yVel = Math.abs(yVel);
                if (yVel < 50.0f) {
                    if (mLinger > BRIGHTNESS_CONTROL_LINGER_THRESHOLD) {
                        adjustBrightness(x);
                    } else {
                        mLinger++;
                    }
                }
                int touchSlop = ViewConfiguration.get(mContext).getScaledTouchSlop();
                if (Math.abs(x - mInitialTouchX) > touchSlop || Math.abs(y - mInitialTouchY) > touchSlop) {
                    mHandler.removeCallbacks(mLongPressBrightnessChange);
                }
            } else {
                mHandler.removeCallbacks(mLongPressBrightnessChange);
            }
        } else if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
            mHandler.removeCallbacks(mLongPressBrightnessChange);
            mLinger = 0;
        }
    }
}
#method_after
private void brightnessControl(MotionEvent event) {
    final int action = event.getAction();
    final int x = (int) event.getRawX();
    final int y = (int) event.getRawY();
    if (action == MotionEvent.ACTION_DOWN) {
        if (y < mNotificationHeaderHeight) {
            mLinger = 0;
            mInitialTouchX = x;
            mInitialTouchY = y;
            mJustPeeked = true;
            mHandler.removeCallbacks(mLongPressBrightnessChange);
            mHandler.postDelayed(mLongPressBrightnessChange, BRIGHTNESS_CONTROL_LONG_PRESS_TIMEOUT);
        }
    } else if (action == MotionEvent.ACTION_MOVE) {
        if (y < mNotificationHeaderHeight && mJustPeeked) {
            if (mLinger > BRIGHTNESS_CONTROL_LINGER_THRESHOLD) {
                adjustBrightness(x);
            } else {
                final int xDiff = Math.abs(x - mInitialTouchX);
                final int yDiff = Math.abs(y - mInitialTouchY);
                final int touchSlop = ViewConfiguration.get(mContext).getScaledTouchSlop();
                if (xDiff > yDiff) {
                    mLinger++;
                }
                if (xDiff > touchSlop || yDiff > touchSlop) {
                    mHandler.removeCallbacks(mLongPressBrightnessChange);
                }
            }
        } else {
            if (y > mPeekHeight) {
                mJustPeeked = false;
            }
            mHandler.removeCallbacks(mLongPressBrightnessChange);
        }
    } else if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
        mHandler.removeCallbacks(mLongPressBrightnessChange);
    }
}
#end_block

#method_before
public boolean interceptTouchEvent(MotionEvent event) {
    if (DEBUG_GESTURES) {
        if (event.getActionMasked() != MotionEvent.ACTION_MOVE) {
            EventLog.writeEvent(EventLogTags.SYSUI_STATUSBAR_TOUCH, event.getActionMasked(), (int) event.getX(), (int) event.getY(), mDisabled);
        }
    }
    if (SPEW) {
        Log.d(TAG, "Touch: rawY=" + event.getRawY() + " event=" + event + " mDisabled=" + mDisabled + " mTracking=" + mTracking);
    } else if (CHATTY) {
        if (event.getAction() != MotionEvent.ACTION_MOVE) {
            Log.d(TAG, String.format("panel: %s at (%f, %f) mDisabled=0x%08x", MotionEvent.actionToString(event.getAction()), event.getRawX(), event.getRawY(), mDisabled));
        }
    }
    if (DEBUG_GESTURES) {
        mGestureRec.add(event);
    }
    if (mStatusBarWindowState == WINDOW_STATE_SHOWING) {
        final boolean upOrCancel = event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL;
        if (upOrCancel && !mExpandedVisible) {
            setInteracting(StatusBarManager.WINDOW_STATUS_BAR, false);
        } else {
            setInteracting(StatusBarManager.WINDOW_STATUS_BAR, true);
        }
    }
    brightnessControl(event);
    return false;
}
#method_after
public boolean interceptTouchEvent(MotionEvent event) {
    if (DEBUG_GESTURES) {
        if (event.getActionMasked() != MotionEvent.ACTION_MOVE) {
            EventLog.writeEvent(EventLogTags.SYSUI_STATUSBAR_TOUCH, event.getActionMasked(), (int) event.getX(), (int) event.getY(), mDisabled);
        }
    }
    if (SPEW) {
        Log.d(TAG, "Touch: rawY=" + event.getRawY() + " event=" + event + " mDisabled=" + mDisabled + " mTracking=" + mTracking);
    } else if (CHATTY) {
        if (event.getAction() != MotionEvent.ACTION_MOVE) {
            Log.d(TAG, String.format("panel: %s at (%f, %f) mDisabled=0x%08x", MotionEvent.actionToString(event.getAction()), event.getRawX(), event.getRawY(), mDisabled));
        }
    }
    if (DEBUG_GESTURES) {
        mGestureRec.add(event);
    }
    if (mBrightnessControl) {
        brightnessControl(event);
        if ((mDisabled & StatusBarManager.DISABLE_EXPAND) != 0) {
            return true;
        }
    }
    if (mStatusBarWindowState == WINDOW_STATE_SHOWING) {
        final boolean upOrCancel = event.getAction() == MotionEvent.ACTION_UP || event.getAction() == MotionEvent.ACTION_CANCEL;
        if (upOrCancel && !mExpandedVisible) {
            setInteracting(StatusBarManager.WINDOW_STATUS_BAR, false);
        } else {
            setInteracting(StatusBarManager.WINDOW_STATUS_BAR, true);
        }
    }
    return false;
}
#end_block

#method_before
@Override
public void tickerDone() {
    mStatusBarContents.setVisibility(View.VISIBLE);
    mCenterClockLayout.setVisibility(View.VISIBLE);
    mTickerView.setVisibility(View.GONE);
    mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.push_down_in, null));
    mTickerView.startAnimation(loadAnim(com.android.internal.R.anim.push_down_out, mTickingDoneListener));
    mCenterClockLayout.startAnimation(loadAnim(com.android.internal.R.anim.push_down_in, null));
}
#method_after
@Override
public void tickerDone() {
    mStatusBarContents.setVisibility(View.VISIBLE);
    mCenterClockLayout.setVisibility(View.VISIBLE);
    mTickerView.setVisibility(View.GONE);
    mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.push_down_in, null));
    mCenterClockLayout.startAnimation(loadAnim(com.android.internal.R.anim.push_down_in, null));
    mTickerView.startAnimation(loadAnim(com.android.internal.R.anim.push_down_out, mTickingDoneListener));
}
#end_block

#method_before
public void tickerHalting() {
    if (mStatusBarContents.getVisibility() != View.VISIBLE) {
        mStatusBarContents.setVisibility(View.VISIBLE);
        mCenterClockLayout.setVisibility(View.VISIBLE);
        mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.fade_in, null));
        mCenterClockLayout.startAnimation(loadAnim(com.android.internal.R.anim.fade_in, null));
    }
    mTickerView.setVisibility(View.GONE);
// we do not animate the ticker away at this point, just get rid of it (b/6992707)
}
#method_after
public void tickerHalting() {
    if (mStatusBarContents.getVisibility() != View.VISIBLE) {
        mStatusBarContents.setVisibility(View.VISIBLE);
        mStatusBarContents.startAnimation(loadAnim(com.android.internal.R.anim.fade_in, null));
    }
    if (mCenterClockLayout.getVisibility() != View.VISIBLE) {
        mCenterClockLayout.setVisibility(View.VISIBLE);
        mCenterClockLayout.startAnimation(loadAnim(com.android.internal.R.anim.fade_in, null));
    }
    mTickerView.setVisibility(View.GONE);
// we do not animate the ticker away at this point, just get rid of it (b/6992707)
}
#end_block

#method_before
protected void loadDimens() {
    final Resources res = mContext.getResources();
    mNaturalBarHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int newIconSize = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_icon_size);
    int newIconHPadding = res.getDimensionPixelSize(R.dimen.status_bar_icon_padding);
    if (newIconHPadding != mIconHPadding || newIconSize != mIconSize) {
        // Log.d(TAG, "size=" + newIconSize + " padding=" + newIconHPadding);
        mIconHPadding = newIconHPadding;
        mIconSize = newIconSize;
    // reloadAllNotificationIcons(); // reload the tray
    }
    mEdgeBorder = res.getDimensionPixelSize(R.dimen.status_bar_edge_ignore);
    mSelfExpandVelocityPx = res.getDimension(R.dimen.self_expand_velocity);
    mSelfCollapseVelocityPx = res.getDimension(R.dimen.self_collapse_velocity);
    mFlingExpandMinVelocityPx = res.getDimension(R.dimen.fling_expand_min_velocity);
    mFlingCollapseMinVelocityPx = res.getDimension(R.dimen.fling_collapse_min_velocity);
    mCollapseMinDisplayFraction = res.getFraction(R.dimen.collapse_min_display_fraction, 1, 1);
    mExpandMinDisplayFraction = res.getFraction(R.dimen.expand_min_display_fraction, 1, 1);
    mExpandAccelPx = res.getDimension(R.dimen.expand_accel);
    mCollapseAccelPx = res.getDimension(R.dimen.collapse_accel);
    mFlingGestureMaxXVelocityPx = res.getDimension(R.dimen.fling_gesture_max_x_velocity);
    mFlingGestureMaxOutputVelocityPx = res.getDimension(R.dimen.fling_gesture_max_output_velocity);
    mNotificationPanelMarginBottomPx = (int) res.getDimension(R.dimen.notification_panel_margin_bottom);
    mNotificationPanelMarginPx = (int) res.getDimension(R.dimen.notification_panel_margin_left);
    mNotificationPanelGravity = res.getInteger(R.integer.notification_panel_layout_gravity);
    if (mNotificationPanelGravity <= 0) {
        mNotificationPanelGravity = Gravity.START | Gravity.TOP;
    }
    mSettingsPanelGravity = res.getInteger(R.integer.settings_panel_layout_gravity);
    Log.d(TAG, "mSettingsPanelGravity = " + mSettingsPanelGravity);
    if (mSettingsPanelGravity <= 0) {
        mSettingsPanelGravity = Gravity.END | Gravity.TOP;
    }
    mCarrierLabelHeight = res.getDimensionPixelSize(R.dimen.carrier_label_height);
    mNotificationHeaderHeight = res.getDimensionPixelSize(R.dimen.notification_panel_header_height);
    mNotificationPanelMinHeightFrac = res.getFraction(R.dimen.notification_panel_min_height_frac, 1, 1);
    if (mNotificationPanelMinHeightFrac < 0f || mNotificationPanelMinHeightFrac > 1f) {
        mNotificationPanelMinHeightFrac = 0f;
    }
    mHeadsUpNotificationDecay = res.getInteger(R.integer.heads_up_notification_decay);
    mRowHeight = res.getDimensionPixelSize(R.dimen.notification_row_min_height);
    if (false)
        Log.v(TAG, "updateResources");
}
#method_after
protected void loadDimens() {
    final Resources res = mContext.getResources();
    mNaturalBarHeight = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
    int newIconSize = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_icon_size);
    int newIconHPadding = res.getDimensionPixelSize(R.dimen.status_bar_icon_padding);
    if (newIconHPadding != mIconHPadding || newIconSize != mIconSize) {
        // Log.d(TAG, "size=" + newIconSize + " padding=" + newIconHPadding);
        mIconHPadding = newIconHPadding;
        mIconSize = newIconSize;
    // reloadAllNotificationIcons(); // reload the tray
    }
    mEdgeBorder = res.getDimensionPixelSize(R.dimen.status_bar_edge_ignore);
    mSelfExpandVelocityPx = res.getDimension(R.dimen.self_expand_velocity);
    mSelfCollapseVelocityPx = res.getDimension(R.dimen.self_collapse_velocity);
    mFlingExpandMinVelocityPx = res.getDimension(R.dimen.fling_expand_min_velocity);
    mFlingCollapseMinVelocityPx = res.getDimension(R.dimen.fling_collapse_min_velocity);
    mCollapseMinDisplayFraction = res.getFraction(R.dimen.collapse_min_display_fraction, 1, 1);
    mExpandMinDisplayFraction = res.getFraction(R.dimen.expand_min_display_fraction, 1, 1);
    mExpandAccelPx = res.getDimension(R.dimen.expand_accel);
    mCollapseAccelPx = res.getDimension(R.dimen.collapse_accel);
    mFlingGestureMaxXVelocityPx = res.getDimension(R.dimen.fling_gesture_max_x_velocity);
    mFlingGestureMaxOutputVelocityPx = res.getDimension(R.dimen.fling_gesture_max_output_velocity);
    mNotificationPanelMarginBottomPx = (int) res.getDimension(R.dimen.notification_panel_margin_bottom);
    mNotificationPanelMarginPx = (int) res.getDimension(R.dimen.notification_panel_margin_left);
    mNotificationPanelGravity = res.getInteger(R.integer.notification_panel_layout_gravity);
    if (mNotificationPanelGravity <= 0) {
        mNotificationPanelGravity = Gravity.START | Gravity.TOP;
    }
    mSettingsPanelGravity = res.getInteger(R.integer.settings_panel_layout_gravity);
    Log.d(TAG, "mSettingsPanelGravity = " + mSettingsPanelGravity);
    if (mSettingsPanelGravity <= 0) {
        mSettingsPanelGravity = Gravity.END | Gravity.TOP;
    }
    mCarrierLabelHeight = res.getDimensionPixelSize(R.dimen.carrier_label_height);
    mNotificationHeaderHeight = res.getDimensionPixelSize(R.dimen.notification_panel_header_height);
    mPeekHeight = res.getDimensionPixelSize(R.dimen.peek_height);
    mNotificationPanelMinHeightFrac = res.getFraction(R.dimen.notification_panel_min_height_frac, 1, 1);
    if (mNotificationPanelMinHeightFrac < 0f || mNotificationPanelMinHeightFrac > 1f) {
        mNotificationPanelMinHeightFrac = 0f;
    }
    mHeadsUpNotificationDecay = res.getInteger(R.integer.heads_up_notification_decay);
    mRowHeight = res.getDimensionPixelSize(R.dimen.notification_row_min_height);
    if (false)
        Log.v(TAG, "updateResources");
}
#end_block

#method_before
private void addTiles(ViewGroup parent, boolean addMissing, boolean reset) {
    // If all the tiles were deleted, they are still loaded, but their visibility is changed
    if (reset) {
        parent.removeAllViews();
    }
    String tileContainer = Settings.System.getString(mContext.getContentResolver(), Settings.System.QUICK_SETTINGS_TILES);
    if (tileContainer == null)
        tileContainer = DEFAULT_TILES;
    Tile[] allTiles = Tile.values();
    String[] storedTiles = tileContainer.split(DELIMITER);
    List<String> allTilesArray = enumToStringArray(allTiles);
    List<String> storedTilesArray = Arrays.asList(storedTiles);
    for (String tile : addMissing ? allTilesArray : storedTilesArray) {
        boolean addTile = storedTilesArray.contains(tile);
        if (addMissing)
            addTile = !addTile;
        if (addTile) {
            if (Tile.USER.toString().equals(tile.toString())) {
                // User
                final QuickSettingsBasicUserTile userTile = new QuickSettingsBasicUserTile(mContext);
                userTile.setTileId(Tile.USER);
                userTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        final UserManager um = UserManager.get(mContext);
                        if (um.getUsers(true).size() > 1) {
                            // Since keyguard and systemui were merged into the same process to save
                            // memory, they share the same Looper and graphics context.  As a result,
                            // there's no way to allow concurrent animation while keyguard inflates.
                            // The workaround is to add a slight delay to allow the animation to finish.
                            mHandler.postDelayed(new Runnable() {

                                public void run() {
                                    try {
                                        WindowManagerGlobal.getWindowManagerService().lockNow(null);
                                    } catch (RemoteException e) {
                                        Log.e(TAG, "Couldn't show user switcher", e);
                                    }
                                }
                            }, // TODO: ideally this would be tied to the collapse of the panel
                            400);
                        } else {
                            Intent intent = ContactsContract.QuickContact.composeQuickContactsIntent(mContext, v, ContactsContract.Profile.CONTENT_URI, ContactsContract.QuickContact.MODE_LARGE, null);
                            mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
                        }
                    }
                });
                userTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SYNC_SETTINGS);
                        return true;
                    }
                });
                mModel.addUserTile(userTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        UserState us = (UserState) state;
                        userTile.setText(state.label);
                        userTile.setImageDrawable(us.avatar);
                        view.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_user, state.label));
                    }
                });
                parent.addView(userTile);
                if (addMissing)
                    userTile.setVisibility(View.GONE);
            } else if (Tile.BRIGHTNESS.toString().equals(tile.toString())) {
                // brightness
                // Brightness
                final QuickSettingsBasicTile brightnessTile = new QuickSettingsBasicTile(mContext);
                brightnessTile.setTileId(Tile.BRIGHTNESS);
                brightnessTile.setImageResource(R.drawable.ic_qs_brightness_auto_off);
                brightnessTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        showBrightnessDialog();
                    }
                });
                brightnessTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        boolean automaticAvailable = mContext.getResources().getBoolean(com.android.internal.R.bool.config_automatic_brightness_available);
                        // If we have automatic brightness available, toggle it
                        if (automaticAvailable) {
                            int automatic;
                            try {
                                automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, UserHandle.USER_CURRENT);
                            } catch (SettingNotFoundException snfe) {
                                automatic = 0;
                            }
                            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, automatic != 0 ? 0 : 1, UserHandle.USER_CURRENT);
                        }
                        return true;
                    }
                });
                mModel.addBrightnessTile(brightnessTile, new QuickSettingsModel.BasicRefreshCallback(brightnessTile));
                parent.addView(brightnessTile);
                if (addMissing)
                    brightnessTile.setVisibility(View.GONE);
            } else if (Tile.SETTINGS.toString().equals(tile.toString())) {
                // Settings tile
                // Settings tile
                final QuickSettingsBasicTile settingsTile = new QuickSettingsBasicTile(mContext);
                settingsTile.setTileId(Tile.SETTINGS);
                settingsTile.setImageResource(R.drawable.ic_qs_settings);
                settingsTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SETTINGS);
                    }
                });
                mModel.addSettingsTile(settingsTile, new QuickSettingsModel.BasicRefreshCallback(settingsTile));
                parent.addView(settingsTile);
                if (addMissing)
                    settingsTile.setVisibility(View.GONE);
            } else if (Tile.WIFI.toString().equals(tile.toString())) {
                // wifi tile
                // Wi-fi
                final QuickSettingsFlipTile wifiTile = new QuickSettingsFlipTile(mContext);
                wifiTile.setTileId(Tile.WIFI);
                wifiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
                        return true;
                    }
                });
                wifiTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        final boolean enable = (mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
                        new AsyncTask<Void, Void, Void>() {

                            @Override
                            protected Void doInBackground(Void... args) {
                                // Disable tethering if enabling Wifi
                                final int wifiApState = mWifiManager.getWifiApState();
                                if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
                                    mWifiManager.setWifiApEnabled(null, false);
                                }
                                mWifiManager.setWifiEnabled(enable);
                                return null;
                            }
                        }.execute();
                        wifiTile.setFrontLoading(true);
                        wifiTile.setFrontPressed(false);
                    }
                });
                mModel.addWifiTile(wifiTile.getFront(), new NetworkActivityCallback() {

                    private String mPreviousLabel = "";

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setFrontImageResource(wifiState.iconId);
                        wifiTile.setFrontText(wifiState.label);
                        wifiTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi, wifiState.signalContentDescription, (wifiState.connected) ? wifiState.label : ""));
                        if (wifiState.label != null && !mPreviousLabel.equals(wifiState.label)) {
                            wifiTile.setFrontLoading(false);
                            mPreviousLabel = wifiState.label;
                        }
                    }
                });
                wifiTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        if (DeviceUtils.deviceSupportsWifiAp(mContext)) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                        return true;
                    }
                });
                mModel.addWifiBackTile(wifiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setBackImageResource(wifiState.iconId);
                        wifiTile.setBackLabel(wifiState.label);
                        if (wifiState.connected) {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_label));
                        } else {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_off_label));
                        }
                    }
                });
                parent.addView(wifiTile);
                if (addMissing)
                    wifiTile.setVisibility(View.GONE);
            } else if (Tile.RSSI.toString().equals(tile.toString())) {
                // rssi tile
                if (DeviceUtils.deviceSupportsMobileData(mContext)) {
                    // RSSI
                    final QuickSettingsNetworkFlipTile rssiTile = new QuickSettingsNetworkFlipTile(mContext);
                    rssiTile.setTileId(Tile.RSSI);
                    final ConnectivityManager cms = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                    rssiTile.setBackLabel(mContext.getString(R.string.quick_settings_network_type));
                    rssiTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean currentState = cms.getMobileDataEnabled();
                            cms.setMobileDataEnabled(!currentState);
                        }
                    });
                    rssiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$DataUsageSummaryActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addRSSITile(rssiTile.getFront(), new NetworkActivityCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            RSSIState rssiState = (RSSIState) state;
                            // Force refresh
                            rssiTile.setFrontImageDrawable(null);
                            rssiTile.setFrontImageResource(rssiState.signalIconId);
                            if (rssiState.dataTypeIconId > 0) {
                                rssiTile.setFrontImageOverlayResource(rssiState.dataTypeIconId);
                            } else {
                                rssiTile.setFrontImageOverlayDrawable(null);
                            }
                            setActivity(view, rssiState);
                            rssiTile.setFrontText(state.label);
                            rssiTile.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile, rssiState.signalContentDescription, rssiState.dataContentDescription, state.label));
                        }
                    });
                    rssiTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent(Intent.ACTION_MAIN);
                            intent.setClassName("com.android.phone", "com.android.phone.Settings");
                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addMobileNetworkTile(rssiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State mobileNetworkState) {
                            rssiTile.setBackFunction(mobileNetworkState.label);
                            rssiTile.setBackImageResource(mobileNetworkState.iconId);
                        }
                    });
                    parent.addView(rssiTile);
                    if (addMissing)
                        rssiTile.setVisibility(View.GONE);
                }
            } else if (Tile.ROTATION.toString().equals(tile.toString())) {
                // Rotation Lock
                if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
                    final QuickSettingsBasicTile rotationLockTile = new QuickSettingsBasicTile(mContext);
                    rotationLockTile.setTileId(Tile.ROTATION);
                    rotationLockTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View view) {
                            final boolean locked = mRotationLockController.isRotationLocked();
                            mRotationLockController.setRotationLocked(!locked);
                        }
                    });
                    rotationLockTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_DISPLAY_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addRotationLockTile(rotationLockTile, mRotationLockController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            QuickSettingsModel.RotationLockState rotationLockState = (QuickSettingsModel.RotationLockState) state;
                            if (state.iconId != 0) {
                                // needed to flush any cached IDs
                                rotationLockTile.setImageDrawable(null);
                                rotationLockTile.setImageResource(state.iconId);
                            }
                            if (state.label != null) {
                                rotationLockTile.setText(state.label);
                            }
                        }
                    });
                    parent.addView(rotationLockTile);
                    if (addMissing)
                        rotationLockTile.setVisibility(View.GONE);
                }
            } else if (Tile.BATTERY.toString().equals(tile.toString())) {
                // battery tile
                // Battery
                mBatteryTile = new QuickSettingsBatteryFlipTile(mContext);
                updateBattery();
                mBatteryTile.setTileId(Tile.BATTERY);
                mBatteryTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
                    }
                });
                mModel.addBatteryTile(mBatteryTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryState batteryState = (QuickSettingsModel.BatteryState) state;
                        String t;
                        if (batteryState.batteryLevel == 100) {
                            t = mContext.getString(R.string.quick_settings_battery_charged_label);
                        } else {
                            if (batteryState.pluggedIn) {
                                t = // circle percent
                                mBatteryStyle != 3 ? mContext.getString(R.string.quick_settings_battery_charging_label, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_charging);
                            } else {
                                // battery bar or battery circle
                                t = (mBatteryStyle == 0 || mBatteryStyle == 2) ? mContext.getString(R.string.status_bar_settings_battery_meter_format, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_discharging);
                            }
                        }
                        mBatteryTile.setFrontText(t);
                        mBatteryTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery, t));
                    }
                });
                mBatteryTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
                    }
                });
                mModel.addBackBatteryTile(mBatteryTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryBackState batteryState = (QuickSettingsModel.BatteryBackState) state;
                        mBatteryTile.setBackLabel(batteryState.temperature);
                        mBatteryTile.setBackFunction(batteryState.voltage + batteryState.healthString);
                    }
                });
                parent.addView(mBatteryTile);
                if (addMissing)
                    mBatteryTile.setVisibility(View.GONE);
            } else if (Tile.IMMERSIVE.toString().equals(tile.toString())) {
                // Immersive tile
                // Immersive mode
                final QuickSettingsFlipTile immersiveTile = new QuickSettingsFlipTile(mContext);
                immersiveTile.setTileId(Tile.IMMERSIVE);
                immersiveTile.setFrontImageResource(R.drawable.ic_qs_immersive_global_off);
                immersiveTile.setFrontText(mContext.getString(R.string.quick_settings_immersive_global_off_label));
                mModel.addImmersiveFrontTile(immersiveTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        immersiveTile.setFrontImageResource(state.iconId);
                        immersiveTile.setFrontText(state.label);
                    }
                });
                immersiveTile.setBackImageResource(R.drawable.ic_qs_immersive_off);
                immersiveTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                mModel.addImmersiveBackTile(immersiveTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        immersiveTile.setBackImageResource(state.iconId);
                        immersiveTile.setBackFunction(state.label);
                    }
                });
                parent.addView(immersiveTile);
                if (addMissing)
                    immersiveTile.setVisibility(View.GONE);
            } else if (Tile.AIRPLANE.toString().equals(tile.toString())) {
                // airplane tile
                // Airplane Mode
                final QuickSettingsBasicTile airplaneTile = new QuickSettingsBasicTile(mContext);
                airplaneTile.setTileId(Tile.AIRPLANE);
                mModel.addAirplaneModeTile(airplaneTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        airplaneTile.setImageResource(state.iconId);
                        String airplaneState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane, airplaneState));
                        airplaneTile.setText(state.label);
                    }
                });
                parent.addView(airplaneTile);
                if (addMissing)
                    airplaneTile.setVisibility(View.GONE);
            } else if (Tile.USBMODE.toString().equals(tile.toString())) {
                // Usb Mode
                if (DeviceUtils.deviceSupportsUsbTether(mContext)) {
                    final QuickSettingsBasicTile usbModeTile = new QuickSettingsBasicTile(mContext);
                    usbModeTile.setTileId(Tile.USBMODE);
                    usbModeTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addUsbModeTile(usbModeTile, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            usbModeTile.setImageResource(state.iconId);
                            usbModeTile.setText(state.label);
                        }
                    });
                    parent.addView(usbModeTile);
                    if (addMissing)
                        usbModeTile.setVisibility(View.GONE);
                }
            } else if (Tile.TORCH.toString().equals(tile.toString())) {
                // Torch
                if (DeviceUtils.deviceSupportsTorch(mContext)) {
                    final QuickSettingsBasicTile torchTile = new QuickSettingsBasicTile(mContext);
                    torchTile.setTileId(Tile.TORCH);
                    torchTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(OmniTorchConstants.INTENT_LAUNCH_APP);
                            return true;
                        }
                    });
                    mModel.addTorchTile(torchTile, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            torchTile.setImageResource(state.iconId);
                            torchTile.setText(state.label);
                        }
                    });
                    parent.addView(torchTile);
                    if (addMissing)
                        torchTile.setVisibility(View.GONE);
                }
            } else if (Tile.SYNC.toString().equals(tile.toString())) {
                // sync tile
                // sync
                final QuickSettingsBasicTile SyncTile = new QuickSettingsBasicTile(mContext);
                SyncTile.setTileId(Tile.SYNC);
                SyncTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent("android.settings.SYNC_SETTINGS");
                        intent.addCategory(Intent.CATEGORY_DEFAULT);
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addSyncModeTile(SyncTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        SyncTile.setImageResource(state.iconId);
                        SyncTile.setText(state.label);
                    }
                });
                parent.addView(SyncTile);
                if (addMissing)
                    SyncTile.setVisibility(View.GONE);
            } else if (Tile.QUITEHOUR.toString().equals(tile.toString())) {
                // Quite hours tile
                // Quite hours mode
                final QuickSettingsBasicTile quiteHourTile = new QuickSettingsBasicTile(mContext);
                quiteHourTile.setTileId(Tile.QUITEHOUR);
                quiteHourTile.setImageResource(R.drawable.ic_qs_quiet_hours_off);
                quiteHourTile.setTextResource(R.string.quick_settings_quiethours_off_label);
                quiteHourTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, checkModeOn ? 0 : 1);
                        Intent scheduleSms = new Intent();
                        scheduleSms.setAction("com.android.settings.slim.service.SCHEDULE_SERVICE_COMMAND");
                        mContext.sendBroadcast(scheduleSms);
                    }
                });
                quiteHourTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent(Intent.ACTION_MAIN);
                        intent.setClassName("com.android.settings", "com.android.settings.Settings$QuietHoursSettingsActivity");
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addQuiteHourTile(quiteHourTile, new QuickSettingsModel.BasicRefreshCallback(quiteHourTile));
                parent.addView(quiteHourTile);
                if (addMissing)
                    quiteHourTile.setVisibility(View.GONE);
            } else if (Tile.VOLUME.toString().equals(tile.toString())) {
                // Volume tile
                // Volume mode
                final QuickSettingsFlipTile VolumeTile = new QuickSettingsFlipTile(mContext);
                VolumeTile.setTileId(Tile.VOLUME);
                VolumeTile.setFrontImageResource(R.drawable.ic_qs_volume);
                VolumeTile.setFrontText(mContext.getString(R.string.quick_settings_volume));
                VolumeTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                VolumeTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
                        am.adjustVolume(AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);
                    }
                });
                VolumeTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                mModel.addRingerModeTile(VolumeTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        VolumeTile.setBackImageResource(state.iconId);
                        VolumeTile.setBackFunction(state.label);
                    }
                });
                VolumeTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                parent.addView(VolumeTile);
                if (addMissing)
                    VolumeTile.setVisibility(View.GONE);
            } else if (Tile.SLEEP.toString().equals(tile.toString())) {
                // Sleep tile
                // Sleep
                final QuickSettingsFlipTile SleepTile = new QuickSettingsFlipTile(mContext);
                SleepTile.setTileId(Tile.SLEEP);
                SleepTile.setFrontImageResource(R.drawable.ic_qs_sleep);
                SleepTile.setFrontText(mContext.getString(R.string.quick_settings_screen_sleep));
                SleepTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                SleepTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        pm.goToSleep(SystemClock.uptimeMillis());
                    }
                });
                SleepTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        collapsePanels();
                        Intent intent = new Intent(Intent.ACTION_POWERMENU);
                        mContext.sendBroadcast(intent);
                        return true;
                    }
                });
                mModel.addSleepModeTile(SleepTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        SleepTile.setBackImageResource(state.iconId);
                        SleepTile.setBackFunction(state.label);
                    }
                });
                parent.addView(SleepTile);
                if (addMissing)
                    SleepTile.setVisibility(View.GONE);
            } else if (Tile.BLUETOOTH.toString().equals(tile.toString())) {
                // Bluetooth
                if (DeviceUtils.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
                    final QuickSettingsFlipTile bluetoothTile = new QuickSettingsFlipTile(mContext);
                    bluetoothTile.setTileId(Tile.BLUETOOTH);
                    bluetoothTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (mBluetoothAdapter.isEnabled()) {
                                mBluetoothAdapter.disable();
                            } else {
                                mBluetoothAdapter.enable();
                            }
                            bluetoothTile.setFrontPressed(false);
                            bluetoothTile.setFrontLoading(true);
                        }
                    });
                    mModel.addBluetoothTile(bluetoothTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        private boolean mPreviousState = false;

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setFrontImageResource(state.iconId);
                            bluetoothTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setFrontText(state.label);
                            if (mPreviousState != state.enabled) {
                                bluetoothTile.setFrontLoading(false);
                                mPreviousState = state.enabled;
                            }
                        }
                    });
                    bluetoothTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (!mBluetoothAdapter.isEnabled()) {
                                return;
                            }
                            if (mBluetoothAdapter.getScanMode() != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    mModel.addBluetoothBackTile(bluetoothTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setBackImageResource(state.iconId);
                            bluetoothTile.setBackContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setBackLabel(state.label);
                            if (mBluetoothAdapter.getScanMode() == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    parent.addView(bluetoothTile);
                    if (addMissing)
                        bluetoothTile.setVisibility(View.GONE);
                }
            } else if (Tile.LOCATION.toString().equals(tile.toString())) {
                // Location
                if (DeviceUtils.deviceSupportsGps(mContext)) {
                    final QuickSettingsFlipTile locationTile = new QuickSettingsFlipTile(mContext);
                    locationTile.setTileId(Tile.LOCATION);
                    locationTile.setFrontImageResource(R.drawable.ic_qs_location_default_on);
                    locationTile.setFrontText(mContext.getString(R.string.quick_settings_location_label));
                    locationTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                    locationTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                            return true;
                        }
                    });
                    locationTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean newLocationEnabledState = !mLocationController.isLocationEnabled();
                            if (mLocationController.setLocationEnabled(newLocationEnabledState) && mLocationController.isLocationAllowPanelCollapse()) {
                                // If we've successfully switched from location off to on, close the
                                // notifications tray to show the network location provider consent dialog.
                                Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                                mContext.sendBroadcast(closeDialog);
                            }
                        }
                    });
                    mModel.addLocationTile(locationTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            locationTile.setFrontImageResource(state.iconId);
                            String locationState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                            locationTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_location, locationState));
                            locationTile.setFrontText(state.label);
                        }
                    });
                    locationTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            int newLocationMode = mLocationController.getLocationMode();
                            if (mLocationController.isLocationEnabled()) {
                                if (mLocationController.setBackLocationEnabled(newLocationMode)) {
                                    if (mLocationController.isLocationAllowPanelCollapse()) {
                                        // If we've successfully switched from location off to on, close the
                                        // notifications tray to show the network location provider consent dialog.
                                        Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                                        mContext.sendBroadcast(closeDialog);
                                    }
                                }
                            }
                        }
                    });
                    locationTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addBackLocationTile(locationTile.getBack(), mLocationController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            locationTile.setBackImageResource(state.iconId);
                            locationTile.setBackFunction(state.label);
                        }
                    });
                    parent.addView(locationTile);
                    if (addMissing)
                        locationTile.setVisibility(View.GONE);
                }
            }
        }
    }
    if (!addMissing)
        addTiles(parent, true, false);
}
#method_after
private void addTiles(ViewGroup parent, boolean addMissing, boolean reset) {
    // If all the tiles were deleted, they are still loaded, but their visibility is changed
    if (reset) {
        parent.removeAllViews();
    }
    String tileContainer = Settings.System.getString(mContext.getContentResolver(), Settings.System.QUICK_SETTINGS_TILES);
    if (tileContainer == null)
        tileContainer = DEFAULT_TILES;
    Tile[] allTiles = Tile.values();
    String[] storedTiles = tileContainer.split(DELIMITER);
    List<String> allTilesArray = enumToStringArray(allTiles);
    List<String> storedTilesArray = Arrays.asList(storedTiles);
    for (String tile : addMissing ? allTilesArray : storedTilesArray) {
        boolean addTile = storedTilesArray.contains(tile);
        if (addMissing)
            addTile = !addTile;
        if (addTile) {
            if (Tile.USER.toString().equals(tile.toString())) {
                // User
                final QuickSettingsBasicUserTile userTile = new QuickSettingsBasicUserTile(mContext);
                userTile.setTileId(Tile.USER);
                userTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        final UserManager um = UserManager.get(mContext);
                        if (um.getUsers(true).size() > 1) {
                            // Since keyguard and systemui were merged into the same process to save
                            // memory, they share the same Looper and graphics context.  As a result,
                            // there's no way to allow concurrent animation while keyguard inflates.
                            // The workaround is to add a slight delay to allow the animation to finish.
                            mHandler.postDelayed(new Runnable() {

                                public void run() {
                                    try {
                                        WindowManagerGlobal.getWindowManagerService().lockNow(null);
                                    } catch (RemoteException e) {
                                        Log.e(TAG, "Couldn't show user switcher", e);
                                    }
                                }
                            }, // TODO: ideally this would be tied to the collapse of the panel
                            400);
                        } else {
                            Intent intent = ContactsContract.QuickContact.composeQuickContactsIntent(mContext, v, ContactsContract.Profile.CONTENT_URI, ContactsContract.QuickContact.MODE_LARGE, null);
                            mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
                        }
                    }
                });
                userTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SYNC_SETTINGS);
                        return true;
                    }
                });
                mModel.addUserTile(userTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        UserState us = (UserState) state;
                        userTile.setText(state.label);
                        userTile.setImageDrawable(us.avatar);
                        view.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_user, state.label));
                    }
                });
                parent.addView(userTile);
                if (addMissing)
                    userTile.setVisibility(View.GONE);
            } else if (Tile.BRIGHTNESS.toString().equals(tile.toString())) {
                // brightness
                // Brightness
                final QuickSettingsBasicTile brightnessTile = new QuickSettingsBasicTile(mContext);
                brightnessTile.setTileId(Tile.BRIGHTNESS);
                brightnessTile.setImageResource(R.drawable.ic_qs_brightness_auto_off);
                brightnessTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        showBrightnessDialog();
                    }
                });
                brightnessTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        boolean automaticAvailable = mContext.getResources().getBoolean(com.android.internal.R.bool.config_automatic_brightness_available);
                        // If we have automatic brightness available, toggle it
                        if (automaticAvailable) {
                            int automatic;
                            try {
                                automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, UserHandle.USER_CURRENT);
                            } catch (SettingNotFoundException snfe) {
                                automatic = 0;
                            }
                            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, automatic != 0 ? 0 : 1, UserHandle.USER_CURRENT);
                        }
                        return true;
                    }
                });
                mModel.addBrightnessTile(brightnessTile, new QuickSettingsModel.BasicRefreshCallback(brightnessTile));
                parent.addView(brightnessTile);
                if (addMissing)
                    brightnessTile.setVisibility(View.GONE);
            } else if (Tile.SETTINGS.toString().equals(tile.toString())) {
                // Settings tile
                // Settings tile
                final QuickSettingsBasicTile settingsTile = new QuickSettingsBasicTile(mContext);
                settingsTile.setTileId(Tile.SETTINGS);
                settingsTile.setImageResource(R.drawable.ic_qs_settings);
                settingsTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SETTINGS);
                    }
                });
                mModel.addSettingsTile(settingsTile, new QuickSettingsModel.BasicRefreshCallback(settingsTile));
                parent.addView(settingsTile);
                if (addMissing)
                    settingsTile.setVisibility(View.GONE);
            } else if (Tile.WIFI.toString().equals(tile.toString())) {
                // wifi tile
                // Wi-fi
                final QuickSettingsFlipTile wifiTile = new QuickSettingsFlipTile(mContext);
                wifiTile.setTileId(Tile.WIFI);
                wifiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
                        return true;
                    }
                });
                wifiTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        final boolean enable = (mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
                        new AsyncTask<Void, Void, Void>() {

                            @Override
                            protected Void doInBackground(Void... args) {
                                // Disable tethering if enabling Wifi
                                final int wifiApState = mWifiManager.getWifiApState();
                                if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
                                    mWifiManager.setWifiApEnabled(null, false);
                                }
                                mWifiManager.setWifiEnabled(enable);
                                return null;
                            }
                        }.execute();
                        wifiTile.setFrontLoading(true);
                        wifiTile.setFrontPressed(false);
                    }
                });
                mModel.addWifiTile(wifiTile.getFront(), new NetworkActivityCallback() {

                    private String mPreviousLabel = "";

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setFrontImageResource(wifiState.iconId);
                        wifiTile.setFrontText(wifiState.label);
                        wifiTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi, wifiState.signalContentDescription, (wifiState.connected) ? wifiState.label : ""));
                        if (wifiState.label != null && !mPreviousLabel.equals(wifiState.label)) {
                            wifiTile.setFrontLoading(false);
                            mPreviousLabel = wifiState.label;
                        }
                    }
                });
                wifiTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        if (DeviceUtils.deviceSupportsWifiAp(mContext)) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                        return true;
                    }
                });
                mModel.addWifiBackTile(wifiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setBackImageResource(wifiState.iconId);
                        wifiTile.setBackLabel(wifiState.label);
                        if (wifiState.connected) {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_label));
                        } else {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_off_label));
                        }
                    }
                });
                parent.addView(wifiTile);
                if (addMissing)
                    wifiTile.setVisibility(View.GONE);
            } else if (Tile.RSSI.toString().equals(tile.toString())) {
                // rssi tile
                if (DeviceUtils.deviceSupportsMobileData(mContext)) {
                    // RSSI
                    final QuickSettingsNetworkFlipTile rssiTile = new QuickSettingsNetworkFlipTile(mContext);
                    rssiTile.setTileId(Tile.RSSI);
                    final ConnectivityManager cms = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                    rssiTile.setBackLabel(mContext.getString(R.string.quick_settings_network_type));
                    rssiTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean currentState = cms.getMobileDataEnabled();
                            cms.setMobileDataEnabled(!currentState);
                        }
                    });
                    rssiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$DataUsageSummaryActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addRSSITile(rssiTile.getFront(), new NetworkActivityCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            RSSIState rssiState = (RSSIState) state;
                            // Force refresh
                            rssiTile.setFrontImageDrawable(null);
                            rssiTile.setFrontImageResource(rssiState.signalIconId);
                            if (rssiState.dataTypeIconId > 0) {
                                rssiTile.setFrontImageOverlayResource(rssiState.dataTypeIconId);
                            } else {
                                rssiTile.setFrontImageOverlayDrawable(null);
                            }
                            setActivity(view, rssiState);
                            rssiTile.setFrontText(state.label);
                            rssiTile.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile, rssiState.signalContentDescription, rssiState.dataContentDescription, state.label));
                        }
                    });
                    rssiTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent(Intent.ACTION_MAIN);
                            intent.setClassName("com.android.phone", "com.android.phone.Settings");
                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addMobileNetworkTile(rssiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State mobileNetworkState) {
                            rssiTile.setBackFunction(mobileNetworkState.label);
                            rssiTile.setBackImageResource(mobileNetworkState.iconId);
                        }
                    });
                    parent.addView(rssiTile);
                    if (addMissing)
                        rssiTile.setVisibility(View.GONE);
                }
            } else if (Tile.ROTATION.toString().equals(tile.toString())) {
                // Rotation Lock
                if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
                    final QuickSettingsBasicTile rotationLockTile = new QuickSettingsBasicTile(mContext);
                    rotationLockTile.setTileId(Tile.ROTATION);
                    rotationLockTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View view) {
                            final boolean locked = mRotationLockController.isRotationLocked();
                            mRotationLockController.setRotationLocked(!locked);
                        }
                    });
                    rotationLockTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_DISPLAY_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addRotationLockTile(rotationLockTile, mRotationLockController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            QuickSettingsModel.RotationLockState rotationLockState = (QuickSettingsModel.RotationLockState) state;
                            if (state.iconId != 0) {
                                // needed to flush any cached IDs
                                rotationLockTile.setImageDrawable(null);
                                rotationLockTile.setImageResource(state.iconId);
                            }
                            if (state.label != null) {
                                rotationLockTile.setText(state.label);
                            }
                        }
                    });
                    parent.addView(rotationLockTile);
                    if (addMissing)
                        rotationLockTile.setVisibility(View.GONE);
                }
            } else if (Tile.BATTERY.toString().equals(tile.toString())) {
                // battery tile
                // Battery
                mBatteryTile = new QuickSettingsBatteryFlipTile(mContext);
                updateBattery();
                mBatteryTile.setTileId(Tile.BATTERY);
                mBatteryTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
                    }
                });
                mModel.addBatteryTile(mBatteryTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryState batteryState = (QuickSettingsModel.BatteryState) state;
                        String t;
                        if (batteryState.batteryLevel == 100) {
                            t = mContext.getString(R.string.quick_settings_battery_charged_label);
                        } else {
                            if (batteryState.pluggedIn) {
                                t = // circle percent or percent only
                                mBatteryStyle != 4 && mBatteryStyle != 5 ? mContext.getString(R.string.quick_settings_battery_charging_label, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_charging);
                            } else {
                                // battery bar or battery circle or none
                                t = (mBatteryStyle == 0 || mBatteryStyle == 2 || mBatteryStyle == 3 || mBatteryStyle == 6) ? mContext.getString(R.string.status_bar_settings_battery_meter_format, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_discharging);
                            }
                        }
                        mBatteryTile.setFrontText(t);
                        mBatteryTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery, t));
                    }
                });
                mBatteryTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        Intent intent = new Intent(Intent.ACTION_MAIN);
                        intent.setClassName("com.android.settings", "com.android.settings.BatteryInfo");
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startSettingsActivity(intent);
                    }
                });
                mModel.addBackBatteryTile(mBatteryTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryBackState batteryState = (QuickSettingsModel.BatteryBackState) state;
                        mBatteryTile.setBackLabel(batteryState.temperature);
                        mBatteryTile.setBackFunction(batteryState.voltage + batteryState.healthString);
                    }
                });
                parent.addView(mBatteryTile);
                if (addMissing)
                    mBatteryTile.setVisibility(View.GONE);
            } else if (Tile.IMMERSIVE.toString().equals(tile.toString())) {
                // Immersive tile
                // Immersive mode
                final QuickSettingsFlipTile immersiveTile = new QuickSettingsFlipTile(mContext);
                immersiveTile.setTileId(Tile.IMMERSIVE);
                immersiveTile.setSupportFlip(DeviceUtils.deviceSupportNavigationBar(mContext));
                immersiveTile.setFrontImageResource(R.drawable.ic_qs_immersive_global_off);
                immersiveTile.setFrontText(mContext.getString(R.string.quick_settings_immersive_global_off_label));
                mModel.addImmersiveFrontTile(immersiveTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        immersiveTile.setFrontImageResource(state.iconId);
                        immersiveTile.setFrontText(state.label);
                    }
                });
                immersiveTile.setBackImageResource(R.drawable.ic_qs_immersive_off);
                immersiveTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                mModel.addImmersiveBackTile(immersiveTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        immersiveTile.setBackImageResource(state.iconId);
                        immersiveTile.setBackFunction(state.label);
                    }
                });
                parent.addView(immersiveTile);
                if (addMissing)
                    immersiveTile.setVisibility(View.GONE);
            } else if (Tile.AIRPLANE.toString().equals(tile.toString())) {
                // airplane tile
                // Airplane Mode
                final QuickSettingsBasicTile airplaneTile = new QuickSettingsBasicTile(mContext);
                airplaneTile.setTileId(Tile.AIRPLANE);
                mModel.addAirplaneModeTile(airplaneTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        airplaneTile.setImageResource(state.iconId);
                        String airplaneState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane, airplaneState));
                        airplaneTile.setText(state.label);
                    }
                });
                parent.addView(airplaneTile);
                if (addMissing)
                    airplaneTile.setVisibility(View.GONE);
            } else if (Tile.USBMODE.toString().equals(tile.toString())) {
                // Usb Mode
                if (DeviceUtils.deviceSupportsUsbTether(mContext)) {
                    final QuickSettingsBasicTile usbModeTile = new QuickSettingsBasicTile(mContext);
                    usbModeTile.setTileId(Tile.USBMODE);
                    usbModeTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addUsbModeTile(usbModeTile, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            usbModeTile.setImageResource(state.iconId);
                            usbModeTile.setText(state.label);
                        }
                    });
                    parent.addView(usbModeTile);
                    if (addMissing)
                        usbModeTile.setVisibility(View.GONE);
                }
            } else if (Tile.TORCH.toString().equals(tile.toString())) {
                // Torch
                if (DeviceUtils.deviceSupportsTorch(mContext)) {
                    final QuickSettingsBasicTile torchTile = new QuickSettingsBasicTile(mContext);
                    torchTile.setTileId(Tile.TORCH);
                    torchTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(OmniTorchConstants.INTENT_LAUNCH_APP);
                            return true;
                        }
                    });
                    mModel.addTorchTile(torchTile, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            torchTile.setImageResource(state.iconId);
                            torchTile.setText(state.label);
                        }
                    });
                    parent.addView(torchTile);
                    if (addMissing)
                        torchTile.setVisibility(View.GONE);
                }
            } else if (Tile.SYNC.toString().equals(tile.toString())) {
                // sync tile
                // sync
                final QuickSettingsBasicTile SyncTile = new QuickSettingsBasicTile(mContext);
                SyncTile.setTileId(Tile.SYNC);
                SyncTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent("android.settings.SYNC_SETTINGS");
                        intent.addCategory(Intent.CATEGORY_DEFAULT);
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addSyncModeTile(SyncTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        SyncTile.setImageResource(state.iconId);
                        SyncTile.setText(state.label);
                    }
                });
                parent.addView(SyncTile);
                if (addMissing)
                    SyncTile.setVisibility(View.GONE);
            } else if (Tile.QUITEHOUR.toString().equals(tile.toString())) {
                // Quite hours tile
                // Quite hours mode
                final QuickSettingsBasicTile quiteHourTile = new QuickSettingsBasicTile(mContext);
                quiteHourTile.setTileId(Tile.QUITEHOUR);
                quiteHourTile.setImageResource(R.drawable.ic_qs_quiet_hours_off);
                quiteHourTile.setTextResource(R.string.quick_settings_quiethours_off_label);
                quiteHourTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, checkModeOn ? 0 : 1);
                        Intent scheduleSms = new Intent();
                        scheduleSms.setAction("com.android.settings.slim.service.SCHEDULE_SERVICE_COMMAND");
                        mContext.sendBroadcast(scheduleSms);
                    }
                });
                quiteHourTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent(Intent.ACTION_MAIN);
                        intent.setClassName("com.android.settings", "com.android.settings.Settings$QuietHoursSettingsActivity");
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addQuiteHourTile(quiteHourTile, new QuickSettingsModel.BasicRefreshCallback(quiteHourTile));
                parent.addView(quiteHourTile);
                if (addMissing)
                    quiteHourTile.setVisibility(View.GONE);
            } else if (Tile.VOLUME.toString().equals(tile.toString())) {
                // Volume tile
                // Volume mode
                final QuickSettingsFlipTile VolumeTile = new QuickSettingsFlipTile(mContext);
                VolumeTile.setTileId(Tile.VOLUME);
                VolumeTile.setFrontImageResource(R.drawable.ic_qs_volume);
                VolumeTile.setFrontText(mContext.getString(R.string.quick_settings_volume));
                VolumeTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                VolumeTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
                        am.adjustVolume(AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);
                    }
                });
                VolumeTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                mModel.addRingerModeTile(VolumeTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        VolumeTile.setBackImageResource(state.iconId);
                        VolumeTile.setBackFunction(state.label);
                    }
                });
                VolumeTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                parent.addView(VolumeTile);
                if (addMissing)
                    VolumeTile.setVisibility(View.GONE);
            } else if (Tile.SLEEP.toString().equals(tile.toString())) {
                // Sleep tile
                // Sleep
                final QuickSettingsFlipTile SleepTile = new QuickSettingsFlipTile(mContext);
                SleepTile.setTileId(Tile.SLEEP);
                SleepTile.setFrontImageResource(R.drawable.ic_qs_sleep);
                SleepTile.setFrontText(mContext.getString(R.string.quick_settings_screen_sleep));
                SleepTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                SleepTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        pm.goToSleep(SystemClock.uptimeMillis());
                    }
                });
                SleepTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        collapsePanels();
                        Intent intent = new Intent(Intent.ACTION_POWERMENU);
                        mContext.sendBroadcast(intent);
                        return true;
                    }
                });
                mModel.addSleepModeTile(SleepTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        SleepTile.setBackImageResource(state.iconId);
                        SleepTile.setBackFunction(state.label);
                    }
                });
                parent.addView(SleepTile);
                if (addMissing)
                    SleepTile.setVisibility(View.GONE);
            } else if (Tile.BLUETOOTH.toString().equals(tile.toString())) {
                // Bluetooth
                if (DeviceUtils.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
                    final QuickSettingsFlipTile bluetoothTile = new QuickSettingsFlipTile(mContext);
                    bluetoothTile.setTileId(Tile.BLUETOOTH);
                    bluetoothTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (mBluetoothAdapter.isEnabled()) {
                                mBluetoothAdapter.disable();
                            } else {
                                mBluetoothAdapter.enable();
                            }
                            bluetoothTile.setFrontPressed(false);
                            bluetoothTile.setFrontLoading(true);
                        }
                    });
                    mModel.addBluetoothTile(bluetoothTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        private boolean mPreviousState = false;

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setFrontImageResource(state.iconId);
                            bluetoothTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setFrontText(state.label);
                            if (mPreviousState != state.enabled) {
                                bluetoothTile.setFrontLoading(false);
                                mPreviousState = state.enabled;
                            }
                        }
                    });
                    bluetoothTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (!mBluetoothAdapter.isEnabled()) {
                                return;
                            }
                            if (mBluetoothAdapter.getScanMode() != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    mModel.addBluetoothBackTile(bluetoothTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setBackImageResource(state.iconId);
                            bluetoothTile.setBackContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setBackLabel(state.label);
                            if (mBluetoothAdapter.getScanMode() == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    parent.addView(bluetoothTile);
                    if (addMissing)
                        bluetoothTile.setVisibility(View.GONE);
                }
            } else if (Tile.LOCATION.toString().equals(tile.toString())) {
                // Location
                if (DeviceUtils.deviceSupportsGps(mContext)) {
                    final QuickSettingsFlipTile locationTile = new QuickSettingsFlipTile(mContext);
                    locationTile.setTileId(Tile.LOCATION);
                    locationTile.setFrontImageResource(R.drawable.ic_qs_location_default_on);
                    locationTile.setFrontText(mContext.getString(R.string.quick_settings_location_label));
                    locationTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                    locationTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                            return true;
                        }
                    });
                    locationTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean newLocationEnabledState = !mLocationController.isLocationEnabled();
                            if (mLocationController.setLocationEnabled(newLocationEnabledState) && mLocationController.isLocationAllowPanelCollapse()) {
                                // If we've successfully switched from location off to on, close the
                                // notifications tray to show the network location provider consent dialog.
                                Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                                mContext.sendBroadcast(closeDialog);
                            }
                        }
                    });
                    mModel.addLocationTile(locationTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            locationTile.setFrontImageResource(state.iconId);
                            String locationState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                            locationTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_location, locationState));
                            locationTile.setFrontText(state.label);
                        }
                    });
                    locationTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            int newLocationMode = mLocationController.getLocationMode();
                            if (mLocationController.isLocationEnabled()) {
                                if (mLocationController.setBackLocationEnabled(newLocationMode)) {
                                    if (mLocationController.isLocationAllowPanelCollapse()) {
                                        // If we've successfully switched from location off to on, close the
                                        // notifications tray to show the network location provider consent dialog.
                                        Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                                        mContext.sendBroadcast(closeDialog);
                                    }
                                }
                            }
                        }
                    });
                    locationTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addBackLocationTile(locationTile.getBack(), mLocationController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            locationTile.setBackImageResource(state.iconId);
                            locationTile.setBackFunction(state.label);
                        }
                    });
                    parent.addView(locationTile);
                    if (addMissing)
                        locationTile.setVisibility(View.GONE);
                }
            }
        }
    }
    if (!addMissing)
        addTiles(parent, true, false);
}
#end_block

#method_before
protected WindowManager.LayoutParams getActiveDisplayViewLayoutParams() {
    WindowManager.LayoutParams lp = new WindowManager.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.TYPE_BOOT_PROGRESS, 0 | WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED, PixelFormat.OPAQUE);
    if (ActivityManager.isHighEndGfx()) {
        lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    lp.gravity = Gravity.TOP | Gravity.FILL;
    lp.setTitle("ActiveDisplayView");
    return lp;
}
#method_after
protected WindowManager.LayoutParams getActiveDisplayViewLayoutParams() {
    WindowManager.LayoutParams lp = new WindowManager.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.TYPE_NAVIGATION_BAR_PANEL, 0 | WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH, PixelFormat.OPAQUE);
    if (ActivityManager.isHighEndGfx()) {
        lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    lp.gravity = Gravity.BOTTOM | Gravity.START;
    lp.setTitle("ActiveDisplayView");
    return lp;
}
#end_block

#method_before
void addMobileNetworkTile(QuickSettingsTileView view, RefreshCallback cb) {
    mMobileNetworkTile = view;
    mMobileNetworkTile.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (SystemClock.elapsedRealtime() - mLastClickTime < 1000) {
                return;
            }
            mLastClickTime = SystemClock.elapsedRealtime();
            toggleMobileNetworkState();
        }
    });
    mMobileNetworkCallback = cb;
    onMobileNetworkChanged();
}
#method_after
void addMobileNetworkTile(QuickSettingsTileView view, RefreshCallback cb) {
    mMobileNetworkTile = view;
    mMobileNetworkTile.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if ((SystemClock.elapsedRealtime() - mLastClickTime) < 1000) {
                return;
            }
            if (mLastClickTime != 0) {
                toggleMobileNetworkState();
            }
            mLastClickTime = SystemClock.elapsedRealtime();
        }
    });
    mMobileNetworkCallback = cb;
    onMobileNetworkChanged();
}
#end_block

#method_before
void addImmersiveBackTile(QuickSettingsTileView view, RefreshCallback cb) {
    mImmersiveBackTile = view;
    mImmersiveBackTile.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            collapsePanels();
            switchImmersiveBack();
            refreshImmersiveBackTile();
        }
    });
    mImmersiveBackCallback = cb;
    onImmersiveBackChanged();
}
#method_after
void addImmersiveBackTile(QuickSettingsTileView view, RefreshCallback cb) {
    mImmersiveBackTile = view;
    mImmersiveBackTile.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            switchImmersiveBack();
            refreshImmersiveBackTile();
        }
    });
    mImmersiveBackCallback = cb;
    onImmersiveBackChanged();
}
#end_block

#method_before
private void onImmersiveBackChanged() {
    Resources r = mContext.getResources();
    int mode = getImmersiveMode();
    int iconId = R.drawable.ic_qs_immersive_off;
    String label = r.getString(R.string.quick_settings_immersive_mode_off_label);
    switch(mode) {
        case IMMERSIVE_MODE_FULL:
            iconId = R.drawable.ic_qs_immersive_off;
            label = r.getString(R.string.quick_settings_immersive_mode_off_label);
            break;
        case IMMERSIVE_MODE_HIDE_ONLY_NAVBAR:
            iconId = R.drawable.ic_qs_immersive_status_bar_off;
            label = r.getString(R.string.quick_settings_immersive_mode_no_status_bar_label);
            break;
        case IMMERSIVE_MODE_HIDE_ONLY_STATUSBAR:
            iconId = R.drawable.ic_qs_immersive_navigation_bar_off;
            label = r.getString(R.string.quick_settings_immersive_mode_no_navigation_bar_label);
            break;
    }
    mImmersiveBackState.iconId = iconId;
    mImmersiveBackState.label = label;
    mImmersiveBackCallback.refreshView(mImmersiveBackTile, mImmersiveBackState);
}
#method_after
private void onImmersiveBackChanged() {
    Resources r = mContext.getResources();
    int mode = getImmersiveMode();
    int iconId = R.drawable.ic_qs_immersive_global_off;
    String label = r.getString(R.string.quick_settings_immersive_mode_off_label);
    switch(mode) {
        case IMMERSIVE_MODE_FULL:
            iconId = R.drawable.ic_qs_immersive_off;
            label = r.getString(R.string.quick_settings_immersive_mode_full_label);
            break;
        case IMMERSIVE_MODE_HIDE_ONLY_NAVBAR:
            iconId = R.drawable.ic_qs_immersive_status_bar_off;
            label = r.getString(R.string.quick_settings_immersive_mode_no_status_bar_label);
            break;
        case IMMERSIVE_MODE_HIDE_ONLY_STATUSBAR:
            iconId = R.drawable.ic_qs_immersive_navigation_bar_off;
            label = r.getString(R.string.quick_settings_immersive_mode_no_navigation_bar_label);
            break;
    }
    mImmersiveBackState.iconId = iconId;
    mImmersiveBackState.label = label;
    mImmersiveBackCallback.refreshView(mImmersiveBackTile, mImmersiveBackState);
}
#end_block

#method_before
private void switchImmersiveBack() {
    int mode = getImmersiveMode();
    switch(mode) {
        case IMMERSIVE_MODE_FULL:
            setImmersiveMode(IMMERSIVE_MODE_HIDE_ONLY_NAVBAR);
            break;
        case IMMERSIVE_MODE_HIDE_ONLY_NAVBAR:
            setImmersiveMode(IMMERSIVE_MODE_HIDE_ONLY_STATUSBAR);
            break;
        case IMMERSIVE_MODE_HIDE_ONLY_STATUSBAR:
            setImmersiveMode(IMMERSIVE_MODE_FULL);
            break;
    }
}
#method_after
private void switchImmersiveBack() {
    int mode = getImmersiveMode();
    switch(mode) {
        case IMMERSIVE_MODE_FULL:
            setImmersiveMode(IMMERSIVE_MODE_HIDE_ONLY_NAVBAR);
            break;
        case IMMERSIVE_MODE_HIDE_ONLY_NAVBAR:
            setImmersiveMode(IMMERSIVE_MODE_HIDE_ONLY_STATUSBAR);
            break;
        case IMMERSIVE_MODE_HIDE_ONLY_STATUSBAR:
            collapsePanels();
            setImmersiveMode(IMMERSIVE_MODE_FULL);
            break;
    }
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENRECORD_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mVolumeUpKeyConsumedByScreenrecordChord) {
            if (!down) {
                mVolumeUpKeyConsumedByScreenrecordChord = false;
            }
            return -1;
        }
    }
    // stop the kill action
    if (mBackKillPending && !down) {
        mHandler.removeCallbacks(mKillTask);
        mBackKillPending = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            if (mRecentAppsPreloaded) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // and his ONLY options are to answer or reject the call.)
            try {
                ITelephony telephonyService = getTelephonyService();
                if (telephonyService != null && telephonyService.isRinging()) {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            } catch (RemoteException ex) {
                Log.w(TAG, "RemoteException from getPhoneInterface()", ex);
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // dont change handling of virtual home button events
            if (mPressOnHomeBehavior != KEY_ACTION_HOME && !virtualKey) {
                performKeyAction(mPressOnHomeBehavior);
            } else {
                launchHomeFromHotKey();
            }
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD || type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            if (down) {
                mHomePressed = true;
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeConsumed = true;
                performKeyAction(mDoubleTapOnHomeBehavior);
            } else if (!mRecentAppsPreloaded && (mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehavior == KEY_ACTION_APP_SWITCH || mPressOnHomeBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
                preloadRecentApps();
            }
            if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                mHomeConsumed = true;
                performKeyAction(mLongPressOnHomeBehavior);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcast(intent, null);
                    return -1;
                } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                    Intent service = new Intent();
                    service.setClassName(mContext, "com.android.server.LoadAverageService");
                    ContentResolver res = mContext.getContentResolver();
                    boolean shown = Settings.System.getInt(res, Settings.System.SHOW_PROCESSES, 0) != 0;
                    if (!shown) {
                        mContext.startService(service);
                    } else {
                        mContext.stopService(service);
                    }
                    Settings.System.putInt(res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
                    return -1;
                } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !virtualKey) {
                    mMenuDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnMenuBehavior);
                    // Do not perform action when key is released
                    mMenuDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mMenuDoCustomAction) {
                mMenuDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnMenuBehavior);
                    return -1;
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAppSwitchBehavior);
                    mAppSwitchLongPressed = true;
                }
            }
        } else {
            if (mAppSwitchLongPressed) {
                mAppSwitchLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAssistBehavior);
                    mAssistKeyLongPressed = true;
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAssistBehavior);
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            Intent intent = new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG);
            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnBackBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    mBackDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn) {
                    if (mLongPressOnBackBehavior != KEY_ACTION_NOTHING) {
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mLongPressOnBackBehavior);
                        // Do not perform action when key is released
                        mBackDoCustomAction = false;
                        return -1;
                    } else if (mSoftBackKillApp) {
                        // OR device with only soft keys and soft key back kill enabled
                        if (!virtualKey) {
                            // ignore hard key press
                            mBackDoCustomAction = false;
                            return -1;
                        } else {
                            // handle soft key press
                            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                            performKeyAction(KEY_ACTION_KILL_APP);
                            // Do not perform action when key is released
                            mBackDoCustomAction = false;
                            return -1;
                        }
                    }
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnBackBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnBackBehavior);
                    return -1;
                }
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB or Meta-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsDialogHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON) || KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_META_ON)) {
                mRecentAppsDialogHeldModifiers = shiftlessModifiers;
                showOrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW);
                return -1;
            }
        }
    } else if (!down && mRecentAppsDialogHeldModifiers != 0 && (metaState & mRecentAppsDialogHeldModifiers) == 0) {
        mRecentAppsDialogHeldModifiers = 0;
        showOrHideRecentAppsDialog(keyguardOn ? RECENT_APPS_BEHAVIOR_DISMISS : RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENRECORD_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mVolumeUpKeyConsumedByScreenrecordChord) {
            if (!down) {
                mVolumeUpKeyConsumedByScreenrecordChord = false;
            }
            return -1;
        }
    }
    // stop the kill action
    if (mBackKillPending && !down) {
        mHandler.removeCallbacks(mKillTask);
        mBackKillPending = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (mRecentAppsPreloaded && mDoubleTapOnHomeBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // and his ONLY options are to answer or reject the call.)
            try {
                ITelephony telephonyService = getTelephonyService();
                if (telephonyService != null && telephonyService.isRinging()) {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            } catch (RemoteException ex) {
                Log.w(TAG, "RemoteException from getPhoneInterface()", ex);
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // dont change handling of virtual home button events
            if (mPressOnHomeBehavior != KEY_ACTION_HOME && !virtualKey) {
                performKeyAction(mPressOnHomeBehavior);
            } else {
                launchHomeFromHotKey();
            }
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD || type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            if (down) {
                mHomePressed = true;
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeConsumed = true;
                performKeyAction(mDoubleTapOnHomeBehavior);
            } else if (!mRecentAppsPreloaded && (mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehavior == KEY_ACTION_APP_SWITCH || mPressOnHomeBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
                preloadRecentApps();
            }
            if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                mHomeConsumed = true;
                performKeyAction(mLongPressOnHomeBehavior);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcast(intent, null);
                    return -1;
                } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                    Intent service = new Intent();
                    service.setClassName(mContext, "com.android.server.LoadAverageService");
                    ContentResolver res = mContext.getContentResolver();
                    boolean shown = Settings.System.getInt(res, Settings.System.SHOW_PROCESSES, 0) != 0;
                    if (!shown) {
                        mContext.startService(service);
                    } else {
                        mContext.stopService(service);
                    }
                    Settings.System.putInt(res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
                    return -1;
                } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !virtualKey) {
                    mMenuDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnMenuBehavior);
                    // Do not perform action when key is released
                    mMenuDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mMenuDoCustomAction) {
                mMenuDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnMenuBehavior);
                    return -1;
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAppSwitchBehavior);
                    mAppSwitchLongPressed = true;
                }
            }
        } else {
            if (mAppSwitchLongPressed) {
                mAppSwitchLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAssistBehavior);
                    mAssistKeyLongPressed = true;
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAssistBehavior);
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            Intent intent = new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG);
            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnBackBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    mBackDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn) {
                    if (mLongPressOnBackBehavior != KEY_ACTION_NOTHING) {
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mLongPressOnBackBehavior);
                        // Do not perform action when key is released
                        mBackDoCustomAction = false;
                        return -1;
                    } else if (mSoftBackKillApp) {
                        // OR device with only soft keys and soft key back kill enabled
                        if (!virtualKey) {
                            // ignore hard key press
                            mBackDoCustomAction = false;
                            return -1;
                        } else {
                            // handle soft key press
                            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                            performKeyAction(KEY_ACTION_KILL_APP);
                            // Do not perform action when key is released
                            mBackDoCustomAction = false;
                            return -1;
                        }
                    }
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnBackBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnBackBehavior);
                    return -1;
                }
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB or Meta-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsDialogHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON) || KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_META_ON)) {
                mRecentAppsDialogHeldModifiers = shiftlessModifiers;
                showOrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW);
                return -1;
            }
        }
    } else if (!down && mRecentAppsDialogHeldModifiers != 0 && (metaState & mRecentAppsDialogHeldModifiers) == 0) {
        mRecentAppsDialogHeldModifiers = 0;
        showOrHideRecentAppsDialog(keyguardOn ? RECENT_APPS_BEHAVIOR_DISMISS : RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags, boolean isScreenOn) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (isScreenOn ? mKeyguardDelegate.isShowingAndNotHidden() : mKeyguardDelegate.isShowing()));
    if (keyCode == KeyEvent.KEYCODE_POWER) {
        policyFlags |= WindowManagerPolicy.FLAG_WAKE;
    }
    boolean isOffscreenWakeKey = false;
    if (mOffscreenGestureSupport) {
        isOffscreenWakeKey = isOffscreenWakeKey(keyCode);
    }
    boolean isWakeKey = (policyFlags & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0 || isOffscreenWakeKey;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTq keycode=" + keyCode + " screenIsOn=" + isScreenOn + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags) + " isWakeKey=" + isWakeKey + " scanCode=" + event.getScanCode());
    }
    if (down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0 && mVirtualKeysHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    // Basic policy based on screen state and keyguard.
    // FIXME: This policy isn't quite correct.  We shouldn't care whether the screen
    // is on or off, really.  We should care about whether the device is in an
    // interactive state or is in suspend pretending to be "off".
    // The primary screen might be turned off due to proximity sensor or
    // because we are presenting media on an auxiliary screen or remotely controlling
    // the device some other way (which is why we have an exemption here for injected
    // events).
    int result;
    if ((isScreenOn && !mHeadless) || (isInjected && !isWakeKey)) {
        // When the screen is on or if the key is injected pass the key to the application.
        result = ACTION_PASS_TO_USER;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (down && isWakeKey && isWakeKeyWhenScreenOff(keyCode)) {
            result |= ACTION_WAKE_UP;
        }
    }
    // key processing.
    if (mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        return result;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (isScreenOn && !mVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mVolumeDownKeyTriggered = true;
                            mVolumeDownKeyTime = event.getDownTime();
                            mVolumeDownKeyConsumedByScreenshotChord = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenrecordChordAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingScreenrecordChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (isScreenOn && !mVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mVolumeUpKeyTriggered = true;
                            mVolumeUpKeyTime = event.getDownTime();
                            mVolumeUpKeyConsumedByScreenrecordChord = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            interceptScreenrecordChord();
                        }
                    } else {
                        mVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingScreenrecordChordAction();
                    }
                }
                if (down) {
                    ITelephony telephonyService = getTelephonyService();
                    if (telephonyService != null) {
                        try {
                            if (telephonyService.isRinging()) {
                                // If an incoming call is ringing, either VOLUME key means
                                // "silence ringer".  We handle these keys here, rather than
                                // in the InCallScreen, to make sure we'll respond to them
                                // even if the InCallScreen hasn't come to the foreground yet.
                                // Look for the DOWN event here, to agree with the "fallback"
                                // behavior in the InCallScreen.
                                Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                                // Silence the ringer.  (It's safe to call this
                                // even if the ringer has already been silenced.)
                                telephonyService.silenceRinger();
                                // And *don't* pass this key thru to the current activity
                                // (which is probably the InCallScreen.)
                                result &= ~ACTION_PASS_TO_USER;
                                break;
                            }
                            if (telephonyService.isOffhook() && (result & ACTION_PASS_TO_USER) == 0) {
                                // If we are in call but we decided not to pass the key to
                                // the application, handle the volume change here.
                                handleVolumeKey(AudioManager.STREAM_VOICE_CALL, keyCode);
                                break;
                            }
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                }
                if (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE && (result & ACTION_PASS_TO_USER) == 0) {
                    if (isMusicActive() && mVolumeMusicControl && down) {
                        mIsVolumeKeyLongPress = false;
                        Message msg = null;
                        if (event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP) {
                            msg = createMediaEventMessage(event, MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK, KeyEvent.KEYCODE_MEDIA_NEXT);
                        } else if (event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_DOWN) {
                            msg = createMediaEventMessage(event, MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK, KeyEvent.KEYCODE_MEDIA_PREVIOUS);
                        }
                        if (msg != null) {
                            msg.setAsynchronous(true);
                            mHandler.sendMessageDelayed(msg, ViewConfiguration.getLongPressTimeout());
                        }
                        break;
                    } else {
                        if (mVolumeMusicControl && !down) {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            if (mIsVolumeKeyLongPress) {
                                break;
                            }
                        }
                        if (!isScreenOn && !mVolumeWakeScreen) {
                            handleVolumeKey(AudioManager.STREAM_MUSIC, keyCode);
                        }
                    }
                    if (isScreenOn || !mVolumeWakeScreen) {
                        break;
                    } else {
                        result |= ACTION_WAKE_UP;
                        break;
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    ITelephony telephonyService = getTelephonyService();
                    boolean hungUp = false;
                    if (telephonyService != null) {
                        try {
                            hungUp = telephonyService.endCall();
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                    interceptPowerKeyDown(!isScreenOn || hungUp);
                } else {
                    if (interceptPowerKeyUp(canceled)) {
                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                            if (goHome()) {
                                break;
                            }
                        }
                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                            result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    if (mImmersiveModeStyle == 0) {
                        mImmersiveModeConfirmation.onPowerKeyDown(isScreenOn, event.getDownTime(), isImmersiveMode(mLastSystemUiFlags));
                    }
                    if (isScreenOn && !mPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mPowerKeyTriggered = true;
                        mPowerKeyTime = event.getDownTime();
                        interceptScreenshotChord();
                        interceptScreenrecordChord();
                    }
                    ITelephony telephonyService = getTelephonyService();
                    boolean hungUp = false;
                    if (telephonyService != null) {
                        try {
                            if (telephonyService.isRinging()) {
                                // Pressing Power while there's a ringing incoming
                                // call should silence the ringer.
                                telephonyService.silenceRinger();
                            } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telephonyService.isOffhook()) {
                                // Otherwise, if "Power button ends call" is enabled,
                                // the Power button will hang up any current active call.
                                hungUp = telephonyService.endCall();
                            }
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                    interceptPowerKeyDown(!isScreenOn || hungUp || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
                } else {
                    mPowerKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                    cancelPendingScreenrecordChordAction();
                    if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {
                        result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
                    }
                    mPendingPowerKeyUpCanceled = false;
                }
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
            if (down) {
                ITelephony telephonyService = getTelephonyService();
                if (telephonyService != null) {
                    try {
                        if (!telephonyService.isIdle()) {
                            // to avoid music playback.
                            break;
                        }
                    } catch (RemoteException ex) {
                        Log.w(TAG, "ITelephony threw RemoteException", ex);
                    }
                }
            }
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    ITelephony telephonyService = getTelephonyService();
                    if (telephonyService != null) {
                        try {
                            if (telephonyService.isRinging()) {
                                Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                                telephonyService.answerRingingCall();
                                // And *don't* pass this key thru to the current activity
                                // (which is presumably the InCallScreen.)
                                result &= ~ACTION_PASS_TO_USER;
                            }
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                }
                break;
            }
    }
    if (!isScreenOn && mOffscreenGestureSupport) {
        handleOffscreenGesture(event, keyCode, result, down);
    }
    return result;
}
#method_after
@Override
public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags, boolean isScreenOn) {
    if (!mSystemBooted) {
        // If we have not yet booted, don't let key events do anything.
        return 0;
    }
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final int keyCode = event.getKeyCode();
    final boolean isInjected = (policyFlags & WindowManagerPolicy.FLAG_INJECTED) != 0;
    // If screen is off then we treat the case where the keyguard is open but hidden
    // the same as if it were open and in front.
    // This will prevent any keys other than the power button from waking the screen
    // when the keyguard is hidden by another activity.
    final boolean keyguardActive = (mKeyguardDelegate == null ? false : (isScreenOn ? mKeyguardDelegate.isShowingAndNotHidden() : mKeyguardDelegate.isShowing()));
    if (keyCode == KeyEvent.KEYCODE_POWER) {
        policyFlags |= WindowManagerPolicy.FLAG_WAKE;
    }
    boolean isOffscreenWakeKey = false;
    if (mOffscreenGestureSupport) {
        isOffscreenWakeKey = isOffscreenWakeKey(keyCode);
    }
    boolean isWakeKey = (policyFlags & (WindowManagerPolicy.FLAG_WAKE | WindowManagerPolicy.FLAG_WAKE_DROPPED)) != 0 || isOffscreenWakeKey;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTq keycode=" + keyCode + " screenIsOn=" + isScreenOn + " keyguardActive=" + keyguardActive + " policyFlags=" + Integer.toHexString(policyFlags) + " isWakeKey=" + isWakeKey + " scanCode=" + event.getScanCode());
    }
    if (down && (policyFlags & WindowManagerPolicy.FLAG_VIRTUAL) != 0 && event.getRepeatCount() == 0 && mVirtualKeysHapticFeedback) {
        performHapticFeedbackLw(null, HapticFeedbackConstants.VIRTUAL_KEY, false);
    }
    // Basic policy based on screen state and keyguard.
    // FIXME: This policy isn't quite correct.  We shouldn't care whether the screen
    // is on or off, really.  We should care about whether the device is in an
    // interactive state or is in suspend pretending to be "off".
    // The primary screen might be turned off due to proximity sensor or
    // because we are presenting media on an auxiliary screen or remotely controlling
    // the device some other way (which is why we have an exemption here for injected
    // events).
    int result;
    if ((isScreenOn && !mHeadless) || (isInjected && !isWakeKey)) {
        // When the screen is on or if the key is injected pass the key to the application.
        result = ACTION_PASS_TO_USER;
    } else {
        // When the screen is off and the key is not injected, determine whether
        // to wake the device but don't pass the key to the application.
        result = 0;
        if (down && isWakeKey && isWakeKeyWhenScreenOff(keyCode)) {
            result |= ACTION_WAKE_UP;
        }
    }
    // key processing.
    if (mGlobalKeyManager.shouldHandleGlobalKey(keyCode, event)) {
        return result;
    }
    // Handle special keys.
    switch(keyCode) {
        case KeyEvent.KEYCODE_VOLUME_DOWN:
        case KeyEvent.KEYCODE_VOLUME_UP:
        case KeyEvent.KEYCODE_VOLUME_MUTE:
            {
                if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
                    if (down) {
                        if (isScreenOn && !mVolumeDownKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mVolumeDownKeyTriggered = true;
                            mVolumeDownKeyTime = event.getDownTime();
                            mVolumeDownKeyConsumedByScreenshotChord = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenrecordChordAction();
                            interceptScreenshotChord();
                        }
                    } else {
                        mVolumeDownKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingScreenrecordChordAction();
                    }
                } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
                    if (down) {
                        if (isScreenOn && !mVolumeUpKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                            mVolumeUpKeyTriggered = true;
                            mVolumeUpKeyTime = event.getDownTime();
                            mVolumeUpKeyConsumedByScreenrecordChord = false;
                            cancelPendingPowerKeyAction();
                            cancelPendingScreenshotChordAction();
                            interceptScreenrecordChord();
                        }
                    } else {
                        mVolumeUpKeyTriggered = false;
                        cancelPendingScreenshotChordAction();
                        cancelPendingScreenrecordChordAction();
                    }
                }
                if (down) {
                    ITelephony telephonyService = getTelephonyService();
                    if (telephonyService != null) {
                        try {
                            if (telephonyService.isRinging()) {
                                // If an incoming call is ringing, either VOLUME key means
                                // "silence ringer".  We handle these keys here, rather than
                                // in the InCallScreen, to make sure we'll respond to them
                                // even if the InCallScreen hasn't come to the foreground yet.
                                // Look for the DOWN event here, to agree with the "fallback"
                                // behavior in the InCallScreen.
                                Log.i(TAG, "interceptKeyBeforeQueueing:" + " VOLUME key-down while ringing: Silence ringer!");
                                // Silence the ringer.  (It's safe to call this
                                // even if the ringer has already been silenced.)
                                telephonyService.silenceRinger();
                                // And *don't* pass this key thru to the current activity
                                // (which is probably the InCallScreen.)
                                result &= ~ACTION_PASS_TO_USER;
                                break;
                            }
                            if (telephonyService.isOffhook() && (result & ACTION_PASS_TO_USER) == 0) {
                                // If we are in call but we decided not to pass the key to
                                // the application, handle the volume change here.
                                handleVolumeKey(AudioManager.STREAM_VOICE_CALL, keyCode);
                                break;
                            }
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                }
                if (isMusicActive() && (result & ACTION_PASS_TO_USER) == 0) {
                    if (mVolumeMusicControl && down && (keyCode != KeyEvent.KEYCODE_VOLUME_MUTE)) {
                        mIsVolumeKeyLongPress = false;
                        Message msg = null;
                        if (event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_UP) {
                            msg = createMediaEventMessage(event, MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK, KeyEvent.KEYCODE_MEDIA_NEXT);
                        } else if (event.getKeyCode() == KeyEvent.KEYCODE_VOLUME_DOWN) {
                            msg = createMediaEventMessage(event, MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK, KeyEvent.KEYCODE_MEDIA_PREVIOUS);
                        }
                        if (msg != null) {
                            msg.setAsynchronous(true);
                            mHandler.sendMessageDelayed(msg, ViewConfiguration.getLongPressTimeout());
                        }
                        break;
                    } else {
                        if (mVolumeMusicControl && !down) {
                            mHandler.removeMessages(MSG_DISPATCH_VOLKEY_WITH_WAKE_LOCK);
                            if (mIsVolumeKeyLongPress) {
                                break;
                            }
                        }
                        if (!isScreenOn && !mVolumeWakeScreen) {
                            if (mVolumeMusicControl) {
                                // we will only enter this on !down
                                handleVolumeKey(AudioManager.STREAM_MUSIC, keyCode);
                            } else if (!down) {
                                // else we would handle it twice
                                handleVolumeKey(AudioManager.STREAM_MUSIC, keyCode);
                            }
                        }
                    }
                }
                if (isScreenOn || !mVolumeWakeScreen) {
                    break;
                } else {
                    result |= ACTION_WAKE_UP;
                    break;
                }
            }
        case KeyEvent.KEYCODE_ENDCALL:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    ITelephony telephonyService = getTelephonyService();
                    boolean hungUp = false;
                    if (telephonyService != null) {
                        try {
                            hungUp = telephonyService.endCall();
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                    interceptPowerKeyDown(!isScreenOn || hungUp);
                } else {
                    if (interceptPowerKeyUp(canceled)) {
                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_HOME) != 0) {
                            if (goHome()) {
                                break;
                            }
                        }
                        if ((mEndcallBehavior & Settings.System.END_BUTTON_BEHAVIOR_SLEEP) != 0) {
                            result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
                        }
                    }
                }
                break;
            }
        case KeyEvent.KEYCODE_POWER:
            {
                result &= ~ACTION_PASS_TO_USER;
                if (down) {
                    if (mImmersiveModeStyle == 0) {
                        mImmersiveModeConfirmation.onPowerKeyDown(isScreenOn, event.getDownTime(), isImmersiveMode(mLastSystemUiFlags));
                    }
                    if (isScreenOn && !mPowerKeyTriggered && (event.getFlags() & KeyEvent.FLAG_FALLBACK) == 0) {
                        mPowerKeyTriggered = true;
                        mPowerKeyTime = event.getDownTime();
                        interceptScreenshotChord();
                        interceptScreenrecordChord();
                    }
                    ITelephony telephonyService = getTelephonyService();
                    boolean hungUp = false;
                    if (telephonyService != null) {
                        try {
                            if (telephonyService.isRinging()) {
                                // Pressing Power while there's a ringing incoming
                                // call should silence the ringer.
                                telephonyService.silenceRinger();
                            } else if ((mIncallPowerBehavior & Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR_HANGUP) != 0 && telephonyService.isOffhook()) {
                                // Otherwise, if "Power button ends call" is enabled,
                                // the Power button will hang up any current active call.
                                hungUp = telephonyService.endCall();
                            }
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                    interceptPowerKeyDown(!isScreenOn || hungUp || mVolumeDownKeyTriggered || mVolumeUpKeyTriggered);
                } else {
                    mPowerKeyTriggered = false;
                    cancelPendingScreenshotChordAction();
                    cancelPendingScreenrecordChordAction();
                    if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) {
                        result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP;
                    }
                    mPendingPowerKeyUpCanceled = false;
                }
                break;
            }
        case KeyEvent.KEYCODE_MEDIA_PLAY:
        case KeyEvent.KEYCODE_MEDIA_PAUSE:
        case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
            if (down) {
                ITelephony telephonyService = getTelephonyService();
                if (telephonyService != null) {
                    try {
                        if (!telephonyService.isIdle()) {
                            // to avoid music playback.
                            break;
                        }
                    } catch (RemoteException ex) {
                        Log.w(TAG, "ITelephony threw RemoteException", ex);
                    }
                }
            }
        case KeyEvent.KEYCODE_HEADSETHOOK:
        case KeyEvent.KEYCODE_MUTE:
        case KeyEvent.KEYCODE_MEDIA_STOP:
        case KeyEvent.KEYCODE_MEDIA_NEXT:
        case KeyEvent.KEYCODE_MEDIA_PREVIOUS:
        case KeyEvent.KEYCODE_MEDIA_REWIND:
        case KeyEvent.KEYCODE_MEDIA_RECORD:
        case KeyEvent.KEYCODE_MEDIA_FAST_FORWARD:
        case KeyEvent.KEYCODE_MEDIA_AUDIO_TRACK:
            {
                if ((result & ACTION_PASS_TO_USER) == 0) {
                    // Only do this if we would otherwise not pass it to the user. In that
                    // case, the PhoneWindow class will do the same thing, except it will
                    // only do it if the showing app doesn't process the key on its own.
                    // Note that we need to make a copy of the key event here because the
                    // original key event will be recycled when we return.
                    mBroadcastWakeLock.acquire();
                    Message msg = mHandler.obtainMessage(MSG_DISPATCH_MEDIA_KEY_WITH_WAKE_LOCK, new KeyEvent(event));
                    msg.setAsynchronous(true);
                    msg.sendToTarget();
                }
                break;
            }
        case KeyEvent.KEYCODE_CALL:
            {
                if (down) {
                    ITelephony telephonyService = getTelephonyService();
                    if (telephonyService != null) {
                        try {
                            if (telephonyService.isRinging()) {
                                Log.i(TAG, "interceptKeyBeforeQueueing:" + " CALL key-down while ringing: Answer the call!");
                                telephonyService.answerRingingCall();
                                // And *don't* pass this key thru to the current activity
                                // (which is presumably the InCallScreen.)
                                result &= ~ACTION_PASS_TO_USER;
                            }
                        } catch (RemoteException ex) {
                            Log.w(TAG, "ITelephony threw RemoteException", ex);
                        }
                    }
                }
                break;
            }
    }
    if (!isScreenOn && mOffscreenGestureSupport) {
        handleOffscreenGesture(event, keyCode, result, down);
    }
    return result;
}
#end_block

#method_before
protected WindowManager.LayoutParams getActiveDisplayViewLayoutParams() {
    WindowManager.LayoutParams lp = new WindowManager.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.TYPE_BOOT_PROGRESS, 0 | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH, PixelFormat.OPAQUE);
    lp.gravity = Gravity.CENTER;
    lp.setTitle("ActiveDisplayView");
    return lp;
}
#method_after
protected WindowManager.LayoutParams getActiveDisplayViewLayoutParams() {
    WindowManager.LayoutParams lp = new WindowManager.LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.TYPE_NAVIGATION_BAR_PANEL, 0 | WindowManager.LayoutParams.FLAG_FULLSCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED | WindowManager.LayoutParams.FLAG_TOUCHABLE_WHEN_WAKING | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH | WindowManager.LayoutParams.FLAG_SPLIT_TOUCH, PixelFormat.OPAQUE);
    if (ActivityManager.isHighEndGfx()) {
        lp.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;
    }
    lp.gravity = Gravity.BOTTOM | Gravity.START;
    lp.setTitle("ActiveDisplayView");
    return lp;
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ENABLE_ACTIVE_DISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TEXT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_POCKET_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_REDISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BRIGHTNESS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_PRIVACY_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TIMEOUT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_THRESHOLD), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_CONTENT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BYPASS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_AROUND_LOCKSCREEN_RING), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_NOTIF_COUNT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_WALLPAPER), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_ANNOYING), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_DOUBLE_TAP), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.LOCKSCREEN_BLUR_RADIUS), false, this);
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ENABLE_ACTIVE_DISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TEXT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_POCKET_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_REDISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BRIGHTNESS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_PRIVACY_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TIMEOUT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_THRESHOLD), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_CONTENT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BYPASS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.BATTERY_AROUND_LOCKSCREEN_RING), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_NOTIF_COUNT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_ANNOYING), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_DOUBLE_TAP), false, this);
    update();
}
#end_block

#method_before
void unobserve() {
    mContext.getContentResolver().unregisterContentObserver(this);
    if (mDisplayNotifications) {
        unregisterCallbacks();
    }
}
#method_after
void unobserve() {
    mContext.getContentResolver().unregisterContentObserver(this);
    if (mActiveDisplayEnabled) {
        unregisterCallbacks();
    }
}
#end_block

#method_before
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    mDisplayNotifications = Settings.System.getIntForUser(resolver, Settings.System.ENABLE_ACTIVE_DISPLAY, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mDisplayNotificationText = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_TEXT, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mShowAllNotifications = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mHideLowPriorityNotifications = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mPocketMode = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_POCKET_MODE, POCKET_MODE_OFF, UserHandle.USER_CURRENT_OR_SELF);
    mRedisplayTimeout = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_REDISPLAY, 0L, UserHandle.USER_CURRENT_OR_SELF);
    mInitialBrightness = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_BRIGHTNESS, mMaximumBacklight, UserHandle.USER_CURRENT_OR_SELF);
    mSunlightModeEnabled = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    String excludedApps = Settings.System.getStringForUser(resolver, Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS, UserHandle.USER_CURRENT_OR_SELF);
    String privacyApps = Settings.System.getStringForUser(resolver, Settings.System.ACTIVE_DISPLAY_PRIVACY_APPS, UserHandle.USER_CURRENT_OR_SELF);
    mDisplayTimeout = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_TIMEOUT, 8000L, UserHandle.USER_CURRENT_OR_SELF);
    mTurnOffModeEnabled = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mProximityThreshold = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_THRESHOLD, 8000L, UserHandle.USER_CURRENT_OR_SELF);
    mUseActiveDisplayContent = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_CONTENT, 1, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mBypassActiveDisplay = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_BYPASS, 1, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mBatteryLockscreen = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_AROUND_LOCKSCREEN_RING, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mShowNotificationCount = Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mEnableWallpaper = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_WALLPAPER, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mIsAnnoyingThreshold = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_ANNOYING, 0, UserHandle.USER_CURRENT_OR_SELF);
    mEnableDoubleTap = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_DOUBLE_TAP, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mBlurRadius = Settings.System.getIntForUser(resolver, Settings.System.LOCKSCREEN_BLUR_RADIUS, mBlurRadius, UserHandle.USER_CURRENT_OR_SELF);
    createExcludedAppsSet(excludedApps);
    createPrivacyAppsSet(privacyApps);
    int brightnessMode = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, -1, UserHandle.USER_CURRENT_OR_SELF);
    if (mBrightnessMode != brightnessMode) {
        mBrightnessMode = brightnessMode;
        mUserBrightnessLevel = -1;
    }
    if (!mDisplayNotifications || mRedisplayTimeout <= 0) {
        cancelRedisplayTimer();
    }
    if (mDisplayNotifications) {
        registerCallbacks();
    } else {
        unregisterCallbacks();
    }
    updateCustomBackground(mEnableWallpaper);
}
#method_after
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    mActiveDisplayEnabled = Settings.System.getIntForUser(resolver, Settings.System.ENABLE_ACTIVE_DISPLAY, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mDisplayNotificationText = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_TEXT, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mShowAllNotifications = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mHideLowPriorityNotifications = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mPocketMode = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_POCKET_MODE, POCKET_MODE_OFF, UserHandle.USER_CURRENT_OR_SELF);
    mRedisplayTimeout = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_REDISPLAY, 0L, UserHandle.USER_CURRENT_OR_SELF);
    mInitialBrightness = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_BRIGHTNESS, mMaximumBacklight, UserHandle.USER_CURRENT_OR_SELF);
    mSunlightModeEnabled = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    String excludedApps = Settings.System.getStringForUser(resolver, Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS, UserHandle.USER_CURRENT_OR_SELF);
    String privacyApps = Settings.System.getStringForUser(resolver, Settings.System.ACTIVE_DISPLAY_PRIVACY_APPS, UserHandle.USER_CURRENT_OR_SELF);
    mDisplayTimeout = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_TIMEOUT, 8000L, UserHandle.USER_CURRENT_OR_SELF);
    mTurnOffModeEnabled = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mProximityThreshold = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_THRESHOLD, 8000L, UserHandle.USER_CURRENT_OR_SELF);
    mUseActiveDisplayContent = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_CONTENT, 1, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mBypassActiveDisplay = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_BYPASS, 1, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mBatteryLockscreen = Settings.System.getIntForUser(resolver, Settings.System.BATTERY_AROUND_LOCKSCREEN_RING, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mShowNotificationCount = Settings.System.getIntForUser(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mIsAnnoyingThreshold = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_ANNOYING, 0, UserHandle.USER_CURRENT_OR_SELF);
    mEnableDoubleTap = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_DOUBLE_TAP, 0, UserHandle.USER_CURRENT_OR_SELF) != 0;
    createExcludedAppsSet(excludedApps);
    createPrivacyAppsSet(privacyApps);
    int brightnessMode = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, -1, UserHandle.USER_CURRENT_OR_SELF);
    if (mBrightnessMode != brightnessMode) {
        mBrightnessMode = brightnessMode;
        mUserBrightnessLevel = -1;
    }
    if (!mActiveDisplayEnabled || mRedisplayTimeout <= 0) {
        cancelRedisplayTimer();
    }
    if (mActiveDisplayEnabled) {
        registerCallbacks();
    } else {
        unregisterCallbacks();
    }
}
#end_block

#method_before
@Override
public synchronized void onFar() {
    mProximityIsFar = true;
    if (!isScreenOn() && mPocketMode != POCKET_MODE_OFF && !isOnCall() && mDisplayNotifications && !inQuietHours()) {
        if ((System.currentTimeMillis() >= (mPocketTime + mProximityThreshold)) && (mPocketTime != 0)) {
            if (mNotification == null) {
                mNotification = getNextAvailableNotification();
            }
            if (mNotification != null) {
                turnScreenOnbySensor();
                showNotification(mNotification, true);
            } else if (mPocketMode == POCKET_MODE_ALWAYS) {
                turnScreenOnbySensor();
                if (isKeyguardSecure()) {
                    showNothing();
                } else {
                    showTime();
                }
            }
        }
    }
}
#method_after
@Override
public synchronized void onFar() {
    mProximityIsFar = true;
    if (!isScreenOn() && mPocketMode != POCKET_MODE_OFF && !isOnCall() && mActiveDisplayEnabled && !inQuietHours()) {
        if ((System.currentTimeMillis() >= (mPocketTime + mProximityThreshold)) && (mPocketTime != 0)) {
            if (mNotification == null) {
                mNotification = getNextAvailableNotification();
            }
            if (mNotification != null) {
                turnScreenOnbySensor();
                showNotification(mNotification, true);
            } else if (mPocketMode == POCKET_MODE_ALWAYS) {
                turnScreenOnbySensor();
                if (isKeyguardSecure()) {
                    showNothing();
                } else {
                    showTime();
                }
            }
        }
    }
}
#end_block

#method_before
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mContentsHost = (ImageView) findViewById(R.id.active_view_host);
    updateCustomBackground(mEnableWallpaper);
    mContents = (FrameLayout) findViewById(R.id.active_view_contents);
    makeActiveDisplayView(mCreationOrientation, false);
}
#method_after
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    mContents = (FrameLayout) findViewById(R.id.active_view_contents);
    makeActiveDisplayView(mCreationOrientation, false);
}
#end_block

#method_before
private void handleShowNotification(boolean ping) {
    if (!mDisplayNotifications || mNotification == null || inQuietHours())
        return;
    handleShowNotificationView();
    setActiveNotification(mNotification, true);
    inflateRemoteView(mNotification);
    if (!isScreenOn()) {
        turnScreenOn();
    }
    if (ping)
        mGlowPadView.ping();
}
#method_after
private void handleShowNotification(boolean ping) {
    if (!mActiveDisplayEnabled || mNotification == null || inQuietHours())
        return;
    handleShowNotificationView();
    setActiveNotification(mNotification, true);
    inflateRemoteView(mNotification);
    if (!isScreenOn()) {
        turnScreenOn();
    }
    if (ping)
        mGlowPadView.ping();
}
#end_block

#method_before
private void onScreenTurnedOff() {
    updateCustomBackground(mEnableWallpaper);
    enableProximitySensor();
    mWakedByPocketMode = false;
    hideNotificationView();
    cancelTimeoutTimer();
    if (mRedisplayTimeout > 0) {
        updateRedisplayTimer();
    }
}
#method_after
private void onScreenTurnedOff() {
    enableProximitySensor();
    mWakedByPocketMode = false;
    hideNotificationView();
    cancelTimeoutTimer();
    if (mRedisplayTimeout > 0) {
        updateRedisplayTimer();
    }
}
#end_block

#method_before
private void turnScreenOnbySensor() {
    if (mTurnOffModeEnabled && mDisplayNotifications) {
        mWakedByPocketMode = true;
    }
}
#method_after
private void turnScreenOnbySensor() {
    if (mTurnOffModeEnabled && mActiveDisplayEnabled) {
        mWakedByPocketMode = true;
    }
}
#end_block

#method_before
private void enableProximitySensor() {
    if (mPocketMode != POCKET_MODE_OFF && mDisplayNotifications) {
        Log.i(TAG, "ActiveDisplay: enable ProximitySensor");
        mProximityIsFar = true;
        mProximitySensorManager.enable();
    }
}
#method_after
private void enableProximitySensor() {
    if (mPocketMode != POCKET_MODE_OFF && mActiveDisplayEnabled) {
        Log.i(TAG, "ActiveDisplay: enable ProximitySensor");
        mProximityIsFar = true;
        mProximitySensorManager.enable();
    }
}
#end_block

#method_before
private void registerBroadcastReceiver() {
    IntentFilter filter = new IntentFilter();
    filter.addAction(ACTION_REDISPLAY_NOTIFICATION);
    filter.addAction(ACTION_DISPLAY_TIMEOUT);
    filter.addAction(ACTION_PHONE_STATE);
    filter.addAction(ACTION_UNLOCK_DEVICE);
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    filter.addAction(Intent.ACTION_WALLPAPER_CHANGED);
    mContext.registerReceiver(mBroadcastReceiver, filter);
}
#method_after
private void registerBroadcastReceiver() {
    IntentFilter filter = new IntentFilter();
    filter.addAction(ACTION_REDISPLAY_NOTIFICATION);
    filter.addAction(ACTION_DISPLAY_TIMEOUT);
    filter.addAction(ACTION_PHONE_STATE);
    filter.addAction(ACTION_UNLOCK_DEVICE);
    filter.addAction(Intent.ACTION_BATTERY_CHANGED);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    mContext.registerReceiver(mBroadcastReceiver, filter);
}
#end_block

#method_before
private void updateOtherNotifications() {
    mOverflowNotifications.post(new Runnable() {

        @Override
        public void run() {
            try {
                // check if other clearable notifications exist and if so display the next one
                StatusBarNotification[] sbns = mNM.getActiveNotificationsFromSystemListener(mNotificationListener);
                mOverflowNotifications.removeAllViews();
                for (int i = sbns.length - 1; i >= 0; i--) {
                    if (isValidNotification(sbns[i]) && mOverflowNotifications.getChildCount() < MAX_OVERFLOW_ICONS) {
                        boolean updateOther = false;
                        RoundedImageView iv = new RoundedImageView(mContext);
                        if (mOverflowNotifications.getChildCount() < (MAX_OVERFLOW_ICONS - 1)) {
                            Drawable iconDrawable = getIconDrawable(sbns[i]);
                            if (iconDrawable != null) {
                                updateOther = true;
                                iv.setImageDrawable(iconDrawable);
                                iv.setTag(sbns[i]);
                                if (sbns[i].getPackageName().equals(mNotification.getPackageName()) && sbns[i].getId() == mNotification.getId()) {
                                    if (mEnableWallpaper) {
                                        iv.setBackgroundResource(R.drawable.ad_active_notification_background_blur);
                                    } else {
                                        iv.setBackgroundResource(R.drawable.ad_active_notification_background);
                                    }
                                } else {
                                    iv.setBackgroundResource(0);
                                }
                            }
                        } else {
                            updateOther = true;
                            iv.setImageResource(R.drawable.ic_ad_morenotifications);
                        }
                        iv.setPadding(mIconPadding, mIconPadding, mIconPadding, mIconPadding);
                        iv.setScaleType(RoundedImageView.ScaleType.FIT_CENTER);
                        if (updateOther) {
                            mOverflowNotifications.addView(iv, mOverflowLayoutParams);
                        }
                    }
                }
            } catch (RemoteException re) {
            } catch (NullPointerException npe) {
            }
        }
    });
}
#method_after
private void updateOtherNotifications() {
    mOverflowNotifications.post(new Runnable() {

        @Override
        public void run() {
            try {
                // check if other clearable notifications exist and if so display the next one
                StatusBarNotification[] sbns = mNM.getActiveNotificationsFromSystemListener(mNotificationListener);
                mOverflowNotifications.removeAllViews();
                for (int i = sbns.length - 1; i >= 0; i--) {
                    if (isValidNotification(sbns[i]) && mOverflowNotifications.getChildCount() < MAX_OVERFLOW_ICONS) {
                        boolean updateOther = false;
                        RoundedImageView iv = new RoundedImageView(mContext);
                        if (mOverflowNotifications.getChildCount() < (MAX_OVERFLOW_ICONS - 1)) {
                            Drawable iconDrawable = getIconDrawable(sbns[i]);
                            if (iconDrawable != null) {
                                updateOther = true;
                                iv.setImageDrawable(iconDrawable);
                                iv.setTag(sbns[i]);
                                if (sbns[i].getPackageName().equals(mNotification.getPackageName()) && sbns[i].getId() == mNotification.getId()) {
                                    if (mUseActiveDisplayContent) {
                                        iv.setBackgroundResource(R.drawable.ad_active_notification_background_blur);
                                    } else {
                                        iv.setBackgroundResource(R.drawable.ad_active_notification_background);
                                    }
                                } else {
                                    iv.setBackgroundResource(0);
                                }
                            }
                        } else {
                            updateOther = true;
                            iv.setImageResource(R.drawable.ic_ad_morenotifications);
                        }
                        iv.setPadding(mIconPadding, mIconPadding, mIconPadding, mIconPadding);
                        iv.setScaleType(RoundedImageView.ScaleType.FIT_CENTER);
                        if (updateOther) {
                            mOverflowNotifications.addView(iv, mOverflowLayoutParams);
                        }
                    }
                }
            } catch (RemoteException re) {
            } catch (NullPointerException npe) {
            }
        }
    });
}
#end_block

#method_before
private RemoteViews applyStandardTemplate(Notification notification, StatusBarNotification sbn) {
    RemoteViews contentView = new RemoteViews(mContext.getPackageName(), R.layout.active_display_notification);
    NotificationData nd = NotificationUtils.getNotificationData(mContext, sbn);
    if (nd == null) {
        return null;
    }
    long when = notification.when;
    int notificationIconResource = notification.icon;
    String privacyApps = getResources().getString(R.string.active_display_privacy_content);
    boolean isPrivacy = isPrivacyApp(sbn);
    if (mEnableWallpaper) {
        contentView.setInt(R.id.notification_content, "setBackgroundColor", R.color.ad_notification_background_color);
    }
    if (nd.iconApp != null) {
        contentView.setImageViewBitmap(R.id.notificationicon, nd.iconApp);
    } else {
        contentView.setImageViewResource(R.id.notificationicon, notificationIconResource);
    }
    if (nd.titleText != null) {
        contentView.setTextViewText(R.id.notificationtitle, nd.titleText);
    }
    if (nd.getLargeMessage() != null) {
        if (isPrivacy) {
            contentView.setTextViewText(R.id.notificationtext, privacyApps);
        } else {
            contentView.setTextViewText(R.id.notificationtext, nd.getLargeMessage());
        }
    } else {
        if (nd.tickerText != null) {
            if (isPrivacy) {
                contentView.setTextViewText(R.id.notificationtext, privacyApps);
            } else {
                contentView.setTextViewText(R.id.notificationtext, nd.tickerText);
            }
        }
    }
    if (nd.iconAppSmall != null) {
        contentView.setImageViewBitmap(R.id.notificationiconsmall, nd.iconAppSmall);
    } else {
        contentView.setImageViewResource(R.id.notificationiconsmall, notificationIconResource);
    }
    if (nd.infoText != null) {
        contentView.setTextViewText(R.id.notificationinfo, nd.infoText);
    }
    if (when != 0) {
        contentView.setLong(R.id.notificationtime, "setTime", when);
    }
    return contentView;
}
#method_after
private RemoteViews applyStandardTemplate(Notification notification, StatusBarNotification sbn) {
    RemoteViews contentView = new RemoteViews(mContext.getPackageName(), R.layout.active_display_notification);
    NotificationData nd = NotificationUtils.getNotificationData(mContext, sbn);
    if (nd == null) {
        return null;
    }
    long when = notification.when;
    int notificationIconResource = notification.icon;
    String privacyApps = getResources().getString(R.string.active_display_privacy_content);
    boolean isPrivacy = isPrivacyApp(sbn);
    if (nd.iconApp != null) {
        contentView.setImageViewBitmap(R.id.notificationicon, nd.iconApp);
    } else {
        contentView.setImageViewResource(R.id.notificationicon, notificationIconResource);
    }
    if (nd.titleText != null) {
        contentView.setTextViewText(R.id.notificationtitle, nd.titleText);
    }
    if (nd.getLargeMessage() != null) {
        if (isPrivacy) {
            contentView.setTextViewText(R.id.notificationtext, privacyApps);
        } else {
            contentView.setTextViewText(R.id.notificationtext, nd.getLargeMessage());
        }
    } else {
        if (nd.tickerText != null) {
            if (isPrivacy) {
                contentView.setTextViewText(R.id.notificationtext, privacyApps);
            } else {
                contentView.setTextViewText(R.id.notificationtext, nd.tickerText);
            }
        }
    }
    if (nd.iconAppSmall != null) {
        contentView.setImageViewBitmap(R.id.notificationiconsmall, nd.iconAppSmall);
    } else {
        contentView.setImageViewResource(R.id.notificationiconsmall, notificationIconResource);
    }
    if (nd.infoText != null) {
        contentView.setTextViewText(R.id.notificationinfo, nd.infoText);
    }
    if (when != 0) {
        contentView.setLong(R.id.notificationtime, "setTime", when);
    }
    return contentView;
}
#end_block

#method_before
private void launchNotificationPendingIntent() {
    if (mNotification != null) {
        PendingIntent contentIntent = mNotification.getNotification().contentIntent;
        if (contentIntent != null) {
            try {
                contentIntent.send();
            } catch (CanceledException ce) {
            }
            KeyguardTouchDelegate.getInstance(mContext).dismiss();
        }
        try {
            if (mNotification.isClearable()) {
                mNM.cancelNotificationFromSystemListener(mNotificationListener, mNotification.getPackageName(), mNotification.getTag(), mNotification.getId());
            }
        } catch (RemoteException e) {
        } catch (NullPointerException npe) {
        }
        mNotification = null;
    }
}
#method_after
private void launchNotificationPendingIntent() {
    if (mNotification != null) {
        PendingIntent contentIntent = mNotification.getNotification().contentIntent;
        if (contentIntent != null) {
            try {
                Intent intent = contentIntent.getIntent();
                intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_CLEAR_TOP);
                contentIntent.send();
            } catch (CanceledException ce) {
            }
            KeyguardTouchDelegate.getInstance(mContext).dismiss();
        }
        try {
            if (mNotification.isClearable()) {
                mNM.cancelNotificationFromSystemListener(mNotificationListener, mNotification.getPackageName(), mNotification.getTag(), mNotification.getId());
            }
        } catch (RemoteException e) {
        } catch (NullPointerException npe) {
        }
        mNotification = null;
    }
}
#end_block

#method_before
private void onScreenTurnedOff() {
    enableProximitySensor();
    mTurnOffTime = System.currentTimeMillis();
    mWakedByPocketMode = false;
    hideNotificationView();
    cancelTimeoutTimer();
    if (mRedisplayTimeout > 0) {
        updateRedisplayTimer();
    }
}
#method_after
private void onScreenTurnedOff() {
    enableProximitySensor();
    mTurnOffTime = System.currentTimeMillis();
    mWakedByPocketMode = false;
    hideNotificationView();
    cancelTimeoutTimer();
    if (mRedisplayTimeout > 0) {
        updateRedisplayTimer();
    }
    if (mContentsHost != null) {
        mContentsHost.updateCustomBackground(mEnableWallpaper);
    }
}
#end_block

#method_before
private void setBrightness(int brightness) {
    final ContentResolver resolver = mContext.getContentResolver();
    mBrightnessMode = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC, UserHandle.USER_CURRENT_OR_SELF);
    if (mBrightnessMode != Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {
        mUserBrightnessLevel = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS, mMaximumBacklight, UserHandle.USER_CURRENT_OR_SELF);
        final int level = brightness + mMinimumBacklight;
        Settings.System.putInt(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);
        try {
            mPM.setTemporaryScreenBrightnessSettingOverride(level);
        } catch (RemoteException e) {
        }
    }
}
#method_after
private void setBrightness(int brightness) {
    final ContentResolver resolver = mContext.getContentResolver();
    mBrightnessMode = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC, UserHandle.USER_CURRENT_OR_SELF);
    if (mBrightnessMode != Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {
        mUserBrightnessLevel = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS, mMaximumBacklight, UserHandle.USER_CURRENT_OR_SELF);
        final int level = brightness;
        Settings.System.putInt(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);
        try {
            mPM.setTemporaryScreenBrightnessSettingOverride(level);
        } catch (RemoteException e) {
        }
    }
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(ENABLED_NOTIFICATION_LISTENERS_URI, false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_START), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_END), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_MUTE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_STILL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_DIM), false, this, UserHandle.USER_ALL);
    update(null);
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(ENABLED_NOTIFICATION_LISTENERS_URI, false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_ON_NOTIFICATION_LED), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_ENABLED), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_START), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_END), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_MUTE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_STILL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUIET_HOURS_DIM), false, this, UserHandle.USER_ALL);
    update(null);
}
#end_block

#method_before
public void update(Uri uri) {
    ContentResolver resolver = mContext.getContentResolver();
    // LED enabled
    mNotificationPulseEnabled = Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE, mNotificationPulseEnabled ? 1 : 0, UserHandle.USER_CURRENT) != 0;
    // LED default color
    mDefaultNotificationColor = Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR, mDefaultNotificationColor, UserHandle.USER_CURRENT);
    // LED default on MS
    mDefaultNotificationLedOn = Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON, mDefaultNotificationLedOn, UserHandle.USER_CURRENT);
    // LED default off MS
    mDefaultNotificationLedOff = Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF, mDefaultNotificationLedOff, UserHandle.USER_CURRENT);
    // LED custom notification colors
    mNotificationPulseCustomLedValues.clear();
    if (Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE, 0, UserHandle.USER_CURRENT) != 0) {
        parseNotificationPulseCustomValuesString(Settings.System.getStringForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES, UserHandle.USER_CURRENT));
    }
    if (uri == null || ENABLED_NOTIFICATION_LISTENERS_URI.equals(uri)) {
        rebindListenerServices();
    }
}
#method_after
public void update(Uri uri) {
    ContentResolver resolver = mContext.getContentResolver();
    // LED enabled
    mNotificationPulseEnabled = Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE, mNotificationPulseEnabled ? 1 : 0, UserHandle.USER_CURRENT) != 0;
    // LED default color
    mDefaultNotificationColor = Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_COLOR, mDefaultNotificationColor, UserHandle.USER_CURRENT);
    // LED default on MS
    mDefaultNotificationLedOn = Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_ON, mDefaultNotificationLedOn, UserHandle.USER_CURRENT);
    // LED default off MS
    mDefaultNotificationLedOff = Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE_DEFAULT_LED_OFF, mDefaultNotificationLedOff, UserHandle.USER_CURRENT);
    // LED custom notification colors
    mNotificationPulseCustomLedValues.clear();
    if (Settings.System.getIntForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_ENABLE, 0, UserHandle.USER_CURRENT) != 0) {
        parseNotificationPulseCustomValuesString(Settings.System.getStringForUser(resolver, Settings.System.NOTIFICATION_LIGHT_PULSE_CUSTOM_VALUES, UserHandle.USER_CURRENT));
    }
    // LED screen on notification
    mScreenOnNotificationLed = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_ON_NOTIFICATION_LED, 0, UserHandle.USER_CURRENT) == 1;
    if (uri == null || ENABLED_NOTIFICATION_LISTENERS_URI.equals(uri)) {
        rebindListenerServices();
    }
}
#end_block

#method_before
private void updateLightsLocked() {
    boolean ScreenOnNotificationLed = Settings.System.getInt(mContext.getContentResolver(), Settings.System.SCREEN_ON_NOTIFICATION_LED, 1) == 1;
    // handle notification lights
    if (mLedNotification == null) {
        // get next notification, if any
        int n = mLights.size();
        if (n > 0) {
            mLedNotification = mLights.get(n - 1);
        }
    }
    // Don't flash while we are in a call or screen is on or its disabled
    if (mLedNotification == null || mInCall || (mScreenOn && (!ScreenOnNotificationLed)) || !mNotificationPulseEnabled || (QuietHoursHelper.inQuietHours(mContext, Settings.System.QUIET_HOURS_DIM))) {
        mNotificationLight.turnOff();
    } else if (mNotificationPulseEnabled) {
        final Notification ledno = mLedNotification.sbn.getNotification();
        final NotificationLedValues ledValues = getLedValuesForNotification(mLedNotification);
        int ledARGB = ledno.ledARGB;
        int ledOnMS = ledno.ledOnMS;
        int ledOffMS = ledno.ledOffMS;
        if (ledValues != null) {
            ledARGB = ledValues.color != 0 ? ledValues.color : mDefaultNotificationColor;
            ledOnMS = ledValues.onMS >= 0 ? ledValues.onMS : mDefaultNotificationLedOn;
            ledOffMS = ledValues.offMS >= 0 ? ledValues.offMS : mDefaultNotificationLedOff;
        } else if ((ledno.defaults & Notification.DEFAULT_LIGHTS) != 0) {
            ledARGB = mDefaultNotificationColor;
            ledOnMS = mDefaultNotificationLedOn;
            ledOffMS = mDefaultNotificationLedOff;
        }
        // pulse repeatedly
        mNotificationLight.setFlashing(ledARGB, LightsService.LIGHT_FLASH_TIMED, ledOnMS, ledOffMS);
    }
}
#method_after
private void updateLightsLocked() {
    // handle notification lights
    if (mLedNotification == null) {
        // get next notification, if any
        int n = mLights.size();
        if (n > 0) {
            mLedNotification = mLights.get(n - 1);
        }
    }
    // Don't flash while we are in a call or screen is on or its disabled
    if (mLedNotification == null || mInCall || (mScreenOn && !mScreenOnNotificationLed) || !mNotificationPulseEnabled || (QuietHoursHelper.inQuietHours(mContext, Settings.System.QUIET_HOURS_DIM))) {
        mNotificationLight.turnOff();
    } else if (mNotificationPulseEnabled) {
        final Notification ledno = mLedNotification.sbn.getNotification();
        final NotificationLedValues ledValues = getLedValuesForNotification(mLedNotification);
        int ledARGB = ledno.ledARGB;
        int ledOnMS = ledno.ledOnMS;
        int ledOffMS = ledno.ledOffMS;
        if (ledValues != null) {
            ledARGB = ledValues.color != 0 ? ledValues.color : mDefaultNotificationColor;
            ledOnMS = ledValues.onMS >= 0 ? ledValues.onMS : mDefaultNotificationLedOn;
            ledOffMS = ledValues.offMS >= 0 ? ledValues.offMS : mDefaultNotificationLedOff;
        } else if ((ledno.defaults & Notification.DEFAULT_LIGHTS) != 0) {
            ledARGB = mDefaultNotificationColor;
            ledOnMS = mDefaultNotificationLedOn;
            ledOffMS = mDefaultNotificationLedOff;
        }
        // pulse repeatedly
        mNotificationLight.setFlashing(ledARGB, LightsService.LIGHT_FLASH_TIMED, ledOnMS, ledOffMS);
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.top);
    pagerAdapter = new MyAdapter(getFragmentManager(), this);
    actionBar = getActionBar();
    viewPager = (ViewPager) findViewById(R.id.viewPager);
    pagerTabStrip = (PagerTabStrip) findViewById(R.id.pagerTabStrip);
    Intent serviceIntent = new Intent(this, HeadsetService.class);
    startService(serviceIntent);
    actionBar.setDisplayShowTitleEnabled(true);
    viewPager.setAdapter(pagerAdapter);
    pagerTabStrip.setDrawFullUnderline(true);
    pagerTabStrip.setTabIndicatorColor(getResources().getColor(android.R.color.holo_blue_light));
}
#method_after
// ==================================
// Overridden Methods
// ==================================
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    mPreferences = PreferenceManager.getDefaultSharedPreferences(this);
    mUserLearnedDrawer = mPreferences.getBoolean(PREF_USER_LEARNED_DRAWER, false);
    if (getResources().getBoolean(R.bool.config_allow_toggle_tabbed)) {
        mIsTabbed = mPreferences.getBoolean(PREF_IS_TABBED, getResources().getBoolean(R.bool.config_use_tabbed));
    } else {
        mIsTabbed = getResources().getBoolean(R.bool.config_use_tabbed);
    }
    mTitle = getTitle();
    ActionBar mActionBar = getActionBar();
    mActionBar.setDisplayHomeAsUpEnabled(true);
    mActionBar.setHomeButtonEnabled(true);
    mActionBar.setDisplayShowTitleEnabled(true);
    if (savedInstanceState != null) {
        mCurrentSelectedPosition = savedInstanceState.getInt(STATE_SELECTED_POSITION);
        mFromSavedInstanceState = true;
    }
    setUpUi();
}
#end_block

#method_before
@Override
public void onResume() {
    super.onResume();
    ServiceConnection connection = new ServiceConnection() {

        @Override
        public void onServiceConnected(ComponentName name, IBinder binder) {
            HeadsetService service = ((HeadsetService.LocalBinder) binder).getService();
            String routing = service.getAudioOutputRouting();
            String[] entries = pagerAdapter.getEntries();
            for (int i = 0; i < entries.length; i++) {
                if (routing.equals(entries[i])) {
                    viewPager.setCurrentItem(i);
                    break;
                }
            }
            unbindService(this);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
    };
    Intent serviceIntent = new Intent(this, HeadsetService.class);
    bindService(serviceIntent, connection, 0);
}
#method_after
@Override
public void onResume() {
    super.onResume();
    ServiceConnection connection = new ServiceConnection() {

        @Override
        public void onServiceConnected(ComponentName name, IBinder binder) {
            HeadsetService service = ((HeadsetService.LocalBinder) binder).getService();
            String routing = service.getAudioOutputRouting();
            if (mIsTabbed && viewPager != null) {
                String[] entries = getEntries();
                for (int i = 0; i < entries.length; i++) {
                    if (routing.equals(entries[i])) {
                        viewPager.setCurrentItem(i);
                        break;
                    }
                }
            }
            unbindService(this);
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {
        }
    };
    Intent serviceIntent = new Intent(this, HeadsetService.class);
    bindService(serviceIntent, connection, 0);
}
#end_block

#method_before
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    MenuInflater inflater = getMenuInflater();
    inflater.inflate(R.menu.menu, menu);
    return true;
}
#method_after
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    if (!isDrawerOpen()) {
        getMenuInflater().inflate(mIsTabbed ? R.menu.menu_tabbed : R.menu.menu, menu);
        if (!getResources().getBoolean(R.bool.config_allow_toggle_tabbed)) {
            menu.removeItem(R.id.dsp_action_tabbed);
        }
        getActionBar().setTitle(mTitle);
        return true;
    } else {
        getActionBar().setTitle(getString(R.string.app_name));
        return super.onCreateOptionsMenu(menu);
    }
}
#end_block

#method_before
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    int choice = item.getItemId();
    switch(choice) {
        case R.id.help:
            DialogFragment df = new HelpFragment();
            df.setStyle(DialogFragment.STYLE_NO_TITLE, 0);
            df.show(getFragmentManager(), "help");
            return true;
        case R.id.save_preset:
            savePresetDialog();
            return true;
        case R.id.load_preset:
            loadPresetDialog();
            return true;
        default:
            return false;
    }
}
#method_after
@Override
public boolean onOptionsItemSelected(MenuItem item) {
    if (!mIsTabbed) {
        if (mDrawerToggle.onOptionsItemSelected(item)) {
            return true;
        }
    }
    int choice = item.getItemId();
    switch(choice) {
        case R.id.help:
            DialogFragment df = new HelpFragment();
            df.setStyle(DialogFragment.STYLE_NO_TITLE, 0);
            df.show(getFragmentManager(), "help");
            return true;
        case R.id.save_preset:
            savePresetDialog();
            return true;
        case R.id.load_preset:
            loadPresetDialog();
            return true;
        case R.id.dsp_action_tabbed:
            mIsTabbed = !mIsTabbed;
            mPreferences.edit().putBoolean(PREF_IS_TABBED, mIsTabbed).commit();
            Utils.restartActivity(this);
            return true;
        default:
            return false;
    }
}
#end_block

#method_before
public void savePreset(String name) {
    final String spDir = getApplicationInfo().dataDir + "/shared_prefs/";
    // Copy the SharedPreference to our output directory
    File presetDir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/" + PRESETS_FOLDER + "/" + name);
    presetDir.mkdirs();
    Log.e("DSP", "Saving preset to " + presetDir.getAbsolutePath());
    final String packageName = "com.bel.android.dspmanager.";
    File bluetooth = new File(presetDir, packageName + "bluetooth.xml");
    File headset = new File(presetDir, packageName + "headset.xml");
    File speaker = new File(presetDir, packageName + "speaker.xml");
    try {
        copy(new File(spDir + packageName + "bluetooth.xml"), bluetooth);
        copy(new File(spDir + packageName + "headset.xml"), headset);
        copy(new File(spDir + packageName + "speaker.xml"), speaker);
    } catch (IOException e) {
        Log.e("DSP", "Cannot save preset", e);
    }
}
#method_after
public void savePreset(String name) {
    final String spDir = getApplicationInfo().dataDir + "/shared_prefs/";
    // Copy the SharedPreference to our output directory
    File presetDir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/" + PRESETS_FOLDER + "/" + name);
    presetDir.mkdirs();
    Log.e("DSP", "Saving preset to " + presetDir.getAbsolutePath());
    final String packageName = "com.bel.android.dspmanager.";
    try {
        copy(new File(spDir + packageName + "bluetooth.xml"), new File(presetDir, packageName + "bluetooth.xml"));
        copy(new File(spDir + packageName + "headset.xml"), new File(presetDir, packageName + "headset.xml"));
        copy(new File(spDir + packageName + "speaker.xml"), new File(presetDir, packageName + "speaker.xml"));
        copy(new File(spDir + packageName + "usb.xml"), new File(presetDir, packageName + "usb.xml"));
        if (SoundControlHelper.getSoundControlHelper(DSPManager.this).isSupported()) {
            copy(new File(spDir + packageName + "soundcontrol.xml"), new File(presetDir, packageName + "soundcontrol.xml"));
        }
        if (BoefflaSoundControlHelper.getBoefflaSoundControlHelper(DSPManager.this).getBoefflaSound()) {
            copy(new File(spDir + packageName + "boefflasoundcontrol.xml"), new File(presetDir, packageName + "boefflasoundcontrol.xml"));
        }
        if (WM8994.isSupported(DSPManager.this)) {
            copy(new File(spDir + packageName + "wm8994.xml"), new File(presetDir, packageName + "wm8994.xml"));
        }
    } catch (IOException e) {
        Log.e("DSP", "Cannot save preset", e);
    }
}
#end_block

#method_before
public void loadPreset(String name) {
    // Copy the SharedPreference to our local directory
    File presetDir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/" + PRESETS_FOLDER + "/" + name);
    if (!presetDir.exists())
        presetDir.mkdirs();
    final String packageName = "com.bel.android.dspmanager.";
    final String spDir = getApplicationInfo().dataDir + "/shared_prefs/";
    try {
        copy(new File(presetDir, packageName + "bluetooth.xml"), new File(spDir + packageName + "bluetooth.xml"));
        copy(new File(presetDir, packageName + "headset.xml"), new File(spDir + packageName + "headset.xml"));
        copy(new File(presetDir, packageName + "speaker.xml"), new File(spDir + packageName + "speaker.xml"));
    } catch (IOException e) {
        Log.e("DSP", "Cannot load preset", e);
    }
    // Reload preferences
    startActivity(new Intent(this, DSPManager.class));
    finish();
}
#method_after
public void loadPreset(String name) {
    // Copy the SharedPreference to our local directory
    File presetDir = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/" + PRESETS_FOLDER + "/" + name);
    if (!presetDir.exists())
        presetDir.mkdirs();
    final String packageName = "com.bel.android.dspmanager.";
    final String spDir = getApplicationInfo().dataDir + "/shared_prefs/";
    try {
        copy(new File(presetDir, packageName + "bluetooth.xml"), new File(spDir + packageName + "bluetooth.xml"));
        copy(new File(presetDir, packageName + "headset.xml"), new File(spDir + packageName + "headset.xml"));
        copy(new File(presetDir, packageName + "speaker.xml"), new File(spDir + packageName + "speaker.xml"));
        copy(new File(presetDir, packageName + "usb.xml"), new File(spDir + packageName + "usb.xml"));
        if (SoundControlHelper.getSoundControlHelper(DSPManager.this).isSupported()) {
            copy(new File(presetDir, packageName + "soundcontrol.xml"), new File(spDir + packageName + "soundcontrol.xml"));
            SoundControlHelper.getSoundControlHelper(DSPManager.this).applyValues();
        }
        if (BoefflaSoundControlHelper.getBoefflaSoundControlHelper(DSPManager.this).getBoefflaSound()) {
            copy(new File(presetDir, packageName + "boefflasoundcontrol.xml"), new File(spDir + packageName + "boefflasoundcontrol.xml"));
            BoefflaSoundControlHelper.getBoefflaSoundControlHelper(DSPManager.this).applyValues();
        }
        if (WM8994.isSupported(DSPManager.this)) {
            copy(new File(presetDir, packageName + "wm8994.xml"), new File(spDir + packageName + "wm8994.xml"));
        }
    } catch (IOException e) {
        Log.e("DSP", "Cannot load preset", e);
    }
    // Reload preferences
    startActivity(new Intent(this, DSPManager.class));
    finish();
}
#end_block

#method_before
@Override
public CharSequence getPageTitle(int position) {
    return titles[position];
}
#method_after
@Override
public CharSequence getPageTitle(int position) {
    return titles.get(position).get("TITLE");
}
#end_block

#method_before
@Override
public Fragment getItem(int position) {
    // Determine if fragment is WM8994
    if (entries[position].equals(WM8994.NAME)) {
        return new WM8994();
    } else if (entries[position].equals(SoundControl.NAME)) {
        return new SoundControl();
    } else if (entries[position].equals(BoefflaControl.NAME)) {
        return new BoefflaControl();
    } else {
        final DSPScreen dspFragment = new DSPScreen();
        Bundle b = new Bundle();
        b.putString("config", entries[position]);
        dspFragment.setArguments(b);
        return dspFragment;
    }
}
#method_after
@Override
public Fragment getItem(int position) {
    // Determine if fragment is WM8994
    if (entries[position].equals(WM8994.NAME)) {
        return new WM8994();
    } else if (entries[position].equals(SoundControl.NAME)) {
        return new SoundControl();
    } else if (entries[position].equals(BoefflaSoundControl.NAME)) {
        return new BoefflaSoundControl();
    } else {
        final DSPScreen dspFragment = new DSPScreen();
        Bundle b = new Bundle();
        b.putString("config", entries[position]);
        dspFragment.setArguments(b);
        return dspFragment;
    }
}
#end_block

#method_before
@Override
public void onReceive(Context context, Intent intent) {
    context.startService(new Intent(context, HeadsetService.class));
    if (WM8994.isSupported(context)) {
        WM8994.restore(context);
    }
    if (SoundControlHelper.getSoundControlHelper(context).isSupported()) {
        SoundControlHelper.getSoundControlHelper(context).applyValues();
    }
    if (BoefflaControlHelper.getBoefflaControlHelper(context).isSupported()) {
        BoefflaControlHelper.getBoefflaControlHelper(context).applyValues();
    }
}
#method_after
@Override
public void onReceive(Context context, Intent intent) {
    context.startService(new Intent(context, HeadsetService.class));
    if (WM8994.isSupported(context)) {
        WM8994.restore(context);
    }
    if (SoundControlHelper.getSoundControlHelper(context).isSupported()) {
        SoundControlHelper.getSoundControlHelper(context).applyValues();
    }
    if (BoefflaSoundControlHelper.getBoefflaSoundControlHelper(context).getBoefflaSound()) {
        BoefflaSoundControlHelper.getBoefflaSoundControlHelper(context).applyValues();
    }
}
#end_block

#method_before
@Override
public void onSensorChanged(SensorEvent event) {
    // Make sure we have a valid value.
    if (event.values == null)
        return;
    if (event.values.length == 0)
        return;
    float value = event.values[0];
    mListener.onLightChange(getBooleanFromValue(value));
}
#method_after
@Override
public void onSensorChanged(SensorEvent event) {
    // Make sure we have a valid value.
    if (event.values == null)
        return;
    if (event.values.length == 0)
        return;
    float value = event.values[0];
    // Convert the sensor into a DARKER/BRIGHTER state.
    State state = getStateFromValue(value);
    synchronized (this) {
        // No change in state, do nothing.
        if (state == mLastState)
            return;
        // Keep track of the current state.
        mLastState = state;
        // If we are waiting to reach the darker state and we are now in it, unregister.
        if (mWaitingForDarkerState && mLastState == State.DARKER) {
            unregisterWithoutNotification();
        }
    }
    // Notify the listener of the state change.
    switch(state) {
        case DARKER:
            mListener.onDarker();
            break;
        case BRIGHTER:
            mListener.onBrighter();
            break;
    }
}
#end_block

#method_before
public synchronized void register() {
    // It is okay to register multiple times.
    mSensorManager.registerListener(this, mLightSensor, SensorManager.SENSOR_DELAY_UI);
}
#method_after
public synchronized void register() {
    // It is okay to register multiple times.
    mSensorManager.registerListener(this, mLightSensor, SensorManager.SENSOR_DELAY_UI);
    // We should no longer be waiting for the darker state if we are registering again.
    mWaitingForDarkerState = false;
}
#end_block

#method_before
public void unregister() {
    synchronized (this) {
        unregisterWithoutNotification();
    }
}
#method_after
public void unregister() {
    State lastState;
    synchronized (this) {
        unregisterWithoutNotification();
        lastState = mLastState;
        // Always go back to the DARKER state. That way, when we register again we will get a
        // transition when the sensor gets into the DARKER state.
        mLastState = State.DARKER;
    }
    // Notify the listener if we changed the state to DARKER while unregistering.
    if (lastState != State.DARKER) {
        mListener.onDarker();
    }
}
#end_block

#method_before
private void unregisterWithoutNotification() {
    mSensorManager.unregisterListener(this);
}
#method_after
private void unregisterWithoutNotification() {
    mSensorManager.unregisterListener(this);
    mWaitingForDarkerState = false;
}
#end_block

#method_before
public void disable() {
    if (mLightSensorListener != null && mManagerEnabled) {
        mLightSensorListener.unregister();
        mManagerEnabled = false;
    }
}
#method_after
public void disable(boolean waitForDarkerState) {
    if (mLightSensorListener != null && mManagerEnabled) {
        if (waitForDarkerState) {
            mLightSensorListener.unregisterWhenDarker();
        } else {
            mLightSensorListener.unregister();
        }
        mManagerEnabled = false;
    }
}
#end_block

#method_before
public void start() {
    mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    mWindowManagerService = WindowManagerGlobal.getWindowManagerService();
    mDisplay = mWindowManager.getDefaultDisplay();
    mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.checkService(DreamService.DREAM_SERVICE));
    mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    // set up
    mProvisioningObserver.onChange(false);
    mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.DEVICE_PROVISIONED), true, mProvisioningObserver);
    mBarService = IStatusBarService.Stub.asInterface(ServiceManager.getService(Context.STATUS_BAR_SERVICE));
    mRecents = getComponent(RecentsComponent.class);
    mLocale = mContext.getResources().getConfiguration().locale;
    mLayoutDirection = TextUtils.getLayoutDirectionFromLocale(mLocale);
    // Connect in to the status bar manager service
    StatusBarIconList iconList = new StatusBarIconList();
    ArrayList<IBinder> notificationKeys = new ArrayList<IBinder>();
    ArrayList<StatusBarNotification> notifications = new ArrayList<StatusBarNotification>();
    mCommandQueue = new CommandQueue(this, iconList);
    int[] switches = new int[7];
    ArrayList<IBinder> binders = new ArrayList<IBinder>();
    try {
        mBarService.registerStatusBar(mCommandQueue, iconList, notificationKeys, notifications, switches, binders);
    } catch (RemoteException ex) {
    // If the system process isn't there we're doomed anyway.
    }
    createAndAddWindows();
    disable(switches[0]);
    setSystemUiVisibility(switches[1], 0xffffffff);
    topAppWindowChanged(switches[2] != 0);
    // StatusBarManagerService has a back up of IME token and it's restored here.
    setImeWindowStatus(binders.get(0), switches[3], switches[4]);
    setHardKeyboardStatus(switches[5] != 0, switches[6] != 0);
    // Set up the initial icon state
    int N = iconList.size();
    int viewIndex = 0;
    for (int i = 0; i < N; i++) {
        StatusBarIcon icon = iconList.getIcon(i);
        if (icon != null) {
            addIcon(iconList.getSlot(i), i, viewIndex, icon);
            viewIndex++;
        }
    }
    // Set up the initial notification state
    N = notificationKeys.size();
    if (N == notifications.size()) {
        for (int i = 0; i < N; i++) {
            addNotification(notificationKeys.get(i), notifications.get(i));
        }
    } else {
        Log.wtf(TAG, "Notification list length mismatch: keys=" + N + " notifications=" + notifications.size());
    }
    if (DEBUG) {
        Log.d(TAG, String.format("init: icons=%d disabled=0x%08x lights=0x%08x menu=0x%08x imeButton=0x%08x", iconList.size(), switches[0], switches[1], switches[2], switches[3]));
    }
    mCurrentUserId = ActivityManager.getCurrentUser();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    mContext.registerReceiver(mBroadcastReceiver, filter);
}
#method_after
public void start() {
    mWindowManager = (WindowManager) mContext.getSystemService(Context.WINDOW_SERVICE);
    mWindowManagerService = WindowManagerGlobal.getWindowManagerService();
    mDisplay = mWindowManager.getDefaultDisplay();
    mDreamManager = IDreamManager.Stub.asInterface(ServiceManager.checkService(DreamService.DREAM_SERVICE));
    mPowerManager = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    // set up
    mSettingsObserver.onChange(false);
    mContext.getContentResolver().registerContentObserver(Settings.Global.getUriFor(Settings.Global.DEVICE_PROVISIONED), true, mSettingsObserver);
    mBarService = IStatusBarService.Stub.asInterface(ServiceManager.getService(Context.STATUS_BAR_SERVICE));
    mRecents = getComponent(RecentsComponent.class);
    mLocale = mContext.getResources().getConfiguration().locale;
    mLayoutDirection = TextUtils.getLayoutDirectionFromLocale(mLocale);
    // Connect in to the status bar manager service
    StatusBarIconList iconList = new StatusBarIconList();
    ArrayList<IBinder> notificationKeys = new ArrayList<IBinder>();
    ArrayList<StatusBarNotification> notifications = new ArrayList<StatusBarNotification>();
    mCommandQueue = new CommandQueue(this, iconList);
    int[] switches = new int[7];
    ArrayList<IBinder> binders = new ArrayList<IBinder>();
    try {
        mBarService.registerStatusBar(mCommandQueue, iconList, notificationKeys, notifications, switches, binders);
    } catch (RemoteException ex) {
    // If the system process isn't there we're doomed anyway.
    }
    createAndAddWindows();
    disable(switches[0]);
    setSystemUiVisibility(switches[1], 0xffffffff);
    topAppWindowChanged(switches[2] != 0);
    // StatusBarManagerService has a back up of IME token and it's restored here.
    setImeWindowStatus(binders.get(0), switches[3], switches[4]);
    setHardKeyboardStatus(switches[5] != 0, switches[6] != 0);
    // Set up the initial icon state
    int N = iconList.size();
    int viewIndex = 0;
    for (int i = 0; i < N; i++) {
        StatusBarIcon icon = iconList.getIcon(i);
        if (icon != null) {
            addIcon(iconList.getSlot(i), i, viewIndex, icon);
            viewIndex++;
        }
    }
    // Set up the initial notification state
    N = notificationKeys.size();
    if (N == notifications.size()) {
        for (int i = 0; i < N; i++) {
            addNotification(notificationKeys.get(i), notifications.get(i));
        }
    } else {
        Log.wtf(TAG, "Notification list length mismatch: keys=" + N + " notifications=" + notifications.size());
    }
    if (DEBUG) {
        Log.d(TAG, String.format("init: icons=%d disabled=0x%08x lights=0x%08x menu=0x%08x imeButton=0x%08x", iconList.size(), switches[0], switches[1], switches[2], switches[3]));
    }
    mCurrentUserId = ActivityManager.getCurrentUser();
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_USER_SWITCHED);
    filter.addAction(OmniSwitchConstants.ACTION_SERVICE_START);
    filter.addAction(OmniSwitchConstants.ACTION_SERVICE_STOP);
    mContext.registerReceiver(mBroadcastReceiver, filter);
}
#end_block

#method_before
protected void toggleRecentsActivity() {
    if (mRecents != null) {
        mRecents.toggleRecents(mDisplay, mLayoutDirection, getStatusBarView());
    }
}
#method_after
protected void toggleRecentsActivity() {
    if (isOmniSwitchEnabled()) {
        Intent showIntent = new Intent(OmniSwitchConstants.ACTION_TOGGLE_OVERLAY);
        mContext.sendBroadcastAsUser(showIntent, UserHandle.CURRENT);
    } else {
        if (mRecents != null) {
            mRecents.toggleRecents(mDisplay, mLayoutDirection, getStatusBarView());
        }
    }
}
#end_block

#method_before
protected void preloadRecentTasksList() {
    if (mRecents != null) {
        mRecents.preloadRecentTasksList();
    }
}
#method_after
protected void preloadRecentTasksList() {
    if (!isOmniSwitchEnabled()) {
        if (mRecents != null) {
            mRecents.preloadRecentTasksList();
        }
    }
}
#end_block

#method_before
protected void cancelPreloadingRecentTasksList() {
    if (mRecents != null) {
        mRecents.cancelPreloadingRecentTasksList();
    }
}
#method_after
protected void cancelPreloadingRecentTasksList() {
    if (!isOmniSwitchEnabled()) {
        if (mRecents != null) {
            mRecents.cancelPreloadingRecentTasksList();
        }
    }
}
#end_block

#method_before
protected void closeRecents() {
    if (mRecents != null) {
        mRecents.closeRecents();
    }
}
#method_after
protected void closeRecents() {
    if (isOmniSwitchEnabled()) {
        Intent hideIntent = new Intent(OmniSwitchConstants.ACTION_HIDE_OVERLAY);
        mContext.sendBroadcastAsUser(hideIntent, UserHandle.CURRENT);
    } else {
        if (mRecents != null) {
            mRecents.closeRecents();
        }
    }
}
#end_block

#method_before
protected void addActiveDisplayView() {
    if (mActiveDisplayView == null) {
        mActiveDisplayView = (ActiveDisplayView) View.inflate(mContext, R.layout.active_display, null);
        mWindowManager.addView(mActiveDisplayView, getActiveDisplayViewLayoutParams());
    }
}
#method_after
protected void addActiveDisplayView() {
    if (mActiveDisplayView == null) {
        mActiveDisplayView = (ActiveDisplayView) View.inflate(mContext, R.layout.active_display, null);
        mActiveDisplayView.setBar(this);
        mWindowManager.addView(mActiveDisplayView, getActiveDisplayViewLayoutParams());
    }
}
#end_block

#method_before
@Override
public void onNotificationPosted(final StatusBarNotification sbn) {
    if (shouldShowNotification() && isValidNotification(sbn)) {
        // viewing the notifications
        if (getVisibility() == View.VISIBLE || !isScreenOn()) {
            showNotification(sbn, true);
        }
    }
}
#method_after
@Override
public void onNotificationPosted(final StatusBarNotification sbn) {
    if (shouldShowNotification() && isValidNotification(sbn) && !inQuietHoursDim()) {
        // viewing the notifications
        if (getVisibility() == View.VISIBLE || !isScreenOn()) {
            showNotification(sbn, true);
        }
    }
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ENABLE_ACTIVE_DISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TEXT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_POCKET_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_REDISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BRIGHTNESS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TIMEOUT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_THRESHOLD), false, this);
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ENABLE_ACTIVE_DISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TEXT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_POCKET_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_REDISPLAY), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BRIGHTNESS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_PRIVACY_APPS), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TIMEOUT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_THRESHOLD), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_CONTENT), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACTIVE_DISPLAY_BYPASS), false, this);
    update();
}
#end_block

#method_before
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    mDisplayNotifications = Settings.System.getInt(resolver, Settings.System.ENABLE_ACTIVE_DISPLAY, 0) == 1;
    mDisplayNotificationText = Settings.System.getInt(resolver, Settings.System.ACTIVE_DISPLAY_TEXT, 0) == 1;
    mShowAllNotifications = Settings.System.getInt(resolver, Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS, 0) == 1;
    mHideLowPriorityNotifications = Settings.System.getInt(resolver, Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS, 0) == 1;
    mPocketMode = Settings.System.getInt(resolver, Settings.System.ACTIVE_DISPLAY_POCKET_MODE, POCKET_MODE_OFF);
    mRedisplayTimeout = Settings.System.getLong(resolver, Settings.System.ACTIVE_DISPLAY_REDISPLAY, 0L);
    mInitialBrightness = Settings.System.getInt(resolver, Settings.System.ACTIVE_DISPLAY_BRIGHTNESS, 100) / 100f;
    mSunlightModeEnabled = Settings.System.getInt(resolver, Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE, 0) == 1;
    String excludedApps = Settings.System.getString(resolver, Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS);
    mDisplayTimeout = Settings.System.getLong(resolver, Settings.System.ACTIVE_DISPLAY_TIMEOUT, 8000L);
    mTurnOffModeEnabled = Settings.System.getInt(resolver, Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE, 0) == 1;
    mProximityThreshold = Settings.System.getLong(resolver, Settings.System.ACTIVE_DISPLAY_THRESHOLD, 8000L);
    createExcludedAppsSet(excludedApps);
    int brightnessMode = Settings.System.getInt(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, -1);
    if (mBrightnessMode != brightnessMode) {
        mBrightnessMode = brightnessMode;
        mUserBrightnessLevel = -1;
    }
    if (!mDisplayNotifications || mRedisplayTimeout <= 0) {
        cancelRedisplayTimer();
    }
    if (mDisplayNotifications) {
        registerCallbacks();
    } else {
        unregisterCallbacks();
    }
}
#method_after
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    mDisplayNotifications = Settings.System.getIntForUser(resolver, Settings.System.ENABLE_ACTIVE_DISPLAY, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mDisplayNotificationText = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_TEXT, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mShowAllNotifications = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mHideLowPriorityNotifications = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mPocketMode = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_POCKET_MODE, POCKET_MODE_OFF, UserHandle.USER_CURRENT_OR_SELF);
    mRedisplayTimeout = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_REDISPLAY, 0L, UserHandle.USER_CURRENT_OR_SELF);
    mInitialBrightness = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_BRIGHTNESS, mMaximumBacklight, UserHandle.USER_CURRENT_OR_SELF);
    mSunlightModeEnabled = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    String excludedApps = Settings.System.getStringForUser(resolver, Settings.System.ACTIVE_DISPLAY_EXCLUDED_APPS, UserHandle.USER_CURRENT_OR_SELF);
    String privacyApps = Settings.System.getStringForUser(resolver, Settings.System.ACTIVE_DISPLAY_PRIVACY_APPS, UserHandle.USER_CURRENT_OR_SELF);
    mDisplayTimeout = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_TIMEOUT, 8000L, UserHandle.USER_CURRENT_OR_SELF);
    mTurnOffModeEnabled = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_TURNOFF_MODE, 0, UserHandle.USER_CURRENT_OR_SELF) == 1;
    mProximityThreshold = Settings.System.getLongForUser(resolver, Settings.System.ACTIVE_DISPLAY_THRESHOLD, 8000L, UserHandle.USER_CURRENT_OR_SELF);
    mUseActiveDisplayContent = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_CONTENT, 1, UserHandle.USER_CURRENT_OR_SELF) != 0;
    mBypassActiveDisplay = Settings.System.getIntForUser(resolver, Settings.System.ACTIVE_DISPLAY_BYPASS, 1, UserHandle.USER_CURRENT_OR_SELF) != 0;
    createExcludedAppsSet(excludedApps);
    createPrivacyAppsSet(privacyApps);
    int brightnessMode = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, -1, UserHandle.USER_CURRENT_OR_SELF);
    if (mBrightnessMode != brightnessMode) {
        mBrightnessMode = brightnessMode;
        mUserBrightnessLevel = -1;
    }
    if (!mDisplayNotifications || mRedisplayTimeout <= 0) {
        cancelRedisplayTimer();
    }
    if (mDisplayNotifications) {
        registerCallbacks();
    } else {
        unregisterCallbacks();
    }
}
#end_block

#method_before
@Override
public synchronized void onFar() {
    mProximityIsFar = true;
    if (!isScreenOn() && mPocketMode != POCKET_MODE_OFF && !isOnCall() && mDisplayNotifications && !inQuietHoursDim()) {
        if ((System.currentTimeMillis() >= (mPocketTime + mProximityThreshold)) && (mPocketTime != 0)) {
            if (mNotification == null) {
                mNotification = getNextAvailableNotification();
            }
            if (mNotification != null) {
                turnScreenOnbySensor();
                showNotification(mNotification, true);
            } else if (mPocketMode == POCKET_MODE_ALWAYS) {
                turnScreenOnbySensor();
                showTime();
            }
        }
    }
}
#method_after
@Override
public synchronized void onFar() {
    mProximityIsFar = true;
    if (!isScreenOn() && mPocketMode != POCKET_MODE_OFF && !isOnCall() && mDisplayNotifications && !inQuietHoursDim()) {
        if ((System.currentTimeMillis() >= (mPocketTime + mProximityThreshold)) && (mPocketTime != 0)) {
            if (mNotification == null) {
                mNotification = getNextAvailableNotification();
            }
            if (mNotification != null) {
                turnScreenOnbySensor();
                showNotification(mNotification, true);
            } else if (mPocketMode == POCKET_MODE_ALWAYS) {
                turnScreenOnbySensor();
                if (isKeyguardSecure()) {
                    showNothing();
                } else {
                    showTime();
                }
            }
        }
    }
}
#end_block

#method_before
private void makeActiveDisplayView(int orientation, boolean recreate) {
    mContents.removeAllViews();
    View contents = View.inflate(mContext, R.layout.active_display_content, mContents);
    mGlowPadView = (GlowPadView) contents.findViewById(R.id.glow_pad_view);
    mGlowPadView.setOnTriggerListener(mOnTriggerListener);
    mGlowPadView.setDrawOuterRing(false);
    TargetDrawable nDrawable = new TargetDrawable(getResources(), R.drawable.ic_handle_notification_normal);
    mGlowPadView.setHandleDrawable(nDrawable);
    mRemoteViewLayout = (FrameLayout) contents.findViewById(R.id.remote_content_parent);
    mClock = contents.findViewById(R.id.clock_view);
    mCurrentNotificationIcon = (ImageView) contents.findViewById(R.id.current_notification_icon);
    mOverflowNotifications = (LinearLayout) contents.findViewById(R.id.keyguard_other_notifications);
    mOverflowNotifications.setOnTouchListener(mOverflowTouchListener);
    mRemoteViewLayoutParams = getRemoteViewLayoutParams(orientation);
    mOverflowLayoutParams = getOverflowLayoutParams();
    updateTargets();
    if (recreate) {
        updateTimeoutTimer();
        if (mNotification == null) {
            mNotification = getNextAvailableNotification();
        }
        showNotification(mNotification, true);
    }
}
#method_after
private void makeActiveDisplayView(int orientation, boolean recreate) {
    mContents.removeAllViews();
    View contents = View.inflate(mContext, R.layout.active_display_content, mContents);
    mGlowPadView = (GlowPadView) contents.findViewById(R.id.glow_pad_view);
    mGlowPadView.setOnTriggerListener(mOnTriggerListener);
    mGlowPadView.setDrawOuterRing(false);
    TargetDrawable nDrawable = new TargetDrawable(getResources(), R.drawable.ic_handle_notification_normal);
    mGlowPadView.setHandleDrawable(nDrawable);
    mRemoteViewLayout = (FrameLayout) contents.findViewById(R.id.remote_content_parent);
    mClock = contents.findViewById(R.id.clock_view);
    mCurrentNotificationIcon = (RoundedImageView) contents.findViewById(R.id.current_notification_icon);
    mOverflowNotifications = (LinearLayout) contents.findViewById(R.id.keyguard_other_notifications);
    mOverflowNotifications.setOnTouchListener(mOverflowTouchListener);
    mRemoteViewLayoutParams = getRemoteViewLayoutParams(orientation);
    mOverflowLayoutParams = getOverflowLayoutParams();
    updateTargets();
    if (recreate) {
        updateTimeoutTimer();
        if (mNotification == null) {
            mNotification = getNextAvailableNotification();
        }
        showNotification(mNotification, true);
    }
}
#end_block

#method_before
private void launchFakeActivityIntent() {
    mNotification = null;
    Intent intent = new Intent(mContext, DummyActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
}
#method_after
private void launchFakeActivityIntent() {
    mPocketTime = 0;
    mNotification = null;
    Intent intent = new Intent(mContext, DummyActivity.class);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
    mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
}
#end_block

#method_before
private void unlockKeyguardActivity() {
    hideNotificationView();
    try {
        // The intent we are sending is for the application, which
        // won't have permission to immediately start an activity after
        // the user switches to home.  We know it is safe to do at this
        // point, so make sure new activity switches are now allowed.
        ActivityManagerNative.getDefault().resumeAppSwitches();
        // Also, notifications can be launched from the lock screen,
        // so dismiss the lock screen when the activity starts.
        ActivityManagerNative.getDefault().dismissKeyguardOnNextActivity();
    } catch (RemoteException e) {
    }
}
#method_after
private void unlockKeyguardActivity() {
    hideNotificationView();
    sendUnlockBroadcast();
    try {
        // The intent we are sending is for the application, which
        // won't have permission to immediately start an activity after
        // the user switches to home.  We know it is safe to do at this
        // point, so make sure new activity switches are now allowed.
        ActivityManagerNative.getDefault().resumeAppSwitches();
        // Also, notifications can be launched from the lock screen,
        // so dismiss the lock screen when the activity starts.
        ActivityManagerNative.getDefault().dismissKeyguardOnNextActivity();
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
private void handleShowNotificationView() {
    mIsActive = true;
    setVisibility(View.VISIBLE);
    mLightSensorManager.enable();
    adjustStatusBarLocked(true);
}
#method_after
private void handleShowNotificationView() {
    mIsActive = true;
    setVisibility(View.VISIBLE);
    Log.i(TAG, "ActiveDisplay: enable LightSensor");
    mLightSensorManager.enable();
    adjustStatusBarLocked(true);
    // Warm up KeyguardTouchDelegate so it's ready by the time
    KeyguardTouchDelegate.getInstance(mContext);
}
#end_block

#method_before
private void handleHideNotificationView() {
    mIsActive = false;
    restoreBrightness();
    mWakedByPocketMode = false;
    cancelTimeoutTimer();
    mLightSensorManager.disable();
    adjustStatusBarLocked(false);
    setVisibility(View.GONE);
}
#method_after
private void handleHideNotificationView() {
    mIsActive = false;
    restoreBrightness();
    mWakedByPocketMode = false;
    cancelTimeoutTimer();
    Log.i(TAG, "ActiveDisplay: disable LightSensor");
    mLightSensorManager.disable(true);
    adjustStatusBarLocked(false);
    setVisibility(View.GONE);
}
#end_block

#method_before
private void handleHideNotificationViewOnCall() {
    mIsActive = false;
    restoreBrightness();
    mWakedByPocketMode = false;
    cancelTimeoutTimer();
    mLightSensorManager.disable();
    setVisibility(View.GONE);
}
#method_after
private void handleHideNotificationViewOnCall() {
    mIsActive = false;
    restoreBrightness();
    mWakedByPocketMode = false;
    cancelTimeoutTimer();
    Log.i(TAG, "ActiveDisplay: disable LightSensor");
    mLightSensorManager.disable(true);
    setVisibility(View.GONE);
}
#end_block

#method_before
private void handleDismissNotification() {
    if (mNotification != null && mNotification.isClearable()) {
        try {
            mNM.cancelNotificationFromSystemListener(mNotificationListener, mNotification.getPackageName(), mNotification.getTag(), mNotification.getId());
        } catch (RemoteException e) {
        } catch (NullPointerException npe) {
        }
        mNotification = getNextAvailableNotification();
        if (mNotification != null) {
            setActiveNotification(mNotification, true);
            inflateRemoteView(mNotification);
            invalidate();
            mGlowPadView.ping();
            isUserActivity();
            return;
        }
    }
    // no other notifications to display so turn screen off
    turnScreenOff();
}
#method_after
private void handleDismissNotification() {
    if (mNotification != null && mNotification.isClearable()) {
        try {
            mNM.cancelNotificationFromSystemListener(mNotificationListener, mNotification.getPackageName(), mNotification.getTag(), mNotification.getId());
        } catch (RemoteException e) {
        } catch (NullPointerException npe) {
        } finally {
            if (mRemoteView != null)
                mRemoteViewLayout.removeView(mRemoteView);
        }
        mNotification = getNextAvailableNotification();
        if (mNotification != null) {
            setActiveNotification(mNotification, true);
            inflateRemoteView(mNotification);
            invalidate();
            mGlowPadView.ping();
            isUserActivity();
            return;
        }
    }
    // no other notifications to display so turn screen off
    turnScreenOff();
}
#end_block

#method_before
private void handleShowTime() {
    mCurrentNotificationIcon.setImageResource(R.drawable.ic_ad_unlock);
    mGlowPadView.setHandleText("");
    mNotificationDrawable = null;
    mRemoteView = null;
    mOverflowNotifications.removeAllViews();
    updateTargets();
    showNotificationView();
    invalidate();
    if (!isScreenOn()) {
        turnScreenOn();
    }
}
#method_after
private void handleShowTime() {
    mCurrentNotificationIcon.setImageResource(R.drawable.ic_ad_unlock);
    mGlowPadView.setHandleText("");
    mNotificationDrawable = null;
    if (mRemoteView != null) {
        mRemoteViewLayout.removeView(mRemoteView);
    }
    mRemoteView = null;
    mOverflowNotifications.removeAllViews();
    updateTargets();
    showNotificationView();
    invalidate();
    if (!isScreenOn()) {
        turnScreenOn();
    }
    // Warm up KeyguardTouchDelegate so it's ready by the time
    KeyguardTouchDelegate.getInstance(mContext);
}
#end_block

#method_before
private void onScreenTurnedOff() {
    enableProximitySensor();
    mTurnOffTime = System.currentTimeMillis();
    mWakedByPocketMode = false;
    if (mIsUnlockByUser) {
        mIsUnlockByUser = false;
        if (!isScreenOn()) {
            turnScreenOn();
        }
        KeyguardTouchDelegate.getInstance(mContext).dismiss();
        return;
    }
    hideNotificationView();
    cancelTimeoutTimer();
    if (mRedisplayTimeout > 0)
        updateRedisplayTimer();
}
#method_after
private void onScreenTurnedOff() {
    enableProximitySensor();
    mTurnOffTime = System.currentTimeMillis();
    mWakedByPocketMode = false;
    hideNotificationView();
    cancelTimeoutTimer();
    if (mRedisplayTimeout > 0)
        updateRedisplayTimer();
}
#end_block

#method_before
private void turnScreenOffTimeOut() {
    if (getVisibility() != View.VISIBLE) {
        return;
    }
    Log.i(TAG, "ActiveDisplay: Screen Timeout");
    mWakedByPocketMode = false;
    try {
        mPM.goToSleep(SystemClock.uptimeMillis(), GO_TO_SLEEP_REASON_TIMEOUT);
    } catch (RemoteException e) {
    }
}
#method_after
private void turnScreenOffTimeOut() {
    if (getVisibility() != View.VISIBLE || mIsUnlockByUser) {
        return;
    }
    Log.i(TAG, "ActiveDisplay: Screen Timeout");
    mWakedByPocketMode = false;
    try {
        mPM.goToSleep(SystemClock.uptimeMillis(), GO_TO_SLEEP_REASON_TIMEOUT);
    } catch (RemoteException e) {
    }
}
#end_block

#method_before
private void turnScreenOn() {
    if ((System.currentTimeMillis() <= (mTurnOffTime + mTurnOffTimeThreshold)) && (mTurnOffTime != 0)) {
        mHandler.removeCallbacks(runWakeDevice);
        return;
    }
    if (mIsTurnOffBySensor) {
        mIsTurnOffBySensor = false;
        mHandler.removeCallbacks(runWakeDevice);
        return;
    }
    // to avoid flicker and showing any other screen than the ActiveDisplayView
    // we use a runnable posted with a 250ms delay to turn wake the device
    mHandler.removeCallbacks(runWakeDevice);
    mHandler.postDelayed(runWakeDevice, 250);
}
#method_after
private void turnScreenOn() {
    if ((System.currentTimeMillis() <= (mTurnOffTime + mTurnOffTimeThreshold)) && (mTurnOffTime != 0) && !mIsUnlockByUser) {
        mHandler.removeCallbacks(runWakeDevice);
        return;
    }
    if (mIsTurnOffBySensor) {
        mIsTurnOffBySensor = false;
        mHandler.removeCallbacks(runWakeDevice);
        return;
    }
    mHandler.removeCallbacks(runWakeDevice);
    mHandler.postDelayed(runWakeDevice, 250);
}
#end_block

#method_before
private void setBrightness(float brightness) {
    final ContentResolver resolver = mContext.getContentResolver();
    mBrightnessMode = Settings.System.getInt(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC);
    if (mBrightnessMode != Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {
        mUserBrightnessLevel = Settings.System.getInt(resolver, Settings.System.SCREEN_BRIGHTNESS, android.os.PowerManager.BRIGHTNESS_ON);
        final int dim = getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
        int level = (int) ((android.os.PowerManager.BRIGHTNESS_ON - dim) * brightness) + dim;
        Settings.System.putInt(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);
        try {
            mPM.setTemporaryScreenBrightnessSettingOverride(level);
        } catch (RemoteException e) {
        }
    }
}
#method_after
private void setBrightness(int brightness) {
    final ContentResolver resolver = mContext.getContentResolver();
    mBrightnessMode = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC, UserHandle.USER_CURRENT_OR_SELF);
    if (mBrightnessMode != Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {
        mUserBrightnessLevel = Settings.System.getIntForUser(resolver, Settings.System.SCREEN_BRIGHTNESS, mMaximumBacklight, UserHandle.USER_CURRENT_OR_SELF);
        final int level = brightness + mMinimumBacklight;
        Settings.System.putInt(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL);
        try {
            mPM.setTemporaryScreenBrightnessSettingOverride(level);
        } catch (RemoteException e) {
        }
    }
}
#end_block

#method_before
private void isUserActivity() {
    restoreBrightness();
    updateTimeoutTimer();
}
#method_after
private void isUserActivity() {
    restoreBrightness();
    updateTimeoutTimer();
    setUserActivity();
}
#end_block

#method_before
private void registerBroadcastReceiver() {
    IntentFilter filter = new IntentFilter();
    filter.addAction(ACTION_REDISPLAY_NOTIFICATION);
    filter.addAction(ACTION_DISPLAY_TIMEOUT);
    filter.addAction(ACTION_PHONE_STATE);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    mContext.registerReceiver(mBroadcastReceiver, filter);
}
#method_after
private void registerBroadcastReceiver() {
    IntentFilter filter = new IntentFilter();
    filter.addAction(ACTION_REDISPLAY_NOTIFICATION);
    filter.addAction(ACTION_DISPLAY_TIMEOUT);
    filter.addAction(ACTION_PHONE_STATE);
    filter.addAction(ACTION_UNLOCK_DEVICE);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(Intent.ACTION_USER_PRESENT);
    mContext.registerReceiver(mBroadcastReceiver, filter);
}
#end_block

#method_before
private void updateOtherNotifications() {
    mOverflowNotifications.post(new Runnable() {

        @Override
        public void run() {
            try {
                // check if other clearable notifications exist and if so display the next one
                StatusBarNotification[] sbns = mNM.getActiveNotificationsFromSystemListener(mNotificationListener);
                mOverflowNotifications.removeAllViews();
                for (int i = sbns.length - 1; i >= 0; i--) {
                    if (isValidNotification(sbns[i]) && mOverflowNotifications.getChildCount() < MAX_OVERFLOW_ICONS) {
                        boolean updateOther = false;
                        ImageView iv = new ImageView(mContext);
                        if (mOverflowNotifications.getChildCount() < (MAX_OVERFLOW_ICONS - 1)) {
                            Drawable iconDrawable = null;
                            try {
                                Context pkgContext = mContext.createPackageContext(sbns[i].getPackageName(), Context.CONTEXT_RESTRICTED);
                                iconDrawable = pkgContext.getResources().getDrawable(sbns[i].getNotification().icon);
                            } catch (NameNotFoundException nnfe) {
                                iconDrawable = null;
                            } catch (Resources.NotFoundException nfe) {
                                iconDrawable = null;
                            }
                            if (iconDrawable != null) {
                                updateOther = true;
                                iv.setImageDrawable(iconDrawable);
                                iv.setTag(sbns[i]);
                                if (sbns[i].getPackageName().equals(mNotification.getPackageName()) && sbns[i].getId() == mNotification.getId()) {
                                    iv.setBackgroundResource(R.drawable.ad_active_notification_background);
                                } else {
                                    iv.setBackgroundResource(0);
                                }
                            }
                        } else {
                            updateOther = true;
                            iv.setImageResource(R.drawable.ic_ad_morenotifications);
                        }
                        iv.setPadding(mIconPadding, mIconPadding, mIconPadding, mIconPadding);
                        iv.setScaleType(ImageView.ScaleType.FIT_CENTER);
                        if (updateOther) {
                            mOverflowNotifications.addView(iv, mOverflowLayoutParams);
                        }
                    }
                }
            } catch (RemoteException re) {
            } catch (NullPointerException npe) {
            }
        }
    });
}
#method_after
private void updateOtherNotifications() {
    mOverflowNotifications.post(new Runnable() {

        @Override
        public void run() {
            try {
                // check if other clearable notifications exist and if so display the next one
                StatusBarNotification[] sbns = mNM.getActiveNotificationsFromSystemListener(mNotificationListener);
                mOverflowNotifications.removeAllViews();
                for (int i = sbns.length - 1; i >= 0; i--) {
                    if (isValidNotification(sbns[i]) && mOverflowNotifications.getChildCount() < MAX_OVERFLOW_ICONS) {
                        boolean updateOther = false;
                        RoundedImageView iv = new RoundedImageView(mContext);
                        if (mOverflowNotifications.getChildCount() < (MAX_OVERFLOW_ICONS - 1)) {
                            Drawable iconDrawable = getIconDrawable(sbns[i]);
                            if (iconDrawable != null) {
                                updateOther = true;
                                iv.setImageDrawable(iconDrawable);
                                iv.setTag(sbns[i]);
                                if (sbns[i].getPackageName().equals(mNotification.getPackageName()) && sbns[i].getId() == mNotification.getId()) {
                                    iv.setBackgroundResource(R.drawable.ad_active_notification_background);
                                } else {
                                    iv.setBackgroundResource(0);
                                }
                            }
                        } else {
                            updateOther = true;
                            iv.setImageResource(R.drawable.ic_ad_morenotifications);
                        }
                        iv.setPadding(mIconPadding, mIconPadding, mIconPadding, mIconPadding);
                        iv.setScaleType(RoundedImageView.ScaleType.FIT_CENTER);
                        if (updateOther) {
                            mOverflowNotifications.addView(iv, mOverflowLayoutParams);
                        }
                    }
                }
            } catch (RemoteException re) {
            } catch (NullPointerException npe) {
            }
        }
    });
}
#end_block

#method_before
private boolean isValidNotification(StatusBarNotification sbn) {
    return (!mExcludedApps.contains(sbn.getPackageName()) && !isOnCall() && (sbn.isClearable() || mShowAllNotifications) && !(mHideLowPriorityNotifications && sbn.getNotification().priority < HIDE_NOTIFICATIONS_BELOW_SCORE));
}
#method_after
private boolean isValidNotification(final StatusBarNotification sbn) {
    return (!isExcludeApp(sbn) && isNotAppBanned(sbn.getPackageName()) && !isOnCall() && (sbn.getNotification().icon != 0) && (sbn.isClearable() || mShowAllNotifications) && !(mHideLowPriorityNotifications && sbn.getNotification().priority < HIDE_NOTIFICATIONS_BELOW_SCORE) && isNotificationForUser(sbn));
}
#end_block

#method_before
private void setActiveNotification(final StatusBarNotification sbn, final boolean updateOthers) {
    try {
        Context pkgContext = mContext.createPackageContext(sbn.getPackageName(), Context.CONTEXT_RESTRICTED);
        mNotificationDrawable = pkgContext.getResources().getDrawable(sbn.getNotification().icon);
    } catch (NameNotFoundException nnfe) {
        mNotificationDrawable = null;
    } catch (Resources.NotFoundException nfe) {
        mNotificationDrawable = null;
    }
    post(new Runnable() {

        @Override
        public void run() {
            if (mNotificationDrawable != null) {
                mCurrentNotificationIcon.setImageDrawable(mNotificationDrawable);
                setHandleText(sbn);
                mNotification = sbn;
            }
            updateResources();
            mGlowPadView.invalidate();
            if (updateOthers)
                updateOtherNotifications();
        }
    });
}
#method_after
private void setActiveNotification(final StatusBarNotification sbn, final boolean updateOthers) {
    mNotificationDrawable = getIconDrawable(sbn);
    post(new Runnable() {

        @Override
        public void run() {
            if (mNotificationDrawable != null) {
                mCurrentNotificationIcon.setImageDrawable(mNotificationDrawable);
                setHandleText(sbn);
                mNotification = sbn;
            } else {
                mCurrentNotificationIcon.setImageDrawable(null);
                mCurrentNotificationIcon.setImageResource(R.drawable.ic_ad_unlock);
                mNotification = null;
            }
            updateResources();
            mGlowPadView.invalidate();
            if (updateOthers)
                updateOtherNotifications();
        }
    });
}
#end_block

#method_before
private void inflateRemoteView(StatusBarNotification sbn) {
    final Notification notification = sbn.getNotification();
    boolean useBigContent = notification.bigContentView != null;
    RemoteViews rv = useBigContent ? notification.bigContentView : notification.contentView;
    if (rv != null) {
        if (mRemoteView != null)
            mRemoteViewLayout.removeView(mRemoteView);
        if (useBigContent) {
            rv.removeAllViews(com.android.internal.R.id.actions);
            rv.setViewVisibility(com.android.internal.R.id.action_divider, View.GONE);
            mRemoteViewLayoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT;
        } else {
            mRemoteViewLayoutParams.height = getResources().getDimensionPixelSize(R.dimen.notification_min_height);
        }
        rv.setInt(com.android.internal.R.id.icon, "setBackgroundResource", com.android.internal.R.color.transparent);
        rv.setInt(com.android.internal.R.id.status_bar_latest_event_content, "setBackgroundResource", com.android.internal.R.color.transparent);
        mRemoteView = rv.apply(mContext, null);
        mRemoteView.setAlpha(0f);
        mRemoteViewLayout.addView(mRemoteView, mRemoteViewLayoutParams);
    }
}
#method_after
private void inflateRemoteView(final StatusBarNotification sbn) {
    final Notification notification = sbn.getNotification();
    boolean useBigContent = notification.bigContentView != null;
    RemoteViews rv = useBigContent ? notification.bigContentView : notification.contentView;
    if (mUseActiveDisplayContent) {
        rv = applyStandardTemplate(notification, sbn);
    }
    if (rv != null) {
        if (mRemoteView != null) {
            mRemoteViewLayout.removeView(mRemoteView);
        }
        if (useBigContent) {
            if (!mUseActiveDisplayContent) {
                rv.removeAllViews(com.android.internal.R.id.actions);
                rv.setViewVisibility(com.android.internal.R.id.action_divider, View.GONE);
            }
            mRemoteViewLayoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT;
        } else {
            mRemoteViewLayoutParams.height = getResources().getDimensionPixelSize(R.dimen.notification_min_height);
        }
        mRemoteView = rv.apply(mContext, null);
        mRemoteView.setAlpha(0f);
        mRemoteViewLayout.addView(mRemoteView, mRemoteViewLayoutParams);
    }
}
#end_block

#method_before
private void setHandleText(StatusBarNotification sbn) {
    final Notification notificiation = sbn.getNotification();
    CharSequence tickerText = mDisplayNotificationText ? notificiation.tickerText : "";
    if (tickerText == null) {
        Bundle extras = notificiation.extras;
        if (extras != null) {
            tickerText = extras.getCharSequence(Notification.EXTRA_TITLE, null);
        }
    }
    mGlowPadView.setHandleText(tickerText != null ? tickerText.toString() : "");
}
#method_after
private void setHandleText(StatusBarNotification sbn) {
    final Notification notification = sbn.getNotification();
    final boolean isPrivacy = isPrivacyApp(sbn);
    CharSequence tickerText = mDisplayNotificationText ? notification.tickerText : "";
    if (tickerText == null) {
        Bundle extras = notification.extras;
        if (extras != null) {
            tickerText = extras.getCharSequence(Notification.EXTRA_TITLE, null);
        }
    }
    if (isPrivacy) {
        mGlowPadView.setHandleText("");
    } else {
        mGlowPadView.setHandleText(tickerText != null ? tickerText.toString() : "");
    }
}
#end_block

#method_before
private void createExcludedAppsSet(String excludedApps) {
    if (TextUtils.isEmpty(excludedApps)) {
        return;
    }
    String[] appsToExclude = excludedApps.split("\\|");
    mExcludedApps = new HashSet<String>(Arrays.asList(appsToExclude));
}
#method_after
private void createExcludedAppsSet(String excludedApps) {
    if (TextUtils.isEmpty(excludedApps)) {
        mExcludedApps = null;
        return;
    }
    String[] appsToExclude = excludedApps.split("\\|");
    mExcludedApps = new HashSet<String>(Arrays.asList(appsToExclude));
}
#end_block

#method_before
@Override
public void setTextSizes(int size) {
    mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
    super.setTextSizes(size);
}
#method_after
@Override
public void setTextSizes(int size) {
    mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
}
#end_block

#method_before
public void flipToSettings() {
    // Settings are not available in setup
    if (!mUserSetup)
        return;
    if (mFlipSettingsViewAnim != null)
        mFlipSettingsViewAnim.cancel();
    if (mScrollViewAnim != null)
        mScrollViewAnim.cancel();
    if (mSettingsButtonAnim != null)
        mSettingsButtonAnim.cancel();
    if (mNotificationButtonAnim != null)
        mNotificationButtonAnim.cancel();
    if (mEditModeButtonAnim != null)
        mEditModeButtonAnim.cancel();
    if (mClearButtonAnim != null)
        mClearButtonAnim.cancel();
    final boolean halfWayDone = mFlipSettingsView.getVisibility() == View.VISIBLE;
    final int zeroOutDelays = halfWayDone ? 0 : 1;
    if (!halfWayDone) {
        mFlipSettingsView.setScaleX(0f);
        mScrollView.setScaleX(1f);
    }
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mFlipSettingsViewAnim = start(startDelay(FLIP_DURATION_OUT * zeroOutDelays, interpolator(mDecelerateInterpolator, ObjectAnimator.ofFloat(mFlipSettingsView, View.SCALE_X, 1f).setDuration(FLIP_DURATION_IN))));
    mScrollViewAnim = start(setVisibilityWhenDone(interpolator(mAccelerateInterpolator, ObjectAnimator.ofFloat(mScrollView, View.SCALE_X, 0f)).setDuration(FLIP_DURATION_OUT), mScrollView, View.INVISIBLE));
    mSettingsButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mSettingsButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mScrollView, View.INVISIBLE));
    mNotificationButton.setVisibility(View.VISIBLE);
    mNotificationButtonAnim = start(ObjectAnimator.ofFloat(mNotificationButton, View.ALPHA, 1f).setDuration(FLIP_DURATION));
    mEditModeButton.setVisibility(View.VISIBLE);
    mEditModeButtonAnim = start(ObjectAnimator.ofFloat(mEditModeButton, View.ALPHA, 1f).setDuration(FLIP_DURATION));
    mClearButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mClearButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mClearButton, View.INVISIBLE));
    mNotificationPanel.postDelayed(new Runnable() {

        public void run() {
            updateCarrierLabelVisibility(false);
        }
    }, FLIP_DURATION - 150);
}
#method_after
public void flipToSettings() {
    // Settings are not available in setup
    if (!mUserSetup)
        return;
    if (mFlipSettingsViewAnim != null)
        mFlipSettingsViewAnim.cancel();
    if (mScrollViewAnim != null)
        mScrollViewAnim.cancel();
    if (mSettingsButtonAnim != null)
        mSettingsButtonAnim.cancel();
    if (mNotificationButtonAnim != null)
        mNotificationButtonAnim.cancel();
    if (mEditModeButtonAnim != null)
        mEditModeButtonAnim.cancel();
    if (mClearButtonAnim != null)
        mClearButtonAnim.cancel();
    final boolean halfWayDone = mFlipSettingsView.getVisibility() == View.VISIBLE;
    final int zeroOutDelays = halfWayDone ? 0 : 1;
    if (!halfWayDone) {
        mFlipSettingsView.setScaleX(0f);
        mScrollView.setScaleX(1f);
    }
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mFlipSettingsViewAnim = start(startDelay(FLIP_DURATION_OUT * zeroOutDelays, interpolator(mDecelerateInterpolator, ObjectAnimator.ofFloat(mFlipSettingsView, View.SCALE_X, 1f).setDuration(FLIP_DURATION_IN))));
    mScrollViewAnim = start(setVisibilityWhenDone(interpolator(mAccelerateInterpolator, ObjectAnimator.ofFloat(mScrollView, View.SCALE_X, 0f)).setDuration(FLIP_DURATION_OUT), mScrollView, View.INVISIBLE));
    mSettingsButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mSettingsButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mScrollView, View.INVISIBLE));
    mNotificationButton.setVisibility(View.VISIBLE);
    mNotificationButtonAnim = start(ObjectAnimator.ofFloat(mNotificationButton, View.ALPHA, 1f).setDuration(FLIP_DURATION));
    mEditModeButton.setVisibility(View.VISIBLE);
    mEditModeButtonAnim = start(ObjectAnimator.ofFloat(mEditModeButton, View.ALPHA, 1f).setDuration(FLIP_DURATION));
    mClearButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mClearButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mClearButton, View.INVISIBLE));
    mNotificationPanel.postDelayed(new Runnable() {

        public void run() {
            updateCarrierLabelVisibility(false);
        }
    }, FLIP_DURATION - 150);
    updateQuickSettings();
}
#end_block

#method_before
void updateResources() {
    final Context context = mContext;
    final Resources res = context.getResources();
    if (mClearButton instanceof TextView) {
        ((TextView) mClearButton).setText(context.getText(R.string.status_bar_clear_all_button));
    }
    loadDimens();
    // check for orientation change and update only the container layout
    // for all other configuration changes update complete QS
    int orientation = res.getConfiguration().orientation;
    if (orientation != mCurrOrientation) {
        mCurrOrientation = orientation;
        // Update the settings container
        if (mSettingsContainer != null) {
            mSettingsContainer.updateResources();
        }
    } else {
        // Update the QuickSettings container
        if (mQS != null)
            mQS.updateResources();
    }
}
#method_after
void updateResources() {
    final Context context = mContext;
    final Resources res = context.getResources();
    if (mClearButton instanceof TextView) {
        ((TextView) mClearButton).setText(context.getText(R.string.status_bar_clear_all_button));
    }
    loadDimens();
    // check for orientation change and update only the container layout
    // for all other configuration changes update complete QS
    int orientation = res.getConfiguration().orientation;
    if (orientation != mCurrOrientation) {
        mCurrOrientation = orientation;
        // Update the settings container
        if (mSettingsContainer != null) {
            mSettingsContainer.updateRotation(orientation);
        }
    } else {
        // Update the QuickSettings container
        if (mQS != null)
            mQS.updateResources();
    }
}
#end_block

#method_before
public void updateResources() {
    refreshSettingsTile();
    refreshBatteryTile();
    refreshBluetoothTile();
    refreshBrightnessTile();
    refreshImmersiveTile();
    onQuiteHourChanged();
    refreshRotationLockTile();
    refreshRssiTile();
    refreshLocationTile();
    refreshBackLocationTile();
    updateRingerState();
    updateSleepState();
    onMobileNetworkChanged();
}
#method_after
public void updateResources() {
    refreshSettingsTile();
    refreshBatteryTile();
    refreshBatteryBackTile();
    refreshBluetoothTile();
    refreshBrightnessTile();
    refreshImmersiveTile();
    onQuiteHourChanged();
    refreshRotationLockTile();
    refreshRssiTile();
    refreshLocationTile();
    refreshBackLocationTile();
    updateRingerState();
    updateSleepState();
    onMobileNetworkChanged();
}
#end_block

#method_before
void onUsbChanged() {
    Resources r = mContext.getResources();
    updateState();
    if (mUsbConnected && !mMassStorageActive) {
        if (mUsbTethered) {
            mUsbModeState.iconId = R.drawable.ic_qs_usb_tether_on;
            mUsbModeState.label = r.getString(R.string.quick_settings_usb_tether_on_label);
        } else {
            mUsbModeState.iconId = R.drawable.ic_qs_usb_tether_connected;
            mUsbModeState.label = r.getString(R.string.quick_settings_usb_tether_connected_label);
        }
        mUsbModeState.enabled = true;
    } else {
        mUsbModeState.iconId = R.drawable.ic_qs_usb_tether_off;
        mUsbModeState.label = r.getString(R.string.quick_settings_usb_tether_off_label);
        mUsbModeState.enabled = false;
    }
    mUsbModeCallback.refreshView(mUsbModeTile, mUsbModeState);
}
#method_after
void onUsbChanged() {
    if (DeviceUtils.deviceSupportsUsbTether(mContext)) {
        updateState();
        Resources r = mContext.getResources();
        if (mUsbConnected && !mMassStorageActive) {
            if (mUsbTethered) {
                mUsbModeState.iconId = R.drawable.ic_qs_usb_tether_on;
                mUsbModeState.label = r.getString(R.string.quick_settings_usb_tether_on_label);
            } else {
                mUsbModeState.iconId = R.drawable.ic_qs_usb_tether_connected;
                mUsbModeState.label = r.getString(R.string.quick_settings_usb_tether_connected_label);
            }
            mUsbModeState.enabled = true;
        } else {
            mUsbModeState.iconId = R.drawable.ic_qs_usb_tether_off;
            mUsbModeState.label = r.getString(R.string.quick_settings_usb_tether_off_label);
            mUsbModeState.enabled = false;
        }
        mUsbModeCallback.refreshView(mUsbModeTile, mUsbModeState);
    }
}
#end_block

#method_before
void onTorchChanged() {
    Resources r = mContext.getResources();
    if (mTorchActive) {
        mTorchState.iconId = R.drawable.ic_qs_torch_on;
        mTorchState.label = r.getString(R.string.quick_settings_torch);
    } else {
        mTorchState.iconId = R.drawable.ic_qs_torch_off;
        mTorchState.label = r.getString(R.string.quick_settings_torch_off);
    }
    mTorchState.enabled = mTorchActive;
    mTorchCallback.refreshView(mTorchTile, mTorchState);
}
#method_after
void onTorchChanged() {
    if (DeviceUtils.deviceSupportsTorch(mContext)) {
        Resources r = mContext.getResources();
        if (mTorchActive) {
            mTorchState.iconId = R.drawable.ic_qs_torch_on;
            mTorchState.label = r.getString(R.string.quick_settings_torch);
        } else {
            mTorchState.iconId = R.drawable.ic_qs_torch_off;
            mTorchState.label = r.getString(R.string.quick_settings_torch_off);
        }
        mTorchState.enabled = mTorchActive;
        mTorchCallback.refreshView(mTorchTile, mTorchState);
    }
}
#end_block

#method_before
void addWifiBackTile(QuickSettingsTileView view, RefreshCallback cb) {
    mWifiBackTile = view;
    mWifiBackTile.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (mCM != null && mCM.getTetherableWifiRegexs().length != 0) {
                int state = mWifiManager.getWifiApState();
                switch(state) {
                    case WifiManager.WIFI_AP_STATE_ENABLING:
                    case WifiManager.WIFI_AP_STATE_ENABLED:
                        setSoftapEnabled(false);
                        break;
                    case WifiManager.WIFI_AP_STATE_DISABLING:
                    case WifiManager.WIFI_AP_STATE_DISABLED:
                        setSoftapEnabled(true);
                        break;
                }
            }
        }
    });
    mWifiBackCallback = cb;
    mWifiCallback.refreshView(mWifiBackTile, mWifiBackState);
}
#method_after
void addWifiBackTile(QuickSettingsTileView view, RefreshCallback cb) {
    mWifiBackTile = view;
    mWifiBackTile.setOnClickListener(new View.OnClickListener() {

        @Override
        public void onClick(View v) {
            if (DeviceUtils.deviceSupportsWifiAp(mContext)) {
                int state = mWifiManager.getWifiApState();
                switch(state) {
                    case WifiManager.WIFI_AP_STATE_ENABLING:
                    case WifiManager.WIFI_AP_STATE_ENABLED:
                        setSoftapEnabled(false);
                        break;
                    case WifiManager.WIFI_AP_STATE_DISABLING:
                    case WifiManager.WIFI_AP_STATE_DISABLED:
                        setSoftapEnabled(true);
                        break;
                }
            }
        }
    });
    mWifiBackCallback = cb;
    mWifiCallback.refreshView(mWifiBackTile, mWifiBackState);
}
#end_block

#method_before
@Override
public void onMobileDataSignalChanged(boolean enabled, int mobileSignalIconId, String signalContentDescription, int dataTypeIconId, boolean activityIn, boolean activityOut, String dataContentDescription, String enabledDesc) {
    if (deviceHasMobileData()) {
        // TODO: If view is in awaiting state, disable
        Resources r = mContext.getResources();
        mRSSIState.signalIconId = enabled && (mobileSignalIconId > 0) ? mobileSignalIconId : R.drawable.ic_qs_signal_no_signal;
        mRSSIState.signalContentDescription = enabled && (mobileSignalIconId > 0) ? signalContentDescription : r.getString(R.string.accessibility_no_signal);
        mRSSIState.dataTypeIconId = enabled && (dataTypeIconId > 0) && !mWifiState.enabled ? dataTypeIconId : 0;
        mRSSIState.activityIn = enabled && activityIn;
        mRSSIState.activityOut = enabled && activityOut;
        mRSSIState.dataContentDescription = enabled && (dataTypeIconId > 0) && !mWifiState.enabled ? dataContentDescription : r.getString(R.string.accessibility_no_data);
        mRSSIState.label = enabled ? removeTrailingPeriod(enabledDesc) : r.getString(R.string.quick_settings_rssi_emergency_only);
        mRSSICallback.refreshView(mRSSITile, mRSSIState);
    }
    onMobileNetworkChanged();
}
#method_after
@Override
public void onMobileDataSignalChanged(boolean enabled, int mobileSignalIconId, String signalContentDescription, int dataTypeIconId, boolean activityIn, boolean activityOut, String dataContentDescription, String enabledDesc) {
    if (DeviceUtils.deviceSupportsMobileData(mContext)) {
        // TODO: If view is in awaiting state, disable
        Resources r = mContext.getResources();
        mRSSIState.signalIconId = enabled && (mobileSignalIconId > 0) ? mobileSignalIconId : R.drawable.ic_qs_signal_no_signal;
        mRSSIState.signalContentDescription = enabled && (mobileSignalIconId > 0) ? signalContentDescription : r.getString(R.string.accessibility_no_signal);
        mRSSIState.dataTypeIconId = enabled && (dataTypeIconId > 0) && !mWifiState.connected ? dataTypeIconId : 0;
        mRSSIState.activityIn = enabled && activityIn;
        mRSSIState.activityOut = enabled && activityOut;
        mRSSIState.dataContentDescription = enabled && (dataTypeIconId > 0) && !mWifiState.connected ? dataContentDescription : r.getString(R.string.accessibility_no_data);
        mRSSIState.label = enabled ? removeTrailingPeriod(enabledDesc) : r.getString(R.string.quick_settings_rssi_emergency_only);
        mRSSICallback.refreshView(mRSSITile, mRSSIState);
    }
    onMobileNetworkChanged();
}
#end_block

#method_before
void onMobileNetworkChanged() {
    if (deviceHasMobileData()) {
        mMobileNetworkState.label = getNetworkType(mContext.getResources());
        mMobileNetworkState.iconId = getNetworkTypeIcon();
        mMobileNetworkState.enabled = true;
        mMobileNetworkCallback.refreshView(mMobileNetworkTile, mMobileNetworkState);
    }
}
#method_after
void onMobileNetworkChanged() {
    if (DeviceUtils.deviceSupportsMobileData(mContext)) {
        mMobileNetworkState.label = getNetworkType(mContext.getResources());
        mMobileNetworkState.iconId = getNetworkTypeIcon();
        mMobileNetworkState.enabled = true;
        mMobileNetworkCallback.refreshView(mMobileNetworkTile, mMobileNetworkState);
    }
}
#end_block

#method_before
private void toggleMobileNetworkState() {
    boolean usesQcLte = SystemProperties.getBoolean("ro.config.qc_lte_network_modes", false);
    int network = get2G3G();
    switch(network) {
        case Phone.NT_MODE_GLOBAL:
        case Phone.NT_MODE_LTE_GSM_WCDMA:
        case Phone.NT_MODE_LTE_ONLY:
        case Phone.NT_MODE_LTE_WCDMA:
            if (deviceSupportsGSMLTE()) {
                mTM.toggleMobileNetwork(Phone.NT_MODE_GSM_ONLY);
            } else if (deviceSupportsCDMALTE()) {
                mTM.toggleMobileNetwork(Phone.NT_MODE_CDMA);
            }
            break;
        case Phone.NT_MODE_LTE_CDMA_AND_EVDO:
        case Phone.NT_MODE_LTE_CMDA_EVDO_GSM_WCDMA:
            mTM.toggleMobileNetwork(Phone.NT_MODE_CDMA_NO_EVDO);
            break;
        case Phone.NT_MODE_CDMA_NO_EVDO:
        case Phone.NT_MODE_EVDO_NO_CDMA:
            mTM.toggleMobileNetwork(Phone.NT_MODE_CDMA);
            break;
        case Phone.NT_MODE_CDMA:
            if (deviceSupportsCDMALTE()) {
                if (usesQcLte) {
                    mTM.toggleMobileNetwork(Phone.NT_MODE_GLOBAL);
                } else {
                    mTM.toggleMobileNetwork(Phone.NT_MODE_LTE_CDMA_AND_EVDO);
                }
            } else {
                mTM.toggleMobileNetwork(Phone.NT_MODE_CDMA_NO_EVDO);
            }
            break;
        case Phone.NT_MODE_GSM_UMTS:
            mTM.toggleMobileNetwork(Phone.NT_MODE_WCDMA_PREF);
            break;
        case Phone.NT_MODE_WCDMA_ONLY:
            mTM.toggleMobileNetwork(Phone.NT_MODE_GSM_UMTS);
            break;
        case Phone.NT_MODE_GSM_ONLY:
            mTM.toggleMobileNetwork(Phone.NT_MODE_WCDMA_ONLY);
            break;
        case Phone.NT_MODE_WCDMA_PREF:
            if (deviceSupportsGSMLTE()) {
                if (usesQcLte) {
                    mTM.toggleMobileNetwork(Phone.NT_MODE_GLOBAL);
                } else {
                    mTM.toggleMobileNetwork(Phone.NT_MODE_LTE_GSM_WCDMA);
                }
            } else {
                mTM.toggleMobileNetwork(Phone.NT_MODE_GSM_ONLY);
            }
            break;
    }
}
#method_after
private void toggleMobileNetworkState() {
    boolean usesQcLte = SystemProperties.getBoolean("ro.config.qc_lte_network_modes", false);
    int network = get2G3G();
    switch(network) {
        case Phone.NT_MODE_GLOBAL:
        case Phone.NT_MODE_LTE_GSM_WCDMA:
        case Phone.NT_MODE_LTE_ONLY:
        case Phone.NT_MODE_LTE_WCDMA:
            if (DeviceUtils.deviceSupportsLteGsm(mContext)) {
                mTM.toggleMobileNetwork(Phone.NT_MODE_GSM_ONLY);
            } else if (DeviceUtils.deviceSupportsLteCdma(mContext)) {
                mTM.toggleMobileNetwork(Phone.NT_MODE_CDMA);
            }
            break;
        case Phone.NT_MODE_LTE_CDMA_AND_EVDO:
        case Phone.NT_MODE_LTE_CMDA_EVDO_GSM_WCDMA:
            mTM.toggleMobileNetwork(Phone.NT_MODE_CDMA_NO_EVDO);
            break;
        case Phone.NT_MODE_CDMA_NO_EVDO:
        case Phone.NT_MODE_EVDO_NO_CDMA:
            mTM.toggleMobileNetwork(Phone.NT_MODE_CDMA);
            break;
        case Phone.NT_MODE_CDMA:
            if (DeviceUtils.deviceSupportsLteCdma(mContext)) {
                if (usesQcLte) {
                    mTM.toggleMobileNetwork(Phone.NT_MODE_GLOBAL);
                } else {
                    mTM.toggleMobileNetwork(Phone.NT_MODE_LTE_CDMA_AND_EVDO);
                }
            } else {
                mTM.toggleMobileNetwork(Phone.NT_MODE_CDMA_NO_EVDO);
            }
            break;
        case Phone.NT_MODE_GSM_UMTS:
            mTM.toggleMobileNetwork(Phone.NT_MODE_WCDMA_PREF);
            break;
        case Phone.NT_MODE_WCDMA_ONLY:
            mTM.toggleMobileNetwork(Phone.NT_MODE_GSM_UMTS);
            break;
        case Phone.NT_MODE_GSM_ONLY:
            mTM.toggleMobileNetwork(Phone.NT_MODE_WCDMA_ONLY);
            break;
        case Phone.NT_MODE_WCDMA_PREF:
            if (DeviceUtils.deviceSupportsLteGsm(mContext)) {
                if (usesQcLte) {
                    mTM.toggleMobileNetwork(Phone.NT_MODE_GLOBAL);
                } else {
                    mTM.toggleMobileNetwork(Phone.NT_MODE_LTE_GSM_WCDMA);
                }
            } else {
                mTM.toggleMobileNetwork(Phone.NT_MODE_GSM_ONLY);
            }
            break;
    }
}
#end_block

#method_before
private String getNetworkType(Resources r) {
    boolean isEnabled = mCM.getMobileDataEnabled();
    int state = get2G3G();
    switch(state) {
        case Phone.NT_MODE_GLOBAL:
        case Phone.NT_MODE_LTE_CDMA_AND_EVDO:
        case Phone.NT_MODE_LTE_GSM_WCDMA:
        case Phone.NT_MODE_LTE_CMDA_EVDO_GSM_WCDMA:
        case Phone.NT_MODE_LTE_ONLY:
        case Phone.NT_MODE_LTE_WCDMA:
            if (!isEnabled) {
                return r.getString(R.string.network_4G) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_4G);
            }
        case Phone.NT_MODE_GSM_UMTS:
            if (!isEnabled) {
                return r.getString(R.string.network_3G_auto) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_3G_auto);
            }
        case Phone.NT_MODE_WCDMA_ONLY:
            if (!isEnabled) {
                return r.getString(R.string.network_3G_only) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_3G_only);
            }
        case Phone.NT_MODE_EVDO_NO_CDMA:
        case Phone.NT_MODE_CDMA_NO_EVDO:
        case Phone.NT_MODE_GSM_ONLY:
            if (!isEnabled) {
                return r.getString(R.string.network_2G) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_2G);
            }
        case Phone.NT_MODE_CDMA:
        case Phone.NT_MODE_WCDMA_PREF:
            if (!isEnabled) {
                return r.getString(R.string.network_3G) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_3G);
            }
    }
    return r.getString(R.string.quick_settings_network_unknown);
}
#method_after
private String getNetworkType(Resources r) {
    boolean isEnabled = isMobileDataEnabled();
    int state = get2G3G();
    switch(state) {
        case Phone.NT_MODE_GLOBAL:
        case Phone.NT_MODE_LTE_CDMA_AND_EVDO:
        case Phone.NT_MODE_LTE_GSM_WCDMA:
        case Phone.NT_MODE_LTE_CMDA_EVDO_GSM_WCDMA:
        case Phone.NT_MODE_LTE_ONLY:
        case Phone.NT_MODE_LTE_WCDMA:
            if (!isEnabled) {
                return r.getString(R.string.network_4G) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_4G);
            }
        case Phone.NT_MODE_GSM_UMTS:
            if (!isEnabled) {
                return r.getString(R.string.network_3G_auto) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_3G_auto);
            }
        case Phone.NT_MODE_WCDMA_ONLY:
            if (!isEnabled) {
                return r.getString(R.string.network_3G_only) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_3G_only);
            }
        case Phone.NT_MODE_EVDO_NO_CDMA:
        case Phone.NT_MODE_CDMA_NO_EVDO:
        case Phone.NT_MODE_GSM_ONLY:
            if (!isEnabled) {
                return r.getString(R.string.network_2G) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_2G);
            }
        case Phone.NT_MODE_CDMA:
        case Phone.NT_MODE_WCDMA_PREF:
            if (!isEnabled) {
                return r.getString(R.string.network_3G) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_3G);
            }
    }
    return r.getString(R.string.quick_settings_network_unknown);
}
#end_block

#method_before
public void onBluetoothStateChange(BluetoothState bluetoothStateIn) {
    if (deviceSupportsBluetooth()) {
        // TODO: If view is in awaiting state, disable
        Resources r = mContext.getResources();
        mBluetoothState.enabled = bluetoothStateIn.enabled;
        mBluetoothState.connected = bluetoothStateIn.connected;
        if (mBluetoothState.enabled) {
            if (mBluetoothState.connected) {
                mBluetoothState.iconId = R.drawable.ic_qs_bluetooth_on;
                mBluetoothState.stateContentDescription = r.getString(R.string.accessibility_desc_connected);
            } else {
                mBluetoothState.iconId = R.drawable.ic_qs_bluetooth_not_connected;
                mBluetoothState.stateContentDescription = r.getString(R.string.accessibility_desc_on);
            }
            mBluetoothState.label = r.getString(R.string.quick_settings_bluetooth_label);
        } else {
            mBluetoothState.iconId = R.drawable.ic_qs_bluetooth_off;
            mBluetoothState.label = r.getString(R.string.quick_settings_bluetooth_off_label);
            mBluetoothState.stateContentDescription = r.getString(R.string.accessibility_desc_off);
        }
        // Back tile: Show paired devices
        if (mBluetoothBackTile != null) {
            boolean isPaired = false;
            final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            Set<BluetoothDevice> btDevices = adapter.getBondedDevices();
            if (btDevices.size() == 1) {
                // Show a generic label about the number of paired bluetooth devices
                isPaired = true;
                mBluetoothBackState.label = r.getString(R.string.quick_settings_bluetooth_number_paired, btDevices.size());
            } else {
                isPaired = false;
                mBluetoothBackState.label = r.getString(R.string.quick_settings_bluetooth_disabled);
            }
            mBluetoothBackState.iconId = isBluetoothPaired(isPaired && bluetoothStateIn.enabled);
        }
        mBluetoothCallback.refreshView(mBluetoothTile, mBluetoothState);
        if (mBluetoothBackTile != null) {
            mBluetoothBackCallback.refreshView(mBluetoothBackTile, mBluetoothBackState);
        }
    }
}
#method_after
public void onBluetoothStateChange(BluetoothState bluetoothStateIn) {
    if (DeviceUtils.deviceSupportsBluetooth()) {
        // TODO: If view is in awaiting state, disable
        Resources r = mContext.getResources();
        mBluetoothState.enabled = bluetoothStateIn.enabled;
        mBluetoothState.connected = bluetoothStateIn.connected;
        if (mBluetoothState.enabled) {
            if (mBluetoothState.connected) {
                mBluetoothState.iconId = R.drawable.ic_qs_bluetooth_on;
                mBluetoothState.stateContentDescription = r.getString(R.string.accessibility_desc_connected);
            } else {
                mBluetoothState.iconId = R.drawable.ic_qs_bluetooth_not_connected;
                mBluetoothState.stateContentDescription = r.getString(R.string.accessibility_desc_on);
            }
            mBluetoothState.label = r.getString(R.string.quick_settings_bluetooth_label);
        } else {
            mBluetoothState.iconId = R.drawable.ic_qs_bluetooth_off;
            mBluetoothState.label = r.getString(R.string.quick_settings_bluetooth_off_label);
            mBluetoothState.stateContentDescription = r.getString(R.string.accessibility_desc_off);
        }
        // Back tile: Show paired devices
        if (mBluetoothBackTile != null) {
            boolean isPaired = false;
            final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
            Set<BluetoothDevice> btDevices = adapter.getBondedDevices();
            String bluetoothLabel = r.getString(R.string.quick_settings_bluetooth_disabled);
            if (btDevices.size() == 1) {
                // Show a generic label about the number of paired bluetooth devices
                isPaired = true;
                bluetoothLabel = r.getString(R.string.quick_settings_bluetooth_number_paired, btDevices.size());
            } else {
                isPaired = false;
                if (bluetoothStateIn.enabled) {
                    bluetoothLabel = r.getString(R.string.quick_settings_bluetooth_enabled);
                } else {
                    bluetoothLabel = r.getString(R.string.quick_settings_bluetooth_disabled);
                }
            }
            mBluetoothBackState.label = bluetoothLabel;
            mBluetoothBackState.iconId = isBluetoothPairedIcon(isPaired, bluetoothStateIn.enabled, bluetoothStateIn.connected);
        }
        mBluetoothCallback.refreshView(mBluetoothTile, mBluetoothState);
        if (mBluetoothBackTile != null) {
            mBluetoothBackCallback.refreshView(mBluetoothBackTile, mBluetoothBackState);
        }
    }
}
#end_block

#method_before
void refreshLocationTile() {
    if (mLocationTile != null) {
        onLocationSettingsChanged(mLocationState.enabled, mLocationState.mode);
    }
}
#method_after
void refreshLocationTile() {
    if (mLocationTile != null) {
        onLocationSettingsChanged(mLocationController.isLocationEnabled(), mLocationController.getLocationMode());
    }
}
#end_block

#method_before
@Override
public void onLocationSettingsChanged(boolean locationEnabled, int locationMode) {
    int textResId = locationEnabled ? R.string.quick_settings_location_label : R.string.quick_settings_location_off_label;
    String label = mContext.getText(textResId).toString();
    int locationIconId = locationEnabled ? R.drawable.ic_qs_location_on : R.drawable.ic_qs_location_off;
    mLocationState.enabled = locationEnabled;
    mLocationState.mode = locationMode;
    mLocationState.label = label;
    mLocationState.iconId = locationIconId;
    mLocationCallback.refreshView(mLocationTile, mLocationState);
    refreshBackLocationTile();
}
#method_after
@Override
public void onLocationSettingsChanged(boolean locationEnabled, int locationMode) {
    onBackLocationSettingsChanged(locationEnabled, locationMode);
    if (DeviceUtils.deviceSupportsGps(mContext)) {
        int textResId = locationEnabled ? R.string.quick_settings_location_label : R.string.quick_settings_location_off_label;
        String label = mContext.getText(textResId).toString();
        int locationIconId = locationEnabled ? R.drawable.ic_qs_location_default_on : R.drawable.ic_qs_location_default_off;
        mLocationState.enabled = locationEnabled;
        mLocationState.label = label;
        mLocationState.iconId = locationIconId;
        mLocationCallback.refreshView(mLocationTile, mLocationState);
    }
}
#end_block

#method_before
void refreshBackLocationTile() {
    if (mBackLocationTile != null) {
        onBackLocationSettingsChanged(mLocationController.locationMode(), mLocationState.enabled);
    }
}
#method_after
void refreshBackLocationTile() {
    if (mBackLocationTile != null) {
        onBackLocationSettingsChanged(mLocationController.isLocationEnabled(), mLocationController.getLocationMode());
    }
}
#end_block

#method_before
private void onBackLocationSettingsChanged(int mode, boolean locationEnabled) {
    int locationIconId = locationEnabled ? R.drawable.ic_qs_location_on : R.drawable.ic_qs_location_off;
    mBackLocationState.enabled = locationEnabled;
    mBackLocationState.label = getLocationMode(mContext.getResources(), mode);
    mBackLocationState.iconId = locationIconId;
    mBackLocationCallback.refreshView(mBackLocationTile, mBackLocationState);
}
#method_after
private void onBackLocationSettingsChanged(boolean locationEnabled, int locationMode) {
    if (DeviceUtils.deviceSupportsGps(mContext)) {
        mBackLocationState.enabled = locationEnabled;
        mBackLocationState.label = getLocationMode(mContext.getResources(), locationMode);
        mBackLocationState.iconId = getLocationDrawableMode(locationMode);
        mBackLocationCallback.refreshView(mBackLocationTile, mBackLocationState);
    }
}
#end_block

#method_before
private int getScreenTimeout() {
    return Settings.System.getInt(mContext.getContentResolver(), Settings.System.SCREEN_OFF_TIMEOUT, 0);
}
#method_after
private int getScreenTimeout() {
    return Settings.System.getInt(mContext.getContentResolver(), Settings.System.SCREEN_OFF_TIMEOUT, SCREEN_TIMEOUT_30);
}
#end_block

#method_before
@Override
public void setTextSizes(int size) {
    mBack.setTextSizes(size);
    mFront.setTextSizes(size);
    super.setTextSizes(size);
}
#method_after
@Override
public void setTextSizes(int size) {
    mBack.setTextSizes(size);
    mFront.setTextSizes(size);
}
#end_block

#method_before
@Override
public void setTextSizes(int size) {
    mLabelView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
    mFunctionView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
    super.setTextSizes(size);
}
#method_after
@Override
public void setTextSizes(int size) {
    mLabelView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
    mFunctionView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
}
#end_block

#method_before
@Override
public boolean onDrag(View v, DragEvent event) {
    QuickSettingsTileView topView = (QuickSettingsTileView) event.getLocalState();
    QuickSettingsTileView bottomView = (QuickSettingsTileView) v;
    if (bottomView.getParent() instanceof QuickSettingsFlipTile) {
        bottomView = (QuickSettingsFlipTile) bottomView.getParent();
    } else if (bottomView.getParent() instanceof QuickSettingsNetworkFlipTile) {
        bottomView = (QuickSettingsNetworkFlipTile) bottomView.getParent();
    }
    if (topView == bottomView)
        return false;
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_ENTERED:
            bottomView.setHoverEffect(true);
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            bottomView.setHoverEffect(false);
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            topView.fadeIn();
            break;
        case DragEvent.ACTION_DROP:
            // Disable hovering
            bottomView.setHoverEffect(false);
            final QuickSettingsContainerView parent = (QuickSettingsContainerView) topView.getParent();
            // Remove top view
            final int topViewIndex = parent.indexOfChild(topView);
            parent.removeViewAt(topViewIndex);
            // Remove bottom view
            final int bottomViewIndex = parent.indexOfChild(bottomView);
            parent.removeViewAt(bottomViewIndex);
            // Add both views to the new indexes
            parent.addView(topView, bottomViewIndex);
            parent.addView(bottomView, topViewIndex);
            // Animate the change
            parent.enableLayoutTransitions();
            break;
        default:
            break;
    }
    return true;
}
#method_after
@Override
public boolean onDrag(View v, DragEvent event) {
    QuickSettingsTileView topView = (QuickSettingsTileView) event.getLocalState();
    QuickSettingsTileView bottomView = (QuickSettingsTileView) v;
    if (bottomView.getParent() instanceof QuickSettingsFlipTile) {
        bottomView = (QuickSettingsFlipTile) bottomView.getParent();
    } else if (bottomView.getParent() instanceof QuickSettingsNetworkFlipTile) {
        bottomView = (QuickSettingsNetworkFlipTile) bottomView.getParent();
    } else if (bottomView.getParent() instanceof QuickSettingsBatteryFlipTile) {
        bottomView = (QuickSettingsBatteryFlipTile) bottomView.getParent();
    }
    if (topView == bottomView)
        return false;
    switch(event.getAction()) {
        case DragEvent.ACTION_DRAG_ENTERED:
            bottomView.setHoverEffect(true);
            break;
        case DragEvent.ACTION_DRAG_EXITED:
            bottomView.setHoverEffect(false);
            break;
        case DragEvent.ACTION_DRAG_ENDED:
            topView.fadeIn();
            break;
        case DragEvent.ACTION_DROP:
            // Disable hovering
            bottomView.setHoverEffect(false);
            final QuickSettingsContainerView parent = (QuickSettingsContainerView) topView.getParent();
            // Remove top view
            final int topViewIndex = parent.indexOfChild(topView);
            parent.removeViewAt(topViewIndex);
            // Remove bottom view
            final int bottomViewIndex = parent.indexOfChild(bottomView);
            parent.removeViewAt(bottomViewIndex);
            // Add both views to the new indexes
            parent.addView(topView, bottomViewIndex);
            parent.addView(bottomView, topViewIndex);
            // Animate the change
            parent.enableLayoutTransitions();
            break;
        default:
            break;
    }
    return true;
}
#end_block

#method_before
@Override
public void setTextSizes(int size) {
    mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
    super.setTextSizes(size);
}
#method_after
@Override
public void setTextSizes(int size) {
    mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
}
#end_block

#method_before
public void setTextSizes(int size) {
    mTileTextSize = size;
}
#method_after
public void setTextSizes(int size) {
// this will call changing text size on child views
}
#end_block

#method_before
public void toggleVisibility() {
    setHoverEffect(HOVER_COLOR_BLACK, mVisible);
    float scale = mVisible ? DISABLED : ENABLED;
    animate().scaleX(scale).scaleY(scale).setListener(new AnimatorListener() {

        @Override
        public void onAnimationCancel(Animator animation) {
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            mVisible = !mVisible;
        }

        @Override
        public void onAnimationRepeat(Animator animation) {
        }

        @Override
        public void onAnimationStart(Animator animation) {
        }
    });
}
#method_after
public void toggleVisibility() {
    setHoverEffect(HOVER_COLOR_BLACK, mVisible);
    float scale = mVisible ? DISABLED : ENABLED;
    animate().scaleX(scale).scaleY(scale).setListener(new AnimatorListenerAdapter() {

        @Override
        public void onAnimationEnd(Animator animation) {
            mVisible = !mVisible;
        }
    });
}
#end_block

#method_before
public void setService(PhoneStatusBar phoneStatusBar) {
    mStatusBarService = phoneStatusBar;
}
#method_after
public void setService(PhoneStatusBar phoneStatusBar) {
    mStatusBarService = phoneStatusBar;
    if (mModel != null) {
        mModel.setService(phoneStatusBar);
    }
}
#end_block

#method_before
private void addTiles(ViewGroup parent, boolean addMissing, boolean reset) {
    // If all the tiles were deleted, they are still loaded, but their visibility is changed
    if (reset) {
        parent.removeAllViews();
    }
    String tileContainer = Settings.System.getString(mContext.getContentResolver(), Settings.System.QUICK_SETTINGS_TILES);
    if (tileContainer == null)
        tileContainer = DEFAULT_TILES;
    Tile[] allTiles = Tile.values();
    String[] storedTiles = tileContainer.split(DELIMITER);
    List<String> allTilesArray = enumToStringArray(allTiles);
    List<String> storedTilesArray = Arrays.asList(storedTiles);
    for (String tile : addMissing ? allTilesArray : storedTilesArray) {
        boolean addTile = storedTilesArray.contains(tile);
        if (addMissing)
            addTile = !addTile;
        if (addTile) {
            if (Tile.USER.toString().equals(tile.toString())) {
                // User
                final QuickSettingsBasicUserTile userTile = new QuickSettingsBasicUserTile(mContext);
                userTile.setTileId(Tile.USER);
                userTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        final UserManager um = UserManager.get(mContext);
                        if (um.getUsers(true).size() > 1) {
                            // Since keyguard and systemui were merged into the same process to save
                            // memory, they share the same Looper and graphics context.  As a result,
                            // there's no way to allow concurrent animation while keyguard inflates.
                            // The workaround is to add a slight delay to allow the animation to finish.
                            mHandler.postDelayed(new Runnable() {

                                public void run() {
                                    try {
                                        WindowManagerGlobal.getWindowManagerService().lockNow(null);
                                    } catch (RemoteException e) {
                                        Log.e(TAG, "Couldn't show user switcher", e);
                                    }
                                }
                            }, // TODO: ideally this would be tied to the collapse of the panel
                            400);
                        } else {
                            Intent intent = ContactsContract.QuickContact.composeQuickContactsIntent(mContext, v, ContactsContract.Profile.CONTENT_URI, ContactsContract.QuickContact.MODE_LARGE, null);
                            mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
                        }
                    }
                });
                userTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SYNC_SETTINGS);
                        return true;
                    }
                });
                mModel.addUserTile(userTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        UserState us = (UserState) state;
                        userTile.setText(state.label);
                        userTile.setImageDrawable(us.avatar);
                        view.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_user, state.label));
                    }
                });
                parent.addView(userTile);
                if (addMissing)
                    userTile.setVisibility(View.GONE);
            } else if (Tile.BRIGHTNESS.toString().equals(tile.toString())) {
                // brightness
                // Brightness
                final QuickSettingsBasicTile brightnessTile = new QuickSettingsBasicTile(mContext);
                brightnessTile.setTileId(Tile.BRIGHTNESS);
                brightnessTile.setImageResource(R.drawable.ic_qs_brightness_auto_off);
                brightnessTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        showBrightnessDialog();
                    }
                });
                brightnessTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        boolean automaticAvailable = mContext.getResources().getBoolean(com.android.internal.R.bool.config_automatic_brightness_available);
                        // If we have automatic brightness available, toggle it
                        if (automaticAvailable) {
                            int automatic;
                            try {
                                automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, UserHandle.USER_CURRENT);
                            } catch (SettingNotFoundException snfe) {
                                automatic = 0;
                            }
                            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, automatic != 0 ? 0 : 1, UserHandle.USER_CURRENT);
                        }
                        return true;
                    }
                });
                mModel.addBrightnessTile(brightnessTile, new QuickSettingsModel.BasicRefreshCallback(brightnessTile));
                parent.addView(brightnessTile);
                if (addMissing)
                    brightnessTile.setVisibility(View.GONE);
            } else if (Tile.SETTINGS.toString().equals(tile.toString())) {
                // Settings tile
                // Settings tile
                final QuickSettingsBasicTile settingsTile = new QuickSettingsBasicTile(mContext);
                settingsTile.setTileId(Tile.SETTINGS);
                settingsTile.setImageResource(R.drawable.ic_qs_settings);
                settingsTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SETTINGS);
                    }
                });
                mModel.addSettingsTile(settingsTile, new QuickSettingsModel.BasicRefreshCallback(settingsTile));
                parent.addView(settingsTile);
                if (addMissing)
                    settingsTile.setVisibility(View.GONE);
            } else if (Tile.WIFI.toString().equals(tile.toString())) {
                // wifi tile
                // Wi-fi
                final QuickSettingsFlipTile wifiTile = new QuickSettingsFlipTile(mContext);
                wifiTile.setTileId(Tile.WIFI);
                wifiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
                        return true;
                    }
                });
                wifiTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        final boolean enable = (mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
                        new AsyncTask<Void, Void, Void>() {

                            @Override
                            protected Void doInBackground(Void... args) {
                                // Disable tethering if enabling Wifi
                                final int wifiApState = mWifiManager.getWifiApState();
                                if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
                                    mWifiManager.setWifiApEnabled(null, false);
                                }
                                mWifiManager.setWifiEnabled(enable);
                                return null;
                            }
                        }.execute();
                        wifiTile.setFrontLoading(true);
                        wifiTile.setFrontPressed(false);
                    }
                });
                mModel.addWifiTile(wifiTile.getFront(), new NetworkActivityCallback() {

                    private String mPreviousLabel = "";

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setFrontImageResource(wifiState.iconId);
                        wifiTile.setFrontText(wifiState.label);
                        wifiTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi, wifiState.signalContentDescription, (wifiState.connected) ? wifiState.label : ""));
                        if (wifiState.label != null && !mPreviousLabel.equals(wifiState.label)) {
                            wifiTile.setFrontLoading(false);
                            mPreviousLabel = wifiState.label;
                        }
                    }
                });
                final ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                wifiTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                        return true;
                    }
                });
                mModel.addWifiBackTile(wifiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setBackImageResource(wifiState.iconId);
                        wifiTile.setBackLabel(wifiState.label);
                        if (wifiState.connected) {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_label));
                        } else {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_off_label));
                        }
                    }
                });
                parent.addView(wifiTile);
                if (addMissing)
                    wifiTile.setVisibility(View.GONE);
            } else if (Tile.RSSI.toString().equals(tile.toString())) {
                // rssi tile
                if (mModel.deviceHasMobileData()) {
                    // RSSI
                    final QuickSettingsNetworkFlipTile rssiTile = new QuickSettingsNetworkFlipTile(mContext);
                    rssiTile.setTileId(Tile.RSSI);
                    final ConnectivityManager cms = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                    rssiTile.setBackLabel(mContext.getString(R.string.quick_settings_network_type));
                    rssiTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean currentState = cms.getMobileDataEnabled();
                            cms.setMobileDataEnabled(!currentState);
                        }
                    });
                    rssiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$DataUsageSummaryActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addRSSITile(rssiTile.getFront(), new NetworkActivityCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            RSSIState rssiState = (RSSIState) state;
                            // Force refresh
                            rssiTile.setFrontImageDrawable(null);
                            rssiTile.setFrontImageResource(rssiState.signalIconId);
                            if (rssiState.dataTypeIconId > 0) {
                                rssiTile.setFrontImageOverlayResource(rssiState.dataTypeIconId);
                            } else {
                                rssiTile.setFrontImageOverlayDrawable(null);
                            }
                            setActivity(view, rssiState);
                            rssiTile.setFrontText(state.label);
                            rssiTile.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile, rssiState.signalContentDescription, rssiState.dataContentDescription, state.label));
                        }
                    });
                    rssiTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent(Intent.ACTION_MAIN);
                            intent.setClassName("com.android.phone", "com.android.phone.Settings");
                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addMobileNetworkTile(rssiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State mobileNetworkState) {
                            rssiTile.setBackFunction(mobileNetworkState.label);
                            rssiTile.setBackImageResource(mobileNetworkState.iconId);
                        }
                    });
                    parent.addView(rssiTile);
                    if (addMissing)
                        rssiTile.setVisibility(View.GONE);
                }
            } else if (Tile.ROTATION.toString().equals(tile.toString())) {
                // Rotation Lock
                if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
                    final QuickSettingsBasicTile rotationLockTile = new QuickSettingsBasicTile(mContext);
                    rotationLockTile.setTileId(Tile.ROTATION);
                    rotationLockTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View view) {
                            final boolean locked = mRotationLockController.isRotationLocked();
                            mRotationLockController.setRotationLocked(!locked);
                        }
                    });
                    rotationLockTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_DISPLAY_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addRotationLockTile(rotationLockTile, mRotationLockController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            QuickSettingsModel.RotationLockState rotationLockState = (QuickSettingsModel.RotationLockState) state;
                            if (state.iconId != 0) {
                                // needed to flush any cached IDs
                                rotationLockTile.setImageDrawable(null);
                                rotationLockTile.setImageResource(state.iconId);
                            }
                            if (state.label != null) {
                                rotationLockTile.setText(state.label);
                            }
                        }
                    });
                    parent.addView(rotationLockTile);
                    if (addMissing)
                        rotationLockTile.setVisibility(View.GONE);
                }
            } else if (Tile.BATTERY.toString().equals(tile.toString())) {
                // battery tile
                // Battery
                mBatteryTile = new QuickSettingsBasicBatteryTile(mContext);
                updateBattery();
                mBatteryTile.setTileId(Tile.BATTERY);
                mBatteryTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
                    }
                });
                mModel.addBatteryTile(mBatteryTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryState batteryState = (QuickSettingsModel.BatteryState) state;
                        String t;
                        if (batteryState.batteryLevel == 100) {
                            t = mContext.getString(R.string.quick_settings_battery_charged_label);
                        } else {
                            if (batteryState.pluggedIn) {
                                t = // circle percent
                                mBatteryStyle != 3 ? mContext.getString(R.string.quick_settings_battery_charging_label, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_charging);
                            } else {
                                // battery bar or battery circle
                                t = (mBatteryStyle == 0 || mBatteryStyle == 2) ? mContext.getString(R.string.status_bar_settings_battery_meter_format, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_discharging);
                            }
                        }
                        mBatteryTile.setText(t);
                        mBatteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery, t));
                    }
                });
                parent.addView(mBatteryTile);
                if (addMissing)
                    mBatteryTile.setVisibility(View.GONE);
            } else if (Tile.IMMERSIVE.toString().equals(tile.toString())) {
                // Immersive tile
                // Immersive mode
                final QuickSettingsBasicTile immersiveTile = new QuickSettingsBasicTile(mContext);
                immersiveTile.setTileId(Tile.IMMERSIVE);
                immersiveTile.setImageResource(R.drawable.ic_qs_immersive_off);
                immersiveTile.setTextResource(R.string.quick_settings_immersive_mode_off_label);
                immersiveTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, checkModeOn ? 0 : 1);
                    }
                });
                mModel.addImmersiveTile(immersiveTile, new QuickSettingsModel.BasicRefreshCallback(immersiveTile));
                parent.addView(immersiveTile);
                if (addMissing)
                    immersiveTile.setVisibility(View.GONE);
            } else if (Tile.AIRPLANE.toString().equals(tile.toString())) {
                // airplane tile
                // Airplane Mode
                final QuickSettingsBasicTile airplaneTile = new QuickSettingsBasicTile(mContext);
                airplaneTile.setTileId(Tile.AIRPLANE);
                mModel.addAirplaneModeTile(airplaneTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        airplaneTile.setImageResource(state.iconId);
                        String airplaneState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane, airplaneState));
                        airplaneTile.setText(state.label);
                    }
                });
                parent.addView(airplaneTile);
                if (addMissing)
                    airplaneTile.setVisibility(View.GONE);
            } else if (Tile.USBMODE.toString().equals(tile.toString())) {
                // usb tile
                // Usb Mode
                final QuickSettingsBasicTile usbModeTile = new QuickSettingsBasicTile(mContext);
                usbModeTile.setTileId(Tile.USBMODE);
                final ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                usbModeTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                        return true;
                    }
                });
                mModel.addUsbModeTile(usbModeTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        usbModeTile.setImageResource(state.iconId);
                        usbModeTile.setText(state.label);
                    }
                });
                parent.addView(usbModeTile);
                if (addMissing)
                    usbModeTile.setVisibility(View.GONE);
            } else if (Tile.TORCH.toString().equals(tile.toString())) {
                // torch tile
                // Torch
                final QuickSettingsBasicTile torchTile = new QuickSettingsBasicTile(mContext);
                torchTile.setTileId(Tile.TORCH);
                torchTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(OmniTorchConstants.INTENT_LAUNCH_APP);
                        return true;
                    }
                });
                mModel.addTorchTile(torchTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        torchTile.setImageResource(state.iconId);
                        torchTile.setText(state.label);
                    }
                });
                parent.addView(torchTile);
                if (addMissing)
                    torchTile.setVisibility(View.GONE);
            } else if (Tile.SYNC.toString().equals(tile.toString())) {
                // sync tile
                // sync
                final QuickSettingsBasicTile SyncTile = new QuickSettingsBasicTile(mContext);
                SyncTile.setTileId(Tile.SYNC);
                SyncTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent("android.settings.SYNC_SETTINGS");
                        intent.addCategory(Intent.CATEGORY_DEFAULT);
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addSyncModeTile(SyncTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        SyncTile.setImageResource(state.iconId);
                        SyncTile.setText(state.label);
                    }
                });
                parent.addView(SyncTile);
                if (addMissing)
                    SyncTile.setVisibility(View.GONE);
            } else if (Tile.QUITEHOUR.toString().equals(tile.toString())) {
                // Quite hours tile
                // Quite hours mode
                final QuickSettingsBasicTile quiteHourTile = new QuickSettingsBasicTile(mContext);
                quiteHourTile.setTileId(Tile.QUITEHOUR);
                quiteHourTile.setImageResource(R.drawable.ic_qs_quiet_hours_off);
                quiteHourTile.setTextResource(R.string.quick_settings_quiethours_off_label);
                quiteHourTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, checkModeOn ? 0 : 1);
                        Intent scheduleSms = new Intent();
                        scheduleSms.setAction("com.android.settings.slim.service.SCHEDULE_SERVICE_COMMAND");
                        mContext.sendBroadcast(scheduleSms);
                    }
                });
                quiteHourTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent(Intent.ACTION_MAIN);
                        intent.setClassName("com.android.settings", "com.android.settings.Settings$QuietHoursSettingsActivity");
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addQuiteHourTile(quiteHourTile, new QuickSettingsModel.BasicRefreshCallback(quiteHourTile));
                parent.addView(quiteHourTile);
                if (addMissing)
                    quiteHourTile.setVisibility(View.GONE);
            } else if (Tile.VOLUME.toString().equals(tile.toString())) {
                // Volume tile
                // Volume mode
                final QuickSettingsFlipTile VolumeTile = new QuickSettingsFlipTile(mContext);
                VolumeTile.setTileId(Tile.VOLUME);
                VolumeTile.setFrontImageResource(R.drawable.ic_qs_volume);
                VolumeTile.setFrontText(mContext.getString(R.string.quick_settings_volume));
                VolumeTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                VolumeTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
                        am.adjustVolume(AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);
                    }
                });
                VolumeTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                mModel.addRingerModeTile(VolumeTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        VolumeTile.setBackImageResource(state.iconId);
                        VolumeTile.setBackFunction(state.label);
                    }
                });
                VolumeTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                parent.addView(VolumeTile);
                if (addMissing)
                    VolumeTile.setVisibility(View.GONE);
            } else if (Tile.SLEEP.toString().equals(tile.toString())) {
                // Sleep tile
                // Sleep
                final QuickSettingsFlipTile SleepTile = new QuickSettingsFlipTile(mContext);
                SleepTile.setTileId(Tile.SLEEP);
                SleepTile.setFrontImageResource(R.drawable.ic_qs_sleep);
                SleepTile.setFrontText(mContext.getString(R.string.quick_settings_screen_sleep));
                SleepTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                SleepTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        pm.goToSleep(SystemClock.uptimeMillis());
                    }
                });
                mModel.addSleepModeTile(SleepTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        SleepTile.setBackImageResource(state.iconId);
                        SleepTile.setBackFunction(state.label);
                    }
                });
                parent.addView(SleepTile);
                if (addMissing)
                    SleepTile.setVisibility(View.GONE);
            } else if (Tile.BLUETOOTH.toString().equals(tile.toString())) {
                // Bluetooth
                if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
                    final QuickSettingsFlipTile bluetoothTile = new QuickSettingsFlipTile(mContext);
                    bluetoothTile.setTileId(Tile.BLUETOOTH);
                    bluetoothTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (mBluetoothAdapter.isEnabled()) {
                                mBluetoothAdapter.disable();
                            } else {
                                mBluetoothAdapter.enable();
                            }
                            bluetoothTile.setFrontPressed(false);
                            bluetoothTile.setFrontLoading(true);
                        }
                    });
                    mModel.addBluetoothTile(bluetoothTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        private boolean mPreviousState = false;

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setFrontImageResource(state.iconId);
                            bluetoothTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setFrontText(state.label);
                            if (mPreviousState != state.enabled) {
                                bluetoothTile.setFrontLoading(false);
                                mPreviousState = state.enabled;
                            }
                        }
                    });
                    bluetoothTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (!mBluetoothAdapter.isEnabled()) {
                                return;
                            }
                            if (mBluetoothAdapter.getScanMode() != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    mModel.addBluetoothBackTile(bluetoothTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setBackImageResource(state.iconId);
                            bluetoothTile.setBackContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setBackLabel(state.label);
                            if (mBluetoothAdapter.getScanMode() == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    parent.addView(bluetoothTile);
                    if (addMissing)
                        bluetoothTile.setVisibility(View.GONE);
                }
            } else if (Tile.LOCATION.toString().equals(tile.toString())) {
                // Location
                // Location
                final QuickSettingsFlipTile locationTile = new QuickSettingsFlipTile(mContext);
                locationTile.setTileId(Tile.LOCATION);
                locationTile.setFrontImageResource(R.drawable.ic_qs_location_on);
                locationTile.setFrontText(mContext.getString(R.string.quick_settings_location_label));
                locationTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                locationTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                        return true;
                    }
                });
                locationTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean newLocationEnabledState = !mLocationController.isLocationEnabled();
                        if (mLocationController.setLocationEnabled(newLocationEnabledState) && newLocationEnabledState) {
                            // If we've successfully switched from location off to on, close the
                            // notifications tray to show the network location provider consent dialog.
                            Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                            mContext.sendBroadcast(closeDialog);
                        }
                    }
                });
                mModel.addLocationTile(locationTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        locationTile.setFrontImageResource(state.iconId);
                        String locationState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        locationTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_location, locationState));
                        locationTile.setFrontText(state.label);
                    }
                });
                locationTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        int newLocationMode = mLocationController.locationMode();
                        if (mLocationController.isLocationEnabled()) {
                            if (mLocationController.setBackLocationEnabled(newLocationMode)) {
                                if (mLocationController.isLocationAllowPanelCollapse()) {
                                    Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                                    mContext.sendBroadcast(closeDialog);
                                }
                            }
                        }
                    }
                });
                locationTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                        return true;
                    }
                });
                mModel.addBackLocationTile(locationTile.getBack(), mLocationController, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        locationTile.setBackImageResource(state.iconId);
                        locationTile.setBackFunction(state.label);
                    }
                });
                parent.addView(locationTile);
                if (addMissing)
                    locationTile.setVisibility(View.GONE);
            }
        }
    }
    if (!addMissing)
        addTiles(parent, true, false);
}
#method_after
private void addTiles(ViewGroup parent, boolean addMissing, boolean reset) {
    // If all the tiles were deleted, they are still loaded, but their visibility is changed
    if (reset) {
        parent.removeAllViews();
    }
    String tileContainer = Settings.System.getString(mContext.getContentResolver(), Settings.System.QUICK_SETTINGS_TILES);
    if (tileContainer == null)
        tileContainer = DEFAULT_TILES;
    Tile[] allTiles = Tile.values();
    String[] storedTiles = tileContainer.split(DELIMITER);
    List<String> allTilesArray = enumToStringArray(allTiles);
    List<String> storedTilesArray = Arrays.asList(storedTiles);
    for (String tile : addMissing ? allTilesArray : storedTilesArray) {
        boolean addTile = storedTilesArray.contains(tile);
        if (addMissing)
            addTile = !addTile;
        if (addTile) {
            if (Tile.USER.toString().equals(tile.toString())) {
                // User
                final QuickSettingsBasicUserTile userTile = new QuickSettingsBasicUserTile(mContext);
                userTile.setTileId(Tile.USER);
                userTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        final UserManager um = UserManager.get(mContext);
                        if (um.getUsers(true).size() > 1) {
                            // Since keyguard and systemui were merged into the same process to save
                            // memory, they share the same Looper and graphics context.  As a result,
                            // there's no way to allow concurrent animation while keyguard inflates.
                            // The workaround is to add a slight delay to allow the animation to finish.
                            mHandler.postDelayed(new Runnable() {

                                public void run() {
                                    try {
                                        WindowManagerGlobal.getWindowManagerService().lockNow(null);
                                    } catch (RemoteException e) {
                                        Log.e(TAG, "Couldn't show user switcher", e);
                                    }
                                }
                            }, // TODO: ideally this would be tied to the collapse of the panel
                            400);
                        } else {
                            Intent intent = ContactsContract.QuickContact.composeQuickContactsIntent(mContext, v, ContactsContract.Profile.CONTENT_URI, ContactsContract.QuickContact.MODE_LARGE, null);
                            mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
                        }
                    }
                });
                userTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SYNC_SETTINGS);
                        return true;
                    }
                });
                mModel.addUserTile(userTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        UserState us = (UserState) state;
                        userTile.setText(state.label);
                        userTile.setImageDrawable(us.avatar);
                        view.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_user, state.label));
                    }
                });
                parent.addView(userTile);
                if (addMissing)
                    userTile.setVisibility(View.GONE);
            } else if (Tile.BRIGHTNESS.toString().equals(tile.toString())) {
                // brightness
                // Brightness
                final QuickSettingsBasicTile brightnessTile = new QuickSettingsBasicTile(mContext);
                brightnessTile.setTileId(Tile.BRIGHTNESS);
                brightnessTile.setImageResource(R.drawable.ic_qs_brightness_auto_off);
                brightnessTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        showBrightnessDialog();
                    }
                });
                brightnessTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        boolean automaticAvailable = mContext.getResources().getBoolean(com.android.internal.R.bool.config_automatic_brightness_available);
                        // If we have automatic brightness available, toggle it
                        if (automaticAvailable) {
                            int automatic;
                            try {
                                automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, UserHandle.USER_CURRENT);
                            } catch (SettingNotFoundException snfe) {
                                automatic = 0;
                            }
                            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, automatic != 0 ? 0 : 1, UserHandle.USER_CURRENT);
                        }
                        return true;
                    }
                });
                mModel.addBrightnessTile(brightnessTile, new QuickSettingsModel.BasicRefreshCallback(brightnessTile));
                parent.addView(brightnessTile);
                if (addMissing)
                    brightnessTile.setVisibility(View.GONE);
            } else if (Tile.SETTINGS.toString().equals(tile.toString())) {
                // Settings tile
                // Settings tile
                final QuickSettingsBasicTile settingsTile = new QuickSettingsBasicTile(mContext);
                settingsTile.setTileId(Tile.SETTINGS);
                settingsTile.setImageResource(R.drawable.ic_qs_settings);
                settingsTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SETTINGS);
                    }
                });
                mModel.addSettingsTile(settingsTile, new QuickSettingsModel.BasicRefreshCallback(settingsTile));
                parent.addView(settingsTile);
                if (addMissing)
                    settingsTile.setVisibility(View.GONE);
            } else if (Tile.WIFI.toString().equals(tile.toString())) {
                // wifi tile
                // Wi-fi
                final QuickSettingsFlipTile wifiTile = new QuickSettingsFlipTile(mContext);
                wifiTile.setTileId(Tile.WIFI);
                wifiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
                        return true;
                    }
                });
                wifiTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        final boolean enable = (mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
                        new AsyncTask<Void, Void, Void>() {

                            @Override
                            protected Void doInBackground(Void... args) {
                                // Disable tethering if enabling Wifi
                                final int wifiApState = mWifiManager.getWifiApState();
                                if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
                                    mWifiManager.setWifiApEnabled(null, false);
                                }
                                mWifiManager.setWifiEnabled(enable);
                                return null;
                            }
                        }.execute();
                        wifiTile.setFrontLoading(true);
                        wifiTile.setFrontPressed(false);
                    }
                });
                mModel.addWifiTile(wifiTile.getFront(), new NetworkActivityCallback() {

                    private String mPreviousLabel = "";

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setFrontImageResource(wifiState.iconId);
                        wifiTile.setFrontText(wifiState.label);
                        wifiTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi, wifiState.signalContentDescription, (wifiState.connected) ? wifiState.label : ""));
                        if (wifiState.label != null && !mPreviousLabel.equals(wifiState.label)) {
                            wifiTile.setFrontLoading(false);
                            mPreviousLabel = wifiState.label;
                        }
                    }
                });
                wifiTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        if (DeviceUtils.deviceSupportsWifiAp(mContext)) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                        return true;
                    }
                });
                mModel.addWifiBackTile(wifiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setBackImageResource(wifiState.iconId);
                        wifiTile.setBackLabel(wifiState.label);
                        if (wifiState.connected) {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_label));
                        } else {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_off_label));
                        }
                    }
                });
                parent.addView(wifiTile);
                if (addMissing)
                    wifiTile.setVisibility(View.GONE);
            } else if (Tile.RSSI.toString().equals(tile.toString())) {
                // rssi tile
                if (DeviceUtils.deviceSupportsMobileData(mContext)) {
                    // RSSI
                    final QuickSettingsNetworkFlipTile rssiTile = new QuickSettingsNetworkFlipTile(mContext);
                    rssiTile.setTileId(Tile.RSSI);
                    final ConnectivityManager cms = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                    rssiTile.setBackLabel(mContext.getString(R.string.quick_settings_network_type));
                    rssiTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean currentState = cms.getMobileDataEnabled();
                            cms.setMobileDataEnabled(!currentState);
                        }
                    });
                    rssiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$DataUsageSummaryActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addRSSITile(rssiTile.getFront(), new NetworkActivityCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            RSSIState rssiState = (RSSIState) state;
                            // Force refresh
                            rssiTile.setFrontImageDrawable(null);
                            rssiTile.setFrontImageResource(rssiState.signalIconId);
                            if (rssiState.dataTypeIconId > 0) {
                                rssiTile.setFrontImageOverlayResource(rssiState.dataTypeIconId);
                            } else {
                                rssiTile.setFrontImageOverlayDrawable(null);
                            }
                            setActivity(view, rssiState);
                            rssiTile.setFrontText(state.label);
                            rssiTile.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile, rssiState.signalContentDescription, rssiState.dataContentDescription, state.label));
                        }
                    });
                    rssiTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent(Intent.ACTION_MAIN);
                            intent.setClassName("com.android.phone", "com.android.phone.Settings");
                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addMobileNetworkTile(rssiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State mobileNetworkState) {
                            rssiTile.setBackFunction(mobileNetworkState.label);
                            rssiTile.setBackImageResource(mobileNetworkState.iconId);
                        }
                    });
                    parent.addView(rssiTile);
                    if (addMissing)
                        rssiTile.setVisibility(View.GONE);
                }
            } else if (Tile.ROTATION.toString().equals(tile.toString())) {
                // Rotation Lock
                if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
                    final QuickSettingsBasicTile rotationLockTile = new QuickSettingsBasicTile(mContext);
                    rotationLockTile.setTileId(Tile.ROTATION);
                    rotationLockTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View view) {
                            final boolean locked = mRotationLockController.isRotationLocked();
                            mRotationLockController.setRotationLocked(!locked);
                        }
                    });
                    rotationLockTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_DISPLAY_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addRotationLockTile(rotationLockTile, mRotationLockController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            QuickSettingsModel.RotationLockState rotationLockState = (QuickSettingsModel.RotationLockState) state;
                            if (state.iconId != 0) {
                                // needed to flush any cached IDs
                                rotationLockTile.setImageDrawable(null);
                                rotationLockTile.setImageResource(state.iconId);
                            }
                            if (state.label != null) {
                                rotationLockTile.setText(state.label);
                            }
                        }
                    });
                    parent.addView(rotationLockTile);
                    if (addMissing)
                        rotationLockTile.setVisibility(View.GONE);
                }
            } else if (Tile.BATTERY.toString().equals(tile.toString())) {
                // battery tile
                // Battery
                mBatteryTile = new QuickSettingsBatteryFlipTile(mContext);
                updateBattery();
                mBatteryTile.setTileId(Tile.BATTERY);
                mBatteryTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
                    }
                });
                mModel.addBatteryTile(mBatteryTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryState batteryState = (QuickSettingsModel.BatteryState) state;
                        String t;
                        if (batteryState.batteryLevel == 100) {
                            t = mContext.getString(R.string.quick_settings_battery_charged_label);
                        } else {
                            if (batteryState.pluggedIn) {
                                t = // circle percent
                                mBatteryStyle != 3 ? mContext.getString(R.string.quick_settings_battery_charging_label, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_charging);
                            } else {
                                // battery bar or battery circle
                                t = (mBatteryStyle == 0 || mBatteryStyle == 2) ? mContext.getString(R.string.status_bar_settings_battery_meter_format, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_discharging);
                            }
                        }
                        mBatteryTile.setFrontText(t);
                        mBatteryTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery, t));
                    }
                });
                mBatteryTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
                    }
                });
                mModel.addBackBatteryTile(mBatteryTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryBackState batteryState = (QuickSettingsModel.BatteryBackState) state;
                        mBatteryTile.setBackLabel(batteryState.temperature);
                        mBatteryTile.setBackFunction(batteryState.voltage + batteryState.healthString);
                    }
                });
                parent.addView(mBatteryTile);
                if (addMissing)
                    mBatteryTile.setVisibility(View.GONE);
            } else if (Tile.IMMERSIVE.toString().equals(tile.toString())) {
                // Immersive tile
                // Immersive mode
                final QuickSettingsBasicTile immersiveTile = new QuickSettingsBasicTile(mContext);
                immersiveTile.setTileId(Tile.IMMERSIVE);
                immersiveTile.setImageResource(R.drawable.ic_qs_immersive_off);
                immersiveTile.setTextResource(R.string.quick_settings_immersive_mode_off_label);
                immersiveTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, checkModeOn ? 0 : 1);
                    }
                });
                mModel.addImmersiveTile(immersiveTile, new QuickSettingsModel.BasicRefreshCallback(immersiveTile));
                parent.addView(immersiveTile);
                if (addMissing)
                    immersiveTile.setVisibility(View.GONE);
            } else if (Tile.AIRPLANE.toString().equals(tile.toString())) {
                // airplane tile
                // Airplane Mode
                final QuickSettingsBasicTile airplaneTile = new QuickSettingsBasicTile(mContext);
                airplaneTile.setTileId(Tile.AIRPLANE);
                mModel.addAirplaneModeTile(airplaneTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        airplaneTile.setImageResource(state.iconId);
                        String airplaneState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane, airplaneState));
                        airplaneTile.setText(state.label);
                    }
                });
                parent.addView(airplaneTile);
                if (addMissing)
                    airplaneTile.setVisibility(View.GONE);
            } else if (Tile.USBMODE.toString().equals(tile.toString())) {
                // Usb Mode
                if (DeviceUtils.deviceSupportsUsbTether(mContext)) {
                    final QuickSettingsBasicTile usbModeTile = new QuickSettingsBasicTile(mContext);
                    usbModeTile.setTileId(Tile.USBMODE);
                    usbModeTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addUsbModeTile(usbModeTile, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            usbModeTile.setImageResource(state.iconId);
                            usbModeTile.setText(state.label);
                        }
                    });
                    parent.addView(usbModeTile);
                    if (addMissing)
                        usbModeTile.setVisibility(View.GONE);
                }
            } else if (Tile.TORCH.toString().equals(tile.toString())) {
                // Torch
                if (DeviceUtils.deviceSupportsTorch(mContext)) {
                    final QuickSettingsBasicTile torchTile = new QuickSettingsBasicTile(mContext);
                    torchTile.setTileId(Tile.TORCH);
                    torchTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(OmniTorchConstants.INTENT_LAUNCH_APP);
                            return true;
                        }
                    });
                    mModel.addTorchTile(torchTile, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            torchTile.setImageResource(state.iconId);
                            torchTile.setText(state.label);
                        }
                    });
                    parent.addView(torchTile);
                    if (addMissing)
                        torchTile.setVisibility(View.GONE);
                }
            } else if (Tile.SYNC.toString().equals(tile.toString())) {
                // sync tile
                // sync
                final QuickSettingsBasicTile SyncTile = new QuickSettingsBasicTile(mContext);
                SyncTile.setTileId(Tile.SYNC);
                SyncTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent("android.settings.SYNC_SETTINGS");
                        intent.addCategory(Intent.CATEGORY_DEFAULT);
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addSyncModeTile(SyncTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        SyncTile.setImageResource(state.iconId);
                        SyncTile.setText(state.label);
                    }
                });
                parent.addView(SyncTile);
                if (addMissing)
                    SyncTile.setVisibility(View.GONE);
            } else if (Tile.QUITEHOUR.toString().equals(tile.toString())) {
                // Quite hours tile
                // Quite hours mode
                final QuickSettingsBasicTile quiteHourTile = new QuickSettingsBasicTile(mContext);
                quiteHourTile.setTileId(Tile.QUITEHOUR);
                quiteHourTile.setImageResource(R.drawable.ic_qs_quiet_hours_off);
                quiteHourTile.setTextResource(R.string.quick_settings_quiethours_off_label);
                quiteHourTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, checkModeOn ? 0 : 1);
                        Intent scheduleSms = new Intent();
                        scheduleSms.setAction("com.android.settings.slim.service.SCHEDULE_SERVICE_COMMAND");
                        mContext.sendBroadcast(scheduleSms);
                    }
                });
                quiteHourTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent(Intent.ACTION_MAIN);
                        intent.setClassName("com.android.settings", "com.android.settings.Settings$QuietHoursSettingsActivity");
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addQuiteHourTile(quiteHourTile, new QuickSettingsModel.BasicRefreshCallback(quiteHourTile));
                parent.addView(quiteHourTile);
                if (addMissing)
                    quiteHourTile.setVisibility(View.GONE);
            } else if (Tile.VOLUME.toString().equals(tile.toString())) {
                // Volume tile
                // Volume mode
                final QuickSettingsFlipTile VolumeTile = new QuickSettingsFlipTile(mContext);
                VolumeTile.setTileId(Tile.VOLUME);
                VolumeTile.setFrontImageResource(R.drawable.ic_qs_volume);
                VolumeTile.setFrontText(mContext.getString(R.string.quick_settings_volume));
                VolumeTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                VolumeTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
                        am.adjustVolume(AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);
                    }
                });
                VolumeTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                mModel.addRingerModeTile(VolumeTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        VolumeTile.setBackImageResource(state.iconId);
                        VolumeTile.setBackFunction(state.label);
                    }
                });
                VolumeTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                parent.addView(VolumeTile);
                if (addMissing)
                    VolumeTile.setVisibility(View.GONE);
            } else if (Tile.SLEEP.toString().equals(tile.toString())) {
                // Sleep tile
                // Sleep
                final QuickSettingsFlipTile SleepTile = new QuickSettingsFlipTile(mContext);
                SleepTile.setTileId(Tile.SLEEP);
                SleepTile.setFrontImageResource(R.drawable.ic_qs_sleep);
                SleepTile.setFrontText(mContext.getString(R.string.quick_settings_screen_sleep));
                SleepTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                SleepTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        pm.goToSleep(SystemClock.uptimeMillis());
                    }
                });
                SleepTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        collapsePanels();
                        Intent intent = new Intent(Intent.ACTION_POWERMENU);
                        mContext.sendBroadcast(intent);
                        return true;
                    }
                });
                mModel.addSleepModeTile(SleepTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        SleepTile.setBackImageResource(state.iconId);
                        SleepTile.setBackFunction(state.label);
                    }
                });
                parent.addView(SleepTile);
                if (addMissing)
                    SleepTile.setVisibility(View.GONE);
            } else if (Tile.BLUETOOTH.toString().equals(tile.toString())) {
                // Bluetooth
                if (DeviceUtils.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
                    final QuickSettingsFlipTile bluetoothTile = new QuickSettingsFlipTile(mContext);
                    bluetoothTile.setTileId(Tile.BLUETOOTH);
                    bluetoothTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (mBluetoothAdapter.isEnabled()) {
                                mBluetoothAdapter.disable();
                            } else {
                                mBluetoothAdapter.enable();
                            }
                            bluetoothTile.setFrontPressed(false);
                            bluetoothTile.setFrontLoading(true);
                        }
                    });
                    mModel.addBluetoothTile(bluetoothTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        private boolean mPreviousState = false;

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setFrontImageResource(state.iconId);
                            bluetoothTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setFrontText(state.label);
                            if (mPreviousState != state.enabled) {
                                bluetoothTile.setFrontLoading(false);
                                mPreviousState = state.enabled;
                            }
                        }
                    });
                    bluetoothTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (!mBluetoothAdapter.isEnabled()) {
                                return;
                            }
                            if (mBluetoothAdapter.getScanMode() != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    mModel.addBluetoothBackTile(bluetoothTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setBackImageResource(state.iconId);
                            bluetoothTile.setBackContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setBackLabel(state.label);
                            if (mBluetoothAdapter.getScanMode() == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    parent.addView(bluetoothTile);
                    if (addMissing)
                        bluetoothTile.setVisibility(View.GONE);
                }
            } else if (Tile.LOCATION.toString().equals(tile.toString())) {
                // Location
                if (DeviceUtils.deviceSupportsGps(mContext)) {
                    final QuickSettingsFlipTile locationTile = new QuickSettingsFlipTile(mContext);
                    locationTile.setTileId(Tile.LOCATION);
                    locationTile.setFrontImageResource(R.drawable.ic_qs_location_default_on);
                    locationTile.setFrontText(mContext.getString(R.string.quick_settings_location_label));
                    locationTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                    locationTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                            return true;
                        }
                    });
                    locationTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean newLocationEnabledState = !mLocationController.isLocationEnabled();
                            if (mLocationController.setLocationEnabled(newLocationEnabledState) && mLocationController.isLocationAllowPanelCollapse()) {
                                // If we've successfully switched from location off to on, close the
                                // notifications tray to show the network location provider consent dialog.
                                Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                                mContext.sendBroadcast(closeDialog);
                            }
                        }
                    });
                    mModel.addLocationTile(locationTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            locationTile.setFrontImageResource(state.iconId);
                            String locationState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                            locationTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_location, locationState));
                            locationTile.setFrontText(state.label);
                        }
                    });
                    locationTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            int newLocationMode = mLocationController.getLocationMode();
                            if (mLocationController.isLocationEnabled()) {
                                if (mLocationController.setBackLocationEnabled(newLocationMode)) {
                                    if (mLocationController.isLocationAllowPanelCollapse()) {
                                        // If we've successfully switched from location off to on, close the
                                        // notifications tray to show the network location provider consent dialog.
                                        Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                                        mContext.sendBroadcast(closeDialog);
                                    }
                                }
                            }
                        }
                    });
                    locationTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addBackLocationTile(locationTile.getBack(), mLocationController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            locationTile.setBackImageResource(state.iconId);
                            locationTile.setBackFunction(state.label);
                        }
                    });
                    parent.addView(locationTile);
                    if (addMissing)
                        locationTile.setVisibility(View.GONE);
                }
            }
        }
    }
    if (!addMissing)
        addTiles(parent, true, false);
}
#end_block

#method_before
void updateResources() {
    // Update the model
    if (mModel != null) {
        mModel.updateResources();
    }
    QuickSettingsContainerView container = ((QuickSettingsContainerView) mContainerView);
    container.updateResources();
    container.updateSpan();
    mContainerView.requestLayout();
}
#method_after
public void updateResources() {
    // Update the model
    if (mModel != null) {
        mModel.updateResources();
    }
    mContainerView.updateResources();
}
#end_block

#method_before
@Override
public void setTextSizes(int size) {
    mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
    super.setTextSizes(size);
}
#method_after
@Override
public void setTextSizes(int size) {
    mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
}
#end_block

#method_before
public void updateResources() {
    mCellGap = mResources.getDimension(R.dimen.quick_settings_cell_gap);
    mNumColumns = mResources.getInteger(R.integer.quick_settings_num_columns);
    mNumFinalColumns = mResources.getInteger(R.integer.quick_settings_numfinal_columns);
    mNumFinalCol = shouldUpdateColumns() ? mNumFinalColumns : mNumColumns;
    requestLayout();
}
#method_after
public void updateResources() {
    mCellGap = mResources.getDimension(R.dimen.quick_settings_cell_gap);
    mNumColumns = mResources.getInteger(R.integer.quick_settings_num_columns);
    mNumFinalColumns = mResources.getInteger(R.integer.quick_settings_numfinal_columns);
    mNumFinalCol = shouldUpdateColumns() ? mNumFinalColumns : mNumColumns;
    updateSpan();
    requestLayout();
}
#end_block

#method_before
public void updateSpan() {
    for (int i = 0; i < getChildCount(); i++) {
        View v = getChildAt(i);
        if (v instanceof QuickSettingsTileView) {
            QuickSettingsTileView qs = (QuickSettingsTileView) v;
            qs.setTextSizes(getTileTextSize());
            if (i < 3 && getTilesSize() < 10 + i) {
                // Modify span of the first three childs
                int span = mResources.getInteger(R.integer.quick_settings_user_time_settings_tile_span);
                qs.setColumnSpan(span);
            } else {
                // One column item
                qs.setColumnSpan(1);
            }
        }
    }
}
#method_after
public void updateSpan() {
    for (int i = 0; i < getChildCount(); i++) {
        View v = getChildAt(i);
        if (v instanceof QuickSettingsTileView) {
            QuickSettingsTileView qs = (QuickSettingsTileView) v;
            // Update column on child view for text sizes
            qs.setColumns(mNumFinalCol);
        }
    }
}
#end_block

#method_before
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    final int N = getChildCount();
    final int width = getWidth();
    int x = getPaddingStart();
    int y = getPaddingTop();
    int cursor = 0;
    float cellGap = mCellGap;
    for (int i = 0; i < N; ++i) {
        QuickSettingsTileView child = (QuickSettingsTileView) getChildAt(i);
        ViewGroup.LayoutParams lp = child.getLayoutParams();
        if (child.getVisibility() != GONE) {
            final int col = cursor % mNumFinalCol;
            final int colSpan = child.getColumnSpan();
            final int childWidth = lp.width;
            final int childHeight = lp.height;
            int row = (int) (cursor / mNumFinalCol);
            // Push the item to the next row if it can't fit on this one
            if ((col + colSpan) > mNumFinalCol) {
                x = getPaddingStart();
                y += childHeight + cellGap;
                row++;
            }
            final int childLeft = isLayoutRtl() ? width - x - childWidth : x;
            final int childRight = childLeft + childWidth;
            final int childTop = y;
            final int childBottom = childTop + childHeight;
            // Layout the container
            child.layout(childLeft, childTop, childRight, childBottom);
            // Offset the position by the cell gap or reset the position and cursor when we
            // reach the end of the row
            cursor += child.getColumnSpan();
            if (cursor < (((row + 1) * mNumFinalCol))) {
                x += childWidth + cellGap;
            } else {
                x = getPaddingStart();
                y += childHeight + cellGap;
            }
        }
    }
    updateSpan();
}
#method_after
@Override
protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
    final int N = getChildCount();
    final int width = getWidth();
    int x = getPaddingStart();
    int y = getPaddingTop();
    int cursor = 0;
    float cellGap = mCellGap;
    for (int i = 0; i < N; ++i) {
        QuickSettingsTileView child = (QuickSettingsTileView) getChildAt(i);
        ViewGroup.LayoutParams lp = child.getLayoutParams();
        if (child.getVisibility() != GONE) {
            final int col = cursor % mNumFinalCol;
            final int colSpan = child.getColumnSpan();
            final int childWidth = lp.width;
            final int childHeight = lp.height;
            int row = (int) (cursor / mNumFinalCol);
            // Push the item to the next row if it can't fit on this one
            if ((col + colSpan) > mNumFinalCol) {
                x = getPaddingStart();
                y += childHeight + cellGap;
                row++;
            }
            final int childLeft = isLayoutRtl() ? width - x - childWidth : x;
            final int childRight = childLeft + childWidth;
            final int childTop = y;
            final int childBottom = childTop + childHeight;
            // Layout the container
            child.layout(childLeft, childTop, childRight, childBottom);
            // Offset the position by the cell gap or reset the position and cursor when we
            // reach the end of the row
            cursor += child.getColumnSpan();
            if (cursor < (((row + 1) * mNumFinalCol))) {
                x += childWidth + cellGap;
            } else {
                x = getPaddingStart();
                y += childHeight + cellGap;
            }
        }
    }
}
#end_block

#method_before
private boolean isLandscape() {
    return Resources.getSystem().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;
}
#method_after
private boolean isLandscape() {
    return (mCurrOrientation == Configuration.ORIENTATION_LANDSCAPE);
}
#end_block

#method_before
public void setEditModeEnabled(boolean enabled) {
    mEditModeEnabled = enabled;
    mEditModeChangedListener.onEditModeChanged(enabled);
    ArrayList<String> tiles = new ArrayList<String>();
    for (int i = 0; i < getChildCount(); i++) {
        View v = getChildAt(i);
        if (v instanceof QuickSettingsTileView) {
            QuickSettingsTileView qs = (QuickSettingsTileView) v;
            qs.setEditMode(enabled);
            // Add to provider string
            if (!enabled && qs.getVisibility() == View.VISIBLE && !qs.isTemporary()) {
                tiles.add(qs.getTileId().toString());
            }
        }
    }
    if (!enabled) {
        // Store modifications
        ContentResolver resolver = getContext().getContentResolver();
        if (!tiles.isEmpty()) {
            Settings.System.putString(resolver, Settings.System.QUICK_SETTINGS_TILES, TextUtils.join(QuickSettings.DELIMITER, tiles));
        } else {
            // No tiles
            Settings.System.putString(resolver, Settings.System.QUICK_SETTINGS_TILES, QuickSettings.NO_TILES);
        }
        updateSpan();
    }
}
#method_after
public void setEditModeEnabled(boolean enabled) {
    mEditModeEnabled = enabled;
    mEditModeChangedListener.onEditModeChanged(enabled);
    ArrayList<String> tiles = new ArrayList<String>();
    for (int i = 0; i < getChildCount(); i++) {
        View v = getChildAt(i);
        if (v instanceof QuickSettingsTileView) {
            QuickSettingsTileView qs = (QuickSettingsTileView) v;
            qs.setEditMode(enabled);
            // Add to provider string
            if (!enabled && qs.getVisibility() == View.VISIBLE && !qs.isTemporary()) {
                tiles.add(qs.getTileId().toString());
            }
        }
    }
    if (!enabled) {
        // Store modifications
        ContentResolver resolver = getContext().getContentResolver();
        if (!tiles.isEmpty()) {
            Settings.System.putString(resolver, Settings.System.QUICK_SETTINGS_TILES, TextUtils.join(QuickSettings.DELIMITER, tiles));
        } else {
            // No tiles
            Settings.System.putString(resolver, Settings.System.QUICK_SETTINGS_TILES, QuickSettings.NO_TILES);
        }
    }
}
#end_block

#method_before
@Override
public boolean onTouch(View view, MotionEvent event) {
    QuickSettingsTileView tile = ((QuickSettingsTileView) view);
    int action = event.getAction();
    if (tile.isEditModeEnabled()) {
        if (action == MotionEvent.ACTION_DOWN) {
            mDragPoint = new Point((int) event.getX(), (int) event.getY());
        }
        if (action == MotionEvent.ACTION_MOVE) {
            mCurrentPoint = new Point((int) event.getX(), (int) event.getY());
            double distance = Math.sqrt(Math.pow(mDragPoint.x - mCurrentPoint.x, 2) + Math.pow(mCurrentPoint.y - mCurrentPoint.y, 2));
            // Only allow drag & drop when on edit mode
            if (distance >= DISTANCE_THRESHOLD) {
                ClipData data = ClipData.newPlainText("", "");
                DragShadowBuilder shadowBuilder = new View.DragShadowBuilder(view);
                view.getParent().requestDisallowInterceptTouchEvent(true);
                view.startDrag(data, shadowBuilder, view, 0);
                ((QuickSettingsTileView) view).fadeOut();
                return true;
            }
            return false;
        } else {
            return false;
        }
    } else {
        mDetector.onTouchEvent(event);
        if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
            mDegrees = 0;
            view.animate().setInterpolator(mInterpolator).setDuration(150).rotationY(0).start();
            return false;
        }
        return false;
    }
}
#method_after
@Override
public boolean onTouch(View view, MotionEvent event) {
    QuickSettingsTileView tile = ((QuickSettingsTileView) view);
    int action = event.getAction();
    if (tile.isEditModeEnabled()) {
        if (action == MotionEvent.ACTION_DOWN) {
            mDragPoint = new Point((int) event.getX(), (int) event.getY());
        }
        if (action == MotionEvent.ACTION_MOVE) {
            mCurrentPoint = new Point((int) event.getX(), (int) event.getY());
            double distance = Math.abs(mDragPoint.x - mCurrentPoint.x) + Math.abs(mDragPoint.y - mCurrentPoint.y);
            // Only allow drag & drop when on edit mode
            if (distance >= DISTANCE_THRESHOLD) {
                ClipData data = ClipData.newPlainText("", "");
                DragShadowBuilder shadowBuilder = new View.DragShadowBuilder(view);
                view.getParent().requestDisallowInterceptTouchEvent(true);
                view.startDrag(data, shadowBuilder, view, 0);
                ((QuickSettingsTileView) view).fadeOut();
                return true;
            }
            return false;
        } else {
            return false;
        }
    } else {
        mDetector.onTouchEvent(event);
        if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_CANCEL) {
            mDegrees = 0;
            view.animate().setInterpolator(mInterpolator).setDuration(150).rotationY(0).start();
            return false;
        }
        return false;
    }
}
#end_block

#method_before
@Override
public void setTextSizes(int size) {
    mBack.setTextSizes(size);
    mFront.setTextSizes(size);
    super.setTextSizes(size);
}
#method_after
@Override
public void setTextSizes(int size) {
    mBack.setTextSizes(size);
    mFront.setTextSizes(size);
}
#end_block

#method_before
@Override
public void setTextSizes(int size) {
    mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
    super.setTextSizes(size);
}
#method_after
@Override
public void setTextSizes(int size) {
    mTextView.setTextSize(TypedValue.COMPLEX_UNIT_PX, size);
}
#end_block

#method_before
private void resetTimeout() {
    removeMessages(MSG_TIMEOUT);
    sendMessageDelayed(obtainMessage(MSG_TIMEOUT), TIMEOUT_DELAY);
}
#method_after
private void resetTimeout() {
    removeMessages(MSG_TIMEOUT);
    sendMessageDelayed(obtainMessage(MSG_TIMEOUT), mCustomTimeoutDelay);
}
#end_block

#method_before
void updateResources() {
    refreshSettingsTile();
    refreshBatteryTile();
    refreshBluetoothTile();
    refreshBrightnessTile();
    refreshImmersiveTile();
    refreshQuiteHourTile();
    refreshRotationLockTile();
    refreshRssiTile();
    refreshLocationTile();
    updateSleepState();
    refreshBackLocationTile();
}
#method_after
void updateResources() {
    refreshSettingsTile();
    refreshBatteryTile();
    refreshBluetoothTile();
    refreshBrightnessTile();
    refreshImmersiveTile();
    onQuiteHourChanged();
    refreshRotationLockTile();
    refreshRssiTile();
    refreshLocationTile();
    refreshBackLocationTile();
    updateRingerState();
    updateSleepState();
    onMobileNetworkChanged();
}
#end_block

#method_before
String getWifiIpAddr() {
    WifiManager wifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
    WifiInfo wifiInfo = wifiManager.getConnectionInfo();
    int ip = wifiInfo.getIpAddress();
    String ipString = String.format("%d.%d.%d.%d", (ip & 0xff), (ip >> 8 & 0xff), (ip >> 16 & 0xff), (ip >> 24 & 0xff));
    return ipString;
}
#method_after
String getWifiIpAddr() {
    WifiInfo wifiInfo = mWifiManager.getConnectionInfo();
    int ip = wifiInfo.getIpAddress();
    String ipString = String.format("%d.%d.%d.%d", (ip & 0xff), (ip >> 8 & 0xff), (ip >> 16 & 0xff), (ip >> 24 & 0xff));
    return ipString;
}
#end_block

#method_before
@Override
public void onMobileDataSignalChanged(boolean enabled, int mobileSignalIconId, String signalContentDescription, int dataTypeIconId, boolean activityIn, boolean activityOut, String dataContentDescription, String enabledDesc) {
    if (deviceHasMobileData()) {
        // TODO: If view is in awaiting state, disable
        Resources r = mContext.getResources();
        mRSSIState.signalIconId = enabled && (mobileSignalIconId > 0) ? mobileSignalIconId : R.drawable.ic_qs_signal_no_signal;
        mRSSIState.signalContentDescription = enabled && (mobileSignalIconId > 0) ? signalContentDescription : r.getString(R.string.accessibility_no_signal);
        mRSSIState.dataTypeIconId = enabled && (dataTypeIconId > 0) && !mWifiState.enabled ? dataTypeIconId : 0;
        mRSSIState.activityIn = enabled && activityIn;
        mRSSIState.activityOut = enabled && activityOut;
        mRSSIState.dataContentDescription = enabled && (dataTypeIconId > 0) && !mWifiState.enabled ? dataContentDescription : r.getString(R.string.accessibility_no_data);
        mRSSIState.label = enabled ? removeTrailingPeriod(enabledDesc) : r.getString(R.string.quick_settings_rssi_emergency_only);
        mRSSIState.networkType = getNetworkType(r);
        mRSSICallback.refreshView(mRSSITile, mRSSIState);
    }
}
#method_after
@Override
public void onMobileDataSignalChanged(boolean enabled, int mobileSignalIconId, String signalContentDescription, int dataTypeIconId, boolean activityIn, boolean activityOut, String dataContentDescription, String enabledDesc) {
    if (deviceHasMobileData()) {
        // TODO: If view is in awaiting state, disable
        Resources r = mContext.getResources();
        mRSSIState.signalIconId = enabled && (mobileSignalIconId > 0) ? mobileSignalIconId : R.drawable.ic_qs_signal_no_signal;
        mRSSIState.signalContentDescription = enabled && (mobileSignalIconId > 0) ? signalContentDescription : r.getString(R.string.accessibility_no_signal);
        mRSSIState.dataTypeIconId = enabled && (dataTypeIconId > 0) && !mWifiState.enabled ? dataTypeIconId : 0;
        mRSSIState.activityIn = enabled && activityIn;
        mRSSIState.activityOut = enabled && activityOut;
        mRSSIState.dataContentDescription = enabled && (dataTypeIconId > 0) && !mWifiState.enabled ? dataContentDescription : r.getString(R.string.accessibility_no_data);
        mRSSIState.label = enabled ? removeTrailingPeriod(enabledDesc) : r.getString(R.string.quick_settings_rssi_emergency_only);
        mRSSICallback.refreshView(mRSSITile, mRSSIState);
    }
    onMobileNetworkChanged();
}
#end_block

#method_before
private String getNetworkType(Resources r) {
    int state = networkModeToState(get2G3G());
    switch(state) {
        case 1:
            return r.getString(R.string.network_2G);
        case 2:
            return r.getString(R.string.network_3G_only);
        case 3:
            return r.getString(R.string.network_3G_auto);
        case 4:
            return r.getString(R.string.network_3G);
    }
    return "global";
}
#method_after
private String getNetworkType(Resources r) {
    boolean isEnabled = mCM.getMobileDataEnabled();
    int state = get2G3G();
    switch(state) {
        case Phone.NT_MODE_GLOBAL:
        case Phone.NT_MODE_LTE_CDMA_AND_EVDO:
        case Phone.NT_MODE_LTE_GSM_WCDMA:
        case Phone.NT_MODE_LTE_CMDA_EVDO_GSM_WCDMA:
        case Phone.NT_MODE_LTE_ONLY:
        case Phone.NT_MODE_LTE_WCDMA:
            if (!isEnabled) {
                return r.getString(R.string.network_4G) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_4G);
            }
        case Phone.NT_MODE_GSM_UMTS:
            if (!isEnabled) {
                return r.getString(R.string.network_3G_auto) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_3G_auto);
            }
        case Phone.NT_MODE_WCDMA_ONLY:
            if (!isEnabled) {
                return r.getString(R.string.network_3G_only) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_3G_only);
            }
        case Phone.NT_MODE_EVDO_NO_CDMA:
        case Phone.NT_MODE_CDMA_NO_EVDO:
        case Phone.NT_MODE_GSM_ONLY:
            if (!isEnabled) {
                return r.getString(R.string.network_2G) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_2G);
            }
        case Phone.NT_MODE_CDMA:
        case Phone.NT_MODE_WCDMA_PREF:
            if (!isEnabled) {
                return r.getString(R.string.network_3G) + r.getString(R.string.quick_settings_network_disable);
            } else {
                return r.getString(R.string.network_3G);
            }
    }
    return r.getString(R.string.quick_settings_network_unknown);
}
#end_block

#method_before
private int get2G3G() {
    int state = 99;
    try {
        state = Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE);
    } catch (SettingNotFoundException e) {
    // Do nothing
    }
    return state;
}
#method_after
private int get2G3G() {
    return Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, Phone.PREFERRED_NT_MODE);
}
#end_block

#method_before
private void addTiles(ViewGroup parent, boolean addMissing, boolean reset) {
    // If all the tiles were deleted, they are still loaded, but their visibility is changed
    if (reset) {
        parent.removeAllViews();
    }
    String tileContainer = Settings.System.getString(mContext.getContentResolver(), Settings.System.QUICK_SETTINGS_TILES);
    if (tileContainer == null)
        tileContainer = DEFAULT_TILES;
    Tile[] allTiles = Tile.values();
    String[] storedTiles = tileContainer.split(DELIMITER);
    List<String> allTilesArray = enumToStringArray(allTiles);
    List<String> storedTilesArray = Arrays.asList(storedTiles);
    for (String tile : addMissing ? allTilesArray : storedTilesArray) {
        boolean addTile = storedTilesArray.contains(tile);
        if (addMissing)
            addTile = !addTile;
        if (addTile) {
            if (Tile.USER.toString().equals(tile.toString())) {
                // User
                final QuickSettingsBasicUserTile userTile = new QuickSettingsBasicUserTile(mContext);
                userTile.setTileId(Tile.USER);
                userTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        final UserManager um = UserManager.get(mContext);
                        if (um.getUsers(true).size() > 1) {
                            // Since keyguard and systemui were merged into the same process to save
                            // memory, they share the same Looper and graphics context.  As a result,
                            // there's no way to allow concurrent animation while keyguard inflates.
                            // The workaround is to add a slight delay to allow the animation to finish.
                            mHandler.postDelayed(new Runnable() {

                                public void run() {
                                    try {
                                        WindowManagerGlobal.getWindowManagerService().lockNow(null);
                                    } catch (RemoteException e) {
                                        Log.e(TAG, "Couldn't show user switcher", e);
                                    }
                                }
                            }, // TODO: ideally this would be tied to the collapse of the panel
                            400);
                        } else {
                            Intent intent = ContactsContract.QuickContact.composeQuickContactsIntent(mContext, v, ContactsContract.Profile.CONTENT_URI, ContactsContract.QuickContact.MODE_LARGE, null);
                            mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
                        }
                    }
                });
                userTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SYNC_SETTINGS);
                        return true;
                    }
                });
                mModel.addUserTile(userTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        UserState us = (UserState) state;
                        userTile.setText(state.label);
                        userTile.setImageDrawable(us.avatar);
                        view.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_user, state.label));
                    }
                });
                parent.addView(userTile);
                if (addMissing)
                    userTile.setVisibility(View.GONE);
            } else if (Tile.BRIGHTNESS.toString().equals(tile.toString())) {
                // brightness
                // Brightness
                final QuickSettingsBasicTile brightnessTile = new QuickSettingsBasicTile(mContext);
                brightnessTile.setTileId(Tile.BRIGHTNESS);
                brightnessTile.setImageResource(R.drawable.ic_qs_brightness_auto_off);
                brightnessTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        showBrightnessDialog();
                    }
                });
                brightnessTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        boolean automaticAvailable = mContext.getResources().getBoolean(com.android.internal.R.bool.config_automatic_brightness_available);
                        // If we have automatic brightness available, toggle it
                        if (automaticAvailable) {
                            int automatic;
                            try {
                                automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, UserHandle.USER_CURRENT);
                            } catch (SettingNotFoundException snfe) {
                                automatic = 0;
                            }
                            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, automatic != 0 ? 0 : 1, UserHandle.USER_CURRENT);
                        }
                        return true;
                    }
                });
                mModel.addBrightnessTile(brightnessTile, new QuickSettingsModel.BasicRefreshCallback(brightnessTile));
                parent.addView(brightnessTile);
                if (addMissing)
                    brightnessTile.setVisibility(View.GONE);
            } else if (Tile.SETTINGS.toString().equals(tile.toString())) {
                // Settings tile
                // Settings tile
                final QuickSettingsBasicTile settingsTile = new QuickSettingsBasicTile(mContext);
                settingsTile.setTileId(Tile.SETTINGS);
                settingsTile.setImageResource(R.drawable.ic_qs_settings);
                settingsTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SETTINGS);
                    }
                });
                mModel.addSettingsTile(settingsTile, new QuickSettingsModel.BasicRefreshCallback(settingsTile));
                parent.addView(settingsTile);
                if (addMissing)
                    settingsTile.setVisibility(View.GONE);
            } else if (Tile.WIFI.toString().equals(tile.toString())) {
                // wifi tile
                // Wi-fi
                final QuickSettingsFlipTile wifiTile = new QuickSettingsFlipTile(mContext);
                wifiTile.setTileId(Tile.WIFI);
                wifiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
                        return true;
                    }
                });
                wifiTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        final boolean enable = (mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
                        new AsyncTask<Void, Void, Void>() {

                            @Override
                            protected Void doInBackground(Void... args) {
                                // Disable tethering if enabling Wifi
                                final int wifiApState = mWifiManager.getWifiApState();
                                if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
                                    mWifiManager.setWifiApEnabled(null, false);
                                }
                                mWifiManager.setWifiEnabled(enable);
                                return null;
                            }
                        }.execute();
                        wifiTile.setFrontLoading(true);
                        wifiTile.setFrontPressed(false);
                    }
                });
                mModel.addWifiTile(wifiTile.getFront(), new NetworkActivityCallback() {

                    private String mPreviousLabel = "";

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setFrontImageResource(wifiState.iconId);
                        wifiTile.setFrontText(wifiState.label);
                        wifiTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi, wifiState.signalContentDescription, (wifiState.connected) ? wifiState.label : ""));
                        if (wifiState.label != null && !mPreviousLabel.equals(wifiState.label)) {
                            wifiTile.setFrontLoading(false);
                            mPreviousLabel = wifiState.label;
                        }
                    }
                });
                final ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                wifiTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                    }
                });
                mModel.addWifiBackTile(wifiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setBackImageResource(wifiState.iconId);
                        wifiTile.setBackLabel(wifiState.label);
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_label));
                        } else {
                            wifiTile.setBackFunction("");
                        }
                    }
                });
                parent.addView(wifiTile);
                if (addMissing)
                    wifiTile.setVisibility(View.GONE);
            } else if (Tile.RSSI.toString().equals(tile.toString())) {
                // rssi tile
                if (mModel.deviceHasMobileData()) {
                    // RSSI
                    final QuickSettingsBasicNetworkTile rssiTile = new QuickSettingsBasicNetworkTile(mContext);
                    rssiTile.setTileId(Tile.RSSI);
                    final ConnectivityManager cms = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                    rssiTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean currentState = cms.getMobileDataEnabled();
                            cms.setMobileDataEnabled(!currentState);
                        }
                    });
                    rssiTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$DataUsageSummaryActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addRSSITile(rssiTile, new NetworkActivityCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            RSSIState rssiState = (RSSIState) state;
                            // Force refresh
                            rssiTile.setImageDrawable(null);
                            rssiTile.setImageResource(rssiState.signalIconId);
                            if (rssiState.dataTypeIconId > 0) {
                                rssiTile.setImageOverlayResource(rssiState.dataTypeIconId);
                            } else {
                                rssiTile.setImageOverlayDrawable(null);
                            }
                            setActivity(view, rssiState);
                            rssiTile.setText(state.label);
                            rssiTile.setNetworkText(rssiState.networkType);
                            rssiTile.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile, rssiState.signalContentDescription, rssiState.dataContentDescription, state.label));
                        }
                    });
                    parent.addView(rssiTile);
                    if (addMissing)
                        rssiTile.setVisibility(View.GONE);
                }
            } else if (Tile.ROTATION.toString().equals(tile.toString())) {
                // Rotation Lock
                if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
                    final QuickSettingsBasicTile rotationLockTile = new QuickSettingsBasicTile(mContext);
                    rotationLockTile.setTileId(Tile.ROTATION);
                    rotationLockTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View view) {
                            final boolean locked = mRotationLockController.isRotationLocked();
                            mRotationLockController.setRotationLocked(!locked);
                        }
                    });
                    rotationLockTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_DISPLAY_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addRotationLockTile(rotationLockTile, mRotationLockController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            QuickSettingsModel.RotationLockState rotationLockState = (QuickSettingsModel.RotationLockState) state;
                            if (state.iconId != 0) {
                                // needed to flush any cached IDs
                                rotationLockTile.setImageDrawable(null);
                                rotationLockTile.setImageResource(state.iconId);
                            }
                            if (state.label != null) {
                                rotationLockTile.setText(state.label);
                            }
                        }
                    });
                    parent.addView(rotationLockTile);
                    if (addMissing)
                        rotationLockTile.setVisibility(View.GONE);
                }
            } else if (Tile.BATTERY.toString().equals(tile.toString())) {
                // battery tile
                // Battery
                mBatteryTile = new QuickSettingsBasicBatteryTile(mContext);
                updateBattery();
                mBatteryTile.setTileId(Tile.BATTERY);
                mBatteryTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
                    }
                });
                mModel.addBatteryTile(mBatteryTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryState batteryState = (QuickSettingsModel.BatteryState) state;
                        String t;
                        if (batteryState.batteryLevel == 100) {
                            t = mContext.getString(R.string.quick_settings_battery_charged_label);
                        } else {
                            if (batteryState.pluggedIn) {
                                t = // circle percent
                                mBatteryStyle != 3 ? mContext.getString(R.string.quick_settings_battery_charging_label, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_charging);
                            } else {
                                // battery bar or battery circle
                                t = (mBatteryStyle == 0 || mBatteryStyle == 2) ? mContext.getString(R.string.status_bar_settings_battery_meter_format, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_discharging);
                            }
                        }
                        mBatteryTile.setText(t);
                        mBatteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery, t));
                    }
                });
                parent.addView(mBatteryTile);
                if (addMissing)
                    mBatteryTile.setVisibility(View.GONE);
            } else if (Tile.IMMERSIVE.toString().equals(tile.toString())) {
                // Immersive tile
                // Immersive mode
                final QuickSettingsBasicTile immersiveTile = new QuickSettingsBasicTile(mContext);
                immersiveTile.setTileId(Tile.IMMERSIVE);
                immersiveTile.setImageResource(R.drawable.ic_qs_immersive_off);
                immersiveTile.setTextResource(R.string.quick_settings_immersive_mode_off_label);
                immersiveTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, checkModeOn ? 0 : 1);
                    }
                });
                mModel.addImmersiveTile(immersiveTile, new QuickSettingsModel.BasicRefreshCallback(immersiveTile));
                parent.addView(immersiveTile);
                if (addMissing)
                    immersiveTile.setVisibility(View.GONE);
            } else if (Tile.AIRPLANE.toString().equals(tile.toString())) {
                // airplane tile
                // Airplane Mode
                final QuickSettingsBasicTile airplaneTile = new QuickSettingsBasicTile(mContext);
                airplaneTile.setTileId(Tile.AIRPLANE);
                mModel.addAirplaneModeTile(airplaneTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        airplaneTile.setImageResource(state.iconId);
                        String airplaneState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane, airplaneState));
                        airplaneTile.setText(state.label);
                    }
                });
                parent.addView(airplaneTile);
                if (addMissing)
                    airplaneTile.setVisibility(View.GONE);
            } else if (Tile.USBMODE.toString().equals(tile.toString())) {
                // usb tile
                // Usb Mode
                final QuickSettingsBasicTile usbModeTile = new QuickSettingsBasicTile(mContext);
                usbModeTile.setTileId(Tile.USBMODE);
                final ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                usbModeTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                        return true;
                    }
                });
                mModel.addUsbModeTile(usbModeTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        usbModeTile.setImageResource(state.iconId);
                        usbModeTile.setText(state.label);
                    }
                });
                parent.addView(usbModeTile);
                if (addMissing)
                    usbModeTile.setVisibility(View.GONE);
            } else if (Tile.TORCH.toString().equals(tile.toString())) {
                // torch tile
                // Torch
                final QuickSettingsBasicTile torchTile = new QuickSettingsBasicTile(mContext);
                torchTile.setTileId(Tile.TORCH);
                torchTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(OmniTorchConstants.INTENT_LAUNCH_APP);
                        return true;
                    }
                });
                mModel.addTorchTile(torchTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        torchTile.setImageResource(state.iconId);
                        torchTile.setText(state.label);
                    }
                });
                parent.addView(torchTile);
                if (addMissing)
                    torchTile.setVisibility(View.GONE);
            } else if (Tile.SYNC.toString().equals(tile.toString())) {
                // sync tile
                // sync
                final QuickSettingsBasicTile SyncTile = new QuickSettingsBasicTile(mContext);
                SyncTile.setTileId(Tile.SYNC);
                SyncTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent("android.settings.SYNC_SETTINGS");
                        intent.addCategory(Intent.CATEGORY_DEFAULT);
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addSyncModeTile(SyncTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        SyncTile.setImageResource(state.iconId);
                        SyncTile.setText(state.label);
                    }
                });
                parent.addView(SyncTile);
                if (addMissing)
                    SyncTile.setVisibility(View.GONE);
            } else if (Tile.QUITEHOUR.toString().equals(tile.toString())) {
                // Quite hours tile
                // Quite hours mode
                final QuickSettingsBasicTile quiteHourTile = new QuickSettingsBasicTile(mContext);
                quiteHourTile.setTileId(Tile.QUITEHOUR);
                quiteHourTile.setImageResource(R.drawable.ic_qs_quiet_hours_off);
                quiteHourTile.setTextResource(R.string.quick_settings_quiethours_off_label);
                quiteHourTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, checkModeOn ? 0 : 1);
                        Intent scheduleSms = new Intent();
                        scheduleSms.setAction("com.android.settings.slim.service.SCHEDULE_SERVICE_COMMAND");
                        mContext.sendBroadcast(scheduleSms);
                    }
                });
                quiteHourTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent(Intent.ACTION_MAIN);
                        intent.setClassName("com.android.settings", "com.android.settings.Settings$QuietHoursSettingsActivity");
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addQuiteHourTile(quiteHourTile, new QuickSettingsModel.BasicRefreshCallback(quiteHourTile));
                parent.addView(quiteHourTile);
                if (addMissing)
                    quiteHourTile.setVisibility(View.GONE);
            } else if (Tile.VOLUME.toString().equals(tile.toString())) {
                // Volume tile
                // Volume mode
                final QuickSettingsFlipTile VolumeTile = new QuickSettingsFlipTile(mContext);
                VolumeTile.setTileId(Tile.VOLUME);
                VolumeTile.setFrontImageResource(R.drawable.ic_qs_volume);
                VolumeTile.setFrontText(mContext.getString(R.string.quick_settings_volume));
                VolumeTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                VolumeTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
                        am.adjustVolume(AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);
                    }
                });
                VolumeTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                mModel.addRingerModeTile(VolumeTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        VolumeTile.setBackImageResource(state.iconId);
                        VolumeTile.setBackFunction(state.label);
                    }
                });
                VolumeTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                parent.addView(VolumeTile);
                if (addMissing)
                    VolumeTile.setVisibility(View.GONE);
            } else if (Tile.SLEEP.toString().equals(tile.toString())) {
                // Sleep tile
                // Sleep
                final QuickSettingsFlipTile SleepTile = new QuickSettingsFlipTile(mContext);
                SleepTile.setTileId(Tile.SLEEP);
                SleepTile.setFrontImageResource(R.drawable.ic_qs_sleep);
                SleepTile.setFrontText(mContext.getString(R.string.quick_settings_screen_sleep));
                SleepTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                SleepTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        pm.goToSleep(SystemClock.uptimeMillis());
                    }
                });
                mModel.addSleepModeTile(SleepTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        SleepTile.setBackImageResource(state.iconId);
                        SleepTile.setBackFunction(state.label);
                    }
                });
                parent.addView(SleepTile);
                if (addMissing)
                    SleepTile.setVisibility(View.GONE);
            } else if (Tile.BLUETOOTH.toString().equals(tile.toString())) {
                // Bluetooth
                if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
                    final QuickSettingsFlipTile bluetoothTile = new QuickSettingsFlipTile(mContext);
                    bluetoothTile.setTileId(Tile.BLUETOOTH);
                    bluetoothTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (mBluetoothAdapter.isEnabled()) {
                                mBluetoothAdapter.disable();
                            } else {
                                mBluetoothAdapter.enable();
                            }
                            bluetoothTile.setFrontPressed(false);
                            bluetoothTile.setFrontLoading(true);
                        }
                    });
                    mModel.addBluetoothTile(bluetoothTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        private boolean mPreviousState = false;

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setFrontImageResource(state.iconId);
                            bluetoothTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setFrontText(state.label);
                            if (mPreviousState != state.enabled) {
                                bluetoothTile.setFrontLoading(false);
                                mPreviousState = state.enabled;
                            }
                        }
                    });
                    bluetoothTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (!mBluetoothAdapter.isEnabled()) {
                                return;
                            }
                            if (mBluetoothAdapter.getScanMode() != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    mModel.addBluetoothBackTile(bluetoothTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setBackImageResource(state.iconId);
                            bluetoothTile.setBackContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setBackLabel(state.label);
                            if (mBluetoothAdapter.getScanMode() == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    parent.addView(bluetoothTile);
                    if (addMissing)
                        bluetoothTile.setVisibility(View.GONE);
                }
            } else if (Tile.LOCATION.toString().equals(tile.toString())) {
                // Location
                // Location
                final QuickSettingsFlipTile locationTile = new QuickSettingsFlipTile(mContext);
                locationTile.setTileId(Tile.LOCATION);
                locationTile.setFrontImageResource(R.drawable.ic_qs_location_on);
                locationTile.setFrontText(mContext.getString(R.string.quick_settings_location_label));
                locationTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                locationTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                        return true;
                    }
                });
                locationTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean newLocationEnabledState = !mLocationController.isLocationEnabled();
                        mLocationController.setLocationEnabled(newLocationEnabledState);
                    }
                });
                mModel.addLocationTile(locationTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        locationTile.setFrontImageResource(state.iconId);
                        String locationState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        locationTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_location, locationState));
                        locationTile.setFrontText(state.label);
                    }
                });
                locationTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        int newLocationMode = mLocationController.locationMode();
                        if (mLocationController.isLocationEnabled()) {
                            if (mLocationController.setBackLocationEnabled(newLocationMode)) {
                                if (mLocationController.isLocationAllowPanelCollapse()) {
                                    Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                                    mContext.sendBroadcast(closeDialog);
                                }
                            }
                        }
                    }
                });
                locationTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                        return true;
                    }
                });
                mModel.addBackLocationTile(locationTile.getBack(), mLocationController, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        locationTile.setBackImageResource(state.iconId);
                        locationTile.setBackFunction(state.label);
                    }
                });
                parent.addView(locationTile);
                if (addMissing)
                    locationTile.setVisibility(View.GONE);
            }
        }
    }
    if (!addMissing)
        addTiles(parent, true, false);
}
#method_after
private void addTiles(ViewGroup parent, boolean addMissing, boolean reset) {
    // If all the tiles were deleted, they are still loaded, but their visibility is changed
    if (reset) {
        parent.removeAllViews();
    }
    String tileContainer = Settings.System.getString(mContext.getContentResolver(), Settings.System.QUICK_SETTINGS_TILES);
    if (tileContainer == null)
        tileContainer = DEFAULT_TILES;
    Tile[] allTiles = Tile.values();
    String[] storedTiles = tileContainer.split(DELIMITER);
    List<String> allTilesArray = enumToStringArray(allTiles);
    List<String> storedTilesArray = Arrays.asList(storedTiles);
    for (String tile : addMissing ? allTilesArray : storedTilesArray) {
        boolean addTile = storedTilesArray.contains(tile);
        if (addMissing)
            addTile = !addTile;
        if (addTile) {
            if (Tile.USER.toString().equals(tile.toString())) {
                // User
                final QuickSettingsBasicUserTile userTile = new QuickSettingsBasicUserTile(mContext);
                userTile.setTileId(Tile.USER);
                userTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        final UserManager um = UserManager.get(mContext);
                        if (um.getUsers(true).size() > 1) {
                            // Since keyguard and systemui were merged into the same process to save
                            // memory, they share the same Looper and graphics context.  As a result,
                            // there's no way to allow concurrent animation while keyguard inflates.
                            // The workaround is to add a slight delay to allow the animation to finish.
                            mHandler.postDelayed(new Runnable() {

                                public void run() {
                                    try {
                                        WindowManagerGlobal.getWindowManagerService().lockNow(null);
                                    } catch (RemoteException e) {
                                        Log.e(TAG, "Couldn't show user switcher", e);
                                    }
                                }
                            }, // TODO: ideally this would be tied to the collapse of the panel
                            400);
                        } else {
                            Intent intent = ContactsContract.QuickContact.composeQuickContactsIntent(mContext, v, ContactsContract.Profile.CONTENT_URI, ContactsContract.QuickContact.MODE_LARGE, null);
                            mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
                        }
                    }
                });
                userTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SYNC_SETTINGS);
                        return true;
                    }
                });
                mModel.addUserTile(userTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        UserState us = (UserState) state;
                        userTile.setText(state.label);
                        userTile.setImageDrawable(us.avatar);
                        view.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_user, state.label));
                    }
                });
                parent.addView(userTile);
                if (addMissing)
                    userTile.setVisibility(View.GONE);
            } else if (Tile.BRIGHTNESS.toString().equals(tile.toString())) {
                // brightness
                // Brightness
                final QuickSettingsBasicTile brightnessTile = new QuickSettingsBasicTile(mContext);
                brightnessTile.setTileId(Tile.BRIGHTNESS);
                brightnessTile.setImageResource(R.drawable.ic_qs_brightness_auto_off);
                brightnessTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        showBrightnessDialog();
                    }
                });
                brightnessTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        boolean automaticAvailable = mContext.getResources().getBoolean(com.android.internal.R.bool.config_automatic_brightness_available);
                        // If we have automatic brightness available, toggle it
                        if (automaticAvailable) {
                            int automatic;
                            try {
                                automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, UserHandle.USER_CURRENT);
                            } catch (SettingNotFoundException snfe) {
                                automatic = 0;
                            }
                            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, automatic != 0 ? 0 : 1, UserHandle.USER_CURRENT);
                        }
                        return true;
                    }
                });
                mModel.addBrightnessTile(brightnessTile, new QuickSettingsModel.BasicRefreshCallback(brightnessTile));
                parent.addView(brightnessTile);
                if (addMissing)
                    brightnessTile.setVisibility(View.GONE);
            } else if (Tile.SETTINGS.toString().equals(tile.toString())) {
                // Settings tile
                // Settings tile
                final QuickSettingsBasicTile settingsTile = new QuickSettingsBasicTile(mContext);
                settingsTile.setTileId(Tile.SETTINGS);
                settingsTile.setImageResource(R.drawable.ic_qs_settings);
                settingsTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SETTINGS);
                    }
                });
                mModel.addSettingsTile(settingsTile, new QuickSettingsModel.BasicRefreshCallback(settingsTile));
                parent.addView(settingsTile);
                if (addMissing)
                    settingsTile.setVisibility(View.GONE);
            } else if (Tile.WIFI.toString().equals(tile.toString())) {
                // wifi tile
                // Wi-fi
                final QuickSettingsFlipTile wifiTile = new QuickSettingsFlipTile(mContext);
                wifiTile.setTileId(Tile.WIFI);
                wifiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
                        return true;
                    }
                });
                wifiTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        final boolean enable = (mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
                        new AsyncTask<Void, Void, Void>() {

                            @Override
                            protected Void doInBackground(Void... args) {
                                // Disable tethering if enabling Wifi
                                final int wifiApState = mWifiManager.getWifiApState();
                                if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
                                    mWifiManager.setWifiApEnabled(null, false);
                                }
                                mWifiManager.setWifiEnabled(enable);
                                return null;
                            }
                        }.execute();
                        wifiTile.setFrontLoading(true);
                        wifiTile.setFrontPressed(false);
                    }
                });
                mModel.addWifiTile(wifiTile.getFront(), new NetworkActivityCallback() {

                    private String mPreviousLabel = "";

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setFrontImageResource(wifiState.iconId);
                        wifiTile.setFrontText(wifiState.label);
                        wifiTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi, wifiState.signalContentDescription, (wifiState.connected) ? wifiState.label : ""));
                        if (wifiState.label != null && !mPreviousLabel.equals(wifiState.label)) {
                            wifiTile.setFrontLoading(false);
                            mPreviousLabel = wifiState.label;
                        }
                    }
                });
                final ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                wifiTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                    }
                });
                mModel.addWifiBackTile(wifiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setBackImageResource(wifiState.iconId);
                        wifiTile.setBackLabel(wifiState.label);
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_label));
                        } else {
                            wifiTile.setBackFunction("");
                        }
                    }
                });
                parent.addView(wifiTile);
                if (addMissing)
                    wifiTile.setVisibility(View.GONE);
            } else if (Tile.RSSI.toString().equals(tile.toString())) {
                // rssi tile
                if (mModel.deviceHasMobileData()) {
                    // RSSI
                    final QuickSettingsNetworkFlipTile rssiTile = new QuickSettingsNetworkFlipTile(mContext);
                    rssiTile.setTileId(Tile.RSSI);
                    final ConnectivityManager cms = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                    rssiTile.setBackLabel(mContext.getString(R.string.quick_settings_network_type));
                    rssiTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean currentState = cms.getMobileDataEnabled();
                            cms.setMobileDataEnabled(!currentState);
                        }
                    });
                    rssiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$DataUsageSummaryActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addRSSITile(rssiTile.getFront(), new NetworkActivityCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            RSSIState rssiState = (RSSIState) state;
                            // Force refresh
                            rssiTile.setFrontImageDrawable(null);
                            rssiTile.setFrontImageResource(rssiState.signalIconId);
                            if (rssiState.dataTypeIconId > 0) {
                                rssiTile.setFrontImageOverlayResource(rssiState.dataTypeIconId);
                            } else {
                                rssiTile.setFrontImageOverlayDrawable(null);
                            }
                            setActivity(view, rssiState);
                            rssiTile.setFrontText(state.label);
                            rssiTile.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile, rssiState.signalContentDescription, rssiState.dataContentDescription, state.label));
                        }
                    });
                    rssiTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent(Intent.ACTION_MAIN);
                            intent.setClassName("com.android.phone", "com.android.phone.Settings");
                            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addMobileNetworkTile(rssiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State mobileNetworkState) {
                            rssiTile.setBackFunction(mobileNetworkState.label);
                            rssiTile.setBackImageResource(mobileNetworkState.iconId);
                        }
                    });
                    parent.addView(rssiTile);
                    if (addMissing)
                        rssiTile.setVisibility(View.GONE);
                }
            } else if (Tile.ROTATION.toString().equals(tile.toString())) {
                // Rotation Lock
                if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
                    final QuickSettingsBasicTile rotationLockTile = new QuickSettingsBasicTile(mContext);
                    rotationLockTile.setTileId(Tile.ROTATION);
                    rotationLockTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View view) {
                            final boolean locked = mRotationLockController.isRotationLocked();
                            mRotationLockController.setRotationLocked(!locked);
                        }
                    });
                    rotationLockTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_DISPLAY_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addRotationLockTile(rotationLockTile, mRotationLockController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            QuickSettingsModel.RotationLockState rotationLockState = (QuickSettingsModel.RotationLockState) state;
                            if (state.iconId != 0) {
                                // needed to flush any cached IDs
                                rotationLockTile.setImageDrawable(null);
                                rotationLockTile.setImageResource(state.iconId);
                            }
                            if (state.label != null) {
                                rotationLockTile.setText(state.label);
                            }
                        }
                    });
                    parent.addView(rotationLockTile);
                    if (addMissing)
                        rotationLockTile.setVisibility(View.GONE);
                }
            } else if (Tile.BATTERY.toString().equals(tile.toString())) {
                // battery tile
                // Battery
                mBatteryTile = new QuickSettingsBasicBatteryTile(mContext);
                updateBattery();
                mBatteryTile.setTileId(Tile.BATTERY);
                mBatteryTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
                    }
                });
                mModel.addBatteryTile(mBatteryTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryState batteryState = (QuickSettingsModel.BatteryState) state;
                        String t;
                        if (batteryState.batteryLevel == 100) {
                            t = mContext.getString(R.string.quick_settings_battery_charged_label);
                        } else {
                            if (batteryState.pluggedIn) {
                                t = // circle percent
                                mBatteryStyle != 3 ? mContext.getString(R.string.quick_settings_battery_charging_label, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_charging);
                            } else {
                                // battery bar or battery circle
                                t = (mBatteryStyle == 0 || mBatteryStyle == 2) ? mContext.getString(R.string.status_bar_settings_battery_meter_format, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_discharging);
                            }
                        }
                        mBatteryTile.setText(t);
                        mBatteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery, t));
                    }
                });
                parent.addView(mBatteryTile);
                if (addMissing)
                    mBatteryTile.setVisibility(View.GONE);
            } else if (Tile.IMMERSIVE.toString().equals(tile.toString())) {
                // Immersive tile
                // Immersive mode
                final QuickSettingsBasicTile immersiveTile = new QuickSettingsBasicTile(mContext);
                immersiveTile.setTileId(Tile.IMMERSIVE);
                immersiveTile.setImageResource(R.drawable.ic_qs_immersive_off);
                immersiveTile.setTextResource(R.string.quick_settings_immersive_mode_off_label);
                immersiveTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, checkModeOn ? 0 : 1);
                    }
                });
                mModel.addImmersiveTile(immersiveTile, new QuickSettingsModel.BasicRefreshCallback(immersiveTile));
                parent.addView(immersiveTile);
                if (addMissing)
                    immersiveTile.setVisibility(View.GONE);
            } else if (Tile.AIRPLANE.toString().equals(tile.toString())) {
                // airplane tile
                // Airplane Mode
                final QuickSettingsBasicTile airplaneTile = new QuickSettingsBasicTile(mContext);
                airplaneTile.setTileId(Tile.AIRPLANE);
                mModel.addAirplaneModeTile(airplaneTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        airplaneTile.setImageResource(state.iconId);
                        String airplaneState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane, airplaneState));
                        airplaneTile.setText(state.label);
                    }
                });
                parent.addView(airplaneTile);
                if (addMissing)
                    airplaneTile.setVisibility(View.GONE);
            } else if (Tile.USBMODE.toString().equals(tile.toString())) {
                // usb tile
                // Usb Mode
                final QuickSettingsBasicTile usbModeTile = new QuickSettingsBasicTile(mContext);
                usbModeTile.setTileId(Tile.USBMODE);
                final ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                usbModeTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                        return true;
                    }
                });
                mModel.addUsbModeTile(usbModeTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        usbModeTile.setImageResource(state.iconId);
                        usbModeTile.setText(state.label);
                    }
                });
                parent.addView(usbModeTile);
                if (addMissing)
                    usbModeTile.setVisibility(View.GONE);
            } else if (Tile.TORCH.toString().equals(tile.toString())) {
                // torch tile
                // Torch
                final QuickSettingsBasicTile torchTile = new QuickSettingsBasicTile(mContext);
                torchTile.setTileId(Tile.TORCH);
                torchTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(OmniTorchConstants.INTENT_LAUNCH_APP);
                        return true;
                    }
                });
                mModel.addTorchTile(torchTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        torchTile.setImageResource(state.iconId);
                        torchTile.setText(state.label);
                    }
                });
                parent.addView(torchTile);
                if (addMissing)
                    torchTile.setVisibility(View.GONE);
            } else if (Tile.SYNC.toString().equals(tile.toString())) {
                // sync tile
                // sync
                final QuickSettingsBasicTile SyncTile = new QuickSettingsBasicTile(mContext);
                SyncTile.setTileId(Tile.SYNC);
                SyncTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent("android.settings.SYNC_SETTINGS");
                        intent.addCategory(Intent.CATEGORY_DEFAULT);
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addSyncModeTile(SyncTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        SyncTile.setImageResource(state.iconId);
                        SyncTile.setText(state.label);
                    }
                });
                parent.addView(SyncTile);
                if (addMissing)
                    SyncTile.setVisibility(View.GONE);
            } else if (Tile.QUITEHOUR.toString().equals(tile.toString())) {
                // Quite hours tile
                // Quite hours mode
                final QuickSettingsBasicTile quiteHourTile = new QuickSettingsBasicTile(mContext);
                quiteHourTile.setTileId(Tile.QUITEHOUR);
                quiteHourTile.setImageResource(R.drawable.ic_qs_quiet_hours_off);
                quiteHourTile.setTextResource(R.string.quick_settings_quiethours_off_label);
                quiteHourTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, checkModeOn ? 0 : 1);
                        Intent scheduleSms = new Intent();
                        scheduleSms.setAction("com.android.settings.slim.service.SCHEDULE_SERVICE_COMMAND");
                        mContext.sendBroadcast(scheduleSms);
                    }
                });
                quiteHourTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent(Intent.ACTION_MAIN);
                        intent.setClassName("com.android.settings", "com.android.settings.Settings$QuietHoursSettingsActivity");
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addQuiteHourTile(quiteHourTile, new QuickSettingsModel.BasicRefreshCallback(quiteHourTile));
                parent.addView(quiteHourTile);
                if (addMissing)
                    quiteHourTile.setVisibility(View.GONE);
            } else if (Tile.VOLUME.toString().equals(tile.toString())) {
                // Volume tile
                // Volume mode
                final QuickSettingsFlipTile VolumeTile = new QuickSettingsFlipTile(mContext);
                VolumeTile.setTileId(Tile.VOLUME);
                VolumeTile.setFrontImageResource(R.drawable.ic_qs_volume);
                VolumeTile.setFrontText(mContext.getString(R.string.quick_settings_volume));
                VolumeTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                VolumeTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
                        am.adjustVolume(AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);
                    }
                });
                VolumeTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                mModel.addRingerModeTile(VolumeTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        VolumeTile.setBackImageResource(state.iconId);
                        VolumeTile.setBackFunction(state.label);
                    }
                });
                VolumeTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                parent.addView(VolumeTile);
                if (addMissing)
                    VolumeTile.setVisibility(View.GONE);
            } else if (Tile.SLEEP.toString().equals(tile.toString())) {
                // Sleep tile
                // Sleep
                final QuickSettingsFlipTile SleepTile = new QuickSettingsFlipTile(mContext);
                SleepTile.setTileId(Tile.SLEEP);
                SleepTile.setFrontImageResource(R.drawable.ic_qs_sleep);
                SleepTile.setFrontText(mContext.getString(R.string.quick_settings_screen_sleep));
                SleepTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                SleepTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        pm.goToSleep(SystemClock.uptimeMillis());
                    }
                });
                mModel.addSleepModeTile(SleepTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        SleepTile.setBackImageResource(state.iconId);
                        SleepTile.setBackFunction(state.label);
                    }
                });
                parent.addView(SleepTile);
                if (addMissing)
                    SleepTile.setVisibility(View.GONE);
            } else if (Tile.BLUETOOTH.toString().equals(tile.toString())) {
                // Bluetooth
                if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
                    final QuickSettingsFlipTile bluetoothTile = new QuickSettingsFlipTile(mContext);
                    bluetoothTile.setTileId(Tile.BLUETOOTH);
                    bluetoothTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (mBluetoothAdapter.isEnabled()) {
                                mBluetoothAdapter.disable();
                            } else {
                                mBluetoothAdapter.enable();
                            }
                            bluetoothTile.setFrontPressed(false);
                            bluetoothTile.setFrontLoading(true);
                        }
                    });
                    mModel.addBluetoothTile(bluetoothTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        private boolean mPreviousState = false;

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setFrontImageResource(state.iconId);
                            bluetoothTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setFrontText(state.label);
                            if (mPreviousState != state.enabled) {
                                bluetoothTile.setFrontLoading(false);
                                mPreviousState = state.enabled;
                            }
                        }
                    });
                    bluetoothTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (!mBluetoothAdapter.isEnabled()) {
                                return;
                            }
                            if (mBluetoothAdapter.getScanMode() != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    mModel.addBluetoothBackTile(bluetoothTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setBackImageResource(state.iconId);
                            bluetoothTile.setBackContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setBackLabel(state.label);
                            if (mBluetoothAdapter.getScanMode() == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    parent.addView(bluetoothTile);
                    if (addMissing)
                        bluetoothTile.setVisibility(View.GONE);
                }
            } else if (Tile.LOCATION.toString().equals(tile.toString())) {
                // Location
                // Location
                final QuickSettingsFlipTile locationTile = new QuickSettingsFlipTile(mContext);
                locationTile.setTileId(Tile.LOCATION);
                locationTile.setFrontImageResource(R.drawable.ic_qs_location_on);
                locationTile.setFrontText(mContext.getString(R.string.quick_settings_location_label));
                locationTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                locationTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                        return true;
                    }
                });
                locationTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean newLocationEnabledState = !mLocationController.isLocationEnabled();
                        if (mLocationController.setLocationEnabled(newLocationEnabledState) && newLocationEnabledState) {
                            // If we've successfully switched from location off to on, close the
                            // notifications tray to show the network location provider consent dialog.
                            Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                            mContext.sendBroadcast(closeDialog);
                        }
                    }
                });
                mModel.addLocationTile(locationTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        locationTile.setFrontImageResource(state.iconId);
                        String locationState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        locationTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_location, locationState));
                        locationTile.setFrontText(state.label);
                    }
                });
                locationTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        int newLocationMode = mLocationController.locationMode();
                        if (mLocationController.isLocationEnabled()) {
                            if (mLocationController.setBackLocationEnabled(newLocationMode)) {
                                if (mLocationController.isLocationAllowPanelCollapse()) {
                                    Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                                    mContext.sendBroadcast(closeDialog);
                                }
                            }
                        }
                    }
                });
                locationTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                        return true;
                    }
                });
                mModel.addBackLocationTile(locationTile.getBack(), mLocationController, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        locationTile.setBackImageResource(state.iconId);
                        locationTile.setBackFunction(state.label);
                    }
                });
                parent.addView(locationTile);
                if (addMissing)
                    locationTile.setVisibility(View.GONE);
            }
        }
    }
    if (!addMissing)
        addTiles(parent, true, false);
}
#end_block

#method_before
private void performKeyAction(int behavior) {
    if (DEBUG_INPUT) {
        Slog.d(TAG, "performKeyAction " + behavior);
    }
    switch(behavior) {
        case KEY_ACTION_NOTHING:
            break;
        case KEY_ACTION_MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case KEY_ACTION_BACK:
            triggerVirtualKeypress(KeyEvent.KEYCODE_BACK);
            break;
        case KEY_ACTION_APP_SWITCH:
            sendCloseSystemWindows(SYSTEM_DIALOG_REASON_RECENT_APPS);
            try {
                IStatusBarService statusbar = getStatusBarService();
                if (statusbar != null) {
                    statusbar.toggleRecentApps();
                    mRecentAppsPreloaded = false;
                }
            } catch (RemoteException e) {
                Slog.e(TAG, "RemoteException when showing recent apps", e);
                // re-acquire status bar service next time it is needed.
                mStatusBarService = null;
            }
            break;
        case KEY_ACTION_SEARCH:
            launchAssistAction();
            break;
        case KEY_ACTION_VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case KEY_ACTION_IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case KEY_ACTION_HOME:
            launchHomeFromHotKey();
            break;
        case KEY_ACTION_KILL_APP:
            mHandler.postDelayed(mKillTask, mBackKillTimeout);
            mBackKillPending = true;
            break;
        case KEY_ACTION_LAST_APP:
            toggleLastApp();
            break;
        case KEY_ACTION_SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        default:
            break;
    }
}
#method_after
private void performKeyAction(int behavior) {
    if (DEBUG_INPUT) {
        Slog.d(TAG, "performKeyAction " + behavior);
    }
    switch(behavior) {
        case KEY_ACTION_NOTHING:
            break;
        case KEY_ACTION_MENU:
            triggerVirtualKeypress(KeyEvent.KEYCODE_MENU);
            break;
        case KEY_ACTION_BACK:
            triggerVirtualKeypress(KeyEvent.KEYCODE_BACK);
            break;
        case KEY_ACTION_APP_SWITCH:
            toggleRecentApps();
            break;
        case KEY_ACTION_SEARCH:
            launchAssistAction();
            break;
        case KEY_ACTION_VOICE_SEARCH:
            launchAssistLongPressAction();
            break;
        case KEY_ACTION_IN_APP_SEARCH:
            triggerVirtualKeypress(KeyEvent.KEYCODE_SEARCH);
            break;
        case KEY_ACTION_HOME:
            launchHomeFromHotKey();
            break;
        case KEY_ACTION_KILL_APP:
            mHandler.postDelayed(mKillTask, mBackKillTimeout);
            mBackKillPending = true;
            break;
        case KEY_ACTION_LAST_APP:
            toggleLastApp();
            break;
        case KEY_ACTION_SLEEP:
            mPowerManager.goToSleep(SystemClock.uptimeMillis());
            break;
        default:
            break;
    }
}
#end_block

#method_before
private void updateKeyAssignments() {
    final boolean hasMenu = (mDeviceHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasBack = (mDeviceHardwareKeys & KEY_MASK_BACK) != 0;
    final boolean hasHome = (mDeviceHardwareKeys & KEY_MASK_HOME) != 0;
    final boolean hasAssist = (mDeviceHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitch = (mDeviceHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final ContentResolver resolver = mContext.getContentResolver();
    mSoftBackKillApp = Settings.System.getIntForUser(resolver, Settings.System.SOFT_BACK_KILL_APP_ENABLE, 0, UserHandle.USER_CURRENT) == 1;
    // initialize all assignments to sane defaults
    mPressOnHomeBehavior = KEY_ACTION_HOME;
    mPressOnMenuBehavior = KEY_ACTION_MENU;
    if (!hasMenu || hasAssist) {
        mLongPressOnMenuBehavior = KEY_ACTION_NOTHING;
    } else {
        mLongPressOnMenuBehavior = KEY_ACTION_SEARCH;
    }
    mPressOnAssistBehavior = KEY_ACTION_SEARCH;
    mLongPressOnAssistBehavior = KEY_ACTION_VOICE_SEARCH;
    mPressOnAppSwitchBehavior = KEY_ACTION_APP_SWITCH;
    mLongPressOnAppSwitchBehavior = KEY_ACTION_NOTHING;
    mPressOnBackBehavior = KEY_ACTION_BACK;
    // sof key back kill app will overrule this default
    if (mSoftBackKillApp) {
        mLongPressOnBackBehavior = KEY_ACTION_KILL_APP;
    } else {
        mLongPressOnBackBehavior = KEY_ACTION_NOTHING;
    }
    mLongPressOnHomeBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnHomeBehavior);
    if (mLongPressOnHomeBehavior == 1) {
        mLongPressOnHomeBehavior = KEY_ACTION_APP_SWITCH;
    } else if (mLongPressOnHomeBehavior == 2) {
        mLongPressOnHomeBehavior = KEY_ACTION_SEARCH;
    } else {
        mLongPressOnHomeBehavior = KEY_ACTION_NOTHING;
    }
    mDoubleTapOnHomeBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doubleTapOnHomeBehavior);
    if (mDoubleTapOnHomeBehavior == 1) {
        mDoubleTapOnHomeBehavior = KEY_ACTION_APP_SWITCH;
    } else {
        mDoubleTapOnHomeBehavior = KEY_ACTION_NOTHING;
    }
    boolean keyRebindingEnabled = Settings.System.getIntForUser(resolver, Settings.System.HARDWARE_KEY_REBINDING, 0, UserHandle.USER_CURRENT) == 1;
    if (keyRebindingEnabled) {
        if (hasHome) {
            mPressOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_ACTION, KEY_ACTION_HOME, UserHandle.USER_CURRENT);
            mLongPressOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_LONG_PRESS_ACTION, hasAppSwitch ? KEY_ACTION_NOTHING : mLongPressOnHomeBehavior, UserHandle.USER_CURRENT);
            mDoubleTapOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, mDoubleTapOnHomeBehavior, UserHandle.USER_CURRENT);
        }
        if (hasMenu) {
            mPressOnMenuBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_ACTION, KEY_ACTION_MENU, UserHandle.USER_CURRENT);
            mLongPressOnMenuBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_LONG_PRESS_ACTION, hasAssist ? KEY_ACTION_NOTHING : KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
        }
        if (hasBack) {
            mPressOnBackBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_ACTION, KEY_ACTION_BACK, UserHandle.USER_CURRENT);
            mLongPressOnBackBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_LONG_PRESS_ACTION, KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
        }
        if (hasAssist) {
            mPressOnAssistBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_ACTION, KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
            mLongPressOnAssistBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_LONG_PRESS_ACTION, KEY_ACTION_VOICE_SEARCH, UserHandle.USER_CURRENT);
        }
        if (hasAppSwitch) {
            mPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_ACTION, KEY_ACTION_APP_SWITCH, UserHandle.USER_CURRENT);
            mLongPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
        }
    }
    if (DEBUG_INPUT) {
        Slog.d(TAG, "home = " + mPressOnHomeBehavior + " home long = " + mLongPressOnHomeBehavior + " home double = " + mDoubleTapOnHomeBehavior);
        Slog.d(TAG, "menu = " + mPressOnMenuBehavior + " menu long = " + mLongPressOnMenuBehavior);
        Slog.d(TAG, "back = " + mPressOnBackBehavior + " back long = " + mLongPressOnBackBehavior);
        Slog.d(TAG, "assist = " + mPressOnAssistBehavior + " assist long = " + mLongPressOnAssistBehavior);
        Slog.d(TAG, "appSwitch = " + mPressOnAppSwitchBehavior + " back long = " + mLongPressOnAppSwitchBehavior);
    }
}
#method_after
private void updateKeyAssignments() {
    final boolean hasMenu = (mDeviceHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasBack = (mDeviceHardwareKeys & KEY_MASK_BACK) != 0;
    final boolean hasHome = (mDeviceHardwareKeys & KEY_MASK_HOME) != 0;
    final boolean hasAssist = (mDeviceHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitch = (mDeviceHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final ContentResolver resolver = mContext.getContentResolver();
    mSoftBackKillApp = Settings.System.getIntForUser(resolver, Settings.System.SOFT_BACK_KILL_APP_ENABLE, 0, UserHandle.USER_CURRENT) == 1;
    // initialize all assignments to sane defaults
    mPressOnHomeBehavior = KEY_ACTION_HOME;
    mPressOnMenuBehavior = KEY_ACTION_MENU;
    if (!hasMenu || hasAssist) {
        mLongPressOnMenuBehavior = KEY_ACTION_NOTHING;
    } else {
        mLongPressOnMenuBehavior = KEY_ACTION_SEARCH;
    }
    mPressOnAssistBehavior = KEY_ACTION_SEARCH;
    mLongPressOnAssistBehavior = KEY_ACTION_VOICE_SEARCH;
    mPressOnAppSwitchBehavior = KEY_ACTION_APP_SWITCH;
    mLongPressOnAppSwitchBehavior = KEY_ACTION_NOTHING;
    mPressOnBackBehavior = KEY_ACTION_BACK;
    mLongPressOnBackBehavior = KEY_ACTION_NOTHING;
    mLongPressOnHomeBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnHomeBehavior);
    if (mLongPressOnHomeBehavior == 1) {
        mLongPressOnHomeBehavior = KEY_ACTION_APP_SWITCH;
    } else if (mLongPressOnHomeBehavior == 2) {
        mLongPressOnHomeBehavior = KEY_ACTION_SEARCH;
    } else {
        mLongPressOnHomeBehavior = KEY_ACTION_NOTHING;
    }
    mDoubleTapOnHomeBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doubleTapOnHomeBehavior);
    if (mDoubleTapOnHomeBehavior == 1) {
        mDoubleTapOnHomeBehavior = KEY_ACTION_APP_SWITCH;
    } else {
        mDoubleTapOnHomeBehavior = KEY_ACTION_NOTHING;
    }
    boolean keyRebindingEnabled = Settings.System.getIntForUser(resolver, Settings.System.HARDWARE_KEY_REBINDING, 0, UserHandle.USER_CURRENT) == 1;
    if (keyRebindingEnabled) {
        if (hasHome) {
            mPressOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_ACTION, KEY_ACTION_HOME, UserHandle.USER_CURRENT);
            mLongPressOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_LONG_PRESS_ACTION, hasAppSwitch ? KEY_ACTION_NOTHING : mLongPressOnHomeBehavior, UserHandle.USER_CURRENT);
            mDoubleTapOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, mDoubleTapOnHomeBehavior, UserHandle.USER_CURRENT);
        }
        if (hasMenu) {
            mPressOnMenuBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_ACTION, KEY_ACTION_MENU, UserHandle.USER_CURRENT);
            mLongPressOnMenuBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_LONG_PRESS_ACTION, hasAssist ? KEY_ACTION_NOTHING : KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
        }
        if (hasBack) {
            mPressOnBackBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_ACTION, KEY_ACTION_BACK, UserHandle.USER_CURRENT);
            mLongPressOnBackBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_LONG_PRESS_ACTION, KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
        }
        if (hasAssist) {
            mPressOnAssistBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_ACTION, KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
            mLongPressOnAssistBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_LONG_PRESS_ACTION, KEY_ACTION_VOICE_SEARCH, UserHandle.USER_CURRENT);
        }
        if (hasAppSwitch) {
            mPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_ACTION, KEY_ACTION_APP_SWITCH, UserHandle.USER_CURRENT);
            mLongPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
        }
    }
    if (DEBUG_INPUT) {
        Slog.d(TAG, "home = " + mPressOnHomeBehavior + " home long = " + mLongPressOnHomeBehavior + " home double = " + mDoubleTapOnHomeBehavior);
        Slog.d(TAG, "menu = " + mPressOnMenuBehavior + " menu long = " + mLongPressOnMenuBehavior);
        Slog.d(TAG, "back = " + mPressOnBackBehavior + " back long = " + mLongPressOnBackBehavior);
        Slog.d(TAG, "assist = " + mPressOnAssistBehavior + " assist long = " + mLongPressOnAssistBehavior);
        Slog.d(TAG, "appSwitch = " + mPressOnAppSwitchBehavior + " back long = " + mLongPressOnAppSwitchBehavior);
    }
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENRECORD_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mVolumeUpKeyConsumedByScreenrecordChord) {
            if (!down) {
                mVolumeUpKeyConsumedByScreenrecordChord = false;
            }
            return -1;
        }
    }
    // stop the kill action
    if (mBackKillPending && !down) {
        mHandler.removeCallbacks(mKillTask);
        mBackKillPending = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            if (mRecentAppsPreloaded) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // and his ONLY options are to answer or reject the call.)
            try {
                ITelephony telephonyService = getTelephonyService();
                if (telephonyService != null && telephonyService.isRinging()) {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            } catch (RemoteException ex) {
                Log.w(TAG, "RemoteException from getPhoneInterface()", ex);
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (mPressOnHomeBehavior != KEY_ACTION_HOME) {
                performKeyAction(mPressOnHomeBehavior);
            } else {
                launchHomeFromHotKey();
            }
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD || type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            if (down) {
                mHomePressed = true;
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeConsumed = true;
                performKeyAction(mDoubleTapOnHomeBehavior);
            } else if (!mRecentAppsPreloaded && (mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehavior == KEY_ACTION_APP_SWITCH || mPressOnHomeBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
                preloadRecentApps();
            }
            if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                mHomeConsumed = true;
                performKeyAction(mLongPressOnHomeBehavior);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcast(intent, null);
                    return -1;
                } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                    Intent service = new Intent();
                    service.setClassName(mContext, "com.android.server.LoadAverageService");
                    ContentResolver res = mContext.getContentResolver();
                    boolean shown = Settings.System.getInt(res, Settings.System.SHOW_PROCESSES, 0) != 0;
                    if (!shown) {
                        mContext.startService(service);
                    } else {
                        mContext.stopService(service);
                    }
                    Settings.System.putInt(res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
                    return -1;
                } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !virtualKey) {
                    mMenuDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnMenuBehavior);
                    // Do not perform action when key is released
                    mMenuDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mMenuDoCustomAction) {
                mMenuDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnMenuBehavior);
                    return -1;
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAppSwitchBehavior);
                    mAppSwitchLongPressed = true;
                }
            }
        } else {
            if (mAppSwitchLongPressed) {
                mAppSwitchLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAssistBehavior);
                    mAssistKeyLongPressed = true;
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAssistBehavior);
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            Intent intent = new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG);
            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnBackBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    mBackDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnBackBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnBackBehavior);
                    // Do not perform action when key is released
                    mBackDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnBackBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnBackBehavior);
                    return -1;
                }
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB or Meta-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsDialogHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON) || KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_META_ON)) {
                mRecentAppsDialogHeldModifiers = shiftlessModifiers;
                showOrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW);
                return -1;
            }
        }
    } else if (!down && mRecentAppsDialogHeldModifiers != 0 && (metaState & mRecentAppsDialogHeldModifiers) == 0) {
        mRecentAppsDialogHeldModifiers = 0;
        showOrHideRecentAppsDialog(keyguardOn ? RECENT_APPS_BEHAVIOR_DISMISS : RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENRECORD_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mVolumeUpKeyConsumedByScreenrecordChord) {
            if (!down) {
                mVolumeUpKeyConsumedByScreenrecordChord = false;
            }
            return -1;
        }
    }
    // stop the kill action
    if (mBackKillPending && !down) {
        mHandler.removeCallbacks(mKillTask);
        mBackKillPending = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            if (mRecentAppsPreloaded) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // and his ONLY options are to answer or reject the call.)
            try {
                ITelephony telephonyService = getTelephonyService();
                if (telephonyService != null && telephonyService.isRinging()) {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            } catch (RemoteException ex) {
                Log.w(TAG, "RemoteException from getPhoneInterface()", ex);
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            // dont change handling of virtual home button events
            if (mPressOnHomeBehavior != KEY_ACTION_HOME && !virtualKey) {
                performKeyAction(mPressOnHomeBehavior);
            } else {
                launchHomeFromHotKey();
            }
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD || type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            if (down) {
                mHomePressed = true;
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeConsumed = true;
                performKeyAction(mDoubleTapOnHomeBehavior);
            } else if (!mRecentAppsPreloaded && (mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehavior == KEY_ACTION_APP_SWITCH || mPressOnHomeBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
                preloadRecentApps();
            }
            if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                mHomeConsumed = true;
                performKeyAction(mLongPressOnHomeBehavior);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcast(intent, null);
                    return -1;
                } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                    Intent service = new Intent();
                    service.setClassName(mContext, "com.android.server.LoadAverageService");
                    ContentResolver res = mContext.getContentResolver();
                    boolean shown = Settings.System.getInt(res, Settings.System.SHOW_PROCESSES, 0) != 0;
                    if (!shown) {
                        mContext.startService(service);
                    } else {
                        mContext.stopService(service);
                    }
                    Settings.System.putInt(res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
                    return -1;
                } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !virtualKey) {
                    mMenuDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnMenuBehavior);
                    // Do not perform action when key is released
                    mMenuDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mMenuDoCustomAction) {
                mMenuDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnMenuBehavior);
                    return -1;
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAppSwitchBehavior);
                    mAppSwitchLongPressed = true;
                }
            }
        } else {
            if (mAppSwitchLongPressed) {
                mAppSwitchLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAssistBehavior);
                    mAssistKeyLongPressed = true;
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAssistBehavior);
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            Intent intent = new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG);
            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnBackBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    mBackDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn) {
                    if (mLongPressOnBackBehavior != KEY_ACTION_NOTHING) {
                        performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                        performKeyAction(mLongPressOnBackBehavior);
                        // Do not perform action when key is released
                        mBackDoCustomAction = false;
                        return -1;
                    } else if (mSoftBackKillApp) {
                        // OR device with only soft keys and soft key back kill enabled
                        if (!virtualKey) {
                            // ignore hard key press
                            mBackDoCustomAction = false;
                            return -1;
                        } else {
                            // handle soft key press
                            performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                            performKeyAction(KEY_ACTION_KILL_APP);
                            // Do not perform action when key is released
                            mBackDoCustomAction = false;
                            return -1;
                        }
                    }
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnBackBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnBackBehavior);
                    return -1;
                }
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB or Meta-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsDialogHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON) || KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_META_ON)) {
                mRecentAppsDialogHeldModifiers = shiftlessModifiers;
                showOrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW);
                return -1;
            }
        }
    } else if (!down && mRecentAppsDialogHeldModifiers != 0 && (metaState & mRecentAppsDialogHeldModifiers) == 0) {
        mRecentAppsDialogHeldModifiers = 0;
        showOrHideRecentAppsDialog(keyguardOn ? RECENT_APPS_BEHAVIOR_DISMISS : RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
private void toggleRecentApps() {
    // preloading no longer needs to be canceled
    mPreloadedRecentApps = false;
    sendCloseSystemWindows(SYSTEM_DIALOG_REASON_RECENT_APPS);
    try {
        IStatusBarService statusbar = getStatusBarService();
        if (statusbar != null) {
            statusbar.toggleRecentApps();
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "RemoteException when showing recent apps", e);
        // re-acquire status bar service next time it is needed.
        mStatusBarService = null;
    }
}
#method_after
private void toggleRecentApps() {
    // preloading no longer needs to be canceled
    mRecentAppsPreloaded = false;
    sendCloseSystemWindows(SYSTEM_DIALOG_REASON_RECENT_APPS);
    try {
        IStatusBarService statusbar = getStatusBarService();
        if (statusbar != null) {
            statusbar.toggleRecentApps();
        }
    } catch (RemoteException e) {
        Slog.e(TAG, "RemoteException when showing recent apps", e);
        // re-acquire status bar service next time it is needed.
        mStatusBarService = null;
    }
}
#end_block

#method_before
@Override
public int rotationForOrientationLw(int orientation, int lastRotation) {
    if (false) {
        Slog.v(TAG, "rotationForOrientationLw(orient=" + orientation + ", last=" + lastRotation + "); user=" + mUserRotation + " " + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED) ? "USER_ROTATION_LOCKED" : ""));
    }
    if (mForceDefaultOrientation) {
        return Surface.ROTATION_0;
    }
    synchronized (mLock) {
        // may be -1
        int sensorRotation = mOrientationListener.getProposedRotation();
        if (sensorRotation < 0) {
            sensorRotation = lastRotation;
        }
        final int preferredRotation;
        if ((mLidState == LID_OPEN && mLidOpenRotation >= 0) && !(mHasRemovableLid && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED)) {
            // Ignore sensor when lid switch is open and rotation is forced
            // and a removable lid was not undocked.
            preferredRotation = mLidOpenRotation;
        } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
            // Ignore sensor when in car dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mCarDockEnablesAccelerometer ? sensorRotation : mCarDockRotation;
        } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK) && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
            // Ignore sensor when in desk dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mDeskDockEnablesAccelerometer ? sensorRotation : mDeskDockRotation;
        } else if (mHdmiPlugged && mDemoHdmiRotationLock) {
            // Ignore sensor when plugged into HDMI when demo HDMI rotation lock enabled.
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mDemoHdmiRotation;
        } else if (mHdmiPlugged && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED && mUndockedHdmiRotation >= 0) {
            // Ignore sensor when plugged into HDMI and an undocked orientation has
            // been specified in the configuration (only for legacy devices without
            // full multi-display support).
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mUndockedHdmiRotation;
        } else if (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {
            // Application just wants to remain locked in the last rotation.
            preferredRotation = lastRotation;
        } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER)) || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
            // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
            if (mAllowAllRotations < 0) {
                // Can't read this during init() because the context doesn't
                // have display metrics at that time so we cannot determine
                // tablet vs. phone then.
                mAllowAllRotations = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
            }
            // Rotation setting bitmask
            // 1=0 2=90 4=180 8=270
            boolean allowed = true;
            if (mUserRotationAngles < 0) {
                // Not set by user so use these defaults
                mUserRotationAngles = mAllowAllRotations == 1 ? // All angles
                (1 | 2 | 4 | 8) : // All except 180
                (1 | 2 | 8);
                Settings.System.putInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.ACCELEROMETER_ROTATION_ANGLES, mUserRotationAngles);
            }
            switch(sensorRotation) {
                case Surface.ROTATION_0:
                    allowed = (mUserRotationAngles & 1) != 0;
                    break;
                case Surface.ROTATION_90:
                    allowed = (mUserRotationAngles & 2) != 0;
                    break;
                case Surface.ROTATION_180:
                    allowed = (mUserRotationAngles & 4) != 0;
                    break;
                case Surface.ROTATION_270:
                    allowed = (mUserRotationAngles & 8) != 0;
                    break;
            }
            if (allowed) {
                preferredRotation = sensorRotation;
            } else {
                preferredRotation = lastRotation;
            }
        } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
            // Apply rotation lock.  Does not apply to NOSENSOR.
            // The idea is that the user rotation expresses a weak preference for the direction
            // of gravity and as NOSENSOR is never affected by gravity, then neither should
            // NOSENSOR be affected by rotation lock (although it will be affected by docks).
            preferredRotation = mUserRotation;
        } else {
            // No overriding preference.
            // We will do exactly what the application asked us to do.
            preferredRotation = -1;
        }
        switch(orientation) {
            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                // Return portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mPortraitRotation;
            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
                // Return landscape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
                // Return reverse portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mUpsideDownRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
                // Return seascape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mSeascapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
            case ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE:
                // Return either landscape rotation.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                if (isLandscapeOrSeascape(lastRotation)) {
                    return lastRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
            case ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT:
                // Return either portrait rotation.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                if (isAnyPortrait(lastRotation)) {
                    return lastRotation;
                }
                return mPortraitRotation;
            default:
                // just return the preferred orientation we already calculated.
                if (preferredRotation >= 0) {
                    return preferredRotation;
                }
                return Surface.ROTATION_0;
        }
    }
}
#method_after
@Override
public int rotationForOrientationLw(int orientation, int lastRotation) {
    if (false) {
        Slog.v(TAG, "rotationForOrientationLw(orient=" + orientation + ", last=" + lastRotation + "); user=" + mUserRotation + " " + ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED) ? "USER_ROTATION_LOCKED" : ""));
    }
    if (mForceDefaultOrientation) {
        return Surface.ROTATION_0;
    }
    synchronized (mLock) {
        // may be -1
        int sensorRotation = mOrientationListener.getProposedRotation();
        if (sensorRotation < 0) {
            sensorRotation = lastRotation;
        }
        final int preferredRotation;
        if ((mLidState == LID_OPEN && mLidOpenRotation >= 0) && !(mHasRemovableLid && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED)) {
            // Ignore sensor when lid switch is open and rotation is forced
            // and a removable lid was not undocked.
            preferredRotation = mLidOpenRotation;
        } else if (mDockMode == Intent.EXTRA_DOCK_STATE_CAR && (mCarDockEnablesAccelerometer || mCarDockRotation >= 0)) {
            // Ignore sensor when in car dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mCarDockEnablesAccelerometer ? sensorRotation : mCarDockRotation;
        } else if ((mDockMode == Intent.EXTRA_DOCK_STATE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_LE_DESK || mDockMode == Intent.EXTRA_DOCK_STATE_HE_DESK) && (mDeskDockEnablesAccelerometer || mDeskDockRotation >= 0)) {
            // Ignore sensor when in desk dock unless explicitly enabled.
            // This case can override the behavior of NOSENSOR, and can also
            // enable 180 degree rotation while docked.
            preferredRotation = mDeskDockEnablesAccelerometer ? sensorRotation : mDeskDockRotation;
        } else if (mHdmiPlugged && mDemoHdmiRotationLock) {
            // Ignore sensor when plugged into HDMI when demo HDMI rotation lock enabled.
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mDemoHdmiRotation;
        } else if (mHdmiPlugged && mDockMode == Intent.EXTRA_DOCK_STATE_UNDOCKED && mUndockedHdmiRotation >= 0) {
            // Ignore sensor when plugged into HDMI and an undocked orientation has
            // been specified in the configuration (only for legacy devices without
            // full multi-display support).
            // Note that the dock orientation overrides the HDMI orientation.
            preferredRotation = mUndockedHdmiRotation;
        } else if (orientation == ActivityInfo.SCREEN_ORIENTATION_LOCKED) {
            // Application just wants to remain locked in the last rotation.
            preferredRotation = lastRotation;
        } else if ((mUserRotationMode == WindowManagerPolicy.USER_ROTATION_FREE && (orientation == ActivityInfo.SCREEN_ORIENTATION_USER || orientation == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_USER)) || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_FULL_SENSOR || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE || orientation == ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT) {
            // by default for USER or UNSPECIFIED modes.  Does not apply to NOSENSOR.
            if (mAllowAllRotations < 0) {
                // Can't read this during init() because the context doesn't
                // have display metrics at that time so we cannot determine
                // tablet vs. phone then.
                mAllowAllRotations = mContext.getResources().getBoolean(com.android.internal.R.bool.config_allowAllRotations) ? 1 : 0;
            }
            // 1=0 2=90 4=180 8=270
            if (mUserRotationAngles < 0) {
                // defaults
                mUserRotationAngles = mAllowAllRotations == 1 ? // All angles
                (ROTATION_0_MODE | ROTATION_90_MODE | ROTATION_180_MODE | ROTATION_270_MODE) : // All except 180
                (ROTATION_0_MODE | ROTATION_90_MODE | ROTATION_270_MODE);
            }
            boolean allowed = true;
            switch(sensorRotation) {
                case Surface.ROTATION_0:
                    allowed = (mUserRotationAngles & ROTATION_0_MODE) != 0;
                    break;
                case Surface.ROTATION_90:
                    allowed = (mUserRotationAngles & ROTATION_90_MODE) != 0;
                    break;
                case Surface.ROTATION_180:
                    allowed = (mUserRotationAngles & ROTATION_180_MODE) != 0;
                    break;
                case Surface.ROTATION_270:
                    allowed = (mUserRotationAngles & ROTATION_270_MODE) != 0;
                    break;
            }
            if (allowed) {
                preferredRotation = sensorRotation;
            } else {
                preferredRotation = lastRotation;
            }
        } else if (mUserRotationMode == WindowManagerPolicy.USER_ROTATION_LOCKED && orientation != ActivityInfo.SCREEN_ORIENTATION_NOSENSOR) {
            // Apply rotation lock.  Does not apply to NOSENSOR.
            // The idea is that the user rotation expresses a weak preference for the direction
            // of gravity and as NOSENSOR is never affected by gravity, then neither should
            // NOSENSOR be affected by rotation lock (although it will be affected by docks).
            preferredRotation = mUserRotation;
        } else {
            // No overriding preference.
            // We will do exactly what the application asked us to do.
            preferredRotation = -1;
        }
        switch(orientation) {
            case ActivityInfo.SCREEN_ORIENTATION_PORTRAIT:
                // Return portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mPortraitRotation;
            case ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE:
                // Return landscape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_PORTRAIT:
                // Return reverse portrait unless overridden.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                return mUpsideDownRotation;
            case ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE:
                // Return seascape unless overridden.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                return mSeascapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE:
            case ActivityInfo.SCREEN_ORIENTATION_USER_LANDSCAPE:
                // Return either landscape rotation.
                if (isLandscapeOrSeascape(preferredRotation)) {
                    return preferredRotation;
                }
                if (isLandscapeOrSeascape(lastRotation)) {
                    return lastRotation;
                }
                return mLandscapeRotation;
            case ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT:
            case ActivityInfo.SCREEN_ORIENTATION_USER_PORTRAIT:
                // Return either portrait rotation.
                if (isAnyPortrait(preferredRotation)) {
                    return preferredRotation;
                }
                if (isAnyPortrait(lastRotation)) {
                    return lastRotation;
                }
                return mPortraitRotation;
            default:
                // just return the preferred orientation we already calculated.
                if (preferredRotation >= 0) {
                    return preferredRotation;
                }
                return Surface.ROTATION_0;
        }
    }
}
#end_block

#method_before
public boolean hasPermanentMenuKey() {
    boolean emulateMenuKey = Settings.System.getInt(mContext.getContentResolver(), Settings.System.EMULATE_MENU_KEY, 0) == 1;
    if (!sHasPermanentMenuKey && emulateMenuKey) {
        return true;
    }
    return sHasPermanentMenuKey;
}
#method_after
public boolean hasPermanentMenuKey() {
    // normally only one of those settings will be 1
    // except for the use-case to force show soft keys on devices
    // that have hardware buttons
    boolean forceShowMenu = Settings.System.getInt(mContext.getContentResolver(), Settings.System.FORCE_SHOW_OVERFLOW_MENU, sHasHwMenuKey ? 0 : 1) == 1;
    boolean emulateHwMenuKey = Settings.System.getInt(mContext.getContentResolver(), Settings.System.EMULATE_HW_MENU_KEY, 0) == 1;
    if (forceShowMenu && sHasPermanentMenuKey) {
        return false;
    }
    if (emulateHwMenuKey) {
        return true;
    }
    return sHasPermanentMenuKey;
}
#end_block

#method_before
private void loadTouchSoundAssetDefaults() {
    SOUND_EFFECT_FILES.add("Effect_Tick.ogg");
    for (int i = 0; i < AudioManager.NUM_SOUND_EFFECTS; i++) {
        SOUND_EFFECT_FILES_MAP[i][0] = 0;
        SOUND_EFFECT_FILES_MAP[i][1] = -1;
    }
}
#method_after
private void loadTouchSoundAssetDefaults() {
    SOUND_EFFECT_FILES.add("Effect_Tick.ogg");
    for (int i = 0; i < AudioManager.NUM_SOUND_EFFECTS; i++) {
        SOUND_EFFECT_FILES_MAP[i][0] = 0;
        SOUND_EFFECT_FILES_MAP[i][1] = -1;
    }
    // Setup default symlinks for MediaActionSound sounds.
    // See MediaActionSound.java for more details
    File symlinkDir = new File(CUSTOM_AUDIO_SYMLINK_PATH);
    symlinkDir.mkdirs();
    symlinkDir.setReadable(true, false);
    symlinkDir.setExecutable(true, false);
    symlink("/system/media/audio/ui/camera_click.ogg", CUSTOM_AUDIO_SYMLINK_PATH + "camera_click.ogg");
    symlink("/system/media/audio/ui/camera_focus.ogg", CUSTOM_AUDIO_SYMLINK_PATH + "camera_focus.ogg");
    symlink("/system/media/audio/ui/VideoRecord.ogg", CUSTOM_AUDIO_SYMLINK_PATH + "VideoRecord_start.ogg");
    symlink("/system/media/audio/ui/VideoRecord.ogg", CUSTOM_AUDIO_SYMLINK_PATH + "VideoRecord_stop.ogg");
    // Reset lock/unlock sounds
    Settings.Global.putString(mContentResolver, Settings.Global.LOCK_SOUND, "/system/media/audio/ui/Lock.ogg");
    Settings.Global.putString(mContentResolver, Settings.Global.UNLOCK_SOUND, "/system/media/audio/ui/Unlock.ogg");
}
#end_block

#method_before
private void loadTouchSoundAssets() {
    XmlResourceParser parser = null;
    // only load assets once.
    if (!SOUND_EFFECT_FILES.isEmpty()) {
        return;
    }
    loadTouchSoundAssetDefaults();
    try {
        parser = mContext.getResources().getXml(com.android.internal.R.xml.audio_assets);
        XmlUtils.beginDocument(parser, TAG_AUDIO_ASSETS);
        String version = parser.getAttributeValue(null, ATTR_VERSION);
        boolean inTouchSoundsGroup = false;
        if (ASSET_FILE_VERSION.equals(version)) {
            while (true) {
                XmlUtils.nextElement(parser);
                String element = parser.getName();
                if (element == null) {
                    break;
                }
                if (element.equals(TAG_GROUP)) {
                    String name = parser.getAttributeValue(null, ATTR_GROUP_NAME);
                    if (GROUP_TOUCH_SOUNDS.equals(name)) {
                        inTouchSoundsGroup = true;
                        break;
                    }
                }
            }
            while (inTouchSoundsGroup) {
                XmlUtils.nextElement(parser);
                String element = parser.getName();
                if (element == null) {
                    break;
                }
                if (element.equals(TAG_ASSET)) {
                    String id = parser.getAttributeValue(null, ATTR_ASSET_ID);
                    String file = parser.getAttributeValue(null, ATTR_ASSET_FILE);
                    int fx;
                    try {
                        Field field = AudioManager.class.getField(id);
                        fx = field.getInt(null);
                    } catch (Exception e) {
                        Log.w(TAG, "Invalid touch sound ID: " + id);
                        continue;
                    }
                    int i = SOUND_EFFECT_FILES.indexOf(file);
                    if (i == -1) {
                        i = SOUND_EFFECT_FILES.size();
                        SOUND_EFFECT_FILES.add(file);
                    }
                    SOUND_EFFECT_FILES_MAP[fx][0] = i;
                } else {
                    break;
                }
            }
        }
    } catch (Resources.NotFoundException e) {
        Log.w(TAG, "audio assets file not found", e);
    } catch (XmlPullParserException e) {
        Log.w(TAG, "XML parser exception reading touch sound assets", e);
    } catch (IOException e) {
        Log.w(TAG, "I/O exception reading touch sound assets", e);
    } finally {
        if (parser != null) {
            parser.close();
        }
    }
}
#method_after
private void loadTouchSoundAssets() {
    XmlPullParser parser = null;
    // only load assets once.
    if (!SOUND_EFFECT_FILES.isEmpty()) {
        return;
    }
    // check if user has custom sounds
    String customSoundsPath = Settings.System.getStringForUser(mContentResolver, Settings.System.CUSTOM_SOUND_EFFECTS_PATH, UserHandle.USER_CURRENT);
    if (customSoundsPath != null) {
        try {
            mActiveSoundEffectsPath = customSoundsPath;
            mActiveAudioAssetsXml = XmlPullParserFactory.newInstance().newPullParser();
            mActiveAudioAssetsXml.setInput(new InputStreamReader(new FileInputStream(customSoundsPath + "/" + CUSTOM_AUDIO_ASSETS_FILE)));
        } catch (IOException e) {
            Log.e(TAG, "Unable to find audio assets XML", e);
        } catch (XmlPullParserException e) {
            Log.e(TAG, "Unable to parse audio assets XML", e);
        }
    } else {
        mActiveSoundEffectsPath = DEFAULT_SOUND_EFFECTS_PATH;
        mActiveAudioAssetsXml = mContext.getResources().getXml(com.android.internal.R.xml.audio_assets);
    }
    loadTouchSoundAssetDefaults();
    try {
        parser = mActiveAudioAssetsXml;
        XmlUtils.beginDocument(parser, TAG_AUDIO_ASSETS);
        String version = parser.getAttributeValue(null, ATTR_VERSION);
        boolean inTouchSoundsGroup = false, inLockSoundsGroup = false, inCameraSoundsGroup = false;
        if (ASSET_FILE_VERSION.equals(version)) {
            while (true) {
                XmlUtils.nextElement(parser);
                String element = parser.getName();
                if (element == null) {
                    break;
                }
                if (element.equals(TAG_GROUP)) {
                    String name = parser.getAttributeValue(null, ATTR_GROUP_NAME);
                    if (GROUP_TOUCH_SOUNDS.equals(name)) {
                        inTouchSoundsGroup = true;
                        break;
                    }
                }
            }
            while (inTouchSoundsGroup) {
                XmlUtils.nextElement(parser);
                String element = parser.getName();
                if (element == null) {
                    break;
                }
                if (element.equals(TAG_ASSET)) {
                    String id = parser.getAttributeValue(null, ATTR_ASSET_ID);
                    String file = parser.getAttributeValue(null, ATTR_ASSET_FILE);
                    int fx;
                    try {
                        Field field = AudioManager.class.getField(id);
                        fx = field.getInt(null);
                    } catch (Exception e) {
                        Log.w(TAG, "Invalid touch sound ID: " + id);
                        continue;
                    }
                    int i = SOUND_EFFECT_FILES.indexOf(file);
                    if (i == -1) {
                        i = SOUND_EFFECT_FILES.size();
                        SOUND_EFFECT_FILES.add(file);
                    }
                    SOUND_EFFECT_FILES_MAP[fx][0] = i;
                } else if (element.equals(TAG_GROUP)) {
                    String name = parser.getAttributeValue(null, ATTR_GROUP_NAME);
                    if (GROUP_LOCK_SOUNDS.equals(name)) {
                        inLockSoundsGroup = true;
                    }
                    break;
                } else {
                    break;
                }
            }
            while (inLockSoundsGroup) {
                XmlUtils.nextElement(parser);
                String element = parser.getName();
                if (element == null) {
                    break;
                }
                if (element.equals(TAG_ASSET)) {
                    String id = parser.getAttributeValue(null, ATTR_ASSET_ID);
                    String file = parser.getAttributeValue(null, ATTR_ASSET_FILE);
                    if (id.equals("FX_LOCK")) {
                        Settings.Global.putString(mContentResolver, Settings.Global.LOCK_SOUND, mActiveSoundEffectsPath + file);
                    } else if (id.equals("FX_UNLOCK")) {
                        Settings.Global.putString(mContentResolver, Settings.Global.UNLOCK_SOUND, mActiveSoundEffectsPath + file);
                    } else {
                        Log.w(TAG, "Unrecognized lock sound ID: " + id);
                    }
                } else if (element.equals(TAG_GROUP)) {
                    String name = parser.getAttributeValue(null, ATTR_GROUP_NAME);
                    if (GROUP_CAMERA_SOUNDS.equals(name)) {
                        inCameraSoundsGroup = true;
                    }
                    break;
                } else {
                    break;
                }
            }
            while (inCameraSoundsGroup) {
                XmlUtils.nextElement(parser);
                String element = parser.getName();
                if (element == null) {
                    break;
                }
                if (element.equals(TAG_ASSET)) {
                    String id = parser.getAttributeValue(null, ATTR_ASSET_ID);
                    String file = parser.getAttributeValue(null, ATTR_ASSET_FILE);
                    if (id.equals("CAMERA_SHUTTER")) {
                        symlink(mActiveSoundEffectsPath + file, CUSTOM_AUDIO_SYMLINK_PATH + "camera_click.ogg");
                    } else if (id.equals("CAMERA_FOCUS")) {
                        symlink(mActiveSoundEffectsPath + file, CUSTOM_AUDIO_SYMLINK_PATH + "camera_focus.ogg");
                    } else if (id.equals("VIDEO_REC_START")) {
                        symlink(mActiveSoundEffectsPath + file, CUSTOM_AUDIO_SYMLINK_PATH + "VideoRecord_start.ogg");
                    } else if (id.equals("VIDEO_REC_STOP")) {
                        symlink(mActiveSoundEffectsPath + file, CUSTOM_AUDIO_SYMLINK_PATH + "VideoRecord_stop.ogg");
                    } else {
                        Log.w(TAG, "Unrecognized camera sound ID: " + id);
                    }
                }
            }
        }
    } catch (Resources.NotFoundException e) {
        Log.w(TAG, "audio assets file not found", e);
    } catch (XmlPullParserException e) {
        Log.w(TAG, "XML parser exception reading touch sound assets", e);
    } catch (IOException e) {
        Log.w(TAG, "I/O exception reading touch sound assets", e);
    } finally {
        if (parser != null && parser instanceof XmlResourceParser) {
            ((XmlResourceParser) parser).close();
        }
    }
}
#end_block

#method_before
private boolean onLoadSoundEffects() {
    int status;
    synchronized (mSoundEffectsLock) {
        if (!mBootCompleted) {
            Log.w(TAG, "onLoadSoundEffects() called before boot complete");
            return false;
        }
        if (mSoundPool != null) {
            return true;
        }
        loadTouchSoundAssets();
        mSoundPool = new SoundPool(NUM_SOUNDPOOL_CHANNELS, AudioSystem.STREAM_SYSTEM, 0);
        mSoundPoolCallBack = null;
        mSoundPoolListenerThread = new SoundPoolListenerThread();
        mSoundPoolListenerThread.start();
        int attempts = 3;
        while ((mSoundPoolCallBack == null) && (attempts-- > 0)) {
            try {
                // Wait for mSoundPoolCallBack to be set by the other thread
                mSoundEffectsLock.wait(SOUND_EFECTS_LOAD_TIMEOUT_MS);
            } catch (InterruptedException e) {
                Log.w(TAG, "Interrupted while waiting sound pool listener thread.");
            }
        }
        if (mSoundPoolCallBack == null) {
            Log.w(TAG, "onLoadSoundEffects() SoundPool listener or thread creation error");
            if (mSoundPoolLooper != null) {
                mSoundPoolLooper.quit();
                mSoundPoolLooper = null;
            }
            mSoundPoolListenerThread = null;
            mSoundPool.release();
            mSoundPool = null;
            return false;
        }
        /*
                 * poolId table: The value -1 in this table indicates that corresponding
                 * file (same index in SOUND_EFFECT_FILES[] has not been loaded.
                 * Once loaded, the value in poolId is the sample ID and the same
                 * sample can be reused for another effect using the same file.
                 */
        int[] poolId = new int[SOUND_EFFECT_FILES.size()];
        for (int fileIdx = 0; fileIdx < SOUND_EFFECT_FILES.size(); fileIdx++) {
            poolId[fileIdx] = -1;
        }
        /*
                 * Effects whose value in SOUND_EFFECT_FILES_MAP[effect][1] is -1 must be loaded.
                 * If load succeeds, value in SOUND_EFFECT_FILES_MAP[effect][1] is > 0:
                 * this indicates we have a valid sample loaded for this effect.
                 */
        int numSamples = 0;
        for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
            // Do not load sample if this effect uses the MediaPlayer
            if (SOUND_EFFECT_FILES_MAP[effect][1] == 0) {
                continue;
            }
            if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == -1) {
                String filePath = Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES.get(SOUND_EFFECT_FILES_MAP[effect][0]);
                int sampleId = mSoundPool.load(filePath, 0);
                if (sampleId <= 0) {
                    Log.w(TAG, "Soundpool could not load file: " + filePath);
                } else {
                    SOUND_EFFECT_FILES_MAP[effect][1] = sampleId;
                    poolId[SOUND_EFFECT_FILES_MAP[effect][0]] = sampleId;
                    numSamples++;
                }
            } else {
                SOUND_EFFECT_FILES_MAP[effect][1] = poolId[SOUND_EFFECT_FILES_MAP[effect][0]];
            }
        }
        // wait for all samples to be loaded
        if (numSamples > 0) {
            mSoundPoolCallBack.setSamples(poolId);
            attempts = 3;
            status = 1;
            while ((status == 1) && (attempts-- > 0)) {
                try {
                    mSoundEffectsLock.wait(SOUND_EFECTS_LOAD_TIMEOUT_MS);
                    status = mSoundPoolCallBack.status();
                } catch (InterruptedException e) {
                    Log.w(TAG, "Interrupted while waiting sound pool callback.");
                }
            }
        } else {
            status = -1;
        }
        if (mSoundPoolLooper != null) {
            mSoundPoolLooper.quit();
            mSoundPoolLooper = null;
        }
        mSoundPoolListenerThread = null;
        if (status != 0) {
            Log.w(TAG, "onLoadSoundEffects(), Error " + status + " while loading samples");
            for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
                if (SOUND_EFFECT_FILES_MAP[effect][1] > 0) {
                    SOUND_EFFECT_FILES_MAP[effect][1] = -1;
                }
            }
            mSoundPool.release();
            mSoundPool = null;
        }
    }
    return (status == 0);
}
#method_after
private boolean onLoadSoundEffects() {
    int status;
    synchronized (mSoundEffectsLock) {
        if (!mBootCompleted) {
            Log.w(TAG, "onLoadSoundEffects() called before boot complete");
            return false;
        }
        if (mSoundPool != null) {
            return true;
        }
        loadTouchSoundAssets();
        mSoundPool = new SoundPool(NUM_SOUNDPOOL_CHANNELS, AudioSystem.STREAM_SYSTEM, 0);
        mSoundPoolCallBack = null;
        mSoundPoolListenerThread = new SoundPoolListenerThread();
        mSoundPoolListenerThread.start();
        int attempts = 3;
        while ((mSoundPoolCallBack == null) && (attempts-- > 0)) {
            try {
                // Wait for mSoundPoolCallBack to be set by the other thread
                mSoundEffectsLock.wait(SOUND_EFECTS_LOAD_TIMEOUT_MS);
            } catch (InterruptedException e) {
                Log.w(TAG, "Interrupted while waiting sound pool listener thread.");
            }
        }
        if (mSoundPoolCallBack == null) {
            Log.w(TAG, "onLoadSoundEffects() SoundPool listener or thread creation error");
            if (mSoundPoolLooper != null) {
                mSoundPoolLooper.quit();
                mSoundPoolLooper = null;
            }
            mSoundPoolListenerThread = null;
            mSoundPool.release();
            mSoundPool = null;
            return false;
        }
        /*
                 * poolId table: The value -1 in this table indicates that corresponding
                 * file (same index in SOUND_EFFECT_FILES[] has not been loaded.
                 * Once loaded, the value in poolId is the sample ID and the same
                 * sample can be reused for another effect using the same file.
                 */
        int[] poolId = new int[SOUND_EFFECT_FILES.size()];
        for (int fileIdx = 0; fileIdx < SOUND_EFFECT_FILES.size(); fileIdx++) {
            poolId[fileIdx] = -1;
        }
        /*
                 * Effects whose value in SOUND_EFFECT_FILES_MAP[effect][1] is -1 must be loaded.
                 * If load succeeds, value in SOUND_EFFECT_FILES_MAP[effect][1] is > 0:
                 * this indicates we have a valid sample loaded for this effect.
                 */
        int numSamples = 0;
        for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
            // Do not load sample if this effect uses the MediaPlayer
            if (SOUND_EFFECT_FILES_MAP[effect][1] == 0) {
                continue;
            }
            if (poolId[SOUND_EFFECT_FILES_MAP[effect][0]] == -1) {
                String filePath = mActiveSoundEffectsPath + SOUND_EFFECT_FILES.get(SOUND_EFFECT_FILES_MAP[effect][0]);
                int sampleId = mSoundPool.load(filePath, 0);
                if (sampleId <= 0) {
                    Log.w(TAG, "Soundpool could not load file: " + filePath);
                } else {
                    SOUND_EFFECT_FILES_MAP[effect][1] = sampleId;
                    poolId[SOUND_EFFECT_FILES_MAP[effect][0]] = sampleId;
                    numSamples++;
                }
            } else {
                SOUND_EFFECT_FILES_MAP[effect][1] = poolId[SOUND_EFFECT_FILES_MAP[effect][0]];
            }
        }
        // wait for all samples to be loaded
        if (numSamples > 0) {
            mSoundPoolCallBack.setSamples(poolId);
            attempts = 3;
            status = 1;
            while ((status == 1) && (attempts-- > 0)) {
                try {
                    mSoundEffectsLock.wait(SOUND_EFECTS_LOAD_TIMEOUT_MS);
                    status = mSoundPoolCallBack.status();
                } catch (InterruptedException e) {
                    Log.w(TAG, "Interrupted while waiting sound pool callback.");
                }
            }
        } else {
            status = -1;
        }
        if (mSoundPoolLooper != null) {
            mSoundPoolLooper.quit();
            mSoundPoolLooper = null;
        }
        mSoundPoolListenerThread = null;
        if (status != 0) {
            Log.w(TAG, "onLoadSoundEffects(), Error " + status + " while loading samples");
            for (int effect = 0; effect < AudioManager.NUM_SOUND_EFFECTS; effect++) {
                if (SOUND_EFFECT_FILES_MAP[effect][1] > 0) {
                    SOUND_EFFECT_FILES_MAP[effect][1] = -1;
                }
            }
            mSoundPool.release();
            mSoundPool = null;
        }
    }
    return (status == 0);
}
#end_block

#method_before
private void onPlaySoundEffect(int effectType, int volume) {
    synchronized (mSoundEffectsLock) {
        onLoadSoundEffects();
        if (mSoundPool == null) {
            return;
        }
        float volFloat;
        // use default if volume is not specified by caller
        if (volume < 0) {
            volFloat = (float) Math.pow(10, (float) sSoundEffectVolumeDb / 20);
        } else {
            volFloat = (float) volume / 1000.0f;
        }
        if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
            mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1], volFloat, volFloat, 0, 0, 1.0f);
        } else {
            MediaPlayer mediaPlayer = new MediaPlayer();
            try {
                String filePath = Environment.getRootDirectory() + SOUND_EFFECTS_PATH + SOUND_EFFECT_FILES.get(SOUND_EFFECT_FILES_MAP[effectType][0]);
                mediaPlayer.setDataSource(filePath);
                mediaPlayer.setAudioStreamType(AudioSystem.STREAM_SYSTEM);
                mediaPlayer.prepare();
                mediaPlayer.setVolume(volFloat);
                mediaPlayer.setOnCompletionListener(new OnCompletionListener() {

                    public void onCompletion(MediaPlayer mp) {
                        cleanupPlayer(mp);
                    }
                });
                mediaPlayer.setOnErrorListener(new OnErrorListener() {

                    public boolean onError(MediaPlayer mp, int what, int extra) {
                        cleanupPlayer(mp);
                        return true;
                    }
                });
                mediaPlayer.start();
            } catch (IOException ex) {
                Log.w(TAG, "MediaPlayer IOException: " + ex);
            } catch (IllegalArgumentException ex) {
                Log.w(TAG, "MediaPlayer IllegalArgumentException: " + ex);
            } catch (IllegalStateException ex) {
                Log.w(TAG, "MediaPlayer IllegalStateException: " + ex);
            }
        }
    }
}
#method_after
private void onPlaySoundEffect(int effectType, int volume) {
    synchronized (mSoundEffectsLock) {
        onLoadSoundEffects();
        if (mSoundPool == null) {
            return;
        }
        float volFloat;
        // use default if volume is not specified by caller
        if (volume < 0) {
            volFloat = (float) Math.pow(10, (float) sSoundEffectVolumeDb / 20);
        } else {
            volFloat = (float) volume / 1000.0f;
        }
        if (SOUND_EFFECT_FILES_MAP[effectType][1] > 0) {
            mSoundPool.play(SOUND_EFFECT_FILES_MAP[effectType][1], volFloat, volFloat, 0, 0, 1.0f);
        } else {
            MediaPlayer mediaPlayer = new MediaPlayer();
            try {
                String filePath = mActiveSoundEffectsPath + SOUND_EFFECT_FILES.get(SOUND_EFFECT_FILES_MAP[effectType][0]);
                mediaPlayer.setDataSource(filePath);
                mediaPlayer.setAudioStreamType(AudioSystem.STREAM_SYSTEM);
                mediaPlayer.prepare();
                mediaPlayer.setVolume(volFloat);
                mediaPlayer.setOnCompletionListener(new OnCompletionListener() {

                    public void onCompletion(MediaPlayer mp) {
                        cleanupPlayer(mp);
                    }
                });
                mediaPlayer.setOnErrorListener(new OnErrorListener() {

                    public boolean onError(MediaPlayer mp, int what, int extra) {
                        cleanupPlayer(mp);
                        return true;
                    }
                });
                mediaPlayer.start();
            } catch (IOException ex) {
                Log.w(TAG, "MediaPlayer IOException: " + ex);
            } catch (IllegalArgumentException ex) {
                Log.w(TAG, "MediaPlayer IllegalArgumentException: " + ex);
            } catch (IllegalStateException ex) {
                Log.w(TAG, "MediaPlayer IllegalStateException: " + ex);
            }
        }
    }
}
#end_block

#method_before
@Override
public void onChange(boolean selfChange) {
    super.onChange(selfChange);
    // mRingerModeMutedStreams and mMuteAffectedStreams are safe (only accessed once).
    synchronized (mSettingsLock) {
        if (updateRingerModeAffectedStreams()) {
            /*
                     * Ensure all stream types that should be affected by ringer mode
                     * are in the proper state.
                     */
            setRingerModeInt(getRingerMode(), false);
        }
        readDockAudioSettings(mContentResolver);
        updateManualSafeMediaVolume();
        mLinkNotificationWithVolume = Settings.System.getIntForUser(mContentResolver, Settings.System.VOLUME_LINK_NOTIFICATION, 1, UserHandle.USER_CURRENT) == 1;
        if (mLinkNotificationWithVolume) {
            mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_RING;
        } else {
            mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_NOTIFICATION;
        }
        mVolumeKeysDefault = Settings.System.getIntForUser(mContentResolver, Settings.System.VOLUME_KEYS_DEFAULT, 1, UserHandle.USER_CURRENT);
    }
}
#method_after
@Override
public void onChange(boolean selfChange) {
    super.onChange(selfChange);
    // mRingerModeMutedStreams and mMuteAffectedStreams are safe (only accessed once).
    synchronized (mSettingsLock) {
        if (updateRingerModeAffectedStreams()) {
            /*
                     * Ensure all stream types that should be affected by ringer mode
                     * are in the proper state.
                     */
            setRingerModeInt(getRingerMode(), false);
        }
        readDockAudioSettings(mContentResolver);
        updateManualSafeMediaVolume();
        mLinkNotificationWithVolume = Settings.System.getIntForUser(mContentResolver, Settings.System.VOLUME_LINK_NOTIFICATION, 1, UserHandle.USER_CURRENT) == 1;
        if (mLinkNotificationWithVolume) {
            mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_RING;
        } else {
            mStreamVolumeAlias[AudioSystem.STREAM_NOTIFICATION] = AudioSystem.STREAM_NOTIFICATION;
        }
        mVolumeKeysDefault = Settings.System.getIntForUser(mContentResolver, Settings.System.VOLUME_KEYS_DEFAULT, 1, UserHandle.USER_CURRENT);
        reloadTouchSoundAssets();
    }
}
#end_block

#method_before
private void enforceSafeMediaVolume() {
    // return if safe volume has been manually turned off
    if (!mManualSafeMediaVolume)
        return;
    VolumeStreamState streamState = mStreamStates[AudioSystem.STREAM_MUSIC];
    int devices = mSafeMediaVolumeDevices;
    int i = 0;
    while (devices != 0) {
        int device = 1 << i++;
        if ((device & devices) == 0) {
            continue;
        }
        int index = streamState.getIndex(device);
        if (index > mSafeMediaVolumeIndex) {
            streamState.setIndex(mSafeMediaVolumeIndex, device);
            sendMsg(mAudioHandler, MSG_SET_DEVICE_VOLUME, SENDMSG_QUEUE, device, 0, streamState, 0);
        }
        devices &= ~device;
    }
}
#method_after
private void enforceSafeMediaVolume() {
    // return if safe volume has been manually turned off
    if (!mManualSafeMediaVolume) {
        return;
    }
    VolumeStreamState streamState = mStreamStates[AudioSystem.STREAM_MUSIC];
    int devices = mSafeMediaVolumeDevices;
    int i = 0;
    while (devices != 0) {
        int device = 1 << i++;
        if ((device & devices) == 0) {
            continue;
        }
        int index = streamState.getIndex(device);
        if (index > mSafeMediaVolumeIndex) {
            streamState.setIndex(mSafeMediaVolumeIndex, device);
            sendMsg(mAudioHandler, MSG_SET_DEVICE_VOLUME, SENDMSG_QUEUE, device, 0, streamState, 0);
        }
        devices &= ~device;
    }
}
#end_block

#method_before
protected void updateManualSafeMediaVolume() {
    int safeMediaVolumeEnable = Settings.System.getInt(mContext.getContentResolver(), Settings.System.MANUAL_SAFE_MEDIA_VOLUME, 1);
    mManualSafeMediaVolume = (safeMediaVolumeEnable == 1);
    setSafeMediaVolumeEnabled(mManualSafeMediaVolume);
}
#method_after
private void updateManualSafeMediaVolume() {
    int safeMediaVolumeEnable = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.MANUAL_SAFE_MEDIA_VOLUME, 1, UserHandle.USER_CURRENT);
    mManualSafeMediaVolume = (safeMediaVolumeEnable == 1);
    setSafeMediaVolumeEnabled(mManualSafeMediaVolume);
}
#end_block

#method_before
private PreferenceScreen createPreferenceHierarchy() {
    PreferenceScreen root = getPreferenceScreen();
    if (root != null) {
        root.removeAll();
    }
    addPreferencesFromResource(R.xml.security_settings);
    root = getPreferenceScreen();
    // Add options for lock/unlock screen
    int resid = 0;
    if (!mLockPatternUtils.isSecure()) {
        // if there are multiple users, disable "None" setting
        UserManager mUm = (UserManager) getSystemService(Context.USER_SERVICE);
        List<UserInfo> users = mUm.getUsers(true);
        final boolean singleUser = users.size() == 1;
        if (singleUser && mLockPatternUtils.isLockScreenDisabled()) {
            resid = R.xml.security_settings_lockscreen;
        } else {
            resid = R.xml.security_settings_chooser;
        }
    } else if (mLockPatternUtils.usingBiometricWeak() && mLockPatternUtils.isBiometricWeakInstalled()) {
        resid = R.xml.security_settings_biometric_weak;
    } else {
        switch(mLockPatternUtils.getKeyguardStoredPasswordQuality()) {
            case DevicePolicyManager.PASSWORD_QUALITY_SOMETHING:
                resid = R.xml.security_settings_pattern;
                break;
            case DevicePolicyManager.PASSWORD_QUALITY_NUMERIC:
                resid = R.xml.security_settings_pin;
                break;
            case DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC:
            case DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC:
            case DevicePolicyManager.PASSWORD_QUALITY_COMPLEX:
                resid = R.xml.security_settings_password;
                break;
        }
    }
    addPreferencesFromResource(resid);
    // Add options for device encryption
    mIsPrimary = UserHandle.myUserId() == UserHandle.USER_OWNER;
    if (!mIsPrimary) {
        // Rename owner info settings
        Preference ownerInfoPref = findPreference(KEY_OWNER_INFO_SETTINGS);
        if (ownerInfoPref != null) {
            if (UserManager.get(getActivity()).isLinkedUser()) {
                ownerInfoPref.setTitle(R.string.profile_info_settings_title);
            } else {
                ownerInfoPref.setTitle(R.string.user_info_settings_title);
            }
        }
    }
    if (mIsPrimary) {
        switch(mDPM.getStorageEncryptionStatus()) {
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE:
                // The device is currently encrypted.
                addPreferencesFromResource(R.xml.security_settings_encrypted);
                break;
            case DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE:
                // This device supports encryption but isn't encrypted.
                addPreferencesFromResource(R.xml.security_settings_unencrypted);
                break;
        }
    }
    // lock after preference
    mLockAfter = (ListPreference) root.findPreference(KEY_LOCK_AFTER_TIMEOUT);
    if (mLockAfter != null) {
        setupLockAfterPreference();
        updateLockAfterPreferenceSummary();
    }
    // Add the additional Omni settings
    mLockRingBattery = (CheckBoxPreference) root.findPreference(BATTERY_AROUND_LOCKSCREEN_RING);
    if (mLockRingBattery != null) {
        mLockRingBattery.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.BATTERY_AROUND_LOCKSCREEN_RING, 0) == 1);
    }
    // Menu Unlock
    mMenuUnlock = (CheckBoxPreference) root.findPreference(MENU_UNLOCK_PREF);
    if (mMenuUnlock != null) {
        final boolean configDisabled = getResources().getBoolean(com.android.internal.R.bool.config_disableMenuKeyInLockScreen);
        mMenuUnlock.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.MENU_UNLOCK_SCREEN, configDisabled ? 0 : 1) == 1);
    }
    // Enable / disable camera widget on lockscreen
    mEnableCameraWidget = (CheckBoxPreference) findPreference(KEY_ENABLE_CAMERA);
    // Enable or disable camera widget settings based on device
    if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA) || Camera.getNumberOfCameras() == 0) {
        PreferenceGroup securityCategory = (PreferenceGroup) root.findPreference(KEY_SECURITY_CATEGORY);
        if (securityCategory != null) {
            securityCategory.removePreference(root.findPreference(KEY_ENABLE_CAMERA));
            mEnableCameraWidget = null;
        }
    } else if (isCameraDisabledByDpm()) {
        if (mEnableCameraWidget != null) {
            mEnableCameraWidget.setEnabled(false);
        }
    } else {
        if (mEnableCameraWidget != null) {
            mEnableCameraWidget.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_ENABLE_CAMERA, 1) == 1);
            mEnableCameraWidget.setOnPreferenceChangeListener(this);
        }
    }
    // Enable / disable power menu on lockscreen
    mEnablePowerMenu = (CheckBoxPreference) findPreference(KEY_ENABLE_POWER_MENU);
    if (mEnablePowerMenu != null) {
        mEnablePowerMenu.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_ENABLE_POWER_MENU, 1) == 1);
        mEnablePowerMenu.setOnPreferenceChangeListener(this);
    }
    // Lockscreen Blur
    mSeeThrough = (CheckBoxPreference) findPreference(KEY_SEE_THROUGH);
    if (mSeeThrough != null) {
        mSeeThrough.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_SEE_THROUGH, 0) == 1);
        mSeeThrough.setOnPreferenceChangeListener(this);
    }
    // biometric weak liveliness
    mBiometricWeakLiveliness = (CheckBoxPreference) root.findPreference(KEY_BIOMETRIC_WEAK_LIVELINESS);
    // visible pattern
    mVisiblePattern = (CheckBoxPreference) root.findPreference(KEY_VISIBLE_PATTERN);
    // lock instantly on power key press
    mPowerButtonInstantlyLocks = (CheckBoxPreference) root.findPreference(KEY_POWER_INSTANTLY_LOCKS);
    // don't display visible pattern if biometric and backup is not pattern
    if (resid == R.xml.security_settings_biometric_weak && mLockPatternUtils.getKeyguardStoredPasswordQuality() != DevicePolicyManager.PASSWORD_QUALITY_SOMETHING) {
        PreferenceGroup securityCategory = (PreferenceGroup) root.findPreference(KEY_SECURITY_CATEGORY);
        if (securityCategory != null && mVisiblePattern != null) {
            securityCategory.removePreference(root.findPreference(KEY_VISIBLE_PATTERN));
        }
    }
    // Lock Numpad Random
    mLockNumpadRandom = (ListPreference) root.findPreference(LOCK_NUMPAD_RANDOM);
    if (mLockNumpadRandom != null) {
        mLockNumpadRandom.setValue(String.valueOf(Settings.Secure.getInt(getContentResolver(), Settings.Secure.LOCK_NUMPAD_RANDOM, 0)));
        mLockNumpadRandom.setSummary(mLockNumpadRandom.getEntry());
        mLockNumpadRandom.setOnPreferenceChangeListener(this);
    }
    // Append the rest of the settings
    addPreferencesFromResource(R.xml.security_settings_misc);
    // Do not display SIM lock for devices without an Icc card
    TelephonyManager tm = TelephonyManager.getDefault();
    if (!mIsPrimary || !tm.hasIccCard()) {
        root.removePreference(root.findPreference(KEY_SIM_LOCK));
    } else {
        // Disable SIM lock if sim card is missing or unknown
        if ((TelephonyManager.getDefault().getSimState() == TelephonyManager.SIM_STATE_ABSENT) || (TelephonyManager.getDefault().getSimState() == TelephonyManager.SIM_STATE_UNKNOWN)) {
            root.findPreference(KEY_SIM_LOCK).setEnabled(false);
        }
    }
    // Enable or disable keyguard widget checkbox based on DPM state
    mEnableKeyguardWidgets = (CheckBoxPreference) root.findPreference(KEY_ENABLE_WIDGETS);
    mMaximizeKeyguardWidgets = (CheckBoxPreference) root.findPreference(LOCKSCREEN_MAXIMIZE_WIDGETS);
    if (mEnableKeyguardWidgets != null && mMaximizeKeyguardWidgets != null) {
        if (ActivityManager.isLowRamDeviceStatic() || mLockPatternUtils.isLockScreenDisabled()) {
            // Widgets take a lot of RAM, so disable them on low-memory devices
            PreferenceGroup securityCategory = (PreferenceGroup) root.findPreference(KEY_SECURITY_CATEGORY);
            if (securityCategory != null) {
                securityCategory.removePreference(mEnableKeyguardWidgets);
                securityCategory.removePreference(mMaximizeKeyguardWidgets);
                mEnableKeyguardWidgets = null;
                mMaximizeKeyguardWidgets = null;
            }
        } else {
            final boolean disabled = (0 != (mDPM.getKeyguardDisabledFeatures(null) & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL));
            if (disabled) {
                mEnableKeyguardWidgets.setSummary(R.string.security_enable_widgets_disabled_summary);
            } else {
                mEnableKeyguardWidgets.setSummary("");
            }
            mEnableKeyguardWidgets.setEnabled(!disabled);
            mMaximizeKeyguardWidgets.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_MAXIMIZE_WIDGETS, 0) == 1);
        }
    }
    mQuickUnlockScreen = (CheckBoxPreference) root.findPreference(LOCKSCREEN_QUICK_UNLOCK_CONTROL);
    if (mQuickUnlockScreen != null) {
        mQuickUnlockScreen.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_QUICK_UNLOCK_CONTROL, 0) == 1);
        mQuickUnlockScreen.setOnPreferenceChangeListener(this);
    }
    // Show password
    mShowPassword = (CheckBoxPreference) root.findPreference(KEY_SHOW_PASSWORD);
    mResetCredentials = root.findPreference(KEY_RESET_CREDENTIALS);
    // Credential storage
    final UserManager um = (UserManager) getActivity().getSystemService(Context.USER_SERVICE);
    // needs to be initialized for onResume()
    mKeyStore = KeyStore.getInstance();
    if (!um.hasUserRestriction(UserManager.DISALLOW_CONFIG_CREDENTIALS)) {
        Preference credentialStorageType = root.findPreference(KEY_CREDENTIAL_STORAGE_TYPE);
        final int storageSummaryRes = mKeyStore.isHardwareBacked() ? R.string.credential_storage_type_hardware : R.string.credential_storage_type_software;
        credentialStorageType.setSummary(storageSummaryRes);
    } else {
        removePreference(KEY_CREDENTIALS_MANAGER);
    }
    // Application install
    PreferenceGroup deviceAdminCategory = (PreferenceGroup) root.findPreference(KEY_DEVICE_ADMIN_CATEGORY);
    mToggleAppInstallation = (CheckBoxPreference) findPreference(KEY_TOGGLE_INSTALL_APPLICATIONS);
    mToggleAppInstallation.setChecked(isNonMarketAppsAllowed());
    // Side loading of apps.
    mToggleAppInstallation.setEnabled(mIsPrimary);
    // Package verification, only visible to primary user and if enabled
    mToggleVerifyApps = (CheckBoxPreference) findPreference(KEY_TOGGLE_VERIFY_APPLICATIONS);
    if (mIsPrimary && showVerifierSetting()) {
        if (isVerifierInstalled()) {
            mToggleVerifyApps.setChecked(isVerifyAppsEnabled());
        } else {
            mToggleVerifyApps.setChecked(false);
            mToggleVerifyApps.setEnabled(false);
        }
    } else {
        if (deviceAdminCategory != null) {
            deviceAdminCategory.removePreference(mToggleVerifyApps);
        } else {
            mToggleVerifyApps.setEnabled(false);
        }
    }
    mNotificationAccess = findPreference(KEY_NOTIFICATION_ACCESS);
    if (mNotificationAccess != null) {
        final int total = NotificationAccessSettings.getListenersCount(mPM);
        if (total == 0) {
            if (deviceAdminCategory != null) {
                deviceAdminCategory.removePreference(mNotificationAccess);
            }
        } else {
            final int n = getNumEnabledNotificationListeners();
            if (n == 0) {
                mNotificationAccess.setSummary(getResources().getString(R.string.manage_notification_access_summary_zero));
            } else {
                mNotificationAccess.setSummary(String.format(getResources().getQuantityString(R.plurals.manage_notification_access_summary_nonzero, n, n)));
            }
        }
    }
    if (shouldBePinProtected(RESTRICTIONS_PIN_SET)) {
        protectByRestrictions(mToggleAppInstallation);
        protectByRestrictions(mToggleVerifyApps);
        protectByRestrictions(mResetCredentials);
        protectByRestrictions(root.findPreference(KEY_CREDENTIALS_INSTALL));
    }
    return root;
}
#method_after
private PreferenceScreen createPreferenceHierarchy() {
    PreferenceScreen root = getPreferenceScreen();
    if (root != null) {
        root.removeAll();
    }
    addPreferencesFromResource(R.xml.security_settings);
    root = getPreferenceScreen();
    // Add options for lock/unlock screen
    int resid = 0;
    if (!mLockPatternUtils.isSecure()) {
        // if there are multiple users, disable "None" setting
        UserManager mUm = (UserManager) getSystemService(Context.USER_SERVICE);
        List<UserInfo> users = mUm.getUsers(true);
        final boolean singleUser = users.size() == 1;
        if (singleUser && mLockPatternUtils.isLockScreenDisabled()) {
            resid = R.xml.security_settings_lockscreen;
        } else {
            resid = R.xml.security_settings_chooser;
        }
    } else if (mLockPatternUtils.usingBiometricWeak() && mLockPatternUtils.isBiometricWeakInstalled()) {
        resid = R.xml.security_settings_biometric_weak;
    } else {
        switch(mLockPatternUtils.getKeyguardStoredPasswordQuality()) {
            case DevicePolicyManager.PASSWORD_QUALITY_SOMETHING:
                resid = R.xml.security_settings_pattern;
                break;
            case DevicePolicyManager.PASSWORD_QUALITY_NUMERIC:
                resid = R.xml.security_settings_pin;
                break;
            case DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC:
            case DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC:
            case DevicePolicyManager.PASSWORD_QUALITY_COMPLEX:
                resid = R.xml.security_settings_password;
                break;
        }
    }
    addPreferencesFromResource(resid);
    // Add options for device encryption
    mIsPrimary = UserHandle.myUserId() == UserHandle.USER_OWNER;
    if (!mIsPrimary) {
        // Rename owner info settings
        Preference ownerInfoPref = findPreference(KEY_OWNER_INFO_SETTINGS);
        if (ownerInfoPref != null) {
            if (UserManager.get(getActivity()).isLinkedUser()) {
                ownerInfoPref.setTitle(R.string.profile_info_settings_title);
            } else {
                ownerInfoPref.setTitle(R.string.user_info_settings_title);
            }
        }
    }
    if (mIsPrimary) {
        switch(mDPM.getStorageEncryptionStatus()) {
            case DevicePolicyManager.ENCRYPTION_STATUS_ACTIVE:
                // The device is currently encrypted.
                addPreferencesFromResource(R.xml.security_settings_encrypted);
                break;
            case DevicePolicyManager.ENCRYPTION_STATUS_INACTIVE:
                // This device supports encryption but isn't encrypted.
                addPreferencesFromResource(R.xml.security_settings_unencrypted);
                break;
        }
    }
    // lock after preference
    mLockAfter = (ListPreference) root.findPreference(KEY_LOCK_AFTER_TIMEOUT);
    if (mLockAfter != null) {
        setupLockAfterPreference();
        updateLockAfterPreferenceSummary();
    }
    // Add the additional Omni settings
    mLockRingBattery = (CheckBoxPreference) root.findPreference(BATTERY_AROUND_LOCKSCREEN_RING);
    if (mLockRingBattery != null) {
        mLockRingBattery.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.BATTERY_AROUND_LOCKSCREEN_RING, 0) == 1);
    }
    // Menu Unlock
    mMenuUnlock = (CheckBoxPreference) root.findPreference(MENU_UNLOCK_PREF);
    if (mMenuUnlock != null) {
        final boolean configDisabled = getResources().getBoolean(com.android.internal.R.bool.config_disableMenuKeyInLockScreen);
        mMenuUnlock.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.MENU_UNLOCK_SCREEN, configDisabled ? 0 : 1) == 1);
    }
    // Enable / disable camera widget on lockscreen
    mEnableCameraWidget = (CheckBoxPreference) findPreference(KEY_ENABLE_CAMERA);
    // Enable or disable camera widget settings based on device
    if (mEnableCameraWidget != null) {
        if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA) || Camera.getNumberOfCameras() == 0) {
            PreferenceGroup securityCategory = (PreferenceGroup) root.findPreference(KEY_SECURITY_CATEGORY);
            if (securityCategory != null) {
                securityCategory.removePreference(root.findPreference(KEY_ENABLE_CAMERA));
            }
        } else if (isCameraDisabledByDpm()) {
            mEnableCameraWidget.setEnabled(false);
        } else {
            mEnableCameraWidget.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_ENABLE_CAMERA, 1) == 1);
            mEnableCameraWidget.setOnPreferenceChangeListener(this);
        }
    }
    // Enable / disable power menu on lockscreen
    mEnablePowerMenu = (CheckBoxPreference) findPreference(KEY_ENABLE_POWER_MENU);
    if (mEnablePowerMenu != null) {
        mEnablePowerMenu.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_ENABLE_POWER_MENU, 1) == 1);
        mEnablePowerMenu.setOnPreferenceChangeListener(this);
    }
    // Lockscreen Blur
    mSeeThrough = (CheckBoxPreference) findPreference(KEY_SEE_THROUGH);
    if (mSeeThrough != null) {
        mSeeThrough.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_SEE_THROUGH, 0) == 1);
        mSeeThrough.setOnPreferenceChangeListener(this);
    }
    // biometric weak liveliness
    mBiometricWeakLiveliness = (CheckBoxPreference) root.findPreference(KEY_BIOMETRIC_WEAK_LIVELINESS);
    // visible pattern
    mVisiblePattern = (CheckBoxPreference) root.findPreference(KEY_VISIBLE_PATTERN);
    // lock instantly on power key press
    mPowerButtonInstantlyLocks = (CheckBoxPreference) root.findPreference(KEY_POWER_INSTANTLY_LOCKS);
    // don't display visible pattern if biometric and backup is not pattern
    if (resid == R.xml.security_settings_biometric_weak && mLockPatternUtils.getKeyguardStoredPasswordQuality() != DevicePolicyManager.PASSWORD_QUALITY_SOMETHING) {
        PreferenceGroup securityCategory = (PreferenceGroup) root.findPreference(KEY_SECURITY_CATEGORY);
        if (securityCategory != null && mVisiblePattern != null) {
            securityCategory.removePreference(root.findPreference(KEY_VISIBLE_PATTERN));
        }
    }
    // Lock Numpad Random
    mLockNumpadRandom = (ListPreference) root.findPreference(LOCK_NUMPAD_RANDOM);
    if (mLockNumpadRandom != null) {
        mLockNumpadRandom.setValue(String.valueOf(Settings.Secure.getInt(getContentResolver(), Settings.Secure.LOCK_NUMPAD_RANDOM, 0)));
        mLockNumpadRandom.setSummary(mLockNumpadRandom.getEntry());
        mLockNumpadRandom.setOnPreferenceChangeListener(this);
    }
    // Append the rest of the settings
    addPreferencesFromResource(R.xml.security_settings_misc);
    // Do not display SIM lock for devices without an Icc card
    TelephonyManager tm = TelephonyManager.getDefault();
    if (!mIsPrimary || !tm.hasIccCard()) {
        root.removePreference(root.findPreference(KEY_SIM_LOCK));
    } else {
        // Disable SIM lock if sim card is missing or unknown
        if ((TelephonyManager.getDefault().getSimState() == TelephonyManager.SIM_STATE_ABSENT) || (TelephonyManager.getDefault().getSimState() == TelephonyManager.SIM_STATE_UNKNOWN)) {
            root.findPreference(KEY_SIM_LOCK).setEnabled(false);
        }
    }
    // Enable or disable keyguard widget checkbox based on DPM state
    mEnableKeyguardWidgets = (CheckBoxPreference) root.findPreference(KEY_ENABLE_WIDGETS);
    mMaximizeKeyguardWidgets = (CheckBoxPreference) root.findPreference(LOCKSCREEN_MAXIMIZE_WIDGETS);
    if (mEnableKeyguardWidgets != null && mMaximizeKeyguardWidgets != null) {
        if (ActivityManager.isLowRamDeviceStatic() || mLockPatternUtils.isLockScreenDisabled()) {
            // Widgets take a lot of RAM, so disable them on low-memory devices
            PreferenceGroup securityCategory = (PreferenceGroup) root.findPreference(KEY_SECURITY_CATEGORY);
            if (securityCategory != null) {
                securityCategory.removePreference(mEnableKeyguardWidgets);
                securityCategory.removePreference(mMaximizeKeyguardWidgets);
                mEnableKeyguardWidgets = null;
                mMaximizeKeyguardWidgets = null;
            }
        } else {
            final boolean disabled = (0 != (mDPM.getKeyguardDisabledFeatures(null) & DevicePolicyManager.KEYGUARD_DISABLE_WIDGETS_ALL));
            if (disabled) {
                mEnableKeyguardWidgets.setSummary(R.string.security_enable_widgets_disabled_summary);
            } else {
                mEnableKeyguardWidgets.setSummary("");
            }
            mEnableKeyguardWidgets.setEnabled(!disabled);
            mMaximizeKeyguardWidgets.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_MAXIMIZE_WIDGETS, 0) == 1);
        }
    }
    mQuickUnlockScreen = (CheckBoxPreference) root.findPreference(LOCKSCREEN_QUICK_UNLOCK_CONTROL);
    if (mQuickUnlockScreen != null) {
        mQuickUnlockScreen.setChecked(Settings.System.getInt(getContentResolver(), Settings.System.LOCKSCREEN_QUICK_UNLOCK_CONTROL, 0) == 1);
        mQuickUnlockScreen.setOnPreferenceChangeListener(this);
    }
    // Show password
    mShowPassword = (CheckBoxPreference) root.findPreference(KEY_SHOW_PASSWORD);
    mResetCredentials = root.findPreference(KEY_RESET_CREDENTIALS);
    // Credential storage
    final UserManager um = (UserManager) getActivity().getSystemService(Context.USER_SERVICE);
    // needs to be initialized for onResume()
    mKeyStore = KeyStore.getInstance();
    if (!um.hasUserRestriction(UserManager.DISALLOW_CONFIG_CREDENTIALS)) {
        Preference credentialStorageType = root.findPreference(KEY_CREDENTIAL_STORAGE_TYPE);
        final int storageSummaryRes = mKeyStore.isHardwareBacked() ? R.string.credential_storage_type_hardware : R.string.credential_storage_type_software;
        credentialStorageType.setSummary(storageSummaryRes);
    } else {
        removePreference(KEY_CREDENTIALS_MANAGER);
    }
    // Application install
    PreferenceGroup deviceAdminCategory = (PreferenceGroup) root.findPreference(KEY_DEVICE_ADMIN_CATEGORY);
    mToggleAppInstallation = (CheckBoxPreference) findPreference(KEY_TOGGLE_INSTALL_APPLICATIONS);
    mToggleAppInstallation.setChecked(isNonMarketAppsAllowed());
    // Side loading of apps.
    mToggleAppInstallation.setEnabled(mIsPrimary);
    // Package verification, only visible to primary user and if enabled
    mToggleVerifyApps = (CheckBoxPreference) findPreference(KEY_TOGGLE_VERIFY_APPLICATIONS);
    if (mIsPrimary && showVerifierSetting()) {
        if (isVerifierInstalled()) {
            mToggleVerifyApps.setChecked(isVerifyAppsEnabled());
        } else {
            mToggleVerifyApps.setChecked(false);
            mToggleVerifyApps.setEnabled(false);
        }
    } else {
        if (deviceAdminCategory != null) {
            deviceAdminCategory.removePreference(mToggleVerifyApps);
        } else {
            mToggleVerifyApps.setEnabled(false);
        }
    }
    mNotificationAccess = findPreference(KEY_NOTIFICATION_ACCESS);
    if (mNotificationAccess != null) {
        final int total = NotificationAccessSettings.getListenersCount(mPM);
        if (total == 0) {
            if (deviceAdminCategory != null) {
                deviceAdminCategory.removePreference(mNotificationAccess);
            }
        } else {
            final int n = getNumEnabledNotificationListeners();
            if (n == 0) {
                mNotificationAccess.setSummary(getResources().getString(R.string.manage_notification_access_summary_zero));
            } else {
                mNotificationAccess.setSummary(String.format(getResources().getQuantityString(R.plurals.manage_notification_access_summary_nonzero, n, n)));
            }
        }
    }
    if (shouldBePinProtected(RESTRICTIONS_PIN_SET)) {
        protectByRestrictions(mToggleAppInstallation);
        protectByRestrictions(mToggleVerifyApps);
        protectByRestrictions(mResetCredentials);
        protectByRestrictions(root.findPreference(KEY_CREDENTIALS_INSTALL));
    }
    return root;
}
#end_block

#method_before
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLUME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLUME_MUSIC_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HARDWARE_KEY_REBINDING), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.IMMERSIVE_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VIRTUAL_KEYS_HAPTIC_FEEDBACK), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#method_after
void observe() {
    // Observe all users' changes
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.END_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.INCALL_POWER_BUTTON_BEHAVIOR), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.ACCELEROMETER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.USER_ROTATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_OFF_TIMEOUT), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.POINTER_LOCATION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.DEFAULT_INPUT_METHOD), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.Secure.IMMERSIVE_MODE_CONFIRMATIONS), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLUME_WAKE_SCREEN), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VOLUME_MUSIC_CONTROL), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_HOME_DOUBLE_TAP_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_MENU_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_ASSIST_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.KEY_BACK_LONG_PRESS_ACTION), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.HARDWARE_KEY_REBINDING), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.IMMERSIVE_MODE), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.VIRTUAL_KEYS_HAPTIC_FEEDBACK), false, this, UserHandle.USER_ALL);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SOFT_BACK_KILL_APP_ENABLE), false, this, UserHandle.USER_ALL);
    updateSettings();
}
#end_block

#method_before
private void updateKeyAssignments() {
    final boolean hasMenu = (mDeviceHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasBack = (mDeviceHardwareKeys & KEY_MASK_BACK) != 0;
    final boolean hasHome = (mDeviceHardwareKeys & KEY_MASK_HOME) != 0;
    final boolean hasAssist = (mDeviceHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitch = (mDeviceHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final ContentResolver resolver = mContext.getContentResolver();
    // initialize all assignments to sane defaults
    mPressOnHomeBehavior = KEY_ACTION_HOME;
    mPressOnMenuBehavior = KEY_ACTION_MENU;
    if (!hasMenu || hasAssist) {
        mLongPressOnMenuBehavior = KEY_ACTION_NOTHING;
    } else {
        mLongPressOnMenuBehavior = KEY_ACTION_SEARCH;
    }
    mPressOnAssistBehavior = KEY_ACTION_SEARCH;
    mLongPressOnAssistBehavior = KEY_ACTION_VOICE_SEARCH;
    mPressOnAppSwitchBehavior = KEY_ACTION_APP_SWITCH;
    mLongPressOnAppSwitchBehavior = KEY_ACTION_NOTHING;
    mPressOnBackBehavior = KEY_ACTION_BACK;
    mLongPressOnBackBehavior = KEY_ACTION_NOTHING;
    mLongPressOnHomeBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnHomeBehavior);
    if (mLongPressOnHomeBehavior == 1) {
        mLongPressOnHomeBehavior = KEY_ACTION_APP_SWITCH;
    } else if (mLongPressOnHomeBehavior == 2) {
        mLongPressOnHomeBehavior = KEY_ACTION_SEARCH;
    } else {
        mLongPressOnHomeBehavior = KEY_ACTION_NOTHING;
    }
    mDoubleTapOnHomeBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doubleTapOnHomeBehavior);
    if (mDoubleTapOnHomeBehavior == 1) {
        mDoubleTapOnHomeBehavior = KEY_ACTION_APP_SWITCH;
    } else {
        mDoubleTapOnHomeBehavior = KEY_ACTION_NOTHING;
    }
    boolean keyRebindingEnabled = Settings.System.getIntForUser(resolver, Settings.System.HARDWARE_KEY_REBINDING, 0, UserHandle.USER_CURRENT) == 1;
    if (keyRebindingEnabled) {
        if (hasHome) {
            mPressOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_ACTION, KEY_ACTION_HOME, UserHandle.USER_CURRENT);
            mLongPressOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_LONG_PRESS_ACTION, hasAppSwitch ? KEY_ACTION_NOTHING : mLongPressOnHomeBehavior, UserHandle.USER_CURRENT);
            mDoubleTapOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, mDoubleTapOnHomeBehavior, UserHandle.USER_CURRENT);
        }
        if (hasMenu) {
            mPressOnMenuBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_ACTION, KEY_ACTION_MENU, UserHandle.USER_CURRENT);
            mLongPressOnMenuBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_LONG_PRESS_ACTION, hasAssist ? KEY_ACTION_NOTHING : KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
        }
        if (hasBack) {
            mPressOnBackBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_ACTION, KEY_ACTION_BACK, UserHandle.USER_CURRENT);
            mLongPressOnBackBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_LONG_PRESS_ACTION, KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
        }
        if (hasAssist) {
            mPressOnAssistBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_ACTION, KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
            mLongPressOnAssistBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_LONG_PRESS_ACTION, KEY_ACTION_VOICE_SEARCH, UserHandle.USER_CURRENT);
        }
        if (hasAppSwitch) {
            mPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_ACTION, KEY_ACTION_APP_SWITCH, UserHandle.USER_CURRENT);
            mLongPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
        }
    }
    if (DEBUG_INPUT) {
        Slog.d(TAG, "home = " + mPressOnHomeBehavior + " home long = " + mLongPressOnHomeBehavior + " home double = " + mDoubleTapOnHomeBehavior);
        Slog.d(TAG, "menu = " + mPressOnMenuBehavior + " menu long = " + mLongPressOnMenuBehavior);
        Slog.d(TAG, "back = " + mPressOnBackBehavior + " back long = " + mLongPressOnBackBehavior);
        Slog.d(TAG, "assist = " + mPressOnAssistBehavior + " assist long = " + mLongPressOnAssistBehavior);
        Slog.d(TAG, "appSwitch = " + mPressOnAppSwitchBehavior + " back long = " + mLongPressOnAppSwitchBehavior);
    }
}
#method_after
private void updateKeyAssignments() {
    final boolean hasMenu = (mDeviceHardwareKeys & KEY_MASK_MENU) != 0;
    final boolean hasBack = (mDeviceHardwareKeys & KEY_MASK_BACK) != 0;
    final boolean hasHome = (mDeviceHardwareKeys & KEY_MASK_HOME) != 0;
    final boolean hasAssist = (mDeviceHardwareKeys & KEY_MASK_ASSIST) != 0;
    final boolean hasAppSwitch = (mDeviceHardwareKeys & KEY_MASK_APP_SWITCH) != 0;
    final ContentResolver resolver = mContext.getContentResolver();
    mSoftBackKillApp = Settings.System.getIntForUser(resolver, Settings.System.SOFT_BACK_KILL_APP_ENABLE, 0, UserHandle.USER_CURRENT) == 1;
    // initialize all assignments to sane defaults
    mPressOnHomeBehavior = KEY_ACTION_HOME;
    mPressOnMenuBehavior = KEY_ACTION_MENU;
    if (!hasMenu || hasAssist) {
        mLongPressOnMenuBehavior = KEY_ACTION_NOTHING;
    } else {
        mLongPressOnMenuBehavior = KEY_ACTION_SEARCH;
    }
    mPressOnAssistBehavior = KEY_ACTION_SEARCH;
    mLongPressOnAssistBehavior = KEY_ACTION_VOICE_SEARCH;
    mPressOnAppSwitchBehavior = KEY_ACTION_APP_SWITCH;
    mLongPressOnAppSwitchBehavior = KEY_ACTION_NOTHING;
    mPressOnBackBehavior = KEY_ACTION_BACK;
    // sof key back kill app will overrule this default
    if (mSoftBackKillApp) {
        mLongPressOnBackBehavior = KEY_ACTION_KILL_APP;
    } else {
        mLongPressOnBackBehavior = KEY_ACTION_NOTHING;
    }
    mLongPressOnHomeBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_longPressOnHomeBehavior);
    if (mLongPressOnHomeBehavior == 1) {
        mLongPressOnHomeBehavior = KEY_ACTION_APP_SWITCH;
    } else if (mLongPressOnHomeBehavior == 2) {
        mLongPressOnHomeBehavior = KEY_ACTION_SEARCH;
    } else {
        mLongPressOnHomeBehavior = KEY_ACTION_NOTHING;
    }
    mDoubleTapOnHomeBehavior = mContext.getResources().getInteger(com.android.internal.R.integer.config_doubleTapOnHomeBehavior);
    if (mDoubleTapOnHomeBehavior == 1) {
        mDoubleTapOnHomeBehavior = KEY_ACTION_APP_SWITCH;
    } else {
        mDoubleTapOnHomeBehavior = KEY_ACTION_NOTHING;
    }
    boolean keyRebindingEnabled = Settings.System.getIntForUser(resolver, Settings.System.HARDWARE_KEY_REBINDING, 0, UserHandle.USER_CURRENT) == 1;
    if (keyRebindingEnabled) {
        if (hasHome) {
            mPressOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_ACTION, KEY_ACTION_HOME, UserHandle.USER_CURRENT);
            mLongPressOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_LONG_PRESS_ACTION, hasAppSwitch ? KEY_ACTION_NOTHING : mLongPressOnHomeBehavior, UserHandle.USER_CURRENT);
            mDoubleTapOnHomeBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_HOME_DOUBLE_TAP_ACTION, mDoubleTapOnHomeBehavior, UserHandle.USER_CURRENT);
        }
        if (hasMenu) {
            mPressOnMenuBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_ACTION, KEY_ACTION_MENU, UserHandle.USER_CURRENT);
            mLongPressOnMenuBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_MENU_LONG_PRESS_ACTION, hasAssist ? KEY_ACTION_NOTHING : KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
        }
        if (hasBack) {
            mPressOnBackBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_ACTION, KEY_ACTION_BACK, UserHandle.USER_CURRENT);
            mLongPressOnBackBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_BACK_LONG_PRESS_ACTION, KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
        }
        if (hasAssist) {
            mPressOnAssistBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_ACTION, KEY_ACTION_SEARCH, UserHandle.USER_CURRENT);
            mLongPressOnAssistBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_ASSIST_LONG_PRESS_ACTION, KEY_ACTION_VOICE_SEARCH, UserHandle.USER_CURRENT);
        }
        if (hasAppSwitch) {
            mPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_ACTION, KEY_ACTION_APP_SWITCH, UserHandle.USER_CURRENT);
            mLongPressOnAppSwitchBehavior = Settings.System.getIntForUser(resolver, Settings.System.KEY_APP_SWITCH_LONG_PRESS_ACTION, KEY_ACTION_NOTHING, UserHandle.USER_CURRENT);
        }
    }
    if (DEBUG_INPUT) {
        Slog.d(TAG, "home = " + mPressOnHomeBehavior + " home long = " + mLongPressOnHomeBehavior + " home double = " + mDoubleTapOnHomeBehavior);
        Slog.d(TAG, "menu = " + mPressOnMenuBehavior + " menu long = " + mLongPressOnMenuBehavior);
        Slog.d(TAG, "back = " + mPressOnBackBehavior + " back long = " + mLongPressOnBackBehavior);
        Slog.d(TAG, "assist = " + mPressOnAssistBehavior + " assist long = " + mLongPressOnAssistBehavior);
        Slog.d(TAG, "appSwitch = " + mPressOnAppSwitchBehavior + " back long = " + mLongPressOnAppSwitchBehavior);
    }
}
#end_block

#method_before
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENRECORD_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mVolumeUpKeyConsumedByScreenrecordChord) {
            if (!down) {
                mVolumeUpKeyConsumedByScreenrecordChord = false;
            }
            return -1;
        }
    }
    // stop the kill action
    if (mBackKillPending && !down) {
        mHandler.removeCallbacks(mKillTask);
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            if (mRecentAppsPreloaded) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // and his ONLY options are to answer or reject the call.)
            try {
                ITelephony telephonyService = getTelephonyService();
                if (telephonyService != null && telephonyService.isRinging()) {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            } catch (RemoteException ex) {
                Log.w(TAG, "RemoteException from getPhoneInterface()", ex);
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (mPressOnHomeBehavior != KEY_ACTION_HOME) {
                performKeyAction(mPressOnHomeBehavior);
            } else {
                launchHomeFromHotKey();
            }
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD || type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            if (down) {
                mHomePressed = true;
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeConsumed = true;
                performKeyAction(mDoubleTapOnHomeBehavior);
            } else if (!mRecentAppsPreloaded && (mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehavior == KEY_ACTION_APP_SWITCH || mPressOnHomeBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
                preloadRecentApps();
            }
            if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                mHomeConsumed = true;
                performKeyAction(mLongPressOnHomeBehavior);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcast(intent, null);
                    return -1;
                } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                    Intent service = new Intent();
                    service.setClassName(mContext, "com.android.server.LoadAverageService");
                    ContentResolver res = mContext.getContentResolver();
                    boolean shown = Settings.System.getInt(res, Settings.System.SHOW_PROCESSES, 0) != 0;
                    if (!shown) {
                        mContext.startService(service);
                    } else {
                        mContext.stopService(service);
                    }
                    Settings.System.putInt(res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
                    return -1;
                } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !virtualKey) {
                    mMenuDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnMenuBehavior);
                    // Do not perform action when key is released
                    mMenuDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mMenuDoCustomAction) {
                mMenuDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnMenuBehavior);
                    return -1;
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAppSwitchBehavior);
                    mAppSwitchLongPressed = true;
                }
            }
        } else {
            if (mAppSwitchLongPressed) {
                mAppSwitchLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAssistBehavior);
                    mAssistKeyLongPressed = true;
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAssistBehavior);
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            Intent intent = new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG);
            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnBackBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    mBackDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnBackBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnBackBehavior);
                    // Do not perform action when key is released
                    mBackDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnBackBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnBackBehavior);
                    return -1;
                }
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB or Meta-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsDialogHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON) || KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_META_ON)) {
                mRecentAppsDialogHeldModifiers = shiftlessModifiers;
                showOrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW);
                return -1;
            }
        }
    } else if (!down && mRecentAppsDialogHeldModifiers != 0 && (metaState & mRecentAppsDialogHeldModifiers) == 0) {
        mRecentAppsDialogHeldModifiers = 0;
        showOrHideRecentAppsDialog(keyguardOn ? RECENT_APPS_BEHAVIOR_DISMISS : RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#method_after
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
    final boolean keyguardOn = keyguardOn();
    final int keyCode = event.getKeyCode();
    final int repeatCount = event.getRepeatCount();
    final int metaState = event.getMetaState();
    final int flags = event.getFlags();
    final boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
    final boolean canceled = event.isCanceled();
    final boolean longPress = (flags & KeyEvent.FLAG_LONG_PRESS) != 0;
    final boolean virtualKey = event.getDeviceId() == KeyCharacterMap.VIRTUAL_KEYBOARD;
    if (DEBUG_INPUT) {
        Slog.d(TAG, "interceptKeyTi keyCode=" + keyCode + " down=" + down + " repeatCount=" + repeatCount + " keyguardOn=" + keyguardOn + " mHomePressed=" + mHomePressed + " canceled=" + canceled + " virtualKey=" + virtualKey);
    }
    // try again later before dispatching.
    if (mScreenshotChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeDownKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeDownKeyTime + SCREENSHOT_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN && mVolumeDownKeyConsumedByScreenshotChord) {
            if (!down) {
                mVolumeDownKeyConsumedByScreenshotChord = false;
            }
            return -1;
        }
    }
    // try again later before dispatching.
    if (mScreenrecordChordEnabled && (flags & KeyEvent.FLAG_FALLBACK) == 0) {
        if (mVolumeUpKeyTriggered && !mPowerKeyTriggered) {
            final long now = SystemClock.uptimeMillis();
            final long timeoutTime = mVolumeUpKeyTime + SCREENRECORD_CHORD_DEBOUNCE_DELAY_MILLIS;
            if (now < timeoutTime) {
                return timeoutTime - now;
            }
        }
        if (keyCode == KeyEvent.KEYCODE_VOLUME_UP && mVolumeUpKeyConsumedByScreenrecordChord) {
            if (!down) {
                mVolumeUpKeyConsumedByScreenrecordChord = false;
            }
            return -1;
        }
    }
    // stop the kill action
    if (mBackKillPending && !down) {
        mHandler.removeCallbacks(mKillTask);
        mBackKillPending = false;
    }
    // timeout.
    if (keyCode == KeyEvent.KEYCODE_HOME) {
        // while it was pressed, then it is time to go home!
        if (!down && mHomePressed) {
            if (mRecentAppsPreloaded) {
                cancelPreloadRecentApps();
            }
            mHomePressed = false;
            if (mHomeConsumed) {
                mHomeConsumed = false;
                return -1;
            }
            if (canceled) {
                Log.i(TAG, "Ignoring HOME; event canceled.");
                return -1;
            }
            // and his ONLY options are to answer or reject the call.)
            try {
                ITelephony telephonyService = getTelephonyService();
                if (telephonyService != null && telephonyService.isRinging()) {
                    Log.i(TAG, "Ignoring HOME; there's a ringing incoming call.");
                    return -1;
                }
            } catch (RemoteException ex) {
                Log.w(TAG, "RemoteException from getPhoneInterface()", ex);
            }
            // Delay handling home if a double-tap is possible.
            if (mDoubleTapOnHomeBehavior != KEY_ACTION_NOTHING) {
                // just in case
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeDoubleTapPending = true;
                mHandler.postDelayed(mHomeDoubleTapTimeoutRunnable, ViewConfiguration.getDoubleTapTimeout());
                return -1;
            }
            if (mPressOnHomeBehavior != KEY_ACTION_HOME) {
                performKeyAction(mPressOnHomeBehavior);
            } else {
                launchHomeFromHotKey();
            }
            return -1;
        }
        // If a system window has focus, then it doesn't make sense
        // right now to interact with applications.
        WindowManager.LayoutParams attrs = win != null ? win.getAttrs() : null;
        if (attrs != null) {
            final int type = attrs.type;
            if (type == WindowManager.LayoutParams.TYPE_KEYGUARD || type == WindowManager.LayoutParams.TYPE_KEYGUARD_SCRIM || type == WindowManager.LayoutParams.TYPE_KEYGUARD_DIALOG) {
                // the "app" is keyguard, so give it the key
                return 0;
            }
            final int typeCount = WINDOW_TYPES_WHERE_HOME_DOESNT_WORK.length;
            for (int i = 0; i < typeCount; i++) {
                if (type == WINDOW_TYPES_WHERE_HOME_DOESNT_WORK[i]) {
                    // don't do anything, but also don't pass it to the app
                    return -1;
                }
            }
        }
        // Remember that home is pressed and handle special actions.
        if (repeatCount == 0) {
            if (down) {
                mHomePressed = true;
            }
            if (mHomeDoubleTapPending) {
                mHomeDoubleTapPending = false;
                mHandler.removeCallbacks(mHomeDoubleTapTimeoutRunnable);
                mHomeConsumed = true;
                performKeyAction(mDoubleTapOnHomeBehavior);
            } else if (!mRecentAppsPreloaded && (mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH || mDoubleTapOnHomeBehavior == KEY_ACTION_APP_SWITCH || mPressOnHomeBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
        } else if (longPress) {
            if (!mRecentAppsPreloaded && mLongPressOnHomeBehavior == KEY_ACTION_APP_SWITCH) {
                preloadRecentApps();
            }
            if (!keyguardOn && mLongPressOnHomeBehavior != KEY_ACTION_NOTHING) {
                performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                mHomeConsumed = true;
                performKeyAction(mLongPressOnHomeBehavior);
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_MENU) {
        // Hijack modified menu keys for debugging features
        final int chordBug = KeyEvent.META_SHIFT_ON;
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnMenuBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnMenuBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mEnableShiftMenuBugReports && (metaState & chordBug) == chordBug) {
                    Intent intent = new Intent(Intent.ACTION_BUG_REPORT);
                    mContext.sendOrderedBroadcast(intent, null);
                    return -1;
                } else if (SHOW_PROCESSES_ON_ALT_MENU && (metaState & KeyEvent.META_ALT_ON) == KeyEvent.META_ALT_ON) {
                    Intent service = new Intent();
                    service.setClassName(mContext, "com.android.server.LoadAverageService");
                    ContentResolver res = mContext.getContentResolver();
                    boolean shown = Settings.System.getInt(res, Settings.System.SHOW_PROCESSES, 0) != 0;
                    if (!shown) {
                        mContext.startService(service);
                    } else {
                        mContext.stopService(service);
                    }
                    Settings.System.putInt(res, Settings.System.SHOW_PROCESSES, shown ? 0 : 1);
                    return -1;
                } else if (mPressOnMenuBehavior != KEY_ACTION_MENU && !virtualKey) {
                    mMenuDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnMenuBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnMenuBehavior);
                    // Do not perform action when key is released
                    mMenuDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnMenuBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnMenuBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mMenuDoCustomAction) {
                mMenuDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnMenuBehavior);
                    return -1;
                }
            }
        }
    } else if (keyCode == KeyEvent.KEYCODE_SEARCH) {
        if (down) {
            if (repeatCount == 0) {
                mSearchKeyShortcutPending = true;
                mConsumeSearchKeyUp = false;
            }
        } else {
            mSearchKeyShortcutPending = false;
            if (mConsumeSearchKeyUp) {
                mConsumeSearchKeyUp = false;
                return -1;
            }
        }
        return 0;
    } else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAppSwitchBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAppSwitchLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAppSwitchBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAppSwitchBehavior);
                    mAppSwitchLongPressed = true;
                }
            }
        } else {
            if (mAppSwitchLongPressed) {
                mAppSwitchLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAppSwitchBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAppSwitchBehavior);
                }
                return -1;
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_ASSIST) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnAssistBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnAssistBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                mAssistKeyLongPressed = false;
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnAssistBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnAssistBehavior);
                    mAssistKeyLongPressed = true;
                }
            }
        } else {
            if (mAssistKeyLongPressed) {
                mAssistKeyLongPressed = false;
            } else {
                if (mRecentAppsPreloaded && mPressOnAssistBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnAssistBehavior);
                }
            }
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_SYSRQ) {
        if (down && repeatCount == 0) {
            mHandler.post(mScreenshotRunnable);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP || keyCode == KeyEvent.KEYCODE_BRIGHTNESS_DOWN) {
        if (down) {
            int direction = keyCode == KeyEvent.KEYCODE_BRIGHTNESS_UP ? 1 : -1;
            // Disable autobrightness if it's on
            int auto = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            if (auto != 0) {
                Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, Settings.System.SCREEN_BRIGHTNESS_MODE_MANUAL, UserHandle.USER_CURRENT_OR_SELF);
            }
            int min = mPowerManager.getMinimumScreenBrightnessSetting();
            int max = mPowerManager.getMaximumScreenBrightnessSetting();
            int step = (max - min + BRIGHTNESS_STEPS - 1) / BRIGHTNESS_STEPS * direction;
            int brightness = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, mPowerManager.getDefaultScreenBrightnessSetting(), UserHandle.USER_CURRENT_OR_SELF);
            brightness += step;
            // Make sure we don't go beyond the limits.
            brightness = Math.min(max, brightness);
            brightness = Math.max(min, brightness);
            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS, brightness, UserHandle.USER_CURRENT_OR_SELF);
            Intent intent = new Intent(Intent.ACTION_SHOW_BRIGHTNESS_DIALOG);
            mContext.sendBroadcastAsUser(intent, UserHandle.CURRENT_OR_SELF);
        }
        return -1;
    } else if (keyCode == KeyEvent.KEYCODE_BACK) {
        if (down) {
            if (!mRecentAppsPreloaded && (mPressOnBackBehavior == KEY_ACTION_APP_SWITCH || mLongPressOnBackBehavior == KEY_ACTION_APP_SWITCH)) {
                preloadRecentApps();
            }
            if (repeatCount == 0) {
                if (mPressOnBackBehavior != KEY_ACTION_BACK && !virtualKey) {
                    mBackDoCustomAction = true;
                    return -1;
                }
            } else if (longPress) {
                if (mRecentAppsPreloaded && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                    cancelPreloadRecentApps();
                }
                if (!keyguardOn && mLongPressOnBackBehavior != KEY_ACTION_NOTHING) {
                    performHapticFeedbackLw(null, HapticFeedbackConstants.LONG_PRESS, false);
                    performKeyAction(mLongPressOnBackBehavior);
                    // Do not perform action when key is released
                    mBackDoCustomAction = false;
                    return -1;
                }
            }
        } else {
            if (mRecentAppsPreloaded && mPressOnBackBehavior != KEY_ACTION_APP_SWITCH && mLongPressOnBackBehavior != KEY_ACTION_APP_SWITCH) {
                cancelPreloadRecentApps();
            }
            if (mBackDoCustomAction) {
                mBackDoCustomAction = false;
                if (!canceled && !keyguardOn) {
                    performKeyAction(mPressOnBackBehavior);
                    return -1;
                }
            }
        }
    }
    // shortcut keys (that emit Search+x) and some of them are not registered.
    if (mSearchKeyShortcutPending) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            mConsumeSearchKeyUp = true;
            mSearchKeyShortcutPending = false;
            if (down && repeatCount == 0 && !keyguardOn) {
                Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState);
                if (shortcutIntent != null) {
                    shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                    try {
                        mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                    } catch (ActivityNotFoundException ex) {
                        Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode), ex);
                    }
                } else {
                    Slog.i(TAG, "Dropping unregistered shortcut key combination: " + "SEARCH+" + KeyEvent.keyCodeToString(keyCode));
                }
            }
            return -1;
        }
    }
    // Invoke shortcuts using Meta.
    if (down && repeatCount == 0 && !keyguardOn && (metaState & KeyEvent.META_META_ON) != 0) {
        final KeyCharacterMap kcm = event.getKeyCharacterMap();
        if (kcm.isPrintingKey(keyCode)) {
            Intent shortcutIntent = mShortcutManager.getIntent(kcm, keyCode, metaState & ~(KeyEvent.META_META_ON | KeyEvent.META_META_LEFT_ON | KeyEvent.META_META_RIGHT_ON));
            if (shortcutIntent != null) {
                shortcutIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                try {
                    mContext.startActivityAsUser(shortcutIntent, UserHandle.CURRENT);
                } catch (ActivityNotFoundException ex) {
                    Slog.w(TAG, "Dropping shortcut key combination because " + "the activity to which it is registered was not found: " + "META+" + KeyEvent.keyCodeToString(keyCode), ex);
                }
                return -1;
            }
        }
    }
    // Handle application launch keys.
    if (down && repeatCount == 0 && !keyguardOn) {
        String category = sApplicationLaunchKeyCategories.get(keyCode);
        if (category != null) {
            Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN, category);
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            try {
                mContext.startActivityAsUser(intent, UserHandle.CURRENT);
            } catch (ActivityNotFoundException ex) {
                Slog.w(TAG, "Dropping application launch key because " + "the activity to which it is registered was not found: " + "keyCode=" + keyCode + ", category=" + category, ex);
            }
            return -1;
        }
    }
    // Display task switcher for ALT-TAB or Meta-TAB.
    if (down && repeatCount == 0 && keyCode == KeyEvent.KEYCODE_TAB) {
        if (mRecentAppsDialogHeldModifiers == 0 && !keyguardOn) {
            final int shiftlessModifiers = event.getModifiers() & ~KeyEvent.META_SHIFT_MASK;
            if (KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_ALT_ON) || KeyEvent.metaStateHasModifiers(shiftlessModifiers, KeyEvent.META_META_ON)) {
                mRecentAppsDialogHeldModifiers = shiftlessModifiers;
                showOrHideRecentAppsDialog(RECENT_APPS_BEHAVIOR_EXIT_TOUCH_MODE_AND_SHOW);
                return -1;
            }
        }
    } else if (!down && mRecentAppsDialogHeldModifiers != 0 && (metaState & mRecentAppsDialogHeldModifiers) == 0) {
        mRecentAppsDialogHeldModifiers = 0;
        showOrHideRecentAppsDialog(keyguardOn ? RECENT_APPS_BEHAVIOR_DISMISS : RECENT_APPS_BEHAVIOR_DISMISS_AND_SWITCH);
    }
    // Handle keyboard language switching.
    if (down && repeatCount == 0 && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || (keyCode == KeyEvent.KEYCODE_SPACE && (metaState & KeyEvent.META_CTRL_MASK) != 0))) {
        int direction = (metaState & KeyEvent.META_SHIFT_MASK) != 0 ? -1 : 1;
        mWindowManagerFuncs.switchKeyboardLayout(event.getDeviceId(), direction);
        return -1;
    }
    if (mLanguageSwitchKeyPressed && !down && (keyCode == KeyEvent.KEYCODE_LANGUAGE_SWITCH || keyCode == KeyEvent.KEYCODE_SPACE)) {
        mLanguageSwitchKeyPressed = false;
        return -1;
    }
    if (mGlobalKeyManager.handleGlobalKey(mContext, keyCode, event)) {
        return -1;
    }
    // Let the application handle the key.
    return 0;
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.bars_settings);
    PreferenceScreen prefSet = getPreferenceScreen();
    ContentResolver resolver = getActivity().getContentResolver();
    mStatusBarBrightnessControl = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_BRIGHTNESS_CONTROL);
    mStatusBarBrightnessControl.setChecked((Settings.System.getInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0) == 1));
    mStatusBarBrightnessControl.setOnPreferenceChangeListener(this);
    try {
        if (Settings.System.getInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {
            mStatusBarBrightnessControl.setEnabled(false);
            mStatusBarBrightnessControl.setSummary(R.string.status_bar_toggle_info);
        }
    } catch (SettingNotFoundException e) {
    }
    mStatusBarNotifCount = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_NOTIF_COUNT);
    mStatusBarNotifCount.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, 0) == 1);
    mStatusBarNotifCount.setOnPreferenceChangeListener(this);
    mStatusBarTraffic = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_TRAFFIC);
    mStatusBarTraffic.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_TRAFFIC, 0) == 1);
    mStatusBarTraffic.setOnPreferenceChangeListener(this);
    mStatusBarNetworkActivity = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_NETWORK_ACTIVITY);
    mStatusBarNetworkActivity.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_NETWORK_ACTIVITY, 0) == 1);
    mStatusBarNetworkActivity.setOnPreferenceChangeListener(this);
    mQuickPulldown = (ListPreference) findPreference(QUICK_PULLDOWN);
    mQuickPulldown.setOnPreferenceChangeListener(this);
    int statusQuickPulldown = Settings.System.getInt(getContentResolver(), Settings.System.QS_QUICK_PULLDOWN, 0);
    mQuickPulldown.setValue(String.valueOf(statusQuickPulldown));
    mQuickSettingsDynamic = (CheckBoxPreference) prefSet.findPreference(QUICKSETTINGS_DYNAMIC);
    mQuickSettingsDynamic.setChecked(Settings.System.getInt(resolver, Settings.System.QUICK_SETTINGS_TILES_ROW, 1) != 0);
    mQuickSettingsDynamic.setOnPreferenceChangeListener(this);
    boolean hasNavBar = getResources().getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Also check, if users without navigation bar force enabled it.
    hasNavBar = hasNavBar || (SystemProperties.getInt("qemu.hw.mainkeys", 1) == 0);
    // Hide navigation bar category on devices without navigation bar
    if (!hasNavBar) {
        prefSet.removePreference(findPreference(CATEGORY_NAVBAR));
    }
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.bars_settings);
    PreferenceScreen prefSet = getPreferenceScreen();
    ContentResolver resolver = getActivity().getContentResolver();
    mStatusBarBrightnessControl = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_BRIGHTNESS_CONTROL);
    mStatusBarBrightnessControl.setChecked((Settings.System.getInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0) == 1));
    mStatusBarBrightnessControl.setOnPreferenceChangeListener(this);
    try {
        if (Settings.System.getInt(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {
            mStatusBarBrightnessControl.setEnabled(false);
            mStatusBarBrightnessControl.setSummary(R.string.status_bar_toggle_info);
        }
    } catch (SettingNotFoundException e) {
    }
    mStatusBarNotifCount = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_NOTIF_COUNT);
    mStatusBarNotifCount.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, 0) == 1);
    mStatusBarNotifCount.setOnPreferenceChangeListener(this);
    mStatusBarTraffic = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_TRAFFIC);
    int intState = Settings.System.getInt(resolver, Settings.System.STATUS_BAR_TRAFFIC, 0);
    intState = setStatusBarTrafficSummary(intState);
    mStatusBarTraffic.setChecked(intState > 0);
    mStatusBarTraffic.setOnPreferenceChangeListener(this);
    mStatusBarNetworkActivity = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_NETWORK_ACTIVITY);
    mStatusBarNetworkActivity.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_NETWORK_ACTIVITY, 0) == 1);
    mStatusBarNetworkActivity.setOnPreferenceChangeListener(this);
    mQuickPulldown = (ListPreference) findPreference(QUICK_PULLDOWN);
    mQuickPulldown.setOnPreferenceChangeListener(this);
    int statusQuickPulldown = Settings.System.getInt(resolver, Settings.System.QS_QUICK_PULLDOWN, 0);
    mQuickPulldown.setValue(String.valueOf(statusQuickPulldown));
    mQuickSettingsDynamic = (CheckBoxPreference) prefSet.findPreference(QUICKSETTINGS_DYNAMIC);
    mQuickSettingsDynamic.setChecked(Settings.System.getInt(resolver, Settings.System.QUICK_SETTINGS_TILES_ROW, 1) != 0);
    mQuickSettingsDynamic.setOnPreferenceChangeListener(this);
    boolean hasNavBar = getResources().getBoolean(com.android.internal.R.bool.config_showNavigationBar);
    // Also check, if users without navigation bar force enabled it.
    hasNavBar = hasNavBar || (SystemProperties.getInt("qemu.hw.mainkeys", 1) == 0);
    // Hide navigation bar category on devices without navigation bar
    if (!hasNavBar) {
        prefSet.removePreference(findPreference(CATEGORY_NAVBAR));
    }
}
#end_block

#method_before
public boolean onPreferenceChange(Preference preference, Object objValue) {
    ContentResolver resolver = getActivity().getContentResolver();
    if (preference == mStatusBarBrightnessControl) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, value ? 1 : 0);
    } else if (preference == mStatusBarNotifCount) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, value ? 1 : 0);
    } else if (preference == mStatusBarTraffic) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_TRAFFIC, value ? 1 : 0);
    } else if (preference == mStatusBarNetworkActivity) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_NETWORK_ACTIVITY, value ? 1 : 0);
    } else if (preference == mQuickSettingsDynamic) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.QUICK_SETTINGS_TILES_ROW, value ? 1 : 0);
    } else if (preference == mQuickPulldown) {
        int statusQuickPulldown = Integer.valueOf((String) objValue);
        Settings.System.putInt(resolver, Settings.System.QS_QUICK_PULLDOWN, statusQuickPulldown);
    } else {
        return false;
    }
    return true;
}
#method_after
@Override
public boolean onPreferenceChange(Preference preference, Object objValue) {
    ContentResolver resolver = getActivity().getContentResolver();
    if (preference == mStatusBarBrightnessControl) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, value ? 1 : 0);
    } else if (preference == mStatusBarNotifCount) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, value ? 1 : 0);
    } else if (preference == mStatusBarTraffic) {
        // Increment the state and then update the label
        int intState = Settings.System.getInt(resolver, Settings.System.STATUS_BAR_TRAFFIC, 0);
        intState++;
        intState = setStatusBarTrafficSummary(intState);
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_TRAFFIC, intState);
        if (intState > 1) {
            return false;
        }
    } else if (preference == mStatusBarNetworkActivity) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_NETWORK_ACTIVITY, value ? 1 : 0);
    } else if (preference == mQuickSettingsDynamic) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.QUICK_SETTINGS_TILES_ROW, value ? 1 : 0);
    } else if (preference == mQuickPulldown) {
        int statusQuickPulldown = Integer.valueOf((String) objValue);
        Settings.System.putInt(resolver, Settings.System.QS_QUICK_PULLDOWN, statusQuickPulldown);
    } else {
        return false;
    }
    return true;
}
#end_block

#method_before
void updateResources() {
    refreshSettingsTile();
    refreshBatteryTile();
    refreshBluetoothTile();
    refreshBrightnessTile();
    refreshImmersiveTile();
    refreshQuiteHourTile();
    refreshRotationLockTile();
    refreshRssiTile();
    refreshLocationTile();
}
#method_after
void updateResources() {
    refreshSettingsTile();
    refreshBatteryTile();
    refreshBluetoothTile();
    refreshBrightnessTile();
    refreshImmersiveTile();
    refreshQuiteHourTile();
    refreshRotationLockTile();
    refreshRssiTile();
    refreshLocationTile();
    updateSleepState();
    refreshBackLocationTile();
}
#end_block

#method_before
@Override
public void onLocationSettingsChanged(boolean locationEnabled) {
    int textResId = locationEnabled ? R.string.quick_settings_location_label : R.string.quick_settings_location_off_label;
    String label = mContext.getText(textResId).toString();
    int locationIconId = locationEnabled ? R.drawable.ic_qs_location_on : R.drawable.ic_qs_location_off;
    mLocationState.enabled = locationEnabled;
    mLocationState.label = label;
    mLocationState.iconId = locationIconId;
    mLocationCallback.refreshView(mLocationTile, mLocationState);
}
#method_after
@Override
public void onLocationSettingsChanged(boolean locationEnabled) {
    int textResId = locationEnabled ? R.string.quick_settings_location_label : R.string.quick_settings_location_off_label;
    String label = mContext.getText(textResId).toString();
    int locationIconId = locationEnabled ? R.drawable.ic_qs_location_on : R.drawable.ic_qs_location_off;
    mLocationState.enabled = locationEnabled;
    mLocationState.label = label;
    mLocationState.iconId = locationIconId;
    mLocationCallback.refreshView(mLocationTile, mLocationState);
    refreshBackLocationTile();
}
#end_block

#method_before
private void addTiles(ViewGroup parent, LayoutInflater inflater, boolean addMissing, boolean reset) {
    // If all the tiles were deleted, they are still loaded, but their visibility is changed
    if (reset) {
        parent.removeAllViews();
    }
    String tileContainer = Settings.System.getString(mContext.getContentResolver(), Settings.System.QUICK_SETTINGS_TILES);
    if (tileContainer == null)
        tileContainer = DEFAULT_TILES;
    Tile[] allTiles = Tile.values();
    String[] storedTiles = tileContainer.split(DELIMITER);
    List<String> allTilesArray = enumToStringArray(allTiles);
    List<String> storedTilesArray = Arrays.asList(storedTiles);
    for (String tile : addMissing ? allTilesArray : storedTilesArray) {
        boolean addTile = storedTilesArray.contains(tile);
        if (addMissing)
            addTile = !addTile;
        if (addTile) {
            if (Tile.USER.toString().equals(tile.toString())) {
                // User
                QuickSettingsTileView userTile = (QuickSettingsTileView) inflater.inflate(R.layout.quick_settings_tile, parent, false);
                userTile.setContent(R.layout.quick_settings_tile_user, inflater);
                userTile.setTileId(Tile.USER);
                userTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        final UserManager um = UserManager.get(mContext);
                        if (um.getUsers(true).size() > 1) {
                            // Since keyguard and systemui were merged into the same process to save
                            // memory, they share the same Looper and graphics context.  As a result,
                            // there's no way to allow concurrent animation while keyguard inflates.
                            // The workaround is to add a slight delay to allow the animation to finish.
                            mHandler.postDelayed(new Runnable() {

                                public void run() {
                                    try {
                                        WindowManagerGlobal.getWindowManagerService().lockNow(null);
                                    } catch (RemoteException e) {
                                        Log.e(TAG, "Couldn't show user switcher", e);
                                    }
                                }
                            }, // TODO: ideally this would be tied to the collapse of the panel
                            400);
                        } else {
                            Intent intent = ContactsContract.QuickContact.composeQuickContactsIntent(mContext, v, ContactsContract.Profile.CONTENT_URI, ContactsContract.QuickContact.MODE_LARGE, null);
                            mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
                        }
                    }
                });
                userTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SYNC_SETTINGS);
                        return true;
                    }
                });
                mModel.addUserTile(userTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        UserState us = (UserState) state;
                        ImageView iv = (ImageView) view.findViewById(R.id.user_imageview);
                        TextView tv = (TextView) view.findViewById(R.id.user_textview);
                        tv.setText(state.label);
                        iv.setImageDrawable(us.avatar);
                        view.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_user, state.label));
                    }
                });
                parent.addView(userTile);
                if (addMissing)
                    userTile.setVisibility(View.GONE);
            } else if (Tile.BRIGHTNESS.toString().equals(tile.toString())) {
                // brightness
                // Brightness
                final QuickSettingsBasicTile brightnessTile = new QuickSettingsBasicTile(mContext);
                brightnessTile.setTileId(Tile.BRIGHTNESS);
                brightnessTile.setImageResource(R.drawable.ic_qs_brightness_auto_off);
                brightnessTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        showBrightnessDialog();
                    }
                });
                brightnessTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        boolean automaticAvailable = mContext.getResources().getBoolean(com.android.internal.R.bool.config_automatic_brightness_available);
                        // If we have automatic brightness available, toggle it
                        if (automaticAvailable) {
                            int automatic;
                            try {
                                automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, UserHandle.USER_CURRENT);
                            } catch (SettingNotFoundException snfe) {
                                automatic = 0;
                            }
                            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, automatic != 0 ? 0 : 1, UserHandle.USER_CURRENT);
                        }
                        return true;
                    }
                });
                mModel.addBrightnessTile(brightnessTile, new QuickSettingsModel.BasicRefreshCallback(brightnessTile));
                parent.addView(brightnessTile);
                if (addMissing)
                    brightnessTile.setVisibility(View.GONE);
            } else if (Tile.SETTINGS.toString().equals(tile.toString())) {
                // Settings tile
                // Settings tile
                final QuickSettingsBasicTile settingsTile = new QuickSettingsBasicTile(mContext);
                settingsTile.setTileId(Tile.SETTINGS);
                settingsTile.setImageResource(R.drawable.ic_qs_settings);
                settingsTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SETTINGS);
                    }
                });
                mModel.addSettingsTile(settingsTile, new QuickSettingsModel.BasicRefreshCallback(settingsTile));
                parent.addView(settingsTile);
                if (addMissing)
                    settingsTile.setVisibility(View.GONE);
            } else if (Tile.WIFI.toString().equals(tile.toString())) {
                // wifi tile
                // Wi-fi
                final QuickSettingsFlipTile wifiTile = new QuickSettingsFlipTile(mContext);
                wifiTile.setTileId(Tile.WIFI);
                wifiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
                        return true;
                    }
                });
                wifiTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        final boolean enable = (mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
                        new AsyncTask<Void, Void, Void>() {

                            @Override
                            protected Void doInBackground(Void... args) {
                                // Disable tethering if enabling Wifi
                                final int wifiApState = mWifiManager.getWifiApState();
                                if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
                                    mWifiManager.setWifiApEnabled(null, false);
                                }
                                mWifiManager.setWifiEnabled(enable);
                                return null;
                            }
                        }.execute();
                        wifiTile.setFrontLoading(true);
                        wifiTile.setFrontPressed(false);
                    }
                });
                mModel.addWifiTile(wifiTile.getFront(), new NetworkActivityCallback() {

                    private String mPreviousLabel = "";

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setFrontImageResource(wifiState.iconId);
                        wifiTile.setFrontText(wifiState.label);
                        wifiTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi, wifiState.signalContentDescription, (wifiState.connected) ? wifiState.label : ""));
                        if (wifiState.label != null && !mPreviousLabel.equals(wifiState.label)) {
                            wifiTile.setFrontLoading(false);
                            mPreviousLabel = wifiState.label;
                        }
                    }
                });
                final ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                wifiTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                    }
                });
                mModel.addWifiBackTile(wifiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setBackImageResource(wifiState.iconId);
                        wifiTile.setBackLabel(wifiState.label);
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_label));
                        } else {
                            wifiTile.setBackFunction("");
                        }
                    }
                });
                parent.addView(wifiTile);
                if (addMissing)
                    wifiTile.setVisibility(View.GONE);
            } else if (Tile.RSSI.toString().equals(tile.toString())) {
                // rssi tile
                if (mModel.deviceHasMobileData()) {
                    // RSSI
                    QuickSettingsTileView rssiTile = (QuickSettingsTileView) inflater.inflate(R.layout.quick_settings_tile, parent, false);
                    rssiTile.setTileId(Tile.RSSI);
                    rssiTile.setContent(R.layout.quick_settings_tile_rssi, inflater);
                    final ConnectivityManager cms = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                    rssiTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean currentState = cms.getMobileDataEnabled();
                            cms.setMobileDataEnabled(!currentState);
                        }
                    });
                    rssiTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$DataUsageSummaryActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addRSSITile(rssiTile, new NetworkActivityCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            RSSIState rssiState = (RSSIState) state;
                            ImageView iv = (ImageView) view.findViewById(R.id.rssi_image);
                            ImageView iov = (ImageView) view.findViewById(R.id.rssi_overlay_image);
                            TextView tv = (TextView) view.findViewById(R.id.rssi_textview);
                            TextView itv = (TextView) view.findViewById(R.id.rssi_type_text);
                            // Force refresh
                            iv.setImageDrawable(null);
                            iv.setImageResource(rssiState.signalIconId);
                            if (rssiState.dataTypeIconId > 0) {
                                iov.setImageResource(rssiState.dataTypeIconId);
                            } else {
                                iov.setImageDrawable(null);
                            }
                            setActivity(view, rssiState);
                            tv.setText(state.label);
                            tv.setTextSize(TypedValue.COMPLEX_UNIT_PX, view.getTextSizes());
                            itv.setText(rssiState.networkType);
                            itv.setTextSize(TypedValue.COMPLEX_UNIT_PX, view.getTextSizes());
                            view.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile, rssiState.signalContentDescription, rssiState.dataContentDescription, state.label));
                        }
                    });
                    parent.addView(rssiTile);
                    if (addMissing)
                        rssiTile.setVisibility(View.GONE);
                }
            } else if (Tile.ROTATION.toString().equals(tile.toString())) {
                // Rotation Lock
                if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
                    final QuickSettingsBasicTile rotationLockTile = new QuickSettingsBasicTile(mContext);
                    rotationLockTile.setTileId(Tile.ROTATION);
                    rotationLockTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View view) {
                            final boolean locked = mRotationLockController.isRotationLocked();
                            mRotationLockController.setRotationLocked(!locked);
                        }
                    });
                    rotationLockTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_DISPLAY_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addRotationLockTile(rotationLockTile, mRotationLockController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            QuickSettingsModel.RotationLockState rotationLockState = (QuickSettingsModel.RotationLockState) state;
                            view.setVisibility(rotationLockState.visible ? View.VISIBLE : View.GONE);
                            if (state.iconId != 0) {
                                // needed to flush any cached IDs
                                rotationLockTile.setImageDrawable(null);
                                rotationLockTile.setImageResource(state.iconId);
                            }
                            if (state.label != null) {
                                rotationLockTile.setText(state.label);
                            }
                        }
                    });
                    parent.addView(rotationLockTile);
                    if (addMissing)
                        rotationLockTile.setVisibility(View.GONE);
                }
            } else if (Tile.BATTERY.toString().equals(tile.toString())) {
                // battery tile
                // Battery
                mBatteryTile = (QuickSettingsTileView) inflater.inflate(R.layout.quick_settings_tile, parent, false);
                mBatteryTile.setContent(R.layout.quick_settings_tile_battery, inflater);
                mBattery = (BatteryMeterView) mBatteryTile.findViewById(R.id.image);
                mBattery.setVisibility(View.GONE);
                mCircleBattery = (BatteryCircleMeterView) mBatteryTile.findViewById(R.id.circle_battery);
                updateBattery();
                mBatteryTile.setTileId(Tile.BATTERY);
                mBatteryTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
                    }
                });
                mModel.addBatteryTile(mBatteryTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryState batteryState = (QuickSettingsModel.BatteryState) state;
                        String t;
                        if (batteryState.batteryLevel == 100) {
                            t = mContext.getString(R.string.quick_settings_battery_charged_label);
                        } else {
                            if (batteryState.pluggedIn) {
                                t = // circle percent
                                mBatteryStyle != 3 ? mContext.getString(R.string.quick_settings_battery_charging_label, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_charging);
                            } else {
                                // battery bar or battery circle
                                t = (mBatteryStyle == 0 || mBatteryStyle == 2) ? mContext.getString(R.string.status_bar_settings_battery_meter_format, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_discharging);
                            }
                        }
                        ((TextView) mBatteryTile.findViewById(R.id.text)).setText(t);
                        ((TextView) mBatteryTile.findViewById(R.id.text)).setTextSize(TypedValue.COMPLEX_UNIT_PX, unused.getTextSizes());
                        mBatteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery, t));
                    }
                });
                parent.addView(mBatteryTile);
                if (addMissing)
                    mBatteryTile.setVisibility(View.GONE);
            } else if (Tile.IMMERSIVE.toString().equals(tile.toString())) {
                // Immersive tile
                // Immersive mode
                final QuickSettingsBasicTile immersiveTile = new QuickSettingsBasicTile(mContext);
                immersiveTile.setTileId(Tile.IMMERSIVE);
                immersiveTile.setImageResource(R.drawable.ic_qs_immersive_off);
                immersiveTile.setTextResource(R.string.quick_settings_immersive_mode_off_label);
                immersiveTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, checkModeOn ? 0 : 1);
                    }
                });
                mModel.addImmersiveTile(immersiveTile, new QuickSettingsModel.BasicRefreshCallback(immersiveTile));
                parent.addView(immersiveTile);
                if (addMissing)
                    immersiveTile.setVisibility(View.GONE);
            } else if (Tile.AIRPLANE.toString().equals(tile.toString())) {
                // airplane tile
                // Airplane Mode
                final QuickSettingsBasicTile airplaneTile = new QuickSettingsBasicTile(mContext);
                airplaneTile.setTileId(Tile.AIRPLANE);
                mModel.addAirplaneModeTile(airplaneTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        airplaneTile.setImageResource(state.iconId);
                        String airplaneState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane, airplaneState));
                        airplaneTile.setText(state.label);
                    }
                });
                parent.addView(airplaneTile);
                if (addMissing)
                    airplaneTile.setVisibility(View.GONE);
            } else if (Tile.USBMODE.toString().equals(tile.toString())) {
                // usb tile
                // Usb Mode
                final QuickSettingsBasicTile usbModeTile = new QuickSettingsBasicTile(mContext);
                usbModeTile.setTileId(Tile.USBMODE);
                final ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                usbModeTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                        return true;
                    }
                });
                mModel.addUsbModeTile(usbModeTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        usbModeTile.setImageResource(state.iconId);
                        usbModeTile.setText(state.label);
                    }
                });
                parent.addView(usbModeTile);
                if (addMissing)
                    usbModeTile.setVisibility(View.GONE);
            } else if (Tile.TORCH.toString().equals(tile.toString())) {
                // torch tile
                // Torch
                final QuickSettingsBasicTile torchTile = new QuickSettingsBasicTile(mContext);
                torchTile.setTileId(Tile.TORCH);
                torchTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(OmniTorchConstants.INTENT_LAUNCH_APP);
                        return true;
                    }
                });
                mModel.addTorchTile(torchTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        torchTile.setImageResource(state.iconId);
                        torchTile.setText(state.label);
                    }
                });
                parent.addView(torchTile);
                if (addMissing)
                    torchTile.setVisibility(View.GONE);
            } else if (Tile.SYNC.toString().equals(tile.toString())) {
                // sync tile
                // sync
                final QuickSettingsBasicTile SyncTile = new QuickSettingsBasicTile(mContext);
                SyncTile.setTileId(Tile.SYNC);
                SyncTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent("android.settings.SYNC_SETTINGS");
                        intent.addCategory(Intent.CATEGORY_DEFAULT);
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addSyncModeTile(SyncTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        SyncTile.setImageResource(state.iconId);
                        SyncTile.setText(state.label);
                    }
                });
                parent.addView(SyncTile);
                if (addMissing)
                    SyncTile.setVisibility(View.GONE);
            } else if (Tile.QUITEHOUR.toString().equals(tile.toString())) {
                // Quite hours tile
                // Quite hours mode
                final QuickSettingsBasicTile quiteHourTile = new QuickSettingsBasicTile(mContext);
                quiteHourTile.setTileId(Tile.QUITEHOUR);
                quiteHourTile.setImageResource(R.drawable.ic_qs_quiet_hours_off);
                quiteHourTile.setTextResource(R.string.quick_settings_quiethours_off_label);
                quiteHourTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, checkModeOn ? 0 : 1);
                        Intent scheduleSms = new Intent();
                        scheduleSms.setAction("com.android.settings.slim.service.SCHEDULE_SERVICE_COMMAND");
                        mContext.sendBroadcast(scheduleSms);
                    }
                });
                quiteHourTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent(Intent.ACTION_MAIN);
                        intent.setClassName("com.android.settings", "com.android.settings.Settings$QuietHoursSettingsActivity");
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addQuiteHourTile(quiteHourTile, new QuickSettingsModel.BasicRefreshCallback(quiteHourTile));
                parent.addView(quiteHourTile);
                if (addMissing)
                    quiteHourTile.setVisibility(View.GONE);
            } else if (Tile.VOLUME.toString().equals(tile.toString())) {
                // Volume tile
                // Volume mode
                final QuickSettingsFlipTile VolumeTile = new QuickSettingsFlipTile(mContext);
                VolumeTile.setTileId(Tile.VOLUME);
                VolumeTile.setFrontImageResource(R.drawable.ic_qs_volume);
                VolumeTile.setFrontText(mContext.getString(R.string.quick_settings_volume));
                VolumeTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                VolumeTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
                        am.adjustVolume(AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);
                    }
                });
                VolumeTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                mModel.addRingerModeTile(VolumeTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        VolumeTile.setBackImageResource(state.iconId);
                        VolumeTile.setBackFunction(state.label);
                    }
                });
                VolumeTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                parent.addView(VolumeTile);
                if (addMissing)
                    VolumeTile.setVisibility(View.GONE);
            } else if (Tile.SLEEP.toString().equals(tile.toString())) {
                // Sleep tile
                // Sleep
                final QuickSettingsBasicTile SleepTile = new QuickSettingsBasicTile(mContext);
                SleepTile.setTileId(Tile.SLEEP);
                SleepTile.setImageResource(R.drawable.ic_qs_sleep);
                SleepTile.setTextResource(R.string.quick_settings_screen_sleep);
                SleepTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        pm.goToSleep(SystemClock.uptimeMillis());
                    }
                });
                parent.addView(SleepTile);
                if (addMissing)
                    SleepTile.setVisibility(View.GONE);
            } else if (Tile.BLUETOOTH.toString().equals(tile.toString())) {
                // Bluetooth
                if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
                    final QuickSettingsFlipTile bluetoothTile = new QuickSettingsFlipTile(mContext);
                    bluetoothTile.setTileId(Tile.BLUETOOTH);
                    bluetoothTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (mBluetoothAdapter.isEnabled()) {
                                mBluetoothAdapter.disable();
                            } else {
                                mBluetoothAdapter.enable();
                            }
                            bluetoothTile.setFrontPressed(false);
                            bluetoothTile.setFrontLoading(true);
                        }
                    });
                    mModel.addBluetoothTile(bluetoothTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        private boolean mPreviousState = false;

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setFrontImageResource(state.iconId);
                            bluetoothTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setFrontText(state.label);
                            if (mPreviousState != state.enabled) {
                                bluetoothTile.setFrontLoading(false);
                                mPreviousState = state.enabled;
                            }
                        }
                    });
                    bluetoothTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (!mBluetoothAdapter.isEnabled()) {
                                return;
                            }
                            if (mBluetoothAdapter.getScanMode() != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    mModel.addBluetoothBackTile(bluetoothTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setBackImageResource(state.iconId);
                            bluetoothTile.setBackContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setBackLabel(state.label);
                            if (mBluetoothAdapter.getScanMode() == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    parent.addView(bluetoothTile);
                    if (addMissing)
                        bluetoothTile.setVisibility(View.GONE);
                }
            } else if (Tile.LOCATION.toString().equals(tile.toString())) {
                // Location
                // Location
                final QuickSettingsBasicTile locationTile = new QuickSettingsBasicTile(mContext);
                locationTile.setTileId(Tile.LOCATION);
                locationTile.setImageResource(R.drawable.ic_qs_location_on);
                locationTile.setTextResource(R.string.quick_settings_location_label);
                locationTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                        return true;
                    }
                });
                locationTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean newLocationEnabledState = !mLocationController.isLocationEnabled();
                        if (mLocationController.setLocationEnabled(newLocationEnabledState) && newLocationEnabledState) {
                            // If we've successfully switched from location off to on, close the
                            // notifications tray to show the network location provider consent dialog.
                            Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                            mContext.sendBroadcast(closeDialog);
                        }
                    }
                });
                mModel.addLocationTile(locationTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        locationTile.setImageResource(state.iconId);
                        String locationState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        locationTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_location, locationState));
                        locationTile.setText(state.label);
                    }
                });
                parent.addView(locationTile);
                if (addMissing)
                    locationTile.setVisibility(View.GONE);
            }
        }
    }
    if (!addMissing)
        addTiles(parent, inflater, true, false);
}
#method_after
private void addTiles(ViewGroup parent, LayoutInflater inflater, boolean addMissing, boolean reset) {
    // If all the tiles were deleted, they are still loaded, but their visibility is changed
    if (reset) {
        parent.removeAllViews();
    }
    String tileContainer = Settings.System.getString(mContext.getContentResolver(), Settings.System.QUICK_SETTINGS_TILES);
    if (tileContainer == null)
        tileContainer = DEFAULT_TILES;
    Tile[] allTiles = Tile.values();
    String[] storedTiles = tileContainer.split(DELIMITER);
    List<String> allTilesArray = enumToStringArray(allTiles);
    List<String> storedTilesArray = Arrays.asList(storedTiles);
    for (String tile : addMissing ? allTilesArray : storedTilesArray) {
        boolean addTile = storedTilesArray.contains(tile);
        if (addMissing)
            addTile = !addTile;
        if (addTile) {
            if (Tile.USER.toString().equals(tile.toString())) {
                // User
                QuickSettingsTileView userTile = (QuickSettingsTileView) inflater.inflate(R.layout.quick_settings_tile, parent, false);
                userTile.setContent(R.layout.quick_settings_tile_user, inflater);
                userTile.setTileId(Tile.USER);
                userTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        final UserManager um = UserManager.get(mContext);
                        if (um.getUsers(true).size() > 1) {
                            // Since keyguard and systemui were merged into the same process to save
                            // memory, they share the same Looper and graphics context.  As a result,
                            // there's no way to allow concurrent animation while keyguard inflates.
                            // The workaround is to add a slight delay to allow the animation to finish.
                            mHandler.postDelayed(new Runnable() {

                                public void run() {
                                    try {
                                        WindowManagerGlobal.getWindowManagerService().lockNow(null);
                                    } catch (RemoteException e) {
                                        Log.e(TAG, "Couldn't show user switcher", e);
                                    }
                                }
                            }, // TODO: ideally this would be tied to the collapse of the panel
                            400);
                        } else {
                            Intent intent = ContactsContract.QuickContact.composeQuickContactsIntent(mContext, v, ContactsContract.Profile.CONTENT_URI, ContactsContract.QuickContact.MODE_LARGE, null);
                            mContext.startActivityAsUser(intent, new UserHandle(UserHandle.USER_CURRENT));
                        }
                    }
                });
                userTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SYNC_SETTINGS);
                        return true;
                    }
                });
                mModel.addUserTile(userTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        UserState us = (UserState) state;
                        ImageView iv = (ImageView) view.findViewById(R.id.user_imageview);
                        TextView tv = (TextView) view.findViewById(R.id.user_textview);
                        tv.setText(state.label);
                        iv.setImageDrawable(us.avatar);
                        view.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_user, state.label));
                    }
                });
                parent.addView(userTile);
                if (addMissing)
                    userTile.setVisibility(View.GONE);
            } else if (Tile.BRIGHTNESS.toString().equals(tile.toString())) {
                // brightness
                // Brightness
                final QuickSettingsBasicTile brightnessTile = new QuickSettingsBasicTile(mContext);
                brightnessTile.setTileId(Tile.BRIGHTNESS);
                brightnessTile.setImageResource(R.drawable.ic_qs_brightness_auto_off);
                brightnessTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        showBrightnessDialog();
                    }
                });
                brightnessTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        boolean automaticAvailable = mContext.getResources().getBoolean(com.android.internal.R.bool.config_automatic_brightness_available);
                        // If we have automatic brightness available, toggle it
                        if (automaticAvailable) {
                            int automatic;
                            try {
                                automatic = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, UserHandle.USER_CURRENT);
                            } catch (SettingNotFoundException snfe) {
                                automatic = 0;
                            }
                            Settings.System.putIntForUser(mContext.getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE, automatic != 0 ? 0 : 1, UserHandle.USER_CURRENT);
                        }
                        return true;
                    }
                });
                mModel.addBrightnessTile(brightnessTile, new QuickSettingsModel.BasicRefreshCallback(brightnessTile));
                parent.addView(brightnessTile);
                if (addMissing)
                    brightnessTile.setVisibility(View.GONE);
            } else if (Tile.SETTINGS.toString().equals(tile.toString())) {
                // Settings tile
                // Settings tile
                final QuickSettingsBasicTile settingsTile = new QuickSettingsBasicTile(mContext);
                settingsTile.setTileId(Tile.SETTINGS);
                settingsTile.setImageResource(R.drawable.ic_qs_settings);
                settingsTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SETTINGS);
                    }
                });
                mModel.addSettingsTile(settingsTile, new QuickSettingsModel.BasicRefreshCallback(settingsTile));
                parent.addView(settingsTile);
                if (addMissing)
                    settingsTile.setVisibility(View.GONE);
            } else if (Tile.WIFI.toString().equals(tile.toString())) {
                // wifi tile
                // Wi-fi
                final QuickSettingsFlipTile wifiTile = new QuickSettingsFlipTile(mContext);
                wifiTile.setTileId(Tile.WIFI);
                wifiTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_WIFI_SETTINGS);
                        return true;
                    }
                });
                wifiTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        final boolean enable = (mWifiManager.getWifiState() != WifiManager.WIFI_STATE_ENABLED);
                        new AsyncTask<Void, Void, Void>() {

                            @Override
                            protected Void doInBackground(Void... args) {
                                // Disable tethering if enabling Wifi
                                final int wifiApState = mWifiManager.getWifiApState();
                                if (enable && ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) || (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED))) {
                                    mWifiManager.setWifiApEnabled(null, false);
                                }
                                mWifiManager.setWifiEnabled(enable);
                                return null;
                            }
                        }.execute();
                        wifiTile.setFrontLoading(true);
                        wifiTile.setFrontPressed(false);
                    }
                });
                mModel.addWifiTile(wifiTile.getFront(), new NetworkActivityCallback() {

                    private String mPreviousLabel = "";

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setFrontImageResource(wifiState.iconId);
                        wifiTile.setFrontText(wifiState.label);
                        wifiTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_wifi, wifiState.signalContentDescription, (wifiState.connected) ? wifiState.label : ""));
                        if (wifiState.label != null && !mPreviousLabel.equals(wifiState.label)) {
                            wifiTile.setFrontLoading(false);
                            mPreviousLabel = wifiState.label;
                        }
                    }
                });
                final ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                wifiTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                    }
                });
                mModel.addWifiBackTile(wifiTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        WifiState wifiState = (WifiState) state;
                        wifiTile.setBackImageResource(wifiState.iconId);
                        wifiTile.setBackLabel(wifiState.label);
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            wifiTile.setBackFunction(mContext.getString(R.string.quick_settings_wifi_tethering_label));
                        } else {
                            wifiTile.setBackFunction("");
                        }
                    }
                });
                parent.addView(wifiTile);
                if (addMissing)
                    wifiTile.setVisibility(View.GONE);
            } else if (Tile.RSSI.toString().equals(tile.toString())) {
                // rssi tile
                if (mModel.deviceHasMobileData()) {
                    // RSSI
                    QuickSettingsTileView rssiTile = (QuickSettingsTileView) inflater.inflate(R.layout.quick_settings_tile, parent, false);
                    rssiTile.setTileId(Tile.RSSI);
                    rssiTile.setContent(R.layout.quick_settings_tile_rssi, inflater);
                    final ConnectivityManager cms = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                    rssiTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            boolean currentState = cms.getMobileDataEnabled();
                            cms.setMobileDataEnabled(!currentState);
                        }
                    });
                    rssiTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$DataUsageSummaryActivity"));
                            startSettingsActivity(intent);
                            return true;
                        }
                    });
                    mModel.addRSSITile(rssiTile, new NetworkActivityCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            RSSIState rssiState = (RSSIState) state;
                            ImageView iv = (ImageView) view.findViewById(R.id.rssi_image);
                            ImageView iov = (ImageView) view.findViewById(R.id.rssi_overlay_image);
                            TextView tv = (TextView) view.findViewById(R.id.rssi_textview);
                            TextView itv = (TextView) view.findViewById(R.id.rssi_type_text);
                            // Force refresh
                            iv.setImageDrawable(null);
                            iv.setImageResource(rssiState.signalIconId);
                            if (rssiState.dataTypeIconId > 0) {
                                iov.setImageResource(rssiState.dataTypeIconId);
                            } else {
                                iov.setImageDrawable(null);
                            }
                            setActivity(view, rssiState);
                            tv.setText(state.label);
                            tv.setTextSize(TypedValue.COMPLEX_UNIT_PX, view.getTextSizes());
                            itv.setText(rssiState.networkType);
                            itv.setTextSize(TypedValue.COMPLEX_UNIT_PX, view.getTextSizes());
                            view.setContentDescription(mContext.getResources().getString(R.string.accessibility_quick_settings_mobile, rssiState.signalContentDescription, rssiState.dataContentDescription, state.label));
                        }
                    });
                    parent.addView(rssiTile);
                    if (addMissing)
                        rssiTile.setVisibility(View.GONE);
                }
            } else if (Tile.ROTATION.toString().equals(tile.toString())) {
                // Rotation Lock
                if (mContext.getResources().getBoolean(R.bool.quick_settings_show_rotation_lock) || DEBUG_GONE_TILES) {
                    final QuickSettingsBasicTile rotationLockTile = new QuickSettingsBasicTile(mContext);
                    rotationLockTile.setTileId(Tile.ROTATION);
                    rotationLockTile.setOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View view) {
                            final boolean locked = mRotationLockController.isRotationLocked();
                            mRotationLockController.setRotationLocked(!locked);
                        }
                    });
                    rotationLockTile.setOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_DISPLAY_SETTINGS);
                            return true;
                        }
                    });
                    mModel.addRotationLockTile(rotationLockTile, mRotationLockController, new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView view, State state) {
                            QuickSettingsModel.RotationLockState rotationLockState = (QuickSettingsModel.RotationLockState) state;
                            view.setVisibility(rotationLockState.visible ? View.VISIBLE : View.GONE);
                            if (state.iconId != 0) {
                                // needed to flush any cached IDs
                                rotationLockTile.setImageDrawable(null);
                                rotationLockTile.setImageResource(state.iconId);
                            }
                            if (state.label != null) {
                                rotationLockTile.setText(state.label);
                            }
                        }
                    });
                    parent.addView(rotationLockTile);
                    if (addMissing)
                        rotationLockTile.setVisibility(View.GONE);
                }
            } else if (Tile.BATTERY.toString().equals(tile.toString())) {
                // battery tile
                // Battery
                mBatteryTile = (QuickSettingsTileView) inflater.inflate(R.layout.quick_settings_tile, parent, false);
                mBatteryTile.setContent(R.layout.quick_settings_tile_battery, inflater);
                mBattery = (BatteryMeterView) mBatteryTile.findViewById(R.id.image);
                mBattery.setVisibility(View.GONE);
                mCircleBattery = (BatteryCircleMeterView) mBatteryTile.findViewById(R.id.circle_battery);
                updateBattery();
                mBatteryTile.setTileId(Tile.BATTERY);
                mBatteryTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        startSettingsActivity(Intent.ACTION_POWER_USAGE_SUMMARY);
                    }
                });
                mModel.addBatteryTile(mBatteryTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        QuickSettingsModel.BatteryState batteryState = (QuickSettingsModel.BatteryState) state;
                        String t;
                        if (batteryState.batteryLevel == 100) {
                            t = mContext.getString(R.string.quick_settings_battery_charged_label);
                        } else {
                            if (batteryState.pluggedIn) {
                                t = // circle percent
                                mBatteryStyle != 3 ? mContext.getString(R.string.quick_settings_battery_charging_label, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_charging);
                            } else {
                                // battery bar or battery circle
                                t = (mBatteryStyle == 0 || mBatteryStyle == 2) ? mContext.getString(R.string.status_bar_settings_battery_meter_format, batteryState.batteryLevel) : mContext.getString(R.string.quick_settings_battery_discharging);
                            }
                        }
                        ((TextView) mBatteryTile.findViewById(R.id.text)).setText(t);
                        ((TextView) mBatteryTile.findViewById(R.id.text)).setTextSize(TypedValue.COMPLEX_UNIT_PX, unused.getTextSizes());
                        mBatteryTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_battery, t));
                    }
                });
                parent.addView(mBatteryTile);
                if (addMissing)
                    mBatteryTile.setVisibility(View.GONE);
            } else if (Tile.IMMERSIVE.toString().equals(tile.toString())) {
                // Immersive tile
                // Immersive mode
                final QuickSettingsBasicTile immersiveTile = new QuickSettingsBasicTile(mContext);
                immersiveTile.setTileId(Tile.IMMERSIVE);
                immersiveTile.setImageResource(R.drawable.ic_qs_immersive_off);
                immersiveTile.setTextResource(R.string.quick_settings_immersive_mode_off_label);
                immersiveTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.IMMERSIVE_MODE, checkModeOn ? 0 : 1);
                    }
                });
                mModel.addImmersiveTile(immersiveTile, new QuickSettingsModel.BasicRefreshCallback(immersiveTile));
                parent.addView(immersiveTile);
                if (addMissing)
                    immersiveTile.setVisibility(View.GONE);
            } else if (Tile.AIRPLANE.toString().equals(tile.toString())) {
                // airplane tile
                // Airplane Mode
                final QuickSettingsBasicTile airplaneTile = new QuickSettingsBasicTile(mContext);
                airplaneTile.setTileId(Tile.AIRPLANE);
                mModel.addAirplaneModeTile(airplaneTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        airplaneTile.setImageResource(state.iconId);
                        String airplaneState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        airplaneTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_airplane, airplaneState));
                        airplaneTile.setText(state.label);
                    }
                });
                parent.addView(airplaneTile);
                if (addMissing)
                    airplaneTile.setVisibility(View.GONE);
            } else if (Tile.USBMODE.toString().equals(tile.toString())) {
                // usb tile
                // Usb Mode
                final QuickSettingsBasicTile usbModeTile = new QuickSettingsBasicTile(mContext);
                usbModeTile.setTileId(Tile.USBMODE);
                final ConnectivityManager cm = (ConnectivityManager) mContext.getSystemService(Context.CONNECTIVITY_SERVICE);
                usbModeTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        if (cm.getTetherableWifiRegexs().length != 0) {
                            Intent intent = new Intent();
                            intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.Settings$TetherSettingsActivity"));
                            startSettingsActivity(intent);
                        }
                        return true;
                    }
                });
                mModel.addUsbModeTile(usbModeTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        usbModeTile.setImageResource(state.iconId);
                        usbModeTile.setText(state.label);
                    }
                });
                parent.addView(usbModeTile);
                if (addMissing)
                    usbModeTile.setVisibility(View.GONE);
            } else if (Tile.TORCH.toString().equals(tile.toString())) {
                // torch tile
                // Torch
                final QuickSettingsBasicTile torchTile = new QuickSettingsBasicTile(mContext);
                torchTile.setTileId(Tile.TORCH);
                torchTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(OmniTorchConstants.INTENT_LAUNCH_APP);
                        return true;
                    }
                });
                mModel.addTorchTile(torchTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        torchTile.setImageResource(state.iconId);
                        torchTile.setText(state.label);
                    }
                });
                parent.addView(torchTile);
                if (addMissing)
                    torchTile.setVisibility(View.GONE);
            } else if (Tile.SYNC.toString().equals(tile.toString())) {
                // sync tile
                // sync
                final QuickSettingsBasicTile SyncTile = new QuickSettingsBasicTile(mContext);
                SyncTile.setTileId(Tile.SYNC);
                SyncTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent("android.settings.SYNC_SETTINGS");
                        intent.addCategory(Intent.CATEGORY_DEFAULT);
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addSyncModeTile(SyncTile, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        SyncTile.setImageResource(state.iconId);
                        SyncTile.setText(state.label);
                    }
                });
                parent.addView(SyncTile);
                if (addMissing)
                    SyncTile.setVisibility(View.GONE);
            } else if (Tile.QUITEHOUR.toString().equals(tile.toString())) {
                // Quite hours tile
                // Quite hours mode
                final QuickSettingsBasicTile quiteHourTile = new QuickSettingsBasicTile(mContext);
                quiteHourTile.setTileId(Tile.QUITEHOUR);
                quiteHourTile.setImageResource(R.drawable.ic_qs_quiet_hours_off);
                quiteHourTile.setTextResource(R.string.quick_settings_quiethours_off_label);
                quiteHourTile.setOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean checkModeOn = Settings.System.getInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, 0) == 1;
                        Settings.System.putInt(mContext.getContentResolver(), Settings.System.QUIET_HOURS_ENABLED, checkModeOn ? 0 : 1);
                        Intent scheduleSms = new Intent();
                        scheduleSms.setAction("com.android.settings.slim.service.SCHEDULE_SERVICE_COMMAND");
                        mContext.sendBroadcast(scheduleSms);
                    }
                });
                quiteHourTile.setOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        Intent intent = new Intent(Intent.ACTION_MAIN);
                        intent.setClassName("com.android.settings", "com.android.settings.Settings$QuietHoursSettingsActivity");
                        startSettingsActivity(intent);
                        return true;
                    }
                });
                mModel.addQuiteHourTile(quiteHourTile, new QuickSettingsModel.BasicRefreshCallback(quiteHourTile));
                parent.addView(quiteHourTile);
                if (addMissing)
                    quiteHourTile.setVisibility(View.GONE);
            } else if (Tile.VOLUME.toString().equals(tile.toString())) {
                // Volume tile
                // Volume mode
                final QuickSettingsFlipTile VolumeTile = new QuickSettingsFlipTile(mContext);
                VolumeTile.setTileId(Tile.VOLUME);
                VolumeTile.setFrontImageResource(R.drawable.ic_qs_volume);
                VolumeTile.setFrontText(mContext.getString(R.string.quick_settings_volume));
                VolumeTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                VolumeTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
                        am.adjustVolume(AudioManager.ADJUST_SAME, AudioManager.FLAG_SHOW_UI);
                    }
                });
                VolumeTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                mModel.addRingerModeTile(VolumeTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        VolumeTile.setBackImageResource(state.iconId);
                        VolumeTile.setBackFunction(state.label);
                    }
                });
                VolumeTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_SOUND_SETTINGS);
                        return true;
                    }
                });
                parent.addView(VolumeTile);
                if (addMissing)
                    VolumeTile.setVisibility(View.GONE);
            } else if (Tile.SLEEP.toString().equals(tile.toString())) {
                // Sleep tile
                // Sleep
                final QuickSettingsFlipTile SleepTile = new QuickSettingsFlipTile(mContext);
                SleepTile.setTileId(Tile.SLEEP);
                SleepTile.setFrontImageResource(R.drawable.ic_qs_sleep);
                SleepTile.setFrontText(mContext.getString(R.string.quick_settings_screen_sleep));
                SleepTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                SleepTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        collapsePanels();
                        pm.goToSleep(SystemClock.uptimeMillis());
                    }
                });
                mModel.addSleepModeTile(SleepTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView view, State state) {
                        SleepTile.setBackImageResource(state.iconId);
                        SleepTile.setBackFunction(state.label);
                    }
                });
                parent.addView(SleepTile);
                if (addMissing)
                    SleepTile.setVisibility(View.GONE);
            } else if (Tile.BLUETOOTH.toString().equals(tile.toString())) {
                // Bluetooth
                if (mModel.deviceSupportsBluetooth() || DEBUG_GONE_TILES) {
                    final QuickSettingsFlipTile bluetoothTile = new QuickSettingsFlipTile(mContext);
                    bluetoothTile.setTileId(Tile.BLUETOOTH);
                    bluetoothTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setFrontOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (mBluetoothAdapter.isEnabled()) {
                                mBluetoothAdapter.disable();
                            } else {
                                mBluetoothAdapter.enable();
                            }
                            bluetoothTile.setFrontPressed(false);
                            bluetoothTile.setFrontLoading(true);
                        }
                    });
                    mModel.addBluetoothTile(bluetoothTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                        private boolean mPreviousState = false;

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setFrontImageResource(state.iconId);
                            bluetoothTile.setFrontContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setFrontText(state.label);
                            if (mPreviousState != state.enabled) {
                                bluetoothTile.setFrontLoading(false);
                                mPreviousState = state.enabled;
                            }
                        }
                    });
                    bluetoothTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                        @Override
                        public boolean onLongClick(View v) {
                            startSettingsActivity(android.provider.Settings.ACTION_BLUETOOTH_SETTINGS);
                            return true;
                        }
                    });
                    bluetoothTile.setBackOnClickListener(new View.OnClickListener() {

                        @Override
                        public void onClick(View v) {
                            if (!mBluetoothAdapter.isEnabled()) {
                                return;
                            }
                            if (mBluetoothAdapter.getScanMode() != BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                mBluetoothAdapter.setScanMode(BluetoothAdapter.SCAN_MODE_CONNECTABLE, 300);
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    mModel.addBluetoothBackTile(bluetoothTile.getBack(), new QuickSettingsModel.RefreshCallback() {

                        @Override
                        public void refreshView(QuickSettingsTileView unused, State state) {
                            BluetoothState bluetoothState = (BluetoothState) state;
                            bluetoothTile.setBackImageResource(state.iconId);
                            bluetoothTile.setBackContentDescription(mContext.getString(R.string.accessibility_quick_settings_bluetooth, bluetoothState.stateContentDescription));
                            bluetoothTile.setBackLabel(state.label);
                            if (mBluetoothAdapter.getScanMode() == BluetoothAdapter.SCAN_MODE_CONNECTABLE_DISCOVERABLE) {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_discoverable_label));
                            } else {
                                bluetoothTile.setBackFunction(mContext.getString(R.string.quick_settings_bluetooth_not_discoverable_label));
                            }
                        }
                    });
                    parent.addView(bluetoothTile);
                    if (addMissing)
                        bluetoothTile.setVisibility(View.GONE);
                }
            } else if (Tile.LOCATION.toString().equals(tile.toString())) {
                // Location
                // Location
                final QuickSettingsFlipTile locationTile = new QuickSettingsFlipTile(mContext);
                locationTile.setTileId(Tile.LOCATION);
                locationTile.setFrontImageResource(R.drawable.ic_qs_location_on);
                locationTile.setFrontText(mContext.getString(R.string.quick_settings_location_label));
                locationTile.setBackLabel(mContext.getString(R.string.quick_settings_volume_status));
                locationTile.setFrontOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                        return true;
                    }
                });
                locationTile.setFrontOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        boolean newLocationEnabledState = !mLocationController.isLocationEnabled();
                        if (mLocationController.setLocationEnabled(newLocationEnabledState) && newLocationEnabledState) {
                            // If we've successfully switched from location off to on, close the
                            // notifications tray to show the network location provider consent dialog.
                            Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                            mContext.sendBroadcast(closeDialog);
                        }
                    }
                });
                mModel.addLocationTile(locationTile.getFront(), new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        locationTile.setFrontImageResource(state.iconId);
                        String locationState = mContext.getString((state.enabled) ? R.string.accessibility_desc_on : R.string.accessibility_desc_off);
                        locationTile.setContentDescription(mContext.getString(R.string.accessibility_quick_settings_location, locationState));
                        locationTile.setFrontText(state.label);
                    }
                });
                locationTile.setBackOnClickListener(new View.OnClickListener() {

                    @Override
                    public void onClick(View v) {
                        int newLocationMode = mLocationController.locationMode();
                        if (mLocationController.isLocationEnabled()) {
                            if (mLocationController.setBackLocationEnabled(newLocationMode)) {
                                if (mLocationController.isLocationAllowPanelCollapse()) {
                                    Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
                                    mContext.sendBroadcast(closeDialog);
                                }
                            }
                        }
                    }
                });
                locationTile.setBackOnLongClickListener(new View.OnLongClickListener() {

                    @Override
                    public boolean onLongClick(View v) {
                        startSettingsActivity(android.provider.Settings.ACTION_LOCATION_SOURCE_SETTINGS);
                        return true;
                    }
                });
                mModel.addBackLocationTile(locationTile.getBack(), mLocationController, new QuickSettingsModel.RefreshCallback() {

                    @Override
                    public void refreshView(QuickSettingsTileView unused, State state) {
                        locationTile.setBackImageResource(state.iconId);
                        locationTile.setBackFunction(state.label);
                    }
                });
                parent.addView(locationTile);
                if (addMissing)
                    locationTile.setVisibility(View.GONE);
            }
        }
    }
    if (!addMissing)
        addTiles(parent, inflater, true, false);
}
#end_block

#method_before
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_CUSTOM_HEADER), false, this);
    update();
}
#method_after
void observe() {
    ContentResolver resolver = mContext.getContentResolver();
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.SCREEN_BRIGHTNESS_MODE), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.STATUS_BAR_CUSTOM_HEADER), false, this);
    resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.QUICK_SETTINGS_TILES), false, this);
    update();
}
#end_block

#method_before
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    boolean autoBrightness = Settings.System.getInt(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, 0) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC;
    mBrightnessControl = !autoBrightness && Settings.System.getInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0) == 1;
    updateCustomHeaderStatus();
}
#method_after
public void update() {
    final ContentResolver resolver = mContext.getContentResolver();
    boolean autoBrightness = Settings.System.getInt(resolver, Settings.System.SCREEN_BRIGHTNESS_MODE, 0) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC;
    mBrightnessControl = !autoBrightness && Settings.System.getInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0) == 1;
    updateCustomHeaderStatus();
    if (mQS != null)
        mQS.updateResources();
}
#end_block

#method_before
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    mScreenWidth = (float) context.getResources().getDisplayMetrics().widthPixels;
    mMinBrightness = context.getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
    // populates mDisplayMetrics
    updateDisplaySize();
    loadDimens();
    mIconSize = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_icon_size);
    mStatusBarWindow = (StatusBarWindowView) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.mService = this;
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    mNotificationPanelIsFullScreenWidth = (mNotificationPanel.getLayoutParams().width == ViewGroup.LayoutParams.MATCH_PARENT);
    // make the header non-responsive to clicks
    mNotificationPanel.findViewById(R.id.header).setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            // e eats everything
            return true;
        }
    });
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
    }
    if (ENABLE_HEADS_UP) {
        mHeadsUpNotificationView = (HeadsUpNotificationView) View.inflate(context, R.layout.heads_up, null);
        mHeadsUpNotificationView.setVisibility(View.GONE);
        mHeadsUpNotificationView.setBar(this);
    }
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    updateShowSearchHoldoff();
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav) {
            mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
            mNavigationBarView.setDisabledFlags(mDisabled);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    if (mRecreating) {
    } else {
        addActiveDisplayView();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mSystemIconArea = (LinearLayout) mStatusBarView.findViewById(R.id.system_icon_area);
    mStatusIcons = (LinearLayout) mStatusBarView.findViewById(R.id.statusIcons);
    mNotificationIcons = (IconMerger) mStatusBarView.findViewById(R.id.notificationIcons);
    mMoreIcon = mStatusBarView.findViewById(R.id.moreIcon);
    mNotificationIcons.setOverflowIndicator(mMoreIcon);
    mStatusBarContents = (LinearLayout) mStatusBarView.findViewById(R.id.status_bar_contents);
    mTickerView = mStatusBarView.findViewById(R.id.ticker);
    mPile = (NotificationRowLayout) mStatusBarWindow.findViewById(R.id.latestItems);
    mPile.setLayoutTransitionsEnabled(false);
    mPile.setLongPressListener(getNotificationLongClicker());
    // was: expanded.findViewById(R.id.notificationLinearLayout);
    mExpandedContents = mPile;
    mNotificationPanelHeader = mStatusBarWindow.findViewById(R.id.header);
    mStatusHeaderMachine = new StatusHeaderMachine(mContext);
    updateCustomHeaderStatus();
    mClearButton = mStatusBarWindow.findViewById(R.id.clear_all_button);
    mClearButton.setOnClickListener(mClearButtonListener);
    mClearButton.setAlpha(0f);
    mClearButton.setVisibility(View.INVISIBLE);
    mClearButton.setEnabled(false);
    mDateView = (DateView) mStatusBarWindow.findViewById(R.id.date);
    if (mDateView != null) {
        mDateView.setOnClickListener(mCalendarClickListener);
        mDateView.setEnabled(true);
    }
    mClockView = mNotificationPanelHeader.findViewById(R.id.clock);
    if (mClockView != null) {
        mClockView.setOnClickListener(mClockClickListener);
        mClockView.setEnabled(true);
    }
    mHasSettingsPanel = res.getBoolean(R.bool.config_hasSettingsPanel);
    mHasFlipSettings = res.getBoolean(R.bool.config_hasFlipSettingsPanel);
    mDateTimeView = mNotificationPanelHeader.findViewById(R.id.datetime);
    mSettingsButton = (ImageView) mStatusBarWindow.findViewById(R.id.settings_button);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
        if (mHasSettingsPanel) {
            if (mStatusBarView.hasFullWidthNotifications()) {
                // the settings panel is hiding behind this button
                mSettingsButton.setImageResource(R.drawable.ic_notify_quicksettings);
                mSettingsButton.setVisibility(View.VISIBLE);
            } else {
                // there is a settings panel, but it's on the other side of the (large) screen
                final View buttonHolder = mStatusBarWindow.findViewById(R.id.settings_button_holder);
                if (buttonHolder != null) {
                    buttonHolder.setVisibility(View.GONE);
                }
            }
        } else {
            // no settings panel, go straight to settings
            mSettingsButton.setVisibility(View.VISIBLE);
            mSettingsButton.setImageResource(R.drawable.ic_notify_settings);
        }
    }
    if (mHasFlipSettings) {
        mNotificationButton = (ImageView) mStatusBarWindow.findViewById(R.id.notification_button);
        if (mNotificationButton != null) {
            mNotificationButton.setOnClickListener(mNotificationButtonListener);
        }
    }
    mScrollView = (ScrollView) mStatusBarWindow.findViewById(R.id.scroll);
    // less drawing during pulldowns
    mScrollView.setVerticalScrollBarEnabled(false);
    if (!mNotificationPanelIsFullScreenWidth) {
        mScrollView.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_NOTIFICATION_ICONS | View.STATUS_BAR_DISABLE_CLOCK);
    }
    mTicker = new MyTicker(context, mStatusBarView);
    TickerView tickerView = (TickerView) mStatusBarView.findViewById(R.id.tickerText);
    tickerView.mTicker = mTicker;
    mEdgeBorder = res.getDimensionPixelSize(R.dimen.status_bar_edge_ignore);
    // set the inital view visibility
    setAreThereNotifications();
    // Other icons
    // will post a notification
    mLocationController = new LocationController(mContext);
    mBatteryController = new BatteryController(mContext);
    mNetworkController = new NetworkController(mContext);
    mBluetoothController = new BluetoothController(mContext);
    mRotationLockController = new RotationLockController(mContext);
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCluster(signalCluster);
    signalCluster.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mEmergencyCallLabel = (TextView) mStatusBarWindow.findViewById(R.id.emergency_calls_only);
        if (mEmergencyCallLabel != null) {
            mNetworkController.addEmergencyLabelView(mEmergencyCallLabel);
            mEmergencyCallLabel.setOnClickListener(new View.OnClickListener() {

                public void onClick(View v) {
                }
            });
            mEmergencyCallLabel.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {

                @Override
                public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
                    updateCarrierLabelVisibility(false);
                }
            });
        }
    }
    mCarrierLabel = (TextView) mStatusBarWindow.findViewById(R.id.carrier_label);
    mShowCarrierInPanel = (mCarrierLabel != null);
    if (DEBUG)
        Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" + mShowCarrierInPanel);
    if (mShowCarrierInPanel) {
        mCarrierLabel.setVisibility(mCarrierLabelVisible ? View.VISIBLE : View.INVISIBLE);
        // for other devices, we show whatever network is connected
        if (mNetworkController.hasMobileDataFeature()) {
            mNetworkController.addMobileLabelView(mCarrierLabel);
        } else {
            mNetworkController.addCombinedLabelView(mCarrierLabel);
        }
        // set up the dynamic hide/show of the label
        mPile.setOnSizeChangedListener(new OnSizeChangedListener() {

            @Override
            public void onSizeChanged(View view, int w, int h, int oldw, int oldh) {
                updateCarrierLabelVisibility(false);
            }
        });
    }
    // Quick Settings (where available, some restrictions apply)
    if (mHasSettingsPanel) {
        // first, figure out where quick settings should be inflated
        final View settings_stub;
        if (mHasFlipSettings) {
            // a version of quick settings that flips around behind the notifications
            settings_stub = mStatusBarWindow.findViewById(R.id.flip_settings_stub);
            if (settings_stub != null) {
                mFlipSettingsView = ((ViewStub) settings_stub).inflate();
                mFlipSettingsView.setVisibility(View.GONE);
                mFlipSettingsView.setVerticalScrollBarEnabled(false);
            }
        } else {
            // full quick settings panel
            settings_stub = mStatusBarWindow.findViewById(R.id.quick_settings_stub);
            if (settings_stub != null) {
                mSettingsPanel = (SettingsPanelView) ((ViewStub) settings_stub).inflate();
            } else {
                mSettingsPanel = (SettingsPanelView) mStatusBarWindow.findViewById(R.id.settings_panel);
            }
            if (mSettingsPanel != null) {
                if (!ActivityManager.isHighEndGfx()) {
                    mSettingsPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
                }
            }
        }
        // wherever you find it, Quick Settings needs a container to survive
        mSettingsContainer = (QuickSettingsContainerView) mStatusBarWindow.findViewById(R.id.quick_settings_container);
        if (mSettingsContainer != null) {
            mQS = new QuickSettings(mContext, mSettingsContainer);
            if (!mNotificationPanelIsFullScreenWidth) {
                mSettingsContainer.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_SYSTEM_INFO);
            }
            if (mSettingsPanel != null) {
                mSettingsPanel.setQuickSettings(mQS);
            }
            mQS.setService(this);
            mQS.setBar(mStatusBarView);
            mQS.setup(mNetworkController, mBluetoothController, mBatteryController, mLocationController, mRotationLockController);
        } else {
            // fly away, be free
            mQS = null;
        }
    }
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(ACTION_DEMO);
    context.registerReceiver(mBroadcastReceiver, filter);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    mVelocityTracker = VelocityTracker.obtain();
    mBattery = (BatteryMeterView) mStatusBarView.findViewById(R.id.battery);
    mCircleBattery = (BatteryCircleMeterView) mStatusBarView.findViewById(R.id.circle_battery);
    return mStatusBarView;
}
#method_after
// ================================================================================
// Constructing the view
protected PhoneStatusBarView makeStatusBarView() {
    final Context context = mContext;
    Resources res = context.getResources();
    mScreenWidth = (float) context.getResources().getDisplayMetrics().widthPixels;
    mMinBrightness = context.getResources().getInteger(com.android.internal.R.integer.config_screenBrightnessDim);
    // populates mDisplayMetrics
    updateDisplaySize();
    loadDimens();
    mIconSize = res.getDimensionPixelSize(com.android.internal.R.dimen.status_bar_icon_size);
    mStatusBarWindow = (StatusBarWindowView) View.inflate(context, R.layout.super_status_bar, null);
    mStatusBarWindow.mService = this;
    mStatusBarWindow.setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            checkUserAutohide(v, event);
            if (event.getAction() == MotionEvent.ACTION_DOWN) {
                if (mExpandedVisible) {
                    animateCollapsePanels();
                }
            }
            return mStatusBarWindow.onTouchEvent(event);
        }
    });
    mStatusBarView = (PhoneStatusBarView) mStatusBarWindow.findViewById(R.id.status_bar);
    mStatusBarView.setBar(this);
    PanelHolder holder = (PanelHolder) mStatusBarWindow.findViewById(R.id.panel_holder);
    mStatusBarView.setPanelHolder(holder);
    mNotificationPanel = (NotificationPanelView) mStatusBarWindow.findViewById(R.id.notification_panel);
    mNotificationPanel.setStatusBar(this);
    mNotificationPanelIsFullScreenWidth = (mNotificationPanel.getLayoutParams().width == ViewGroup.LayoutParams.MATCH_PARENT);
    // make the header non-responsive to clicks
    mNotificationPanel.findViewById(R.id.header).setOnTouchListener(new View.OnTouchListener() {

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            // e eats everything
            return true;
        }
    });
    if (!ActivityManager.isHighEndGfx()) {
        mStatusBarWindow.setBackground(null);
        mNotificationPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
    }
    if (ENABLE_HEADS_UP) {
        mHeadsUpNotificationView = (HeadsUpNotificationView) View.inflate(context, R.layout.heads_up, null);
        mHeadsUpNotificationView.setVisibility(View.GONE);
        mHeadsUpNotificationView.setBar(this);
    }
    if (MULTIUSER_DEBUG) {
        mNotificationPanelDebugText = (TextView) mNotificationPanel.findViewById(R.id.header_debug_info);
        mNotificationPanelDebugText.setVisibility(View.VISIBLE);
    }
    updateShowSearchHoldoff();
    try {
        boolean showNav = mWindowManagerService.hasNavigationBar();
        if (DEBUG)
            Log.v(TAG, "hasNavigationBar=" + showNav);
        if (showNav) {
            mNavigationBarView = (NavigationBarView) View.inflate(context, R.layout.navigation_bar, null);
            mNavigationBarView.setDisabledFlags(mDisabled);
            mNavigationBarView.setBar(this);
            mNavigationBarView.setOnTouchListener(new View.OnTouchListener() {

                @Override
                public boolean onTouch(View v, MotionEvent event) {
                    checkUserAutohide(v, event);
                    return false;
                }
            });
        }
    } catch (RemoteException ex) {
    // no window manager? good luck with that
    }
    if (mRecreating) {
    } else {
        addActiveDisplayView();
    }
    // figure out which pixel-format to use for the status bar.
    mPixelFormat = PixelFormat.OPAQUE;
    mSystemIconArea = (LinearLayout) mStatusBarView.findViewById(R.id.system_icon_area);
    mStatusIcons = (LinearLayout) mStatusBarView.findViewById(R.id.statusIcons);
    mNotificationIcons = (IconMerger) mStatusBarView.findViewById(R.id.notificationIcons);
    mMoreIcon = mStatusBarView.findViewById(R.id.moreIcon);
    mNotificationIcons.setOverflowIndicator(mMoreIcon);
    mStatusBarContents = (LinearLayout) mStatusBarView.findViewById(R.id.status_bar_contents);
    mTickerView = mStatusBarView.findViewById(R.id.ticker);
    mPile = (NotificationRowLayout) mStatusBarWindow.findViewById(R.id.latestItems);
    mPile.setLayoutTransitionsEnabled(false);
    mPile.setLongPressListener(getNotificationLongClicker());
    // was: expanded.findViewById(R.id.notificationLinearLayout);
    mExpandedContents = mPile;
    mNotificationPanelHeader = mStatusBarWindow.findViewById(R.id.header);
    mStatusHeaderMachine = new StatusHeaderMachine(mContext);
    mStatusHeaderImage = (ImageView) mNotificationPanelHeader.findViewById(R.id.header_background_image);
    mHeaderOverlay = res.getDrawable(R.drawable.bg_custom_header_overlay);
    updateCustomHeaderStatus();
    mClearButton = mStatusBarWindow.findViewById(R.id.clear_all_button);
    mClearButton.setOnClickListener(mClearButtonListener);
    mClearButton.setAlpha(0f);
    mClearButton.setVisibility(View.INVISIBLE);
    mClearButton.setEnabled(false);
    mDateView = (DateView) mStatusBarWindow.findViewById(R.id.date);
    if (mDateView != null) {
        mDateView.setOnClickListener(mCalendarClickListener);
        mDateView.setEnabled(true);
    }
    mClockView = mNotificationPanelHeader.findViewById(R.id.clock);
    if (mClockView != null) {
        mClockView.setOnClickListener(mClockClickListener);
        mClockView.setEnabled(true);
    }
    mHasSettingsPanel = res.getBoolean(R.bool.config_hasSettingsPanel);
    mHasFlipSettings = res.getBoolean(R.bool.config_hasFlipSettingsPanel);
    mDateTimeView = mNotificationPanelHeader.findViewById(R.id.datetime);
    mSettingsButton = (ImageView) mStatusBarWindow.findViewById(R.id.settings_button);
    if (mSettingsButton != null) {
        mSettingsButton.setOnClickListener(mSettingsButtonListener);
        if (mHasSettingsPanel) {
            if (mStatusBarView.hasFullWidthNotifications()) {
                // the settings panel is hiding behind this button
                mSettingsButton.setImageResource(R.drawable.ic_notify_quicksettings);
                mSettingsButton.setVisibility(View.VISIBLE);
            } else {
                // there is a settings panel, but it's on the other side of the (large) screen
                final View buttonHolder = mStatusBarWindow.findViewById(R.id.settings_button_holder);
                if (buttonHolder != null) {
                    buttonHolder.setVisibility(View.GONE);
                }
            }
        } else {
            // no settings panel, go straight to settings
            mSettingsButton.setVisibility(View.VISIBLE);
            mSettingsButton.setImageResource(R.drawable.ic_notify_settings);
        }
    }
    if (mHasFlipSettings) {
        mNotificationButton = (ImageView) mStatusBarWindow.findViewById(R.id.notification_button);
        if (mNotificationButton != null) {
            mNotificationButton.setOnClickListener(mNotificationButtonListener);
        }
    }
    mScrollView = (ScrollView) mStatusBarWindow.findViewById(R.id.scroll);
    // less drawing during pulldowns
    mScrollView.setVerticalScrollBarEnabled(false);
    if (!mNotificationPanelIsFullScreenWidth) {
        mScrollView.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_NOTIFICATION_ICONS | View.STATUS_BAR_DISABLE_CLOCK);
    }
    mTicker = new MyTicker(context, mStatusBarView);
    TickerView tickerView = (TickerView) mStatusBarView.findViewById(R.id.tickerText);
    tickerView.mTicker = mTicker;
    mEdgeBorder = res.getDimensionPixelSize(R.dimen.status_bar_edge_ignore);
    // set the inital view visibility
    setAreThereNotifications();
    // Other icons
    // will post a notification
    mLocationController = new LocationController(mContext);
    mBatteryController = new BatteryController(mContext);
    mNetworkController = new NetworkController(mContext);
    mBluetoothController = new BluetoothController(mContext);
    mRotationLockController = new RotationLockController(mContext);
    final SignalClusterView signalCluster = (SignalClusterView) mStatusBarView.findViewById(R.id.signal_cluster);
    mNetworkController.addSignalCluster(signalCluster);
    signalCluster.setNetworkController(mNetworkController);
    final boolean isAPhone = mNetworkController.hasVoiceCallingFeature();
    if (isAPhone) {
        mEmergencyCallLabel = (TextView) mStatusBarWindow.findViewById(R.id.emergency_calls_only);
        if (mEmergencyCallLabel != null) {
            mNetworkController.addEmergencyLabelView(mEmergencyCallLabel);
            mEmergencyCallLabel.setOnClickListener(new View.OnClickListener() {

                public void onClick(View v) {
                }
            });
            mEmergencyCallLabel.addOnLayoutChangeListener(new View.OnLayoutChangeListener() {

                @Override
                public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
                    updateCarrierLabelVisibility(false);
                }
            });
        }
    }
    mCarrierLabel = (TextView) mStatusBarWindow.findViewById(R.id.carrier_label);
    mShowCarrierInPanel = (mCarrierLabel != null);
    if (DEBUG)
        Log.v(TAG, "carrierlabel=" + mCarrierLabel + " show=" + mShowCarrierInPanel);
    if (mShowCarrierInPanel) {
        mCarrierLabel.setVisibility(mCarrierLabelVisible ? View.VISIBLE : View.INVISIBLE);
        // for other devices, we show whatever network is connected
        if (mNetworkController.hasMobileDataFeature()) {
            mNetworkController.addMobileLabelView(mCarrierLabel);
        } else {
            mNetworkController.addCombinedLabelView(mCarrierLabel);
        }
        // set up the dynamic hide/show of the label
        mPile.setOnSizeChangedListener(new OnSizeChangedListener() {

            @Override
            public void onSizeChanged(View view, int w, int h, int oldw, int oldh) {
                updateCarrierLabelVisibility(false);
            }
        });
    }
    // Quick Settings (where available, some restrictions apply)
    if (mHasSettingsPanel) {
        // first, figure out where quick settings should be inflated
        final View settings_stub;
        if (mHasFlipSettings) {
            // a version of quick settings that flips around behind the notifications
            settings_stub = mStatusBarWindow.findViewById(R.id.flip_settings_stub);
            if (settings_stub != null) {
                mFlipSettingsView = ((ViewStub) settings_stub).inflate();
                mFlipSettingsView.setVisibility(View.GONE);
                mFlipSettingsView.setVerticalScrollBarEnabled(false);
                mEditModeButton = (ImageView) mStatusBarWindow.findViewById(R.id.edit_mode_button);
                mEditModeButton.setVisibility(View.INVISIBLE);
            }
        } else {
            // full quick settings panel
            settings_stub = mStatusBarWindow.findViewById(R.id.quick_settings_stub);
            if (settings_stub != null) {
                mSettingsPanel = (SettingsPanelView) ((ViewStub) settings_stub).inflate();
            } else {
                mSettingsPanel = (SettingsPanelView) mStatusBarWindow.findViewById(R.id.settings_panel);
            }
            if (mSettingsPanel != null) {
                if (!ActivityManager.isHighEndGfx()) {
                    mSettingsPanel.setBackground(new FastColorDrawable(context.getResources().getColor(R.color.notification_panel_solid_background)));
                }
                mEditModeButton = (ImageView) mSettingsPanel.findViewById(R.id.edit_mode_button);
            }
        }
        // wherever you find it, Quick Settings needs a container to survive
        mSettingsContainer = (QuickSettingsContainerView) mStatusBarWindow.findViewById(R.id.quick_settings_container);
        if (mSettingsContainer != null) {
            mQS = new QuickSettings(mContext, mSettingsContainer);
            if (!mNotificationPanelIsFullScreenWidth) {
                mSettingsContainer.setSystemUiVisibility(View.STATUS_BAR_DISABLE_NOTIFICATION_TICKER | View.STATUS_BAR_DISABLE_SYSTEM_INFO);
            }
            if (mSettingsPanel != null) {
                mSettingsPanel.setQuickSettings(mQS);
            }
            mQS.setService(this);
            mQS.setBar(mStatusBarView);
            mQS.setup(mNetworkController, mBluetoothController, mBatteryController, mLocationController, mRotationLockController);
            if (mEditModeButton != null) {
                mEditModeButton.setOnClickListener(mEditModeButtonListener);
                mEditModeButton.setOnLongClickListener(mEditModeLongButtonListener);
                mEditModeButton.setEnabled(true);
            }
            // set edit mode changed listener
            mSettingsContainer.setOnEditModeChangedListener(new QuickSettingsContainerView.EditModeChangedListener() {

                @Override
                public void onEditModeChanged(final boolean enabled) {
                    mEditModeButton.setImageResource(enabled ? R.drawable.ic_notify_edit_save : R.drawable.ic_notify_edit_normal);
                }
            });
        } else {
            // fly away, be free
            mQS = null;
        }
    }
    PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
    mBroadcastReceiver.onReceive(mContext, new Intent(pm.isScreenOn() ? Intent.ACTION_SCREEN_ON : Intent.ACTION_SCREEN_OFF));
    // receive broadcasts
    IntentFilter filter = new IntentFilter();
    filter.addAction(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
    filter.addAction(Intent.ACTION_SCREEN_OFF);
    filter.addAction(Intent.ACTION_SCREEN_ON);
    filter.addAction(ACTION_DEMO);
    context.registerReceiver(mBroadcastReceiver, filter);
    // listen for USER_SETUP_COMPLETE setting (per-user)
    resetUserSetupObserver();
    mVelocityTracker = VelocityTracker.obtain();
    mBattery = (BatteryMeterView) mStatusBarView.findViewById(R.id.battery);
    mCircleBattery = (BatteryCircleMeterView) mStatusBarView.findViewById(R.id.circle_battery);
    return mStatusBarView;
}
#end_block

#method_before
private void updateCustomHeaderStatus() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean customHeader = Settings.System.getInt(resolver, Settings.System.STATUS_BAR_CUSTOM_HEADER, 0) == 1;
    if (mNotificationPanelHeader == null)
        return;
    // Setup the updating notification bar header image
    if (customHeader) {
        if (mStatusHeaderUpdater == null) {
            mStatusHeaderUpdater = new Runnable() {

                private Drawable mPrevious = mNotificationPanelHeader.getBackground();

                public void run() {
                    Drawable next = mStatusHeaderMachine.getCurrent();
                    if (next != mPrevious) {
                        Log.i(TAG, "Updating status bar header background");
                        setNotificationPanelHeaderBackground(next);
                        mPrevious = next;
                    }
                    // Check every hour. As postDelayed isn't holding a wakelock, it will basically
                    // only check when the CPU is on. Thus, not consuming battery overnight.
                    mHandler.postDelayed(this, 1000 * 3600);
                }
            };
        }
        // Cancel any eventual ongoing statusHeaderUpdater, and start a clean one
        mHandler.removeCallbacks(mStatusHeaderUpdater);
        mHandler.post(mStatusHeaderUpdater);
    } else {
        if (mStatusHeaderUpdater != null) {
            mHandler.removeCallbacks(mStatusHeaderUpdater);
        }
        setNotificationPanelHeaderBackground(mStatusHeaderMachine.getDefault());
    }
}
#method_after
private void updateCustomHeaderStatus() {
    ContentResolver resolver = mContext.getContentResolver();
    boolean customHeader = Settings.System.getInt(resolver, Settings.System.STATUS_BAR_CUSTOM_HEADER, 0) == 1;
    if (mNotificationPanelHeader == null)
        return;
    // Setup the updating notification bar header image
    if (customHeader) {
        if (mStatusHeaderUpdater == null) {
            mStatusHeaderUpdater = new Runnable() {

                private Drawable mPrevious = mNotificationPanelHeader.getBackground();

                public void run() {
                    Drawable next = mStatusHeaderMachine.getCurrent();
                    Log.i(TAG, "Updating status bar header background");
                    setNotificationPanelHeaderBackground(next);
                    mPrevious = next;
                    // Check every hour. As postDelayed isn't holding a wakelock, it will basically
                    // only check when the CPU is on. Thus, not consuming battery overnight.
                    mHandler.postDelayed(this, 1000 * 3600);
                }
            };
        }
        // Cancel any eventual ongoing statusHeaderUpdater, and start a clean one
        mHandler.removeCallbacks(mStatusHeaderUpdater);
        mHandler.post(mStatusHeaderUpdater);
    } else {
        if (mStatusHeaderUpdater != null) {
            mHandler.removeCallbacks(mStatusHeaderUpdater);
        }
        setNotificationPanelHeaderBackground(mStatusHeaderMachine.getDefault());
    }
}
#end_block

#method_before
private void setNotificationPanelHeaderBackground(final Drawable dw) {
    Drawable[] arrayDrawable = new Drawable[2];
    if (dw instanceof BitmapDrawable) {
        BitmapDrawable bdw = (BitmapDrawable) dw;
        bdw.setGravity(Gravity.TOP);
    }
    if (!(dw instanceof BitmapDrawable) && !(mNotificationPanelHeader.getBackground() instanceof BitmapDrawable) && !(mNotificationPanelHeader.getBackground() instanceof TransitionDrawable)) {
        return;
    }
    arrayDrawable[0] = mNotificationPanelHeader.getBackground();
    arrayDrawable[1] = dw;
    TransitionDrawable transitionDrawable = new TransitionDrawable(arrayDrawable);
    transitionDrawable.setCrossFadeEnabled(true);
    mNotificationPanelHeader.setBackgroundDrawable(transitionDrawable);
    transitionDrawable.startTransition(1000);
}
#method_after
private void setNotificationPanelHeaderBackground(Drawable dwSrc) {
    Drawable[] arrayDrawable = new Drawable[2];
    // Overlay a dark gradient
    arrayDrawable[0] = dwSrc;
    arrayDrawable[1] = mHeaderOverlay;
    final Drawable dw = new LayerDrawable(arrayDrawable);
    // Transition animation
    arrayDrawable[0] = mStatusHeaderImage.getDrawable();
    arrayDrawable[1] = dw;
    if (arrayDrawable[0] != null) {
        TransitionDrawable transitionDrawable = new TransitionDrawable(arrayDrawable);
        transitionDrawable.setCrossFadeEnabled(true);
        mStatusHeaderImage.setImageDrawable(transitionDrawable);
        transitionDrawable.startTransition(1000);
    } else {
        mStatusHeaderImage.setImageDrawable(dw);
    }
}
#end_block

#method_before
@Override
protected void refreshLayout(int layoutDirection) {
    if (mNavigationBarView != null) {
        mNavigationBarView.setLayoutDirection(layoutDirection);
    }
    if (mClearButton != null && mClearButton instanceof ImageView) {
        // Force asset reloading
        ((ImageView) mClearButton).setImageDrawable(null);
        ((ImageView) mClearButton).setImageResource(R.drawable.ic_notify_clear);
    }
    if (mSettingsButton != null) {
        // Force asset reloading
        mSettingsButton.setImageDrawable(null);
        mSettingsButton.setImageResource(R.drawable.ic_notify_quicksettings);
    }
    if (mNotificationButton != null) {
        // Force asset reloading
        mNotificationButton.setImageDrawable(null);
        mNotificationButton.setImageResource(R.drawable.ic_notifications);
    }
    refreshAllStatusBarIcons();
}
#method_after
@Override
protected void refreshLayout(int layoutDirection) {
    if (mNavigationBarView != null) {
        mNavigationBarView.setLayoutDirection(layoutDirection);
    }
    if (mClearButton != null && mClearButton instanceof ImageView) {
        // Force asset reloading
        ((ImageView) mClearButton).setImageDrawable(null);
        ((ImageView) mClearButton).setImageResource(R.drawable.ic_notify_clear);
    }
    if (mEditModeButton != null) {
        // Force asset reloading
        mEditModeButton.setImageDrawable(null);
        mEditModeButton.setImageResource(R.drawable.ic_notify_edit_normal);
    }
    if (mSettingsButton != null) {
        // Force asset reloading
        mSettingsButton.setImageDrawable(null);
        mSettingsButton.setImageResource(R.drawable.ic_notify_quicksettings);
    }
    if (mNotificationButton != null) {
        // Force asset reloading
        mNotificationButton.setImageDrawable(null);
        mNotificationButton.setImageResource(R.drawable.ic_notifications);
    }
    refreshAllStatusBarIcons();
}
#end_block

#method_before
public void flipToNotifications() {
    if (mFlipSettingsViewAnim != null)
        mFlipSettingsViewAnim.cancel();
    if (mScrollViewAnim != null)
        mScrollViewAnim.cancel();
    if (mSettingsButtonAnim != null)
        mSettingsButtonAnim.cancel();
    if (mNotificationButtonAnim != null)
        mNotificationButtonAnim.cancel();
    if (mClearButtonAnim != null)
        mClearButtonAnim.cancel();
    mScrollView.setVisibility(View.VISIBLE);
    mScrollViewAnim = start(startDelay(FLIP_DURATION_OUT, interpolator(mDecelerateInterpolator, ObjectAnimator.ofFloat(mScrollView, View.SCALE_X, 0f, 1f).setDuration(FLIP_DURATION_IN))));
    mFlipSettingsViewAnim = start(setVisibilityWhenDone(interpolator(mAccelerateInterpolator, ObjectAnimator.ofFloat(mFlipSettingsView, View.SCALE_X, 1f, 0f)).setDuration(FLIP_DURATION_OUT), mFlipSettingsView, View.INVISIBLE));
    mNotificationButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mNotificationButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mNotificationButton, View.INVISIBLE));
    mSettingsButton.setVisibility(View.VISIBLE);
    mSettingsButtonAnim = start(ObjectAnimator.ofFloat(mSettingsButton, View.ALPHA, 1f).setDuration(FLIP_DURATION));
    mClearButton.setVisibility(View.VISIBLE);
    mClearButton.setAlpha(0f);
    // this will show/hide the button as necessary
    setAreThereNotifications();
    mNotificationPanel.postDelayed(new Runnable() {

        public void run() {
            updateCarrierLabelVisibility(false);
        }
    }, FLIP_DURATION - 150);
}
#method_after
public void flipToNotifications() {
    if (mFlipSettingsViewAnim != null)
        mFlipSettingsViewAnim.cancel();
    if (mScrollViewAnim != null)
        mScrollViewAnim.cancel();
    if (mSettingsButtonAnim != null)
        mSettingsButtonAnim.cancel();
    if (mNotificationButtonAnim != null)
        mNotificationButtonAnim.cancel();
    if (mEditModeButtonAnim != null)
        mEditModeButtonAnim.cancel();
    if (mClearButtonAnim != null)
        mClearButtonAnim.cancel();
    mScrollView.setVisibility(View.VISIBLE);
    mScrollViewAnim = start(startDelay(FLIP_DURATION_OUT, interpolator(mDecelerateInterpolator, ObjectAnimator.ofFloat(mScrollView, View.SCALE_X, 0f, 1f).setDuration(FLIP_DURATION_IN))));
    mFlipSettingsViewAnim = start(setVisibilityWhenDone(interpolator(mAccelerateInterpolator, ObjectAnimator.ofFloat(mFlipSettingsView, View.SCALE_X, 1f, 0f)).setDuration(FLIP_DURATION_OUT), mFlipSettingsView, View.INVISIBLE));
    mNotificationButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mNotificationButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mNotificationButton, View.INVISIBLE));
    mSettingsButton.setVisibility(View.VISIBLE);
    mSettingsButtonAnim = start(ObjectAnimator.ofFloat(mSettingsButton, View.ALPHA, 1f).setDuration(FLIP_DURATION));
    mEditModeButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mEditModeButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mEditModeButton, View.INVISIBLE));
    mClearButton.setVisibility(View.VISIBLE);
    mClearButton.setAlpha(0f);
    // this will show/hide the button as necessary
    setAreThereNotifications();
    mNotificationPanel.postDelayed(new Runnable() {

        public void run() {
            updateCarrierLabelVisibility(false);
        }
    }, FLIP_DURATION - 150);
}
#end_block

#method_before
public void switchToSettings() {
    // Settings are not available in setup
    if (!mUserSetup)
        return;
    mFlipSettingsView.setScaleX(1f);
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mSettingsButton.setVisibility(View.GONE);
    mScrollView.setVisibility(View.GONE);
    mScrollView.setScaleX(0f);
    mNotificationButton.setVisibility(View.VISIBLE);
    mNotificationButton.setAlpha(1f);
    mClearButton.setVisibility(View.GONE);
}
#method_after
public void switchToSettings() {
    // Settings are not available in setup
    if (!mUserSetup)
        return;
    mFlipSettingsView.setScaleX(1f);
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mSettingsButton.setVisibility(View.GONE);
    mScrollView.setVisibility(View.GONE);
    mScrollView.setScaleX(0f);
    mNotificationButton.setVisibility(View.VISIBLE);
    mNotificationButton.setAlpha(1f);
    mEditModeButton.setVisibility(View.VISIBLE);
    mEditModeButton.setAlpha(1f);
    mClearButton.setVisibility(View.GONE);
}
#end_block

#method_before
public void flipToSettings() {
    // Settings are not available in setup
    if (!mUserSetup)
        return;
    if (mFlipSettingsViewAnim != null)
        mFlipSettingsViewAnim.cancel();
    if (mScrollViewAnim != null)
        mScrollViewAnim.cancel();
    if (mSettingsButtonAnim != null)
        mSettingsButtonAnim.cancel();
    if (mNotificationButtonAnim != null)
        mNotificationButtonAnim.cancel();
    if (mClearButtonAnim != null)
        mClearButtonAnim.cancel();
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mFlipSettingsView.setScaleX(0f);
    mFlipSettingsViewAnim = start(startDelay(FLIP_DURATION_OUT, interpolator(mDecelerateInterpolator, ObjectAnimator.ofFloat(mFlipSettingsView, View.SCALE_X, 0f, 1f).setDuration(FLIP_DURATION_IN))));
    mScrollViewAnim = start(setVisibilityWhenDone(interpolator(mAccelerateInterpolator, ObjectAnimator.ofFloat(mScrollView, View.SCALE_X, 1f, 0f)).setDuration(FLIP_DURATION_OUT), mScrollView, View.INVISIBLE));
    mSettingsButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mSettingsButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mScrollView, View.INVISIBLE));
    mNotificationButton.setVisibility(View.VISIBLE);
    mNotificationButtonAnim = start(ObjectAnimator.ofFloat(mNotificationButton, View.ALPHA, 1f).setDuration(FLIP_DURATION));
    mClearButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mClearButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mClearButton, View.INVISIBLE));
    mNotificationPanel.postDelayed(new Runnable() {

        public void run() {
            updateCarrierLabelVisibility(false);
        }
    }, FLIP_DURATION - 150);
}
#method_after
public void flipToSettings() {
    // Settings are not available in setup
    if (!mUserSetup)
        return;
    if (mFlipSettingsViewAnim != null)
        mFlipSettingsViewAnim.cancel();
    if (mScrollViewAnim != null)
        mScrollViewAnim.cancel();
    if (mSettingsButtonAnim != null)
        mSettingsButtonAnim.cancel();
    if (mNotificationButtonAnim != null)
        mNotificationButtonAnim.cancel();
    if (mEditModeButtonAnim != null)
        mEditModeButtonAnim.cancel();
    if (mClearButtonAnim != null)
        mClearButtonAnim.cancel();
    mFlipSettingsView.setVisibility(View.VISIBLE);
    mFlipSettingsView.setScaleX(0f);
    mFlipSettingsViewAnim = start(startDelay(FLIP_DURATION_OUT, interpolator(mDecelerateInterpolator, ObjectAnimator.ofFloat(mFlipSettingsView, View.SCALE_X, 0f, 1f).setDuration(FLIP_DURATION_IN))));
    mScrollViewAnim = start(setVisibilityWhenDone(interpolator(mAccelerateInterpolator, ObjectAnimator.ofFloat(mScrollView, View.SCALE_X, 1f, 0f)).setDuration(FLIP_DURATION_OUT), mScrollView, View.INVISIBLE));
    mSettingsButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mSettingsButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mScrollView, View.INVISIBLE));
    mNotificationButton.setVisibility(View.VISIBLE);
    mNotificationButtonAnim = start(ObjectAnimator.ofFloat(mNotificationButton, View.ALPHA, 1f).setDuration(FLIP_DURATION));
    mEditModeButton.setVisibility(View.VISIBLE);
    mEditModeButtonAnim = start(ObjectAnimator.ofFloat(mEditModeButton, View.ALPHA, 1f).setDuration(FLIP_DURATION));
    mClearButtonAnim = start(setVisibilityWhenDone(ObjectAnimator.ofFloat(mClearButton, View.ALPHA, 0f).setDuration(FLIP_DURATION), mClearButton, View.INVISIBLE));
    mNotificationPanel.postDelayed(new Runnable() {

        public void run() {
            updateCarrierLabelVisibility(false);
        }
    }, FLIP_DURATION - 150);
}
#end_block

#method_before
void makeExpandedInvisible() {
    if (SPEW)
        Log.d(TAG, "makeExpandedInvisible: mExpandedVisible=" + mExpandedVisible + " mExpandedVisible=" + mExpandedVisible);
    if (!mExpandedVisible) {
        return;
    }
    // Ensure the panel is fully collapsed (just in case; bug 6765842, 7260868)
    mStatusBarView.collapseAllPanels(/*animate=*/
    false);
    if (mHasFlipSettings) {
        // reset things to their proper state
        if (mFlipSettingsViewAnim != null)
            mFlipSettingsViewAnim.cancel();
        if (mScrollViewAnim != null)
            mScrollViewAnim.cancel();
        if (mSettingsButtonAnim != null)
            mSettingsButtonAnim.cancel();
        if (mNotificationButtonAnim != null)
            mNotificationButtonAnim.cancel();
        if (mClearButtonAnim != null)
            mClearButtonAnim.cancel();
        mScrollView.setScaleX(1f);
        mScrollView.setVisibility(View.VISIBLE);
        mSettingsButton.setAlpha(1f);
        mSettingsButton.setVisibility(View.VISIBLE);
        mNotificationPanel.setVisibility(View.GONE);
        mFlipSettingsView.setVisibility(View.GONE);
        mNotificationButton.setVisibility(View.GONE);
        // show the clear button
        setAreThereNotifications();
    }
    mExpandedVisible = false;
    mPile.setLayoutTransitionsEnabled(false);
    if (mNavigationBarView != null)
        mNavigationBarView.setSlippery(false);
    visibilityChanged(false);
    // Shrink the window to the size of the status bar only
    WindowManager.LayoutParams lp = (WindowManager.LayoutParams) mStatusBarWindow.getLayoutParams();
    lp.height = getStatusBarHeight();
    lp.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    lp.flags &= ~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
    mWindowManager.updateViewLayout(mStatusBarWindow, lp);
    if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        setNotificationIconVisibility(true, com.android.internal.R.anim.fade_in);
    }
    // Close any "App info" popups that might have snuck on-screen
    dismissPopups();
    if (mPostCollapseCleanup != null) {
        mPostCollapseCleanup.run();
        mPostCollapseCleanup = null;
    }
    setInteracting(StatusBarManager.WINDOW_STATUS_BAR, false);
}
#method_after
void makeExpandedInvisible() {
    if (SPEW)
        Log.d(TAG, "makeExpandedInvisible: mExpandedVisible=" + mExpandedVisible + " mExpandedVisible=" + mExpandedVisible);
    if (!mExpandedVisible) {
        return;
    }
    // Ensure the panel is fully collapsed (just in case; bug 6765842, 7260868)
    mStatusBarView.collapseAllPanels(/*animate=*/
    false);
    if (mHasFlipSettings) {
        // reset things to their proper state
        if (mFlipSettingsViewAnim != null)
            mFlipSettingsViewAnim.cancel();
        if (mScrollViewAnim != null)
            mScrollViewAnim.cancel();
        if (mSettingsButtonAnim != null)
            mSettingsButtonAnim.cancel();
        if (mNotificationButtonAnim != null)
            mNotificationButtonAnim.cancel();
        if (mEditModeButtonAnim != null)
            mEditModeButtonAnim.cancel();
        if (mClearButtonAnim != null)
            mClearButtonAnim.cancel();
        mScrollView.setScaleX(1f);
        mScrollView.setVisibility(View.VISIBLE);
        mSettingsButton.setAlpha(1f);
        mSettingsButton.setVisibility(View.VISIBLE);
        mNotificationPanel.setVisibility(View.GONE);
        mFlipSettingsView.setVisibility(View.GONE);
        mNotificationButton.setVisibility(View.GONE);
        mEditModeButton.setVisibility(View.GONE);
        // show the clear button
        setAreThereNotifications();
    }
    mExpandedVisible = false;
    mPile.setLayoutTransitionsEnabled(false);
    if (mNavigationBarView != null)
        mNavigationBarView.setSlippery(false);
    visibilityChanged(false);
    // Shrink the window to the size of the status bar only
    WindowManager.LayoutParams lp = (WindowManager.LayoutParams) mStatusBarWindow.getLayoutParams();
    lp.height = getStatusBarHeight();
    lp.flags |= WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;
    lp.flags &= ~WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM;
    mWindowManager.updateViewLayout(mStatusBarWindow, lp);
    if ((mDisabled & StatusBarManager.DISABLE_NOTIFICATION_ICONS) == 0) {
        setNotificationIconVisibility(true, com.android.internal.R.anim.fade_in);
    }
    // Close any "App info" popups that might have snuck on-screen
    dismissPopups();
    if (mPostCollapseCleanup != null) {
        mPostCollapseCleanup.run();
        mPostCollapseCleanup = null;
    }
    setInteracting(StatusBarManager.WINDOW_STATUS_BAR, false);
}
#end_block

#method_before
public void systemRunning(StatusBarManagerService statusBar) {
    synchronized (mMethodMap) {
        if (DEBUG) {
            Slog.d(TAG, "--- systemReady");
        }
        if (!mSystemReady) {
            mSystemReady = true;
            mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
            mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
            mStatusBar = statusBar;
            statusBar.setIconVisibility("ime", false);
            updateImeWindowStatusLocked();
            mShowOngoingImeSwitcherForPhones = mRes.getBoolean(com.android.internal.R.bool.show_ongoing_ime_switcher);
            if (mShowOngoingImeSwitcherForPhones) {
                mWindowManagerService.setOnHardKeyboardStatusChangeListener(mHardKeyboardListener);
            }
            buildInputMethodListLocked(mMethodList, mMethodMap, !mImeSelectedOnBoot);
            if (!mImeSelectedOnBoot) {
                Slog.w(TAG, "Reset the default IME as \"Resource\" is ready here.");
                resetStateIfCurrentLocaleChangedLocked();
                InputMethodUtils.setNonSelectedSystemImesDisabledUntilUsed(mContext.getPackageManager(), mSettings.getEnabledInputMethodListLocked());
            }
            mLastSystemLocale = mRes.getConfiguration().locale;
            try {
                startInputInnerLocked();
            } catch (RuntimeException e) {
                Slog.w(TAG, "Unexpected exception", e);
            }
        }
    }
}
#method_after
public void systemRunning(StatusBarManagerService statusBar) {
    synchronized (mMethodMap) {
        if (DEBUG) {
            Slog.d(TAG, "--- systemReady");
        }
        if (!mSystemReady) {
            mSystemReady = true;
            mKeyguardManager = (KeyguardManager) mContext.getSystemService(Context.KEYGUARD_SERVICE);
            mNotificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
            mStatusBar = statusBar;
            statusBar.setIconVisibility("ime", false);
            updateImeWindowStatusLocked();
            if (isShowOngoingImeSwitcherForPhones()) {
                mWindowManagerService.setOnHardKeyboardStatusChangeListener(mHardKeyboardListener);
            }
            buildInputMethodListLocked(mMethodList, mMethodMap, !mImeSelectedOnBoot);
            if (!mImeSelectedOnBoot) {
                Slog.w(TAG, "Reset the default IME as \"Resource\" is ready here.");
                resetStateIfCurrentLocaleChangedLocked();
                InputMethodUtils.setNonSelectedSystemImesDisabledUntilUsed(mContext.getPackageManager(), mSettings.getEnabledInputMethodListLocked());
            }
            mLastSystemLocale = mRes.getConfiguration().locale;
            try {
                startInputInnerLocked();
            } catch (RuntimeException e) {
                Slog.w(TAG, "Unexpected exception", e);
            }
        }
    }
}
#end_block

#method_before
void updateFromSettingsLocked(boolean enabledMayChange) {
    if (enabledMayChange) {
        List<InputMethodInfo> enabled = mSettings.getEnabledInputMethodListLocked();
        for (int i = 0; i < enabled.size(); i++) {
            // We allow the user to select "disabled until used" apps, so if they
            // are enabling one of those here we now need to make it enabled.
            InputMethodInfo imm = enabled.get(i);
            try {
                ApplicationInfo ai = mIPackageManager.getApplicationInfo(imm.getPackageName(), PackageManager.GET_DISABLED_UNTIL_USED_COMPONENTS, mSettings.getCurrentUserId());
                if (ai != null && ai.enabledSetting == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED) {
                    if (DEBUG) {
                        Slog.d(TAG, "Update state(" + imm.getId() + "): DISABLED_UNTIL_USED -> DEFAULT");
                    }
                    mIPackageManager.setApplicationEnabledSetting(imm.getPackageName(), PackageManager.COMPONENT_ENABLED_STATE_DEFAULT, PackageManager.DONT_KILL_APP, mSettings.getCurrentUserId(), mContext.getBasePackageName());
                }
            } catch (RemoteException e) {
            }
        }
    }
    // We are assuming that whoever is changing DEFAULT_INPUT_METHOD and
    // ENABLED_INPUT_METHODS is taking care of keeping them correctly in
    // sync, so we will never have a DEFAULT_INPUT_METHOD that is not
    // enabled.
    String id = mSettings.getSelectedInputMethod();
    // There is no input method selected, try to choose new applicable input method.
    if (TextUtils.isEmpty(id) && chooseNewDefaultIMELocked()) {
        id = mSettings.getSelectedInputMethod();
    }
    if (!TextUtils.isEmpty(id)) {
        try {
            setInputMethodLocked(id, mSettings.getSelectedInputMethodSubtypeId(id));
        } catch (IllegalArgumentException e) {
            Slog.w(TAG, "Unknown input method from prefs: " + id, e);
            mCurMethodId = null;
            unbindCurrentMethodLocked(true, false);
        }
        mShortcutInputMethodsAndSubtypes.clear();
    } else {
        // There is no longer an input method set, so stop any current one.
        mCurMethodId = null;
        unbindCurrentMethodLocked(true, false);
    }
    // code to disable the IME switcher with config_show_IMESwitcher set = false
    try {
        mShowOngoingImeSwitcherForPhones = Settings.System.getIntForUser(mContext.getContentResolver(), Settings.System.STATUS_BAR_IME_SWITCHER, UserHandle.USER_CURRENT) == 1;
    } catch (SettingNotFoundException e) {
        mShowOngoingImeSwitcherForPhones = mRes.getBoolean(com.android.internal.R.bool.config_show_IMESwitcher);
    }
}
#method_after
void updateFromSettingsLocked(boolean enabledMayChange) {
    if (enabledMayChange) {
        List<InputMethodInfo> enabled = mSettings.getEnabledInputMethodListLocked();
        for (int i = 0; i < enabled.size(); i++) {
            // We allow the user to select "disabled until used" apps, so if they
            // are enabling one of those here we now need to make it enabled.
            InputMethodInfo imm = enabled.get(i);
            try {
                ApplicationInfo ai = mIPackageManager.getApplicationInfo(imm.getPackageName(), PackageManager.GET_DISABLED_UNTIL_USED_COMPONENTS, mSettings.getCurrentUserId());
                if (ai != null && ai.enabledSetting == PackageManager.COMPONENT_ENABLED_STATE_DISABLED_UNTIL_USED) {
                    if (DEBUG) {
                        Slog.d(TAG, "Update state(" + imm.getId() + "): DISABLED_UNTIL_USED -> DEFAULT");
                    }
                    mIPackageManager.setApplicationEnabledSetting(imm.getPackageName(), PackageManager.COMPONENT_ENABLED_STATE_DEFAULT, PackageManager.DONT_KILL_APP, mSettings.getCurrentUserId(), mContext.getBasePackageName());
                }
            } catch (RemoteException e) {
            }
        }
    }
    // We are assuming that whoever is changing DEFAULT_INPUT_METHOD and
    // ENABLED_INPUT_METHODS is taking care of keeping them correctly in
    // sync, so we will never have a DEFAULT_INPUT_METHOD that is not
    // enabled.
    String id = mSettings.getSelectedInputMethod();
    // There is no input method selected, try to choose new applicable input method.
    if (TextUtils.isEmpty(id) && chooseNewDefaultIMELocked()) {
        id = mSettings.getSelectedInputMethod();
    }
    if (!TextUtils.isEmpty(id)) {
        try {
            setInputMethodLocked(id, mSettings.getSelectedInputMethodSubtypeId(id));
        } catch (IllegalArgumentException e) {
            Slog.w(TAG, "Unknown input method from prefs: " + id, e);
            mCurMethodId = null;
            unbindCurrentMethodLocked(true, false);
        }
        mShortcutInputMethodsAndSubtypes.clear();
    } else {
        // There is no longer an input method set, so stop any current one.
        mCurMethodId = null;
        unbindCurrentMethodLocked(true, false);
    }
    mShowOngoingImeSwitcherForPhones = isShowOngoingImeSwitcherForPhones();
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.active_display_settings);
    mEnabledPref = (SwitchPreference) findPreference(KEY_ENABLED);
    mEnabledPref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ENABLE_ACTIVE_DISPLAY, 0) == 1));
    mEnabledPref.setOnPreferenceChangeListener(this);
    mShowTextPref = (CheckBoxPreference) findPreference(KEY_SHOW_TEXT);
    mShowTextPref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_TEXT, 0) == 1));
    mAllNotificationsPref = (CheckBoxPreference) findPreference(KEY_ALL_NOTIFICATIONS);
    mAllNotificationsPref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS, 0) == 1));
    mPocketModePref = (CheckBoxPreference) findPreference(KEY_POCKET_MODE);
    mPocketModePref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_POCKET_MODE, 0) == 1));
    if (!hasProximitySensor()) {
        getPreferenceScreen().removePreference(mPocketModePref);
    }
    PreferenceScreen prefSet = getPreferenceScreen();
    mRedisplayPref = (ListPreference) prefSet.findPreference(KEY_REDISPLAY);
    mRedisplayPref.setOnPreferenceChangeListener(this);
    long timeout = Settings.System.getLong(getContentResolver(), Settings.System.ACTIVE_DISPLAY_REDISPLAY, 0);
    mRedisplayPref.setValue(String.valueOf(timeout));
    updateRedisplaySummary(timeout);
    mBrightnessLevel = (SeekBarPreference) findPreference(KEY_BRIGHTNESS);
    mBrightnessLevel.setValue(Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_BRIGHTNESS, 100));
    mBrightnessLevel.setOnPreferenceChangeListener(this);
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.active_display_settings);
    mEnabledPref = (SwitchPreference) findPreference(KEY_ENABLED);
    mEnabledPref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ENABLE_ACTIVE_DISPLAY, 0) == 1));
    mEnabledPref.setOnPreferenceChangeListener(this);
    mShowTextPref = (CheckBoxPreference) findPreference(KEY_SHOW_TEXT);
    mShowTextPref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_TEXT, 0) == 1));
    mAllNotificationsPref = (CheckBoxPreference) findPreference(KEY_ALL_NOTIFICATIONS);
    mAllNotificationsPref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS, 0) == 1));
    mHideLowPriorityPref = (CheckBoxPreference) findPreference(KEY_HIDE_LOW_PRIORITY);
    mHideLowPriorityPref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS, 0) == 1));
    mPocketModePref = (ListPreference) findPreference(KEY_POCKET_MODE);
    mPocketModePref.setOnPreferenceChangeListener(this);
    int mode = Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_POCKET_MODE, 0);
    mPocketModePref.setValue(String.valueOf(mode));
    updatePocketModeSummary(mode);
    if (!hasProximitySensor()) {
        getPreferenceScreen().removePreference(mPocketModePref);
    }
    mSunlightModePref = (CheckBoxPreference) findPreference(KEY_SUNLIGHT_MODE);
    mSunlightModePref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE, 0) == 1));
    if (!hasLightSensor()) {
        getPreferenceScreen().removePreference(mSunlightModePref);
    }
    PreferenceScreen prefSet = getPreferenceScreen();
    mRedisplayPref = (ListPreference) prefSet.findPreference(KEY_REDISPLAY);
    mRedisplayPref.setOnPreferenceChangeListener(this);
    long timeout = Settings.System.getLong(getContentResolver(), Settings.System.ACTIVE_DISPLAY_REDISPLAY, 0);
    mRedisplayPref.setValue(String.valueOf(timeout));
    updateRedisplaySummary(timeout);
    mExcludedAppsPref = (AppMultiSelectListPreference) findPreference(KEY_EXCLUDED_APPS);
    Set<String> excludedApps = getExcludedApps();
    if (excludedApps != null)
        mExcludedAppsPref.setValues(excludedApps);
    mExcludedAppsPref.setOnPreferenceChangeListener(this);
    mShowDatePref = (CheckBoxPreference) findPreference(KEY_SHOW_DATE);
    mShowDatePref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_SHOW_DATE, 0) == 1));
    mShowAmPmPref = (CheckBoxPreference) findPreference(KEY_SHOW_AMPM);
    mShowAmPmPref.setChecked((Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_SHOW_AMPM, 0) == 1));
    mBrightnessLevel = (SeekBarPreference) findPreference(KEY_BRIGHTNESS);
    mBrightnessLevel.setValue(Settings.System.getInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_BRIGHTNESS, 100));
    mBrightnessLevel.setOnPreferenceChangeListener(this);
}
#end_block

#method_before
public boolean onPreferenceChange(Preference preference, Object newValue) {
    if (preference == mRedisplayPref) {
        int timeout = Integer.valueOf((String) newValue);
        updateRedisplaySummary(timeout);
        return true;
    } else if (preference == mEnabledPref) {
        Settings.System.putInt(getContentResolver(), Settings.System.ENABLE_ACTIVE_DISPLAY, ((Boolean) newValue).booleanValue() ? 1 : 0);
        return true;
    } else if (preference == mBrightnessLevel) {
        int brightness = ((Integer) newValue).intValue();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_BRIGHTNESS, brightness);
        return true;
    }
    return false;
}
#method_after
public boolean onPreferenceChange(Preference preference, Object newValue) {
    if (preference == mRedisplayPref) {
        int timeout = Integer.valueOf((String) newValue);
        updateRedisplaySummary(timeout);
        return true;
    } else if (preference == mEnabledPref) {
        Settings.System.putInt(getContentResolver(), Settings.System.ENABLE_ACTIVE_DISPLAY, ((Boolean) newValue).booleanValue() ? 1 : 0);
        return true;
    } else if (preference == mPocketModePref) {
        int mode = Integer.valueOf((String) newValue);
        updatePocketModeSummary(mode);
        return true;
    } else if (preference == mExcludedAppsPref) {
        storeExcludedApps((Set<String>) newValue);
        return true;
    } else if (preference == mBrightnessLevel) {
        int brightness = ((Integer) newValue).intValue();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_BRIGHTNESS, brightness);
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
    boolean value;
    if (preference == mShowTextPref) {
        value = mShowTextPref.isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_TEXT, value ? 1 : 0);
    } else if (preference == mAllNotificationsPref) {
        value = mAllNotificationsPref.isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS, value ? 1 : 0);
    } else if (preference == mPocketModePref) {
        value = mPocketModePref.isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_POCKET_MODE, value ? 1 : 0);
    } else {
        return super.onPreferenceTreeClick(preferenceScreen, preference);
    }
    return true;
}
#method_after
@Override
public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
    boolean value;
    if (preference == mShowTextPref) {
        value = mShowTextPref.isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_TEXT, value ? 1 : 0);
    } else if (preference == mAllNotificationsPref) {
        value = mAllNotificationsPref.isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_ALL_NOTIFICATIONS, value ? 1 : 0);
    } else if (preference == mHideLowPriorityPref) {
        value = mHideLowPriorityPref.isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_HIDE_LOW_PRIORITY_NOTIFICATIONS, value ? 1 : 0);
    } else if (preference == mSunlightModePref) {
        value = mSunlightModePref.isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_SUNLIGHT_MODE, value ? 1 : 0);
    } else if (preference == mShowDatePref) {
        value = mShowDatePref.isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_SHOW_DATE, value ? 1 : 0);
    } else if (preference == mShowAmPmPref) {
        value = mShowAmPmPref.isChecked();
        Settings.System.putInt(getContentResolver(), Settings.System.ACTIVE_DISPLAY_SHOW_AMPM, value ? 1 : 0);
    } else {
        return super.onPreferenceTreeClick(preferenceScreen, preference);
    }
    return true;
}
#end_block

#method_before
public static void makeDefaultPhone(Context context) {
    synchronized (Phone.class) {
        if (!sMadeDefaults) {
            sLooper = Looper.myLooper();
            sContext = context;
            if (sLooper == null) {
                throw new RuntimeException("PhoneFactory.makeDefaultPhone must be called from Looper thread");
            }
            int retryCount = 0;
            for (; ; ) {
                boolean hasException = false;
                retryCount++;
                try {
                    // use UNIX domain socket to
                    // prevent subsequent initialization
                    new LocalServerSocket("com.android.internal.telephony");
                } catch (java.io.IOException ex) {
                    hasException = true;
                }
                if (!hasException) {
                    break;
                } else if (retryCount > SOCKET_OPEN_MAX_RETRY) {
                    throw new RuntimeException("PhoneFactory probably already running");
                } else {
                    try {
                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                    } catch (InterruptedException er) {
                    }
                }
            }
            sPhoneNotifier = new DefaultPhoneNotifier();
            // Get preferred network mode
            int preferredNetworkMode = RILConstants.PREFERRED_NETWORK_MODE;
            if (TelephonyManager.getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                preferredNetworkMode = Phone.NT_MODE_GLOBAL;
            }
            int networkMode = Settings.Global.getInt(context.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, preferredNetworkMode);
            Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkMode));
            int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
            Rlog.i(LOG_TAG, "Cdma Subscription set to " + cdmaSubscription);
            // reads the system properties and makes commandsinterface
            String sRILClassname = SystemProperties.get("ro.telephony.ril_class", "RIL").trim();
            Rlog.i(LOG_TAG, "RILClassname is " + sRILClassname);
            // Use reflection to construct the RIL class (defaults to RIL)
            Class<?> classDefinition = null;
            try {
                classDefinition = Class.forName("com.android.internal.telephony." + sRILClassname);
            } catch (Exception e) {
                // Try using the default RIL
                Rlog.e(LOG_TAG, "Invalid RIL Class " + sRILClassname, e);
                sRILClassname = "RIL";
            }
            try {
                if (classDefinition == null) {
                    classDefinition = Class.forName("com.android.internal.telephony." + sRILClassname);
                }
                Constructor<?> constructor = classDefinition.getConstructor(new Class[] { Context.class, int.class, int.class });
                sCommandsInterface = (RIL) constructor.newInstance(new Object[] { context, networkMode, cdmaSubscription });
            } catch (Exception e) {
                // 6 different types of exceptions are thrown here that it's
                // easier to just catch Exception as our "error handling" is the same.
                Rlog.e(LOG_TAG, "Unable to construct command interface", e);
                throw new RuntimeException(e);
            }
            // Instantiate UiccController so that all other classes can just call getInstance()
            UiccController.make(context, sCommandsInterface);
            int phoneType = TelephonyManager.getPhoneType(networkMode);
            if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                Rlog.i(LOG_TAG, "Creating GSMPhone");
                sProxyPhone = new PhoneProxy(new GSMPhone(context, sCommandsInterface, sPhoneNotifier));
            } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                switch(TelephonyManager.getLteOnCdmaModeStatic()) {
                    case PhoneConstants.LTE_ON_CDMA_TRUE:
                        Rlog.i(LOG_TAG, "Creating CDMALTEPhone");
                        sProxyPhone = new PhoneProxy(new CDMALTEPhone(context, sCommandsInterface, sPhoneNotifier));
                        break;
                    case PhoneConstants.LTE_ON_CDMA_FALSE:
                    default:
                        Rlog.i(LOG_TAG, "Creating CDMAPhone");
                        sProxyPhone = new PhoneProxy(new CDMAPhone(context, sCommandsInterface, sPhoneNotifier));
                        break;
                }
            }
            // Ensure that we have a default SMS app. Requesting the app with
            // updateIfNeeded set to true is enough to configure a default SMS app.
            ComponentName componentName = SmsApplication.getDefaultSmsApplication(context, true);
            String packageName = "NONE";
            if (componentName != null) {
                packageName = componentName.getPackageName();
            }
            Rlog.i(LOG_TAG, "defaultSmsApplication: " + packageName);
            // Set up monitor to watch for changes to SMS packages
            SmsApplication.initSmsPackageMonitor(context);
            sMadeDefaults = true;
        }
    }
}
#method_after
public static void makeDefaultPhone(Context context) {
    synchronized (Phone.class) {
        if (!sMadeDefaults) {
            sLooper = Looper.myLooper();
            sContext = context;
            if (sLooper == null) {
                throw new RuntimeException("PhoneFactory.makeDefaultPhone must be called from Looper thread");
            }
            int retryCount = 0;
            for (; ; ) {
                boolean hasException = false;
                retryCount++;
                try {
                    // use UNIX domain socket to
                    // prevent subsequent initialization
                    new LocalServerSocket("com.android.internal.telephony");
                } catch (java.io.IOException ex) {
                    hasException = true;
                }
                if (!hasException) {
                    break;
                } else if (retryCount > SOCKET_OPEN_MAX_RETRY) {
                    throw new RuntimeException("PhoneFactory probably already running");
                } else {
                    try {
                        Thread.sleep(SOCKET_OPEN_RETRY_MILLIS);
                    } catch (InterruptedException er) {
                    }
                }
            }
            sPhoneNotifier = new DefaultPhoneNotifier();
            // Get preferred network mode
            int preferredNetworkMode = RILConstants.PREFERRED_NETWORK_MODE;
            if (TelephonyManager.getLteOnCdmaModeStatic() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                preferredNetworkMode = Phone.NT_MODE_GLOBAL;
            }
            int networkMode = Settings.Global.getInt(context.getContentResolver(), Settings.Global.PREFERRED_NETWORK_MODE, preferredNetworkMode);
            Rlog.i(LOG_TAG, "Network Mode set to " + Integer.toString(networkMode));
            int cdmaSubscription = CdmaSubscriptionSourceManager.getDefault(context);
            Rlog.i(LOG_TAG, "Cdma Subscription set to " + cdmaSubscription);
            // reads the system properties and makes commandsinterface
            String sRILClassname = SystemProperties.get("ro.telephony.ril_class", "RIL").trim();
            Rlog.i(LOG_TAG, "RILClassname is " + sRILClassname);
            // Use reflection to construct the RIL class (defaults to RIL)
            try {
                sCommandsInterface = instantiateCustomRIL(sRILClassname, context, networkMode, cdmaSubscription);
            } catch (Exception e) {
                // 6 different types of exceptions are thrown here that it's
                // easier to just catch Exception as our "error handling" is the same.
                Rlog.e(LOG_TAG, "Unable to construct custom RIL class", e);
                sCommandsInterface = new RIL(context, networkMode, cdmaSubscription);
            }
            // Instantiate UiccController so that all other classes can just call getInstance()
            UiccController.make(context, sCommandsInterface);
            int phoneType = TelephonyManager.getPhoneType(networkMode);
            if (phoneType == PhoneConstants.PHONE_TYPE_GSM) {
                Rlog.i(LOG_TAG, "Creating GSMPhone");
                sProxyPhone = new PhoneProxy(new GSMPhone(context, sCommandsInterface, sPhoneNotifier));
            } else if (phoneType == PhoneConstants.PHONE_TYPE_CDMA) {
                switch(TelephonyManager.getLteOnCdmaModeStatic()) {
                    case PhoneConstants.LTE_ON_CDMA_TRUE:
                        Rlog.i(LOG_TAG, "Creating CDMALTEPhone");
                        sProxyPhone = new PhoneProxy(new CDMALTEPhone(context, sCommandsInterface, sPhoneNotifier));
                        break;
                    case PhoneConstants.LTE_ON_CDMA_FALSE:
                    default:
                        Rlog.i(LOG_TAG, "Creating CDMAPhone");
                        sProxyPhone = new PhoneProxy(new CDMAPhone(context, sCommandsInterface, sPhoneNotifier));
                        break;
                }
            }
            // Ensure that we have a default SMS app. Requesting the app with
            // updateIfNeeded set to true is enough to configure a default SMS app.
            ComponentName componentName = SmsApplication.getDefaultSmsApplication(context, true);
            String packageName = "NONE";
            if (componentName != null) {
                packageName = componentName.getPackageName();
            }
            Rlog.i(LOG_TAG, "defaultSmsApplication: " + packageName);
            // Set up monitor to watch for changes to SMS packages
            SmsApplication.initSmsPackageMonitor(context);
            sMadeDefaults = true;
        }
    }
}
#end_block

#method_before
private void pushMediaButtonReceiver_syncAfRcs(PendingIntent mediaIntent, ComponentName target, IBinder token) {
    // already at top of stack?
    if (!mRCStack.empty() && mRCStack.peek().mMediaIntent.equals(mediaIntent)) {
        return;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_TAKE_MEDIA_BUTTONS, Binder.getCallingUid(), mediaIntent.getCreatorPackage()) != AppOpsManager.MODE_ALLOWED) {
        return;
    }
    RemoteControlStackEntry rcse = null;
    boolean wasInsideStack = false;
    try {
        for (int index = mRCStack.size() - 1; index >= 0; index--) {
            rcse = mRCStack.elementAt(index);
            if (rcse.mMediaIntent.equals(mediaIntent)) {
                // ok to remove element while traversing the stack since we're leaving the loop
                mRCStack.removeElementAt(index);
                wasInsideStack = true;
                break;
            }
        }
    } catch (ArrayIndexOutOfBoundsException e) {
        // not expected to happen, indicates improper concurrent modification
        Log.e(TAG, "Wrong index accessing media button stack, lock error? ", e);
    }
    if (!wasInsideStack) {
        rcse = new RemoteControlStackEntry(this, mediaIntent, target, token);
    }
    // rcse is never null
    mRCStack.push(rcse);
    // post message to persist the default media button receiver
    if (target != null) {
        mEventHandler.sendMessage(mEventHandler.obtainMessage(MSG_PERSIST_MEDIABUTTONRECEIVER, 0, 0, target));
    }
}
#method_after
private boolean pushMediaButtonReceiver_syncAfRcs(PendingIntent mediaIntent, ComponentName target, IBinder token) {
    // already at top of stack?
    if (!mRCStack.empty() && mRCStack.peek().mMediaIntent.equals(mediaIntent)) {
        return false;
    }
    if (mAppOps.noteOp(AppOpsManager.OP_TAKE_MEDIA_BUTTONS, Binder.getCallingUid(), mediaIntent.getCreatorPackage()) != AppOpsManager.MODE_ALLOWED) {
        return false;
    }
    RemoteControlStackEntry rcse = null;
    boolean wasInsideStack = false;
    try {
        for (int index = mRCStack.size() - 1; index >= 0; index--) {
            rcse = mRCStack.elementAt(index);
            if (rcse.mMediaIntent.equals(mediaIntent)) {
                // ok to remove element while traversing the stack since we're leaving the loop
                mRCStack.removeElementAt(index);
                wasInsideStack = true;
                break;
            }
        }
    } catch (ArrayIndexOutOfBoundsException e) {
        // not expected to happen, indicates improper concurrent modification
        Log.e(TAG, "Wrong index accessing media button stack, lock error? ", e);
    }
    if (!wasInsideStack) {
        rcse = new RemoteControlStackEntry(this, mediaIntent, target, token);
    }
    // rcse is never null
    mRCStack.push(rcse);
    // post message to persist the default media button receiver
    if (target != null) {
        mEventHandler.sendMessage(mEventHandler.obtainMessage(MSG_PERSIST_MEDIABUTTONRECEIVER, 0, 0, target));
    }
    // RC stack was modified
    return true;
}
#end_block

#method_before
protected void registerMediaButtonIntent(PendingIntent mediaIntent, ComponentName eventReceiver, IBinder token) {
    Log.i(TAG, "  Remote Control   registerMediaButtonIntent() for " + mediaIntent);
    synchronized (mAudioFocusLock) {
        synchronized (mRCStack) {
            pushMediaButtonReceiver_syncAfRcs(mediaIntent, eventReceiver, token);
            // new RC client, assume every type of information shall be queried
            checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
        }
    }
}
#method_after
protected void registerMediaButtonIntent(PendingIntent mediaIntent, ComponentName eventReceiver, IBinder token) {
    Log.i(TAG, "  Remote Control   registerMediaButtonIntent() for " + mediaIntent);
    synchronized (mAudioFocusLock) {
        synchronized (mRCStack) {
            if (pushMediaButtonReceiver_syncAfRcs(mediaIntent, eventReceiver, token)) {
                // new RC client, assume every type of information shall be queried
                checkUpdateRemoteControlDisplay_syncAfRcs(RC_INFO_ALL);
            }
        }
    }
}
#end_block

#method_before
private void showImpl(boolean show) {
    sendCloseSystemWindows(mContext, BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
    mShowing = show;
    if (show) {
        // if there are no apps, bring up a "No recent apps" message
        boolean noApps = mRecentTaskDescriptions != null && (mRecentTaskDescriptions.size() == 0);
        mRecentsNoApps.setAlpha(1f);
        mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
        boolean showClearAllButton = Settings.System.getInt(mContext.getContentResolver(), Settings.System.SHOW_CLEAR_RECENTS_BUTTON, 1) == 1;
        boolean showMemoryIndicator = Settings.System.getInt(mContext.getContentResolver(), Settings.System.SHOW_RECENTS_MEMORY_INDICATOR, 1) == 1;
        if (showMemoryIndicator) {
            int recentsMemoryIndicatorLocation = Settings.System.getInt(mContext.getContentResolver(), Settings.System.RECENTS_MEMORY_INDICATOR_LOCATION, Constants.CLEAR_ALL_BUTTON_BOTTOM_LEFT);
            FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) mRecentsMemoryIndicator.getLayoutParams();
            switch(recentsMemoryIndicatorLocation) {
                case Constants.CLEAR_ALL_BUTTON_TOP_LEFT:
                    layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_TOP_RIGHT:
                    layoutParams.gravity = Gravity.TOP | Gravity.RIGHT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_BOTTOM_RIGHT:
                    layoutParams.gravity = Gravity.BOTTOM | Gravity.RIGHT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_BOTTOM_LEFT:
                default:
                    layoutParams.gravity = Gravity.BOTTOM | Gravity.LEFT;
                    break;
            }
            mRecentsMemoryIndicator.setLayoutParams(layoutParams);
        } else {
            mRecentsMemoryIndicator.setVisibility(View.GONE);
        }
        if (showClearAllButton) {
            mClearAllRecents.setVisibility(noApps ? View.GONE : View.VISIBLE);
            int clearAllButtonLocation = Settings.System.getInt(mContext.getContentResolver(), Settings.System.CLEAR_RECENTS_BUTTON_LOCATION, Constants.CLEAR_ALL_BUTTON_BOTTOM_LEFT);
            FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) mClearAllRecents.getLayoutParams();
            switch(clearAllButtonLocation) {
                case Constants.CLEAR_ALL_BUTTON_TOP_LEFT:
                    layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_TOP_RIGHT:
                    layoutParams.gravity = Gravity.TOP | Gravity.RIGHT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_BOTTOM_RIGHT:
                    layoutParams.gravity = Gravity.BOTTOM | Gravity.RIGHT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_BOTTOM_LEFT:
                default:
                    layoutParams.gravity = Gravity.BOTTOM | Gravity.LEFT;
                    break;
            }
            mClearAllRecents.setLayoutParams(layoutParams);
        } else {
            mClearAllRecents.setVisibility(View.GONE);
        }
        onAnimationEnd(null);
        setFocusable(true);
        setFocusableInTouchMode(true);
        requestFocus();
    } else {
        mWaitingToShow = false;
        // call onAnimationEnd() and clearRecentTasksList() in onUiHidden()
        mCallUiHiddenBeforeNextReload = true;
        if (mPopup != null) {
            mPopup.dismiss();
        }
    }
}
#method_after
private void showImpl(boolean show) {
    sendCloseSystemWindows(mContext, BaseStatusBar.SYSTEM_DIALOG_REASON_RECENT_APPS);
    mShowing = show;
    if (show) {
        // if there are no apps, bring up a "No recent apps" message
        boolean noApps = mRecentTaskDescriptions != null && (mRecentTaskDescriptions.size() == 0);
        mRecentsNoApps.setAlpha(1f);
        mRecentsNoApps.setVisibility(noApps ? View.VISIBLE : View.INVISIBLE);
        boolean showClearAllButton = Settings.System.getInt(mContext.getContentResolver(), Settings.System.SHOW_CLEAR_RECENTS_BUTTON, 0) == 1;
        boolean showMemoryIndicator = Settings.System.getInt(mContext.getContentResolver(), Settings.System.SHOW_RECENTS_MEMORY_INDICATOR, 0) == 1;
        if (showMemoryIndicator) {
            int recentsMemoryIndicatorLocation = Settings.System.getInt(mContext.getContentResolver(), Settings.System.RECENTS_MEMORY_INDICATOR_LOCATION, Constants.CLEAR_ALL_BUTTON_BOTTOM_LEFT);
            FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) mRecentsMemoryIndicator.getLayoutParams();
            switch(recentsMemoryIndicatorLocation) {
                case Constants.CLEAR_ALL_BUTTON_TOP_LEFT:
                    layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_TOP_RIGHT:
                    layoutParams.gravity = Gravity.TOP | Gravity.RIGHT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_BOTTOM_RIGHT:
                    layoutParams.gravity = Gravity.BOTTOM | Gravity.RIGHT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_BOTTOM_LEFT:
                default:
                    layoutParams.gravity = Gravity.BOTTOM | Gravity.LEFT;
                    break;
            }
            mRecentsMemoryIndicator.setLayoutParams(layoutParams);
        } else {
            mRecentsMemoryIndicator.setVisibility(View.GONE);
        }
        if (showClearAllButton) {
            mClearAllRecents.setVisibility(noApps ? View.GONE : View.VISIBLE);
            int clearAllButtonLocation = Settings.System.getInt(mContext.getContentResolver(), Settings.System.CLEAR_RECENTS_BUTTON_LOCATION, Constants.CLEAR_ALL_BUTTON_BOTTOM_LEFT);
            FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) mClearAllRecents.getLayoutParams();
            switch(clearAllButtonLocation) {
                case Constants.CLEAR_ALL_BUTTON_TOP_LEFT:
                    layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_TOP_RIGHT:
                    layoutParams.gravity = Gravity.TOP | Gravity.RIGHT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_BOTTOM_RIGHT:
                    layoutParams.gravity = Gravity.BOTTOM | Gravity.RIGHT;
                    break;
                case Constants.CLEAR_ALL_BUTTON_BOTTOM_LEFT:
                default:
                    layoutParams.gravity = Gravity.BOTTOM | Gravity.LEFT;
                    break;
            }
            mClearAllRecents.setLayoutParams(layoutParams);
        } else {
            mClearAllRecents.setVisibility(View.GONE);
        }
        onAnimationEnd(null);
        setFocusable(true);
        setFocusableInTouchMode(true);
        requestFocus();
    } else {
        mWaitingToShow = false;
        // call onAnimationEnd() and clearRecentTasksList() in onUiHidden()
        mCallUiHiddenBeforeNextReload = true;
        if (mPopup != null) {
            mPopup.dismiss();
        }
    }
}
#end_block

#method_before
// ===== Update the views =======================================================
void refreshViews() {
    Context context = mContext;
    int combinedSignalIconId = 0;
    int combinedActivityIconId = 0;
    String combinedLabel = "";
    String wifiLabel = "";
    String mobileLabel = "";
    int N;
    final boolean emergencyOnly = isEmergencyOnly();
    if (!mHasMobileDataFeature) {
        mDataSignalIconId = mPhoneSignalIconId = 0;
        mQSPhoneSignalIconId = 0;
        mobileLabel = "";
    } else {
        if (mDataConnected) {
            mobileLabel = mNetworkName;
        } else if (mConnected || emergencyOnly) {
            if (hasService() || emergencyOnly) {
                // The isEmergencyOnly test covers the case of a phone with no SIM
                mobileLabel = mNetworkName;
            } else {
                // Tablets, basically
                mobileLabel = "";
            }
        } else {
            mobileLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
        // Now for things that should only be shown when actually using mobile data.
        if (mDataConnected) {
            combinedSignalIconId = mDataSignalIconId;
            switch(mDataActivity) {
                case TelephonyManager.DATA_ACTIVITY_IN:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_in;
                    break;
                case TelephonyManager.DATA_ACTIVITY_OUT:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_out;
                    break;
                case TelephonyManager.DATA_ACTIVITY_INOUT:
                    mMobileActivityIconId = R.drawable.stat_sys_signal_inout;
                    break;
                default:
                    mMobileActivityIconId = 0;
                    break;
            }
            combinedLabel = mobileLabel;
            combinedActivityIconId = mMobileActivityIconId;
            // set by updateDataIcon()
            combinedSignalIconId = mDataSignalIconId;
            mContentDescriptionCombinedSignal = mContentDescriptionDataType;
        } else {
            mMobileActivityIconId = 0;
        }
    }
    if (mWifiConnected) {
        if (mWifiSsid == null) {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_wifi_nossid);
            // no wifis, no bits
            mWifiActivityIconId = 0;
        } else {
            wifiLabel = mWifiSsid;
            if (DEBUG) {
                wifiLabel += "xxxxXXXXxxxxXXXX";
            }
            switch(mWifiActivity) {
                case WifiManager.DATA_ACTIVITY_IN:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_in;
                    break;
                case WifiManager.DATA_ACTIVITY_OUT:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_out;
                    break;
                case WifiManager.DATA_ACTIVITY_INOUT:
                    mWifiActivityIconId = R.drawable.stat_sys_wifi_inout;
                    break;
                case WifiManager.DATA_ACTIVITY_NONE:
                    mWifiActivityIconId = 0;
                    break;
            }
        }
        combinedActivityIconId = mWifiActivityIconId;
        combinedLabel = wifiLabel;
        // set by updateWifiIcons()
        combinedSignalIconId = mWifiIconId;
        mContentDescriptionCombinedSignal = mContentDescriptionWifi;
    } else {
        if (mHasMobileDataFeature) {
            wifiLabel = "";
        } else {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
    }
    if (mBluetoothTethered) {
        combinedLabel = mContext.getString(R.string.bluetooth_tethered);
        combinedSignalIconId = mBluetoothTetherIconId;
        mContentDescriptionCombinedSignal = mContext.getString(R.string.accessibility_bluetooth_tether);
    }
    final boolean ethernetConnected = (mConnectedNetworkType == ConnectivityManager.TYPE_ETHERNET);
    if (ethernetConnected) {
        combinedLabel = context.getString(R.string.ethernet_label);
    }
    if (mAirplaneMode && (mServiceState == null || (!hasService() && !mServiceState.isEmergencyOnly()))) {
        // Only display the flight-mode icon if not in "emergency calls only" mode.
        // look again; your radios are now airplanes
        mContentDescriptionPhoneSignal = mContext.getString(R.string.accessibility_airplane_mode);
        mAirplaneIconId = FLIGHT_MODE_ICON;
        mPhoneSignalIconId = mDataSignalIconId = mDataTypeIconId = mQSDataTypeIconId = 0;
        mQSPhoneSignalIconId = 0;
        // combined values from connected wifi take precedence over airplane mode
        if (mWifiConnected) {
            // Suppress "No internet connection." from mobile if wifi connected.
            mobileLabel = "";
        } else {
            if (mHasMobileDataFeature) {
                // let the mobile icon show "No internet connection."
                wifiLabel = "";
            } else {
                wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
                combinedLabel = wifiLabel;
            }
            mContentDescriptionCombinedSignal = mContentDescriptionPhoneSignal;
            combinedSignalIconId = mDataSignalIconId;
        }
    } else if (!mDataConnected && !mWifiConnected && !mBluetoothTethered && !mWimaxConnected && !ethernetConnected) {
        // pretty much totally disconnected
        combinedLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        // On devices without mobile radios, we want to show the wifi icon
        combinedSignalIconId = mHasMobileDataFeature ? mDataSignalIconId : mWifiIconId;
        mContentDescriptionCombinedSignal = mHasMobileDataFeature ? mContentDescriptionDataType : mContentDescriptionWifi;
        mDataTypeIconId = 0;
        mQSDataTypeIconId = 0;
        if (isCdma()) {
            if (isCdmaEri()) {
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
            }
        } else if (mPhone.isNetworkRoaming()) {
            mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
            mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
        }
    }
    if (DEBUG) {
        Log.d(TAG, "refreshViews connected={" + (mWifiConnected ? " wifi" : "") + (mDataConnected ? " data" : "") + " } level=" + ((mSignalStrength == null) ? "??" : Integer.toString(mSignalStrength.getLevel())) + " combinedSignalIconId=0x" + Integer.toHexString(combinedSignalIconId) + "/" + getResourceName(combinedSignalIconId) + " combinedActivityIconId=0x" + Integer.toHexString(combinedActivityIconId) + " mobileLabel=" + mobileLabel + " wifiLabel=" + wifiLabel + " emergencyOnly=" + emergencyOnly + " combinedLabel=" + combinedLabel + " mAirplaneMode=" + mAirplaneMode + " mDataActivity=" + mDataActivity + " mPhoneSignalIconId=0x" + Integer.toHexString(mPhoneSignalIconId) + " mQSPhoneSignalIconId=0x" + Integer.toHexString(mQSPhoneSignalIconId) + " mDataDirectionIconId=0x" + Integer.toHexString(mDataDirectionIconId) + " mDataSignalIconId=0x" + Integer.toHexString(mDataSignalIconId) + " mDataTypeIconId=0x" + Integer.toHexString(mDataTypeIconId) + " mQSDataTypeIconId=0x" + Integer.toHexString(mQSDataTypeIconId) + " mWifiIconId=0x" + Integer.toHexString(mWifiIconId) + " mQSWifiIconId=0x" + Integer.toHexString(mQSWifiIconId) + " mBluetoothTetherIconId=0x" + Integer.toHexString(mBluetoothTetherIconId));
    }
    // update QS
    for (NetworkSignalChangedCallback cb : mSignalsChangedCallbacks) {
        notifySignalsChangedCallbacks(cb);
    }
    if (mLastPhoneSignalIconId != mPhoneSignalIconId || mLastDataDirectionOverlayIconId != combinedActivityIconId || mLastWifiIconId != mWifiIconId || mLastWimaxIconId != mWimaxIconId || mLastDataTypeIconId != mDataTypeIconId || mLastAirplaneMode != mAirplaneMode || mLastLocale != mLocale) {
        // NB: the mLast*s will be updated later
        for (SignalCluster cluster : mSignalClusters) {
            refreshSignalCluster(cluster);
        }
    }
    if (mLastAirplaneMode != mAirplaneMode) {
        mLastAirplaneMode = mAirplaneMode;
    }
    if (mLastLocale != mLocale) {
        mLastLocale = mLocale;
    }
    // the phone icon on phones
    if (mLastPhoneSignalIconId != mPhoneSignalIconId) {
        mLastPhoneSignalIconId = mPhoneSignalIconId;
        N = mPhoneSignalIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mPhoneSignalIconViews.get(i);
            if (mPhoneSignalIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mPhoneSignalIconId);
                v.setContentDescription(mContentDescriptionPhoneSignal);
            }
        }
    }
    // the data icon on phones
    if (mLastDataDirectionIconId != mDataDirectionIconId) {
        mLastDataDirectionIconId = mDataDirectionIconId;
        N = mDataDirectionIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataDirectionIconViews.get(i);
            v.setImageResource(mDataDirectionIconId);
            v.setContentDescription(mContentDescriptionDataType);
        }
    }
    // the wifi icon on phones
    if (mLastWifiIconId != mWifiIconId) {
        mLastWifiIconId = mWifiIconId;
        N = mWifiIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWifiIconViews.get(i);
            if (mWifiIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mWifiIconId);
                v.setContentDescription(mContentDescriptionWifi);
            }
        }
    }
    // the wimax icon on phones
    if (mLastWimaxIconId != mWimaxIconId) {
        mLastWimaxIconId = mWimaxIconId;
        N = mWimaxIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mWimaxIconViews.get(i);
            if (mWimaxIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mWimaxIconId);
                v.setContentDescription(mContentDescriptionWimax);
            }
        }
    }
    // the combined data signal icon
    if (mLastCombinedSignalIconId != combinedSignalIconId) {
        mLastCombinedSignalIconId = combinedSignalIconId;
        N = mCombinedSignalIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mCombinedSignalIconViews.get(i);
            v.setImageResource(combinedSignalIconId);
            v.setContentDescription(mContentDescriptionCombinedSignal);
        }
    }
    // the data network type overlay
    if (mLastDataTypeIconId != mDataTypeIconId) {
        mLastDataTypeIconId = mDataTypeIconId;
        N = mDataTypeIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataTypeIconViews.get(i);
            if (mDataTypeIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(mDataTypeIconId);
                v.setContentDescription(mContentDescriptionDataType);
            }
        }
    }
    // the data direction overlay
    if (mLastDataDirectionOverlayIconId != combinedActivityIconId) {
        if (DEBUG) {
            Log.d(TAG, "changing data overlay icon id to " + combinedActivityIconId);
        }
        mLastDataDirectionOverlayIconId = combinedActivityIconId;
        N = mDataDirectionOverlayIconViews.size();
        for (int i = 0; i < N; i++) {
            final ImageView v = mDataDirectionOverlayIconViews.get(i);
            if (combinedActivityIconId == 0) {
                v.setVisibility(View.GONE);
            } else {
                v.setVisibility(View.VISIBLE);
                v.setImageResource(combinedActivityIconId);
                v.setContentDescription(mContentDescriptionDataType);
            }
        }
    }
    // the combinedLabel in the notification panel
    if (!mLastCombinedLabel.equals(combinedLabel)) {
        mLastCombinedLabel = combinedLabel;
        N = mCombinedLabelViews.size();
        for (int i = 0; i < N; i++) {
            TextView v = mCombinedLabelViews.get(i);
            v.setText(combinedLabel);
        }
    }
    // wifi label
    N = mWifiLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mWifiLabelViews.get(i);
        v.setText(wifiLabel);
        if ("".equals(wifiLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
    // mobile label
    N = mMobileLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mMobileLabelViews.get(i);
        v.setText(mobileLabel);
        if ("".equals(mobileLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
    // e-call label
    N = mEmergencyLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mEmergencyLabelViews.get(i);
        if (!emergencyOnly) {
            v.setVisibility(View.GONE);
        } else {
            // comes from the telephony stack
            v.setText(mobileLabel);
            v.setVisibility(View.VISIBLE);
        }
    }
}
#method_after
// ===== Update the views =======================================================
void refreshViews() {
    Context context = mContext;
    int combinedSignalIconId = 0;
    int combinedActivityIconId = 0;
    String combinedLabel = "";
    String wifiLabel = "";
    String mobileLabel = "";
    int N;
    final boolean emergencyOnly = isEmergencyOnly();
    if (!mHasMobileDataFeature) {
        mDataSignalIconId = mPhoneSignalIconId = 0;
        mQSPhoneSignalIconId = 0;
        mobileLabel = "";
    } else {
        if (mDataConnected) {
            mobileLabel = mNetworkName;
        } else if (mConnected || emergencyOnly) {
            if (hasService() || emergencyOnly) {
                // The isEmergencyOnly test covers the case of a phone with no SIM
                mobileLabel = mNetworkName;
            } else {
                // Tablets, basically
                mobileLabel = "";
            }
        } else {
            mobileLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
        // Now for things that should only be shown when actually using mobile data.
        if (mDataConnected) {
            combinedSignalIconId = mDataSignalIconId;
            if (mDirectionArrowsEnabled) {
                switch(mDataActivity) {
                    case TelephonyManager.DATA_ACTIVITY_IN:
                        mMobileActivityIconId = R.drawable.stat_sys_signal_in;
                        break;
                    case TelephonyManager.DATA_ACTIVITY_OUT:
                        mMobileActivityIconId = R.drawable.stat_sys_signal_out;
                        break;
                    case TelephonyManager.DATA_ACTIVITY_INOUT:
                        mMobileActivityIconId = R.drawable.stat_sys_signal_inout;
                        break;
                    default:
                        mMobileActivityIconId = 0;
                        break;
                }
            } else {
                mMobileActivityIconId = 0;
            }
            combinedLabel = mobileLabel;
            combinedActivityIconId = mMobileActivityIconId;
            // set by updateDataIcon()
            combinedSignalIconId = mDataSignalIconId;
            mContentDescriptionCombinedSignal = mContentDescriptionDataType;
        } else {
            mMobileActivityIconId = 0;
        }
    }
    if (mWifiConnected) {
        if (mWifiSsid == null) {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_wifi_nossid);
            // no wifis, no bits
            mWifiActivityIconId = 0;
        } else {
            wifiLabel = mWifiSsid;
            if (DEBUG) {
                wifiLabel += "xxxxXXXXxxxxXXXX";
            }
            if (mDirectionArrowsEnabled) {
                switch(mWifiActivity) {
                    case WifiManager.DATA_ACTIVITY_IN:
                        mWifiActivityIconId = R.drawable.stat_sys_wifi_in;
                        break;
                    case WifiManager.DATA_ACTIVITY_OUT:
                        mWifiActivityIconId = R.drawable.stat_sys_wifi_out;
                        break;
                    case WifiManager.DATA_ACTIVITY_INOUT:
                        mWifiActivityIconId = R.drawable.stat_sys_wifi_inout;
                        break;
                    case WifiManager.DATA_ACTIVITY_NONE:
                        mWifiActivityIconId = 0;
                        break;
                }
            } else {
                mWifiActivityIconId = 0;
            }
        }
        combinedActivityIconId = mWifiActivityIconId;
        combinedLabel = wifiLabel;
        // set by updateWifiIcons()
        combinedSignalIconId = mWifiIconId;
        mContentDescriptionCombinedSignal = mContentDescriptionWifi;
    } else {
        if (mHasMobileDataFeature) {
            wifiLabel = "";
        } else {
            wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        }
    }
    if (mBluetoothTethered) {
        combinedLabel = mContext.getString(R.string.bluetooth_tethered);
        combinedSignalIconId = mBluetoothTetherIconId;
        mContentDescriptionCombinedSignal = mContext.getString(R.string.accessibility_bluetooth_tether);
    }
    final boolean ethernetConnected = (mConnectedNetworkType == ConnectivityManager.TYPE_ETHERNET);
    if (ethernetConnected) {
        combinedLabel = context.getString(R.string.ethernet_label);
    }
    if (mAirplaneMode && (mServiceState == null || (!hasService() && !mServiceState.isEmergencyOnly()))) {
        // Only display the flight-mode icon if not in "emergency calls only" mode.
        // look again; your radios are now airplanes
        mContentDescriptionPhoneSignal = mContext.getString(R.string.accessibility_airplane_mode);
        mAirplaneIconId = FLIGHT_MODE_ICON;
        mPhoneSignalIconId = mDataSignalIconId = mDataTypeIconId = mQSDataTypeIconId = 0;
        mQSPhoneSignalIconId = 0;
        // combined values from connected wifi take precedence over airplane mode
        if (mWifiConnected) {
            // Suppress "No internet connection." from mobile if wifi connected.
            mobileLabel = "";
        } else {
            if (mHasMobileDataFeature) {
                // let the mobile icon show "No internet connection."
                wifiLabel = "";
            } else {
                wifiLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
                combinedLabel = wifiLabel;
            }
            mContentDescriptionCombinedSignal = mContentDescriptionPhoneSignal;
            combinedSignalIconId = mDataSignalIconId;
        }
    } else if (!mDataConnected && !mWifiConnected && !mBluetoothTethered && !mWimaxConnected && !ethernetConnected) {
        // pretty much totally disconnected
        combinedLabel = context.getString(R.string.status_bar_settings_signal_meter_disconnected);
        // On devices without mobile radios, we want to show the wifi icon
        combinedSignalIconId = mHasMobileDataFeature ? mDataSignalIconId : mWifiIconId;
        mContentDescriptionCombinedSignal = mHasMobileDataFeature ? mContentDescriptionDataType : mContentDescriptionWifi;
        mDataTypeIconId = 0;
        mQSDataTypeIconId = 0;
        if (isCdma()) {
            if (isCdmaEri()) {
                mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
                mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
            }
        } else if (mPhone.isNetworkRoaming()) {
            mDataTypeIconId = R.drawable.stat_sys_data_fully_connected_roam;
            mQSDataTypeIconId = TelephonyIcons.QS_DATA_R[mInetCondition];
        }
    }
    if (DEBUG) {
        Log.d(TAG, "refreshViews connected={" + (mWifiConnected ? " wifi" : "") + (mDataConnected ? " data" : "") + " } level=" + ((mSignalStrength == null) ? "??" : Integer.toString(mSignalStrength.getLevel())) + " combinedSignalIconId=0x" + Integer.toHexString(combinedSignalIconId) + "/" + getResourceName(combinedSignalIconId) + " combinedActivityIconId=0x" + Integer.toHexString(combinedActivityIconId) + " mobileLabel=" + mobileLabel + " wifiLabel=" + wifiLabel + " emergencyOnly=" + emergencyOnly + " combinedLabel=" + combinedLabel + " mAirplaneMode=" + mAirplaneMode + " mDataActivity=" + mDataActivity + " mPhoneSignalIconId=0x" + Integer.toHexString(mPhoneSignalIconId) + " mQSPhoneSignalIconId=0x" + Integer.toHexString(mQSPhoneSignalIconId) + " mDataDirectionIconId=0x" + Integer.toHexString(mDataDirectionIconId) + " mDataSignalIconId=0x" + Integer.toHexString(mDataSignalIconId) + " mDataTypeIconId=0x" + Integer.toHexString(mDataTypeIconId) + " mQSDataTypeIconId=0x" + Integer.toHexString(mQSDataTypeIconId) + " mWifiIconId=0x" + Integer.toHexString(mWifiIconId) + " mQSWifiIconId=0x" + Integer.toHexString(mQSWifiIconId) + " mBluetoothTetherIconId=0x" + Integer.toHexString(mBluetoothTetherIconId));
    }
    // update QS
    for (NetworkSignalChangedCallback cb : mSignalsChangedCallbacks) {
        notifySignalsChangedCallbacks(cb);
    }
    if (mLastPhoneSignalIconId != mPhoneSignalIconId || mLastDataDirectionOverlayIconId != combinedActivityIconId || mLastWifiIconId != mWifiIconId || mLastWimaxIconId != mWimaxIconId || mLastDataTypeIconId != mDataTypeIconId || mLastAirplaneMode != mAirplaneMode || mLastLocale != mLocale) {
        // NB: the mLast*s will be updated later
        for (SignalCluster cluster : mSignalClusters) {
            refreshSignalCluster(cluster);
        }
    }
    if (mLastAirplaneMode != mAirplaneMode) {
        mLastAirplaneMode = mAirplaneMode;
    }
    if (mLastLocale != mLocale) {
        mLastLocale = mLocale;
    }
    // the phone icon on phones
    if (mLastPhoneSignalIconId != mPhoneSignalIconId) {
        mLastPhoneSignalIconId = mPhoneSignalIconId;
    }
    // the data icon on phones
    if (mLastDataDirectionIconId != mDataDirectionIconId) {
        mLastDataDirectionIconId = mDataDirectionIconId;
    }
    // the wifi icon on phones
    if (mLastWifiIconId != mWifiIconId) {
        mLastWifiIconId = mWifiIconId;
    }
    // the wimax icon on phones
    if (mLastWimaxIconId != mWimaxIconId) {
        mLastWimaxIconId = mWimaxIconId;
    }
    // the combined data signal icon
    if (mLastCombinedSignalIconId != combinedSignalIconId) {
        mLastCombinedSignalIconId = combinedSignalIconId;
    }
    // the data network type overlay
    if (mLastDataTypeIconId != mDataTypeIconId) {
        mLastDataTypeIconId = mDataTypeIconId;
    }
    // the data direction overlay
    if (mLastDataDirectionOverlayIconId != combinedActivityIconId) {
        mLastDataDirectionOverlayIconId = combinedActivityIconId;
    }
    // the combinedLabel in the notification panel
    if (!mLastCombinedLabel.equals(combinedLabel)) {
        mLastCombinedLabel = combinedLabel;
        N = mCombinedLabelViews.size();
        for (int i = 0; i < N; i++) {
            TextView v = mCombinedLabelViews.get(i);
            v.setText(combinedLabel);
        }
    }
    // wifi label
    N = mWifiLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mWifiLabelViews.get(i);
        v.setText(wifiLabel);
        if ("".equals(wifiLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
    // mobile label
    N = mMobileLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mMobileLabelViews.get(i);
        v.setText(mobileLabel);
        if ("".equals(mobileLabel)) {
            v.setVisibility(View.GONE);
        } else {
            v.setVisibility(View.VISIBLE);
        }
    }
    // e-call label
    N = mEmergencyLabelViews.size();
    for (int i = 0; i < N; i++) {
        TextView v = mEmergencyLabelViews.get(i);
        if (!emergencyOnly) {
            v.setVisibility(View.GONE);
        } else {
            // comes from the telephony stack
            v.setText(mobileLabel);
            v.setVisibility(View.VISIBLE);
        }
    }
}
#end_block

#method_before
private void internalSetTargetResources(int resourceId) {
    final ArrayList<TargetDrawable> targets = loadDrawableArray(resourceId);
    mTargetDrawables = targets;
    mTargetResourceId = resourceId;
    int maxWidth = mHandleDrawable.getWidth();
    int maxHeight = mHandleDrawable.getHeight();
    final int count = targets.size();
    for (int i = 0; i < count; i++) {
        TargetDrawable target = targets.get(i);
        maxWidth = Math.max(maxWidth, target.getWidth());
        maxHeight = Math.max(maxHeight, target.getHeight());
    }
    if (mMaxTargetWidth != maxWidth || mMaxTargetHeight != maxHeight) {
        mMaxTargetWidth = maxWidth;
        mMaxTargetHeight = maxHeight;
        // required to resize layout and call updateTargetPositions()
        requestLayout();
    } else {
        updateTargetPositions(mWaveCenterX, mWaveCenterY);
        updatePointCloudPosition(mWaveCenterX, mWaveCenterY);
    }
}
#method_after
private void internalSetTargetResources(ArrayList<TargetDrawable> drawList) {
    mTargetResourceId = 0;
    mTargetDrawables = drawList;
    updateTargetPositions(mWaveCenterX, mWaveCenterY);
    updatePointCloudPosition(mWaveCenterX, mWaveCenterY);
    hideTargets(false, false);
}
#end_block

#method_before
public void setTargetResources(int resourceId) {
    if (mAnimatingTargets) {
        // postpone this change until we return to the initial state
        mNewTargetResources = resourceId;
    } else {
        internalSetTargetResources(resourceId);
    }
}
#method_after
public void setTargetResources(ArrayList<TargetDrawable> drawList) {
    if (mAnimatingTargets) {
        // postpone this change until we return to the initial state
        mNewTargetDrawables = drawList;
    } else {
        internalSetTargetResources(drawList);
    }
}
#end_block

#method_before
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.bars_and_menus_settings);
    PreferenceScreen prefSet = getPreferenceScreen();
    ContentResolver resolver = getActivity().getContentResolver();
    mStatusBarBrightnessControl = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_BRIGHTNESS_CONTROL);
    mStatusBarBrightnessControl.setChecked((Settings.System.getInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0) == 1));
    mStatusBarBrightnessControl.setOnPreferenceChangeListener(this);
    try {
        if (Settings.System.getInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {
            mStatusBarBrightnessControl.setEnabled(false);
            mStatusBarBrightnessControl.setSummary(R.string.status_bar_toggle_info);
        }
    } catch (SettingNotFoundException e) {
    }
    mStatusBarNotifCount = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_NOTIF_COUNT);
    mStatusBarNotifCount.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, 0) == 1);
    mStatusBarNotifCount.setOnPreferenceChangeListener(this);
    mStatusBarTraffic = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_TRAFFIC);
    mStatusBarTraffic.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_TRAFFIC, 0) == 1);
    mStatusBarTraffic.setOnPreferenceChangeListener(this);
    mRecentClearAll = (CheckBoxPreference) prefSet.findPreference(RECENT_MENU_CLEAR_ALL);
    mRecentClearAll.setChecked(Settings.System.getInt(resolver, Settings.System.SHOW_CLEAR_RECENTS_BUTTON, 1) == 1);
    mRecentClearAll.setOnPreferenceChangeListener(this);
}
#method_after
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.bars_and_menus_settings);
    PreferenceScreen prefSet = getPreferenceScreen();
    ContentResolver resolver = getActivity().getContentResolver();
    mStatusBarBrightnessControl = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_BRIGHTNESS_CONTROL);
    mStatusBarBrightnessControl.setChecked((Settings.System.getInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, 0) == 1));
    mStatusBarBrightnessControl.setOnPreferenceChangeListener(this);
    try {
        if (Settings.System.getInt(getActivity().getApplicationContext().getContentResolver(), Settings.System.SCREEN_BRIGHTNESS_MODE) == Settings.System.SCREEN_BRIGHTNESS_MODE_AUTOMATIC) {
            mStatusBarBrightnessControl.setEnabled(false);
            mStatusBarBrightnessControl.setSummary(R.string.status_bar_toggle_info);
        }
    } catch (SettingNotFoundException e) {
    }
    mStatusBarNotifCount = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_NOTIF_COUNT);
    mStatusBarNotifCount.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, 0) == 1);
    mStatusBarNotifCount.setOnPreferenceChangeListener(this);
    mStatusBarTraffic = (CheckBoxPreference) prefSet.findPreference(STATUS_BAR_TRAFFIC);
    mStatusBarTraffic.setChecked(Settings.System.getInt(resolver, Settings.System.STATUS_BAR_TRAFFIC, 0) == 1);
    mStatusBarTraffic.setOnPreferenceChangeListener(this);
    mRecentClearAll = (CheckBoxPreference) prefSet.findPreference(RECENT_MENU_CLEAR_ALL);
    mRecentClearAll.setChecked(Settings.System.getInt(resolver, Settings.System.SHOW_CLEAR_RECENTS_BUTTON, 1) == 1);
    mRecentClearAll.setOnPreferenceChangeListener(this);
    mRecentClearAllPosition = (ListPreference) prefSet.findPreference(RECENT_MENU_CLEAR_ALL_LOCATION);
    String recentClearAllPosition = Settings.System.getString(resolver, Settings.System.CLEAR_RECENTS_BUTTON_LOCATION);
    if (recentClearAllPosition != null) {
        mRecentClearAllPosition.setValue(recentClearAllPosition);
    }
    mRecentClearAllPosition.setOnPreferenceChangeListener(this);
}
#end_block

#method_before
public boolean onPreferenceChange(Preference preference, Object objValue) {
    ContentResolver resolver = getActivity().getContentResolver();
    if (preference == mStatusBarBrightnessControl) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, value ? 1 : 0);
    } else if (preference == mStatusBarNotifCount) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, value ? 1 : 0);
    } else if (preference == mStatusBarTraffic) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_TRAFFIC, value ? 1 : 0);
    } else if (preference == mRecentClearAll) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.SHOW_CLEAR_RECENTS_BUTTON, value ? 1 : 0);
    } else {
        return false;
    }
    return true;
}
#method_after
public boolean onPreferenceChange(Preference preference, Object objValue) {
    ContentResolver resolver = getActivity().getContentResolver();
    if (preference == mStatusBarBrightnessControl) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_BRIGHTNESS_CONTROL, value ? 1 : 0);
    } else if (preference == mStatusBarNotifCount) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_NOTIF_COUNT, value ? 1 : 0);
    } else if (preference == mStatusBarTraffic) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.STATUS_BAR_TRAFFIC, value ? 1 : 0);
    } else if (preference == mRecentClearAll) {
        boolean value = (Boolean) objValue;
        Settings.System.putInt(resolver, Settings.System.SHOW_CLEAR_RECENTS_BUTTON, value ? 1 : 0);
    } else if (preference == mRecentClearAllPosition) {
        String value = (String) objValue;
        Settings.System.putString(resolver, Settings.System.CLEAR_RECENTS_BUTTON_LOCATION, value);
    } else {
        return false;
    }
    return true;
}
#end_block

