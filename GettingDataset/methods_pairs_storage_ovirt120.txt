732
#method_before
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() != null && stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#method_after
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    for (VdsNetworkInterface iface : _vds.getInterfaces()) {
        Double transmitRate = iface.getStatistics().getTransmitRate();
        Double receiveRate = iface.getStatistics().getReceiveRate();
        if ((transmitRate != null && iface.getStatistics().getTransmitRate().intValue() > maxUsedPercentageThreshold) || (receiveRate != null && iface.getStatistics().getReceiveRate().intValue() > maxUsedPercentageThreshold)) {
            AuditLogableBase logable = new AuditLogableBase(_vds.getId());
            logable.setCustomId(iface.getName());
            logable.addCustomValue("HostName", _vds.getName());
            logable.addCustomValue("InterfaceName", iface.getName());
            logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
            logable.addCustomValue("TransmitRate", String.valueOf(transmitRate.intValue()));
            logable.addCustomValue("ReceiveRate", String.valueOf(receiveRate.intValue()));
            auditLog(logable, AuditLogType.HOST_INTERFACE_HIGH_NETWORK_USE);
        }
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        reportNicStatusChanges();
        Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, InterfaceStatus> monitoredInterfaces = new HashMap<String, InterfaceStatus>();
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String parentIfaceName = iface.getVlanId() == null ? iface.getName() : NetworkUtils.stripVlan(iface.getName());
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(parentIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || (iface.getLabels() != null && !iface.getLabels().isEmpty())) {
            VdsNetworkInterface parentIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                for (VdsNetworkInterface tmpIface : interfaces) {
                    if (parentIfaceName.equals(tmpIface.getName())) {
                        parentIface = tmpIface;
                    }
                }
            }
            monitoredInterfaces.put(parentIface.getName(), parentIface.getStatistics().getStatus());
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave.getStatistics().getStatus());
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        InterfaceStatus status = monitoredInterfaces.get(oldIface.getName());
        if (status != null && oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
            AuditLogableBase logable = new AuditLogableBase(_vds.getId());
            logable.setCustomId(oldIface.getName());
            logable.addCustomValue("InterfaceName", oldIface.getName());
            if (oldIface.getBonded() != null && oldIface.getBonded()) {
                auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_UP : AuditLogType.HOST_BOND_DOWN);
            } else {
                auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_IFACE_UP : AuditLogType.HOST_IFACE_DOWN);
            }
        }
    }
}
#method_after
private void reportNicStatusChanges() {
    List<VdsNetworkInterface> interfaces = _vds.getInterfaces();
    Set<VdsNetworkInterface> slaves = new HashSet<>();
    Map<String, VdsNetworkInterface> monitoredInterfaces = new HashMap<String, VdsNetworkInterface>();
    Map<String, VdsNetworkInterface> interfaceByName = Entities.entitiesByName(interfaces);
    for (VdsNetworkInterface iface : interfaces) {
        if (iface.getBondName() != null) {
            slaves.add(iface);
        }
        String baseIfaceName = NetworkUtils.stripVlan(iface.getName());
        // If the parent interface already marked as monitored- no need to check it again
        if (monitoredInterfaces.containsKey(baseIfaceName)) {
            continue;
        }
        // The status of the interface should be monitored only if it has networks attached to it or has labels
        if (StringUtils.isNotEmpty(iface.getNetworkName()) || NetworkUtils.isLabeled(iface)) {
            VdsNetworkInterface baseIface = iface;
            // If vlan find the parent interface
            if (iface.getVlanId() != null) {
                baseIface = interfaceByName.get(baseIfaceName);
            }
            monitoredInterfaces.put(baseIfaceName, baseIface);
        }
    }
    // Slaves should be monitored if the bond is monitored
    for (VdsNetworkInterface slave : slaves) {
        if (monitoredInterfaces.containsKey(slave.getBondName())) {
            monitoredInterfaces.put(slave.getName(), slave);
        }
    }
    for (VdsNetworkInterface oldIface : getDbFacade().getInterfaceDao().getAllInterfacesForVds(_vds.getId())) {
        VdsNetworkInterface iface = monitoredInterfaces.get(oldIface.getName());
        InterfaceStatus status;
        if (iface != null) {
            status = iface.getStatistics().getStatus();
            if (oldIface.getStatistics().getStatus() != InterfaceStatus.NONE && oldIface.getStatistics().getStatus() != status) {
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.setCustomId(iface.getName());
                if (iface.getBondName() != null) {
                    logable.addCustomValue("SlaveName", iface.getName());
                    logable.addCustomValue("BondName", iface.getBondName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_BOND_SLAVE_STATE_UP : AuditLogType.HOST_BOND_SLAVE_STATE_DOWN);
                } else {
                    logable.addCustomValue("InterfaceName", iface.getName());
                    auditLog(logable, status == InterfaceStatus.UP ? AuditLogType.HOST_INTERFACE_STATE_UP : AuditLogType.HOST_INTERFACE_STATE_DOWN);
                }
            }
        }
    }
}
#end_block

#method_before
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = getDeviceType(device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#method_after
private void logDeviceInformation(Guid vmId, Map device) {
    String message = "Received a {0} Device without an address when processing VM {1} devices, skipping device";
    String deviceType = (String) device.get(VdsProperties.Device);
    if (shouldLogDeviceDetails(deviceType)) {
        Map<String, Object> deviceInfo = device;
        log.infoFormat(message + ": {2}", StringUtils.defaultString(deviceType), vmId, deviceInfo);
    } else {
        log.infoFormat(message, StringUtils.defaultString(deviceType), vmId);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(CpuFlagsManagerHandler.FindMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getcompatibility_version()));
    // CPU flags are empty if we change oVrt node cluster during approve process
    if (vds.getCpuFlags() != null) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getcompatibility_version()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VDS vds = getVds();
    if (vds == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_INVALID_SERVER_ID);
        return false;
    }
    if (!ObjectIdentityChecker.CanUpdateField(vds, "vdsGroupId", vds.getStatus())) {
        addCanDoActionMessage(VdcBllMessages.VDS_STATUS_NOT_VALID_FOR_UPDATE);
        return false;
    }
    if (getTargetCluster() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    targetStoragePool = DbFacade.getInstance().getStoragePoolDao().getForVdsGroup(getTargetCluster().getId());
    if (targetStoragePool != null && targetStoragePool.isLocal()) {
        if (!DbFacade.getInstance().getVdsStaticDao().getAllForVdsGroup(getParameters().getClusterId()).isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_ADD_MORE_THEN_ONE_HOST_TO_LOCAL_STORAGE);
            return false;
        }
    }
    if (getVdsGroup().supportsGlusterService()) {
        if (getGlusterUtils().hasBricks(getVdsId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CANNOT_REMOVE_HOST_HAVING_GLUSTER_VOLUME);
            return false;
        }
        if (!hasUpServer(getSourceCluster())) {
            return false;
        }
    }
    if (getTargetCluster().supportsGlusterService() && !hasUpServerInTarget(getTargetCluster())) {
        return false;
    }
    vds.setCpuName(CpuFlagsManagerHandler.FindMaxServerCpuByFlags(vds.getCpuFlags(), getTargetCluster().getcompatibility_version()));
    // CPU flags are null if oVirt node cluster is changed during approve process.
    if (!StringUtils.isEmpty(vds.getCpuFlags())) {
        if (vds.getCpuName() == null) {
            return failCanDoAction(VdcBllMessages.CPU_TYPE_UNSUPPORTED_IN_THIS_CLUSTER_VERSION);
        }
        if (getTargetCluster().getArchitecture() != ArchitectureType.undefined && getTargetCluster().getArchitecture() != vds.getCpuName().getArchitecture()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_CLUSTER_DIFFERENT_ARCHITECTURES);
        }
    }
    if (FeatureSupported.hostNetworkQos(getSourceCluster().getcompatibility_version()) && !FeatureSupported.hostNetworkQos(getTargetCluster().getcompatibility_version())) {
        for (VdsNetworkInterface iface : getHostNics()) {
            if (iface.getQos() != null) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED, String.format("$ACTION_TYPE_FAILED_HOST_NETWORK_QOS_NOT_SUPPORTED_LIST %s", iface.getNetworkName()));
            }
        }
    }
    if (!targetClusterSupportsSetupNetworks() && hostHasLabeledNics()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_HOST_NETWORK_LABELS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "setUpStatus", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "setUpStatus", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#method_after
public void failedToRunVm(VDS vds) {
    if (mFailedToRunVmAttempts.get() < Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds) && mFailedToRunVmAttempts.incrementAndGet() >= Config.<Integer>getValue(ConfigValues.NumberOfFailedRunsOnVds)) {
        // Only one thread at a time can enter here
        ResourceManager.getInstance().runVdsCommand(VDSCommandType.SetVdsStatus, new SetVdsStatusVDSCommandParameters(vds.getId(), VDSStatus.Error));
        SchedulerUtil sched = SchedulerUtilQuartzImpl.getInstance();
        sched.scheduleAOneTimeJob(this, "recoverFromError", new Class[0], new Object[0], VDS_DURING_FAILURE_TIMEOUT_IN_MINUTES, TimeUnit.MINUTES);
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("Time", Config.<Integer>getValue(ConfigValues.TimeToReduceFailedRunOnVdsInMinutes).toString());
        AuditLogDirector.log(logable, AuditLogType.VDS_FAILED_TO_RUN_VMS);
        log.infoFormat("Vds {0} moved to Error mode after {1} attempts. Time: {2}", vds.getName(), mFailedToRunVmAttempts, new Date());
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("onVdsDuringFailureTimer")
public void onVdsDuringFailureTimer() {
    synchronized (getLockObj()) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
        /**
         * Move vds to Up status from error
         */
        if (vds.getStatus() == VDSStatus.Error) {
            mFailedToRunVmAttempts.set(0);
            setStatus(VDSStatus.Up, vds);
            DbFacade.getInstance().getVdsDynamicDao().updateStatus(getVdsId(), VDSStatus.Up);
            log.infoFormat("onVdsDuringFailureTimer of Host {0} entered after {1} attempts to run a VM", vds.getName(), mFailedToRunVmAttempts);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("onVdsDuringFailureTimer")
public void onVdsDuringFailureTimer() {
    VDS vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
    /**
     * Move vds to Up status from error
     */
    if (vds.getStatus() == VDSStatus.Error) {
        setStatus(VDSStatus.Up, vds);
        DbFacade.getInstance().getVdsDynamicDao().updateStatus(getVdsId(), VDSStatus.Up);
        log.infoFormat("onVdsDuringFailureTimer of Host {0} entered after {1} attempts to run a VM", vds.getName(), mFailedToRunVmAttempts);
        mFailedToRunVmAttempts.set(0);
    }
}
#end_block

#method_before
private void vmInitLoaded(VmTemplate template) {
    UnitVmModel model = new UnitVmModel(createBehavior(template));
    // $NON-NLS-1$
    model.setIsAdvancedModeLocalStorageKey(getEditTemplateAdvancedModelKey());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editTemplateTitle());
    model.setHelpTag(HelpTag.edit_template);
    // $NON-NLS-1$
    model.setHashName("edit_template");
    model.getVmType().setSelectedItem(template.getVmType());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSave", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#method_after
private void vmInitLoaded(VmTemplate template) {
    UnitVmModel model = new UnitVmModel(createBehavior(template));
    model.setIsAdvancedModeLocalStorageKey(getEditTemplateAdvancedModelKey());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editTemplateTitle());
    model.setHelpTag(HelpTag.edit_template);
    // $NON-NLS-1$
    model.setHashName("edit_template");
    model.getVmType().setSelectedItem(template.getVmType());
    model.initialize(this.getSystemTreeSelectedItem());
    VmBasedWidgetSwitchModeCommand switchModeCommand = new VmBasedWidgetSwitchModeCommand();
    switchModeCommand.init(model);
    model.getCommands().add(switchModeCommand);
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand("OnSave", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().ok());
    command.setIsDefault(true);
    model.getCommands().add(command);
    // $NON-NLS-1$
    command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    model.getCommands().add(command);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getCloneVmCommand()) {
        cloneVm();
    }
    if (command == getNewVmCommand()) {
        newInternal();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSaveCommand()) {
        onSave();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    } else if ("OnClone".equals(command.getName())) {
        // $NON-NLS-1$
        onClone();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newInternal();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getSaveCommand()) {
        onSave();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (command.getName().equals("closeVncInfo")) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    getEditCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool());
    getRemoveCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RemoveVm));
    getRunOnceCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RunVmOnce));
    getCloneVmCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.CloneVm));
    getChangeCdCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.ChangeDisk));
    getNewTemplateCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.AddVmTemplate));
}
#method_after
private void updateActionAvailability() {
    UserPortalItemModel selectedItem = (UserPortalItemModel) getSelectedItem();
    getEditCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool());
    getRemoveCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RemoveVm));
    getRunOnceCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.RunVmOnce));
    getChangeCdCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.ChangeDisk));
    getNewTemplateCommand().setIsExecutionAllowed(selectedItem != null && !selectedItem.isPool() && VdcActionUtils.canExecute(new ArrayList<VM>(Arrays.asList(new VM[] { (VM) selectedItem.getEntity() })), VM.class, VdcActionType.AddVmTemplate));
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
    updateWatchdogModels();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    handleQxlClusterLevel();
    updateWatchdogModels();
}
#end_block

#method_before
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        if (dataCenterToCluster.containsKey(dataCenter.getId())) {
            for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
                dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
            }
        }
    }
    selectDataCenterWithCluster(selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void selectDataCenterWithCluster(UnitVmModel model, Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    if (selectedCluster == null) {
        getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters));
    } else {
        model.getDataCenterWithClustersList().setSelectedItem(Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster)));
    }
}
#method_after
protected void selectDataCenterWithCluster(Guid selectedCluster, List<DataCenterWithCluster> dataCentersWithClusters) {
    DataCenterWithCluster selectedDataCenterWithCluster = (selectedCluster == null) ? Linq.firstOrDefault(dataCentersWithClusters) : Linq.firstOrDefault(dataCentersWithClusters, new Linq.DataCenterWithClusterAccordingClusterPredicate(selectedCluster));
    getDataCenterWithClustersList().setItems(dataCentersWithClusters, selectedDataCenterWithCluster);
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid();
}
#method_after
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        // Minimum 'Physical Memory Guaranteed' is 1MB
        validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
        if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
            validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getIsSystemTabValid();
}
#end_block

#method_before
private void validateMemorySize(EntityModel model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = (Integer) model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#method_after
private void validateMemorySize(EntityModel<Integer> model, int maxMemSize, int minMemSize) {
    boolean isValid = false;
    int memSize = model.getEntity();
    if (memSize == 0) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().memSizeBetween(minMemSize, maxMemSize));
    } else if (memSize > maxMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().maxMemSizeIs(maxMemSize));
    } else if (memSize < minMemSize) {
        model.getInvalidityReasons().add(ConstantsManager.getInstance().getMessages().minMemSizeIs(minMemSize));
    } else {
        isValid = true;
    }
    model.setIsValid(isValid);
}
#end_block

#method_before
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1);
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getCloneVmCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CloneVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getRebootCommand().setIsExecutionAllowed(AsyncDataProvider.isRebootCommandExecutionAllowed(items));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    updateHaMaintenanceAvailability(items);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getCloneVmCommand()) {
        cloneVm();
    } else if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnClone".equals(command.getName())) {
        onClone();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewVmCommand()) {
        newVm();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getEditConsoleCommand()) {
        editConsole();
    } else if (command == getConsoleConnectCommand()) {
        connectToConsoles();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getRunCommand()) {
        run();
    } else if (command == getPauseCommand()) {
        pause();
    } else if (command == getStopCommand()) {
        stop();
    } else if (command == getShutdownCommand()) {
        shutdown();
    } else if (command == getRebootCommand()) {
        reboot();
    } else if (command == getMigrateCommand()) {
        migrate();
    } else if (command == getNewTemplateCommand()) {
        newTemplate();
    } else if (command == getRunOnceCommand()) {
        runOnce();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportVirtualMachineTitle());
    } else if (command == getCreateSnapshotCommand()) {
        createSnapshot();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (command == getRetrieveIsoImagesCommand()) {
        retrieveIsoImages();
    } else if (command == getChangeCdCommand()) {
        changeCD();
    } else if (command == getEnableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(true);
    } else if (command == getDisableGlobalHaMaintenanceCommand()) {
        setGlobalHaMaintenance(false);
    } else if (command == getAssignTagsCommand()) {
        assignTags();
    } else if (// $NON-NLS-1$
    "OnAssignTags".equals(command.getName())) {
        onAssignTags();
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        preSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    "OnRunOnce".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnNewTemplate".equals(command.getName())) {
        onNewTemplate();
    } else if (// $NON-NLS-1$
    "OnMigrate".equals(command.getName())) {
        onMigrate();
    } else if (command == getCancelMigrateCommand()) {
        cancelMigration();
    } else if (// $NON-NLS-1$
    "OnShutdown".equals(command.getName())) {
        onShutdown();
    } else if (// $NON-NLS-1$
    "OnStop".equals(command.getName())) {
        onStop();
    } else if (// $NON-NLS-1$
    "OnReboot".equals(command.getName())) {
        onReboot();
    } else if (// $NON-NLS-1$
    "OnChangeCD".equals(command.getName())) {
        onChangeCD();
    } else if (// $NON-NLS-1$
    command.getName().equals("closeVncInfo") || "OnEditConsoleSave".equals(command.getName())) {
        // $NON-NLS-1$
        setWindow(null);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.getByExternalId(directoryUser.getDirectoryName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(new Guid(directoryUser.getId().getBytes(), true));
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DbUserDAO dao = getDbUserDAO();
    // First check if the user is already in the database, if it is we need to update, if not we need to insert:
    DbUser dbUser = dao.getByExternalId(directoryUser.getDirectoryName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.save(dbUser);
    } else {
        Guid id = dbUser.getId();
        dbUser = new DbUser(directoryUser);
        dbUser.setId(id);
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        dao.update(dbUser);
    }
    // Return the identifier of the created user:
    setActionReturnValue(dbUser.getId());
    setSucceeded(true);
}
#end_block

#method_before
public static String getSysPrep(VM vm, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    if (vm.getVmInit() != null && !StringUtils.isEmpty(vm.getVmInit().getCustomScript())) {
        sysPrepContent = vm.getVmInit().getCustomScript();
    } else {
        sysPrepContent = LoadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    }
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    String domain = (vm.getVmInit() != null && vm.getVmInit().getDomain() != null) ? vm.getVmInit().getDomain() : "";
    String hostName = (vm.getVmInit() != null && vm.getVmInit().getHostname() != null) ? vm.getVmInit().getHostname() : vm.getName();
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>getValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>getValue(ConfigValues.OrganizationName));
        String inputLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String uiLanguage = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String systemLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String userLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String activeDirectorAU = "";
        if (vm.getVmInit() != null) {
            if (!StringUtils.isEmpty(vm.getVmInit().getInputLocale())) {
                inputLocale = vm.getVmInit().getInputLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUiLanguage())) {
                uiLanguage = vm.getVmInit().getUiLanguage();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getSystemLocale())) {
                systemLocale = vm.getVmInit().getSystemLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUserLocale())) {
                userLocale = vm.getVmInit().getUserLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getActiveDirectoryOU())) {
                activeDirectorAU = vm.getVmInit().getActiveDirectoryOU();
            }
        }
        sysPrepContent = replace(sysPrepContent, "$SetupUiLanguageUiLanguage$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$InputLocale$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$UiLanguage$", uiLanguage);
        sysPrepContent = replace(sysPrepContent, "$SystemLocale$", systemLocale);
        sysPrepContent = replace(sysPrepContent, "$UserLocale$", userLocale);
        sysPrepContent = replace(sysPrepContent, "$MachineObjectOU$", activeDirectorAU);
    }
    return sysPrepContent;
}
#method_after
public static String getSysPrep(VM vm, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    if (vm.getVmInit() != null && !StringUtils.isEmpty(vm.getVmInit().getCustomScript())) {
        sysPrepContent = vm.getVmInit().getCustomScript();
    } else {
        sysPrepContent = LoadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    }
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    String domain = (vm.getVmInit() != null && vm.getVmInit().getDomain() != null) ? vm.getVmInit().getDomain() : "";
    String hostName = (vm.getVmInit() != null && vm.getVmInit().getHostname() != null) ? vm.getVmInit().getHostname() : vm.getName();
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>getValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>getValue(ConfigValues.OrganizationName));
        String inputLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String uiLanguage = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String systemLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String userLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String activeDirectoryOU = "";
        if (vm.getVmInit() != null) {
            if (!StringUtils.isEmpty(vm.getVmInit().getInputLocale())) {
                inputLocale = vm.getVmInit().getInputLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUiLanguage())) {
                uiLanguage = vm.getVmInit().getUiLanguage();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getSystemLocale())) {
                systemLocale = vm.getVmInit().getSystemLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getUserLocale())) {
                userLocale = vm.getVmInit().getUserLocale();
            }
            if (!StringUtils.isEmpty(vm.getVmInit().getActiveDirectoryOU())) {
                activeDirectoryOU = vm.getVmInit().getActiveDirectoryOU();
            }
        }
        sysPrepContent = replace(sysPrepContent, "$SetupUiLanguageUiLanguage$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$InputLocale$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$UiLanguage$", uiLanguage);
        sysPrepContent = replace(sysPrepContent, "$SystemLocale$", systemLocale);
        sysPrepContent = replace(sysPrepContent, "$UserLocale$", userLocale);
        sysPrepContent = replace(sysPrepContent, "$MachineObjectOU$", activeDirectoryOU);
    }
    return sysPrepContent;
}
#end_block

#method_before
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<Object>();
    networkNameEditor = new EntityModelTextBoxEditor();
    networkComboBox = new ComboBox(networkListEditor, networkNameEditor);
}
#method_after
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<String>();
    networkNameEditor = new StringEntityModelTextBoxEditor();
    networkComboBox = new ComboBox<String>(networkListEditor, networkNameEditor);
}
#end_block

#method_before
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !(Boolean) model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#method_after
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#end_block

#method_before
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled((Boolean) model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled((Boolean) model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = (Boolean) model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#method_after
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled(model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled(model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#end_block

#method_before
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty((String) getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty((String) getHostname().getEntity());
    }
}
#method_after
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty(getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty(getHostname().getEntity());
    }
}
#end_block

#method_before
public ListModel getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#method_after
public ListModel<Map.Entry<String, String>> getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#end_block

#method_before
public void setWindowsSysprepTimeZone(ListModel windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#method_after
public void setWindowsSysprepTimeZone(ListModel<Map.Entry<String, String>> windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#end_block

#method_before
public EntityModel getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public void setWindowsSysprepTimeZoneEnabled(EntityModel windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#method_after
public void setWindowsSysprepTimeZoneEnabled(EntityModel<Boolean> windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public EntityModel getWindowsHostname() {
    return privateWindowsHostname;
}
#method_after
public EntityModel<String> getWindowsHostname() {
    return privateWindowsHostname;
}
#end_block

#method_before
private void setWindowsHostname(EntityModel value) {
    privateWindowsHostname = value;
}
#method_after
private void setWindowsHostname(EntityModel<String> value) {
    privateWindowsHostname = value;
}
#end_block

#method_before
public EntityModel getHostname() {
    return privateHostname;
}
#method_after
public EntityModel<String> getHostname() {
    return privateHostname;
}
#end_block

#method_before
private void setHostname(EntityModel value) {
    privateHostname = value;
}
#method_after
private void setHostname(EntityModel<String> value) {
    privateHostname = value;
}
#end_block

#method_before
public EntityModel getInputLocale() {
    return privateInputLocale;
}
#method_after
public EntityModel<String> getInputLocale() {
    return privateInputLocale;
}
#end_block

#method_before
private void setInputLocale(EntityModel value) {
    privateInputLocale = value;
}
#method_after
private void setInputLocale(EntityModel<String> value) {
    privateInputLocale = value;
}
#end_block

#method_before
public EntityModel getUiLanguage() {
    return privateUiLanguage;
}
#method_after
public EntityModel<String> getUiLanguage() {
    return privateUiLanguage;
}
#end_block

#method_before
private void setUiLanguage(EntityModel value) {
    privateUiLanguage = value;
}
#method_after
private void setUiLanguage(EntityModel<String> value) {
    privateUiLanguage = value;
}
#end_block

#method_before
public EntityModel getSystemLocale() {
    return privateSystemLocale;
}
#method_after
public EntityModel<String> getSystemLocale() {
    return privateSystemLocale;
}
#end_block

#method_before
private void setSystemLocale(EntityModel value) {
    privateSystemLocale = value;
}
#method_after
private void setSystemLocale(EntityModel<String> value) {
    privateSystemLocale = value;
}
#end_block

#method_before
public EntityModel getUserLocale() {
    return privateUserLocale;
}
#method_after
public EntityModel<String> getUserLocale() {
    return privateUserLocale;
}
#end_block

#method_before
private void setUserLocale(EntityModel value) {
    privateUserLocale = value;
}
#method_after
private void setUserLocale(EntityModel<String> value) {
    privateUserLocale = value;
}
#end_block

#method_before
public EntityModel getDomain() {
    return privateDomain;
}
#method_after
public EntityModel<String> getDomain() {
    return privateDomain;
}
#end_block

#method_before
private void setDomain(EntityModel value) {
    privateDomain = value;
}
#method_after
private void setDomain(EntityModel<String> value) {
    privateDomain = value;
}
#end_block

#method_before
public EntityModel getUserName() {
    return privateUserName;
}
#method_after
public EntityModel<String> getUserName() {
    return privateUserName;
}
#end_block

#method_before
private void setUserName(EntityModel value) {
    privateUserName = value;
}
#method_after
private void setUserName(EntityModel<String> value) {
    privateUserName = value;
}
#end_block

#method_before
public EntityModel getActiveDirectoryOU() {
    return privateActiveDirectoryOU;
}
#method_after
public EntityModel<String> getActiveDirectoryOU() {
    return privateActiveDirectoryOU;
}
#end_block

#method_before
private void setActiveDirectoryOU(EntityModel value) {
    privateActiveDirectoryOU = value;
}
#method_after
private void setActiveDirectoryOU(EntityModel<String> value) {
    privateActiveDirectoryOU = value;
}
#end_block

#method_before
public EntityModel getCustomScript() {
    return privateCustomScript;
}
#method_after
public EntityModel<String> getCustomScript() {
    return privateCustomScript;
}
#end_block

#method_before
private void setCustomScript(EntityModel value) {
    privateCustomScript = value;
}
#method_after
private void setCustomScript(EntityModel<String> value) {
    privateCustomScript = value;
}
#end_block

#method_before
public EntityModel getSysprepScript() {
    return privateSysprepScript;
}
#method_after
public EntityModel<String> getSysprepScript() {
    return privateSysprepScript;
}
#end_block

#method_before
private void setSysprepScript(EntityModel value) {
    privateSysprepScript = value;
}
#method_after
private void setSysprepScript(EntityModel<String> value) {
    privateSysprepScript = value;
}
#end_block

#method_before
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#method_after
public EntityModel<String> getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#end_block

#method_before
private void setAuthorizedKeys(EntityModel value) {
    privateAuthorizedKeys = value;
}
#method_after
private void setAuthorizedKeys(EntityModel<String> value) {
    privateAuthorizedKeys = value;
}
#end_block

#method_before
public EntityModel getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#method_after
public EntityModel<Boolean> getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#end_block

#method_before
private void setRegenerateKeysEnabled(EntityModel value) {
    privateRegenerateKeysEnabled = value;
}
#method_after
private void setRegenerateKeysEnabled(EntityModel<Boolean> value) {
    privateRegenerateKeysEnabled = value;
}
#end_block

#method_before
public EntityModel getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#end_block

#method_before
private void setTimeZoneEnabled(EntityModel value) {
    privateTimeZoneEnabled = value;
}
#method_after
private void setTimeZoneEnabled(EntityModel<Boolean> value) {
    privateTimeZoneEnabled = value;
}
#end_block

#method_before
public ListModel getTimeZoneList() {
    return privateTimeZoneList;
}
#method_after
public ListModel<Map.Entry<String, String>> getTimeZoneList() {
    return privateTimeZoneList;
}
#end_block

#method_before
private void setTimeZoneList(ListModel value) {
    privateTimeZoneList = value;
}
#method_after
private void setTimeZoneList(ListModel<Map.Entry<String, String>> value) {
    privateTimeZoneList = value;
}
#end_block

#method_before
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getRootPassword() {
    return privateRootPassword;
}
#method_after
public EntityModel<String> getRootPassword() {
    return privateRootPassword;
}
#end_block

#method_before
private void setRootPassword(EntityModel value) {
    privateRootPassword = value;
}
#method_after
private void setRootPassword(EntityModel<String> value) {
    privateRootPassword = value;
}
#end_block

#method_before
public EntityModel getPasswordSet() {
    return privatePasswordSet;
}
#method_after
public EntityModel<Boolean> getPasswordSet() {
    return privatePasswordSet;
}
#end_block

#method_before
private void setPasswordSet(EntityModel value) {
    privatePasswordSet = value;
}
#method_after
private void setPasswordSet(EntityModel<Boolean> value) {
    privatePasswordSet = value;
}
#end_block

#method_before
public EntityModel getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#method_after
public EntityModel<String> getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#end_block

#method_before
private void setRootPasswordVerification(EntityModel value) {
    privateRootPasswordVerification = value;
}
#method_after
private void setRootPasswordVerification(EntityModel<String> value) {
    privateRootPasswordVerification = value;
}
#end_block

#method_before
public EntityModel getNetworkEnabled() {
    return privateNetworkEnabled;
}
#method_after
public EntityModel<Boolean> getNetworkEnabled() {
    return privateNetworkEnabled;
}
#end_block

#method_before
private void setNetworkEnabled(EntityModel value) {
    privateNetworkEnabled = value;
}
#method_after
private void setNetworkEnabled(EntityModel<Boolean> value) {
    privateNetworkEnabled = value;
}
#end_block

#method_before
public EntityModel getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#method_after
public EntityModel<String> getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#end_block

#method_before
private void setNetworkSelectedName(EntityModel value) {
    privateNetworkSelectedName = value;
}
#method_after
private void setNetworkSelectedName(EntityModel<String> value) {
    privateNetworkSelectedName = value;
}
#end_block

#method_before
public ListModel getNetworkList() {
    return privateNetworkList;
}
#method_after
public ListModel<String> getNetworkList() {
    return privateNetworkList;
}
#end_block

#method_before
private void setNetworkList(ListModel value) {
    privateNetworkList = value;
}
#method_after
private void setNetworkList(ListModel<String> value) {
    privateNetworkList = value;
}
#end_block

#method_before
public EntityModel getNetworkDhcp() {
    return privateNetworkDhcp;
}
#method_after
public EntityModel<Boolean> getNetworkDhcp() {
    return privateNetworkDhcp;
}
#end_block

#method_before
private void setNetworkDhcp(EntityModel value) {
    privateNetworkDhcp = value;
}
#method_after
private void setNetworkDhcp(EntityModel<Boolean> value) {
    privateNetworkDhcp = value;
}
#end_block

#method_before
public EntityModel getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#method_after
public EntityModel<String> getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#end_block

#method_before
private void setNetworkIpAddress(EntityModel value) {
    privateNetworkIpAddress = value;
}
#method_after
private void setNetworkIpAddress(EntityModel<String> value) {
    privateNetworkIpAddress = value;
}
#end_block

#method_before
public EntityModel getNetworkNetmask() {
    return privateNetworkNetmask;
}
#method_after
public EntityModel<String> getNetworkNetmask() {
    return privateNetworkNetmask;
}
#end_block

#method_before
private void setNetworkNetmask(EntityModel value) {
    privateNetworkNetmask = value;
}
#method_after
private void setNetworkNetmask(EntityModel<String> value) {
    privateNetworkNetmask = value;
}
#end_block

#method_before
public EntityModel getNetworkGateway() {
    return privateNetworkGateway;
}
#method_after
public EntityModel<String> getNetworkGateway() {
    return privateNetworkGateway;
}
#end_block

#method_before
private void setNetworkGateway(EntityModel value) {
    privateNetworkGateway = value;
}
#method_after
private void setNetworkGateway(EntityModel<String> value) {
    privateNetworkGateway = value;
}
#end_block

#method_before
public EntityModel getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#method_after
public EntityModel<Boolean> getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#end_block

#method_before
private void setNetworkStartOnBoot(EntityModel value) {
    privateNetworkStartOnBoot = value;
}
#method_after
private void setNetworkStartOnBoot(EntityModel<Boolean> value) {
    privateNetworkStartOnBoot = value;
}
#end_block

#method_before
public EntityModel getDnsServers() {
    return privateDnsServers;
}
#method_after
public EntityModel<String> getDnsServers() {
    return privateDnsServers;
}
#end_block

#method_before
public void setDnsServers(EntityModel dnsServers) {
    privateDnsServers = dnsServers;
}
#method_after
public void setDnsServers(EntityModel<String> dnsServers) {
    privateDnsServers = dnsServers;
}
#end_block

#method_before
public EntityModel getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#method_after
public EntityModel<String> getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#end_block

#method_before
public void setDnsSearchDomains(EntityModel dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#method_after
public void setDnsSearchDomains(EntityModel<String> dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#end_block

#method_before
public EntityModel getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#method_after
public EntityModel<Boolean> getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#end_block

#method_before
private void setAttachmentEnabled(EntityModel value) {
    privateAttachmentEnabled = value;
}
#method_after
private void setAttachmentEnabled(EntityModel<Boolean> value) {
    privateAttachmentEnabled = value;
}
#end_block

#method_before
private void selectTimeZone(ListModel specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#method_after
private void selectTimeZone(ListModel<Map.Entry<String, String>> specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#end_block

#method_before
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if ((Boolean) getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString((String) getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString((String) getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#method_after
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#end_block

#method_before
private boolean validateHidden(EntityModel entity, final Object value, final String message, final IValidation[] validations) {
    EntityModel tmp = new EntityModel(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#method_after
private boolean validateHidden(EntityModel<String> entity, final String value, final String message, final IValidation[] validations) {
    EntityModel<String> tmp = new EntityModel<String>(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#end_block

#method_before
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if ((Boolean) model.getIsSysprepEnabled().getEntity() || (Boolean) model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), (String) model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#method_after
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if (model.getIsSysprepEnabled().getEntity() || model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#end_block

#method_before
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && (Boolean) getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && (Boolean) getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain((String) getDomain().getEntity());
    }
    return vmInit;
}
#method_after
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain(getDomain().getEntity());
    }
    return vmInit;
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
        vmInit.setCustomScript((String) getSysprepScript().getEntity());
        vmInit.setActiveDirectoryOU((String) getActiveDirectoryOU().getEntity());
    } else {
        vmInit.setCustomScript((String) getCustomScript().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? getWindowsHostname().getEntity() : getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
        vmInit.setCustomScript((String) getSysprepScript().getEntity());
        vmInit.setActiveDirectoryOU((String) getActiveDirectoryOU().getEntity());
    } else {
        vmInit.setCustomScript((String) getCustomScript().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword(getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys(getAuthorizedKeys().getEntity());
    if (getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList<VmInitNetwork>(networkMap.values()));
        }
    }
    vmInit.setDnsServers(getDnsServers().getEntity());
    vmInit.setDnsSearch(getDnsSearchDomains().getEntity());
    vmInit.setCustomScript(getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored(getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private void passwordSetChanged() {
    Boolean passwordChangable = !(Boolean) getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#method_after
private void passwordSetChanged() {
    Boolean passwordChangable = !getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#end_block

#method_before
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = (String) getNetworkList().getSelectedItem();
}
#method_after
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = getNetworkList().getSelectedItem();
}
#end_block

#method_before
private void networkSelectedName_SelectionChanged() {
    String oldName = (String) getNetworkList().getSelectedItem();
    String newName = (String) getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#method_after
private void networkSelectedName_SelectionChanged() {
    String oldName = getNetworkList().getSelectedItem();
    String newName = getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#end_block

#method_before
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && (Boolean) getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp((String) getNetworkIpAddress().getEntity());
            obj.setNetmask((String) getNetworkNetmask().getEntity());
            obj.setGateway((String) getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && (Boolean) getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#method_after
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp(getNetworkIpAddress().getEntity());
            obj.setNetmask(getNetworkNetmask().getEntity());
            obj.setGateway(getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = (String) getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#method_after
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#end_block

#method_before
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty((String) getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty((String) getHostname().getEntity());
    }
}
#method_after
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty(getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty(getHostname().getEntity());
    }
}
#end_block

#method_before
public ListModel getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#method_after
public ListModel<Map.Entry<String, String>> getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#end_block

#method_before
public void setWindowsSysprepTimeZone(ListModel windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#method_after
public void setWindowsSysprepTimeZone(ListModel<Map.Entry<String, String>> windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#end_block

#method_before
public EntityModel getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public void setWindowsSysprepTimeZoneEnabled(EntityModel windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#method_after
public void setWindowsSysprepTimeZoneEnabled(EntityModel<Boolean> windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public EntityModel getWindowsHostname() {
    return privateWindowsHostname;
}
#method_after
public EntityModel<String> getWindowsHostname() {
    return privateWindowsHostname;
}
#end_block

#method_before
private void setWindowsHostname(EntityModel value) {
    privateWindowsHostname = value;
}
#method_after
private void setWindowsHostname(EntityModel<String> value) {
    privateWindowsHostname = value;
}
#end_block

#method_before
public EntityModel getHostname() {
    return privateHostname;
}
#method_after
public EntityModel<String> getHostname() {
    return privateHostname;
}
#end_block

#method_before
private void setHostname(EntityModel value) {
    privateHostname = value;
}
#method_after
private void setHostname(EntityModel<String> value) {
    privateHostname = value;
}
#end_block

#method_before
public EntityModel getInputLocale() {
    return privateInputLocale;
}
#method_after
public EntityModel<String> getInputLocale() {
    return privateInputLocale;
}
#end_block

#method_before
private void setInputLocale(EntityModel value) {
    privateInputLocale = value;
}
#method_after
private void setInputLocale(EntityModel<String> value) {
    privateInputLocale = value;
}
#end_block

#method_before
public EntityModel getUiLanguage() {
    return privateUiLanguage;
}
#method_after
public EntityModel<String> getUiLanguage() {
    return privateUiLanguage;
}
#end_block

#method_before
private void setUiLanguage(EntityModel value) {
    privateUiLanguage = value;
}
#method_after
private void setUiLanguage(EntityModel<String> value) {
    privateUiLanguage = value;
}
#end_block

#method_before
public EntityModel getSystemLocale() {
    return privateSystemLocale;
}
#method_after
public EntityModel<String> getSystemLocale() {
    return privateSystemLocale;
}
#end_block

#method_before
private void setSystemLocale(EntityModel value) {
    privateSystemLocale = value;
}
#method_after
private void setSystemLocale(EntityModel<String> value) {
    privateSystemLocale = value;
}
#end_block

#method_before
public EntityModel getUserLocale() {
    return privateUserLocale;
}
#method_after
public EntityModel<String> getUserLocale() {
    return privateUserLocale;
}
#end_block

#method_before
private void setUserLocale(EntityModel value) {
    privateUserLocale = value;
}
#method_after
private void setUserLocale(EntityModel<String> value) {
    privateUserLocale = value;
}
#end_block

#method_before
public EntityModel getDomain() {
    return privateDomain;
}
#method_after
public EntityModel<String> getDomain() {
    return privateDomain;
}
#end_block

#method_before
private void setDomain(EntityModel value) {
    privateDomain = value;
}
#method_after
private void setDomain(EntityModel<String> value) {
    privateDomain = value;
}
#end_block

#method_before
public EntityModel getUserName() {
    return privateUserName;
}
#method_after
public EntityModel<String> getUserName() {
    return privateUserName;
}
#end_block

#method_before
private void setUserName(EntityModel value) {
    privateUserName = value;
}
#method_after
private void setUserName(EntityModel<String> value) {
    privateUserName = value;
}
#end_block

#method_before
public EntityModel getCustomScript() {
    return privateCustomScript;
}
#method_after
public EntityModel<String> getCustomScript() {
    return privateCustomScript;
}
#end_block

#method_before
private void setCustomScript(EntityModel value) {
    privateCustomScript = value;
}
#method_after
private void setCustomScript(EntityModel<String> value) {
    privateCustomScript = value;
}
#end_block

#method_before
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#method_after
public EntityModel<String> getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#end_block

#method_before
private void setAuthorizedKeys(EntityModel value) {
    privateAuthorizedKeys = value;
}
#method_after
private void setAuthorizedKeys(EntityModel<String> value) {
    privateAuthorizedKeys = value;
}
#end_block

#method_before
public EntityModel getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#method_after
public EntityModel<Boolean> getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#end_block

#method_before
private void setRegenerateKeysEnabled(EntityModel value) {
    privateRegenerateKeysEnabled = value;
}
#method_after
private void setRegenerateKeysEnabled(EntityModel<Boolean> value) {
    privateRegenerateKeysEnabled = value;
}
#end_block

#method_before
public EntityModel getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#end_block

#method_before
private void setTimeZoneEnabled(EntityModel value) {
    privateTimeZoneEnabled = value;
}
#method_after
private void setTimeZoneEnabled(EntityModel<Boolean> value) {
    privateTimeZoneEnabled = value;
}
#end_block

#method_before
public ListModel getTimeZoneList() {
    return privateTimeZoneList;
}
#method_after
public ListModel<Map.Entry<String, String>> getTimeZoneList() {
    return privateTimeZoneList;
}
#end_block

#method_before
private void setTimeZoneList(ListModel value) {
    privateTimeZoneList = value;
}
#method_after
private void setTimeZoneList(ListModel<Map.Entry<String, String>> value) {
    privateTimeZoneList = value;
}
#end_block

#method_before
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getRootPassword() {
    return privateRootPassword;
}
#method_after
public EntityModel<String> getRootPassword() {
    return privateRootPassword;
}
#end_block

#method_before
private void setRootPassword(EntityModel value) {
    privateRootPassword = value;
}
#method_after
private void setRootPassword(EntityModel<String> value) {
    privateRootPassword = value;
}
#end_block

#method_before
public EntityModel getPasswordSet() {
    return privatePasswordSet;
}
#method_after
public EntityModel<Boolean> getPasswordSet() {
    return privatePasswordSet;
}
#end_block

#method_before
private void setPasswordSet(EntityModel value) {
    privatePasswordSet = value;
}
#method_after
private void setPasswordSet(EntityModel<Boolean> value) {
    privatePasswordSet = value;
}
#end_block

#method_before
public EntityModel getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#method_after
public EntityModel<String> getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#end_block

#method_before
private void setRootPasswordVerification(EntityModel value) {
    privateRootPasswordVerification = value;
}
#method_after
private void setRootPasswordVerification(EntityModel<String> value) {
    privateRootPasswordVerification = value;
}
#end_block

#method_before
public EntityModel getNetworkEnabled() {
    return privateNetworkEnabled;
}
#method_after
public EntityModel<Boolean> getNetworkEnabled() {
    return privateNetworkEnabled;
}
#end_block

#method_before
private void setNetworkEnabled(EntityModel value) {
    privateNetworkEnabled = value;
}
#method_after
private void setNetworkEnabled(EntityModel<Boolean> value) {
    privateNetworkEnabled = value;
}
#end_block

#method_before
public EntityModel getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#method_after
public EntityModel<String> getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#end_block

#method_before
private void setNetworkSelectedName(EntityModel value) {
    privateNetworkSelectedName = value;
}
#method_after
private void setNetworkSelectedName(EntityModel<String> value) {
    privateNetworkSelectedName = value;
}
#end_block

#method_before
public ListModel getNetworkList() {
    return privateNetworkList;
}
#method_after
public ListModel<String> getNetworkList() {
    return privateNetworkList;
}
#end_block

#method_before
private void setNetworkList(ListModel value) {
    privateNetworkList = value;
}
#method_after
private void setNetworkList(ListModel<String> value) {
    privateNetworkList = value;
}
#end_block

#method_before
public EntityModel getNetworkDhcp() {
    return privateNetworkDhcp;
}
#method_after
public EntityModel<Boolean> getNetworkDhcp() {
    return privateNetworkDhcp;
}
#end_block

#method_before
private void setNetworkDhcp(EntityModel value) {
    privateNetworkDhcp = value;
}
#method_after
private void setNetworkDhcp(EntityModel<Boolean> value) {
    privateNetworkDhcp = value;
}
#end_block

#method_before
public EntityModel getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#method_after
public EntityModel<String> getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#end_block

#method_before
private void setNetworkIpAddress(EntityModel value) {
    privateNetworkIpAddress = value;
}
#method_after
private void setNetworkIpAddress(EntityModel<String> value) {
    privateNetworkIpAddress = value;
}
#end_block

#method_before
public EntityModel getNetworkNetmask() {
    return privateNetworkNetmask;
}
#method_after
public EntityModel<String> getNetworkNetmask() {
    return privateNetworkNetmask;
}
#end_block

#method_before
private void setNetworkNetmask(EntityModel value) {
    privateNetworkNetmask = value;
}
#method_after
private void setNetworkNetmask(EntityModel<String> value) {
    privateNetworkNetmask = value;
}
#end_block

#method_before
public EntityModel getNetworkGateway() {
    return privateNetworkGateway;
}
#method_after
public EntityModel<String> getNetworkGateway() {
    return privateNetworkGateway;
}
#end_block

#method_before
private void setNetworkGateway(EntityModel value) {
    privateNetworkGateway = value;
}
#method_after
private void setNetworkGateway(EntityModel<String> value) {
    privateNetworkGateway = value;
}
#end_block

#method_before
public EntityModel getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#method_after
public EntityModel<Boolean> getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#end_block

#method_before
private void setNetworkStartOnBoot(EntityModel value) {
    privateNetworkStartOnBoot = value;
}
#method_after
private void setNetworkStartOnBoot(EntityModel<Boolean> value) {
    privateNetworkStartOnBoot = value;
}
#end_block

#method_before
public EntityModel getDnsServers() {
    return privateDnsServers;
}
#method_after
public EntityModel<String> getDnsServers() {
    return privateDnsServers;
}
#end_block

#method_before
public void setDnsServers(EntityModel dnsServers) {
    privateDnsServers = dnsServers;
}
#method_after
public void setDnsServers(EntityModel<String> dnsServers) {
    privateDnsServers = dnsServers;
}
#end_block

#method_before
public EntityModel getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#method_after
public EntityModel<String> getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#end_block

#method_before
public void setDnsSearchDomains(EntityModel dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#method_after
public void setDnsSearchDomains(EntityModel<String> dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#end_block

#method_before
public EntityModel getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#method_after
public EntityModel<Boolean> getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#end_block

#method_before
private void setAttachmentEnabled(EntityModel value) {
    privateAttachmentEnabled = value;
}
#method_after
private void setAttachmentEnabled(EntityModel<Boolean> value) {
    privateAttachmentEnabled = value;
}
#end_block

#method_before
private void selectTimeZone(ListModel specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#method_after
private void selectTimeZone(ListModel<Map.Entry<String, String>> specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#end_block

#method_before
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if ((Boolean) getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString((String) getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString((String) getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#method_after
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#end_block

#method_before
private boolean validateHidden(EntityModel entity, final Object value, final String message, final IValidation[] validations) {
    EntityModel tmp = new EntityModel(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#method_after
private boolean validateHidden(EntityModel<String> entity, final String value, final String message, final IValidation[] validations) {
    EntityModel<String> tmp = new EntityModel<String>(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#end_block

#method_before
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if ((Boolean) model.getIsSysprepEnabled().getEntity() || (Boolean) model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), (String) model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#method_after
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if (model.getIsSysprepEnabled().getEntity() || model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#end_block

#method_before
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && (Boolean) getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && (Boolean) getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain((String) getDomain().getEntity());
    }
    return vmInit;
}
#method_after
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain(getDomain().getEntity());
    }
    return vmInit;
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? getWindowsHostname().getEntity() : getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword(getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys(getAuthorizedKeys().getEntity());
    if (getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList<VmInitNetwork>(networkMap.values()));
        }
    }
    vmInit.setDnsServers(getDnsServers().getEntity());
    vmInit.setDnsSearch(getDnsSearchDomains().getEntity());
    vmInit.setCustomScript(getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored(getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private void passwordSetChanged() {
    Boolean passwordChangable = !(Boolean) getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#method_after
private void passwordSetChanged() {
    Boolean passwordChangable = !getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#end_block

#method_before
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = (String) getNetworkList().getSelectedItem();
}
#method_after
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = getNetworkList().getSelectedItem();
}
#end_block

#method_before
private void networkSelectedName_SelectionChanged() {
    String oldName = (String) getNetworkList().getSelectedItem();
    String newName = (String) getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#method_after
private void networkSelectedName_SelectionChanged() {
    String oldName = getNetworkList().getSelectedItem();
    String newName = getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#end_block

#method_before
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && (Boolean) getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp((String) getNetworkIpAddress().getEntity());
            obj.setNetmask((String) getNetworkNetmask().getEntity());
            obj.setGateway((String) getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && (Boolean) getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#method_after
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp(getNetworkIpAddress().getEntity());
            obj.setNetmask(getNetworkNetmask().getEntity());
            obj.setGateway(getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = (String) getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#method_after
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            // currently only root password supported in backend
            if ("root".equals(user.getUserName())) {
                entity.setRootPassword(user.getPassword());
            }
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#method_after
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            entity.setRootPassword(user.getPassword());
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#end_block

#method_before
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<Object>();
    networkNameEditor = new EntityModelTextBoxEditor();
    networkComboBox = new ComboBox(networkListEditor, networkNameEditor);
}
#method_after
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<String>();
    networkNameEditor = new StringEntityModelTextBoxEditor();
    networkComboBox = new ComboBox<String>(networkListEditor, networkNameEditor);
}
#end_block

#method_before
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !(Boolean) model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#method_after
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#end_block

#method_before
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled((Boolean) model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled((Boolean) model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = (Boolean) model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#method_after
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled(model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled(model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    // set (null), the action will fail if only one of those parameters is null.
    if (getParameters().getSysPrepUserName() == null ^ getParameters().getSysPrepPassword() == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_ONCE_WITH_ILLEGAL_SYSPREP_PARAM);
    }
    if (getParameters().getVmInit() != null) {
        if (!FeatureSupported.cloudInit(getVm().getVdsGroupCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLOUD_INIT_IS_NOT_SUPPORTED);
        }
        if (getParameters().getVmInit().isPasswordAlreadyStored()) {
            VmBase temp = new VmBase();
            temp.setId(getParameters().getVmId());
            VmHandler.updateVmInitFromDB(temp, false);
            getParameters().getVmInit().setRootPassword(temp.getVmInit().getRootPassword());
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    // set (null), the action will fail if only one of those parameters is null.
    if (getParameters().getSysPrepUserName() == null ^ getParameters().getSysPrepPassword() == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_ONCE_WITH_ILLEGAL_SYSPREP_PARAM);
    }
    if (getParameters().getVmInit() != null) {
        if (!OsRepositoryImpl.INSTANCE.isWindows(getVm().getOs()) && !FeatureSupported.cloudInit(getVm().getVdsGroupCompatibilityVersion())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLOUD_INIT_IS_NOT_SUPPORTED);
        }
        if (getParameters().getVmInit().isPasswordAlreadyStored()) {
            VmBase temp = new VmBase();
            temp.setId(getParameters().getVmId());
            VmHandler.updateVmInitFromDB(temp, false);
            getParameters().getVmInit().setRootPassword(temp.getVmInit().getRootPassword());
        }
    }
    return true;
}
#end_block

#method_before
@Override
protected void refreshBootParameters(RunVmParams runVmParameters) {
    if (runVmParameters == null) {
        return;
    }
    getVm().setInitrdUrl(runVmParameters.getInitrdUrl());
    getVm().setKernelUrl(runVmParameters.getKernelUrl());
    getVm().setKernelParams(runVmParameters.getKernelParams());
    getVm().setCustomProperties(runVmParameters.getCustomProperties());
    getVm().setBootSequence((runVmParameters.getBootSequence() != null) ? runVmParameters.getBootSequence() : getVm().getDefaultBootSequence());
}
#method_after
@Override
protected void refreshBootParameters(RunVmParams runVmParameters) {
    getVm().setInitrdUrl(runVmParameters.getInitrdUrl());
    getVm().setKernelUrl(runVmParameters.getKernelUrl());
    getVm().setKernelParams(runVmParameters.getKernelParams());
    getVm().setCustomProperties(runVmParameters.getCustomProperties());
    getVm().setBootSequence((runVmParameters.getBootSequence() != null) ? runVmParameters.getBootSequence() : getVm().getDefaultBootSequence());
    getVm().setRunOnce(true);
}
#end_block

#method_before
@Override
protected void initVm() {
    super.initVm();
    if (getParameters().getVncKeyboardLayout() == null) {
        getVm().getDynamicData().setVncKeyboardLayout(getVm().getDefaultVncKeyboardLayout());
    } else {
        // if is not null it means runVM was launch from the run once command, thus
        // the VM can run with keyboard layout type which is different from its default display type
        getVm().getDynamicData().setVncKeyboardLayout(getParameters().getVncKeyboardLayout());
    }
}
#method_after
@Override
protected void initVm() {
    super.initVm();
    if (getParameters().getVncKeyboardLayout() == null) {
        getVm().getDynamicData().setVncKeyboardLayout(getVm().getDefaultVncKeyboardLayout());
    } else {
        // if is not null it means runVM was launch from the run once command, thus
        // the VM can run with keyboard layout type which is different from its default display type
        getVm().getDynamicData().setVncKeyboardLayout(getParameters().getVncKeyboardLayout());
    }
    if (getParameters().getVmInit() != null) {
        getVm().setVmInit(getParameters().getVmInit());
    }
}
#end_block

#method_before
private SnapshotDao getSnapshotDao() {
    return DbFacade.getInstance().getSnapshotDao();
}
#method_after
private SnapshotDao getSnapshotDao() {
    return getDbFacade().getSnapshotDao();
}
#end_block

#method_before
protected void refreshBootParameters(RunVmParams runVmParameters) {
    if (runVmParameters == null) {
        return;
    }
    getVm().setBootSequence(getVm().getDefaultBootSequence());
}
#method_after
protected void refreshBootParameters(RunVmParams runVmParameters) {
    getVm().setBootSequence(getVm().getDefaultBootSequence());
    getVm().setRunOnce(false);
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            VmHandler.updateVmGuestAgentVersion(getVm());
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        setCommandShouldBeLogged(false);
        runningFailed();
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        runningFailed();
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    // Before running the VM we update its devices, as they may need to be changed due to
    // configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    setActionReturnValue(VMStatus.Down);
    initVm();
    perform();
}
#method_after
@Override
protected void executeVmCommand() {
    setActionReturnValue(VMStatus.Down);
    initVm();
    perform();
}
#end_block

#method_before
private String chooseCd() {
    if (!StringUtils.isEmpty(getParameters().getDiskPath())) {
        return getParameters().getDiskPath();
    }
    if (getVm().getBootSequence() != null && getVm().getBootSequence().containsSubsequence(BootSequence.D)) {
        return getVm().getIsoPath();
    }
    String guestToolPath = guestToolsVersionTreatment();
    if (guestToolPath != null) {
        return guestToolPath;
    }
    return getVm().getIsoPath();
}
#method_after
private String chooseCd() {
    if (getParameters().getDiskPath() != null) {
        return getParameters().getDiskPath();
    }
    if (getVm().getBootSequence() != null && getVm().getBootSequence().containsSubsequence(BootSequence.D)) {
        return getVm().getIsoPath();
    }
    String guestToolPath = guestToolsVersionTreatment();
    if (guestToolPath != null) {
        return guestToolPath;
    }
    return getVm().getIsoPath();
}
#end_block

#method_before
protected VMStatus createVm() {
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    getVm().setLastStartTime(new Date());
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.infoFormat("Running VM with attached cd {0}", cdPath);
    }
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, initCreateVmParams(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotIrrelevant = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#method_after
protected VMStatus createVm() {
    final String cdPath = chooseCd();
    if (StringUtils.isNotEmpty(cdPath)) {
        log.infoFormat("Running VM with attached cd {0}", cdPath);
    }
    updateCurrentCd(cdPath);
    getVm().setCdPath(cdPathWindowsToLinux(cdPath));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, buildCreateVmParameters(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotUsed = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#end_block

#method_before
protected void initVm() {
    if (!EnumSet.of(RunVmFlow.RUN, RunVmFlow.RESUME_HIBERNATE).contains(getFlow())) {
        return;
    }
    fetchVmDisksFromDb();
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                getVm().setInitializationType(InitializationType.Sysprep);
            } else if (getVm().getVmInit() != null) {
                getVm().setInitializationType(InitializationType.CloudInit);
            } else {
                getVm().setInitializationType(InitializationType.None);
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // if we attach floppy we don't need the sysprep
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVmStaticDAO().update(getVm().getStaticData());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
}
#method_after
protected void initVm() {
    if (!isInitVmRequired()) {
        return;
    }
    fetchVmDisksFromDb();
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    // Before running the VM we update its devices, as they may
    // need to be changed due to configuration option change
    VmDeviceUtils.updateVmDevices(getVm().getStaticData());
    getVm().setKvmEnable(getParameters().getKvmEnable());
    getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
    getVm().setAcpiEnable(getParameters().getAcpiEnable());
    // Clear the first user:
    getVm().setConsoleUserId(null);
    getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
    (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
    if (getParameters().getInitializationType() == null) {
        // if vm not initialized, use sysprep/cloud-init
        if (!getVm().isInitialized()) {
            VmHandler.updateVmInitFromDB(getVm().getStaticData(), false);
            if (osRepository.isWindows(getVm().getVmOsId())) {
                getVm().setInitializationType(InitializationType.Sysprep);
            } else if (getVm().getVmInit() != null) {
                getVm().setInitializationType(InitializationType.CloudInit);
            } else {
                getVm().setInitializationType(InitializationType.None);
            }
        }
    } else {
        getVm().setInitializationType(getParameters().getInitializationType());
    }
    // if we attach floppy we don't need the sysprep
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVmStaticDAO().update(getVm().getStaticData());
    }
    // get what cpu flags should be passed to vdsm according to cluster
    // cpu name
    getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
    VmHandler.updateVmGuestAgentVersion(getVm());
    getVm().setCpuName(getVdsGroup().getcpu_name());
    if (!getVm().getInterfaces().isEmpty()) {
        initParametersForExternalNetworks();
    }
    if (getFlow() != RunVmFlow.RESUME_HIBERNATE) {
        getVm().setHibernationVolHandle(getMemoryFromSnapshot());
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), getPredefinedVdsIdToRunOn(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void runningFailed() {
    if (memoryFromSnapshotIrrelevant) {
        removeMemoryFromActiveSnapshot();
    }
    super.runningFailed();
}
#method_after
@Override
protected void runningFailed() {
    if (memoryFromSnapshotUsed) {
        removeMemoryFromActiveSnapshot();
    }
    super.runningFailed();
}
#end_block

#method_before
private void removeMemoryFromActiveSnapshot() {
    if (memoryVolumeFromSnapshot.isEmpty()) {
        return;
    }
    // If the active snapshot is the only one that points to the memory volume we can remove it
    if (getSnapshotDao().getNumOfSnapshotsByMemory(memoryVolumeFromSnapshot) == 1) {
        removeMemoryVolumes(memoryVolumeFromSnapshot, getActionType(), true);
    }
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
}
#method_after
private void removeMemoryFromActiveSnapshot() {
    if (StringUtils.isEmpty(cachedMemoryVolumeFromSnapshot)) {
        return;
    }
    // If the active snapshot is the only one that points to the memory volume we can remove it
    if (getSnapshotDao().getNumOfSnapshotsByMemory(cachedMemoryVolumeFromSnapshot) == 1) {
        removeMemoryVolumes(cachedMemoryVolumeFromSnapshot, getActionType(), true);
    }
    getSnapshotDao().removeMemoryFromActiveSnapshot(getVmId());
}
#end_block

#method_before
public EntityModel getAttachFloppy() {
    return privateAttachFloppy;
}
#method_after
public EntityModel<Boolean> getAttachFloppy() {
    return privateAttachFloppy;
}
#end_block

#method_before
private void setAttachFloppy(EntityModel value) {
    privateAttachFloppy = value;
}
#method_after
private void setAttachFloppy(EntityModel<Boolean> value) {
    privateAttachFloppy = value;
}
#end_block

#method_before
public ListModel getFloppyImage() {
    return privateFloppyImage;
}
#method_after
public ListModel<String> getFloppyImage() {
    return privateFloppyImage;
}
#end_block

#method_before
private void setFloppyImage(ListModel value) {
    privateFloppyImage = value;
}
#method_after
private void setFloppyImage(ListModel<String> value) {
    privateFloppyImage = value;
}
#end_block

#method_before
public EntityModel getAttachIso() {
    return privateAttachIso;
}
#method_after
public EntityModel<Boolean> getAttachIso() {
    return privateAttachIso;
}
#end_block

#method_before
private void setAttachIso(EntityModel value) {
    privateAttachIso = value;
}
#method_after
private void setAttachIso(EntityModel<Boolean> value) {
    privateAttachIso = value;
}
#end_block

#method_before
public ListModel getIsoImage() {
    return privateIsoImage;
}
#method_after
public ListModel<String> getIsoImage() {
    return privateIsoImage;
}
#end_block

#method_before
private void setIsoImage(ListModel value) {
    privateIsoImage = value;
}
#method_after
private void setIsoImage(ListModel<String> value) {
    privateIsoImage = value;
}
#end_block

#method_before
public ListModel getDisplayProtocol() {
    return privateDisplayProtocol;
}
#method_after
public ListModel<EntityModel<DisplayType>> getDisplayProtocol() {
    return privateDisplayProtocol;
}
#end_block

#method_before
private void setDisplayProtocol(ListModel value) {
    privateDisplayProtocol = value;
}
#method_after
private void setDisplayProtocol(ListModel<EntityModel<DisplayType>> value) {
    privateDisplayProtocol = value;
}
#end_block

#method_before
public EntityModel getInitrd_path() {
    return privateInitrd_path;
}
#method_after
public EntityModel<String> getInitrd_path() {
    return privateInitrd_path;
}
#end_block

#method_before
private void setInitrd_path(EntityModel value) {
    privateInitrd_path = value;
}
#method_after
private void setInitrd_path(EntityModel<String> value) {
    privateInitrd_path = value;
}
#end_block

#method_before
public EntityModel getKernel_path() {
    return privateKernel_path;
}
#method_after
public EntityModel<String> getKernel_path() {
    return privateKernel_path;
}
#end_block

#method_before
private void setKernel_path(EntityModel value) {
    privateKernel_path = value;
}
#method_after
private void setKernel_path(EntityModel<String> value) {
    privateKernel_path = value;
}
#end_block

#method_before
public EntityModel getKernel_parameters() {
    return privateKernel_parameters;
}
#method_after
public EntityModel<String> getKernel_parameters() {
    return privateKernel_parameters;
}
#end_block

#method_before
private void setKernel_parameters(EntityModel value) {
    privateKernel_parameters = value;
}
#method_after
private void setKernel_parameters(EntityModel<String> value) {
    privateKernel_parameters = value;
}
#end_block

#method_before
public ListModel getSysPrepDomainName() {
    return privateSysPrepDomainName;
}
#method_after
public ListModel<String> getSysPrepDomainName() {
    return privateSysPrepDomainName;
}
#end_block

#method_before
private void setSysPrepDomainName(ListModel value) {
    privateSysPrepDomainName = value;
}
#method_after
private void setSysPrepDomainName(ListModel<String> value) {
    privateSysPrepDomainName = value;
}
#end_block

#method_before
public EntityModel getSysPrepSelectedDomainName() {
    return privateSysPrepSelectedDomainName;
}
#method_after
public EntityModel<String> getSysPrepSelectedDomainName() {
    return privateSysPrepSelectedDomainName;
}
#end_block

#method_before
private void setSysPrepSelectedDomainName(EntityModel value) {
    privateSysPrepSelectedDomainName = value;
}
#method_after
private void setSysPrepSelectedDomainName(EntityModel<String> value) {
    privateSysPrepSelectedDomainName = value;
}
#end_block

#method_before
public EntityModel getSysPrepUserName() {
    return privateSysPrepUserName;
}
#method_after
public EntityModel<String> getSysPrepUserName() {
    return privateSysPrepUserName;
}
#end_block

#method_before
private void setSysPrepUserName(EntityModel value) {
    privateSysPrepUserName = value;
}
#method_after
private void setSysPrepUserName(EntityModel<String> value) {
    privateSysPrepUserName = value;
}
#end_block

#method_before
public EntityModel getSysPrepPassword() {
    return privateSysPrepPassword;
}
#method_after
public EntityModel<String> getSysPrepPassword() {
    return privateSysPrepPassword;
}
#end_block

#method_before
private void setSysPrepPassword(EntityModel value) {
    privateSysPrepPassword = value;
}
#method_after
private void setSysPrepPassword(EntityModel<String> value) {
    privateSysPrepPassword = value;
}
#end_block

#method_before
public EntityModel getUseAlternateCredentials() {
    return privateUseAlternateCredentials;
}
#method_after
public EntityModel<Boolean> getUseAlternateCredentials() {
    return privateUseAlternateCredentials;
}
#end_block

#method_before
private void setUseAlternateCredentials(EntityModel value) {
    privateUseAlternateCredentials = value;
}
#method_after
private void setUseAlternateCredentials(EntityModel<Boolean> value) {
    privateUseAlternateCredentials = value;
}
#end_block

#method_before
public EntityModel getIsSysprepEnabled() {
    return privateIsSysprepEnabled;
}
#method_after
public EntityModel<Boolean> getIsSysprepEnabled() {
    return privateIsSysprepEnabled;
}
#end_block

#method_before
private void setIsSysprepEnabled(EntityModel value) {
    privateIsSysprepEnabled = value;
}
#method_after
private void setIsSysprepEnabled(EntityModel<Boolean> value) {
    privateIsSysprepEnabled = value;
}
#end_block

#method_before
public EntityModel getIsSysprepPossible() {
    return privateIsSysprepPossible;
}
#method_after
public EntityModel<Boolean> getIsSysprepPossible() {
    return privateIsSysprepPossible;
}
#end_block

#method_before
private void setIsSysprepPossible(EntityModel value) {
    privateIsSysprepPossible = value;
}
#method_after
private void setIsSysprepPossible(EntityModel<Boolean> value) {
    privateIsSysprepPossible = value;
}
#end_block

#method_before
public EntityModel getIsVmFirstRun() {
    return privateIsVmFirstRun;
}
#method_after
public EntityModel<Boolean> getIsVmFirstRun() {
    return privateIsVmFirstRun;
}
#end_block

#method_before
private void setIsVmFirstRun(EntityModel value) {
    privateIsVmFirstRun = value;
}
#method_after
private void setIsVmFirstRun(EntityModel<Boolean> value) {
    privateIsVmFirstRun = value;
}
#end_block

#method_before
public EntityModel getIsLinuxOptionsAvailable() {
    return privateIsLinuxOptionsAvailable;
}
#method_after
public EntityModel<Boolean> getIsLinuxOptionsAvailable() {
    return privateIsLinuxOptionsAvailable;
}
#end_block

#method_before
private void setIsLinuxOptionsAvailable(EntityModel value) {
    privateIsLinuxOptionsAvailable = value;
}
#method_after
private void setIsLinuxOptionsAvailable(EntityModel<Boolean> value) {
    privateIsLinuxOptionsAvailable = value;
}
#end_block

#method_before
public EntityModel getIsCloudInitEnabled() {
    return privateIsCloudInitEnabled;
}
#method_after
public EntityModel<Boolean> getIsCloudInitEnabled() {
    return privateIsCloudInitEnabled;
}
#end_block

#method_before
private void setIsCloudInitEnabled(EntityModel value) {
    privateIsCloudInitEnabled = value;
}
#method_after
private void setIsCloudInitEnabled(EntityModel<Boolean> value) {
    privateIsCloudInitEnabled = value;
}
#end_block

#method_before
public EntityModel getIsCloudInitPossible() {
    return privateIsCloudInitPossible;
}
#method_after
public EntityModel<Boolean> getIsCloudInitPossible() {
    return privateIsCloudInitPossible;
}
#end_block

#method_before
private void setIsCloudInitPossible(EntityModel value) {
    privateIsCloudInitPossible = value;
}
#method_after
private void setIsCloudInitPossible(EntityModel<Boolean> value) {
    privateIsCloudInitPossible = value;
}
#end_block

#method_before
public EntityModel getRunAndPause() {
    return privateRunAndPause;
}
#method_after
public EntityModel<Boolean> getRunAndPause() {
    return privateRunAndPause;
}
#end_block

#method_before
public void setRunAndPause(EntityModel value) {
    privateRunAndPause = value;
}
#method_after
public void setRunAndPause(EntityModel<Boolean> value) {
    privateRunAndPause = value;
}
#end_block

#method_before
public EntityModel getRunAsStateless() {
    return privateRunAsStateless;
}
#method_after
public EntityModel<Boolean> getRunAsStateless() {
    return privateRunAsStateless;
}
#end_block

#method_before
public void setRunAsStateless(EntityModel value) {
    privateRunAsStateless = value;
}
#method_after
public void setRunAsStateless(EntityModel<Boolean> value) {
    privateRunAsStateless = value;
}
#end_block

#method_before
public EntityModel getDisplayConsole_Vnc_IsSelected() {
    return privateDisplayConsole_Vnc_IsSelected;
}
#method_after
public EntityModel<Boolean> getDisplayConsole_Vnc_IsSelected() {
    return privateDisplayConsole_Vnc_IsSelected;
}
#end_block

#method_before
public void setDisplayConsole_Vnc_IsSelected(EntityModel value) {
    privateDisplayConsole_Vnc_IsSelected = value;
}
#method_after
public void setDisplayConsole_Vnc_IsSelected(EntityModel<Boolean> value) {
    privateDisplayConsole_Vnc_IsSelected = value;
}
#end_block

#method_before
public EntityModel getDisplayConsole_Spice_IsSelected() {
    return privateDisplayConsole_Spice_IsSelected;
}
#method_after
public EntityModel<Boolean> getDisplayConsole_Spice_IsSelected() {
    return privateDisplayConsole_Spice_IsSelected;
}
#end_block

#method_before
public void setDisplayConsole_Spice_IsSelected(EntityModel value) {
    privateDisplayConsole_Spice_IsSelected = value;
}
#method_after
public void setDisplayConsole_Spice_IsSelected(EntityModel<Boolean> value) {
    privateDisplayConsole_Spice_IsSelected = value;
}
#end_block

#method_before
public ListModel getDefaultHost() {
    return defaultHost;
}
#method_after
public ListModel<VDS> getDefaultHost() {
    return defaultHost;
}
#end_block

#method_before
private void setDefaultHost(ListModel value) {
    this.defaultHost = value;
}
#method_after
private void setDefaultHost(ListModel<VDS> value) {
    this.defaultHost = value;
}
#end_block

#method_before
public EntityModel getIsAutoAssign() {
    return isAutoAssign;
}
#method_after
public EntityModel<Boolean> getIsAutoAssign() {
    return isAutoAssign;
}
#end_block

#method_before
public void setIsAutoAssign(EntityModel value) {
    this.isAutoAssign = value;
}
#method_after
public void setIsAutoAssign(EntityModel<Boolean> value) {
    this.isAutoAssign = value;
}
#end_block

#method_before
// The "sysprep" option was moved from a standalone check box to a
// pseudo floppy disk image. In order not to change the back-end
// interface, the Reinitialize variable was changed to a read-only
// property and its value is based on the selected floppy image.
// A similar comparison is done for cloud-init iso images, so the
public InitializationType getInitializationType() {
    if (getAttachFloppy().getEntity() != null && (Boolean) getAttachFloppy().getEntity() && "[sysprep]".equals(getFloppyImage().getSelectedItem())) {
        // $NON-NLS-1$
        return InitializationType.Sysprep;
    } else if (getIsCloudInitEnabled().getEntity() != null && (Boolean) getIsCloudInitEnabled().getEntity()) {
        return InitializationType.CloudInit;
    } else {
        return InitializationType.None;
    }
}
#method_after
// The "sysprep" option was moved from a standalone check box to a
// pseudo floppy disk image. In order not to change the back-end
// interface, the Reinitialize variable was changed to a read-only
// property and its value is based on the selected floppy image.
// A similar comparison is done for cloud-init iso images, so the
public InitializationType getInitializationType() {
    if (getAttachFloppy().getEntity() != null && getAttachFloppy().getEntity() && "[sysprep]".equals(getFloppyImage().getSelectedItem())) {
        // $NON-NLS-1$
        return InitializationType.Sysprep;
    } else if (getIsCloudInitEnabled().getEntity() != null && getIsCloudInitEnabled().getEntity()) {
        return InitializationType.CloudInit;
    } else {
        return InitializationType.None;
    }
}
#end_block

#method_before
public String getFloppyImagePath() {
    if ((Boolean) getAttachFloppy().getEntity()) {
        return getInitializationType() == InitializationType.Sysprep ? "" : // $NON-NLS-1$
        (String) getFloppyImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#method_after
public String getFloppyImagePath() {
    if (getAttachFloppy().getEntity()) {
        return getInitializationType() == InitializationType.Sysprep ? "" : // $NON-NLS-1$
        getFloppyImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#end_block

#method_before
public String getIsoImagePath() {
    if ((Boolean) getAttachIso().getEntity()) {
        return (String) getIsoImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#method_after
public String getIsoImagePath() {
    if (getAttachIso().getEntity()) {
        return getIsoImage().getSelectedItem();
    } else {
        // $NON-NLS-1$
        return "";
    }
}
#end_block

#method_before
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    getAttachIso().setEntity(false);
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel vncProtocol = new EntityModel(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel qxlProtocol = new EntityModel(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
}
#method_after
public void init() {
    setTitle(ConstantsManager.getInstance().getConstants().runVirtualMachinesTitle());
    setHelpTag(HelpTag.run_virtual_machine);
    // $NON-NLS-1$
    setHashName("run_virtual_machine");
    // needs to be called before iso list is updated
    setIsoImagePath(vm.getIsoPath());
    getAttachFloppy().setEntity(false);
    getRunAsStateless().setEntity(vm.isStateless());
    getRunAndPause().setEntity(vm.isRunAndPause());
    setHwAcceleration(true);
    // passing Kernel parameters
    getKernel_parameters().setEntity(vm.getKernelParams());
    getKernel_path().setEntity(vm.getKernelUrl());
    getInitrd_path().setEntity(vm.getInitrdUrl());
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(vm.getVmOsId()));
    getIsLinuxOptionsAvailable().setEntity(getIsLinuxOS());
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(vm.getVmOsId()));
    getIsVmFirstRun().setEntity(!vm.isInitialized());
    initVmInitEnabled(vm.getVmInit(), vm.isInitialized());
    getVmInit().init(vm.getStaticData());
    setCustomPropertiesKeysList(customPropertiesKeysList);
    updateDomainList();
    updateIsoList();
    updateDisplayProtocols();
    updateFloppyImages();
    updateInitialRunFields();
    // Boot sequence.
    setIsBootFromNetworkAllowedForVm();
    setIsBootFromHardDiskAllowedForVm();
    // Display protocols.
    EntityModel<DisplayType> vncProtocol = new EntityModel<DisplayType>(DisplayType.vnc).setTitle(ConstantsManager.getInstance().getConstants().VNCTitle());
    EntityModel<DisplayType> qxlProtocol = new EntityModel<DisplayType>(DisplayType.qxl).setTitle(ConstantsManager.getInstance().getConstants().spiceTitle());
    getDisplayProtocol().setItems(Arrays.asList(vncProtocol, qxlProtocol));
    getDisplayProtocol().setSelectedItem(vm.getDefaultDisplayType() == DisplayType.vnc ? vncProtocol : qxlProtocol);
}
#end_block

#method_before
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setRunAndPause((Boolean) getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless((Boolean) getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties((String) getCustomProperties().getEntity());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl((String) getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams((String) getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl((String) getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName((String) getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword((String) getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && (Boolean) getIsCloudInitEnabled().getEntity() || getIsSysprepEnabled() != null && (Boolean) getIsSysprepEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) getDisplayProtocol().getSelectedItem();
    params.setUseVnc((DisplayType) displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if ((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity() || (Boolean) getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc((Boolean) getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = (String) getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#method_after
protected RunVmOnceParams createRunVmOnceParams() {
    RunVmOnceParams params = new RunVmOnceParams();
    params.setVmId(vm.getId());
    params.setBootSequence(getBootSequence().getSequence());
    params.setDiskPath(getIsoImagePath());
    params.setFloppyPath(getFloppyImagePath());
    params.setKvmEnable(getHwAcceleration());
    params.setRunAndPause(getRunAndPause().getEntity());
    params.setAcpiEnable(true);
    params.setRunAsStateless(getRunAsStateless().getEntity());
    params.setInitializationType(getInitializationType());
    params.setCustomProperties(getCustomPropertySheet().serialize());
    // kernel params
    if (getKernel_path().getEntity() != null) {
        params.setKernelUrl(getKernel_path().getEntity());
    }
    if (getKernel_parameters().getEntity() != null) {
        params.setKernelParams(getKernel_parameters().getEntity());
    }
    if (getInitrd_path().getEntity() != null) {
        params.setInitrdUrl(getInitrd_path().getEntity());
    }
    // Sysprep params
    if (getSysPrepUserName().getEntity() != null) {
        params.setSysPrepUserName(getSysPrepUserName().getEntity());
    }
    if (getSysPrepPassword().getEntity() != null) {
        params.setSysPrepPassword(getSysPrepPassword().getEntity());
    }
    if (getIsCloudInitEnabled() != null && getIsCloudInitEnabled().getEntity() || getIsSysprepEnabled() != null && getIsSysprepEnabled().getEntity()) {
        params.setVmInit(getVmInit().buildCloudInitParameters(this));
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) getDisplayProtocol().getSelectedItem();
    params.setUseVnc(displayProtocolSelectedItem.getEntity() == DisplayType.vnc);
    if (getDisplayConsole_Vnc_IsSelected().getEntity() || getDisplayConsole_Spice_IsSelected().getEntity()) {
        params.setUseVnc(getDisplayConsole_Vnc_IsSelected().getEntity());
    }
    params.setVncKeyboardLayout(getVncKeyboardLayout().getSelectedItem());
    String selectedDomain = getSysPrepSelectedDomainName().getEntity();
    if (!StringHelper.isNullOrEmpty(selectedDomain)) {
        params.setSysPrepDomainName(selectedDomain);
    }
    return params;
}
#end_block

#method_before
private void setIsBootFromHardDiskAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<Disk> vmDisks = (ArrayList<Disk>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (vmDisks.isEmpty()) {
                getRunAsStateless().setIsChangable(false);
                getRunAsStateless().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().disklessVmCannotRunAsStateless());
                getRunAsStateless().setEntity(false);
            }
            if (!isDisksContainBootableDisk(vmDisks)) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getHardDiskOption().setIsChangable(false);
                bootSequenceModel.getHardDiskOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootableDiskIsRequiredToBootFromDisk());
            }
        }
    }));
}
#method_after
private void setIsBootFromHardDiskAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllDisksByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<Disk> vmDisks = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (vmDisks.isEmpty()) {
                getRunAsStateless().setIsChangable(false);
                getRunAsStateless().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().disklessVmCannotRunAsStateless());
                getRunAsStateless().setEntity(false);
            }
            if (!isDisksContainBootableDisk(vmDisks)) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getHardDiskOption().setIsChangable(false);
                bootSequenceModel.getHardDiskOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().bootableDiskIsRequiredToBootFromDisk());
            }
        }
    }));
}
#end_block

#method_before
private void setIsBootFromNetworkAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<VmNetworkInterface> nics = (Collection<VmNetworkInterface>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            Collection<VmNetworkInterface> pluggedNics = Linq.where(nics, new Linq.IPredicate<VmNetworkInterface>() {

                @Override
                public boolean match(VmNetworkInterface vnic) {
                    return vnic.isPlugged();
                }
            });
            boolean hasPluggedNics = !((List<VmNetworkInterface>) pluggedNics).isEmpty();
            if (!hasPluggedNics) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().interfaceIsRequiredToBootFromNetwork());
            }
        }
    }));
}
#method_after
private void setIsBootFromNetworkAllowedForVm() {
    Frontend.getInstance().runQuery(VdcQueryType.GetVmInterfacesByVmId, new IdQueryParameters(vm.getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Collection<VmNetworkInterface> nics = ((VdcQueryReturnValue) returnValue).getReturnValue();
            Collection<VmNetworkInterface> pluggedNics = Linq.where(nics, new Linq.IPredicate<VmNetworkInterface>() {

                @Override
                public boolean match(VmNetworkInterface vnic) {
                    return vnic.isPlugged();
                }
            });
            boolean hasPluggedNics = !pluggedNics.isEmpty();
            if (!hasPluggedNics) {
                BootSequenceModel bootSequenceModel = getBootSequence();
                bootSequenceModel.getNetworkOption().setIsChangable(false);
                bootSequenceModel.getNetworkOption().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().interfaceIsRequiredToBootFromNetwork());
            }
        }
    }));
}
#end_block

#method_before
public void updateIsoList(boolean forceRefresh) {
    AsyncDataProvider.getIrsImageList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<String> images = (List<String>) returnValue;
            getIsoImage().setItems(images);
            if (getIsoImage().getIsChangable() && getIsoImage().getSelectedItem() == null) {
                getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    }), vm.getStoragePoolId(), forceRefresh);
}
#method_after
public void updateIsoList(boolean forceRefresh) {
    AsyncDataProvider.getIrsImageList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<String> images = (List<String>) returnValue;
            final String lastSelectedIso = getIsoImage().getSelectedItem();
            getIsoImage().setItems(images);
            if (getIsoImage().getIsChangable()) {
                // try to preselect last image
                if (lastSelectedIso != null && images.contains(lastSelectedIso)) {
                    getIsoImage().setSelectedItem(lastSelectedIso);
                } else {
                    getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
                }
            }
        }
    }), vm.getStoragePoolId(), forceRefresh);
}
#end_block

#method_before
private void updateDomainList() {
    // Update Domain list
    AsyncDataProvider.getDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<String> domains = (List<String>) returnValue;
            String oldDomain = (String) getSysPrepDomainName().getSelectedItem();
            if (oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                // $NON-NLS-1$
                domains.add(0, oldDomain);
            }
            getSysPrepDomainName().setItems(domains);
            String selectedDomain = (oldDomain != null) ? oldDomain : Linq.firstOrDefault(domains);
            if (!StringHelper.isNullOrEmpty(selectedDomain)) {
                getSysPrepDomainName().setSelectedItem(selectedDomain);
            }
        }
    }), true);
}
#method_after
private void updateDomainList() {
    // Update Domain list
    AsyncDataProvider.getDomainList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            List<String> domains = (List<String>) returnValue;
            String oldDomain = getSysPrepDomainName().getSelectedItem();
            if (oldDomain != null && !oldDomain.equals("") && !domains.contains(oldDomain)) {
                // $NON-NLS-1$
                domains.add(0, oldDomain);
            }
            getSysPrepDomainName().setItems(domains);
            String selectedDomain = (oldDomain != null) ? oldDomain : Linq.firstOrDefault(domains);
            if (!StringHelper.isNullOrEmpty(selectedDomain)) {
                getSysPrepDomainName().setSelectedItem(selectedDomain);
            }
        }
    }), true);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && (Boolean) ((EntityModel) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getIsoImage()) {
            IsoImage_SelectedItemChanged();
        } else if (sender == getFloppyImage()) {
            floppyImage_SelectedItemChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getAttachFloppy()) {
            attachFloppy_EntityChanged();
        } else if (sender == getAttachIso()) {
            attachIso_EntityChanged();
        } else if (sender == getIsVmFirstRun()) {
            isVmFirstRun_EntityChanged();
        } else if (sender == getUseAlternateCredentials()) {
            useAlternateCredentials_EntityChanged();
        } else if (sender == getDisplayConsole_Vnc_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Spice_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(true);
        } else if (sender == getDisplayConsole_Spice_IsSelected() && ((EntityModel<Boolean>) sender).getEntity()) {
            getDisplayConsole_Vnc_IsSelected().setEntity(false);
            getVncKeyboardLayout().setIsChangable(false);
        } else if (sender == getIsAutoAssign()) {
            isAutoAssign_EntityChanged(sender, args);
        }
    }
}
#end_block

#method_before
private void attachIso_EntityChanged() {
    getIsoImage().setIsChangable((Boolean) getAttachIso().getEntity());
    getBootSequence().getCdromOption().setIsChangable((Boolean) getAttachIso().getEntity());
    updateInitialRunFields();
}
#method_after
private void attachIso_EntityChanged() {
    getIsoImage().setIsChangable(getAttachIso().getEntity());
    getBootSequence().getCdromOption().setIsChangable(getAttachIso().getEntity());
    updateInitialRunFields();
}
#end_block

#method_before
private void attachFloppy_EntityChanged() {
    getFloppyImage().setIsChangable((Boolean) getAttachFloppy().getEntity());
    updateInitialRunFields();
}
#method_after
private void attachFloppy_EntityChanged() {
    getFloppyImage().setIsChangable(getAttachFloppy().getEntity());
    updateInitialRunFields();
}
#end_block

#method_before
private void useAlternateCredentials_EntityChanged() {
    boolean useAlternateCredentials = (Boolean) getUseAlternateCredentials().getEntity();
    getSysPrepUserName().setIsChangable((Boolean) getUseAlternateCredentials().getEntity());
    getSysPrepPassword().setIsChangable((Boolean) getUseAlternateCredentials().getEntity());
    // $NON-NLS-1$
    getSysPrepUserName().setEntity(useAlternateCredentials ? "" : null);
    // $NON-NLS-1$
    getSysPrepPassword().setEntity(useAlternateCredentials ? "" : null);
}
#method_after
private void useAlternateCredentials_EntityChanged() {
    boolean useAlternateCredentials = getUseAlternateCredentials().getEntity();
    getSysPrepUserName().setIsChangable(getUseAlternateCredentials().getEntity());
    getSysPrepPassword().setIsChangable(getUseAlternateCredentials().getEntity());
    // $NON-NLS-1$
    getSysPrepUserName().setEntity(useAlternateCredentials ? "" : null);
    // $NON-NLS-1$
    getSysPrepPassword().setEntity(useAlternateCredentials ? "" : null);
}
#end_block

#method_before
private void isAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if ((Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().setIsChangable(true);
    }
}
#method_after
private void isAutoAssign_EntityChanged(Object sender, EventArgs args) {
    if (getIsAutoAssign().getEntity() == false) {
        getDefaultHost().setIsChangable(true);
    }
}
#end_block

#method_before
public boolean validate() {
    getIsoImage().setIsValid(true);
    if ((Boolean) getAttachIso().getEntity()) {
        getIsoImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if ((Boolean) getAttachFloppy().getEntity()) {
        getFloppyImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty((String) getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty((String) getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty((String) getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getIsAutoAssign().getEntity() != null && (Boolean) getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    boolean cloudInitIsValid = getVmInit().validate();
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation && cloudInitIsValid;
}
#method_after
public boolean validate() {
    getIsoImage().setIsValid(true);
    if (getAttachIso().getEntity()) {
        getIsoImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getFloppyImage().setIsValid(true);
    if (getAttachFloppy().getEntity()) {
        getFloppyImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    boolean customPropertyValidation = getCustomPropertySheet().validate();
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    boolean cloudInitIsValid = getVmInit().validate();
    return getIsoImage().getIsValid() && getFloppyImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getDefaultHost().getIsValid() && customPropertyValidation && cloudInitIsValid;
}
#end_block

#method_before
@Override
protected void executeVdsIdCommand() {
    if (_vdsManager == null) {
        getVDSReturnValue().setSucceeded(false);
        return;
    }
    final VM vm = getParameters().getVm();
    if (canExecute() && ResourceManager.getInstance().AddAsyncRunningVm(vm.getId())) {
        CreateVDSCommand<?> command = null;
        try {
            command = initCreateVDSCommand(vm);
            command.execute();
            if (command.getVDSReturnValue().getSucceeded()) {
                saveSetInitializedToDb(vm.getId());
                vm.setInitialized(true);
                vm.setRunOnVds(getVdsId());
                if (getParameters().isClearHibernationVolumes()) {
                    vm.setHibernationVolHandle(StringUtils.EMPTY);
                }
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
            } else {
                handleCommandResult(command);
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
        } catch (java.lang.Exception e) {
            log.error("Error in excuting CreateVmVDSCommand", e);
            if (command != null && !command.getVDSReturnValue().getSucceeded()) {
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
            throw new RuntimeException(e);
        }
    }
    getVDSReturnValue().setReturnValue(vm.getStatus());
}
#method_after
@Override
protected void executeVdsIdCommand() {
    if (_vdsManager == null) {
        getVDSReturnValue().setSucceeded(false);
        return;
    }
    final VM vm = getParameters().getVm();
    vm.setLastStartTime(new Date());
    // if the VM is not suspended, it means that if there is 'hibernation volume'
    // set, it is actually memory from snapshot, thus it should be cleared right
    // after the VM started
    final boolean clearHibernationVolume = vm.getStatus() != VMStatus.Suspended;
    if (canExecute() && ResourceManager.getInstance().AddAsyncRunningVm(vm.getId())) {
        CreateVDSCommand<?> command = null;
        try {
            command = initCreateVDSCommand(vm);
            command.execute();
            if (command.getVDSReturnValue().getSucceeded()) {
                saveSetInitializedToDb(vm.getId());
                vm.setInitialized(true);
                vm.setRunOnVds(getVdsId());
                if (clearHibernationVolume) {
                    vm.setHibernationVolHandle(StringUtils.EMPTY);
                }
                DbFacade.getInstance().getVmDynamicDao().update(vm.getDynamicData());
            } else {
                handleCommandResult(command);
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
        } catch (Exception e) {
            log.error("Error in excuting CreateVmVDSCommand", e);
            if (command != null && !command.getVDSReturnValue().getSucceeded()) {
                ResourceManager.getInstance().RemoveAsyncRunningVm(getParameters().getVmId());
            }
            throw new RuntimeException(e);
        }
    }
    getVDSReturnValue().setReturnValue(vm.getStatus());
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(vm.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (entity.getVmInit().getDomain() != null) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (entity.getVmInit().getDomain() != null) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity.getStaticData(), null));
    }
    return model;
}
#end_block

#method_before
@Mapping(from = CloudInit.class, to = VmInit.class)
public static VmInit map(CloudInit model, VmInit template) {
    VmInit entity = template != null ? template : new VmInit();
    if (model.isSetHost() && model.getHost().isSetAddress()) {
        entity.setHostname(model.getHost().getAddress());
    }
    if (model.isSetAuthorizedKeys() && model.getAuthorizedKeys().isSetAuthorizedKeys() && !model.getAuthorizedKeys().getAuthorizedKeys().isEmpty()) {
        StringBuilder keys = new StringBuilder();
        for (AuthorizedKey authKey : model.getAuthorizedKeys().getAuthorizedKeys()) {
            if (keys.length() > 0) {
                keys.append("\n");
            }
            keys.append(authKey.getKey());
        }
        entity.setAuthorizedKeys(keys.toString());
    }
    if (model.isSetRegenerateSshKeys()) {
        entity.setRegenerateKeys(model.isRegenerateSshKeys());
    }
    if (model.isSetNetworkConfiguration()) {
        if (model.getNetworkConfiguration().isSetNics()) {
            List<VmInitNetwork> interfaces = new ArrayList<VmInitNetwork>();
            for (NIC iface : model.getNetworkConfiguration().getNics().getNics()) {
                VmInitNetwork vmInitInterface = new VmInitNetwork();
                interfaces.add(vmInitInterface);
                if (iface.isSetBootProtocol()) {
                    NetworkBootProtocol protocol = BootProtocolMapper.map(BootProtocol.fromValue(iface.getBootProtocol()), vmInitInterface.getBootProtocol());
                    vmInitInterface.setBootProtocol(protocol);
                    if (protocol != NetworkBootProtocol.DHCP && iface.isSetNetwork() && iface.getNetwork().isSetIp()) {
                        if (iface.getNetwork().getIp().isSetAddress()) {
                            vmInitInterface.setIp(iface.getNetwork().getIp().getAddress());
                        }
                        if (iface.getNetwork().getIp().isSetNetmask()) {
                            vmInitInterface.setNetmask(iface.getNetwork().getIp().getNetmask());
                        }
                        if (iface.getNetwork().getIp().isSetGateway()) {
                            vmInitInterface.setGateway(iface.getNetwork().getIp().getGateway());
                        }
                    }
                    if (iface.isSetOnBoot() && iface.isOnBoot()) {
                        vmInitInterface.setStartOnBoot(true);
                    }
                }
            }
            entity.setNetworks(interfaces);
        }
        if (model.getNetworkConfiguration().isSetDns()) {
            if (model.getNetworkConfiguration().getDns().isSetServers() && model.getNetworkConfiguration().getDns().getServers().isSetHosts() && !model.getNetworkConfiguration().getDns().getServers().getHosts().isEmpty()) {
                StringBuilder dnsServers = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getServers().getHosts()) {
                    if (host.isSetAddress()) {
                        dnsServers.append(host.getAddress());
                    }
                }
                entity.setDnsServers(dnsServers.toString());
            }
            if (model.getNetworkConfiguration().getDns().isSetSearchDomains() && model.getNetworkConfiguration().getDns().getSearchDomains().isSetHosts() && !model.getNetworkConfiguration().getDns().getSearchDomains().getHosts().isEmpty()) {
                StringBuilder searchDomains = new StringBuilder();
                for (Host host : model.getNetworkConfiguration().getDns().getSearchDomains().getHosts()) {
                    if (host.isSetAddress()) {
                        searchDomains.append(host.getAddress());
                    }
                }
                entity.setDnsSearch(searchDomains.toString());
            }
        }
    }
    if (model.isSetTimezone() && model.getTimezone() != null) {
        entity.setTimeZone(model.getTimezone());
    }
    if (model.isSetUsers()) {
        for (User user : model.getUsers().getUsers()) {
            // currently only root password supported in backend
            if ("root".equals(user.getUserName())) {
                entity.setRootPassword(user.getPassword());
            }
        }
    }
    // for RunOnce backward compatibility.
    if (model.isSetFiles() && model.getFiles().isSetFiles() && !model.getFiles().getFiles().isEmpty()) {
        File file = model.getFiles().getFiles().get(0);
        entity.setCustomScript(file.getContent());
    }
    return entity;
}
#method_after
public static Sessions map(org.ovirt.engine.core.common.businessentities.VM vm, Sessions sessions) {
    if (sessions == null) {
        sessions = new Sessions();
    }
    mapConsoleSession(vm, sessions);
    mapGuestSessions(vm, sessions);
    return sessions;
}
#end_block

#method_before
public static String getSysPrep(VM vm, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    sysPrepContent = LoadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    String domain = (vm.getVmInit() != null && vm.getVmInit().getDomain() != null) ? vm.getVmInit().getDomain() : "";
    String hostName = (vm.getVmInit() != null && vm.getVmInit().getHostname() != null) ? vm.getVmInit().getHostname() : vm.getName();
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>getValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>getValue(ConfigValues.OrganizationName));
        if (vm.getVmInit() != null) {
            sysPrepContent = replace(sysPrepContent, "$SetupUiLanguageUiLanguage$", vm.getVmInit().getInputLocale() != null ? vm.getVmInit().getInputLocale() : Config.<String>getValue(ConfigValues.DefaultSysprepLocale));
            sysPrepContent = replace(sysPrepContent, "$InputLocale$", vm.getVmInit().getInputLocale() != null ? vm.getVmInit().getInputLocale() : Config.<String>getValue(ConfigValues.DefaultSysprepLocale));
            sysPrepContent = replace(sysPrepContent, "$UiLanguage$", vm.getVmInit().getUiLanguage() != null ? vm.getVmInit().getUiLanguage() : Config.<String>getValue(ConfigValues.DefaultSysprepLocale));
            sysPrepContent = replace(sysPrepContent, "$SystemLocale$", vm.getVmInit().getSystemLocale() != null ? vm.getVmInit().getSystemLocale() : Config.<String>getValue(ConfigValues.DefaultSysprepLocale));
            sysPrepContent = replace(sysPrepContent, "$UserLocale$", vm.getVmInit().getUserLocale() != null ? vm.getVmInit().getUserLocale() : Config.<String>getValue(ConfigValues.DefaultSysprepLocale));
        }
    }
    return sysPrepContent;
}
#method_after
public static String getSysPrep(VM vm, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    sysPrepContent = LoadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    String domain = (vm.getVmInit() != null && vm.getVmInit().getDomain() != null) ? vm.getVmInit().getDomain() : "";
    String hostName = (vm.getVmInit() != null && vm.getVmInit().getHostname() != null) ? vm.getVmInit().getHostname() : vm.getName();
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>getValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>getValue(ConfigValues.OrganizationName));
        String inputLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String uiLanguage = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String systemLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        String userLocale = Config.<String>getValue(ConfigValues.DefaultSysprepLocale);
        if (vm.getVmInit() != null) {
            if (vm.getVmInit().getInputLocale() != null) {
                inputLocale = vm.getVmInit().getInputLocale();
            }
            if (vm.getVmInit().getUiLanguage() != null) {
                uiLanguage = vm.getVmInit().getUiLanguage();
            }
            if (vm.getVmInit().getSystemLocale() != null) {
                systemLocale = vm.getVmInit().getSystemLocale();
            }
            if (vm.getVmInit().getUserLocale() != null) {
                userLocale = vm.getVmInit().getUserLocale();
            }
        }
        sysPrepContent = replace(sysPrepContent, "$SetupUiLanguageUiLanguage$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$InputLocale$", inputLocale);
        sysPrepContent = replace(sysPrepContent, "$UiLanguage$", uiLanguage);
        sysPrepContent = replace(sysPrepContent, "$SystemLocale$", systemLocale);
        sysPrepContent = replace(sysPrepContent, "$UserLocale$", userLocale);
    }
    return sysPrepContent;
}
#end_block

#method_before
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty((String) getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty((String) getHostname().getEntity());
    }
}
#method_after
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty(getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty(getHostname().getEntity());
    }
}
#end_block

#method_before
public ListModel getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#method_after
public ListModel<Map.Entry<String, String>> getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#end_block

#method_before
public void setWindowsSysprepTimeZone(ListModel windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#method_after
public void setWindowsSysprepTimeZone(ListModel<Map.Entry<String, String>> windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#end_block

#method_before
public EntityModel getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public void setWindowsSysprepTimeZoneEnabled(EntityModel windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#method_after
public void setWindowsSysprepTimeZoneEnabled(EntityModel<Boolean> windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public EntityModel getWindowsHostname() {
    return privateWindowsHostname;
}
#method_after
public EntityModel<String> getWindowsHostname() {
    return privateWindowsHostname;
}
#end_block

#method_before
private void setWindowsHostname(EntityModel value) {
    privateWindowsHostname = value;
}
#method_after
private void setWindowsHostname(EntityModel<String> value) {
    privateWindowsHostname = value;
}
#end_block

#method_before
public EntityModel getHostname() {
    return privateHostname;
}
#method_after
public EntityModel<String> getHostname() {
    return privateHostname;
}
#end_block

#method_before
private void setHostname(EntityModel value) {
    privateHostname = value;
}
#method_after
private void setHostname(EntityModel<String> value) {
    privateHostname = value;
}
#end_block

#method_before
public EntityModel getInputLocale() {
    return privateInputLocale;
}
#method_after
public EntityModel<String> getInputLocale() {
    return privateInputLocale;
}
#end_block

#method_before
private void setInputLocale(EntityModel value) {
    privateInputLocale = value;
}
#method_after
private void setInputLocale(EntityModel<String> value) {
    privateInputLocale = value;
}
#end_block

#method_before
public EntityModel getUiLanguage() {
    return privateUiLanguage;
}
#method_after
public EntityModel<String> getUiLanguage() {
    return privateUiLanguage;
}
#end_block

#method_before
private void setUiLanguage(EntityModel value) {
    privateUiLanguage = value;
}
#method_after
private void setUiLanguage(EntityModel<String> value) {
    privateUiLanguage = value;
}
#end_block

#method_before
public EntityModel getSystemLocale() {
    return privateSystemLocale;
}
#method_after
public EntityModel<String> getSystemLocale() {
    return privateSystemLocale;
}
#end_block

#method_before
private void setSystemLocale(EntityModel value) {
    privateSystemLocale = value;
}
#method_after
private void setSystemLocale(EntityModel<String> value) {
    privateSystemLocale = value;
}
#end_block

#method_before
public EntityModel getUserLocale() {
    return privateUserLocale;
}
#method_after
public EntityModel<String> getUserLocale() {
    return privateUserLocale;
}
#end_block

#method_before
private void setUserLocale(EntityModel value) {
    privateUserLocale = value;
}
#method_after
private void setUserLocale(EntityModel<String> value) {
    privateUserLocale = value;
}
#end_block

#method_before
public EntityModel getDomain() {
    return privateDomain;
}
#method_after
public EntityModel<String> getDomain() {
    return privateDomain;
}
#end_block

#method_before
private void setDomain(EntityModel value) {
    privateDomain = value;
}
#method_after
private void setDomain(EntityModel<String> value) {
    privateDomain = value;
}
#end_block

#method_before
public EntityModel getCustomScript() {
    return privateCustomScript;
}
#method_after
public EntityModel<String> getCustomScript() {
    return privateCustomScript;
}
#end_block

#method_before
private void setCustomScript(EntityModel value) {
    privateCustomScript = value;
}
#method_after
private void setCustomScript(EntityModel<String> value) {
    privateCustomScript = value;
}
#end_block

#method_before
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#method_after
public EntityModel<String> getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#end_block

#method_before
private void setAuthorizedKeys(EntityModel value) {
    privateAuthorizedKeys = value;
}
#method_after
private void setAuthorizedKeys(EntityModel<String> value) {
    privateAuthorizedKeys = value;
}
#end_block

#method_before
public EntityModel getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#method_after
public EntityModel<Boolean> getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#end_block

#method_before
private void setRegenerateKeysEnabled(EntityModel value) {
    privateRegenerateKeysEnabled = value;
}
#method_after
private void setRegenerateKeysEnabled(EntityModel<Boolean> value) {
    privateRegenerateKeysEnabled = value;
}
#end_block

#method_before
public EntityModel getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#end_block

#method_before
private void setTimeZoneEnabled(EntityModel value) {
    privateTimeZoneEnabled = value;
}
#method_after
private void setTimeZoneEnabled(EntityModel<Boolean> value) {
    privateTimeZoneEnabled = value;
}
#end_block

#method_before
public ListModel getTimeZoneList() {
    return privateTimeZoneList;
}
#method_after
public ListModel<Map.Entry<String, String>> getTimeZoneList() {
    return privateTimeZoneList;
}
#end_block

#method_before
private void setTimeZoneList(ListModel value) {
    privateTimeZoneList = value;
}
#method_after
private void setTimeZoneList(ListModel<Map.Entry<String, String>> value) {
    privateTimeZoneList = value;
}
#end_block

#method_before
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getRootPassword() {
    return privateRootPassword;
}
#method_after
public EntityModel<String> getRootPassword() {
    return privateRootPassword;
}
#end_block

#method_before
private void setRootPassword(EntityModel value) {
    privateRootPassword = value;
}
#method_after
private void setRootPassword(EntityModel<String> value) {
    privateRootPassword = value;
}
#end_block

#method_before
public EntityModel getPasswordSet() {
    return privatePasswordSet;
}
#method_after
public EntityModel<Boolean> getPasswordSet() {
    return privatePasswordSet;
}
#end_block

#method_before
private void setPasswordSet(EntityModel value) {
    privatePasswordSet = value;
}
#method_after
private void setPasswordSet(EntityModel<Boolean> value) {
    privatePasswordSet = value;
}
#end_block

#method_before
public EntityModel getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#method_after
public EntityModel<String> getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#end_block

#method_before
private void setRootPasswordVerification(EntityModel value) {
    privateRootPasswordVerification = value;
}
#method_after
private void setRootPasswordVerification(EntityModel<String> value) {
    privateRootPasswordVerification = value;
}
#end_block

#method_before
public EntityModel getNetworkEnabled() {
    return privateNetworkEnabled;
}
#method_after
public EntityModel<Boolean> getNetworkEnabled() {
    return privateNetworkEnabled;
}
#end_block

#method_before
private void setNetworkEnabled(EntityModel value) {
    privateNetworkEnabled = value;
}
#method_after
private void setNetworkEnabled(EntityModel<Boolean> value) {
    privateNetworkEnabled = value;
}
#end_block

#method_before
public EntityModel getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#method_after
public EntityModel<String> getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#end_block

#method_before
private void setNetworkSelectedName(EntityModel value) {
    privateNetworkSelectedName = value;
}
#method_after
private void setNetworkSelectedName(EntityModel<String> value) {
    privateNetworkSelectedName = value;
}
#end_block

#method_before
public ListModel getNetworkList() {
    return privateNetworkList;
}
#method_after
public ListModel<String> getNetworkList() {
    return privateNetworkList;
}
#end_block

#method_before
private void setNetworkList(ListModel value) {
    privateNetworkList = value;
}
#method_after
private void setNetworkList(ListModel<String> value) {
    privateNetworkList = value;
}
#end_block

#method_before
public EntityModel getNetworkDhcp() {
    return privateNetworkDhcp;
}
#method_after
public EntityModel<Boolean> getNetworkDhcp() {
    return privateNetworkDhcp;
}
#end_block

#method_before
private void setNetworkDhcp(EntityModel value) {
    privateNetworkDhcp = value;
}
#method_after
private void setNetworkDhcp(EntityModel<Boolean> value) {
    privateNetworkDhcp = value;
}
#end_block

#method_before
public EntityModel getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#method_after
public EntityModel<String> getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#end_block

#method_before
private void setNetworkIpAddress(EntityModel value) {
    privateNetworkIpAddress = value;
}
#method_after
private void setNetworkIpAddress(EntityModel<String> value) {
    privateNetworkIpAddress = value;
}
#end_block

#method_before
public EntityModel getNetworkNetmask() {
    return privateNetworkNetmask;
}
#method_after
public EntityModel<String> getNetworkNetmask() {
    return privateNetworkNetmask;
}
#end_block

#method_before
private void setNetworkNetmask(EntityModel value) {
    privateNetworkNetmask = value;
}
#method_after
private void setNetworkNetmask(EntityModel<String> value) {
    privateNetworkNetmask = value;
}
#end_block

#method_before
public EntityModel getNetworkGateway() {
    return privateNetworkGateway;
}
#method_after
public EntityModel<String> getNetworkGateway() {
    return privateNetworkGateway;
}
#end_block

#method_before
private void setNetworkGateway(EntityModel value) {
    privateNetworkGateway = value;
}
#method_after
private void setNetworkGateway(EntityModel<String> value) {
    privateNetworkGateway = value;
}
#end_block

#method_before
public EntityModel getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#method_after
public EntityModel<Boolean> getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#end_block

#method_before
private void setNetworkStartOnBoot(EntityModel value) {
    privateNetworkStartOnBoot = value;
}
#method_after
private void setNetworkStartOnBoot(EntityModel<Boolean> value) {
    privateNetworkStartOnBoot = value;
}
#end_block

#method_before
public EntityModel getDnsServers() {
    return privateDnsServers;
}
#method_after
public EntityModel<String> getDnsServers() {
    return privateDnsServers;
}
#end_block

#method_before
public void setDnsServers(EntityModel dnsServers) {
    privateDnsServers = dnsServers;
}
#method_after
public void setDnsServers(EntityModel<String> dnsServers) {
    privateDnsServers = dnsServers;
}
#end_block

#method_before
public EntityModel getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#method_after
public EntityModel<String> getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#end_block

#method_before
public void setDnsSearchDomains(EntityModel dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#method_after
public void setDnsSearchDomains(EntityModel<String> dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#end_block

#method_before
public EntityModel getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#method_after
public EntityModel<Boolean> getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#end_block

#method_before
private void setAttachmentEnabled(EntityModel value) {
    privateAttachmentEnabled = value;
}
#method_after
private void setAttachmentEnabled(EntityModel<Boolean> value) {
    privateAttachmentEnabled = value;
}
#end_block

#method_before
private void selectTimeZone(ListModel specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#method_after
private void selectTimeZone(ListModel<Map.Entry<String, String>> specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#end_block

#method_before
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if ((Boolean) getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation() })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString((String) getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString((String) getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#method_after
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#end_block

#method_before
private boolean validateHidden(EntityModel entity, final Object value, final String message, final IValidation[] validations) {
    EntityModel tmp = new EntityModel(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#method_after
private boolean validateHidden(EntityModel<String> entity, final String value, final String message, final IValidation[] validations) {
    EntityModel<String> tmp = new EntityModel<String>(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#end_block

#method_before
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if ((Boolean) model.getIsSysprepEnabled().getEntity() || (Boolean) model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), (String) model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#method_after
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if (model.getIsSysprepEnabled().getEntity() || model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#end_block

#method_before
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && (Boolean) getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && (Boolean) getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain((String) getDomain().getEntity());
    }
    return vmInit;
}
#method_after
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain(getDomain().getEntity());
    }
    return vmInit;
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? getWindowsHostname().getEntity() : getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword(getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys(getAuthorizedKeys().getEntity());
    if (getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList<VmInitNetwork>(networkMap.values()));
        }
    }
    vmInit.setDnsServers(getDnsServers().getEntity());
    vmInit.setDnsSearch(getDnsSearchDomains().getEntity());
    vmInit.setCustomScript(getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored(getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private void passwordSetChanged() {
    Boolean passwordChangable = !(Boolean) getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#method_after
private void passwordSetChanged() {
    Boolean passwordChangable = !getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#end_block

#method_before
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = (String) getNetworkList().getSelectedItem();
}
#method_after
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = getNetworkList().getSelectedItem();
}
#end_block

#method_before
private void networkSelectedName_SelectionChanged() {
    String oldName = (String) getNetworkList().getSelectedItem();
    String newName = (String) getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#method_after
private void networkSelectedName_SelectionChanged() {
    String oldName = getNetworkList().getSelectedItem();
    String newName = getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#end_block

#method_before
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && (Boolean) getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp((String) getNetworkIpAddress().getEntity());
            obj.setNetmask((String) getNetworkNetmask().getEntity());
            obj.setGateway((String) getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && (Boolean) getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#method_after
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.NONE);
            obj.setIp(getNetworkIpAddress().getEntity());
            obj.setNetmask(getNetworkNetmask().getEntity());
            obj.setGateway(getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = (String) getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#method_after
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#end_block

#method_before
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<Object>();
    networkNameEditor = new EntityModelTextBoxEditor();
    networkComboBox = new ComboBox(networkListEditor, networkNameEditor);
}
#method_after
void initComboBoxEditors() {
    networkListEditor = new ListModelListBoxEditor<String>();
    networkNameEditor = new StringEntityModelTextBoxEditor();
    networkComboBox = new ComboBox<String>(networkListEditor, networkNameEditor);
}
#end_block

#method_before
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !(Boolean) model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#method_after
@Override
public void edit(final VmInitModel model) {
    driver.edit(model);
    initializeEnabledCBBehavior(model);
    networkAddButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getAddNetworkCommand().execute();
        }
    });
    networkRemoveButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            model.getRemoveNetworkCommand().execute();
        }
    });
    model.getNetworkList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            // Can't use ListModel.isEmpty() because ListModel.SetItems(<empty list>)) will
            // cause the ItemsChanged and SelectedItemChanged events to be fired before we
            // can update the isEmpty() flag, causing erroneous readings upon item removal.
            setNetworkDetailsStyle(model.getNetworkList().getSelectedItem() != null);
        }
    });
    model.getNetworkDhcp().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setNetworkStaticDetailsStyle(model.getNetworkDhcp().getEntity() == null || !model.getNetworkDhcp().getEntity());
        }
    });
    model.getPasswordSet().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsChangable".equals(propName)) {
                // $NON-NLS-1$
                passwordSetEditor.setTitle(model.getPasswordSet().getIsChangable() ? constants.vmInitPasswordSetToolTip() : constants.vmInitPasswordNotSetToolTip());
            }
        }
    });
}
#end_block

#method_before
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled((Boolean) model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled((Boolean) model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled((Boolean) model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled((Boolean) model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = (Boolean) model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#method_after
void initializeEnabledCBBehavior(final VmInitModel model) {
    if (model.getRegenerateKeysEnabled().getEntity() != null) {
        regenerateKeysEnabledEditor.setEnabled(model.getRegenerateKeysEnabled().getEntity());
    }
    if (model.getTimeZoneEnabled().getEntity() != null) {
        timeZoneEnabledEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
    }
    model.getWindowsSysprepTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
        }
    });
    if (model.getWindowsSysprepTimeZoneEnabled().getEntity() != null) {
        windowsSysprepTimeZoneEditor.setEnabled(model.getWindowsSysprepTimeZoneEnabled().getEntity());
    }
    model.getTimeZoneEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            timeZoneEditor.setEnabled(model.getTimeZoneEnabled().getEntity());
        }
    });
    if (model.getNetworkEnabled().getEntity() != null) {
        networkEnabledEditor.setEnabled(model.getNetworkEnabled().getEntity());
    }
    model.getNetworkEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean enabled = model.getNetworkEnabled().getEntity();
            networkAddButton.setEnabled(enabled);
            setLabelEnabled(networkAddLabel, enabled);
            // See note above re: parameter to this method call
            setNetworkDetailsStyle(enabled && model.getNetworkList().getSelectedItem() != null);
        }
    });
}
#end_block

#method_before
private void storeNetwork() throws UnsupportedEncodingException {
    StringBuilder output = new StringBuilder();
    if (vmInit.getNetworks() != null) {
        List<VmInitNetwork> networks = vmInit.getNetworks();
        for (VmInitNetwork iface : networks) {
            output.append("iface " + iface.getName() + " inet " + iface.getBootProtocol().getDisplayName() + "\n");
            if (!StringUtils.isEmpty(iface.getIp())) {
                output.append("  address " + iface.getIp() + "\n");
            }
            if (!StringUtils.isEmpty(iface.getNetmask())) {
                output.append("  netmask " + iface.getNetmask() + "\n");
            }
            if (!StringUtils.isEmpty(iface.getGateway())) {
                output.append("  gateway " + iface.getGateway() + "\n");
            }
            // As of cloud-init 0.7.1, you can't set DNS servers without also setting NICs
            if (vmInit.getDnsServers() != null) {
                output.append("  dns-nameservers").append(" ").append(vmInit.getDnsServers());
                output.append("\n");
            }
            if (vmInit.getDnsSearch() != null) {
                output.append("  dns-search").append(" ").append(vmInit.getDnsSearch());
                output.append("\n");
            }
        }
        output.append("auto");
        for (VmInitNetwork iface : networks) {
            output.append(" " + iface.getName());
        }
        output.append("\n");
    }
    interfaces = output.toString();
    if (!interfaces.isEmpty()) {
        // Workaround for cloud-init 0.6.3, which requires the "network-interfaces"
        // meta-data entry instead of the "network_config" file reference
        metaData.put("network-interfaces", interfaces);
        // Cloud-init will translate this as needed for ifcfg-based systems
        storeNextFile(CloudInitFileMode.NETWORK, "/etc/network/interfaces", interfaces.getBytes("US-ASCII"));
    }
}
#method_after
private void storeNetwork() throws UnsupportedEncodingException {
    StringBuilder output = new StringBuilder();
    if (vmInit.getNetworks() != null) {
        List<VmInitNetwork> networks = vmInit.getNetworks();
        for (VmInitNetwork iface : networks) {
            output.append("iface " + iface.getName() + " inet " + iface.getBootProtocol().getDisplayName() + "\n");
            if (StringUtils.isNotEmpty(iface.getIp())) {
                output.append("  address " + iface.getIp() + "\n");
            }
            if (StringUtils.isNotEmpty(iface.getNetmask())) {
                output.append("  netmask " + iface.getNetmask() + "\n");
            }
            if (StringUtils.isNotEmpty(iface.getGateway())) {
                output.append("  gateway " + iface.getGateway() + "\n");
            }
            // As of cloud-init 0.7.1, you can't set DNS servers without also setting NICs
            if (vmInit.getDnsServers() != null) {
                output.append("  dns-nameservers").append(" ").append(vmInit.getDnsServers());
                output.append("\n");
            }
            if (vmInit.getDnsSearch() != null) {
                output.append("  dns-search").append(" ").append(vmInit.getDnsSearch());
                output.append("\n");
            }
        }
        output.append("auto");
        for (VmInitNetwork iface : networks) {
            output.append(" " + iface.getName());
        }
        output.append("\n");
    }
    interfaces = output.toString();
    if (!interfaces.isEmpty()) {
        // Workaround for cloud-init 0.6.3, which requires the "network-interfaces"
        // meta-data entry instead of the "network_config" file reference
        metaData.put("network-interfaces", interfaces);
        // Cloud-init will translate this as needed for ifcfg-based systems
        storeNextFile(CloudInitFileMode.NETWORK, "/etc/network/interfaces", interfaces.getBytes("US-ASCII"));
    }
}
#end_block

#method_before
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty((String) getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty((String) getHostname().getEntity());
    }
}
#method_after
public boolean getHostnameEnabled() {
    if (isWindowsOS) {
        return !StringHelper.isNullOrEmpty(getWindowsHostname().getEntity());
    } else {
        return !StringHelper.isNullOrEmpty(getHostname().getEntity());
    }
}
#end_block

#method_before
public ListModel getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#method_after
public ListModel<Map.Entry<String, String>> getWindowsSysprepTimeZone() {
    return windowsSysprepTimeZone;
}
#end_block

#method_before
public void setWindowsSysprepTimeZone(ListModel windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#method_after
public void setWindowsSysprepTimeZone(ListModel<Map.Entry<String, String>> windowsSysprepTimeZone) {
    this.windowsSysprepTimeZone = windowsSysprepTimeZone;
}
#end_block

#method_before
public EntityModel getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getWindowsSysprepTimeZoneEnabled() {
    return windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public void setWindowsSysprepTimeZoneEnabled(EntityModel windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#method_after
public void setWindowsSysprepTimeZoneEnabled(EntityModel<Boolean> windowsSysprepTimeZoneEnabled) {
    this.windowsSysprepTimeZoneEnabled = windowsSysprepTimeZoneEnabled;
}
#end_block

#method_before
public EntityModel getWindowsHostname() {
    return privateWindowsHostname;
}
#method_after
public EntityModel<String> getWindowsHostname() {
    return privateWindowsHostname;
}
#end_block

#method_before
private void setWindowsHostname(EntityModel value) {
    privateWindowsHostname = value;
}
#method_after
private void setWindowsHostname(EntityModel<String> value) {
    privateWindowsHostname = value;
}
#end_block

#method_before
public EntityModel getHostname() {
    return privateHostname;
}
#method_after
public EntityModel<String> getHostname() {
    return privateHostname;
}
#end_block

#method_before
private void setHostname(EntityModel value) {
    privateHostname = value;
}
#method_after
private void setHostname(EntityModel<String> value) {
    privateHostname = value;
}
#end_block

#method_before
public EntityModel getInputLocale() {
    return privateInputLocale;
}
#method_after
public EntityModel<String> getInputLocale() {
    return privateInputLocale;
}
#end_block

#method_before
private void setInputLocale(EntityModel value) {
    privateInputLocale = value;
}
#method_after
private void setInputLocale(EntityModel<String> value) {
    privateInputLocale = value;
}
#end_block

#method_before
public EntityModel getUiLanguage() {
    return privateUiLanguage;
}
#method_after
public EntityModel<String> getUiLanguage() {
    return privateUiLanguage;
}
#end_block

#method_before
private void setUiLanguage(EntityModel value) {
    privateUiLanguage = value;
}
#method_after
private void setUiLanguage(EntityModel<String> value) {
    privateUiLanguage = value;
}
#end_block

#method_before
public EntityModel getSystemLocale() {
    return privateSystemLocale;
}
#method_after
public EntityModel<String> getSystemLocale() {
    return privateSystemLocale;
}
#end_block

#method_before
private void setSystemLocale(EntityModel value) {
    privateSystemLocale = value;
}
#method_after
private void setSystemLocale(EntityModel<String> value) {
    privateSystemLocale = value;
}
#end_block

#method_before
public EntityModel getUserLocale() {
    return privateUserLocale;
}
#method_after
public EntityModel<String> getUserLocale() {
    return privateUserLocale;
}
#end_block

#method_before
private void setUserLocale(EntityModel value) {
    privateUserLocale = value;
}
#method_after
private void setUserLocale(EntityModel<String> value) {
    privateUserLocale = value;
}
#end_block

#method_before
public EntityModel getDomain() {
    return privateDomain;
}
#method_after
public EntityModel<String> getDomain() {
    return privateDomain;
}
#end_block

#method_before
private void setDomain(EntityModel value) {
    privateDomain = value;
}
#method_after
private void setDomain(EntityModel<String> value) {
    privateDomain = value;
}
#end_block

#method_before
public EntityModel getUserName() {
    return privateUserName;
}
#method_after
public EntityModel<String> getUserName() {
    return privateUserName;
}
#end_block

#method_before
private void setUserName(EntityModel value) {
    privateUserName = value;
}
#method_after
private void setUserName(EntityModel<String> value) {
    privateUserName = value;
}
#end_block

#method_before
public EntityModel getActiveDirectoryOU() {
    return privateActiveDirectoryOU;
}
#method_after
public EntityModel<String> getActiveDirectoryOU() {
    return privateActiveDirectoryOU;
}
#end_block

#method_before
private void setActiveDirectoryOU(EntityModel value) {
    privateActiveDirectoryOU = value;
}
#method_after
private void setActiveDirectoryOU(EntityModel<String> value) {
    privateActiveDirectoryOU = value;
}
#end_block

#method_before
public EntityModel getCustomScript() {
    return privateCustomScript;
}
#method_after
public EntityModel<String> getCustomScript() {
    return privateCustomScript;
}
#end_block

#method_before
private void setCustomScript(EntityModel value) {
    privateCustomScript = value;
}
#method_after
private void setCustomScript(EntityModel<String> value) {
    privateCustomScript = value;
}
#end_block

#method_before
public EntityModel getSysprepScript() {
    return privateSysprepScript;
}
#method_after
public EntityModel<String> getSysprepScript() {
    return privateSysprepScript;
}
#end_block

#method_before
private void setSysprepScript(EntityModel value) {
    privateSysprepScript = value;
}
#method_after
private void setSysprepScript(EntityModel<String> value) {
    privateSysprepScript = value;
}
#end_block

#method_before
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getAuthorizedKeysEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#method_after
public EntityModel<String> getAuthorizedKeys() {
    return privateAuthorizedKeys;
}
#end_block

#method_before
private void setAuthorizedKeys(EntityModel value) {
    privateAuthorizedKeys = value;
}
#method_after
private void setAuthorizedKeys(EntityModel<String> value) {
    privateAuthorizedKeys = value;
}
#end_block

#method_before
public EntityModel getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#method_after
public EntityModel<Boolean> getRegenerateKeysEnabled() {
    return privateRegenerateKeysEnabled;
}
#end_block

#method_before
private void setRegenerateKeysEnabled(EntityModel value) {
    privateRegenerateKeysEnabled = value;
}
#method_after
private void setRegenerateKeysEnabled(EntityModel<Boolean> value) {
    privateRegenerateKeysEnabled = value;
}
#end_block

#method_before
public EntityModel getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#method_after
public EntityModel<Boolean> getTimeZoneEnabled() {
    return privateTimeZoneEnabled;
}
#end_block

#method_before
private void setTimeZoneEnabled(EntityModel value) {
    privateTimeZoneEnabled = value;
}
#method_after
private void setTimeZoneEnabled(EntityModel<Boolean> value) {
    privateTimeZoneEnabled = value;
}
#end_block

#method_before
public ListModel getTimeZoneList() {
    return privateTimeZoneList;
}
#method_after
public ListModel<Map.Entry<String, String>> getTimeZoneList() {
    return privateTimeZoneList;
}
#end_block

#method_before
private void setTimeZoneList(ListModel value) {
    privateTimeZoneList = value;
}
#method_after
private void setTimeZoneList(ListModel<Map.Entry<String, String>> value) {
    privateTimeZoneList = value;
}
#end_block

#method_before
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty((String) getRootPassword().getEntity());
}
#method_after
public boolean getRootPasswordEnabled() {
    return !StringHelper.isNullOrEmpty(getRootPassword().getEntity());
}
#end_block

#method_before
public EntityModel getRootPassword() {
    return privateRootPassword;
}
#method_after
public EntityModel<String> getRootPassword() {
    return privateRootPassword;
}
#end_block

#method_before
private void setRootPassword(EntityModel value) {
    privateRootPassword = value;
}
#method_after
private void setRootPassword(EntityModel<String> value) {
    privateRootPassword = value;
}
#end_block

#method_before
public EntityModel getPasswordSet() {
    return privatePasswordSet;
}
#method_after
public EntityModel<Boolean> getPasswordSet() {
    return privatePasswordSet;
}
#end_block

#method_before
private void setPasswordSet(EntityModel value) {
    privatePasswordSet = value;
}
#method_after
private void setPasswordSet(EntityModel<Boolean> value) {
    privatePasswordSet = value;
}
#end_block

#method_before
public EntityModel getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#method_after
public EntityModel<String> getRootPasswordVerification() {
    return privateRootPasswordVerification;
}
#end_block

#method_before
private void setRootPasswordVerification(EntityModel value) {
    privateRootPasswordVerification = value;
}
#method_after
private void setRootPasswordVerification(EntityModel<String> value) {
    privateRootPasswordVerification = value;
}
#end_block

#method_before
public EntityModel getNetworkEnabled() {
    return privateNetworkEnabled;
}
#method_after
public EntityModel<Boolean> getNetworkEnabled() {
    return privateNetworkEnabled;
}
#end_block

#method_before
private void setNetworkEnabled(EntityModel value) {
    privateNetworkEnabled = value;
}
#method_after
private void setNetworkEnabled(EntityModel<Boolean> value) {
    privateNetworkEnabled = value;
}
#end_block

#method_before
public EntityModel getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#method_after
public EntityModel<String> getNetworkSelectedName() {
    return privateNetworkSelectedName;
}
#end_block

#method_before
private void setNetworkSelectedName(EntityModel value) {
    privateNetworkSelectedName = value;
}
#method_after
private void setNetworkSelectedName(EntityModel<String> value) {
    privateNetworkSelectedName = value;
}
#end_block

#method_before
public ListModel getNetworkList() {
    return privateNetworkList;
}
#method_after
public ListModel<String> getNetworkList() {
    return privateNetworkList;
}
#end_block

#method_before
private void setNetworkList(ListModel value) {
    privateNetworkList = value;
}
#method_after
private void setNetworkList(ListModel<String> value) {
    privateNetworkList = value;
}
#end_block

#method_before
public EntityModel getNetworkDhcp() {
    return privateNetworkDhcp;
}
#method_after
public EntityModel<Boolean> getNetworkDhcp() {
    return privateNetworkDhcp;
}
#end_block

#method_before
private void setNetworkDhcp(EntityModel value) {
    privateNetworkDhcp = value;
}
#method_after
private void setNetworkDhcp(EntityModel<Boolean> value) {
    privateNetworkDhcp = value;
}
#end_block

#method_before
public EntityModel getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#method_after
public EntityModel<String> getNetworkIpAddress() {
    return privateNetworkIpAddress;
}
#end_block

#method_before
private void setNetworkIpAddress(EntityModel value) {
    privateNetworkIpAddress = value;
}
#method_after
private void setNetworkIpAddress(EntityModel<String> value) {
    privateNetworkIpAddress = value;
}
#end_block

#method_before
public EntityModel getNetworkNetmask() {
    return privateNetworkNetmask;
}
#method_after
public EntityModel<String> getNetworkNetmask() {
    return privateNetworkNetmask;
}
#end_block

#method_before
private void setNetworkNetmask(EntityModel value) {
    privateNetworkNetmask = value;
}
#method_after
private void setNetworkNetmask(EntityModel<String> value) {
    privateNetworkNetmask = value;
}
#end_block

#method_before
public EntityModel getNetworkGateway() {
    return privateNetworkGateway;
}
#method_after
public EntityModel<String> getNetworkGateway() {
    return privateNetworkGateway;
}
#end_block

#method_before
private void setNetworkGateway(EntityModel value) {
    privateNetworkGateway = value;
}
#method_after
private void setNetworkGateway(EntityModel<String> value) {
    privateNetworkGateway = value;
}
#end_block

#method_before
public EntityModel getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#method_after
public EntityModel<Boolean> getNetworkStartOnBoot() {
    return privateNetworkStartOnBoot;
}
#end_block

#method_before
private void setNetworkStartOnBoot(EntityModel value) {
    privateNetworkStartOnBoot = value;
}
#method_after
private void setNetworkStartOnBoot(EntityModel<Boolean> value) {
    privateNetworkStartOnBoot = value;
}
#end_block

#method_before
public EntityModel getDnsServers() {
    return privateDnsServers;
}
#method_after
public EntityModel<String> getDnsServers() {
    return privateDnsServers;
}
#end_block

#method_before
public void setDnsServers(EntityModel dnsServers) {
    privateDnsServers = dnsServers;
}
#method_after
public void setDnsServers(EntityModel<String> dnsServers) {
    privateDnsServers = dnsServers;
}
#end_block

#method_before
public EntityModel getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#method_after
public EntityModel<String> getDnsSearchDomains() {
    return privateDnsSearchDomains;
}
#end_block

#method_before
public void setDnsSearchDomains(EntityModel dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#method_after
public void setDnsSearchDomains(EntityModel<String> dnsSearchDomains) {
    privateDnsSearchDomains = dnsSearchDomains;
}
#end_block

#method_before
public EntityModel getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#method_after
public EntityModel<Boolean> getAttachmentEnabled() {
    return privateAttachmentEnabled;
}
#end_block

#method_before
private void setAttachmentEnabled(EntityModel value) {
    privateAttachmentEnabled = value;
}
#method_after
private void setAttachmentEnabled(EntityModel<Boolean> value) {
    privateAttachmentEnabled = value;
}
#end_block

#method_before
private void selectTimeZone(ListModel specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#method_after
private void selectTimeZone(ListModel<Map.Entry<String, String>> specificTimeZoneModel, Map<String, String> timezones, final String tz) {
    specificTimeZoneModel.setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            return item.getKey().equals(tz);
        }
    }));
}
#end_block

#method_before
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if ((Boolean) getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString((String) getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString((String) getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#method_after
public boolean validate() {
    getHostname().setIsValid(true);
    getWindowsHostname().setIsValid(true);
    if (getHostnameEnabled()) {
        if (this.isWindowsOS) {
            getWindowsHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        } else {
            getHostname().validateEntity(new IValidation[] { new HostnameValidation() });
        }
    }
    getDomain().setIsValid(true);
    getAuthorizedKeys().setIsValid(true);
    getTimeZoneList().setIsValid(true);
    if (getTimeZoneEnabled().getEntity()) {
        getTimeZoneList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getRootPassword().setIsValid(true);
    getRootPasswordVerification().setIsValid(true);
    if (getRootPasswordEnabled()) {
        getRootPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
        if (getRootPassword().getIsValid()) {
            if (!(getRootPassword().getEntity()).equals(getRootPasswordVerification().getEntity())) {
                ArrayList<String> reasons = new ArrayList<String>();
                reasons.add(rootPasswordMatchMessage);
                getRootPassword().setInvalidityReasons(reasons);
                getRootPassword().setIsValid(false);
            }
        }
        if (!getRootPassword().getIsValid()) {
            getRootPasswordVerification().setInvalidityReasons(getRootPassword().getInvalidityReasons());
            getRootPasswordVerification().setIsValid(false);
        }
    }
    boolean networkIsValid = true;
    getNetworkList().setIsValid(true);
    getNetworkIpAddress().setIsValid(true);
    getNetworkNetmask().setIsValid(true);
    getNetworkGateway().setIsValid(true);
    boolean dnsIsValid = true;
    getDnsServers().setIsValid(true);
    getDnsSearchDomains().setIsValid(true);
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
            String name = entry.getKey();
            VmInitNetwork params = entry.getValue();
            if (params.getBootProtocol() != NetworkBootProtocol.DHCP) {
                if (!validateHidden(getNetworkList(), name, null, new IValidation[] { new AsciiNameValidation() }) || !validateHidden(getNetworkIpAddress(), params.getIp(), null, new IValidation[] { new IpAddressValidation() }) || !validateHidden(getNetworkNetmask(), params.getNetmask(), null, new IValidation[] { new SubnetMaskValidation() }) || !validateHidden(getNetworkGateway(), params.getGateway(), null, new IValidation[] { new IpAddressValidation(true) })) {
                    getNetworkList().setSelectedItem(name);
                    networkIsValid = false;
                    break;
                }
            }
        }
        if (!networkMap.isEmpty()) {
            if (getDnsServers().getEntity() != null) {
                for (String server : tokenizeString(getDnsServers().getEntity())) {
                    if (!validateHidden(getDnsServers(), server, dnsServerListMessage, new IValidation[] { new IpAddressValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
            if (getDnsSearchDomains().getEntity() != null) {
                for (String domain : tokenizeString(getDnsSearchDomains().getEntity())) {
                    if (!validateHidden(getDnsSearchDomains(), domain, null, new IValidation[] { new HostnameValidation() })) {
                        dnsIsValid = false;
                        break;
                    }
                }
            }
        }
    }
    return getHostname().getIsValid() && getWindowsHostname().getIsValid() && getDomain().getIsValid() && getAuthorizedKeys().getIsValid() && getTimeZoneList().getIsValid() && getRootPassword().getIsValid() && networkIsValid && dnsIsValid;
}
#end_block

#method_before
private boolean validateHidden(EntityModel entity, final Object value, final String message, final IValidation[] validations) {
    EntityModel tmp = new EntityModel(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#method_after
private boolean validateHidden(EntityModel<String> entity, final String value, final String message, final IValidation[] validations) {
    EntityModel<String> tmp = new EntityModel<String>(value);
    tmp.setIsValid(true);
    tmp.validateEntity(validations);
    if (!tmp.getIsValid()) {
        if (message != null) {
            List<String> reasons = new ArrayList<String>();
            reasons.add(message);
            entity.setInvalidityReasons(reasons);
        } else {
            entity.setInvalidityReasons(tmp.getInvalidityReasons());
        }
        entity.setIsValid(false);
    } else {
        entity.setIsValid(true);
    }
    return tmp.getIsValid();
}
#end_block

#method_before
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if ((Boolean) model.getIsSysprepEnabled().getEntity() || (Boolean) model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), (String) model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#method_after
public VmInit buildCloudInitParameters(RunOnceModel model) {
    if (model.getIsSysprepEnabled().getEntity() || model.getIsCloudInitEnabled().getEntity()) {
        return buildModelSpecificParameters(model.getIsWindowsOS(), model.getSysPrepSelectedDomainName().getEntity());
    } else {
        return null;
    }
}
#end_block

#method_before
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && (Boolean) getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && (Boolean) getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = (Map.Entry<String, String>) getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain((String) getDomain().getEntity());
    }
    return vmInit;
}
#method_after
private VmInit buildModelSpecificParameters(boolean isWindows, String domainFromModel) {
    VmInit vmInit = buildCloudInitParameters();
    if (isWindows && getWindowsSysprepTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getWindowsSysprepTimeZone().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    } else if (!isWindows && getTimeZoneEnabled().getEntity()) {
        Map.Entry<String, String> entry = getTimeZoneList().getSelectedItem();
        vmInit.setTimeZone(entry.getKey());
    }
    if (isWindows) {
        vmInit.setDomain(domainFromModel);
    } else {
        vmInit.setDomain(getDomain().getEntity());
    }
    return vmInit;
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
        vmInit.setCustomScript((String) getSysprepScript().getEntity());
        vmInit.setActiveDirectoryOU((String) getActiveDirectoryOU().getEntity());
    } else {
        vmInit.setCustomScript((String) getCustomScript().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? getWindowsHostname().getEntity() : getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
        vmInit.setCustomScript((String) getSysprepScript().getEntity());
        vmInit.setActiveDirectoryOU((String) getActiveDirectoryOU().getEntity());
    } else {
        vmInit.setCustomScript((String) getCustomScript().getEntity());
    }
    vmInit.setUserName((String) getUserName().getEntity());
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword(getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys(getAuthorizedKeys().getEntity());
    if (getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if (getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList<VmInitNetwork>(networkMap.values()));
        }
    }
    vmInit.setDnsServers(getDnsServers().getEntity());
    vmInit.setDnsSearch(getDnsSearchDomains().getEntity());
    vmInit.setCustomScript(getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored(getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private void passwordSetChanged() {
    Boolean passwordChangable = !(Boolean) getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#method_after
private void passwordSetChanged() {
    Boolean passwordChangable = !getPasswordSet().getEntity();
    getRootPassword().setIsChangable(passwordChangable);
    getRootPasswordVerification().setIsChangable(passwordChangable);
}
#end_block

#method_before
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = (String) getNetworkList().getSelectedItem();
}
#method_after
/* === Network === */
private void networkList_SelectedItemChanged() {
    saveNetworkFields();
    // The networkSelectedName EntityChangedEvent is really only
    // to catch user updates; don't trigger it programmatically.
    // Suppressing events locally works better than setEntity(, false).
    getNetworkSelectedName().getEntityChangedEvent().removeListener(this);
    getNetworkSelectedName().setEntity(getNetworkList().getSelectedItem());
    getNetworkSelectedName().getEntityChangedEvent().addListener(this);
    updateNetworkDisplay();
    // lastSelectedNetworkName can be used throughout update process to see prior name
    lastSelectedNetworkName = getNetworkList().getSelectedItem();
}
#end_block

#method_before
private void networkSelectedName_SelectionChanged() {
    String oldName = (String) getNetworkList().getSelectedItem();
    String newName = (String) getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#method_after
private void networkSelectedName_SelectionChanged() {
    String oldName = getNetworkList().getSelectedItem();
    String newName = getNetworkSelectedName().getEntity();
    if (oldName != null && newName != null && !newName.trim().equals(oldName)) {
        VmInitNetwork obj = networkMap.get(oldName);
        newName = newName.trim();
        if (newName.isEmpty() || networkMap.containsKey(newName)) {
            getNetworkSelectedName().setEntity(oldName);
        } else {
            networkMap.remove(oldName);
            networkMap.put(newName, obj);
            getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
            getNetworkList().setSelectedItem(newName);
        }
    }
}
#end_block

#method_before
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && (Boolean) getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.STATIC_IP);
            obj.setIp((String) getNetworkIpAddress().getEntity());
            obj.setNetmask((String) getNetworkNetmask().getEntity());
            obj.setGateway((String) getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && (Boolean) getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#method_after
private void saveNetworkFields() {
    if (lastSelectedNetworkName != null) {
        VmInitNetwork obj = networkMap.get(lastSelectedNetworkName);
        if (obj != null) {
            obj.setBootProtocol((getNetworkDhcp().getEntity() != null && getNetworkDhcp().getEntity()) ? NetworkBootProtocol.DHCP : NetworkBootProtocol.STATIC_IP);
            obj.setIp(getNetworkIpAddress().getEntity());
            obj.setNetmask(getNetworkNetmask().getEntity());
            obj.setGateway(getNetworkGateway().getEntity());
            if (getNetworkStartOnBoot().getEntity() != null && getNetworkStartOnBoot().getEntity()) {
                networkStartOnBoot.add(lastSelectedNetworkName);
            } else {
                networkStartOnBoot.remove(lastSelectedNetworkName);
            }
        }
    }
}
#end_block

#method_before
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = (String) getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#method_after
private void updateNetworkDisplay() {
    String networkName = null;
    VmInitNetwork obj = null;
    if (getNetworkList().getSelectedItem() != null) {
        networkName = getNetworkList().getSelectedItem();
        obj = networkMap.get(networkName);
    }
    getNetworkDhcp().setEntity(obj == null ? null : obj.getBootProtocol() == NetworkBootProtocol.DHCP);
    getNetworkIpAddress().setEntity(obj == null ? null : obj.getIp());
    getNetworkNetmask().setEntity(obj == null ? null : obj.getNetmask());
    getNetworkGateway().setEntity(obj == null ? null : obj.getGateway());
    getNetworkStartOnBoot().setEntity(networkName == null ? null : networkStartOnBoot.contains(networkName));
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        // Minimum 'Physical Memory Guaranteed' is 1MB
        validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
        if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
            validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getIsSystemTabValid();
}
#method_after
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    setIsSystemTabValid(true);
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        // Minimum 'Physical Memory Guaranteed' is 1MB
        validateMemorySize(getMemSize(), Integer.MAX_VALUE, 1);
        if (!(getBehavior() instanceof TemplateVmModelBehavior) && getMemSize().getIsValid()) {
            validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    setIsSystemTabValid(getMemSize().getIsValid() && getTotalCPUCores().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid());
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getIsSystemTabValid();
}
#end_block

#method_before
@Override
public Integer parse(CharSequence text) throws ParseException {
    // $NON-NLS-1$
    MatchResult match = RegExp.compile("^(\\d*)\\s*(\\w*)$").exec(text.toString());
    String prefix = match.getGroup(1);
    String suffix = match.getGroup(2);
    Integer size = null;
    try {
        size = Integer.parseInt(prefix);
    } catch (NumberFormatException e) {
        return 0;
    }
    if (suffix.equalsIgnoreCase("TB") || suffix.equalsIgnoreCase("T")) {
        // $NON-NLS-1$ $NON-NLS-2$
        size *= 1024 * 1024;
        return size;
    }
    if (suffix.equalsIgnoreCase("GB") || suffix.equalsIgnoreCase("G")) {
        // $NON-NLS-1$ $NON-NLS-2$
        size *= 1024;
        return size;
    }
    if (suffix.equalsIgnoreCase("MB") || suffix.equalsIgnoreCase("M")) {
        // $NON-NLS-1$ $NON-NLS-2$
        return size;
    }
    return size;
}
#method_after
@Override
public Integer parse(CharSequence text) throws ParseException {
    // $NON-NLS-1$
    MatchResult match = RegExp.compile("^(\\d*)\\s*(\\w*)$").exec(text.toString());
    if (match == null) {
        return 0;
    }
    String prefix = match.getGroup(1);
    String suffix = match.getGroup(2);
    Integer size = null;
    try {
        size = Integer.parseInt(prefix);
    } catch (NumberFormatException e) {
        return 0;
    }
    if (suffix.equalsIgnoreCase("TB") || suffix.equalsIgnoreCase("T")) {
        // $NON-NLS-1$ $NON-NLS-2$
        return size * 1024 * 1024;
    } else if (suffix.equalsIgnoreCase("GB") || suffix.equalsIgnoreCase("G")) {
        // $NON-NLS-1$ $NON-NLS-2$
        return size * 1024;
    } else if (suffix.equalsIgnoreCase("MB") || suffix.equalsIgnoreCase("M")) {
        // $NON-NLS-1$ $NON-NLS-2$
        return size;
    } else if (StringHelper.isNullOrEmpty(suffix)) {
        return size;
    } else {
        // disallow garbled suffixes
        return 0;
    }
}
#end_block

#method_before
public void setBootTime(Date value) {
    if (bootTime != value) {
        bootTime = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("bootTime"));
    }
}
#method_after
public void setBootTime(Long value) {
    /* Factor by 1000 since Date works with millis since epoch and we store seconds (as provided by machines) */
    if (value == null) {
        if (bootTime == null) {
            return;
        }
        bootTime = null;
    } else {
        if (bootTime == null) {
            bootTime = new Date(value * 1000);
        } else if ((bootTime.getTime() / 1000) != value) {
            bootTime.setTime(value * 1000);
        } else {
            return;
        }
    }
    // $NON-NLS-1$
    onPropertyChanged(new PropertyChangedEventArgs("bootTime"));
}
#end_block

#method_before
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime(rs.getTimestamp("boot_time"));
    return entity;
}
#method_after
@Override
public VDS mapRow(final ResultSet rs, final int rowNum) throws SQLException {
    final VDS entity = new VDS();
    entity.setId(getGuidDefaultEmpty(rs, "vds_id"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVdsName(rs.getString("vds_name"));
    entity.setComment(rs.getString("free_text_comment"));
    entity.setManagementIp(rs.getString("ip"));
    entity.setUniqueId(rs.getString("vds_unique_id"));
    entity.setServerSslEnabled(rs.getBoolean("server_SSL_enabled"));
    entity.setHostName(rs.getString("host_name"));
    entity.setPort(rs.getInt("port"));
    entity.setSshPort(rs.getInt("ssh_port"));
    entity.setSshUsername(rs.getString("ssh_username"));
    entity.setStatus(VDSStatus.forValue(rs.getInt("status")));
    entity.setCpuCores((Integer) rs.getObject("cpu_cores"));
    entity.setCpuThreads((Integer) rs.getObject("cpu_threads"));
    entity.setCpuModel(rs.getString("cpu_model"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSpeedMh(rs.getDouble("cpu_speed_mh"));
    entity.setIfTotalSpeed(rs.getString("if_total_speed"));
    entity.setKvmEnabled((Boolean) rs.getObject("kvm_enabled"));
    entity.setPhysicalMemMb((Integer) rs.getObject("physical_mem_mb"));
    entity.setCpuIdle(rs.getDouble("cpu_idle"));
    entity.setCpuLoad(rs.getDouble("cpu_load"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setMemCommited((Integer) rs.getObject("mem_commited"));
    entity.setVmActive((Integer) rs.getObject("vm_active"));
    entity.setVmCount((Integer) rs.getObject("vm_count"));
    entity.setVmsCoresCount((Integer) rs.getObject("vms_cores_count"));
    entity.setVmMigrating((Integer) rs.getObject("vm_migrating"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setReservedMem((Integer) rs.getObject("reserved_mem"));
    entity.setGuestOverhead((Integer) rs.getObject("guest_overhead"));
    entity.setVersion(new RpmVersion(rs.getString("rpm_version")));
    entity.setSoftwareVersion(rs.getString("software_version"));
    entity.setVersionName(rs.getString("version_name"));
    entity.setPreviousStatus(VDSStatus.forValue(rs.getInt("previous_status")));
    entity.setMemAvailable(rs.getLong("mem_available"));
    entity.setMemShared(rs.getLong("mem_shared"));
    entity.setVdsType(VDSType.forValue(rs.getInt("vds_type")));
    entity.setCpuFlags(rs.getString("cpu_flags"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setPendingVcpusCount((Integer) rs.getObject("pending_vcpus_count"));
    entity.setCpuOverCommitTimestamp(DbFacadeUtils.fromDate(rs.getTimestamp("cpu_over_commit_time_stamp")));
    entity.setPendingVmemSize(rs.getInt("pending_vmem_size"));
    entity.setVdsStrength(rs.getInt("vds_strength"));
    entity.setMaxVdsMemoryOverCommit(rs.getInt("max_vds_memory_over_commit"));
    entity.setCpuSockets((Integer) rs.getObject("cpu_sockets"));
    entity.setVdsSpmId((Integer) rs.getObject("vds_spm_id"));
    entity.setNetConfigDirty((Boolean) rs.getObject("net_config_dirty"));
    entity.setPmType(rs.getString("pm_type"));
    entity.setPmUser(rs.getString("pm_user"));
    entity.setPmPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_password")));
    entity.setPmPort((Integer) rs.getObject("pm_port"));
    entity.setPmOptions(rs.getString("pm_options"));
    entity.setpm_enabled(rs.getBoolean("pm_enabled"));
    entity.setPmProxyPreferences(rs.getString("pm_proxy_preferences"));
    entity.setPmSecondaryIp((rs.getString("pm_secondary_ip")));
    entity.setPmSecondaryType(rs.getString("pm_secondary_type"));
    entity.setPmSecondaryUser(rs.getString("pm_secondary_user"));
    entity.setPmSecondaryPassword(DbFacadeUtils.decryptPassword(rs.getString("pm_secondary_password")));
    entity.setPmSecondaryPort((Integer) rs.getObject("pm_secondary_port"));
    entity.setPmSecondaryOptions(rs.getString("pm_secondary_options"));
    entity.setPmSecondaryConcurrent(rs.getBoolean("pm_secondary_concurrent"));
    entity.setSpmStatus(VdsSpmStatus.forValue(rs.getInt("spm_status")));
    entity.setSwapFree(rs.getLong("swap_free"));
    entity.setSwapTotal(rs.getLong("swap_total"));
    entity.setKsmCpuPercent((Integer) rs.getObject("ksm_cpu_percent"));
    entity.setKsmPages(rs.getLong("ksm_pages"));
    entity.setKsmState((Boolean) rs.getObject("ksm_state"));
    entity.setSupportedClusterLevels(rs.getString("supported_cluster_levels"));
    entity.setSupportedEngines(rs.getString("supported_engines"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setVdsGroupSupportsVirtService(rs.getBoolean("vds_group_virt_service"));
    entity.setVdsGroupSupportsGlusterService(rs.getBoolean("vds_group_gluster_service"));
    entity.setHostOs(rs.getString("host_os"));
    entity.setGlusterVersion(new RpmVersion(rs.getString("gluster_version")));
    entity.setKvmVersion(rs.getString("kvm_version"));
    entity.setLibvirtVersion(new RpmVersion(rs.getString("libvirt_version")));
    entity.setSpiceVersion(rs.getString("spice_version"));
    entity.setKernelVersion(rs.getString("kernel_version"));
    entity.setIScsiInitiatorName(rs.getString("iscsi_initiator_name"));
    entity.setTransparentHugePagesState(VdsTransparentHugePagesState.forValue(rs.getInt("transparent_hugepages_state")));
    entity.setAnonymousHugePages(rs.getInt("anonymous_hugepages"));
    entity.setHooksStr(rs.getString("hooks"));
    entity.setNonOperationalReason(NonOperationalReason.forValue(rs.getInt("non_operational_reason")));
    entity.setOtpValidity(rs.getLong("otp_validity"));
    entity.setVdsSpmPriority(rs.getInt("vds_spm_priority"));
    entity.setAutoRecoverable(rs.getBoolean("recoverable"));
    entity.setSshKeyFingerprint(rs.getString("sshKeyFingerprint"));
    entity.setHardwareManufacturer(rs.getString("hw_manufacturer"));
    entity.setHardwareProductName(rs.getString("hw_product_name"));
    entity.setHardwareVersion(rs.getString("hw_version"));
    entity.setHardwareSerialNumber(rs.getString("hw_serial_number"));
    entity.setHardwareUUID(rs.getString("hw_uuid"));
    entity.setHardwareFamily(rs.getString("hw_family"));
    entity.setHBAs(new JsonObjectDeserializer().deserialize(rs.getString("hbas"), HashMap.class));
    entity.setConsoleAddress(rs.getString("console_address"));
    entity.setSupportedEmulatedMachines(rs.getString("supported_emulated_machines"));
    entity.setHighlyAvailableScore(rs.getInt("ha_score"));
    entity.setDisablePowerManagementPolicy(rs.getBoolean("disable_auto_pm"));
    entity.setPowerManagementControlledByPolicy(rs.getBoolean("controlled_by_pm_policy"));
    entity.setHighlyAvailableIsConfigured(rs.getBoolean("ha_configured"));
    entity.setHighlyAvailableIsActive(rs.getBoolean("ha_active"));
    entity.setHighlyAvailableGlobalMaintenance(rs.getBoolean("ha_global_maintenance"));
    entity.setHighlyAvailableLocalMaintenance(rs.getBoolean("ha_local_maintenance"));
    entity.calculateFreeVirtualMemory();
    entity.setBootTime((Long) rs.getObject("boot_time"));
    return entity;
}
#end_block

#method_before
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    setComment(getComment());
    vds.setPort(getPort());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    return vds;
}
#method_after
public VDS clone() {
    VDS vds = new VDS();
    vds.setVdsGroupId(getVdsGroupId());
    vds.setVdsGroupCpuName(getVdsGroupCpuName());
    vds.setCpuName(getCpuName());
    vds.setVdsGroupDescription(getVdsGroupDescription());
    vds.setId(getId());
    vds.setVdsName(getName());
    vds.setManagementIp(getManagementIp());
    vds.setHostName(getHostName());
    vds.setComment(getComment());
    vds.setPort(getPort());
    vds.setSshPort(getSshPort());
    vds.setSshUsername(getSshUsername());
    vds.setStatus(getStatus());
    vds.setHardwareManufacturer(getHardwareManufacturer());
    vds.setHardwareProductName(getHardwareProductName());
    vds.setHardwareVersion(getHardwareVersion());
    vds.setHardwareSerialNumber(getHardwareSerialNumber());
    vds.setHardwareUUID(getHardwareUUID());
    vds.setHardwareFamily(getHardwareFamily());
    vds.setCpuCores(getCpuCores());
    vds.setCpuThreads(getCpuThreads());
    vds.setCpuModel(getCpuModel());
    vds.setCpuSpeedMh(getCpuSpeedMh());
    vds.setIfTotalSpeed(getIfTotalSpeed());
    vds.setKvmEnabled(getKvmEnabled());
    vds.setPhysicalMemMb(getPhysicalMemMb());
    vds.setCpuIdle(getCpuIdle());
    vds.setCpuLoad(getCpuLoad());
    vds.setCpuSys(getCpuSys());
    vds.setCpuUser(getCpuUser());
    vds.setMemCommited(getMemCommited());
    vds.setVmActive(getVmActive());
    vds.setVmCount(getVmCount());
    vds.setVmMigrating(getVmMigrating());
    vds.setUsageMemPercent(getUsageMemPercent());
    vds.setUsageCpuPercent(getUsageCpuPercent());
    vds.setUsageNetworkPercent(getUsageNetworkPercent());
    vds.setReservedMem(getReservedMem());
    vds.setBootTime(getBootTime());
    vds.setGuestOverhead(getGuestOverhead());
    vds.setPreviousStatus(getPreviousStatus());
    vds.setMemAvailable(getMemAvailable());
    vds.setMemShared(getMemShared());
    vds.setSoftwareVersion(getSoftwareVersion());
    vds.setVersionName(getVersionName());
    vds.setServerSslEnabled(isServerSslEnabled());
    vds.setCpuFlags(getCpuFlags());
    vds.setNetConfigDirty(getNetConfigDirty());
    vds.setpm_enabled(getpm_enabled());
    vds.setPmPassword(getPmPassword());
    vds.setPmPort(getPort());
    vds.setPmOptions(getPmOptions());
    vds.setPmType(getPmType());
    vds.setPmUser(getPmUser());
    vds.setPmSecondaryIp(getPmSecondaryIp());
    vds.setPmSecondaryType(getPmSecondaryType());
    vds.setPmSecondaryPort(getPmSecondaryPort());
    vds.setPmSecondaryOptions(getPmSecondaryOptions());
    vds.setPmSecondaryUser(getPmSecondaryUser());
    vds.setPmSecondaryPassword(getPmSecondaryPassword());
    vds.setPmSecondaryConcurrent(isPmSecondaryConcurrent());
    vds.setPmPort(getPmPort());
    vds.setConsoleAddress(getConsoleAddress());
    vds.setHBAs(getHBAs());
    vds.setVdsSpmPriority(getVdsSpmPriority());
    vds.setOtpValidity(getOtpValidity());
    vds.setKernelVersion(getKernelVersion());
    vds.setKvmVersion(getKvmVersion());
    vds.setLibvirtVersion(getLibvirtVersion());
    vds.setGlusterVersion(getGlusterVersion());
    vds.setHooksStr(getHooksStr());
    vds.setActiveNic(getActiveNic());
    vds.setPowerManagementControlledByPolicy(isPowerManagementControlledByPolicy());
    vds.setDisablePowerManagementPolicy(isDisablePowerManagementPolicy());
    vds.setHighlyAvailableScore(getHighlyAvailableScore());
    vds.setHighlyAvailableIsConfigured(getHighlyAvailableIsConfigured());
    vds.setHighlyAvailableIsActive(getHighlyAvailableIsActive());
    vds.setHighlyAvailableGlobalMaintenance(getHighlyAvailableGlobalMaintenance());
    vds.setHighlyAvailableLocalMaintenance(getHighlyAvailableLocalMaintenance());
    return vds;
}
#end_block

#method_before
public Date getBootTime() {
    return this.mVdsDynamic.getboot_time();
}
#method_after
public Long getBootTime() {
    return this.mVdsStatistics.getboot_time();
}
#end_block

#method_before
public void setBootTime(Date value) {
    this.mVdsDynamic.setboot_time(value);
}
#method_after
public void setBootTime(Long value) {
    this.mVdsStatistics.setboot_time(value);
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    } else {
        vm.setCurrentCd(null);
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
    if (xmlRpcStruct.containsKey(VdsProperties.CDRom)) {
        String isoName = Paths.get((String) xmlRpcStruct.get(VdsProperties.CDRom)).getFileName().toString();
        vm.setCurrentCd(isoName);
    }
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignDatetimeValue(xmlRpcStruct, VdsProperties.bootTime));
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignDatetimeValue(xmlRpcStruct, VdsProperties.bootTime));
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    // hosted engine
    Integer haScore = null;
    Boolean haIsConfigured = null;
    Boolean haIsActive = null;
    Boolean haGlobalMaint = null;
    Boolean haLocalMaint = null;
    if (xmlRpcStruct.containsKey(VdsProperties.ha_stats)) {
        Map<String, Object> haStats = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.ha_stats);
        if (haStats != null) {
            haScore = AssignIntValue(haStats, VdsProperties.ha_stats_score);
            haIsConfigured = AssignBoolValue(haStats, VdsProperties.ha_stats_is_configured);
            haIsActive = AssignBoolValue(haStats, VdsProperties.ha_stats_is_active);
            haGlobalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_global_maintenance);
            haLocalMaint = AssignBoolValue(haStats, VdsProperties.ha_stats_local_maintenance);
        }
    } else {
        haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
        // prior to 3.4, haScore was returned if ha was installed; assume active if > 0
        if (haScore != null) {
            haIsConfigured = true;
            haIsActive = (haScore > 0);
        }
    }
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    vds.setHighlyAvailableIsConfigured(haIsConfigured != null ? haIsConfigured : false);
    vds.setHighlyAvailableIsActive(haIsActive != null ? haIsActive : false);
    vds.setHighlyAvailableGlobalMaintenance(haGlobalMaint != null ? haGlobalMaint : false);
    vds.setHighlyAvailableLocalMaintenance(haLocalMaint != null ? haLocalMaint : false);
    vds.setBootTime(AssignLongValue(xmlRpcStruct, VdsProperties.bootTime));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(getStorageDomainId(), getStoragePoolId()) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST_IN_DATA_CENTER.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the DAO
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<Disk>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.error("Could not get populated disk, reason: " + unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#method_after
@Override
protected void executeQueryCommand() {
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    if (getDbFacade().getStorageDomainDao().get(getStorageDomainId()) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the DAO
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<Disk>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.error("Could not get populated disk, reason: " + unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(storageDomainId, storagePoolId) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST_IN_DATA_CENTER.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    if (getDbFacade().getStorageDomainDao().get(storageDomainId) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.STORAGE_DOMAIN_DOES_NOT_EXIST.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
@Test
public void testGetUnregisteredDisks() {
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    StorageDomainDAO storageDomainDAOMock = mock(StorageDomainDAO.class);
    when(dbFacadeMock.getStorageDomainDao()).thenReturn(storageDomainDAOMock);
    StorageDomain storageDomain = new StorageDomain();
    when(storageDomainDAOMock.getForStoragePool(storageDomainId, storagePoolId)).thenReturn(storageDomain);
    // Execute query
    getQuery().executeQueryCommand();
    // Assert the query's results
    @SuppressWarnings("unchecked")
    List<Disk> newDisks = (List<Disk>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals(newDisks.size(), 1);
    assertEquals(newDisks.get(0).getId(), importDiskId);
}
#method_after
@Test
public void testGetUnregisteredDisks() {
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    StorageDomainDAO storageDomainDAOMock = mock(StorageDomainDAO.class);
    when(dbFacadeMock.getStorageDomainDao()).thenReturn(storageDomainDAOMock);
    StorageDomain storageDomain = new StorageDomain();
    when(storageDomainDAOMock.get(storageDomainId)).thenReturn(storageDomain);
    // Execute query
    getQuery().executeQueryCommand();
    // Assert the query's results
    @SuppressWarnings("unchecked")
    List<Disk> newDisks = (List<Disk>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals(newDisks.size(), 1);
    assertEquals(newDisks.get(0).getId(), importDiskId);
}
#end_block

#method_before
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    DbFacade dbFacade = getDbFacade();
    check(dbFacade.getVdsDao(), VdcActionType.ActivateVds, new DoWithClosure<VDS, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final VDS arg) {
            final VdsActionParameters params = new VdsActionParameters(arg.getId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<VDS>() {

        @Override
        public List<VDS> filter(List<VDS> list) {
            List<VDS> filtered = new ArrayList<>(list.size());
            for (VDS vds : list) {
                Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(getDbFacade().getInterfaceDao().getAllInterfacesForVds(vds.getId()), getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
                if (problematicNics.getFirst().isEmpty()) {
                    filtered.add(vds);
                }
            }
            return filtered;
        }
    }, "hosts");
    check(dbFacade.getStorageDomainDao(), VdcActionType.ConnectDomainToStorage, new DoWithClosure<StorageDomain, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final StorageDomain arg) {
            final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(arg.getId(), arg.getStoragePoolId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<StorageDomain>() {

        @Override
        public List<StorageDomain> filter(List<StorageDomain> list) {
            return list;
        }
    }, "storage domains");
}
#method_after
@OnTimerMethodAnnotation("onTimer")
public void onTimer() {
    DbFacade dbFacade = getDbFacade();
    check(dbFacade.getVdsDao(), VdcActionType.ActivateVds, new DoWithClosure<VDS, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final VDS arg) {
            final VdsActionParameters params = new VdsActionParameters(arg.getId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<VDS>() {

        @Override
        public List<VDS> filter(List<VDS> list) {
            List<VDS> filtered = new ArrayList<>(list.size());
            List<VdsNetworkInterface> nics;
            for (VDS vds : list) {
                if (vds.getNonOperationalReason() == NonOperationalReason.NETWORK_INTERFACE_IS_DOWN) {
                    getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(vds));
                    nics = vds.getInterfaces();
                } else {
                    nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(vds.getId());
                }
                Pair<List<String>, List<String>> problematicNics = NetworkMonitoringHelper.determineProblematicNics(nics, getDbFacade().getNetworkDao().getAllForCluster(vds.getVdsGroupId()));
                if (problematicNics.getFirst().isEmpty()) {
                    filtered.add(vds);
                }
            }
            return filtered;
        }
    }, "hosts");
    check(dbFacade.getStorageDomainDao(), VdcActionType.ConnectDomainToStorage, new DoWithClosure<StorageDomain, VdcActionParametersBase>() {

        @Override
        public VdcActionParametersBase doWith(final StorageDomain arg) {
            final StorageDomainPoolParametersBase params = new StorageDomainPoolParametersBase(arg.getId(), arg.getStoragePoolId());
            params.setRunSilent(true);
            return params;
        }
    }, new FilterClosure<StorageDomain>() {

        @Override
        public List<StorageDomain> filter(List<StorageDomain> list) {
            return list;
        }
    }, "storage domains");
}
#end_block

#method_before
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    if (stat.getusage_network_percent() != null && stat.getusage_network_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("UsedNetwork", stat.getusage_network_percent().toString());
        logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
        auditLog(logable, AuditLogType.VDS_HIGH_NETWORK_USE);
    }
}
#method_after
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    for (VdsNetworkInterface iface : _vds.getInterfaces()) {
        Double transmitRate = iface.getStatistics().getTransmitRate();
        Double receiveRate = iface.getStatistics().getReceiveRate();
        if ((transmitRate != null && iface.getStatistics().getTransmitRate().intValue() > maxUsedPercentageThreshold) || (receiveRate != null && iface.getStatistics().getReceiveRate().intValue() > maxUsedPercentageThreshold)) {
            AuditLogableBase logable = new AuditLogableBase(_vds.getId());
            logable.setCustomId(iface.getName());
            logable.addCustomValue("HostName", _vds.getName());
            logable.addCustomValue("InterfaceName", iface.getName());
            logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
            logable.addCustomValue("TransmitRate", String.valueOf(transmitRate.intValue()));
            logable.addCustomValue("ReceiveRate", String.valueOf(receiveRate.intValue()));
            auditLog(logable, AuditLogType.HOST_INTERFACE_HIGH_NETWORK_USE);
        }
    }
}
#end_block

#method_before
private boolean isHostNetworkUnreacable(VDS vds) {
    VdsDynamic vdsDynamic = vds.getDynamicData();
    return ((vdsDynamic.getStatus() == VDSStatus.Down) || (vdsDynamic.getStatus() == VDSStatus.Reboot) || (vdsDynamic.getStatus() == VDSStatus.NonOperational && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE));
}
#method_after
private boolean isHostNetworkUnreacable(VDS vds) {
    VdsDynamic vdsDynamic = vds.getDynamicData();
    return (vdsDynamic.getStatus() == VDSStatus.Down || vdsDynamic.getStatus() == VDSStatus.Reboot || (vdsDynamic.getStatus() == VDSStatus.NonOperational && vdsDynamic.getNonOperationalReason() == NonOperationalReason.NETWORK_UNREACHABLE));
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(storageDomainId, storagePoolId) == null) {
        getQueryReturnValue().setExceptionString("Storage Domain does not exist in the Data Center");
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#method_after
@Override
protected void executeQueryCommand() {
    Guid storagePoolId = getParameters().getStoragePoolId();
    Guid storageDomainId = getParameters().getStorageDomainId();
    Guid diskId = getParameters().getDiskId();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(storageDomainId, storagePoolId) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST_IN_DATA_CENTER.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // Now get the list of volumes for each new image.
    StoragePoolDomainAndGroupIdBaseVDSCommandParameters getVolumesParameters = new StoragePoolDomainAndGroupIdBaseVDSCommandParameters(storagePoolId, storageDomainId, diskId);
    VDSReturnValue volumesListReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetVolumesList, getVolumesParameters);
    if (!volumesListReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(volumesListReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    @SuppressWarnings("unchecked")
    List<Guid> volumesList = (List<Guid>) volumesListReturn.getReturnValue();
    // image. If there are multiple volumes, skip the image and move on to the next.
    if (volumesList.size() != 1) {
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    Guid volumeId = volumesList.get(0);
    // Get the information about the volume from VDSM.
    GetImageInfoVDSCommandParameters imageInfoParameters = new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, diskId, volumeId);
    VDSReturnValue imageInfoReturn = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImageInfo, imageInfoParameters);
    if (!imageInfoReturn.getSucceeded()) {
        getQueryReturnValue().setExceptionString(imageInfoReturn.getExceptionString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    DiskImage newDiskImage = (DiskImage) imageInfoReturn.getReturnValue();
    // The disk image won't have an interface set on it. Set it to IDE by default. When the
    // disk is attached to a VM, its interface can be changed to the appropriate value for that VM.
    newDiskImage.setDiskInterface(DiskInterface.IDE);
    newDiskImage.setStoragePoolId(storagePoolId);
    getQueryReturnValue().setReturnValue(newDiskImage);
    getQueryReturnValue().setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(getStorageDomainId(), getStoragePoolId()) == null) {
        getQueryReturnValue().setExceptionString("Storage Domain does not exist in the Data Center");
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the DAO
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<Disk>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.error("Could not get populated disk, reason: " + unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#method_after
@Override
protected void executeQueryCommand() {
    VDSBrokerFrontend vdsBroker = getVdsBroker();
    if (getDbFacade().getStorageDomainDao().getForStoragePool(getStorageDomainId(), getStoragePoolId()) == null) {
        getQueryReturnValue().setExceptionString(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST_IN_DATA_CENTER.toString());
        getQueryReturnValue().setSucceeded(false);
        return;
    }
    // first, run getImagesList query into vdsm to get all of the images on the storage domain - then store in
    // imagesList
    VDSReturnValue imagesListResult = vdsBroker.RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getStoragePoolId()));
    @SuppressWarnings("unchecked")
    List<Guid> imagesList = (List<Guid>) imagesListResult.getReturnValue();
    // fromDao is a list of all disk images on the domain from the DAO
    List<DiskImage> fromDao = getDbFacade().getDiskImageDao().getAllSnapshotsForStorageDomain(getStorageDomainId());
    // if the ID in imagesList is recognized by oVirt, remove from list
    for (DiskImage image : fromDao) {
        imagesList.remove(image.getId());
    }
    List<Disk> unregisteredDisks = new ArrayList<Disk>();
    for (Guid unregisteredDiskId : imagesList) {
        GetUnregisteredDiskQueryParameters unregQueryParams = new GetUnregisteredDiskQueryParameters(unregisteredDiskId, getStorageDomainId(), getStoragePoolId());
        VdcQueryReturnValue unregQueryReturn = getBackend().runInternalQuery(VdcQueryType.GetUnregisteredDisk, unregQueryParams);
        if (unregQueryReturn.getSucceeded()) {
            unregisteredDisks.add(unregQueryReturn.<Disk>getReturnValue());
        } else {
            log.error("Could not get populated disk, reason: " + unregQueryReturn.getExceptionString());
        }
    }
    getQueryReturnValue().setReturnValue(unregisteredDisks);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
        return false;
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        return false;
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
            return false;
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
        return false;
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
        return false;
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
        return false;
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        addCanDoActionMessage("$device console");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        addCanDoActionMessage("$device sound");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        addCanDoActionMessage("$device VirtIO-SCSI");
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vmFromDB = getVm();
    VM vmFromParams = getParameters().getVm();
    if (!isVmExist()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    boolean vmNameValidLength = isVmNameValidLength(vmFromParams);
    if (!vmNameValidLength) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // Checking if a desktop with same name already exists
    if (!StringUtils.equals(vmFromDB.getName(), vmFromParams.getName())) {
        boolean exists = isVmWithSameNameExists(vmFromParams.getName());
        if (exists) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    List<ValidationError> validationErrors = validateCustomProperties(vmFromParams.getStaticData());
    if (!validationErrors.isEmpty()) {
        VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, getReturnValue().getCanDoActionMessages());
        return false;
    }
    if (!VmHandler.isOsTypeSupported(vmFromParams.getOs(), getVdsGroup().getArchitecture(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromParams.getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!areUpdatedFieldsLegal()) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_ILLEGAL_FIELD);
    }
    if (!vmFromDB.getVdsGroupId().equals(vmFromParams.getVdsGroupId())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_CLUSTER);
    }
    if (!isDedicatedVdsOnSameCluster(vmFromParams.getStaticData())) {
        return false;
    }
    // Check if number of monitors passed is legal
    if (!VmHandler.isNumOfMonitorsLegal(vmFromParams.getDefaultDisplayType(), vmFromParams.getNumOfMonitors(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check PCI and IDE limits are ok
    if (!isValidPciAndIdeLimit(vmFromParams)) {
        return false;
    }
    if (!VmTemplateCommand.isVmPriorityValueLegal(vmFromParams.getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (vmFromDB.getVmPoolId() != null && vmFromParams.isStateless()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_FROM_POOL_CANNOT_BE_STATELESS);
    }
    if (!AddVmCommand.checkCpuSockets(vmFromParams.getNumOfSockets(), vmFromParams.getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), vmFromParams.getIsoPath())) {
            return false;
        }
        // we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // check for Vm Watchdog Model
    if (getParameters().getWatchdog() != null) {
        if (!validate((new VmWatchdogValidator(vmFromParams.getOs(), getParameters().getWatchdog(), getVdsGroup().getcompatibility_version())).isModelCompatibleWithOs())) {
            return false;
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // Check if the display type is supported
    if (!VmHandler.isDisplayTypeSupported(vmFromParams.getOs(), vmFromParams.getDefaultDisplayType(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    // check cpuPinning
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (!validatePinningAndMigration(getReturnValue().getCanDoActionMessages(), getParameters().getVm().getStaticData(), getParameters().getVm().getCpuPinning())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (getParameters().isConsoleEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONSOLE, getParameters().isConsoleEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device console");
    }
    if (getParameters().isSoundDeviceEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.SOUND, getParameters().isSoundDeviceEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device sound");
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) || isVirtioScsiEnabledForVm(getVmId())) {
        // Verify cluster compatibility
        if (!FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
        }
        // Verify OS compatibility
        if (!VmHandler.isOsTypeSupportedForVirtioScsi(vmFromParams.getOs(), getVdsGroup().getcompatibility_version(), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    if (Boolean.FALSE.equals(getParameters().isVirtioScsiEnabled())) {
        List<Disk> allDisks = getDiskDao().getAllForVm(getVmId(), true);
        for (Disk disk : allDisks) {
            if (disk.getDiskInterface() == DiskInterface.VirtIO_SCSI) {
                return failCanDoAction(VdcBllMessages.CANNOT_DISABLE_VIRTIO_SCSI_PLUGGED_DISKS);
            }
        }
    }
    if (getParameters().isVirtioScsiEnabled() != null && !getVm().isDown() && vmDeviceChanged(VmDeviceGeneralType.CONTROLLER, VmDeviceType.VIRTIOSCSI.getName(), getParameters().isVirtioScsiEnabled())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_UPDATE_DEVICE_VM_NOT_DOWN, "$device VirtIO-SCSI");
    }
    if (vmFromParams.getMinAllocatedMem() > vmFromParams.getMemSizeMb()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIN_MEMORY_CANNOT_EXCEED_MEMORY_SIZE);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean canDo = true;
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        canDo = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if (getParameters().getPlugAction() == PlugAction.PLUG) {
        if (!FeatureSupported.hotPlugCpu(getVm().getVdsGroupCompatibilityVersion(), getVm().getClusterArch())) {
            canDo = failCanDoAction(VdcBllMessages.HOT_PLUG_CPU_IS_NOT_SUPPORTED);
        }
    } else if (!FeatureSupported.hotUnplugCpu(getVm().getVdsGroupCompatibilityVersion(), getVm().getClusterArch())) {
        canDo = failCanDoAction(VdcBllMessages.HOT_UNPLUG_CPU_IS_NOT_SUPPORTED);
    }
    return canDo;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean canDo = true;
    if (getVm() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
    }
    if (getVm().getStatus() != VMStatus.Up) {
        canDo = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if (getParameters().getVm().getNumOfCpus() > SlaValidator.getEffectiveCpuCores(getVds())) {
        canDo = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_VM_CPUS);
    }
    if (getParameters().getPlugAction() == PlugAction.PLUG) {
        if (!FeatureSupported.hotPlugCpu(getVm().getVdsGroupCompatibilityVersion(), getVm().getClusterArch())) {
            canDo = failCanDoAction(VdcBllMessages.HOT_PLUG_CPU_IS_NOT_SUPPORTED);
        }
    } else if (!FeatureSupported.hotUnplugCpu(getVm().getVdsGroupCompatibilityVersion(), getVm().getClusterArch())) {
        canDo = failCanDoAction(VdcBllMessages.HOT_UNPLUG_CPU_IS_NOT_SUPPORTED);
    }
    return canDo;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__HOT_SET_CPUS);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    addCanDoActionMessage(String.format("clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion()));
    addCanDoActionMessage(String.format("$architecture %1$s", getVm().getClusterArch()));
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__HOT_SET_CPUS);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM);
    addCanDoActionMessage(String.format("$clusterVersion %1$s", getVm().getVdsGroupCompatibilityVersion()));
    addCanDoActionMessage(String.format("$architecture %1$s", getVm().getClusterArch()));
}
#end_block

#method_before
public boolean getLegal() {
    if (getUseTimout()) {
        String keyForCheck = getkeyForCheck();
        if (!CacheManager.getTimeoutBaseCache().containsKey(keyForCheck)) {
            CacheManager.getTimeoutBaseCache().put(keyForCheck, keyForCheck, getEndTime(), TimeUnit.MILLISECONDS);
            return true;
        }
        return false;
    }
    return true;
}
#method_after
public boolean getLegal() {
    if (getUseTimout()) {
        String keyForCheck = getkeyForCheck();
        synchronized (keyForCheck.intern()) {
            if (!CacheManager.getTimeoutBaseCache().containsKey(keyForCheck)) {
                CacheManager.getTimeoutBaseCache().put(keyForCheck, keyForCheck, getEndTime(), TimeUnit.MILLISECONDS);
                return true;
            }
        }
        return false;
    }
    return true;
}
#end_block

#method_before
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    for (VdsNetworkInterface iface : _vds.getInterfaces()) {
        checkNetwrokInterfaceThreshold(iface, iface.getStatistics().getReceiveRate(), AuditLogType.RECEIVE_RATE);
        checkNetwrokInterfaceThreshold(iface, iface.getStatistics().getTransmitRate(), AuditLogType.TRANSMIT_RATE);
    }
}
#method_after
private void checkVdsNetworkThreshold(VdsStatistics stat) {
    Integer maxUsedPercentageThreshold = Config.getValue(ConfigValues.LogMaxNetworkUsedThresholdInPercentage);
    for (VdsNetworkInterface iface : _vds.getInterfaces()) {
        Double transmitRate = iface.getStatistics().getTransmitRate();
        Double receiveRate = iface.getStatistics().getReceiveRate();
        if ((transmitRate != null && iface.getStatistics().getTransmitRate().intValue() > maxUsedPercentageThreshold) || (receiveRate != null && iface.getStatistics().getReceiveRate().intValue() > maxUsedPercentageThreshold)) {
            AuditLogableBase logable = new AuditLogableBase(_vds.getId());
            logable.setCustomId(iface.getName());
            logable.addCustomValue("HostName", _vds.getName());
            logable.addCustomValue("InterfaceName", iface.getName());
            logable.addCustomValue("Threshold", maxUsedPercentageThreshold.toString());
            logable.addCustomValue("TransmitRate", String.valueOf(transmitRate.intValue()));
            logable.addCustomValue("ReceiveRate", String.valueOf(receiveRate.intValue()));
            auditLog(logable, AuditLogType.HOST_INTERFACE_HIGH_NETWORK_USE);
        }
    }
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retreive it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                StringBuilder sNics = new StringBuilder();
                StringBuilder sNetworks = new StringBuilder();
                for (String nic : brokenNics) {
                    sNics.append(nic).append(", ");
                }
                for (String net : networks) {
                    sNetworks.append(net).append(", ");
                }
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), sNics.toString(), sNetworks.toString());
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", StringUtils.stripEnd(sNetworks.toString(), ", "));
                logable.addCustomValue("Interfaces", StringUtils.stripEnd(sNics.toString(), ", "));
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#method_after
// Check if one of the Host interfaces is down, we set the host to non-operational
private void checkVdsInterfaces() {
    if (_vds.getStatus() != VDSStatus.Up) {
        return;
    }
    List<String> networks = new ArrayList<String>();
    List<String> brokenNics = new ArrayList<String>();
    try {
        Pair<List<String>, List<String>> problematicNics = determineProblematicNics(_vds.getInterfaces(), getDbFacade().getNetworkDao().getAllForCluster(_vds.getVdsGroupId()));
        brokenNics.addAll(problematicNics.getFirst());
        networks.addAll(problematicNics.getSecond());
    } catch (Exception e) {
        log.error(String.format("Failure on checkInterfaces on update runtimeinfo for vds: %s", _vds.getName()), e);
    } finally {
        if (!brokenNics.isEmpty()) {
            // we give 1 minutes to a nic to get up in case the nic get the ip from DHCP server
            if (!hostDownTimes.containsKey(_vds.getId())) {
                hostDownTimes.put(_vds.getId(), System.currentTimeMillis());
                return;
            }
            // if less then 1 minutes, still waiting for DHCP
            int delay = Config.<Integer>getValue(ConfigValues.NicDHCPDelayGraceInMS) * 1000;
            if (System.currentTimeMillis() < hostDownTimes.get(_vds.getId()) + delay) {
                return;
            }
            // if we could retrieve it within the timeout, remove from map (for future checks) and set the host to
            // non-operational
            hostDownTimes.remove(_vds.getId());
            try {
                String networkNames = StringUtils.join(networks, ", ");
                String nicNames = StringUtils.join(brokenNics, ", ");
                String message = String.format("Host '%s' moved to Non-Operational state because interface/s '%s' are down which needed by network/s '%s' in the current cluster", _vds.getName(), nicNames, networkNames);
                _vds.setNonOperationalReason(NonOperationalReason.NETWORK_INTERFACE_IS_DOWN);
                _vdsManager.setStatus(VDSStatus.NonOperational, _vds);
                log.info(message);
                AuditLogableBase logable = new AuditLogableBase(_vds.getId());
                logable.addCustomValue("Networks", networkNames);
                logable.addCustomValue("Interfaces", nicNames);
                logable.setCustomId(nicNames + networkNames);
                auditLog(logable, AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN);
            } catch (Exception e) {
                log.error(String.format("checkInterface: Failure on moving host: %s to non-operational.", _vds.getName()), e);
            }
        } else {
            // no nics are down, remove from list if exists
            hostDownTimes.remove(_vds.getId());
        }
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        // refreshCommitedMemory must be called before we modify _runningVms, because
        // we iterate over it there, assuming it is the same as it was received from VDSM
        refreshCommitedMemory();
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#end_block

#method_before
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters> command = new GetVmStatsVDSCommand<GetVmStatsVDSCommandParameters>(new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                command.execute();
                if (command.getVDSReturnValue().getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) command.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#method_after
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.errorFormat("failed to fetch {0} stats. status remain unchanged ({1})", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                _runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#method_after
protected void processExternallyManagedVms() {
    List<String> vmsToQuery = new ArrayList<String>();
    // Searching for External VMs that run on the host
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VM currentVmData = _vmDict.get(vmInternalData.getVmDynamic().getId());
        if (currentVmData == null) {
            if (getDbFacade().getVmStaticDao().get(vmInternalData.getVmDynamic().getId()) == null) {
                Guid vmId = vmInternalData.getVmDynamic().getId();
                vmsToQuery.add(vmId.toString());
            }
        }
    }
    // and marking the VMs for addition
    if (!vmsToQuery.isEmpty()) {
        // Query VDSM for VMs info, and creating a proper VMStatic to be used when importing them
        Map[] vmsInfo = getVmInfo(vmsToQuery);
        for (Map vmInfo : vmsInfo) {
            Guid vmId = Guid.createGuidFromString((String) vmInfo.get(VdsProperties.vm_guid));
            VmStatic vmStatic = new VmStatic();
            vmStatic.setId(vmId);
            vmStatic.setCreationDate(new Date());
            vmStatic.setVdsGroupId(_vds.getVdsGroupId());
            String vmNameOnHost = (String) vmInfo.get(VdsProperties.vm_name);
            if (StringUtils.equals(HOSTED_ENGINE_VM_NAME, vmNameOnHost)) {
                vmStatic.setName(vmNameOnHost);
                vmStatic.setOrigin(OriginType.HOSTED_ENGINE);
                vmStatic.setMigrationSupport(MigrationSupport.IMPLICITLY_NON_MIGRATABLE);
            } else {
                vmStatic.setName(String.format(EXTERNAL_VM_NAME_FORMAT, vmNameOnHost));
                vmStatic.setOrigin(OriginType.EXTERNAL);
            }
            vmStatic.setNumOfSockets(parseIntVdsProperty(vmInfo.get(VdsProperties.num_of_cpus)));
            vmStatic.setMemSizeMb(parseIntVdsProperty(vmInfo.get(VdsProperties.mem_size_mb)));
            vmStatic.setSingleQxlPci(false);
            _externalVmsToAdd.add(vmStatic);
            log.infoFormat("Importing VM {0} as {1}, as it is running on the on Host, but does not exist in the engine.", vmNameOnHost, vmStatic.getName());
        }
    }
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        // we shouldn't include them as committed.
        if (vm.getStatus() != VMStatus.WaitForLaunch) {
            memCommited += vm.getVmMemSizeMb();
            memCommited += _vds.getGuestOverhead();
            vmsCoresCount += vm.getNumOfCpus();
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#method_after
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VmInternalData runningVm : _runningVms.values()) {
        VmDynamic vmDynamic = runningVm.getVmDynamic();
        // we shouldn't include them as committed.
        if (vmDynamic.getStatus() != VMStatus.WaitForLaunch && vmDynamic.getStatus() != VMStatus.Down) {
            VM vm = _vmDict.get(vmDynamic.getId());
            if (vm != null) {
                memCommited += vm.getVmMemSizeMb();
                memCommited += _vds.getGuestOverhead();
                vmsCoresCount += vm.getNumOfCpus();
            }
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#end_block

#method_before
@Override
public String toString() {
    return String.format("vmId = %s, status = %s", getVmId(), getStatus());
}
#method_after
@Override
public String toString() {
    return String.format("vmId = %s, status = %s, exit status = %s", getVmId(), getStatus(), getExitStatus());
}
#end_block

#method_before
@Test
public void testIscsiLogin() throws Exception {
    setUriInfo(setUpActionExpectations(VdcActionType.ConnectStorageToVds, StorageServerConnectionParametersBase.class, new String[] { "VdsId", "StorageServerConnection.connection", "StorageServerConnection.portal", "StorageServerConnection.iqn", "StorageServerConnection.port", "StorageServerConnection.storage_type", "StorageServerConnection.user_name", "StorageServerConnection.password" }, new Object[] { GUIDS[0], ISCSI_SERVER_ADDRESS, // TODO: right now hard-coded, but this should change when VDSM and Backend support portal
    "1", ISCSI_IQN, ISCSI_PORT_STRING, ISCSI_STORAGE_TYPE, ISCSI_USER_NAME, ISCSI_USER_PASS }));
    Action action = new Action();
    IscsiDetails iscsiDetails = new IscsiDetails();
    iscsiDetails.setAddress(ISCSI_SERVER_ADDRESS);
    iscsiDetails.setPort(ISCSI_PORT_INT);
    iscsiDetails.setTarget(ISCSI_IQN);
    iscsiDetails.setUsername(ISCSI_USER_NAME);
    iscsiDetails.setPassword(ISCSI_USER_PASS);
    action.setIscsi(iscsiDetails);
    verifyActionResponse(resource.iscsiLogin(action));
}
#method_after
@Test
public void testIscsiLogin() throws Exception {
    setUriInfo(setUpActionExpectations(VdcActionType.ConnectStorageToVds, StorageServerConnectionParametersBase.class, new String[] { "VdsId", "StorageServerConnection.connection", "StorageServerConnection.portal", "StorageServerConnection.iqn", "StorageServerConnection.port", "StorageServerConnection.storage_type", "StorageServerConnection.user_name", "StorageServerConnection.password" }, new Object[] { GUIDS[0], ISCSI_SERVER_ADDRESS, // TODO: right now hard-coded, but this should change when VDSM and Backend support portal
    StorageServerConnections.DEFAULT_TPGT, ISCSI_IQN, ISCSI_PORT_STRING, ISCSI_STORAGE_TYPE, ISCSI_USER_NAME, ISCSI_USER_PASS }));
    Action action = new Action();
    IscsiDetails iscsiDetails = new IscsiDetails();
    iscsiDetails.setAddress(ISCSI_SERVER_ADDRESS);
    iscsiDetails.setPort(ISCSI_PORT_INT);
    iscsiDetails.setTarget(ISCSI_IQN);
    iscsiDetails.setUsername(ISCSI_USER_NAME);
    iscsiDetails.setPassword(ISCSI_USER_PASS);
    action.setIscsi(iscsiDetails);
    verifyActionResponse(resource.iscsiLogin(action));
}
#end_block

#method_before
public void handleQuotaColumnVisibility() {
    isQuotaVisible = false;
    SystemTreeItemModel treeItem = (SystemTreeItemModel) CommonModel.getInstance().getSystemTree().getSelectedItem();
    if (treeItem != null && SystemTreeItemType.DataCenter.equals(treeItem.getType())) {
        StoragePool storagePool = (StoragePool) treeItem.getEntity();
        if (!QuotaEnforcementTypeEnum.DISABLED.equals(storagePool.getQuotaEnforcementType())) {
            isQuotaVisible = true;
        }
    }
    onDiskViewTypeChanged();
}
#method_after
public void handleQuotaColumnVisibility() {
    isQuotaVisible = false;
    SystemTreeItemModel treeItem = (SystemTreeItemModel) CommonModelManager.instance().getSystemTree().getSelectedItem();
    if (treeItem != null && SystemTreeItemType.DataCenter == treeItem.getType()) {
        StoragePool storagePool = (StoragePool) treeItem.getEntity();
        if (QuotaEnforcementTypeEnum.DISABLED != storagePool.getQuotaEnforcementType()) {
            isQuotaVisible = true;
        }
    }
    onDiskViewTypeChanged();
}
#end_block

#method_before
void onDiskViewTypeChanged() {
    boolean all = disksViewRadioGroup.getAllButton().getValue();
    boolean images = disksViewRadioGroup.getImagesButton().getValue();
    boolean luns = disksViewRadioGroup.getLunsButton().getValue();
    searchByDiskViewType(disksViewRadioGroup.getDiskStorageType());
    getTable().ensureColumnPresent(DisksViewColumns.aliasColumn, constants.aliasDisk(), all || images || luns, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.idColumn, constants.idDisk(), all || images || luns, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.bootableDiskColumn, DisksViewColumns.bootableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.shareableDiskColumn, DisksViewColumns.shareableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.lunDiskColumn, DisksViewColumns.lunDiskColumn.getHeaderHtml(), all, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(// $NON-NLS-1$
    DisksViewColumns.diskContainersIconColumn, // $NON-NLS-1$
    "", // $NON-NLS-1$
    all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.diskContainersColumn, constants.attachedToDisk(), all || images || luns, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.storageDomainsColumn, constants.storageDomainsDisk(), images, // $NON-NLS-1$
    "180px");
    getTable().ensureColumnPresent(DisksViewColumns.sizeColumn, constants.provisionedSizeDisk(), all || images || luns, // $NON-NLS-1$
    "110px");
    getTable().ensureColumnPresent(DisksViewColumns.allocationColumn, constants.allocationDisk(), images, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnPresent(DisksViewColumns.dateCreatedColumn, constants.creationDateDisk(), images, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnPresent(DisksViewColumns.statusColumn, constants.statusDisk(), images, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(DisksViewColumns.lunIdColumn, constants.lunIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunSerialColumn, constants.serialSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunVendorIdColumn, constants.vendorIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunProductIdColumn, constants.productIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.qoutaColumn, constants.qoutaDisk(), (all || images || luns) && isQuotaVisible, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.descriptionColumn, constants.descriptionDisk(), all || images || luns, // $NON-NLS-1$
    "90px");
}
#method_after
void onDiskViewTypeChanged() {
    boolean all = disksViewRadioGroup.getAllButton().getValue();
    boolean images = disksViewRadioGroup.getImagesButton().getValue();
    boolean luns = disksViewRadioGroup.getLunsButton().getValue();
    searchByDiskViewType(disksViewRadioGroup.getDiskStorageType());
    getTable().ensureColumnPresent(DisksViewColumns.aliasColumn, constants.aliasDisk(), all || images || luns, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.idColumn, constants.idDisk(), all || images || luns, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.bootableDiskColumn, DisksViewColumns.bootableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.shareableDiskColumn, DisksViewColumns.shareableDiskColumn.getHeaderHtml(), all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.lunDiskColumn, DisksViewColumns.lunDiskColumn.getHeaderHtml(), all, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(// $NON-NLS-1$
    DisksViewColumns.diskContainersIconColumn, // $NON-NLS-1$
    "", // $NON-NLS-1$
    all || images || luns, // $NON-NLS-1$
    "30px");
    getTable().ensureColumnPresent(DisksViewColumns.diskContainersColumn, constants.attachedToDisk(), all || images || luns, // $NON-NLS-1$
    "125px");
    getTable().ensureColumnPresent(DisksViewColumns.storageDomainsColumn, constants.storageDomainsDisk(), images, // $NON-NLS-1$
    "180px");
    getTable().ensureColumnPresent(DisksViewColumns.sizeColumn, constants.provisionedSizeDisk(), all || images || luns, // $NON-NLS-1$
    "110px");
    getTable().ensureColumnPresent(DisksViewColumns.allocationColumn, constants.allocationDisk(), images, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnPresent(DisksViewColumns.dateCreatedColumn, constants.creationDateDisk(), images, // $NON-NLS-1$
    "130px");
    getTable().ensureColumnPresent(DisksViewColumns.statusColumn, constants.statusDisk(), images, // $NON-NLS-1$
    "80px");
    getTable().ensureColumnPresent(DisksViewColumns.lunIdColumn, constants.lunIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunSerialColumn, constants.serialSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunVendorIdColumn, constants.vendorIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.lunProductIdColumn, constants.productIdSanStorage(), luns, // $NON-NLS-1$
    "100px");
    getTable().ensureColumnPresent(DisksViewColumns.qoutaColumn, constants.quotaDisk(), images && isQuotaVisible, // $NON-NLS-1$
    "120px");
    getTable().ensureColumnPresent(DisksViewColumns.descriptionColumn, constants.descriptionDisk(), all || images || luns, // $NON-NLS-1$
    "90px");
}
#end_block

#method_before
void searchByDiskViewType(Object diskViewType) {
    // $NON-NLS-1$
    final String disksSearchPrefix = "Disks:";
    // $NON-NLS-1$
    final String diskTypeSearchPrefix = "disk_type = ";
    // $NON-NLS-1$
    final String searchConjunctionAnd = "and ";
    // $NON-NLS-1$
    final String searchRegexDisksSearchPrefix = "^\\s*(disk(s)?\\s*(:)+)+\\s*";
    // $NON-NLS-1$
    final String searchRegexDiskTypeClause = "\\s*((and|or)\\s+)?disk_type\\s*=\\s*\\S+";
    // $NON-NLS-1$
    final String searchRegexStartConjunction = "^\\s*(and|or)\\s*";
    // $NON-NLS-1$
    final String searchRegexFlags = "ig";
    // $NON-NLS-1$
    final String space = " ";
    // $NON-NLS-1$
    final String empty = "";
    // $NON-NLS-1$
    final String colon = ":";
    RegExp searchPatternDisksSearchPrefix = RegExp.compile(searchRegexDisksSearchPrefix, searchRegexFlags);
    RegExp searchPatternDiskTypeClause = RegExp.compile(searchRegexDiskTypeClause, searchRegexFlags);
    RegExp searchPatternStartConjunction = RegExp.compile(searchRegexStartConjunction, searchRegexFlags);
    String diskTypePostfix = diskViewType != null ? ((DiskStorageType) diskViewType).name().toLowerCase() + space : null;
    String diskTypeClause = diskTypePostfix != null ? diskTypeSearchPrefix + diskTypePostfix : empty;
    String inputSearchString = commonModel.getSearchString().trim();
    String inputSearchStringPrefix = commonModel.getSearchStringPrefix().trim();
    if (!inputSearchString.isEmpty() && inputSearchStringPrefix.isEmpty()) {
        int indexOfColon = inputSearchString.indexOf(colon);
        inputSearchStringPrefix = inputSearchString.substring(0, indexOfColon + 1).trim();
        inputSearchString = inputSearchString.substring(indexOfColon + 1).trim();
    }
    if (inputSearchStringPrefix.isEmpty()) {
        inputSearchStringPrefix = disksSearchPrefix;
        inputSearchString = empty;
    }
    String searchStringPrefixRaw = searchPatternDiskTypeClause.replace(inputSearchStringPrefix, empty).trim();
    String searchStringPrefix;
    if (diskTypeClause.equals(empty)) {
        searchStringPrefix = searchStringPrefixRaw + space;
    } else {
        searchStringPrefix = searchStringPrefixRaw + space + (searchPatternDisksSearchPrefix.test(searchStringPrefixRaw) ? empty : searchConjunctionAnd) + diskTypeClause;
    }
    inputSearchString = searchPatternDiskTypeClause.replace(inputSearchString, empty);
    inputSearchString = searchPatternStartConjunction.replace(inputSearchString, empty);
    String searchString;
    if (searchPatternDisksSearchPrefix.test(searchStringPrefix) || inputSearchString.isEmpty()) {
        searchString = inputSearchString;
    } else {
        searchString = searchConjunctionAnd + inputSearchString;
    }
    commonModel.setSearchStringPrefix(searchStringPrefix);
    commonModel.setSearchString(searchString);
    getTable().getSelectionModel().clear();
    getMainModel().setItems(null);
    getMainModel().setSearchString(commonModel.getEffectiveSearchString());
    getMainModel().search();
}
#method_after
void searchByDiskViewType(Object diskViewType) {
    // $NON-NLS-1$
    final String disksSearchPrefix = "Disks:";
    // $NON-NLS-1$
    final String diskTypeSearchPrefix = "disk_type = ";
    // $NON-NLS-1$
    final String searchConjunctionAnd = "and ";
    // $NON-NLS-1$
    final String searchRegexDisksSearchPrefix = "^\\s*(disk(s)?\\s*(:)+)+\\s*";
    // $NON-NLS-1$
    final String searchRegexDiskTypeClause = "\\s*((and|or)\\s+)?disk_type\\s*=\\s*\\S+";
    // $NON-NLS-1$
    final String searchRegexStartConjunction = "^\\s*(and|or)\\s*";
    // $NON-NLS-1$
    final String searchRegexFlags = "ig";
    // $NON-NLS-1$
    final String space = " ";
    // $NON-NLS-1$
    final String empty = "";
    // $NON-NLS-1$
    final String colon = ":";
    RegExp searchPatternDisksSearchPrefix = RegExp.compile(searchRegexDisksSearchPrefix, searchRegexFlags);
    RegExp searchPatternDiskTypeClause = RegExp.compile(searchRegexDiskTypeClause, searchRegexFlags);
    RegExp searchPatternStartConjunction = RegExp.compile(searchRegexStartConjunction, searchRegexFlags);
    String diskTypePostfix = diskViewType != null ? ((DiskStorageType) diskViewType).name().toLowerCase() + space : null;
    String diskTypeClause = diskTypePostfix != null ? diskTypeSearchPrefix + diskTypePostfix : empty;
    String inputSearchString = CommonModelManager.instance().getSearchString().trim();
    String inputSearchStringPrefix = CommonModelManager.instance().getSearchStringPrefix().trim();
    if (!inputSearchString.isEmpty() && inputSearchStringPrefix.isEmpty()) {
        int indexOfColon = inputSearchString.indexOf(colon);
        inputSearchStringPrefix = inputSearchString.substring(0, indexOfColon + 1).trim();
        inputSearchString = inputSearchString.substring(indexOfColon + 1).trim();
    }
    if (inputSearchStringPrefix.isEmpty()) {
        inputSearchStringPrefix = disksSearchPrefix;
        inputSearchString = empty;
    }
    String searchStringPrefixRaw = searchPatternDiskTypeClause.replace(inputSearchStringPrefix, empty).trim();
    String searchStringPrefix;
    if (diskTypeClause.equals(empty)) {
        searchStringPrefix = searchStringPrefixRaw + space;
    } else {
        searchStringPrefix = searchStringPrefixRaw + space + (searchPatternDisksSearchPrefix.test(searchStringPrefixRaw) ? empty : searchConjunctionAnd) + diskTypeClause;
    }
    inputSearchString = searchPatternDiskTypeClause.replace(inputSearchString, empty);
    inputSearchString = searchPatternStartConjunction.replace(inputSearchString, empty);
    String searchString;
    if (searchPatternDisksSearchPrefix.test(searchStringPrefix) || inputSearchString.isEmpty()) {
        searchString = inputSearchString;
    } else {
        searchString = searchConjunctionAnd + inputSearchString;
    }
    CommonModelManager.instance().setSearchStringPrefix(searchStringPrefix);
    CommonModelManager.instance().setSearchString(searchString);
    getTable().getSelectionModel().clear();
    getMainModel().setItems(null);
    getMainModel().setSearchString(CommonModelManager.instance().getEffectiveSearchString());
    getMainModel().search();
}
#end_block

#method_before
public void onSaveInternal() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    StoragePool dataCenter = model.getIsNew() ? new StoragePool() : (StoragePool) Cloner.clone(getSelectedItem());
    // cancel confirm window if there is
    cancelConfirmation();
    // Save changes.
    dataCenter.setName(model.getName().getEntity());
    dataCenter.setdescription(model.getDescription().getEntity());
    dataCenter.setComment(model.getComment().getEntity());
    dataCenter.setIsLocal(model.getStoragePoolType().getSelectedItem());
    dataCenter.setcompatibility_version(model.getVersion().getSelectedItem());
    dataCenter.setQuotaEnforcementType(model.getQuotaEnforceTypeListModel().getSelectedItem());
    model.startProgress(null);
    if (model.getIsNew()) {
        // When adding a data center use sync action to be able present a Guide Me dialog afterwards.
        Frontend.getInstance().runAction(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(dataCenter), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        // Update the Quota at the corresponding DC object at the system tree.
        // The DC Quota value from the tree is used at MainTabDiskView.
        SystemTreeItemModel itemModel = CommonModel.getInstance().getSystemTree().getItemById(dataCenter.getId());
        StoragePool storagePool = (StoragePool) itemModel.getEntity();
        storagePool.setQuotaEnforcementType(dataCenter.getQuotaEnforcementType());
        // Otherwise use async action in order to close dialog immediately.
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateStoragePool, new ArrayList<VdcActionParametersBase>(Arrays.asList(new StoragePoolManagementParameter(dataCenter))), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue().get(0));
            }
        }, this);
    }
}
#method_after
public void onSaveInternal() {
    DataCenterModel model = (DataCenterModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    StoragePool dataCenter = model.getIsNew() ? new StoragePool() : (StoragePool) Cloner.clone(getSelectedItem());
    // cancel confirm window if there is
    cancelConfirmation();
    // Save changes.
    dataCenter.setName(model.getName().getEntity());
    dataCenter.setdescription(model.getDescription().getEntity());
    dataCenter.setComment(model.getComment().getEntity());
    dataCenter.setIsLocal(model.getStoragePoolType().getSelectedItem());
    dataCenter.setcompatibility_version(model.getVersion().getSelectedItem());
    dataCenter.setQuotaEnforcementType(model.getQuotaEnforceTypeListModel().getSelectedItem());
    model.startProgress(null);
    if (model.getIsNew()) {
        // When adding a data center use sync action to be able present a Guide Me dialog afterwards.
        Frontend.getInstance().runAction(VdcActionType.AddEmptyStoragePool, new StoragePoolManagementParameter(dataCenter), new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue());
            }
        }, this);
    } else {
        // Update the Quota at the corresponding DC object at the system tree.
        // The DC Quota value from the tree is used at MainTabDiskView.
        SystemTreeItemModel itemModel = CommonModel.getInstance().getSystemTree().getItemById(dataCenter.getId());
        itemModel.setEntity(dataCenter);
        // Otherwise use async action in order to close dialog immediately.
        Frontend.getInstance().runMultipleAction(VdcActionType.UpdateStoragePool, new ArrayList<VdcActionParametersBase>(Arrays.asList(new StoragePoolManagementParameter(dataCenter))), new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                DataCenterListModel localModel = (DataCenterListModel) result.getState();
                localModel.postOnSaveInternal(result.getReturnValue().get(0));
            }
        }, this);
    }
}
#end_block

#method_before
@Override
public void executed(FrontendMultipleQueryAsyncResult result) {
    ArrayList<StorageDomain> storages = null;
    int count = -1;
    treeItemById = new HashMap<Guid, SystemTreeItemModel>();
    // Build tree items.
    SystemTreeItemModel systemItem = new SystemTreeItemModel();
    systemItem.setType(SystemTreeItemType.System);
    systemItem.setIsSelected(true);
    systemItem.setTitle(ConstantsManager.getInstance().getConstants().systemTitle());
    // Add Data Centers node under System
    SystemTreeItemModel dataCentersItem = new SystemTreeItemModel();
    dataCentersItem.setType(SystemTreeItemType.DataCenters);
    dataCentersItem.setApplicationMode(ApplicationMode.VirtOnly);
    dataCentersItem.setTitle(ConstantsManager.getInstance().getConstants().dataCentersTitle());
    systemItem.addChild(dataCentersItem);
    // Populate everything under Data Centers
    for (VdcQueryReturnValue returnValue : result.getReturnValues()) {
        ++count;
        if (!returnValue.getSucceeded()) {
            continue;
        }
        storages = (ArrayList<StorageDomain>) returnValue.getReturnValue();
        SystemTreeItemModel dataCenterItem = new SystemTreeItemModel();
        dataCenterItem.setType(SystemTreeItemType.DataCenter);
        dataCenterItem.setApplicationMode(ApplicationMode.VirtOnly);
        dataCenterItem.setTitle(getDataCenters().get(count).getName());
        dataCenterItem.setEntity(getDataCenters().get(count));
        dataCentersItem.addChild(dataCenterItem);
        SystemTreeItemModel storagesItem = new SystemTreeItemModel();
        storagesItem.setType(SystemTreeItemType.Storages);
        storagesItem.setApplicationMode(ApplicationMode.VirtOnly);
        storagesItem.setTitle(ConstantsManager.getInstance().getConstants().storageTitle());
        storagesItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(storagesItem);
        treeItemById.put(getDataCenters().get(count).getId(), storagesItem);
        if (storages != null && storages.size() > 0) {
            // sort by name first
            Collections.sort(storages, new Linq.StorageDomainComparator());
            for (StorageDomain storage : storages) {
                SystemTreeItemModel storageItem = new SystemTreeItemModel();
                storageItem.setType(SystemTreeItemType.Storage);
                storageItem.setApplicationMode(ApplicationMode.VirtOnly);
                storageItem.setTitle(storage.getStorageName());
                storageItem.setEntity(storage);
                storagesItem.addChild(storageItem);
            }
        }
        SystemTreeItemModel networksItem = new SystemTreeItemModel();
        networksItem.setType(SystemTreeItemType.Networks);
        networksItem.setApplicationMode(ApplicationMode.VirtOnly);
        networksItem.setTitle(ConstantsManager.getInstance().getConstants().networksTitle());
        networksItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(networksItem);
        List<Network> dcNetworks = getNetworkMap().get(getDataCenters().get(count).getId());
        if (dcNetworks != null) {
            // sort by name first
            Collections.sort(dcNetworks, new Linq.NetworkComparator());
            for (Network network : dcNetworks) {
                SystemTreeItemModel networkItem = new SystemTreeItemModel();
                networkItem.setType(SystemTreeItemType.Network);
                networkItem.setApplicationMode(ApplicationMode.VirtOnly);
                networkItem.setTitle(network.getName());
                networkItem.setEntity(network);
                networksItem.addChild(networkItem);
                treeItemById.put(network.getId(), networkItem);
            }
        }
        SystemTreeItemModel templatesItem = new SystemTreeItemModel();
        templatesItem.setType(SystemTreeItemType.Templates);
        templatesItem.setApplicationMode(ApplicationMode.VirtOnly);
        templatesItem.setTitle(ConstantsManager.getInstance().getConstants().templatesTitle());
        templatesItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(templatesItem);
        SystemTreeItemModel clustersItem = new SystemTreeItemModel();
        clustersItem.setType(SystemTreeItemType.Clusters);
        clustersItem.setTitle(ConstantsManager.getInstance().getConstants().clustersTitle());
        clustersItem.setEntity(getDataCenters().get(count));
        dataCenterItem.addChild(clustersItem);
        if (getClusterMap().containsKey(getDataCenters().get(count).getId())) {
            List<VDSGroup> clusters = getClusterMap().get(getDataCenters().get(count).getId());
            Collections.sort(clusters, new Linq.VDSGroupComparator());
            for (VDSGroup cluster : clusters) {
                SystemTreeItemModel clusterItem = new SystemTreeItemModel();
                clusterItem.setType(cluster.supportsGlusterService() ? SystemTreeItemType.Cluster_Gluster : SystemTreeItemType.Cluster);
                clusterItem.setTitle(cluster.getName());
                clusterItem.setEntity(cluster);
                clustersItem.addChild(clusterItem);
                SystemTreeItemModel hostsItem = new SystemTreeItemModel();
                hostsItem.setType(SystemTreeItemType.Hosts);
                hostsItem.setTitle(ConstantsManager.getInstance().getConstants().hostsTitle());
                hostsItem.setEntity(cluster);
                clusterItem.addChild(hostsItem);
                if (getHostMap().containsKey(cluster.getId())) {
                    for (VDS host : getHostMap().get(cluster.getId())) {
                        SystemTreeItemModel hostItem = new SystemTreeItemModel();
                        hostItem.setType(SystemTreeItemType.Host);
                        hostItem.setTitle(host.getName());
                        hostItem.setEntity(host);
                        hostsItem.addChild(hostItem);
                    }
                }
                if (cluster.supportsGlusterService()) {
                    SystemTreeItemModel volumesItem = new SystemTreeItemModel();
                    volumesItem.setType(SystemTreeItemType.Volumes);
                    volumesItem.setApplicationMode(ApplicationMode.GlusterOnly);
                    volumesItem.setTitle(ConstantsManager.getInstance().getConstants().volumesTitle());
                    volumesItem.setEntity(cluster);
                    clusterItem.addChild(volumesItem);
                    if (getVolumeMap().containsKey(cluster.getId())) {
                        for (GlusterVolumeEntity volume : getVolumeMap().get(cluster.getId())) {
                            SystemTreeItemModel volumeItem = new SystemTreeItemModel();
                            volumeItem.setType(SystemTreeItemType.Volume);
                            volumeItem.setApplicationMode(ApplicationMode.GlusterOnly);
                            volumeItem.setTitle(volume.getName());
                            volumeItem.setEntity(volume);
                            volumesItem.addChild(volumeItem);
                        }
                    }
                }
                if (cluster.supportsVirtService()) {
                    SystemTreeItemModel vmsItem = new SystemTreeItemModel();
                    vmsItem.setType(SystemTreeItemType.VMs);
                    vmsItem.setApplicationMode(ApplicationMode.VirtOnly);
                    vmsItem.setTitle(ConstantsManager.getInstance().getConstants().vmsTitle());
                    vmsItem.setEntity(cluster);
                    clusterItem.addChild(vmsItem);
                }
            }
        }
    }
    // Add Providers node under System
    SystemTreeItemModel providersItem = new SystemTreeItemModel();
    providersItem.setType(SystemTreeItemType.Providers);
    providersItem.setApplicationMode(ApplicationMode.VirtOnly);
    providersItem.setTitle(ConstantsManager.getInstance().getConstants().externalProvidersTitle());
    systemItem.addChild(providersItem);
    // Populate with providers
    for (Provider provider : getProviders()) {
        SystemTreeItemModel providerItem = new SystemTreeItemModel();
        providerItem.setType(SystemTreeItemType.Provider);
        providerItem.setApplicationMode(ApplicationMode.VirtOnly);
        providerItem.setTitle(provider.getName());
        providerItem.setEntity(provider);
        providersItem.addChild(providerItem);
        treeItemById.put(provider.getId(), providerItem);
    }
    if (!ApplicationModeHelper.getUiMode().equals(ApplicationMode.AllModes)) {
        ApplicationModeHelper.filterSystemTreeByApplictionMode(systemItem);
    }
    setItems(new ArrayList<SystemTreeItemModel>(Arrays.asList(new SystemTreeItemModel[] { systemItem })));
}
#method_after
@Override
public void executed(FrontendMultipleQueryAsyncResult result) {
    ArrayList<StorageDomain> storages = null;
    int count = -1;
    treeItemById = new HashMap<Guid, SystemTreeItemModel>();
    // Build tree items.
    SystemTreeItemModel systemItem = new SystemTreeItemModel();
    systemItem.setType(SystemTreeItemType.System);
    systemItem.setIsSelected(true);
    systemItem.setTitle(ConstantsManager.getInstance().getConstants().systemTitle());
    // Add Data Centers node under System
    SystemTreeItemModel dataCentersItem = new SystemTreeItemModel();
    dataCentersItem.setType(SystemTreeItemType.DataCenters);
    dataCentersItem.setApplicationMode(ApplicationMode.VirtOnly);
    dataCentersItem.setTitle(ConstantsManager.getInstance().getConstants().dataCentersTitle());
    systemItem.addChild(dataCentersItem);
    // Populate everything under Data Centers
    for (VdcQueryReturnValue returnValue : result.getReturnValues()) {
        ++count;
        if (!returnValue.getSucceeded()) {
            continue;
        }
        storages = (ArrayList<StorageDomain>) returnValue.getReturnValue();
        SystemTreeItemModel dataCenterItem = new SystemTreeItemModel();
        dataCenterItem.setType(SystemTreeItemType.DataCenter);
        dataCenterItem.setApplicationMode(ApplicationMode.VirtOnly);
        StoragePool dataCenter = getDataCenters().get(count);
        dataCenterItem.setTitle(dataCenter.getName());
        dataCenterItem.setEntity(dataCenter);
        dataCentersItem.addChild(dataCenterItem);
        treeItemById.put(dataCenter.getId(), dataCenterItem);
        SystemTreeItemModel storagesItem = new SystemTreeItemModel();
        storagesItem.setType(SystemTreeItemType.Storages);
        storagesItem.setApplicationMode(ApplicationMode.VirtOnly);
        storagesItem.setTitle(ConstantsManager.getInstance().getConstants().storageTitle());
        storagesItem.setEntity(dataCenter);
        dataCenterItem.addChild(storagesItem);
        if (storages != null && storages.size() > 0) {
            // sort by name first
            Collections.sort(storages, new Linq.StorageDomainComparator());
            for (StorageDomain storage : storages) {
                SystemTreeItemModel storageItem = new SystemTreeItemModel();
                storageItem.setType(SystemTreeItemType.Storage);
                storageItem.setApplicationMode(ApplicationMode.VirtOnly);
                storageItem.setTitle(storage.getStorageName());
                storageItem.setEntity(storage);
                storagesItem.addChild(storageItem);
            }
        }
        SystemTreeItemModel networksItem = new SystemTreeItemModel();
        networksItem.setType(SystemTreeItemType.Networks);
        networksItem.setApplicationMode(ApplicationMode.VirtOnly);
        networksItem.setTitle(ConstantsManager.getInstance().getConstants().networksTitle());
        networksItem.setEntity(dataCenter);
        dataCenterItem.addChild(networksItem);
        List<Network> dcNetworks = getNetworkMap().get(dataCenter.getId());
        if (dcNetworks != null) {
            // sort by name first
            Collections.sort(dcNetworks, new Linq.NetworkComparator());
            for (Network network : dcNetworks) {
                SystemTreeItemModel networkItem = new SystemTreeItemModel();
                networkItem.setType(SystemTreeItemType.Network);
                networkItem.setApplicationMode(ApplicationMode.VirtOnly);
                networkItem.setTitle(network.getName());
                networkItem.setEntity(network);
                networksItem.addChild(networkItem);
                treeItemById.put(network.getId(), networkItem);
            }
        }
        SystemTreeItemModel templatesItem = new SystemTreeItemModel();
        templatesItem.setType(SystemTreeItemType.Templates);
        templatesItem.setApplicationMode(ApplicationMode.VirtOnly);
        templatesItem.setTitle(ConstantsManager.getInstance().getConstants().templatesTitle());
        templatesItem.setEntity(dataCenter);
        dataCenterItem.addChild(templatesItem);
        SystemTreeItemModel clustersItem = new SystemTreeItemModel();
        clustersItem.setType(SystemTreeItemType.Clusters);
        clustersItem.setTitle(ConstantsManager.getInstance().getConstants().clustersTitle());
        clustersItem.setEntity(dataCenter);
        dataCenterItem.addChild(clustersItem);
        if (getClusterMap().containsKey(dataCenter.getId())) {
            List<VDSGroup> clusters = getClusterMap().get(dataCenter.getId());
            Collections.sort(clusters, new Linq.VDSGroupComparator());
            for (VDSGroup cluster : clusters) {
                SystemTreeItemModel clusterItem = new SystemTreeItemModel();
                clusterItem.setType(cluster.supportsGlusterService() ? SystemTreeItemType.Cluster_Gluster : SystemTreeItemType.Cluster);
                clusterItem.setTitle(cluster.getName());
                clusterItem.setEntity(cluster);
                clustersItem.addChild(clusterItem);
                SystemTreeItemModel hostsItem = new SystemTreeItemModel();
                hostsItem.setType(SystemTreeItemType.Hosts);
                hostsItem.setTitle(ConstantsManager.getInstance().getConstants().hostsTitle());
                hostsItem.setEntity(cluster);
                clusterItem.addChild(hostsItem);
                if (getHostMap().containsKey(cluster.getId())) {
                    for (VDS host : getHostMap().get(cluster.getId())) {
                        SystemTreeItemModel hostItem = new SystemTreeItemModel();
                        hostItem.setType(SystemTreeItemType.Host);
                        hostItem.setTitle(host.getName());
                        hostItem.setEntity(host);
                        hostsItem.addChild(hostItem);
                    }
                }
                if (cluster.supportsGlusterService()) {
                    SystemTreeItemModel volumesItem = new SystemTreeItemModel();
                    volumesItem.setType(SystemTreeItemType.Volumes);
                    volumesItem.setApplicationMode(ApplicationMode.GlusterOnly);
                    volumesItem.setTitle(ConstantsManager.getInstance().getConstants().volumesTitle());
                    volumesItem.setEntity(cluster);
                    clusterItem.addChild(volumesItem);
                    if (getVolumeMap().containsKey(cluster.getId())) {
                        for (GlusterVolumeEntity volume : getVolumeMap().get(cluster.getId())) {
                            SystemTreeItemModel volumeItem = new SystemTreeItemModel();
                            volumeItem.setType(SystemTreeItemType.Volume);
                            volumeItem.setApplicationMode(ApplicationMode.GlusterOnly);
                            volumeItem.setTitle(volume.getName());
                            volumeItem.setEntity(volume);
                            volumesItem.addChild(volumeItem);
                        }
                    }
                }
                if (cluster.supportsVirtService()) {
                    SystemTreeItemModel vmsItem = new SystemTreeItemModel();
                    vmsItem.setType(SystemTreeItemType.VMs);
                    vmsItem.setApplicationMode(ApplicationMode.VirtOnly);
                    vmsItem.setTitle(ConstantsManager.getInstance().getConstants().vmsTitle());
                    vmsItem.setEntity(cluster);
                    clusterItem.addChild(vmsItem);
                }
            }
        }
    }
    // Add Providers node under System
    SystemTreeItemModel providersItem = new SystemTreeItemModel();
    providersItem.setType(SystemTreeItemType.Providers);
    providersItem.setApplicationMode(ApplicationMode.VirtOnly);
    providersItem.setTitle(ConstantsManager.getInstance().getConstants().externalProvidersTitle());
    systemItem.addChild(providersItem);
    // Populate with providers
    for (Provider provider : getProviders()) {
        SystemTreeItemModel providerItem = new SystemTreeItemModel();
        providerItem.setType(SystemTreeItemType.Provider);
        providerItem.setApplicationMode(ApplicationMode.VirtOnly);
        providerItem.setTitle(provider.getName());
        providerItem.setEntity(provider);
        providersItem.addChild(providerItem);
        treeItemById.put(provider.getId(), providerItem);
    }
    if (!ApplicationModeHelper.getUiMode().equals(ApplicationMode.AllModes)) {
        ApplicationModeHelper.filterSystemTreeByApplictionMode(systemItem);
    }
    setItems(new ArrayList<SystemTreeItemModel>(Arrays.asList(new SystemTreeItemModel[] { systemItem })));
}
#end_block

#method_before
@Override
protected void onReveal() {
    Event entityChangedEvent = getModel().getDiskViewType().getEntityChangedEvent();
    if (!entityChangedEvent.getListeners().contains(getView().getDiskTypeChangedEventListener())) {
        entityChangedEvent.addListener(getView().getDiskTypeChangedEventListener());
    }
    Event systemTreeSelectedItemChangedEvent = CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent();
    if (!systemTreeSelectedItemChangedEvent.getListeners().contains(getView().systemTreeChangedEventListener())) {
        systemTreeSelectedItemChangedEvent.addListener(getView().systemTreeChangedEventListener());
    }
    super.onReveal();
    ((MainTabDiskView) getView()).handleQuotaColumnVisibility();
}
#method_after
@Override
protected void onReveal() {
    Event entityChangedEvent = getModel().getDiskViewType().getEntityChangedEvent();
    if (!entityChangedEvent.getListeners().contains(getView().getDiskTypeChangedEventListener())) {
        entityChangedEvent.addListener(getView().getDiskTypeChangedEventListener());
    }
    Event systemTreeSelectedItemChangedEvent = CommonModel.getInstance().getSystemTree().getSelectedItemChangedEvent();
    systemTreeSelectedItemChangedEvent.addListener(systemTreeListener);
    super.onReveal();
    getView().handleQuotaColumnVisibility();
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setProviderId(getParameters().getProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = Backend.getInstance().runInternalMultipleActions(VdcActionType.InstallVds, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateVdsData();
    if (NeedToUpdateVdsBroker()) {
        initializeVds();
    }
    if (getParameters().getInstallVds()) {
        InstallVdsParameters tempVar = new InstallVdsParameters(getVdsId(), getParameters().getPassword());
        tempVar.setIsReinstallOrUpgrade(getParameters().getIsReinstallOrUpgrade());
        tempVar.setoVirtIsoFile(getParameters().getoVirtIsoFile());
        tempVar.setOverrideFirewall(getParameters().getOverrideFirewall());
        tempVar.setRebootAfterInstallation(getParameters().isRebootAfterInstallation());
        tempVar.setProviderId(getParameters().getProviderId());
        tempVar.setNetworkMappings(getParameters().getNetworkMappings());
        tempVar.setAuthMethod(getParameters().getAuthMethod());
        ArrayList<VdcReturnValueBase> resultList = Backend.getInstance().runInternalMultipleActions(actionType, new ArrayList<VdcActionParametersBase>(Arrays.asList(tempVar)));
        // status, therefore needed to fail the command to revert the status.
        if (!resultList.isEmpty()) {
            VdcReturnValueBase vdcReturnValueBase = resultList.get(0);
            if (vdcReturnValueBase != null && !vdcReturnValueBase.getCanDoAction()) {
                ArrayList<String> canDoActionMessages = vdcReturnValueBase.getCanDoActionMessages();
                if (!canDoActionMessages.isEmpty()) {
                    // add can do action messages to return value so error messages
                    // are returned back to the client
                    getReturnValue().getCanDoActionMessages().addAll(canDoActionMessages);
                    log.errorFormat("Installation/upgrade of Host {0},{1} failed due to: {2} ", getVdsId(), getVdsName(), StringUtils.join(Backend.getInstance().getErrorsTranslator().TranslateErrorText(canDoActionMessages), ","));
                }
                // set can do action to false so can do action messages are
                // returned back to client
                getReturnValue().setCanDoAction(false);
                setSucceeded(false);
                // add old vds dynamic data to compensation context. This
                // way the status will revert back to what it was before
                // starting installation process
                getCompensationContext().snapshotEntityStatus(_oldVds.getDynamicData());
                getCompensationContext().stateChanged();
                return;
            }
        }
    }
    // set clusters network to be operational (if needed)
    if (_oldVds.getStatus() == VDSStatus.Up) {
        List<NetworkCluster> networkClusters = DbFacade.getInstance().getNetworkClusterDao().getAllForCluster(_oldVds.getVdsGroupId());
        List<Network> networks = DbFacade.getInstance().getNetworkDao().getAllForCluster(_oldVds.getVdsGroupId());
        for (NetworkCluster item : networkClusters) {
            for (Network net : networks) {
                if (net.getId().equals(item.getNetworkId())) {
                    NetworkClusterHelper.setStatus(_oldVds.getVdsGroupId(), net);
                }
            }
        }
    }
    AlertIfPowerManagementNotConfigured(getParameters().getVdsStaticData());
    TestVdsPowerManagementStatus(getParameters().getVdsStaticData());
    setSucceeded(true);
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
                filterUnsupportedArchs(clusterModel);
            }
        }

        private void filterUnsupportedArchs(ClusterModel clusterModel) {
            Collection<ArchitectureType> archsWithSupportingCpus = new HashSet<ArchitectureType>();
            archsWithSupportingCpus.add(ArchitectureType.undefined);
            for (ServerCpu cpu : clusterModel.getCPU().getItems()) {
                archsWithSupportingCpus.add(cpu.getArchitecture());
            }
            clusterModel.getArchitecture().setItems(archsWithSupportingCpus);
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#end_block

#method_before
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(ArchitectureType.values())));
        } else {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = (ArchitectureType) clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(ArchitectureType.values())));
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
}
#method_after
private void populateCPUList(ClusterModel clusterModel, List<ServerCpu> cpus, boolean canChangeArchitecture) {
    ServerCpu oldSelectedCpu = clusterModel.getCPU().getSelectedItem();
    clusterModel.getCPU().setItems(cpus);
    initSupportedArchitectures(clusterModel);
    clusterModel.getCPU().setSelectedItem(oldSelectedCpu != null ? Linq.firstOrDefault(cpus, new Linq.ServerCpuPredicate(oldSelectedCpu.getCpuName())) : null);
    if (clusterModel.getCPU().getSelectedItem() == null || !isCPUinitialized) {
        initCPU();
    }
    if (clusterModel.getIsEdit()) {
        if (!canChangeArchitecture) {
            getArchitecture().setItems(new ArrayList<ArchitectureType>(Arrays.asList(clusterModel.getEntity().getArchitecture())));
        }
        ArchitectureType oldSelectedArch = (ArchitectureType) clusterModel.getArchitecture().getSelectedItem();
        if (oldSelectedArch != null) {
            getArchitecture().setSelectedItem(oldSelectedArch);
        } else {
            getArchitecture().setSelectedItem(getEntity().getArchitecture());
        }
    } else {
        getArchitecture().setSelectedItem(ArchitectureType.undefined);
    }
}
#end_block

#method_before
@Override
protected void executeVdsIdCommand() {
    if (_vdsManager == null) {
        getVDSReturnValue().setSucceeded(false);
        return;
    }
    MigrateBrokerVDSCommand<?> command = new MigrateBrokerVDSCommand<>(getParameters());
    command.execute();
    VDSReturnValue vdsReturnValue = command.getVDSReturnValue();
    final VmDynamic vmDynamic = getVmDynamicDAO().get(getParameters().getVmId());
    if (vdsReturnValue.getSucceeded()) {
        vmDynamic.setStatus(VMStatus.MigratingFrom);
        vmDynamic.setMigratingToVds(getParameters().getDstVdsId());
        vmDynamic.setExitStatus(VmExitStatus.Normal);
        vmDynamic.setExitMessage(StringUtils.EMPTY);
        ResourceManager.getInstance().AddAsyncRunningVm(getParameters().getVmId());
        getVDSReturnValue().setReturnValue(VMStatus.MigratingFrom);
    } else {
        log.error("Failed Vm migration");
        getVDSReturnValue().setSucceeded(false);
        getVDSReturnValue().setReturnValue(vmDynamic.getStatus());
        getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
        getVDSReturnValue().setExceptionString(vdsReturnValue.getExceptionString());
        getVDSReturnValue().setExceptionObject(vdsReturnValue.getExceptionObject());
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getVmDynamicDAO().update(vmDynamic);
            return null;
        }
    });
}
#method_after
@Override
protected void executeVdsIdCommand() {
    if (_vdsManager == null) {
        getVDSReturnValue().setSucceeded(false);
        return;
    }
    MigrateBrokerVDSCommand<?> command = new MigrateBrokerVDSCommand<>(getParameters());
    command.execute();
    VDSReturnValue vdsReturnValue = command.getVDSReturnValue();
    final VM vm = getVmDao().get(getParameters().getVmId());
    if (vdsReturnValue.getSucceeded()) {
        ResourceManager.getInstance().InternalSetVmStatus(vm, VMStatus.MigratingFrom);
        vm.setMigratingToVds(getParameters().getDstVdsId());
        ResourceManager.getInstance().AddAsyncRunningVm(getParameters().getVmId());
        getVDSReturnValue().setReturnValue(VMStatus.MigratingFrom);
    } else {
        log.error("Failed Vm migration");
        getVDSReturnValue().setSucceeded(false);
        getVDSReturnValue().setReturnValue(vm.getStatus());
        getVDSReturnValue().setVdsError(vdsReturnValue.getVdsError());
        getVDSReturnValue().setExceptionString(vdsReturnValue.getExceptionString());
        getVDSReturnValue().setExceptionObject(vdsReturnValue.getExceptionObject());
    }
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getVmDynamicDAO().update(vm.getDynamicData());
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null)
            ec.setJob(this.getExecutionContext().getJob());
        super.executeCommand();
        if (ec != null)
            this.setExecutionContext(ec);
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    getReturnValue().setSucceeded(shouldBeFenced);
}
#method_after
@Override
protected void executeCommand() {
    setVds(null);
    if (getVds() == null) {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it doesn't exist anymore.", getVdsName(), getVdsId());
        getReturnValue().setSucceeded(false);
        return;
    }
    VdsValidator validator = new VdsValidator(getVds());
    boolean shouldBeFenced = validator.shouldVdsBeFenced();
    if (shouldBeFenced) {
        getParameters().setParentCommand(VdcActionType.VdsNotRespondingTreatment);
        // Make sure that the StopVdsCommand that runs by the RestartVds
        // don't write over our job, and disrupt marking the job status correctly
        ExecutionContext ec = (ExecutionContext) ObjectUtils.clone(this.getExecutionContext());
        if (ec != null) {
            ec.setJob(this.getExecutionContext().getJob());
            super.executeCommand();
            this.setExecutionContext(ec);
        } else {
            super.executeCommand();
        }
    } else {
        setCommandShouldBeLogged(false);
        log.infoFormat("Host {0}({1}) not fenced since it's status is ok, or it doesn't exist anymore.", getVdsName(), getVdsId());
    }
    getReturnValue().setSucceeded(shouldBeFenced);
}
#end_block

#method_before
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                TemplateListModel templateListModel = (TemplateListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                HashMap<String, ArrayList<String>> templateDic = new HashMap<String, ArrayList<String>>();
                ArrayList<String> verTempMissingBase = new ArrayList<String>();
                // check if relevant templates are already there
                for (Object selectedItem : templateListModel.getSelectedItems()) {
                    VmTemplate template = (VmTemplate) selectedItem;
                    // only relevant for template versions
                    if (!template.isBaseTemplate()) {
                        boolean hasMatch = false;
                        for (VmTemplate a : templatesDiskSet.keySet()) {
                            if (template.getBaseTemplateId().equals(a.getId())) {
                                hasMatch = true;
                                break;
                            }
                        }
                        if (!template.getBaseTemplateId().equals(Guid.Empty) && !hasMatch) {
                            verTempMissingBase.add(template.getName());
                        }
                    }
                }
                templateListModel.postExportGetMissingTemplates(verTempMissingBase);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#method_after
private void postGetTemplatesNotPresentOnExportDomain(StoragePool storagePool) {
    ExportVmModel model = (ExportVmModel) getWindow();
    Guid storageDomainId = ((StorageDomain) model.getStorage().getSelectedItem()).getId();
    if (storagePool != null) {
        AsyncDataProvider.getAllTemplatesFromExportDomain(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                TemplateListModel templateListModel = (TemplateListModel) target;
                HashMap<VmTemplate, ArrayList<DiskImage>> templatesDiskSet = (HashMap<VmTemplate, ArrayList<DiskImage>>) returnValue;
                ArrayList<String> verTempMissingBase = new ArrayList<String>();
                // check if relevant templates are already there
                for (Object selectedItem : templateListModel.getSelectedItems()) {
                    VmTemplate template = (VmTemplate) selectedItem;
                    // only relevant for template versions
                    if (!template.isBaseTemplate()) {
                        boolean hasMatch = false;
                        for (VmTemplate a : templatesDiskSet.keySet()) {
                            if (template.getBaseTemplateId().equals(a.getId())) {
                                hasMatch = true;
                                break;
                            }
                        }
                        if (!template.getBaseTemplateId().equals(Guid.Empty) && !hasMatch) {
                            verTempMissingBase.add(template.getName());
                        }
                    }
                }
                templateListModel.postExportGetMissingTemplates(verTempMissingBase);
            }
        }), storagePool.getId(), storageDomainId);
    }
}
#end_block

#method_before
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
    model.stopProgress();
    for (Object item : getSelectedItems()) {
        VmTemplate a = (VmTemplate) item;
        if (a.getId().equals(Guid.Empty)) {
            continue;
        }
        MoveOrCopyParameters tempVar = new MoveOrCopyParameters(a.getId(), ((StorageDomain) model.getStorage().getSelectedItem()).getId());
        tempVar.setForceOverride((Boolean) model.getForceOverride().getEntity());
        parameters.add(tempVar);
    }
    if ((missingTemplatesFromVms == null || missingTemplatesFromVms.size() > 0)) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().baseTemplatesNotFoundOnExportDomainTitle());
        confirmModel.setHelpTag(HelpTag.base_template_not_found_on_export_domain);
        // $NON-NLS-1$
        confirmModel.setHashName("base_template_not_found_on_export_domain");
        confirmModel.setMessage(missingTemplatesFromVms == null ? ConstantsManager.getInstance().getConstants().couldNotReadTemplatesFromExportDomainMsg() : ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainForTemplateVersionsMsg());
        confirmModel.setItems(missingTemplatesFromVms);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnExportNoTemplates", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else {
        if (model.getProgress() != null) {
            return;
        }
        model.startProgress(null);
        Frontend.getInstance().runMultipleAction(VdcActionType.ExportVmTemplate, parameters, new IFrontendMultipleActionAsyncCallback() {

            @Override
            public void executed(FrontendMultipleActionAsyncResult result) {
                ExportVmModel localModel = (ExportVmModel) result.getState();
                localModel.stopProgress();
                cancel();
            }
        }, model);
    }
}
#method_after
private void postExportGetMissingTemplates(ArrayList<String> missingTemplatesFromVms) {
    ExportVmModel model = (ExportVmModel) getWindow();
    if (!missingTemplatesFromVms.isEmpty()) {
        model.stopProgress();
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().baseTemplatesNotFoundOnExportDomainTitle());
        confirmModel.setHelpTag(HelpTag.base_template_not_found_on_export_domain);
        // $NON-NLS-1$
        confirmModel.setHashName("base_template_not_found_on_export_domain");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().theFollowingTemplatesAreMissingOnTargetExportDomainForTemplateVersionsMsg());
        confirmModel.setItems(missingTemplatesFromVms);
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnExportNoTemplates", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        confirmModel.getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        confirmModel.getCommands().add(tempVar2);
    } else {
        doExport();
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportTemplateTitle());
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        onExportNoTemplates();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getExportCommand()) {
        export(ConstantsManager.getInstance().getConstants().exportTemplateTitle());
    } else if (// $NON-NLS-1$
    "Cancel".equals(command.getName())) {
        cancel();
    } else if (// $NON-NLS-1$
    "OnExport".equals(command.getName())) {
        onExport();
    } else if (// $NON-NLS-1$
    "OnSave".equals(command.getName())) {
        onSave();
    } else if (// $NON-NLS-1$
    "OnRemove".equals(command.getName())) {
        onRemove();
    } else if (// $NON-NLS-1$
    "OnExportNoTemplates".equals(command.getName())) {
        doExport();
    } else if (// $NON-NLS-1$
    "CancelConfirmation".equals(command.getName())) {
        cancelConfirmation();
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                if (storagePool != null) {
                    // so all the domains need to move to "unknown" status as otherwise their status won't change.
                    if (DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, reportingVdsStatus).isEmpty()) {
                        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(_storagePoolId, StoragePoolDomainHelper.storageDomainMonitoredStatus, StorageDomainStatus.Unknown);
                    }
                    if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend) {
                        proceedStoragePoolStats(storagePool);
                    }
                }
            }
        }
    } catch (Exception ex) {
    }
}
#method_after
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                if (storagePool != null) {
                    // so all the domains need to move to "unknown" status as otherwise their status won't change.
                    if (DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, reportingVdsStatus).isEmpty()) {
                        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(_storagePoolId, StoragePoolDomainHelper.storageDomainMonitoredStatus, StorageDomainStatus.Unknown, "no reporting hosts");
                    }
                    if (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend) {
                        proceedStoragePoolStats(storagePool);
                    }
                }
            }
        }
    } catch (Exception ex) {
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = mCurrentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getmaster_domain_version();
        java.util.HashSet<Guid> domainsInVds = new java.util.HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = mCurrentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>getValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getmaster_domain_version();
        HashSet<Guid> domainsInVds = new HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
}
#end_block

#method_before
public java.util.HashSet<Guid> getTriedVdssList() {
    return mTriedVdssList;
}
#method_after
public HashSet<Guid> getTriedVdssList() {
    return mTriedVdssList;
}
#end_block

#method_before
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    _domainsInProblem.put(domainId, new java.util.HashSet<Guid>(java.util.Arrays.asList(vdsId)));
    log.warnFormat("domain {0} in problem. vds: {1}", getDomainIdTuple(domainId), vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFalureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#method_after
private void addDomainInProblemData(Guid domainId, Guid vdsId, String vdsName) {
    _domainsInProblem.put(domainId, new HashSet<Guid>(Arrays.asList(vdsId)));
    log.warnFormat("domain {0} in problem. vds: {1}", getDomainIdTuple(domainId), vdsName);
    Class[] inputType = new Class[] { Guid.class };
    Object[] inputParams = new Object[] { domainId };
    String jobId = SchedulerUtilQuartzImpl.getInstance().scheduleAOneTimeJob(this, "onTimer", inputType, inputParams, Config.<Integer>getValue(ConfigValues.StorageDomainFalureTimeoutInMinutes), TimeUnit.MINUTES);
    clearTimer(domainId);
    _timers.put(domainId, jobId);
}
#end_block

#method_before
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, true, domainId);
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.errorFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#method_after
private EventResult processDomainRecovery(final Guid domainId) {
    EventResult result = null;
    // build a list of all the hosts in status UP in
    // Pool.
    List<Guid> vdssInPool = new ArrayList<Guid>();
    List<VDS> allVds = DbFacade.getInstance().getVdsDao().getAllForStoragePool(_storagePoolId);
    Map<Guid, VDS> vdsMap = new HashMap<Guid, VDS>();
    for (VDS tempVDS : allVds) {
        vdsMap.put(tempVDS.getId(), tempVDS);
        if (tempVDS.getStatus() == VDSStatus.Up) {
            vdssInPool.add(tempVDS.getId());
        }
    }
    // build a list of all the hosts that did not report
    // on this domain as in problem.
    // Mark the above list as hosts we suspect are in
    // problem.
    Set<Guid> hostsThatReportedDomainAsInProblem = _domainsInProblem.get(domainId);
    List<Guid> vdssInProblem = new ArrayList<Guid>();
    for (Guid tempVDSId : vdssInPool) {
        if (!hostsThatReportedDomainAsInProblem.contains(tempVDSId)) {
            vdssInProblem.add(tempVDSId);
        }
    }
    // If not All the hosts in status UP reported on
    // this domain as in problem. We assume the problem
    // is with the hosts
    // that did report on a problem with this domain.
    // (and not a problem with the domain itself).
    StorageDomainStatic storageDomain = DbFacade.getInstance().getStorageDomainStaticDao().get(domainId);
    String domainIdTuple = getDomainIdTuple(domainId);
    List<Guid> nonOpVdss = new ArrayList<Guid>();
    if (vdssInProblem.size() > 0) {
        if (storageDomain.getStorageDomainType() != StorageDomainType.ImportExport && storageDomain.getStorageDomainType() != StorageDomainType.ISO) {
            // operational.
            for (final Guid vdsId : _domainsInProblem.get(domainId)) {
                VDS vds = vdsMap.get(vdsId);
                if (vds == null) {
                    log.warnFormat("vds {0} reported domain {1} - as in problem but cannot find vds in db!!", vdsId, domainIdTuple);
                } else if (vds.getStatus() == VDSStatus.Up) {
                    log.warnFormat("vds {0} reported domain {1} as in problem, attempting to move the vds to status NonOperational", vds.getName(), domainIdTuple);
                    ThreadPoolUtil.execute(new Runnable() {

                        @Override
                        public void run() {
                            ResourceManager.getInstance().getEventListener().vdsNonOperational(vdsId, NonOperationalReason.STORAGE_DOMAIN_UNREACHABLE, true, domainId);
                        }
                    });
                    nonOpVdss.add(vdsId);
                } else {
                    log.warnFormat("vds {0} reported domain {1} as in problem, vds is in status {3}, no need to move to nonoperational", vds.getName(), domainIdTuple, vds.getStatus());
                }
            }
        } else {
            log.warnFormat("Storage domain {0} is not visible to one or more hosts. " + "Since the domain's type is {1}, hosts status will not be changed to non-operational", domainIdTuple, storageDomain.getStorageDomainType());
        }
        result = new EventResult(true, EventType.VDSSTOARGEPROBLEMS);
    } else {
        // Domain.
        if (storageDomain.getStorageDomainType() != StorageDomainType.Master) {
            log.errorFormat("Domain {0} was reported by all hosts in status UP as problematic. Moving the domain to NonOperational.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().storageDomainNotOperational(domainId, _storagePoolId);
        } else {
            log.warnFormat("Domain {0} was reported by all hosts in status UP as problematic. Not moving the domain to NonOperational because it is being reconstructed now.", domainIdTuple);
            result = ResourceManager.getInstance().getEventListener().masterDomainNotOperational(domainId, _storagePoolId, false, false);
        }
    }
    // clear from cache of _domainsInProblem
    clearDomainFromCache(domainId, nonOpVdss);
    return result;
}
#end_block

#method_before
public static void updateApplicablePoolDomainsStatuses(Guid storagePoolId, Set<StorageDomainStatus> applicableStatusesForUpdate, StorageDomainStatus newStatus) {
    List<StoragePoolIsoMap> storagesStatusInPool = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(storagePoolId);
    for (StoragePoolIsoMap storageStatusInPool : storagesStatusInPool) {
        if (storageStatusInPool.getStatus() != null && storageStatusInPool.getStatus() != newStatus && applicableStatusesForUpdate.contains(storageStatusInPool.getStatus())) {
            storageStatusInPool.setStatus(newStatus);
            DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(storageStatusInPool.getId(), storageStatusInPool.getStatus());
        }
    }
}
#method_after
public static void updateApplicablePoolDomainsStatuses(Guid storagePoolId, Set<StorageDomainStatus> applicableStatusesForUpdate, StorageDomainStatus newStatus, String reason) {
    List<StoragePoolIsoMap> storagesStatusInPool = DbFacade.getInstance().getStoragePoolIsoMapDao().getAllForStoragePool(storagePoolId);
    for (StoragePoolIsoMap storageStatusInPool : storagesStatusInPool) {
        if (storageStatusInPool.getStatus() != null && storageStatusInPool.getStatus() != newStatus && applicableStatusesForUpdate.contains(storageStatusInPool.getStatus())) {
            log.infoFormat("Storage Pool {0} - Updating Storage Domain {1} status from {2} to {3}, reason : {4}", storagePoolId, storageStatusInPool.getstorage_id(), storageStatusInPool.getStatus().name(), newStatus.name(), reason);
            storageStatusInPool.setStatus(newStatus);
            DbFacade.getInstance().getStoragePoolIsoMapDao().updateStatus(storageStatusInPool.getId(), storageStatusInPool.getStatus());
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getStoragePool().setStatus(getParameters().getStatus());
    setVdsIdRef(getStoragePool().getspm_vds_id());
    DbFacade.getInstance().getStoragePoolDao().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
    if (getParameters().getStatus() == StoragePoolStatus.NonResponsive || getParameters().getStatus() == StoragePoolStatus.NotOperational) {
        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(getStoragePool().getId(), Collections.singleton(StorageDomainStatus.Active), StorageDomainStatus.Unknown);
    }
    StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getStoragePool().setStatus(getParameters().getStatus());
    setVdsIdRef(getStoragePool().getspm_vds_id());
    DbFacade.getInstance().getStoragePoolDao().updateStatus(getStoragePool().getId(), getStoragePool().getStatus());
    if (getParameters().getStatus() == StoragePoolStatus.NonResponsive || getParameters().getStatus() == StoragePoolStatus.NotOperational) {
        StoragePoolDomainHelper.updateApplicablePoolDomainsStatuses(getStoragePool().getId(), EnumSet.of(StorageDomainStatus.Active), StorageDomainStatus.Unknown, null);
    }
    StoragePoolStatusHandler.poolStatusChanged(getStoragePool().getId(), getStoragePool().getStatus());
    setSucceeded(true);
}
#end_block

#method_before
@OnTimerMethodAnnotation("refreshAllUsers")
public void refreshAllUsers() {
    // We will need the DAO:
    DbUserDAO dao = DbFacade.getInstance().getDbUserDao();
    // Retrieve all the users from the database:
    List<DbUser> dbUsers = dao.getAll();
    List<DbGroup> dbGroups = DbFacade.getInstance().getDbGroupDao().getAll();
    for (DbGroup group : dbGroups) {
        groupsMap.put(group.getExternalId(), group);
    }
    // Classify the users by directory. Note that the resulting map may have an entry with a null key, that
    // corresponds to the users whose directory has been removed from the configuration.
    Map<Directory, List<DbUser>> index = new HashMap<>();
    for (DbUser dbUser : dbUsers) {
        AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(dbUser.getDomain());
        if (profile == null) {
            log.warn(String.format("No profile was found for user %1$s. It is possible that the relevant domain for the user was removed for the user. Marking the user as inactive", dbUser.getLoginName()));
            if (dbUser.isActive()) {
                dbUser.setActive(false);
                dao.update(dbUser);
            }
            continue;
        }
        Directory key = profile.getDirectory();
        List<DbUser> value = index.get(key);
        if (value == null) {
            value = new ArrayList<DbUser>();
            index.put(key, value);
        }
        value.add(dbUser);
    }
    // Refresh the users for each directory:
    List<DbUser> updates = new ArrayList<>();
    for (Map.Entry<Directory, List<DbUser>> entry : index.entrySet()) {
        List<DbUser> refreshed = refreshUsers(entry.getValue(), entry.getKey());
        updates.addAll(refreshed);
    }
    // have support for that yet):
    for (DbUser dbUser : updates) {
        dao.update(dbUser);
    }
}
#method_after
@OnTimerMethodAnnotation("refreshAllUsers")
public void refreshAllUsers() {
    // We will need the DAO:
    DbUserDAO dao = DbFacade.getInstance().getDbUserDao();
    // Retrieve all the users from the database:
    List<DbUser> dbUsers = dao.getAll();
    List<DbGroup> dbGroups = DbFacade.getInstance().getDbGroupDao().getAll();
    for (DbGroup group : dbGroups) {
        groupsMap.put(group.getExternalId(), group);
    }
    // Classify the users by directory. Note that the resulting map may have an entry with a null key, that
    // corresponds to the users whose directory has been removed from the configuration.
    Map<Directory, List<DbUser>> index = new HashMap<>();
    for (DbUser dbUser : dbUsers) {
        AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(dbUser.getDomain());
        if (profile == null) {
            log.warn(String.format("No profile was found for user %1$s. It is possible that the relevant " + "domain for the user was removed for the user. Marking the user as inactive", dbUser.getLoginName()));
            if (dbUser.isActive()) {
                dbUser.setActive(false);
                dao.update(dbUser);
            }
            continue;
        }
        Directory key = profile.getDirectory();
        List<DbUser> value = index.get(key);
        if (value == null) {
            value = new ArrayList<DbUser>();
            index.put(key, value);
        }
        value.add(dbUser);
    }
    // Refresh the users for each directory:
    List<DbUser> updates = new ArrayList<>();
    for (Map.Entry<Directory, List<DbUser>> entry : index.entrySet()) {
        List<DbUser> refreshed = refreshUsers(entry.getValue(), entry.getKey());
        updates.addAll(refreshed);
    }
    // have support for that yet):
    for (DbUser dbUser : updates) {
        dao.update(dbUser);
    }
}
#end_block

#method_before
@Override
public Integer getVmsCountByClusterId(Guid vdsGroupId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_group_id", vdsGroupId);
    return getCallsHandler().executeRead("GetNumberOfVmsInCluster", getIntegerMapper(), parameterSource);
}
#method_after
@Override
public int getVmsCountByClusterId(Guid vdsGroupId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_group_id", vdsGroupId);
    return getCallsHandler().executeRead("GetNumberOfVmsInCluster", getIntegerMapper(), parameterSource);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    Integer numOfVms = getDbFacade().getVdsGroupDao().getVmsCountByClusterId(getParameters().getId());
    getQueryReturnValue().setReturnValue(numOfVms);
}
#method_after
@Override
protected void executeQueryCommand() {
    int numOfVms = getDbFacade().getVdsGroupDao().getVmsCountByClusterId(getParameters().getId());
    getQueryReturnValue().setReturnValue(numOfVms);
}
#end_block

#method_before
public String getNumberOfVms() {
    return Integer.toString(numberOfVms);
}
#method_after
public String getNumberOfVms() {
    // $NON-NLS-1$
    return numberOfVms == null ? "0" : Integer.toString(numberOfVms);
}
#end_block

#method_before
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<String>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#method_after
public static void isSoundcardEnabled(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetSoundDevices, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return ((List<VmDevice>) source).size() > 0;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#method_after
public static void isVirtioScsiEnabledForVm(AsyncQuery aQuery, Guid vmId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null) {
                return !((List<?>) source).isEmpty();
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVirtioScsiControllers, new IdQueryParameters(vmId), aQuery);
}
#end_block

#method_before
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId), aQuery);
}
#method_after
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && ((List) source).size() > 0) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#method_after
public static void isAnyHostUpInCluster(AsyncQuery aQuery, String clusterName) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            if (source != null && !((List<?>) source).isEmpty()) {
                return true;
            }
            return false;
        }
    };
    getUpHostListByCluster(aQuery, clusterName, 1);
}
#end_block

#method_before
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void getClusterListByStorageDomain(AsyncQuery _AsyncQuery, Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(_AsyncQuery, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<StoragePool> pools = (ArrayList<StoragePool>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (pools != null && pools.size() > 0) {
                StoragePool pool = pools.get(0);
                getClusterList((AsyncQuery) model, pool.getId());
            }
        }
    }));
}
#method_after
public static void getClusterListByStorageDomain(AsyncQuery _AsyncQuery, Guid storageDomainId) {
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolsByStorageDomainId, new IdQueryParameters(storageDomainId), new AsyncQuery(_AsyncQuery, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<StoragePool> pools = (List<StoragePool>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (pools != null && !pools.isEmpty()) {
                StoragePool pool = pools.get(0);
                getClusterList((AsyncQuery) model, pool.getId());
            }
        }
    }));
}
#end_block

#method_before
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId), aQuery);
}
#method_after
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#end_block

#method_before
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase(), aQuery);
    }
}
#method_after
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#end_block

#method_before
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            if (siblingVlanInterfaces.size() > 0) {
                return true;
            }
            return false;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#method_after
private static void interfaceHasSiblingVlanInterfaces(Guid vdsID, VdsNetworkInterface iface, AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            ArrayList<VdsNetworkInterface> siblingVlanInterfaces = (ArrayList<VdsNetworkInterface>) source;
            return !siblingVlanInterfaces.isEmpty();
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllSiblingVlanInterfaces, new InterfaceAndIdQueryParameters(vdsID, iface), aQuery);
}
#end_block

#method_before
private void createKerberosLdapAAAConfigurations() {
    for (String domain : Config.<String>getValue(ConfigValues.DomainName).split("[,]", 0)) {
        if (!domain.isEmpty()) {
            Properties authConfig = new Properties();
            authConfig.put(ExtensionsManager.CLASS, "org.ovirt.engine.extensions.aaa.builtin.kerberosldap.KerberosLdapAuthenticator");
            authConfig.put(ExtensionsManager.PROVIDES, "org.ovirt.engine.authentication");
            authConfig.put(ExtensionsManager.ENABLED, "true");
            authConfig.put(ExtensionsManager.MODULE, "org.ovirt.engine.extensions.builtin");
            authConfig.put(ExtensionsManager.NAME, String.format("builtin-authn-%1$s", domain));
            authConfig.put("ovirt.engine.aaa.authn.profile.name", domain);
            authConfig.put("ovirt.engine.aaa.authn.authz.plugin", domain);
            ExtensionsManager.getInstance().load(authConfig);
            Properties dirConfig = new Properties();
            dirConfig.put(ExtensionsManager.CLASS, "org.ovirt.engine.extensions.aaa.builtin.kerberosldap.KerberosLdapDirectory");
            dirConfig.put(ExtensionsManager.PROVIDES, "org.ovirt.engine.authorization");
            dirConfig.put(ExtensionsManager.ENABLED, "true");
            dirConfig.put(ExtensionsManager.MODULE, "org.ovirt.engine.extensions.builtin");
            dirConfig.put(ExtensionsManager.NAME, domain);
            ExtensionsManager.getInstance().load(dirConfig);
        }
    }
}
#method_after
private void createKerberosLdapAAAConfigurations() {
    for (String domain : Config.<String>getValue(ConfigValues.DomainName).split("[,]", 0)) {
        domain = domain.trim();
        if (!domain.isEmpty()) {
            Properties authConfig = new Properties();
            authConfig.put(ExtensionsManager.CLASS, "org.ovirt.engine.extensions.aaa.builtin.kerberosldap.KerberosLdapAuthenticator");
            authConfig.put(ExtensionsManager.PROVIDES, "org.ovirt.engine.authentication");
            authConfig.put(ExtensionsManager.ENABLED, "true");
            authConfig.put(ExtensionsManager.MODULE, "org.ovirt.engine.extensions.builtin");
            authConfig.put(ExtensionsManager.NAME, String.format("builtin-authn-%1$s", domain));
            authConfig.put("ovirt.engine.aaa.authn.profile.name", domain);
            authConfig.put("ovirt.engine.aaa.authn.authz.plugin", domain);
            ExtensionsManager.getInstance().load(authConfig);
            Properties dirConfig = new Properties();
            dirConfig.put(ExtensionsManager.CLASS, "org.ovirt.engine.extensions.aaa.builtin.kerberosldap.KerberosLdapDirectory");
            dirConfig.put(ExtensionsManager.PROVIDES, "org.ovirt.engine.authorization");
            dirConfig.put(ExtensionsManager.ENABLED, "true");
            dirConfig.put(ExtensionsManager.MODULE, "org.ovirt.engine.extensions.builtin");
            dirConfig.put(ExtensionsManager.NAME, domain);
            ExtensionsManager.getInstance().load(dirConfig);
        }
    }
}
#end_block

#method_before
private void storeExecutionParameters() {
    // Store defaults in meta-data and user-data that apply regardless
    // of parameters passed in from the user.
    // New instance id required for cloud-init to process data on startup
    metaData.put("uuid", UUID.randomUUID().toString());
    Map<String, String> meta = new HashMap<String, String>();
    // Local allows us to set up networking
    meta.put("dsmode", "local");
    meta.put("essential", "false");
    meta.put("role", "server");
    metaData.put("meta", meta);
    metaData.put("launch_index", "0");
    metaData.put("availability_zone", "nova");
    // Don't create ec2-user
    userData.put("user", "root");
    // Redirect log output from cloud-init execution from terminal
    Map<String, String> output = new HashMap<String, String>();
    output.put("all", ">> /var/log/cloud-init-output.log");
    userData.put("output", output);
    List<String> bootcmd = new ArrayList<String>();
    // set disable_root=0 for enabling root ssh login and
    // datasource_list in cloud.cfg
    bootcmd.add("sed -i '/^disable_root: /d' /etc/cloud/cloud.cfg");
    bootcmd.add("echo 'disable_root: 0' >> /etc/cloud/cloud.cfg");
    bootcmd.add("sed -i '/^datasource_list: /d' /etc/cloud/cloud.cfg");
    bootcmd.add("echo 'datasource_list: [\"NoCloud\", \"ConfigDrive\"]' >> /etc/cloud/cloud.cfg");
    userData.put("bootcmd", bootcmd);
    Map<String, Object> opts = new HashMap<String, Object>();
    opts.put("expire", false);
    userData.put("chpasswd", opts);
    userData.put("ssh_pwauth", true);
}
#method_after
private void storeExecutionParameters() {
    // Store defaults in meta-data and user-data that apply regardless
    // of parameters passed in from the user.
    // New instance id required for cloud-init to process data on startup
    metaData.put("uuid", UUID.randomUUID().toString());
    Map<String, String> meta = new HashMap<String, String>();
    // Local allows us to set up networking
    meta.put("dsmode", "local");
    meta.put("essential", "false");
    meta.put("role", "server");
    metaData.put("meta", meta);
    metaData.put("launch_index", "0");
    metaData.put("availability_zone", "nova");
    // Don't create ec2-user
    userData.put("user", "root");
    userData.put("disable_root", 0);
    // Redirect log output from cloud-init execution from terminal
    Map<String, String> output = new HashMap<String, String>();
    output.put("all", ">> /var/log/cloud-init-output.log");
    userData.put("output", output);
    // Disable metadata-server-based datasources to prevent long boot times
    List<String> runcmd = new ArrayList<String>();
    runcmd.add("sed -i '/^datasource_list: /d' /etc/cloud/cloud.cfg; echo 'datasource_list: [\"NoCloud\", \"ConfigDrive\"]' >> /etc/cloud/cloud.cfg");
    userData.put("runcmd", runcmd);
    Map<String, Object> opts = new HashMap<String, Object>();
    opts.put("expire", false);
    userData.put("chpasswd", opts);
    userData.put("ssh_pwauth", true);
}
#end_block

#method_before
private String mapToJson(Map<String, Object> input) throws IOException, JsonGenerationException, JsonMappingException {
    ObjectMapper mapper = new ObjectMapper();
    JsonFactory factory = new JsonFactory();
    StringWriter writer = new StringWriter();
    JsonGenerator generator = factory.createJsonGenerator(writer);
    generator.useDefaultPrettyPrinter();
    mapper.writeValue(generator, input);
    return writer.toString();
}
#method_after
private String mapToJson(Map<String, Object> input) throws IOException {
    return JsonHelper.mapToJson(input);
}
#end_block

#method_before
public void install() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    model.getUserPassword().setIsAvailable(true);
    model.getUserPassword().setIsChangable(true);
    Version v3 = new Version(3, 0);
    boolean isLessThan3 = host.getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
    if (!isLessThan3) {
        model.getOverrideIpTables().setIsAvailable(true);
        model.getOverrideIpTables().setEntity(true);
    }
    addInstallCommands(model, host, false);
    getWindow().stopProgress();
}
#method_after
public void install() {
    final VDS host = (VDS) getSelectedItem();
    if (host.getVdsType() == VDSType.oVirtNode) {
        host.setSshUsername(HostModel.AdminUserName);
    }
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    model.getUserPassword().setIsAvailable(true);
    model.getUserPassword().setIsChangable(true);
    Version v3 = new Version(3, 0);
    boolean isLessThan3 = host.getVdsGroupCompatibilityVersion().compareTo(v3) < 0;
    if (!isLessThan3) {
        model.getOverrideIpTables().setIsAvailable(true);
        model.getOverrideIpTables().setEntity(true);
    }
    addInstallCommands(model, host, false);
    getWindow().stopProgress();
}
#end_block

#method_before
public void onInstall() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.UpdateVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#method_after
public void onInstall() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.InstallVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#end_block

#method_before
public void upgrade() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            InstallModel model = (InstallModel) target;
            ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
            Collections.sort(isos, new Comparator<RpmVersion>() {

                @Override
                public int compare(RpmVersion rpmV1, RpmVersion rpmV2) {
                    return RpmVersionUtils.compareRpmParts(rpmV2.getRpmName(), rpmV1.getRpmName());
                }
            });
            model.getOVirtISO().setItems(isos);
            model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
            model.getOVirtISO().setIsAvailable(true);
            model.getOVirtISO().setIsChangable(!isos.isEmpty());
            model.getHostVersion().setIsAvailable(true);
            if (isos.isEmpty()) {
                model.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
            }
            addUpgradeCommands(model, host, isos.isEmpty());
            getWindow().stopProgress();
        }
    }), host.getId());
}
#method_after
public void upgrade() {
    final VDS host = (VDS) getSelectedItem();
    host.setSshUsername(HostModel.AdminUserName);
    InstallModel model = new InstallModel();
    model.setVds(host);
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().installHostTitle());
    model.setHelpTag(HelpTag.install_host);
    // $NON-NLS-1$
    model.setHashName("install_host");
    model.getOVirtISO().setIsAvailable(false);
    model.getOverrideIpTables().setIsAvailable(false);
    model.getHostVersion().setEntity(host.getHostOs());
    model.getHostVersion().setIsAvailable(false);
    getWindow().startProgress(null);
    AsyncDataProvider.getoVirtISOsList(new AsyncQuery(model, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            InstallModel model = (InstallModel) target;
            ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
            Collections.sort(isos, new Comparator<RpmVersion>() {

                @Override
                public int compare(RpmVersion rpmV1, RpmVersion rpmV2) {
                    return RpmVersionUtils.compareRpmParts(rpmV2.getRpmName(), rpmV1.getRpmName());
                }
            });
            model.getOVirtISO().setItems(isos);
            model.getOVirtISO().setSelectedItem(Linq.firstOrDefault(isos));
            model.getOVirtISO().setIsAvailable(true);
            model.getOVirtISO().setIsChangable(!isos.isEmpty());
            model.getHostVersion().setIsAvailable(true);
            if (isos.isEmpty()) {
                model.setMessage(ConstantsManager.getInstance().getConstants().thereAreNoISOversionsVompatibleWithHostCurrentVerMsg());
            }
            addUpgradeCommands(model, host, isos.isEmpty());
            getWindow().stopProgress();
        }
    }), host.getId());
}
#end_block

#method_before
public void onUpgrade() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = host.getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? ((RpmVersion) model.getOVirtISO().getSelectedItem()).getRpmName() : null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.UpdateOvirtNode, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#method_after
public void onUpgrade() {
    final VDS host = (VDS) getSelectedItem();
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = host.getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(host);
    param.setVdsId(host.getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? ((RpmVersion) model.getOVirtISO().getSelectedItem()).getRpmName() : null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.getInstance().runAction(VdcActionType.UpgradeOvirtNode, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), host.getVdsGroupId());
}
#end_block

#method_before
private void changeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                _attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images));
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void changeCD() {
    final VM vm = (VM) getSelectedItem();
    if (vm == null) {
        return;
    }
    AttachCdModel model = new AttachCdModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().changeCDTitle());
    model.setHelpTag(HelpTag.change_cd);
    // $NON-NLS-1$
    model.setHashName("change_cd");
    AttachCdModel attachCdModel = (AttachCdModel) getWindow();
    ArrayList<String> images1 = new ArrayList<String>(Arrays.asList(new String[] { ConstantsManager.getInstance().getConstants().noCds() }));
    attachCdModel.getIsoImage().setItems(images1);
    attachCdModel.getIsoImage().setSelectedItem(Linq.firstOrDefault(images1));
    AsyncQuery getIrsImageListCallback = new AsyncQuery();
    getIrsImageListCallback.setModel(this);
    getIrsImageListCallback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            VmListModel vmListModel2 = (VmListModel) model;
            AttachCdModel _attachCdModel = (AttachCdModel) vmListModel2.getWindow();
            ArrayList<String> images = (ArrayList<String>) result;
            images.add(0, ConsoleModel.getEjectLabel());
            _attachCdModel.getIsoImage().setItems(images);
            if (_attachCdModel.getIsoImage().getIsChangable()) {
                String selectedIso = Linq.firstOrDefault(images, new Linq.IPredicate<String>() {

                    @Override
                    public boolean match(String s) {
                        return vm.getCurrentCd().equals(s);
                    }
                });
                _attachCdModel.getIsoImage().setSelectedItem(selectedIso == null ? ConsoleModel.getEjectLabel() : selectedIso);
            }
        }
    };
    AsyncDataProvider.getIrsImageList(getIrsImageListCallback, vm.getStoragePoolId());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnChangeCD", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem().toString(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem().toString();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onChangeCD() {
    VM vm = (VM) getSelectedItem();
    if (vm == null) {
        cancel();
        return;
    }
    AttachCdModel model = (AttachCdModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    String isoName = // $NON-NLS-1$
    (ObjectUtils.objectsEqual(model.getIsoImage().getSelectedItem(), ConsoleModel.getEjectLabel())) ? // $NON-NLS-1$
    "" : model.getIsoImage().getSelectedItem();
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.ChangeDisk, new ChangeDiskCommandParameters(vm.getId(), isoName), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            AttachCdModel attachCdModel = (AttachCdModel) result.getState();
            attachCdModel.stopProgress();
            cancel();
        }
    }, model);
}
#end_block

#method_before
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                // do nothing
                }

                @Override
                public void queryFailed() {
                // do nothing
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        getWindow().stopProgress();
                        setWindow(null);
                        setGuideContext(returnValue.getActionReturnValue());
                        updateActionAvailability();
                        getGuideCommand().execute();
                    }
                    super.executed(result);
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VM vm = getcurrentVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase params = new VmManagementParametersBase(vm);
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        Guid newClusterID = model.getSelectedCluster().getId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    // Save changes.
    buildVmOnSave(model, getcurrentVm());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    getcurrentVm().setCpuPinning(model.getCpuPinning().getEntity());
    if (model.getCpuSharesAmount().getIsAvailable() && model.getCpuSharesAmount().getEntity() != null) {
        // $NON-NLS-1$
        getcurrentVm().setCpuShares(model.getCpuSharesAmount().getEntity());
    }
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setVmInit(model.getVmInitModel().buildCloudInitParameters(model));
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                // do nothing
                }

                @Override
                public void queryFailed() {
                // do nothing
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.getInstance().runAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager) {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    getWindow().stopProgress();
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        setWindow(null);
                        setGuideContext(returnValue.getActionReturnValue());
                        updateActionAvailability();
                        getGuideCommand().execute();
                    } else {
                        cancel();
                    }
                    super.executed(result);
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if (model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(unitVmModel.getTemplate().getSelectedItem().getTemplateVersionName()));
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vm, unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, getcurrentVm().getVmtGuid());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VM vm = getcurrentVm();
                vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                VmManagementParametersBase params = new VmManagementParametersBase(vm);
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions(model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.getInstance().runAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        Guid newClusterID = model.getSelectedCluster().getId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.getInstance().runAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VM vm = vmListModel.getcurrentVm();
                        vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vm.getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VM vm = getcurrentVm();
            vm.setUseLatestVersion(constants.latestTemplateVersionName().equals(model.getTemplate().getSelectedItem().getTemplateVersionName()));
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vm);
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled(model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
            Frontend.getInstance().runAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#end_block

#method_before
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, new IdQueryParameters(dataCenterId).withoutRefresh(), aQuery);
}
#method_after
public static void getDataCenterById(AsyncQuery aQuery, Guid dataCenterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    IdQueryParameters params = new IdQueryParameters(dataCenterId);
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetStoragePoolById, params, aQuery);
}
#end_block

#method_before
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, new VdcQueryParametersBase().withoutRefresh(), aQuery);
}
#method_after
public static void getCustomPropertiesList(AsyncQuery aQuery) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            Map<Version, String> map = source != null ? (HashMap<Version, String>) source : new HashMap<Version, String>();
            Map<Version, ArrayList<String>> retMap = new HashMap<Version, ArrayList<String>>();
            for (Map.Entry<Version, String> keyValuePair : map.entrySet()) {
                // $NON-NLS-1$
                String[] split = keyValuePair.getValue().split("[;]", -1);
                if (split.length == 1 && (split[0] == null || split[0].isEmpty())) {
                    retMap.put(keyValuePair.getKey(), null);
                } else {
                    retMap.put(keyValuePair.getKey(), new ArrayList<String>());
                    for (String s : split) {
                        retMap.get(keyValuePair.getKey()).add(s);
                    }
                }
            }
            return retMap;
        }
    };
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmCustomProperties, params, aQuery);
}
#end_block

#method_before
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, new IdQueryParameters(snapshotSourceId).withoutRefresh(), aQuery);
}
#method_after
public static void getVmConfigurationBySnapshot(AsyncQuery aQuery, Guid snapshotSourceId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source != null ? (VM) source : null;
        }
    };
    IdQueryParameters params = new IdQueryParameters(snapshotSourceId);
    params.setRefresh(false);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmConfigurationBySnapshot, params, aQuery);
}
#end_block

#method_before
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, new VdcQueryParametersBase().withoutRefresh(), aQuery);
    }
}
#method_after
public static void isCommandCompatible(AsyncQuery aQuery, final VdcActionType vdcActionType, final Version cluster, final Version dc) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            cachedCommandsCompatibilityVersions = (HashMap<VdcActionType, CommandVersionsInfo>) source;
            return isCommandCompatible(vdcActionType, cluster, dc);
        }
    };
    if (cachedCommandsCompatibilityVersions != null) {
        aQuery.asyncCallback.onSuccess(aQuery.getModel(), isCommandCompatible(vdcActionType, cluster, dc));
    } else {
        VdcQueryParametersBase params = new VdcQueryParametersBase();
        params.setRefresh(false);
        Frontend.getInstance().runQuery(VdcQueryType.GetCommandsCompatibilityVersions, params, aQuery);
    }
}
#end_block

#method_before
private static void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    String message = null;
    String resolvedMessage = null;
    AuditLogSeverity severity = logType.getSeverity();
    if (severity == null) {
        severity = AuditLogSeverity.NORMAL;
        log.infoFormat("No severity for {0} audit log type, assuming Normal severity", logType);
    }
    AuditLog auditLog = null;
    // handle external log messages invoked by plugins via the API
    if (auditLogable.isExternal()) {
        // message is sent as an argument, no need to resolve.
        resolvedMessage = message = loggerString;
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserId() != null ? getDbFacadeInstance().getDbUserDao().get(auditLogable.getUserId()).getLoginName() : null, auditLogable.getVmIdRef(), auditLogable.getVmIdRef() != null ? getDbFacadeInstance().getVmDao().get(auditLogable.getVmIdRef()).getName() : null, auditLogable.getVdsIdRef(), auditLogable.getVdsIdRef() != null ? getDbFacadeInstance().getVdsDao().get(auditLogable.getVdsIdRef()).getName() : null, auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateIdRef() != null ? getDbFacadeInstance().getVmTemplateDao().get(auditLogable.getVmTemplateIdRef()).getName() : null, auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
    } else if ((message = messages.get(logType)) != null) {
        // Application log message from AuditLogMessages
        resolvedMessage = resolveMessage(message, auditLogable);
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
    }
    if (auditLog != null) {
        auditLog.setstorage_domain_id(auditLogable.getStorageDomainId());
        auditLog.setstorage_domain_name(auditLogable.getStorageDomainName());
        auditLog.setstorage_pool_id(auditLogable.getStoragePoolId());
        auditLog.setstorage_pool_name(auditLogable.getStoragePoolName());
        auditLog.setvds_group_id(auditLogable.getVdsGroupId());
        auditLog.setvds_group_name(auditLogable.getVdsGroupName());
        auditLog.setCorrelationId(auditLogable.getCorrelationId());
        auditLog.setJobId(auditLogable.getJobId());
        auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
        auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
        auditLog.setExternal(auditLogable.isExternal());
        auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
        auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
        auditLog.setCallStack(auditLogable.getCallStack());
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        String logMessage;
        if (!"".equals(loggerString)) {
            logMessage = log.transform(loggerString, resolvedMessage);
        } else {
            logMessage = auditLog.toStringForLogging();
        }
        switch(severity) {
            case NORMAL:
            case ALERT:
                log.info(logMessage);
                break;
            case ERROR:
                log.error(logMessage);
                break;
            case WARNING:
                log.warn(logMessage);
                break;
        }
    }
}
#method_after
private static void saveToDb(AuditLogableBase auditLogable, AuditLogType logType, String loggerString) {
    String message = null;
    String resolvedMessage = null;
    AuditLogSeverity severity = logType.getSeverity();
    if (severity == null) {
        severity = AuditLogSeverity.NORMAL;
        log.infoFormat("No severity for {0} audit log type, assuming Normal severity", logType);
    }
    AuditLog auditLog = null;
    // handle external log messages invoked by plugins via the API
    if (auditLogable.isExternal()) {
        // message is sent as an argument, no need to resolve.
        resolvedMessage = message = loggerString;
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserId() != null ? getDbFacadeInstance().getDbUserDao().get(auditLogable.getUserId()).getLoginName() : null, auditLogable.getVmIdRef(), auditLogable.getVmIdRef() != null ? getDbFacadeInstance().getVmDao().get(auditLogable.getVmIdRef()).getName() : null, auditLogable.getVdsIdRef(), auditLogable.getVdsIdRef() != null ? getDbFacadeInstance().getVdsDao().get(auditLogable.getVdsIdRef()).getName() : null, auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateIdRef() != null ? getDbFacadeInstance().getVmTemplateDao().get(auditLogable.getVmTemplateIdRef()).getName() : null, auditLogable.getOrigin(), auditLogable.getCustomEventId(), auditLogable.getEventFloodInSec(), auditLogable.getCustomData());
    } else if ((message = messages.get(logType)) != null) {
        // Application log message from AuditLogMessages
        resolvedMessage = resolveMessage(message, auditLogable);
        auditLog = new AuditLog(logType, severity, resolvedMessage, auditLogable.getUserId(), auditLogable.getUserName(), auditLogable.getVmIdRef(), auditLogable.getVmName(), auditLogable.getVdsIdRef(), auditLogable.getVdsName(), auditLogable.getVmTemplateIdRef(), auditLogable.getVmTemplateName());
    }
    if (auditLog != null) {
        auditLog.setstorage_domain_id(auditLogable.getStorageDomainId());
        auditLog.setstorage_domain_name(auditLogable.getStorageDomainName());
        auditLog.setstorage_pool_id(auditLogable.getStoragePoolId());
        auditLog.setstorage_pool_name(auditLogable.getStoragePoolName());
        auditLog.setvds_group_id(auditLogable.getVdsGroupId());
        auditLog.setvds_group_name(auditLogable.getVdsGroupName());
        auditLog.setCorrelationId(auditLogable.getCorrelationId());
        auditLog.setJobId(auditLogable.getJobId());
        auditLog.setGlusterVolumeId(auditLogable.getGlusterVolumeId());
        auditLog.setGlusterVolumeName(auditLogable.getGlusterVolumeName());
        auditLog.setExternal(auditLogable.isExternal());
        auditLog.setQuotaId(auditLogable.getQuotaIdForLog());
        auditLog.setQuotaName(auditLogable.getQuotaNameForLog());
        auditLog.setCallStack(auditLogable.getCallStack());
        getDbFacadeInstance().getAuditLogDao().save(auditLog);
        String logMessage;
        if (!"".equals(loggerString)) {
            logMessage = log.transform(loggerString, resolvedMessage);
        } else {
            logMessage = auditLog.toStringForLogging();
        }
        switch(severity) {
            case NORMAL:
                log.info(logMessage);
                break;
            case ERROR:
                log.error(logMessage);
                break;
            case ALERT:
            case WARNING:
                log.warn(logMessage);
                break;
        }
    }
}
#end_block

#method_before
@Override
public void updateOvfGenerations(List<Guid> ids, List<Long> values, List<String> ovfData) {
    getCallsHandler().executeModification("UpdateOvfGenerations", getCustomMapSqlParameterSource().addValue("vms_ids", StringUtils.join(ids, ',')).addValue("vms_db_generations", StringUtils.join(values, ',')).addValue("ovf_data", StringUtils.join(ovfData, "ENDOVF")).addValue("ovf_data_seperator", "ENDOVF"));
}
#method_after
@Override
public void updateOvfGenerations(List<Guid> ids, List<Long> values, List<String> ovfData) {
    getCallsHandler().executeModification("UpdateOvfGenerations", getCustomMapSqlParameterSource().addValue("vms_ids", StringUtils.join(ids, ',')).addValue("vms_db_generations", StringUtils.join(values, ',')).addValue("ovf_data", StringUtils.join(ovfData, ovfSeparator)).addValue("ovf_data_seperator", ovfSeparator));
}
#end_block

#method_before
@Override
public List<Pair<Guid, String>> loadOvfDataForIds(List<Guid> ids) {
    return getCallsHandler().executeReadList("LoadOvfDataForIds", new RowMapper<Pair<Guid, String>>() {

        @Override
        public Pair<Guid, String> mapRow(ResultSet resultSet, int i) throws SQLException {
            return new Pair<>(getGuid(resultSet, "vm_guid"), resultSet.getString("ovf_data"));
        }
    }, getCustomMapSqlParameterSource().addValue("ids", StringUtils.join(ids, ',')));
}
#method_after
@Override
public List<Pair<Guid, String>> loadOvfDataForIds(List<Guid> ids) {
    return getCallsHandler().executeReadList("LoadOvfDataForIds", ovfDataRowMapper, getCustomMapSqlParameterSource().addValue("ids", StringUtils.join(ids, ',')));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    if (isDiskUsedAsOvfStore(disk)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(getSnapshotsValidator().snapshotExists(getSnapshot())) || !validate(getSnapshotsValidator().snapshotTypeSupported(getSnapshot(), Collections.singletonList(SnapshotType.REGULAR))))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
            return false;
        }
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return canPerformDiskHotPlug(disk);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!checkDiskUsedAsOvfStore(diskValidator)) {
        return false;
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(getSnapshotsValidator().snapshotExists(getSnapshot())) || !validate(getSnapshotsValidator().snapshotTypeSupported(getSnapshot(), Collections.singletonList(SnapshotType.REGULAR))))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
            return false;
        }
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return canPerformDiskHotPlug(disk);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && isImageNotLocked() && !isDiskUsedAsOvfStore() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration() && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#method_after
@Override
protected boolean canDoAction() {
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && isImageNotLocked() && isDiskUsedAsOvfStore() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration() && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#end_block

#method_before
protected boolean isDiskUsedAsOvfStore() {
    if (getImage().isOvfStore()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OVF_DISK_NOT_SUPPORTED);
        return true;
    }
    return false;
}
#method_after
protected boolean isDiskUsedAsOvfStore() {
    return validate(new DiskValidator(getImage()).isDiskUsedAsOvfStore());
}
#end_block

#method_before
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = getDiskImage();
    if (diskImage.isOvfStore() && diskImage.getImageStatus() != ImageStatus.ILLEGAL) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_OVF_DISK_NOT_IN_APPLICABLE_STATUS);
    }
    if (diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType()) {
        // Temporary fix until re factoring vm_images_view and image_storage_domain_view
        diskImage.setStorageIds(getDiskImageDao().get(diskImage.getImageId()).getStorageIds());
    } else if ((getParameters().getStorageDomainId() == null) || (Guid.Empty.equals(getParameters().getStorageDomainId()))) {
        getParameters().setStorageDomainId(diskImage.getStorageIds().get(0));
        setStorageDomainId(diskImage.getStorageIds().get(0));
    }
    if (!diskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
    if (retValue && diskImage.getImageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue && getDisk().getVmEntityType() != null) {
        if (getDisk().getVmEntityType().isVmType()) {
            retValue = canRemoveVmImageDisk();
        } else if (getDisk().getVmEntityType().isTemplateType()) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#method_after
private boolean canRemoveDiskBasedOnImageStorageCheck() {
    boolean retValue = true;
    DiskImage diskImage = getDiskImage();
    DiskImagesValidator diskImagesValidator = new DiskImagesValidator(Collections.singletonList(diskImage));
    if (diskImage.isOvfStore() && !validate(diskImagesValidator.disksInStatus(ImageStatus.ILLEGAL))) {
        return false;
    }
    if (diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType()) {
        // Temporary fix until re factoring vm_images_view and image_storage_domain_view
        diskImage.setStorageIds(getDiskImageDao().get(diskImage.getImageId()).getStorageIds());
    } else if ((getParameters().getStorageDomainId() == null) || (Guid.Empty.equals(getParameters().getStorageDomainId()))) {
        getParameters().setStorageDomainId(diskImage.getStorageIds().get(0));
        setStorageDomainId(diskImage.getStorageIds().get(0));
    }
    if (!diskImage.getStorageIds().contains(getParameters().getStorageDomainId())) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_IS_WRONG);
    }
    StorageDomainValidator validator = new StorageDomainValidator(getStorageDomain());
    retValue = retValue && validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
    if (retValue && diskImage.getImageStatus() == ImageStatus.LOCKED) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED);
    }
    if (retValue && getDisk().getVmEntityType() != null) {
        if (getDisk().getVmEntityType().isVmType()) {
            retValue = canRemoveVmImageDisk();
        } else if (getDisk().getVmEntityType().isTemplateType()) {
            retValue = canRemoveTemplateDisk();
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (isDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && shouldUpdatePropertiesOtherThanSize()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE.equals(getOldDisk().getDiskStorageType()) && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm()));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!checkDiskUsedAsOvfStore(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && shouldUpdatePropertiesOtherThanSize()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE.equals(getOldDisk().getDiskStorageType()) && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    updateOvfStoreContent();
    int missingDiskCount = Config.<Integer>getValue(ConfigValues.StorageDomainOvfStoreCount) - ovfDiskCount;
    if (missingDiskCount > 0) {
        Backend.getInstance().runInternalAction(VdcActionType.CreateOvfStoresForStorageDomain, new CreateOvfStoresForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), missingDiskCount));
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    updateOvfStoreContent();
    int missingDiskCount = Config.<Integer>getValue(ConfigValues.StorageDomainOvfStoreCount) - ovfDiskCount;
    if (missingDiskCount > 0) {
        getBackend().runInternalAction(VdcActionType.CreateOvfStoresForStorageDomain, new CreateOvfStoresForStorageDomainCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), missingDiskCount));
    }
    setSucceeded(true);
}
#end_block

#method_before
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId());
}
#method_after
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && !SimpleDependecyInjector.getInstance().get(OsRepository.class).isWindows(getVmOsId());
}
#end_block

#method_before
protected void updateCurrentCd(String cdPath) {
    VmHandler.updateCurrentCd(getVm(), cdPath);
}
#method_after
protected void updateCurrentCd(String cdPath) {
    VmHandler.updateCurrentCd(getVdsId(), getVm(), cdPath);
}
#end_block

#method_before
@Override
protected void perform() {
    setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ChangeDisk, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), cdImagePath)).getReturnValue());
    VmHandler.updateCurrentCd(getVm(), getParameters().getCdImagePath());
    setSucceeded(true);
}
#method_after
@Override
protected void perform() {
    setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.ChangeDisk, new ChangeDiskVDSCommandParameters(getVdsId(), getVm().getId(), cdImagePath)).getReturnValue());
    VmHandler.updateCurrentCd(getVdsId(), getVm(), getParameters().getCdImagePath());
    setSucceeded(true);
}
#end_block

#method_before
public static void updateCurrentCd(VM vm, String currentCd) {
    VmDynamicDAO vmDynamicDao = DbFacade.getInstance().getVmDynamicDao();
    VmDynamic vmDynamic = vm.getDynamicData();
    vmDynamic.setCurrentCd(currentCd);
    vmDynamicDao.update(vmDynamic);
}
#method_after
public static void updateCurrentCd(Guid vdsId, VM vm, String currentCd) {
    VmDynamic vmDynamic = vm.getDynamicData();
    vmDynamic.setCurrentCd(currentCd);
    Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(vdsId, vmDynamic));
}
#end_block

#method_before
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    CpuTune cpuTune = new CpuTune();
    VCpuPin pin = new VCpuPin();
    pin.setVcpu(33);
    pin.setCpuSet("1-4,6");
    cpuTune.getVCpuPin().add(pin);
    from.getCpu().setCpuTune(cpuTune);
    from.setTimezone("Australia/Darwin");
    from.setPlacementPolicy(new VmPlacementPolicy());
    from.getPlacementPolicy().setHost(new Host());
    from.getPlacementPolicy().getHost().setId(Guid.Empty.toString());
    for (GuestNicConfiguration guestNic : from.getInitialization().getNicConfigurations().getNicConfigurations()) {
        guestNic.setBootProtocol(MappingTestHelper.shuffle(BootProtocol.class).value());
    }
    return from;
}
#method_after
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    CpuTune cpuTune = new CpuTune();
    VCpuPin pin = new VCpuPin();
    pin.setVcpu(33);
    pin.setCpuSet("1-4,6");
    cpuTune.getVCpuPin().add(pin);
    from.getCpu().setCpuTune(cpuTune);
    from.setTimezone("Australia/Darwin");
    from.setPlacementPolicy(new VmPlacementPolicy());
    from.getPlacementPolicy().setHost(new Host());
    from.getPlacementPolicy().getHost().setId(Guid.Empty.toString());
    for (GuestNicConfiguration guestNic : from.getInitialization().getNicConfigurations().getNicConfigurations()) {
        guestNic.setBootProtocol(MappingTestHelper.shuffle(BootProtocol.class).value());
    }
    from.getSerialNumber().setPolicy(SerialNumberPolicy.CUSTOM.value());
    return from;
}
#end_block

#method_before
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isSingleQxlPci(), transform.getDisplay().isSingleQxlPci());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.getDisplay().getKeyboardLayout(), transform.getDisplay().getKeyboardLayout());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.getMigrationDowntime(), transform.getMigrationDowntime());
}
#method_after
@Override
protected void verify(VM model, VM transform) {
    assertNotNull(transform);
    assertEquals(model.getName(), transform.getName());
    assertEquals(model.getId(), transform.getId());
    assertEquals(model.getDescription(), transform.getDescription());
    assertEquals(model.getComment(), transform.getComment());
    assertEquals(model.getType(), transform.getType());
    assertEquals(model.getOrigin(), transform.getOrigin());
    assertTrue(Math.abs(model.getMemory() - transform.getMemory()) <= (1024 * 1024));
    assertNotNull(transform.getTemplate());
    assertEquals(model.getTemplate().getId(), transform.getTemplate().getId());
    assertNotNull(transform.getCluster());
    assertNotNull(transform.getCpu());
    assertNotNull(transform.getCpu().getTopology());
    assertTrue(Math.abs(model.getCpu().getTopology().getCores() - transform.getCpu().getTopology().getCores()) < model.getCpu().getTopology().getSockets());
    assertEquals(model.getCpu().getTopology().getSockets(), transform.getCpu().getTopology().getSockets());
    assertNotNull(transform.getOs());
    assertTrue(transform.getOs().isSetBoot());
    assertEquals(model.getOs().getBoot().size(), transform.getOs().getBoot().size());
    for (int i = 0; i < model.getOs().getBoot().size(); i++) {
        assertEquals(model.getOs().getBoot().get(i).getDev(), transform.getOs().getBoot().get(i).getDev());
    }
    assertEquals(model.getOs().getKernel(), transform.getOs().getKernel());
    assertEquals(model.getOs().getInitrd(), transform.getOs().getInitrd());
    assertEquals(model.getOs().getCmdline(), transform.getOs().getCmdline());
    assertTrue(transform.isSetDisplay());
    assertEquals(model.isSetDisplay(), transform.isSetDisplay());
    assertEquals(model.getDisplay().getType(), transform.getDisplay().getType());
    assertEquals(model.getDisplay().getMonitors(), transform.getDisplay().getMonitors());
    assertEquals(model.getDisplay().isSingleQxlPci(), transform.getDisplay().isSingleQxlPci());
    assertEquals(model.getDisplay().isAllowOverride(), transform.getDisplay().isAllowOverride());
    assertEquals(model.getPlacementPolicy().getHost().getId(), transform.getPlacementPolicy().getHost().getId());
    assertTrue(Math.abs(model.getMemoryPolicy().getGuaranteed() - transform.getMemoryPolicy().getGuaranteed()) <= (1024 * 1024));
    assertEquals(model.getTimezone(), transform.getTimezone());
    assertEquals(model.getDisplay().isSmartcardEnabled(), transform.getDisplay().isSmartcardEnabled());
    assertEquals(model.getDisplay().getKeyboardLayout(), transform.getDisplay().getKeyboardLayout());
    assertEquals(model.isDeleteProtected(), transform.isDeleteProtected());
    assertEquals(model.isTunnelMigration(), transform.isTunnelMigration());
    assertEquals(model.getMigrationDowntime(), transform.getMigrationDowntime());
    assertEquals(model.getSerialNumber().getPolicy(), transform.getSerialNumber().getPolicy());
    assertEquals(model.getSerialNumber().getValue(), transform.getSerialNumber().getValue());
}
#end_block

#method_before
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    return staticVm;
}
#method_after
@Mapping(from = VmTemplate.class, to = VmStatic.class)
public static VmStatic map(VmTemplate entity, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    staticVm.setId(Guid.Empty);
    staticVm.setVmtGuid(entity.getId());
    staticVm.setVdsGroupId(entity.getVdsGroupId());
    staticVm.setMemSizeMb(entity.getMemSizeMb());
    staticVm.setOsId(entity.getOsId());
    staticVm.setNiceLevel(entity.getNiceLevel());
    staticVm.setCpuShares(entity.getCpuShares());
    staticVm.setFailBack(entity.isFailBack());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setStateless(entity.isStateless());
    staticVm.setDeleteProtected(entity.isDeleteProtected());
    staticVm.setSsoMethod(entity.getSsoMethod());
    staticVm.setSmartcardEnabled(entity.isSmartcardEnabled());
    staticVm.setAutoStartup(entity.isAutoStartup());
    staticVm.setDefaultBootSequence(entity.getDefaultBootSequence());
    staticVm.setVmType(entity.getVmType());
    staticVm.setDefaultDisplayType(entity.getDefaultDisplayType());
    staticVm.setIsoPath(entity.getIsoPath());
    staticVm.setNumOfSockets(entity.getNumOfSockets());
    staticVm.setCpuPerSocket(entity.getCpuPerSocket());
    staticVm.setKernelUrl(entity.getKernelUrl());
    staticVm.setKernelParams(entity.getKernelParams());
    staticVm.setInitrdUrl(entity.getInitrdUrl());
    staticVm.setTimeZone(entity.getTimeZone());
    staticVm.setNumOfMonitors(entity.getNumOfMonitors());
    staticVm.setSingleQxlPci(entity.getSingleQxlPci());
    staticVm.setAllowConsoleReconnect(entity.isAllowConsoleReconnect());
    staticVm.setPriority(entity.getPriority());
    staticVm.setUsbPolicy(entity.getUsbPolicy());
    staticVm.setTunnelMigration(entity.getTunnelMigration());
    staticVm.setVncKeyboardLayout(entity.getVncKeyboardLayout());
    staticVm.setMigrationDowntime(entity.getMigrationDowntime());
    staticVm.setVmInit(entity.getVmInit());
    staticVm.setSerialNumberPolicy(entity.getSerialNumberPolicy());
    staticVm.setCustomSerialNumber(entity.getCustomSerialNumber());
    return staticVm;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(vm.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (entity.getVmInit().getDomain() != null) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
        // otherwise the value of this property is meaningless and misleading
        if (entity.isStateless()) {
            model.setUseLatestTemplateVersion(entity.isUseLatestVersion());
        }
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    cpu.setArchitecture(CPUMapper.map(entity.getClusterArch(), null));
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (entity.getLastStopTime() != null) {
        model.setStopTime(DateMapper.map(entity.getLastStopTime(), null));
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getDefaultVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setSso(SsoMapper.map(entity.getSsoMethod(), null));
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    model.setMigrationDowntime(mapNullToMinusOne(entity.getMigrationDowntime()));
    if (entity.getVmInit() != null) {
        model.setInitialization(map(entity.getVmInit(), null));
        if (entity.getVmInit().getDomain() != null) {
            Domain domain = new Domain();
            domain.setName(entity.getVmInit().getDomain());
            model.setDomain(domain);
        }
    }
    if (entity.getSerialNumberPolicy() != null) {
        model.setSerialNumber(SerialNumberMapper.map(entity.getStaticData(), null));
    }
    return model;
}
#end_block

#method_before
public static Sessions map(org.ovirt.engine.core.common.businessentities.VM vm, Sessions sessions) {
    if (sessions == null) {
        sessions = new Sessions();
    }
    mapConsoleSession(vm, sessions);
    mapGusetSessions(vm, sessions);
    return sessions;
}
#method_after
public static Sessions map(org.ovirt.engine.core.common.businessentities.VM vm, Sessions sessions) {
    if (sessions == null) {
        sessions = new Sessions();
    }
    mapConsoleSession(vm, sessions);
    mapGuestSessions(vm, sessions);
    return sessions;
}
#end_block

#method_before
@Override
public Sessions list() {
    Object vm = getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), vmId.toString(), true);
    Sessions sessions = VmMapper.map((VM) vm, new Sessions());
    UsersResource usersResource = getUsersResource();
    if (sessions.isSetSessions()) {
        for (Session session : sessions.getSessions()) {
            setSessionId(session);
            setSessionUser(usersResource, session);
            addLinks(session);
        }
    }
    return sessions;
}
#method_after
@Override
public Sessions list() {
    Object obj = getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(vmId), vmId.toString(), true);
    VM vm = (VM) obj;
    Sessions sessions = VmMapper.map(vm, new Sessions());
    org.ovirt.engine.api.model.VM vmModel = new org.ovirt.engine.api.model.VM();
    vmModel.setId(vm.getId().toString());
    if (sessions.isSetSessions()) {
        for (Session session : sessions.getSessions()) {
            setSessionId(session);
            setSessionVmId(vmModel, session);
            setSessionUser(session);
            addLinks(session, org.ovirt.engine.api.model.VM.class);
        }
    }
    return sessions;
}
#end_block

#method_before
private void setSessionId(Session session) {
    String idString = session.getUser().getName();
    if (session.isSetIp() && session.getIp().isSetAddress()) {
        idString += session.getIp().getAddress();
    }
    if (session.isSetProtocol()) {
        idString += session.getProtocol();
    }
    session.setId(GuidUtils.generateGuidUsingMd5(idString).toString());
    addLinks(session);
}
#method_after
private void setSessionId(Session session) {
    String idString = session.getUser().getName();
    if (session.isSetIp() && session.getIp().isSetAddress()) {
        idString += session.getIp().getAddress();
    }
    if (session.isSetProtocol()) {
        idString += session.getProtocol();
    }
    session.setId(GuidUtils.generateGuidUsingMd5(idString).toString());
}
#end_block

#method_before
private void setSessionUser(UsersResource usersResource, Session session) {
    if (session.isSetConsoleUser() && session.isConsoleUser()) {
        // all users and search.
        for (User user : usersResource.list().getUsers()) {
            if (user.getName().equals(session.getUser().getName())) {
                session.setUser(user);
                return;
            }
        }
        // Console user is an ovirt user and must be found.
        throw new WebApplicationException(Response.Status.NOT_FOUND);
    }
}
#method_after
private void setSessionUser(Session session) {
    if (session.isSetConsoleUser() && session.isConsoleUser()) {
        // (only console user assumed to be an ovirt user).
        User user = getUserResource().getUserByName(session.getUser().getName());
        session.getUser().setId(user.getId());
        session.getUser().setHref(user.getHref());
    }
}
#end_block

#method_before
protected <P extends VdcActionParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#method_after
protected <P extends VdcQueryParametersBase> P sessionize(P parameters) {
    return sessionHelper.sessionize(parameters);
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(poolSpecificFields(), hiddenField()).putOne(logicalNetworksEditorPanel, hiddenField()).update(consoleTab, simpleField().visibleInAdvancedModeOnly());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(poolSpecificFields(), hiddenField()).putOne(logicalNetworksEditorPanel, hiddenField()).update(consoleTab, simpleField().visibleInAdvancedModeOnly()).update(templateVersionNameEditor, hiddenField());
}
#end_block

#method_before
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#method_after
public void init(final boolean isEdit) {
    setIsEdit(isEdit);
    setName(new EntityModel<String>());
    setDescription(new EntityModel<String>());
    setComment(new EntityModel<String>());
    setEnableTrustedService(new EntityModel<Boolean>(false));
    setEnableHaReservation(new EntityModel<Boolean>(false));
    setAllowClusterWithVirtGlusterEnabled(true);
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            setAllowClusterWithVirtGlusterEnabled((Boolean) returnValue);
        }
    }));
    setEnableOvirtService(new EntityModel<Boolean>());
    setEnableGlusterService(new EntityModel<Boolean>());
    setSpiceProxyEnabled(new EntityModel<Boolean>());
    getSpiceProxyEnabled().setEntity(false);
    getSpiceProxyEnabled().getEntityChangedEvent().addListener(this);
    setSpiceProxy(new EntityModel<String>());
    getSpiceProxy().setIsChangable(false);
    setEnableOvirtService(new EntityModel());
    setEnableGlusterService(new EntityModel());
    setSerialNumberPolicy(new SerialNumberPolicyModel());
    getEnableOvirtService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableOvirtService().getEntity()) {
                getEnableGlusterService().setEntity(Boolean.FALSE);
            }
            getEnableGlusterService().setIsChangable(true);
            getEnableTrustedService().setEntity(false);
            if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                if (getEnableGlusterService().getEntity() != null && !getEnableGlusterService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            } else {
                getEnableTrustedService().setIsChangable(false);
            }
        }
    });
    getEnableOvirtService().setEntity(ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    getEnableOvirtService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.VirtOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.VirtOnly));
    initImportCluster(isEdit);
    getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!getAllowClusterWithVirtGlusterEnabled() && getEnableGlusterService().getEntity()) {
                getEnableOvirtService().setEntity(Boolean.FALSE);
            }
            if (!isEdit && getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getIsImportGlusterConfiguration().setIsAvailable(true);
                getGlusterHostAddress().setIsAvailable(true);
                getGlusterHostFingerprint().setIsAvailable(true);
                getGlusterHostPassword().setIsAvailable(true);
            } else {
                getIsImportGlusterConfiguration().setIsAvailable(false);
                getIsImportGlusterConfiguration().setEntity(false);
                getGlusterHostAddress().setIsAvailable(false);
                getGlusterHostFingerprint().setIsAvailable(false);
                getGlusterHostPassword().setIsAvailable(false);
            }
            if (getEnableGlusterService().getEntity() != null && getEnableGlusterService().getEntity()) {
                getEnableTrustedService().setEntity(false);
                getEnableTrustedService().setIsChangable(false);
            } else {
                if (getEnableOvirtService().getEntity() != null && getEnableOvirtService().getEntity()) {
                    getEnableTrustedService().setIsChangable(true);
                } else {
                    getEnableTrustedService().setIsChangable(false);
                }
            }
        }
    });
    getEnableTrustedService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (getEnableTrustedService().getEntity() != null && getEnableTrustedService().getEntity()) {
                getEnableGlusterService().setEntity(false);
                getEnableGlusterService().setIsChangable(false);
            } else {
                getEnableGlusterService().setIsChangable(true);
            }
        }
    });
    getEnableGlusterService().setEntity(ApplicationModeHelper.getUiMode() == ApplicationMode.GlusterOnly);
    getEnableGlusterService().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly && ApplicationModeHelper.isModeSupported(ApplicationMode.GlusterOnly));
    setOptimizationNone(new EntityModel<Integer>());
    setOptimizationForServer(new EntityModel<Integer>());
    setOptimizationForDesktop(new EntityModel<Integer>());
    setOptimizationCustom(new EntityModel<Integer>());
    EntityModel tempVar = new EntityModel<Boolean>();
    tempVar.setEntity(false);
    setOptimizationNone_IsSelected(tempVar);
    getOptimizationNone_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar2 = new EntityModel<Boolean>();
    tempVar2.setEntity(false);
    setOptimizationForServer_IsSelected(tempVar2);
    getOptimizationForServer_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar3 = new EntityModel<Boolean>();
    tempVar3.setEntity(false);
    setOptimizationForDesktop_IsSelected(tempVar3);
    getOptimizationForDesktop_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar4 = new EntityModel<Boolean>();
    tempVar4.setEntity(false);
    tempVar4.setIsAvailable(false);
    setOptimizationCustom_IsSelected(tempVar4);
    getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(this);
    EntityModel tempVar5 = new EntityModel<Boolean>();
    tempVar5.setEntity(false);
    setMigrateOnErrorOption_YES(tempVar5);
    getMigrateOnErrorOption_YES().getEntityChangedEvent().addListener(this);
    EntityModel tempVar6 = new EntityModel<Boolean>();
    tempVar6.setEntity(false);
    setMigrateOnErrorOption_NO(tempVar6);
    getMigrateOnErrorOption_NO().getEntityChangedEvent().addListener(this);
    EntityModel tempVar7 = new EntityModel<Boolean>();
    tempVar7.setEntity(false);
    setMigrateOnErrorOption_HA_ONLY(tempVar7);
    getMigrateOnErrorOption_HA_ONLY().getEntityChangedEvent().addListener(this);
    setEnableKsm(new EntityModel<Boolean>());
    getEnableKsm().setEntity(false);
    setEnableBallooning(new EntityModel<Boolean>());
    getEnableBallooning().setEntity(false);
    // Optimization methods:
    // default value =100;
    setDefaultMemoryOvercommit(AsyncDataProvider.getClusterDefaultMemoryOverCommit());
    setCountThreadsAsCores(new EntityModel(AsyncDataProvider.getClusterDefaultCountThreadsAsCores()));
    setVersionSupportsCpuThreads(new EntityModel<Boolean>(true));
    setOptimizeForUtilization(new EntityModel<Boolean>());
    setOptimizeForSpeed(new EntityModel<Boolean>());
    getOptimizeForUtilization().setEntity(true);
    getOptimizeForSpeed().setEntity(false);
    getOptimizeForUtilization().getEntityChangedEvent().addListener(this);
    getOptimizeForSpeed().getEntityChangedEvent().addListener(this);
    setGuarantyResources(new EntityModel<Boolean>());
    setAllowOverbooking(new EntityModel<Boolean>());
    getGuarantyResources().setEntity(true);
    getAllowOverbooking().setEntity(false);
    getAllowOverbooking().getEntityChangedEvent().addListener(this);
    getGuarantyResources().getEntityChangedEvent().addListener(this);
    boolean overbookingSupported = AsyncDataProvider.getScheudulingAllowOverbookingSupported();
    getAllowOverbooking().setIsAvailable(overbookingSupported);
    if (overbookingSupported) {
        getOptimizeForSpeed().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getOptimizeForSpeed().getEntity();
                if (entity) {
                    getGuarantyResources().setEntity(true);
                }
                getAllowOverbooking().setIsChangable(!entity);
            }
        });
        getAllowOverbooking().getEntityChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                Boolean entity = getAllowOverbooking().getEntity();
                if (entity) {
                    getOptimizeForUtilization().setEntity(true);
                }
                getOptimizeForSpeed().setIsChangable(!entity);
            }
        });
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            clusterModel.setDesktopOverCommit((Integer) result);
            AsyncQuery _asyncQuery1 = new AsyncQuery();
            _asyncQuery1.setModel(clusterModel);
            _asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result1) {
                    ClusterModel clusterModel1 = (ClusterModel) model1;
                    clusterModel1.setServerOverCommit((Integer) result1);
                    // temp is used for conversion purposes
                    EntityModel temp;
                    temp = clusterModel1.getOptimizationNone();
                    temp.setEntity(clusterModel1.getDefaultMemoryOvercommit());
                    // res1, res2 is used for conversion purposes.
                    boolean res1 = clusterModel1.getDesktopOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    boolean res2 = clusterModel1.getServerOverCommit() != clusterModel1.getDefaultMemoryOvercommit();
                    temp = clusterModel1.getOptimizationNone_IsSelected();
                    setIsSelected(res1 && res2);
                    temp.setEntity(getIsSelected());
                    temp = clusterModel1.getOptimizationForServer();
                    temp.setEntity(clusterModel1.getServerOverCommit());
                    temp = clusterModel1.getOptimizationForServer_IsSelected();
                    temp.setEntity(clusterModel1.getServerOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationForDesktop();
                    temp.setEntity(clusterModel1.getDesktopOverCommit());
                    temp = clusterModel1.getOptimizationForDesktop_IsSelected();
                    temp.setEntity(clusterModel1.getDesktopOverCommit() == clusterModel1.getDefaultMemoryOvercommit());
                    temp = clusterModel1.getOptimizationCustom();
                    temp.setIsAvailable(false);
                    temp.setIsChangable(false);
                    if (clusterModel1.getIsEdit()) {
                        clusterModel1.postInit();
                    }
                }
            };
            AsyncDataProvider.getClusterServerMemoryOverCommit(_asyncQuery1);
        }
    };
    AsyncDataProvider.getClusterDesktopMemoryOverCommit(_asyncQuery);
    setDataCenter(new ListModel<StoragePool>());
    getDataCenter().getSelectedItemChangedEvent().addListener(this);
    getDataCenter().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    setCPU(new ListModel<ServerCpu>());
    getCPU().setIsAvailable(ApplicationModeHelper.getUiMode() != ApplicationMode.GlusterOnly);
    getCPU().getSelectedItemChangedEvent().addListener(this);
    setVersion(new ListModel<Version>());
    getVersion().getSelectedItemChangedEvent().addListener(this);
    setMigrateOnErrorOption(MigrateOnErrorOptions.YES);
    setArchitecture(new ListModel<ArchitectureType>());
    setIsGeneralTabValid(true);
    setIsResiliencePolicyTabAvailable(true);
    setClusterPolicy(new ListModel<ClusterPolicy>());
    setCustomPropertySheet(new KeyValueModel());
    getClusterPolicy().getSelectedItemChangedEvent().addListener(this);
    Frontend.getInstance().runQuery(VdcQueryType.GetAllPolicyUnits, new VdcQueryParametersBase(), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<PolicyUnit> policyUnits = ((VdcQueryReturnValue) returnValue).getReturnValue();
            policyUnitMap = new LinkedHashMap<Guid, PolicyUnit>();
            for (PolicyUnit policyUnit : policyUnits) {
                policyUnitMap.put(policyUnit.getId(), policyUnit);
            }
            Frontend.getInstance().runQuery(VdcQueryType.GetClusterPolicies, new VdcQueryParametersBase(), new AsyncQuery(model, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    ClusterModel clusterModel = (ClusterModel) model;
                    ArrayList<ClusterPolicy> list = ((VdcQueryReturnValue) returnValue).getReturnValue();
                    clusterModel.getClusterPolicy().setItems(list);
                    ClusterPolicy defaultClusterPolicy = null;
                    ClusterPolicy selectedClusterPolicy = null;
                    for (ClusterPolicy clusterPolicy : list) {
                        if (clusterModel.getIsEdit() && getEntity() != null && clusterPolicy.getId().equals(getEntity().getClusterPolicyId())) {
                            selectedClusterPolicy = clusterPolicy;
                        }
                        if (clusterPolicy.isDefaultPolicy()) {
                            defaultClusterPolicy = clusterPolicy;
                        }
                    }
                    if (selectedClusterPolicy != null) {
                        clusterModel.getClusterPolicy().setSelectedItem(selectedClusterPolicy);
                    } else {
                        clusterModel.getClusterPolicy().setSelectedItem(defaultClusterPolicy);
                    }
                    clusterPolicyChanged();
                }
            }));
        }
    }));
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getDataCenter()) {
            storagePool_SelectedItemChanged(args);
        } else if (sender == getVersion()) {
            version_SelectedItemChanged(args);
        } else if (sender == getClusterPolicy()) {
            clusterPolicyChanged();
        } else if (sender == getCPU()) {
            CPU_SelectedItemChanged(args);
        }
    } else if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        EntityModel senderEntityModel = (EntityModel) sender;
        if (senderEntityModel == getSpiceProxyEnabled()) {
            getSpiceProxy().setIsChangable(getSpiceProxyEnabled().getEntity());
        } else if ((Boolean) senderEntityModel.getEntity()) {
            if (senderEntityModel == getOptimizationNone_IsSelected()) {
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForServer_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationForDesktop_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationCustom_IsSelected().setEntity(false);
            } else if (senderEntityModel == getOptimizationCustom_IsSelected()) {
                getOptimizationNone_IsSelected().setEntity(false);
                getOptimizationForServer_IsSelected().setEntity(false);
                getOptimizationForDesktop_IsSelected().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_YES()) {
                getMigrateOnErrorOption_NO().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_NO()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_HA_ONLY().setEntity(false);
            } else if (senderEntityModel == getMigrateOnErrorOption_HA_ONLY()) {
                getMigrateOnErrorOption_YES().setEntity(false);
                getMigrateOnErrorOption_NO().setEntity(false);
            } else if (senderEntityModel == getOptimizeForUtilization()) {
                getOptimizeForSpeed().setEntity(false);
            } else if (senderEntityModel == getOptimizeForSpeed()) {
                getOptimizeForUtilization().setEntity(false);
            } else if (senderEntityModel == getGuarantyResources()) {
                getAllowOverbooking().setEntity(false);
            } else if (senderEntityModel == getAllowOverbooking()) {
                getGuarantyResources().setEntity(false);
            }
        }
    }
}
#end_block

#method_before
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
}
#method_after
private void version_SelectedItemChanged(EventArgs e) {
    Version version;
    if (getVersion().getSelectedItem() != null) {
        version = getVersion().getSelectedItem();
    } else {
        version = getDataCenter().getSelectedItem().getcompatibility_version();
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            ClusterModel clusterModel = (ClusterModel) model;
            ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) result;
            if (clusterModel.getIsEdit()) {
                AsyncQuery emptyQuery = new AsyncQuery();
                emptyQuery.setModel(new Object[] { clusterModel, cpus });
                emptyQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        Boolean isEmpty = (Boolean) returnValue;
                        Object[] objArray = (Object[]) model;
                        ClusterModel clusterModel = (ClusterModel) objArray[0];
                        ArrayList<ServerCpu> cpus = (ArrayList<ServerCpu>) objArray[1];
                        if (isEmpty) {
                            populateCPUList(clusterModel, cpus, true);
                        } else {
                            ArrayList<ServerCpu> filteredCpus = new ArrayList<ServerCpu>();
                            for (ServerCpu cpu : cpus) {
                                if (cpu.getArchitecture() == clusterModel.getEntity().getArchitecture()) {
                                    filteredCpus.add(cpu);
                                }
                            }
                            populateCPUList(clusterModel, filteredCpus, false);
                        }
                    }
                };
                AsyncDataProvider.isClusterEmpty(emptyQuery, clusterModel.getEntity().getId());
            } else {
                populateCPUList(clusterModel, cpus, true);
            }
        }
    };
    AsyncDataProvider.getCPUList(_asyncQuery, version);
    // CPU Thread support is only available for clusters of version 3.2 or greater
    getVersionSupportsCpuThreads().setEntity(version.compareTo(Version.v3_2) >= 0);
    getEnableBallooning().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ballooningNotAvailable());
    getEnableBallooning().setIsChangable(version.compareTo(Version.v3_3) >= 0);
    boolean isSmallerThanVersion3_4 = version.compareTo(Version.v3_4) < 0;
    getEnableKsm().setIsChangable(!isSmallerThanVersion3_4);
    getEnableKsm().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().ksmNotAvailable());
    if (isSmallerThanVersion3_4) {
        getEnableKsm().setEntity(true);
    }
    updateMigrateOnError();
}
#end_block

#method_before
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getSpiceProxy().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true) && getCustomPropertySheet().getIsValid();
}
#method_after
public boolean validate(boolean validateStoragePool, boolean validateCpu, boolean validateCustomProperties) {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation(40), new I18NNameValidation() });
    if (validateStoragePool) {
        getDataCenter().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (validateCpu) {
        getCPU().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getCPU().validateSelectedItem(new IValidation[] {});
    }
    if (validateCustomProperties) {
        getCustomPropertySheet().setIsValid(getCustomPropertySheet().validate());
    }
    getVersion().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    // TODO: async validation for webadmin
    // string name = (string)Name.Entity;
    // //Check name unicitate.
    // if (String.Compare(name, OriginalName, true) != 0 && !DataProvider.IsClusterNameUnique(name))
    // {
    // Name.IsValid = false;
    // Name.InvalidityReasons.Add("Name must be unique.");
    // }
    boolean validService = true;
    if (getEnableOvirtService().getIsAvailable() && getEnableGlusterService().getIsAvailable()) {
        validService = getEnableOvirtService().getEntity() || getEnableGlusterService().getEntity();
    }
    getGlusterHostAddress().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getGlusterHostPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    if (!validService) {
        setMessage(ConstantsManager.getInstance().getConstants().clusterServiceValidationMsg());
    } else if (getIsImportGlusterConfiguration().getEntity() && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && !isFingerprintVerified()) {
        setMessage(ConstantsManager.getInstance().getConstants().fingerprintNotVerified());
    } else {
        setMessage(null);
    }
    if (getSpiceProxyEnabled().getEntity()) {
        getSpiceProxy().validateEntity(new IValidation[] { new HostWithProtocolAndPortAddressValidation() });
    } else {
        getSpiceProxy().setIsValid(true);
    }
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsGeneralTabValid(getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true));
    return getName().getIsValid() && getDataCenter().getIsValid() && getCPU().getIsValid() && getSpiceProxy().getIsValid() && getVersion().getIsValid() && validService && getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid() && (getIsImportGlusterConfiguration().getEntity() ? (getGlusterHostAddress().getIsValid() && getGlusterHostPassword().getIsValid() && isFingerprintVerified()) : true) && getCustomPropertySheet().getIsValid();
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // If this a blank template, use the proper value for the default OS
        if (template.getId().equals(Guid.Empty)) {
            Integer osId = AsyncDataProvider.getDefaultOs(getModel().getSelectedCluster().getArchitecture());
            if (osId != null) {
                setSelectedOSById(osId.intValue());
            }
        } else {
            setSelectedOSById(template.getOsId());
        }
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
        getModel().getMemSize().setEntity(template.getMemSizeMb());
        getModel().setBootSequence(template.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        getModel().selectSsoMethod(template.getSsoMethod());
        getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateConsoleDevice(template.getId());
        updateVirtioScsiEnabled(template.getId(), template.getOsId());
        updateTimeZone(template.getTimeZone());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == template.getDefaultDisplayType()) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getKernelUrl());
        getModel().getKernel_parameters().setEntity(template.getKernelParams());
        getModel().getInitrd_path().setEntity(template.getInitrdUrl());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            initSoundCard(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initPriority(template.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (template.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        updateNetworkInterfacesByTemplate(template);
        getModel().getVmInitModel().init(template);
        getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
        BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    }
}
#method_after
@Override
public void template_SelectedItemChanged() {
    VmTemplate template = getModel().getTemplate().getSelectedItem();
    if (template != null) {
        // Copy VM parameters from template.
        setSelectedOSType(template, getModel().getSelectedCluster().getArchitecture());
        getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
        getModel().getMemSize().setEntity(template.getMemSizeMb());
        getModel().setBootSequence(template.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
        updateHostPinning(template.getMigrationSupport());
        doChangeDefautlHost(template.getDedicatedVmForVds());
        getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
        getModel().selectSsoMethod(template.getSsoMethod());
        getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
        getModel().getIsStateless().setEntity(template.isStateless());
        boolean hasCd = !StringHelper.isNullOrEmpty(template.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(template.getIsoPath());
        }
        updateConsoleDevice(template.getId());
        updateVirtioScsiEnabled(template.getId(), template.getOsId());
        updateTimeZone(template.getTimeZone());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == template.getDefaultDisplayType()) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(template.getKernelUrl());
        getModel().getKernel_parameters().setEntity(template.getKernelParams());
        getModel().getInitrd_path().setEntity(template.getInitrdUrl());
        if (!template.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().getProvisioning().setIsChangable(true);
            getModel().getVmType().setSelectedItem(template.getVmType());
            getModel().setIsBlankTemplate(false);
            getModel().getCopyPermissions().setIsAvailable(true);
            getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
            initDisks();
            initSoundCard(template.getId());
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().getProvisioning().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().getCopyPermissions().setIsAvailable(false);
            getModel().setDisks(null);
        }
        initPriority(template.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (template.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
        }
        updateQuotaByCluster(template.getQuotaId(), template.getQuotaName());
        updateNetworkInterfacesByTemplate(template);
        getModel().getVmInitModel().init(template);
        getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
        BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getOverrideSerialNumberPolicy()) {
            overrideSerialNumberPolicyChanged();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    if (ev.matchesDefinition(EntityModel.entityChangedEventDefinition)) {
        if (sender == getOverrideSerialNumberPolicy()) {
            overrideSerialNumberPolicyChanged();
        } else if (sender == getSerialNumberPolicy()) {
            serialNumberPolicyChanged();
        }
    }
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().update(highAvailabilityTab, hiddenField()).update(spiceProxyEditor, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyEnabledCheckboxWithInfoIcon, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyOverrideEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isStatelessEditor, hiddenField()).putOne(isRunAndPauseEditor, hiddenField()).putOne(editPoolEditVmsPanel, hiddenField()).putOne(editPoolIncraseNumOfVmsPanel, hiddenField()).putOne(logicalNetworksEditorPanel, hiddenField()).putOne(editPoolEditMaxAssignedVmsPerUserPanel, hiddenField());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().update(highAvailabilityTab, hiddenField()).update(spiceProxyEditor, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyEnabledCheckboxWithInfoIcon, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyOverrideEnabledEditor, simpleField().visibleInAdvancedModeOnly()).putOne(isStatelessEditor, hiddenField()).putOne(isRunAndPauseEditor, hiddenField()).putOne(editPoolEditVmsPanel, hiddenField()).putOne(editPoolIncraseNumOfVmsPanel, hiddenField()).putOne(logicalNetworksEditorPanel, hiddenField()).putOne(editPoolEditMaxAssignedVmsPerUserPanel, hiddenField()).update(templateVersionNameEditor, hiddenField());
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(poolSpecificFields(), hiddenField());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().putAll(poolSpecificFields(), hiddenField()).update(templateVersionNameEditor, hiddenField());
}
#end_block

#method_before
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        getModel().getOSType().setSelectedItem(vmBase.getOsId());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(vmBase.getSingleQxlPci());
        getModel().getMemSize().setEntity(vmBase.getMemSizeMb());
        getModel().setBootSequence(vmBase.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.isAutoStartup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().selectSsoMethod(vmBase.getSsoMethod());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        updateTimeZone(vmBase.getTimeZone());
        updateConsoleDevice(vmBase.getId());
        updateVirtioScsiEnabled(vmBase.getId(), vmBase.getOsId());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(vmBase.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(vmBase.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        getModel().setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getKernelUrl());
        getModel().getKernel_parameters().setEntity(vmBase.getKernelParams());
        getModel().getInitrd_path().setEntity(vmBase.getInitrdUrl());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initPriority(vmBase.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (vmBase.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
        }
        initSoundCard(vmBase.getId());
        getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
        getModel().getVmInitModel().init(vmBase);
        getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
        BuilderExecutor.build(vmBase, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    }
}
#method_after
protected void setupWindowModelFrom(VmBase vmBase) {
    if (vmBase != null) {
        updateQuotaByCluster(vmBase.getQuotaId(), vmBase.getQuotaName());
        // Copy VM parameters from template.
        setSelectedOSType(vmBase, getModel().getSelectedCluster().getArchitecture());
        getModel().getTotalCPUCores().setEntity(Integer.toString(vmBase.getNumOfCpus()));
        getModel().getNumOfSockets().setSelectedItem(vmBase.getNumOfSockets());
        getModel().getNumOfMonitors().setSelectedItem(vmBase.getNumOfMonitors());
        getModel().getIsSingleQxlEnabled().setEntity(vmBase.getSingleQxlPci());
        getModel().getMemSize().setEntity(vmBase.getMemSizeMb());
        getModel().setBootSequence(vmBase.getDefaultBootSequence());
        getModel().getIsHighlyAvailable().setEntity(vmBase.isAutoStartup());
        getModel().getIsDeleteProtected().setEntity(vmBase.isDeleteProtected());
        getModel().selectSsoMethod(vmBase.getSsoMethod());
        getModel().getIsRunAndPause().setEntity(false);
        boolean hasCd = !StringHelper.isNullOrEmpty(vmBase.getIsoPath());
        getModel().getCdImage().setIsChangable(hasCd);
        getModel().getCdAttached().setEntity(hasCd);
        if (hasCd) {
            getModel().getCdImage().setSelectedItem(vmBase.getIsoPath());
        }
        updateTimeZone(vmBase.getTimeZone());
        updateConsoleDevice(vmBase.getId());
        updateVirtioScsiEnabled(vmBase.getId(), vmBase.getOsId());
        // Update domain list
        updateDomain();
        // Update display protocol selected item
        EntityModel<DisplayType> displayProtocol = null;
        boolean isFirst = true;
        for (EntityModel<DisplayType> item : getModel().getDisplayProtocol().getItems()) {
            if (isFirst) {
                displayProtocol = item;
                isFirst = false;
            }
            DisplayType dt = item.getEntity();
            if (dt == extractDisplayType(vmBase)) {
                displayProtocol = item;
                break;
            }
        }
        getModel().getDisplayProtocol().setSelectedItem(displayProtocol);
        getModel().getUsbPolicy().setSelectedItem(vmBase.getUsbPolicy());
        getModel().getVncKeyboardLayout().setSelectedItem(vmBase.getVncKeyboardLayout());
        getModel().getIsSmartcardEnabled().setEntity(vmBase.isSmartcardEnabled());
        getModel().setSelectedMigrationDowntime(vmBase.getMigrationDowntime());
        // By default, take kernel params from template.
        getModel().getKernel_path().setEntity(vmBase.getKernelUrl());
        getModel().getKernel_parameters().setEntity(vmBase.getKernelParams());
        getModel().getInitrd_path().setEntity(vmBase.getInitrdUrl());
        if (!vmBase.getId().equals(Guid.Empty)) {
            getModel().getStorageDomain().setIsChangable(true);
            getModel().setIsBlankTemplate(false);
            initDisks();
        } else {
            getModel().getStorageDomain().setIsChangable(false);
            getModel().setIsBlankTemplate(true);
            getModel().setIsDisksAvailable(false);
            getModel().setDisks(null);
        }
        getModel().getProvisioning().setEntity(false);
        initPriority(vmBase.getPriority());
        initStorageDomains();
        // use min. allocated memory from the template, if specified
        if (vmBase.getMinAllocatedMem() == 0) {
            updateMinAllocatedMemory();
        } else {
            getModel().getMinAllocatedMemory().setEntity(vmBase.getMinAllocatedMem());
        }
        initSoundCard(vmBase.getId());
        getModel().getAllowConsoleReconnect().setEntity(vmBase.isAllowConsoleReconnect());
        getModel().getVmInitModel().init(vmBase);
        getModel().getVmInitEnabled().setEntity(vmBase.getVmInit() != null);
        BuilderExecutor.build(vmBase, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
    }
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getBaseTemplate().setIsChangable(false);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    if (template.getStoragePoolId() != null && !template.getStoragePoolId().equals(Guid.Empty)) {
        AsyncDataProvider.getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                final StoragePool dataCenter = (StoragePool) returnValue;
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
                        ArrayList<VDSGroup> clustersSupportingVirt = new ArrayList<VDSGroup>();
                        // filter clusters supporting virt service only
                        for (VDSGroup cluster : clusters) {
                            if (cluster.supportsVirtService()) {
                                clustersSupportingVirt.add(cluster);
                            }
                        }
                        List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clustersSupportingVirt, template.getClusterArch());
                        model.setDataCentersAndClusters(model, new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter })), filteredClusters, template.getVdsGroupId());
                        AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                                initTemplate();
                                initCdImage();
                            }
                        }), template.getId());
                    }
                }, getModel().getHash()), true, false);
            }
        }, getModel().getHash()), template.getStoragePoolId());
    }
    AsyncDataProvider.getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel().name());
            }
        }
    }), template.getId());
    getModel().getMigrationMode().setSelectedItem(template.getMigrationSupport());
    setupBaseTemplate(template.getBaseTemplateId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getTemplate().setIsChangable(false);
    getModel().getBaseTemplate().setIsChangable(false);
    getModel().getProvisioning().setIsChangable(false);
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    getModel().getVmType().setIsChangable(true);
    getModel().getTemplateVersionName().setIsChangable(!template.getId().equals(template.getBaseTemplateId()));
    if (template.getStoragePoolId() != null && !template.getStoragePoolId().equals(Guid.Empty)) {
        AsyncDataProvider.getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                final StoragePool dataCenter = (StoragePool) returnValue;
                AsyncDataProvider.getClusterListByService(new AsyncQuery(getModel(), new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object target, Object returnValue) {
                        UnitVmModel model = (UnitVmModel) target;
                        ArrayList<VDSGroup> clusters = (ArrayList<VDSGroup>) returnValue;
                        ArrayList<VDSGroup> clustersSupportingVirt = new ArrayList<VDSGroup>();
                        // filter clusters supporting virt service only
                        for (VDSGroup cluster : clusters) {
                            if (cluster.supportsVirtService()) {
                                clustersSupportingVirt.add(cluster);
                            }
                        }
                        List<VDSGroup> filteredClusters = AsyncDataProvider.filterByArchitecture(clustersSupportingVirt, template.getClusterArch());
                        model.setDataCentersAndClusters(model, new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter })), filteredClusters, template.getVdsGroupId());
                        AsyncDataProvider.isSoundcardEnabled(new AsyncQuery(getModel(), new INewAsyncCallback() {

                            @Override
                            public void onSuccess(Object model, Object returnValue) {
                                getModel().getIsSoundcardEnabled().setEntity((Boolean) returnValue);
                                initTemplate();
                                initCdImage();
                            }
                        }), template.getId());
                    }
                }, getModel().getHash()), true, false);
            }
        }, getModel().getHash()), template.getStoragePoolId());
    }
    AsyncDataProvider.getWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel().name());
            }
        }
    }), template.getId());
    getModel().getMigrationMode().setSelectedItem(template.getMigrationSupport());
    setupBaseTemplate(template.getBaseTemplateId());
}
#end_block

#method_before
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getName().setEntity(template.getName());
    getModel().getDescription().setEntity(template.getDescription());
    getModel().getComment().setEntity(template.getComment());
    getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
    getModel().getMinAllocatedMemory().setIsChangable(false);
    getModel().getMemSize().setEntity(template.getMemSizeMb());
    getModel().getOSType().setSelectedItem(template.getOsId());
    getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
    getModel().setBootSequence(template.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
    getModel().getIsStateless().setEntity(template.isStateless());
    getModel().getIsRunAndPause().setEntity(template.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
    getModel().selectSsoMethod(template.getSsoMethod());
    getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
    getModel().getKernel_parameters().setEntity(template.getKernelParams());
    getModel().getKernel_path().setEntity(template.getKernelUrl());
    getModel().getInitrd_path().setEntity(template.getInitrdUrl());
    getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
    updateTimeZone(template.getTimeZone());
    // Update domain list
    updateDomain();
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == template.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    updateConsoleDevice(template.getId());
    getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
    getModel().getVmInitModel().init(template);
    initPriority(template.getPriority());
    BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#method_after
private void initTemplate() {
    // Update model state according to VM properties.
    getModel().getName().setEntity(template.getName());
    getModel().getDescription().setEntity(template.getDescription());
    getModel().getComment().setEntity(template.getComment());
    getModel().getMinAllocatedMemory().setEntity(template.getMinAllocatedMem());
    getModel().getMinAllocatedMemory().setIsChangable(false);
    getModel().getMemSize().setEntity(template.getMemSizeMb());
    getModel().getOSType().setSelectedItem(template.getOsId());
    getModel().getUsbPolicy().setSelectedItem(template.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(template.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(template.isAllowConsoleReconnect());
    getModel().setBootSequence(template.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(template.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(template.getNumOfCpus()));
    getModel().getNumOfSockets().setSelectedItem(template.getNumOfSockets());
    getModel().getIsStateless().setEntity(template.isStateless());
    getModel().getIsRunAndPause().setEntity(template.isRunAndPause());
    getModel().getIsDeleteProtected().setEntity(template.isDeleteProtected());
    getModel().selectSsoMethod(template.getSsoMethod());
    getModel().getIsSmartcardEnabled().setEntity(template.isSmartcardEnabled());
    getModel().getVncKeyboardLayout().setSelectedItem(template.getVncKeyboardLayout());
    getModel().setSelectedMigrationDowntime(template.getMigrationDowntime());
    getModel().getKernel_parameters().setEntity(template.getKernelParams());
    getModel().getKernel_path().setEntity(template.getKernelUrl());
    getModel().getInitrd_path().setEntity(template.getInitrdUrl());
    getModel().getIsSingleQxlEnabled().setEntity(template.getSingleQxlPci());
    updateTimeZone(template.getTimeZone());
    // Update domain list
    updateDomain();
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == template.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    updateConsoleDevice(template.getId());
    getModel().getVmInitEnabled().setEntity(template.getVmInit() != null);
    getModel().getVmInitModel().init(template);
    getModel().getTemplateVersionName().setEntity(template.getTemplateVersionName());
    initPriority(template.getPriority());
    BuilderExecutor.build(template, getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(isHotSetCpuSupported() || !vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    updateVirtioScsiEnabled(getVm().getId(), getVm().getVmOsId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getDefaultVncKeyboardLayout());
    Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    initPriority(vm.getPriority());
    getModel().setSelectedMigrationDowntime(vm.getMigrationDowntime());
    if (isHotSetCpuSupported()) {
        // cancel related events while fetching data
        getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
        getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
        getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
        AsyncDataProvider.getHostById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ExistingVmModelBehavior existingVmModelBehavior = (ExistingVmModelBehavior) model;
                runningOnHost = (VDS) returnValue;
                hostCpu = calculateHostCpus();
                existingVmModelBehavior.updateNumOfSockets();
            }
        }), vm.getRunOnVds());
    }
    BuilderExecutor.build(vm.getStaticData(), getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#method_after
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMemSize().setIsChangable(vm.isDown());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().selectSsoMethod(vm.getSsoMethod());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(isHotSetCpuSupported() || !vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().deserialize(vm.getCustomProperties());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.getInstance().runQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    updateVirtioScsiEnabled(getVm().getId(), getVm().getVmOsId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getDefaultVncKeyboardLayout());
    Frontend.getInstance().runQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity((Boolean) ((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (EntityModel<DisplayType> model : getModel().getDisplayProtocol().getItems()) {
        DisplayType displayType = model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(model);
            break;
        }
    }
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    initPriority(vm.getPriority());
    getModel().setSelectedMigrationDowntime(vm.getMigrationDowntime());
    if (isHotSetCpuSupported()) {
        // cancel related events while fetching data
        getModel().getTotalCPUCores().getEntityChangedEvent().removeListener(getModel());
        getModel().getCoresPerSocket().getSelectedItemChangedEvent().removeListener(getModel());
        getModel().getNumOfSockets().getSelectedItemChangedEvent().removeListener(getModel());
        AsyncDataProvider.getHostById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                ExistingVmModelBehavior existingVmModelBehavior = (ExistingVmModelBehavior) model;
                runningOnHost = (VDS) returnValue;
                hostCpu = calculateHostCpus();
                existingVmModelBehavior.updateNumOfSockets();
            }
        }), vm.getRunOnVds());
    }
    BuilderExecutor.build(vm.getStaticData(), getModel(), new SerialNumberPolicyVmBaseToUnitBuilder());
}
#end_block

#method_before
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().update(spiceProxyEditor, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyEnabledCheckboxWithInfoIcon, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyOverrideEnabledEditor, simpleField().visibleInAdvancedModeOnly()).update(numOfVmsEditor, hiddenField()).update(newPoolEditVmsPanel, hiddenField()).update(newPoolEditMaxAssignedVmsPerUserPanel, hiddenField()).update(editPoolEditVmsPanel, simpleField()).update(editPoolIncraseNumOfVmsPanel, simpleField()).update(editPoolEditMaxAssignedVmsPerUserPanel, simpleField());
}
#method_after
@Override
protected PopupWidgetConfigMap createWidgetConfiguration() {
    return super.createWidgetConfiguration().update(spiceProxyEditor, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyEnabledCheckboxWithInfoIcon, simpleField().visibleInAdvancedModeOnly()).update(spiceProxyOverrideEnabledEditor, simpleField().visibleInAdvancedModeOnly()).update(numOfVmsEditor, hiddenField()).update(newPoolEditVmsPanel, hiddenField()).update(newPoolEditMaxAssignedVmsPerUserPanel, hiddenField()).update(editPoolEditVmsPanel, simpleField()).update(editPoolIncraseNumOfVmsPanel, simpleField()).update(editPoolEditMaxAssignedVmsPerUserPanel, simpleField()).update(templateVersionNameEditor, hiddenField());
}
#end_block

#method_before
private void initRadioButtonEditors() {
    // $NON-NLS-1$
    enableOvirtServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    enableGlusterServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    migrateOnErrorOption_YESEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_HA_ONLYEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_NOEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    optimizeForUtilizationEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    optimizeForSpeedEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    guarantyResourcesEditor = new EntityModelRadioButtonEditor("4");
    // $NON-NLS-1$
    allowOverbookingEditor = new EntityModelRadioButtonEditor("4");
    serialNumberPolicyEditor = new SerialNumberPolicyWidget(eventBus);
}
#method_after
private void initRadioButtonEditors() {
    // $NON-NLS-1$
    enableOvirtServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    enableGlusterServiceOptionEditor = new EntityModelRadioButtonEditor("service");
    // $NON-NLS-1$
    optimizationNoneEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForServerEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationForDesktopEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    optimizationCustomEditor = new EntityModelRadioButtonEditor("1");
    // $NON-NLS-1$
    migrateOnErrorOption_YESEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_HA_ONLYEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    migrateOnErrorOption_NOEditor = new EntityModelRadioButtonEditor("2");
    // $NON-NLS-1$
    optimizeForUtilizationEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    optimizeForSpeedEditor = new EntityModelRadioButtonEditor("3");
    // $NON-NLS-1$
    guarantyResourcesEditor = new EntityModelRadioButtonEditor("4");
    // $NON-NLS-1$
    allowOverbookingEditor = new EntityModelRadioButtonEditor("4");
    serialNumberPolicyEditor = new SerialNumberPolicyWidget(eventBus, templates, messages, resources, new VisibilityRenderer.SimpleVisibilityRenderer());
}
#end_block

#method_before
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getCPU().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isCpuNameBlank = object.getCPU().getSelectedItem() == null;
            architectureEditor.setVisible(isCpuNameBlank);
        }
    });
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
}
#method_after
@Override
public void edit(final ClusterModel object) {
    driver.edit(object);
    customPropertiesSheetEditor.edit(object.getCustomPropertySheet());
    servicesCheckboxPanel.setVisible(object.getAllowClusterWithVirtGlusterEnabled());
    servicesRadioPanel.setVisible(!object.getAllowClusterWithVirtGlusterEnabled());
    serialNumberPolicyEditor.edit(object.getSerialNumberPolicy());
    optimizationForServerFormatter(object);
    optimizationForDesktopFormatter(object);
    optimizationCustomFormatter(object);
    object.getOptimizationForServer().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForServerFormatter(object);
        }
    });
    object.getOptimizationForDesktop().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            optimizationForDesktopFormatter(object);
        }
    });
    object.getOptimizationCustom_IsSelected().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getOptimizationCustom_IsSelected().getEntity()) {
                optimizationCustomFormatter(object);
                optimizationCustomEditor.setVisible(true);
            }
        }
    });
    object.getDataCenter().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            resiliencePolicyTab.setVisible(object.getisResiliencePolicyTabAvailable());
            applyModeCustomizations();
        }
    });
    object.getEnableGlusterService().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
        }
    });
    importGlusterExplanationLabel.setVisible(object.getEnableGlusterService().getEntity() && object.getIsNew());
    object.getCPU().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isCpuNameBlank = object.getCPU().getSelectedItem() == null;
            architectureEditor.setVisible(isCpuNameBlank);
        }
    });
    object.getVersionSupportsCpuThreads().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            cpuThreadsPanel.setVisible(object.getVersionSupportsCpuThreads().getEntity());
        }
    });
    schedulerOptimizationInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getSchedulerOptimizationInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingInfoIcon.setText(SafeHtmlUtils.fromTrustedString(// $NON-NLS-1$
    templates.italicFixedWidth(// $NON-NLS-1$
    "350px", object.getAllowOverbookingInfoMessage()).asString().replaceAll("(\r\n|\n)", // $NON-NLS-1$ //$NON-NLS-2$
    "<br />")));
    allowOverbookingPanel.setVisible(allowOverbookingEditor.isVisible());
    object.getVersion().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getVersion().getSelectedItem() != null) {
                String clusterVersion = object.getVersion().getSelectedItem().getValue();
                serialNumberPolicyEditor.setVisible(AsyncDataProvider.isSerialNumberPolicySupported(clusterVersion));
            }
        }
    });
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
    updateWatchdogModels();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMigrationOptions();
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
    updateWatchdogModels();
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid();
}
#method_after
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && getIsAutoAssign().getEntity() == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    getMigrationDowntime().validateEntity(new IValidation[] { new NotNullIntegerValidation(0, Integer.MAX_VALUE) });
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty(getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty(getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty(getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    if (getSerialNumberPolicy().getSelectedSerialNumberPolicy() == SerialNumberPolicy.CUSTOM) {
        getSerialNumberPolicy().getCustomSerialNumber().validateEntity(new IValidation[] { new NotEmptyValidation() });
    } else {
        getSerialNumberPolicy().getCustomSerialNumber().setIsValid(true);
    }
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    boolean behaviorValid = behavior.validate();
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid() && getSpiceProxy().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid() && getMigrationDowntime().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behaviorValid && customPropertySheetValid && getQuota().getIsValid() && getMigrationDowntime().getIsValid() && getSerialNumberPolicy().getCustomSerialNumber().getIsValid();
}
#end_block

#method_before
private void initTextBoxEditors() {
    descriptionEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    commentEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    numOfVmsEditor = new IntegerEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    cpuPinning = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    kernel_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    initrd_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    kernel_parametersEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    nameEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    prestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editPrestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    maxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editMaxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
}
#method_after
private void initTextBoxEditors() {
    templateVersionNameEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    descriptionEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    commentEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    numOfVmsEditor = new IntegerEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    cpuPinning = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    kernel_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    initrd_pathEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    kernel_parametersEditor = new StringEntityModelTextBoxEditor(new ModeSwitchingVisibilityRenderer());
    nameEditor = new StringEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    prestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editPrestartedVmsEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    maxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    editMaxAssignedVmsPerUserEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages));
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
private void initListBoxEditors() {
    // General tab
    dataCenterWithClusterEditor = new ListModelTypeAheadListBoxEditor<DataCenterWithCluster>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<DataCenterWithCluster>() {

        @Override
        public String getReplacementStringNullSafe(DataCenterWithCluster data) {
            return // $NON-NLS-1$
            data.getCluster().getName() + "/" + data.getDataCenter().getName();
        }

        @Override
        public String getDisplayStringNullSafe(DataCenterWithCluster data) {
            String dcDescription = data.getDataCenter().getdescription();
            return typeAheadNameDescriptionTemplateNullSafe(data.getCluster().getName(), !StringHelper.isNullOrEmpty(dcDescription) ? dcDescription : data.getDataCenter().getName());
        }
    }, new ModeSwitchingVisibilityRenderer());
    quotaEditor = new ListModelTypeAheadListBoxEditor<Quota>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<Quota>() {

        @Override
        public String getReplacementStringNullSafe(Quota data) {
            return data.getQuotaName();
        }

        @Override
        public String getDisplayStringNullSafe(Quota data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getQuotaName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    baseTemplateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return data.getName();
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(data.getName(), data.getDescription());
        }
    }, new ModeSwitchingVisibilityRenderer());
    templateEditor = new ListModelTypeAheadListBoxEditor<VmTemplate>(new ListModelTypeAheadListBoxEditor.NullSafeSuggestBoxRenderer<VmTemplate>() {

        @Override
        public String getReplacementStringNullSafe(VmTemplate data) {
            return getDisplayableTemplateVersionName(data);
        }

        @Override
        public String getDisplayStringNullSafe(VmTemplate data) {
            return typeAheadNameDescriptionTemplateNullSafe(getDisplayableTemplateVersionName(data), data.getDescription());
        }

        private String getDisplayableTemplateVersionName(VmTemplate template) {
            String versionName = template.getTemplateVersionName();
            if (ConstantsManager.getInstance().getConstants().latestTemplateVersionName().equals(versionName)) {
                return constants.latest();
            }
            versionName = template.getId().equals(template.getBaseTemplateId()) ? constants.baseTemplate() : template.getTemplateVersionName();
            return // $NON-NLS-1$
            (versionName == null ? "" : versionName) + // $NON-NLS-1$
            StringFormat.format(" (%d)", template.getTemplateVersionNumber());
        }
    }, new ModeSwitchingVisibilityRenderer());
    oSTypeEditor = new ListModelListBoxEditor<Integer>(new AbstractRenderer<Integer>() {

        @Override
        public String render(Integer object) {
            return AsyncDataProvider.getOsName(object);
        }
    }, new ModeSwitchingVisibilityRenderer());
    vmTypeEditor = new ListModelListBoxEditor<VmType>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfSocketsEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    corePerSocketEditor = new ListModelListBoxEditor<Integer>(new ModeSwitchingVisibilityRenderer());
    // Pools
    poolTypeEditor = new ListModelListBoxEditor<EntityModel<VmPoolType>>(new NullSafeRenderer<EntityModel<VmPoolType>>() {

        @Override
        public String renderNullSafe(EntityModel<VmPoolType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Windows Sysprep
    domainEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    timeZoneEditor = new ListModelListBoxEditor<TimeZoneModel>(new NullSafeRenderer<TimeZoneModel>() {

        @Override
        public String renderNullSafe(TimeZoneModel timeZone) {
            if (timeZone.isDefault()) {
                return messages.defaultTimeZoneCaption(timeZone.getDisplayValue());
            } else {
                return timeZone.getDisplayValue();
            }
        }
    }, new ModeSwitchingVisibilityRenderer());
    // Console tab
    displayProtocolEditor = new ListModelListBoxEditor<EntityModel<DisplayType>>(new NullSafeRenderer<EntityModel<DisplayType>>() {

        @Override
        public String renderNullSafe(EntityModel<DisplayType> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    usbSupportEditor = new ListModelListBoxEditor<UsbPolicy>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    numOfMonitorsEditor = new ListModelListBoxEditor<Integer>(new NullSafeRenderer<Integer>() {

        @Override
        public String renderNullSafe(Integer object) {
            return object.toString();
        }
    }, new ModeSwitchingVisibilityRenderer());
    vncKeyboardLayoutEditor = new ListModelListBoxEditor<String>(new VncKeyMapRenderer(messages), new ModeSwitchingVisibilityRenderer());
    // Host Tab
    // $NON-NLS-1$
    specificHost = new RadioButton("runVmOnHostGroup");
    isAutoAssignEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("runVmOnHostGroup", new ModeSwitchingVisibilityRenderer());
    defaultHostEditor = new ListModelListBoxEditor<VDS>(new NullSafeRenderer<VDS>() {

        @Override
        public String renderNullSafe(VDS object) {
            return object.getName();
        }
    }, new ModeSwitchingVisibilityRenderer());
    migrationModeEditor = new ListModelListBoxEditor<MigrationSupport>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
    overrideMigrationDowntimeEditor = new EntityModelCheckBoxOnlyEditor(new ModeSwitchingVisibilityRenderer(), false);
    migrationDowntimeEditor = new IntegerEntityModelTextBoxOnlyEditor(new ModeSwitchingVisibilityRenderer());
    // Resource Allocation
    provisioningThinEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    provisioningCloneEditor = // $NON-NLS-1$
    new EntityModelRadioButtonEditor("provisioningGroup", new ModeSwitchingVisibilityRenderer());
    // Boot Options Tab
    firstBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    secondBootDeviceEditor = new ListModelListBoxEditor<EntityModel<BootSequence>>(new NullSafeRenderer<EntityModel<BootSequence>>() {

        @Override
        public String renderNullSafe(EntityModel<BootSequence> object) {
            return object.getTitle();
        }
    }, new ModeSwitchingVisibilityRenderer());
    cdImageEditor = new ListModelListBoxEditor<String>(new NullSafeRenderer<String>() {

        @Override
        public String renderNullSafe(String object) {
            return object;
        }
    }, new ModeSwitchingVisibilityRenderer());
    cpuSharesAmountSelectionEditor = new ListModelListBoxOnlyEditor<UnitVmModel.CpuSharesAmount>(new EnumRenderer(), new ModeSwitchingVisibilityRenderer());
}
#end_block

#method_before
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
}
#method_after
protected void localize(CommonApplicationConstants constants) {
    // Tabs
    highAvailabilityTab.setLabel(constants.highAvailVmPopup());
    resourceAllocationTab.setLabel(constants.resourceAllocVmPopup());
    bootOptionsTab.setLabel(constants.bootOptionsVmPopup());
    customPropertiesTab.setLabel(constants.customPropsVmPopup());
    systemTab.setLabel(constants.systemVmPopup());
    // General Tab
    generalTab.setLabel(constants.GeneralVmPopup());
    dataCenterWithClusterEditor.setLabel(constants.hostClusterVmPopup());
    quotaEditor.setLabel(constants.quotaVmPopup());
    nameLabel.setText(constants.nameVmPopup());
    templateVersionNameEditor.setLabel(constants.templateVersionName());
    descriptionEditor.setLabel(constants.descriptionVmPopup());
    commentEditor.setLabel(constants.commentLabel());
    baseTemplateEditor.setLabel(constants.basedOnTemplateVmPopup());
    templateEditor.setLabel(constants.templateSubVersion());
    oSTypeEditor.setLabel(constants.osVmPopup());
    vmTypeEditor.setLabel(constants.optimizedFor());
    isStatelessEditor.setLabel(constants.statelessVmPopup());
    isRunAndPauseEditor.setLabel(constants.runAndPauseVmPopup());
    isDeleteProtectedEditor.setLabel(constants.deleteProtectionPopup());
    isConsoleDeviceEnabledEditor.setLabel(constants.consoleDeviceEnabled());
    copyTemplatePermissionsEditor.setLabel(constants.copyTemplatePermissions());
    isSmartcardEnabledEditor.setLabel(constants.smartcardVmPopup());
    isMemoryBalloonDeviceEnabled.setLabel(constants.memoryBalloonDeviceEnabled());
    isVirtioScsiEnabled.setLabel(constants.isVirtioScsiEnabled());
    // Pools Tab
    poolTab.setLabel(constants.poolVmPopup());
    poolTypeEditor.setLabel(constants.poolTypeVmPopup());
    editPrestartedVmsLabel.setText(constants.prestartedVms());
    prestartedLabel.setText(constants.prestartedPoolPopup());
    numOfVmsEditor.setLabel(constants.numOfVmsPoolPopup());
    maxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    editMaxAssignedVmsPerUserEditor.setLabel(constants.maxAssignedVmsPerUser());
    // initial run Tab
    initialRunTab.setLabel(constants.initialRunVmPopup());
    domainEditor.setLabel(constants.domainVmPopup());
    timeZoneEditor.setLabel(constants.tzVmPopup());
    vmInitEnabledEditor.setLabel(constants.cloudInitOrSysprep());
    // Console Tab
    consoleTab.setLabel(constants.consoleVmPopup());
    displayProtocolEditor.setLabel(constants.protocolVmPopup());
    vncKeyboardLayoutEditor.setLabel(constants.vncKeyboardLayoutVmPopup());
    usbSupportEditor.setLabel(constants.usbPolicyVmPopup());
    numOfMonitorsEditor.setLabel(constants.monitorsVmPopup());
    allowConsoleReconnectEditor.setLabel(constants.allowConsoleReconnect());
    isSoundcardEnabledEditor.setLabel(constants.soundcardEnabled());
    isSingleQxlEnabledEditor.setLabel(constants.singleQxlEnabled());
    ssoMethodNone.setLabel(constants.none());
    ssoMethodGuestAgent.setLabel(constants.guestAgent());
    spiceProxyEditor.setLabel(constants.overriddenSpiceProxyAddress());
    // Host Tab
    hostTab.setLabel(constants.hostVmPopup());
    isAutoAssignEditor.setLabel(constants.anyHostInClusterVmPopup());
    // specificHostEditor.setLabel("Specific");
    hostCpuEditor.setLabel(constants.useHostCpu());
    cpuPinning.setLabel(constants.cpuPinningLabel());
    // High Availability Tab
    isHighlyAvailableEditor.setLabel(constants.highlyAvailableVmPopup());
    // watchdog
    watchdogActionEditor.setLabel(constants.watchdogAction());
    watchdogModelEditor.setLabel(constants.watchdogModel());
    // Resource Allocation Tab
    provisioningEditor.setLabel(constants.templateProvisVmPopup());
    provisioningThinEditor.setLabel(constants.thinVmPopup());
    provisioningCloneEditor.setLabel(constants.cloneVmPopup());
    minAllocatedMemoryEditor.setLabel(constants.physMemGuarVmPopup());
    // Boot Options
    firstBootDeviceEditor.setLabel(constants.firstDeviceVmPopup());
    secondBootDeviceEditor.setLabel(constants.secondDeviceVmPopup());
    kernel_pathEditor.setLabel(constants.kernelPathVmPopup());
    initrd_pathEditor.setLabel(constants.initrdPathVmPopup());
    kernel_parametersEditor.setLabel(constants.kernelParamsVmPopup());
    // System tab
    memSizeEditor.setLabel(constants.memSizeVmPopup());
    corePerSocketEditor.setLabel(constants.coresPerSocket());
    numOfSocketsEditor.setLabel(constants.numOfSockets());
}
#end_block

#method_before
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                boolean sysprepEnabled = object.getSysprepEnabled().getEntity();
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
                domainEditor.setVisible(sysprepEnabled);
            }
        }
    });
}
#method_after
protected void initListeners(final UnitVmModel object) {
    // TODO should be handled by the core framework
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("IsHostTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsHostTabValid()) {
                    hostTab.markAsValid();
                } else {
                    hostTab.markAsInvalid(null);
                }
            } else if ("IsCustomPropertiesTabAvailable".equals(propName)) {
                // $NON-NLS-1$
                setupCustomPropertiesAvailability(object);
            } else if ("IsDisksAvailable".equals(propName)) {
                // $NON-NLS-1$
                addDiskAllocation(object);
            }
        }
    });
    object.getIsAutoAssign().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isAutoAssign = object.getIsAutoAssign().getEntity();
            defaultHostEditor.setEnabled(!isAutoAssign);
            // only this is not bind to the model, so needs to listen to the change explicitly
            specificHost.setValue(!isAutoAssign);
        }
    });
    object.getProvisioning().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            boolean isProvisioningChangable = object.getProvisioning().getIsChangable();
            provisioningThinEditor.setEnabled(isProvisioningChangable);
            provisioningCloneEditor.setEnabled(isProvisioningChangable);
            boolean isProvisioningAvailable = object.getProvisioning().getIsAvailable();
            changeApplicationLevelVisibility(provisionSelectionPanel, isProvisioningAvailable);
            boolean isDisksAvailable = object.getIsDisksAvailable();
            changeApplicationLevelVisibility(disksAllocationPanel, isDisksAvailable);
            changeApplicationLevelVisibility(storageAllocationPanel, isProvisioningAvailable || isDisksAvailable || object.getIsVirtioScsiEnabled().getIsAvailable());
        }
    });
    object.getIsVirtioScsiEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "IsAvailable") {
                // $NON-NLS-1$
                isVirtioScsiEnabledInfoIcon.setVisible(object.getIsVirtioScsiEnabled().getIsAvailable());
            }
        }
    });
    object.getUsbPolicy().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.propertyName == "SelectedItem") {
                // $NON-NLS-1$
                updateUsbNativeMessageVisibility(object);
            }
        }
    });
    updateUsbNativeMessageVisibility(object);
    object.getEditingEnabled().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Boolean enabled = object.getEditingEnabled().getEntity();
            if (Boolean.FALSE.equals(enabled)) {
                disableAllTabs();
                generalWarningMessage.setText(object.getEditingEnabled().getMessage());
            }
        }
    });
    object.getCpuSharesAmountSelection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if ("IsAvailable".equals(((PropertyChangedEventArgs) args).propertyName)) {
                // $NON-NLS-1$
                changeApplicationLevelVisibility(cpuSharesEditor, object.getCpuSharesAmountSelection().getIsAvailable());
            }
        }
    });
    object.getCloudInitEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getCloudInitEnabled().getEntity() != null) {
                vmInitEditor.setCloudInitContentVisible(object.getCloudInitEnabled().getEntity());
            }
        }
    });
    object.getSysprepEnabled().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (object.getSysprepEnabled().getEntity() != null) {
                boolean sysprepEnabled = object.getSysprepEnabled().getEntity();
                vmInitEditor.setSyspepContentVisible(object.getSysprepEnabled().getEntity());
                domainEditor.setVisible(sysprepEnabled);
            }
        }
    });
    object.getDataCenterWithClustersList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            VDSGroup vdsGroup = object.getSelectedCluster();
            if (vdsGroup != null && vdsGroup.getcompatibility_version() != null) {
                boolean enabled = AsyncDataProvider.isSerialNumberPolicySupported(vdsGroup.getcompatibility_version().getValue());
                changeApplicationLevelVisibility(serialNumberPolicyEditor, enabled);
            }
        }
    });
}
#end_block

#method_before
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    nextTabIndex = generalTab.setTabIndexes(nextTabIndex);
    quotaEditor.setTabIndex(nextTabIndex++);
    oSTypeEditor.setTabIndex(nextTabIndex++);
    baseTemplateEditor.setTabIndex(nextTabIndex++);
    templateEditor.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    templateVersionNameEditor.setTabIndex(nextTabIndex++);
    descriptionEditor.setTabIndex(nextTabIndex++);
    commentEditor.setTabIndex(nextTabIndex++);
    isStatelessEditor.setTabIndex(nextTabIndex++);
    isRunAndPauseEditor.setTabIndex(nextTabIndex++);
    isDeleteProtectedEditor.setTabIndex(nextTabIndex++);
    copyTemplatePermissionsEditor.setTabIndex(nextTabIndex++);
    numOfVmsEditor.setTabIndex(nextTabIndex++);
    prestartedVmsEditor.setTabIndex(nextTabIndex++);
    editPrestartedVmsEditor.setTabIndex(nextTabIndex++);
    incraseNumOfVmsEditor.setTabIndex(nextTabIndex++);
    maxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    editMaxAssignedVmsPerUserEditor.setTabIndex(nextTabIndex++);
    // ==System Tab==
    nextTabIndex = systemTab.setTabIndexes(nextTabIndex);
    memSizeEditor.setTabIndex(nextTabIndex++);
    totalvCPUsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = vcpusAdvancedParameterExpander.setTabIndexes(nextTabIndex);
    corePerSocketEditor.setTabIndex(nextTabIndex++);
    numOfSocketsEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = serialNumberPolicyEditor.setTabIndexes(nextTabIndex);
    // == Pools ==
    nextTabIndex = poolTab.setTabIndexes(nextTabIndex);
    poolTypeEditor.setTabIndex(nextTabIndex++);
    // ==Initial run Tab==
    nextTabIndex = initialRunTab.setTabIndexes(nextTabIndex);
    timeZoneEditor.setTabIndex(nextTabIndex++);
    domainEditor.setTabIndex(nextTabIndex++);
    // ==Console Tab==
    nextTabIndex = consoleTab.setTabIndexes(nextTabIndex);
    displayProtocolEditor.setTabIndex(nextTabIndex++);
    vncKeyboardLayoutEditor.setTabIndex(nextTabIndex++);
    usbSupportEditor.setTabIndex(nextTabIndex++);
    isSingleQxlEnabledEditor.setTabIndex(nextTabIndex++);
    numOfMonitorsEditor.setTabIndex(nextTabIndex++);
    isSmartcardEnabledEditor.setTabIndex(nextTabIndex++);
    ssoMethodNone.setTabIndex(nextTabIndex++);
    ssoMethodGuestAgent.setTabIndex(nextTabIndex++);
    nextTabIndex = expander.setTabIndexes(nextTabIndex);
    allowConsoleReconnectEditor.setTabIndex(nextTabIndex++);
    isSoundcardEnabledEditor.setTabIndex(nextTabIndex++);
    isConsoleDeviceEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyOverrideEnabledEditor.setTabIndex(nextTabIndex++);
    spiceProxyEditor.setTabIndex(nextTabIndex++);
    // ==Host Tab==
    nextTabIndex = hostTab.setTabIndexes(nextTabIndex);
    isAutoAssignEditor.setTabIndex(nextTabIndex++);
    specificHost.setTabIndex(nextTabIndex++);
    defaultHostEditor.setTabIndex(nextTabIndex++);
    migrationModeEditor.setTabIndex(nextTabIndex++);
    overrideMigrationDowntimeEditor.setTabIndex(nextTabIndex++);
    migrationDowntimeEditor.setTabIndex(nextTabIndex++);
    hostCpuEditor.setTabIndex(nextTabIndex++);
    // ==High Availability Tab==
    nextTabIndex = highAvailabilityTab.setTabIndexes(nextTabIndex);
    isHighlyAvailableEditor.setTabIndex(nextTabIndex++);
    priorityEditor.setTabIndex(nextTabIndex++);
    watchdogModelEditor.setTabIndex(nextTabIndex++);
    watchdogActionEditor.setTabIndex(nextTabIndex++);
    // ==Resource Allocation Tab==
    nextTabIndex = resourceAllocationTab.setTabIndexes(nextTabIndex);
    minAllocatedMemoryEditor.setTabIndex(nextTabIndex++);
    provisioningEditor.setTabIndex(nextTabIndex++);
    provisioningThinEditor.setTabIndex(nextTabIndex++);
    provisioningCloneEditor.setTabIndex(nextTabIndex++);
    cpuPinning.setTabIndex(nextTabIndex++);
    cpuSharesAmountEditor.setTabIndex(nextTabIndex++);
    nextTabIndex = disksAllocationView.setTabIndexes(nextTabIndex);
    // ==Boot Options Tab==
    nextTabIndex = bootOptionsTab.setTabIndexes(nextTabIndex);
    firstBootDeviceEditor.setTabIndex(nextTabIndex++);
    secondBootDeviceEditor.setTabIndex(nextTabIndex++);
    cdAttachedEditor.setTabIndex(nextTabIndex++);
    cdImageEditor.setTabIndex(nextTabIndex++);
    kernel_pathEditor.setTabIndex(nextTabIndex++);
    initrd_pathEditor.setTabIndex(nextTabIndex++);
    kernel_parametersEditor.setTabIndex(nextTabIndex++);
    // ==Custom Properties Tab==
    nextTabIndex = customPropertiesTab.setTabIndexes(nextTabIndex);
    return nextTabIndex;
}
#end_block

#method_before
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assert (oldDisk.getDiskInterface() != parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit();
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#method_after
@Test
public void testUpdateDiskInterfaceUnsupported() {
    final UpdateVmDiskParameters parameters = createParameters();
    parameters.getDiskInfo().setDiskInterface(DiskInterface.IDE);
    when(diskDao.get(diskImageGuid)).thenAnswer(new Answer() {

        @Override
        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {
            final DiskImage oldDisk = createDiskImage();
            oldDisk.setDiskInterface(DiskInterface.VirtIO);
            assert (oldDisk.getDiskInterface() != parameters.getDiskInfo().getDiskInterface());
            return oldDisk;
        }
    });
    initializeCommand(parameters);
    doReturn(true).when(command).validatePciAndIdeLimit(any(List.class));
    when(diskValidator.isReadOnlyPropertyCompatibleWithInterface()).thenReturn(ValidationResult.VALID);
    when(diskValidator.isDiskInterfaceSupported(any(VM.class))).thenReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED));
    when(diskValidator.isVirtIoScsiValid(any(VM.class))).thenReturn(ValidationResult.VALID);
    when(command.getDiskValidator(any(Disk.class))).thenReturn(diskValidator);
    VmDevice device = createVmDevice(diskImageGuid, vmId);
    doReturn(device).when(vmDeviceDAO).get(device.getId());
    command.executeVmCommand();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_DISK_INTERFACE_UNSUPPORTED.toString()));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown() && updateRuntimeParametersRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit()) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm())) && validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface()) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm())));
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !isDiskExist(getOldDisk())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!vmsDiskOrSnapshotPluggedTo.isEmpty()) {
        // only virtual drive size can be updated when VMs is running
        if (isAtLeastOneVmIsNotDown(vmsDiskOrSnapshotPluggedTo) && updateParametersRequiringVmDownRequested()) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        }
        boolean isUpdatedAsBootable = !getOldDisk().isBoot() && getNewDisk().isBoot();
        // multiple boot disk snapshot can be attached to a single vm
        if (isUpdatedAsBootable && !validate(noVmsContainBootableDisks(vmsDiskPluggedTo))) {
            return false;
        }
        boolean isDiskInterfaceUpdated = getOldDisk().getDiskInterface() != getNewDisk().getDiskInterface();
        if (isDiskInterfaceUpdated && !validatePciAndIdeLimit(vmsDiskOrSnapshotPluggedTo)) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getOldDisk().getDiskStorageType() && !validateCanResizeDisk()) {
        return false;
    }
    DiskValidator diskValidator = getDiskValidator(getNewDisk());
    return validateCanUpdateShareable() && validateCanUpdateReadOnly() && validate(diskValidator.isVirtIoScsiValid(getVm())) && validate(diskValidator.isReadOnlyPropertyCompatibleWithInterface()) && (getOldDisk().getDiskInterface() == getNewDisk().getDiskInterface() || validate(diskValidator.isDiskInterfaceSupported(getVm())));
}
#end_block

#method_before
protected boolean validatePciAndIdeLimit() {
    for (VM vm : vmsDiskPluggedTo) {
        List<VmNic> allVmInterfaces = getVmNicDao().getAllForVm(vm.getId());
        List<Disk> allVmDisks = new LinkedList<>(getOtherVmDisks(vm.getId()));
        allVmDisks.add(getNewDisk());
        if (!checkPciAndIdeLimit(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), vm.getNumOfMonitors(), allVmInterfaces, allVmDisks, VmDeviceUtils.isVirtioScsiControllerAttached(vm.getId()), VmDeviceUtils.hasWatchdog(vm.getId()), VmDeviceUtils.isBalloonEnabled(vm.getId()), VmDeviceUtils.isSoundDeviceEnabled(vm.getId()), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#method_after
protected boolean validatePciAndIdeLimit(List<VM> vmsDiskPluggedTo) {
    for (VM vm : vmsDiskPluggedTo) {
        List<VmNic> allVmInterfaces = getVmNicDao().getAllForVm(vm.getId());
        List<Disk> allVmDisks = new LinkedList<>(getOtherVmDisks(vm.getId()));
        allVmDisks.add(getNewDisk());
        if (!checkPciAndIdeLimit(vm.getOs(), vm.getVdsGroupCompatibilityVersion(), vm.getNumOfMonitors(), allVmInterfaces, allVmDisks, VmDeviceUtils.isVirtioScsiControllerAttached(vm.getId()), VmDeviceUtils.hasWatchdog(vm.getId()), VmDeviceUtils.isBalloonEnabled(vm.getId()), VmDeviceUtils.isSoundDeviceEnabled(vm.getId()), getReturnValue().getCanDoActionMessages())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isAtLeastOneVmIsNotDown() {
    for (VM vm : vmsDiskPluggedTo) {
        if (vm.getStatus() != VMStatus.Down) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isAtLeastOneVmIsNotDown(List<VM> vmsDiskPluggedTo) {
    for (VM vm : vmsDiskPluggedTo) {
        if (vm.getStatus() != VMStatus.Down) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
protected void destroyVm() {
    if (getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(getVm().getMigratingToVds().toString()), getVmId(), true, false, 0));
    }
    if (getVm().getStatus() == VMStatus.Paused) {
        VmStatic vmStatic = getVm().getStaticData();
        decreasePendingVms(getVm().getRunOnVds(), vmStatic.getNumOfCpus(), vmStatic.getMinAllocatedMem(), vmStatic.getName());
    }
    setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVdsId(), getVmId(), false, false, 0)).getReturnValue());
}
#method_after
protected void destroyVm() {
    boolean wasPaused = (getVm().getStatus() == VMStatus.Paused && getVm().getVmPauseStatus() == VmPauseStatus.NOERR);
    if (getVm().getStatus() == VMStatus.MigratingFrom && getVm().getMigratingToVds() != null) {
        Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(new Guid(getVm().getMigratingToVds().toString()), getVmId(), true, false, 0));
    }
    setActionReturnValue(Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DestroyVm, new DestroyVmVDSCommandParameters(getVdsId(), getVmId(), false, false, 0)).getReturnValue());
    if (wasPaused) {
        VmHandler.decreasePendingVms(getVm(), getVdsId());
    }
}
#end_block

#method_before
@Override
public void rerun() {
    decreasePendingVms(getCurrentVdsId());
    setSucceeded(false);
    setVm(null);
    // by default, if rerun is called then rerun process is about to start so log the result of the
    // previous run as if rerun is about to begin (and change it later in case rerun isn't going to happen)
    _isRerun = true;
    log();
    // set _isRerun flag to false so that we'll be able to know if
    // there is another rerun attempt within the method
    _isRerun = false;
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>getValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getStatus() != VMStatus.Paused) {
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        insertAsyncTaskPlaceHolders();
        executeAction();
        // wasn't done because canDoAction check returned false..
        if (!_isRerun && !getReturnValue().getCanDoAction()) {
            runningFailed();
        }
        // signal the caller that a rerun was made
        _isRerun = true;
    } else {
        runningFailed();
    }
}
#method_after
@Override
public void rerun() {
    decreasePendingVms();
    setSucceeded(false);
    setVm(null);
    // by default, if rerun is called then rerun process is about to start so log the result of the
    // previous run as if rerun is about to begin (and change it later in case rerun isn't going to happen)
    _isRerun = true;
    log();
    // set _isRerun flag to false so that we'll be able to know if
    // there is another rerun attempt within the method
    _isRerun = false;
    /**
     * Rerun VM only if not exceeded maximum rerun attempts. for example if there are 10 hosts that can run VM and
     * predefine maximum 3 attempts to rerun VM - on 4th turn vm will stop to run despite there are still available
     * hosts to run it DO NOT TRY TO RERUN IF RESUME FAILED.
     */
    if (getRunVdssList().size() < Config.<Integer>getValue(ConfigValues.MaxRerunVmOnVdsCount) && getVm().getStatus() != VMStatus.Paused) {
        // restore CanDoAction value to false so CanDoAction checks will run again
        getReturnValue().setCanDoAction(false);
        if (getExecutionContext() != null) {
            Job job = getExecutionContext().getJob();
            if (job != null) {
                // mark previous steps as fail
                JobRepositoryFactory.getJobRepository().closeCompletedJobSteps(job.getId(), JobExecutionStatus.FAILED);
            }
        }
        insertAsyncTaskPlaceHolders();
        executeAction();
        // wasn't done because canDoAction check returned false..
        if (!_isRerun && !getReturnValue().getCanDoAction()) {
            runningFailed();
        }
        // signal the caller that a rerun was made
        _isRerun = true;
    } else {
        runningFailed();
    }
}
#end_block

#method_before
protected void runningFailed() {
    try {
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        _isRerun = false;
        setSucceeded(false);
        log();
        processVmPoolOnStopVm();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), false);
    } finally {
        freeLock();
    }
}
#method_after
protected void runningFailed() {
    try {
        decreasePendingVms();
        Backend.getInstance().getResourceManager().RemoveAsyncRunningCommand(getVmId());
        _isRerun = false;
        setSucceeded(false);
        log();
        processVmPoolOnStopVm();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), false);
    } finally {
        freeLock();
    }
}
#end_block

#method_before
@Override
public void runningSucceded() {
    try {
        setSucceeded(true);
        setActionReturnValue(VMStatus.Up);
        log();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), true);
        notifyHostsVmFailed();
        if (getVm().getLastVdsRunOn() == null || !getVm().getLastVdsRunOn().equals(getCurrentVdsId())) {
            getVm().setLastVdsRunOn(getCurrentVdsId());
        }
        if (StringUtils.isNotEmpty(getVm().getHibernationVolHandle())) {
            removeVmHibernationVolumes();
            // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
            // this method (which is a part of the cached VM command,
            // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
            // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
            // status to up.
            getVm().setStatus(VMStatus.Up);
            getVm().setHibernationVolHandle(null);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
        }
    } finally {
        freeLock();
    }
}
#method_after
@Override
public void runningSucceded() {
    try {
        decreasePendingVms();
        setSucceeded(true);
        setActionReturnValue(VMStatus.Up);
        log();
        ExecutionHandler.setAsyncJob(getExecutionContext(), false);
        ExecutionHandler.endJob(getExecutionContext(), true);
        notifyHostsVmFailed();
        if (getVm().getLastVdsRunOn() == null || !getVm().getLastVdsRunOn().equals(getCurrentVdsId())) {
            getVm().setLastVdsRunOn(getCurrentVdsId());
        }
        if (StringUtils.isNotEmpty(getVm().getHibernationVolHandle())) {
            removeVmHibernationVolumes();
            // In order to prevent a race where VdsUpdateRuntimeInfo saves the Vm Dynamic as UP prior to execution of
            // this method (which is a part of the cached VM command,
            // so the state this method is aware to is RESTORING, in case of RunVmCommand after the VM got suspended.
            // In addition, as the boolean return value of HandleHIbernateVm is ignored here, it is safe to set the
            // status to up.
            getVm().setStatus(VMStatus.Up);
            getVm().setHibernationVolHandle(null);
            Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.UpdateVmDynamicData, new UpdateVmDynamicDataVDSCommandParameters(getCurrentVdsId(), getVm().getDynamicData()));
        }
    } finally {
        freeLock();
    }
}
#end_block

#method_before
@Override
public void reportCompleted() {
    try {
        ExecutionContext executionContext = getExecutionContext();
        if (executionContext != null && executionContext.isMonitored() && !executionContext.isCompleted()) {
            endExecutionMonitoring();
        }
    } finally {
        freeLock();
    }
}
#method_after
@Override
public final void reportCompleted() {
    try {
        ExecutionContext executionContext = getExecutionContext();
        if (executionContext != null && executionContext.isMonitored() && !executionContext.isCompleted()) {
            endExecutionMonitoring();
        }
    } finally {
        freeLock();
    }
}
#end_block

#method_before
@Override
public void onPowerringUp() {
    VmStatic vmStatic = getVmStaticDAO().get(getVmId());
    decreasePendingVms(getCurrentVdsId(), vmStatic.getNumOfCpus(), vmStatic.getMinAllocatedMem(), vmStatic.getName());
}
#method_after
@Override
public void onPowerringUp() {
    VmStatic vmStatic = getVmStaticDAO().get(getVmId());
    VmHandler.decreasePendingVms(getCurrentVdsId(), vmStatic.getNumOfCpus(), vmStatic.getMinAllocatedMem(), vmStatic.getName());
}
#end_block

#method_before
@Override
protected void writeGeneralData() {
    super.writeGeneralData();
    _writer.WriteStartElement("Name");
    _writer.WriteRaw(_vmTemplate.getName());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateId");
    _writer.WriteRaw(_vmTemplate.getId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("Origin");
    _writer.WriteRaw(_vmTemplate.getOrigin() == null ? "" : String.valueOf(_vmTemplate.getOrigin().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("default_display_type");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getDefaultDisplayType().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("IsDisabled");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isDisabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TrustedService");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isTrustedService()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateType");
    _writer.WriteRaw(_vmTemplate.getTemplateType().name());
    _writer.WriteEndElement();
    _writer.WriteStartElement("BaseTemplateId");
    _writer.WriteRaw(_vmTemplate.getBaseTemplateId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateVersionNumber");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getTemplateVersionNumber()));
    _writer.WriteEndElement();
    _writer.WriteStartElement("TemplateVersionName");
    _writer.WriteRaw(_vmTemplate.getTemplateVersionName());
    _writer.WriteEndElement();
    // aka highly available
    _writer.WriteStartElement("AutoStartup");
    _writer.WriteRaw(String.valueOf(_vmTemplate.getAutoStartup()));
    _writer.WriteEndElement();
}
#method_after
@Override
protected void writeGeneralData() {
    super.writeGeneralData();
    _writer.WriteStartElement(OvfProperties.NAME);
    _writer.WriteRaw(_vmTemplate.getName());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TEMPLATE_ID);
    _writer.WriteRaw(_vmTemplate.getId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.ORIGIN);
    _writer.WriteRaw(_vmTemplate.getOrigin() == null ? "" : String.valueOf(_vmTemplate.getOrigin().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TEMPLATE_DEFAULT_DISPLAY_TYPE);
    _writer.WriteRaw(String.valueOf(_vmTemplate.getDefaultDisplayType().getValue()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.IS_DISABLED);
    _writer.WriteRaw(String.valueOf(_vmTemplate.isDisabled()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TRUSTED_SERVICE);
    _writer.WriteRaw(String.valueOf(_vmTemplate.isTrustedService()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TEMPLATE_TYPE);
    _writer.WriteRaw(_vmTemplate.getTemplateType().name());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.BASE_TEMPLATE_ID);
    _writer.WriteRaw(_vmTemplate.getBaseTemplateId().toString());
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TEMPLATE_VERSION_NUMBER);
    _writer.WriteRaw(String.valueOf(_vmTemplate.getTemplateVersionNumber()));
    _writer.WriteEndElement();
    _writer.WriteStartElement(OvfProperties.TEMPLATE_VERSION_NAME);
    _writer.WriteRaw(_vmTemplate.getTemplateVersionName());
    _writer.WriteEndElement();
    // aka highly available
    _writer.WriteStartElement("AutoStartup");
    _writer.WriteRaw(String.valueOf(_vmTemplate.isAutoStartup()));
    _writer.WriteEndElement();
}
#end_block

#method_before
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    XmlNode node = content.SelectSingleNode("Name");
    if (node != null) {
        _vmTemplate.setName(node.innerText);
        name = _vmTemplate.getName();
    }
    node = content.SelectSingleNode("TemplateId");
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vmTemplate.setId(new Guid(node.innerText));
        }
    }
    node = content.SelectSingleNode("IsDisabled");
    if (node != null) {
        _vmTemplate.setDisabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TrustedService");
    if (node != null) {
        _vmTemplate.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode("TemplateType");
    if (node != null) {
        _vmTemplate.setTemplateType(VmEntityType.valueOf(node.innerText));
    }
    node = content.SelectSingleNode("BaseTemplateId");
    if (node != null) {
        _vmTemplate.setBaseTemplateId(Guid.createGuidFromString(node.innerText));
    } else {
        // in case base template is missing, we assume it is a base template
        _vmTemplate.setBaseTemplateId(_vmTemplate.getId());
    }
    node = content.SelectSingleNode("TemplateVersionNumber");
    if (node != null) {
        _vmTemplate.setTemplateVersionNumber(Integer.parseInt(node.innerText));
    }
    node = content.SelectSingleNode("TemplateVersionName");
    if (node != null) {
        _vmTemplate.setTemplateVersionName(node.innerText);
    }
    node = content.SelectSingleNode("AutoStartup");
    if (node != null) {
        _vmTemplate.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
}
#method_after
@Override
protected void readGeneralData(XmlNode content) {
    // General Vm
    XmlNode node = content.SelectSingleNode(OvfProperties.NAME);
    if (node != null) {
        _vmTemplate.setName(node.innerText);
        name = _vmTemplate.getName();
    }
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_ID);
    if (node != null) {
        if (StringUtils.isNotEmpty(node.innerText)) {
            _vmTemplate.setId(new Guid(node.innerText));
        }
    }
    node = content.SelectSingleNode(OvfProperties.IS_DISABLED);
    if (node != null) {
        _vmTemplate.setDisabled(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.TRUSTED_SERVICE);
    if (node != null) {
        _vmTemplate.setTrustedService(Boolean.parseBoolean(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_TYPE);
    if (node != null) {
        _vmTemplate.setTemplateType(VmEntityType.valueOf(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.BASE_TEMPLATE_ID);
    if (node != null) {
        _vmTemplate.setBaseTemplateId(Guid.createGuidFromString(node.innerText));
    } else {
        // in case base template is missing, we assume it is a base template
        _vmTemplate.setBaseTemplateId(_vmTemplate.getId());
    }
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_VERSION_NUMBER);
    if (node != null) {
        _vmTemplate.setTemplateVersionNumber(Integer.parseInt(node.innerText));
    }
    node = content.SelectSingleNode(OvfProperties.TEMPLATE_VERSION_NAME);
    if (node != null) {
        _vmTemplate.setTemplateVersionName(node.innerText);
    }
    node = content.SelectSingleNode("AutoStartup");
    if (node != null) {
        _vmTemplate.setAutoStartup(Boolean.parseBoolean(node.innerText));
    }
}
#end_block

#method_before
@Override
protected String getDefaultDisplayTypeStringRepresentation() {
    return "default_display_type";
}
#method_after
@Override
protected String getDefaultDisplayTypeStringRepresentation() {
    return OvfProperties.TEMPLATE_DEFAULT_DISPLAY_TYPE;
}
#end_block

#method_before
@Override
public List<Guid> runFilters(List<String> filterNames, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (filterNames.isEmpty()) {
            return hostIDs;
        }
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(FILTER, createFilterArgs(filterNames, hostIDs, vmID, propertiesMap));
        return parseFilterResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while filtering", e);
        auditLogFailedToConnect();
        return hostIDs;
    }
}
#method_after
@Override
public List<Guid> runFilters(List<String> filterNames, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (filterNames.isEmpty()) {
            return hostIDs;
        }
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object xmlRpcStruct = client.execute(FILTER, createFilterArgs(filterNames, hostIDs, vmID, propertiesMap));
        return ExternalSchedulerBrokerObjectBuilder.getFilteringResult(xmlRpcStruct).getHosts();
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while filtering", e);
        auditLogFailedToConnect();
        return hostIDs;
    }
}
#end_block

#method_before
@Override
public List<Pair<Guid, Integer>> runScores(List<Pair<String, Integer>> scoreNameAndWeight, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (scoreNameAndWeight.isEmpty()) {
            return null;
        }
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(SCORE, createScoreArgs(scoreNameAndWeight, hostIDs, vmID, propertiesMap));
        return parseScoreResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while running weight modules", e);
        auditLogFailedToConnect();
        return null;
    }
}
#method_after
@Override
public List<Pair<Guid, Integer>> runScores(List<Pair<String, Integer>> scoreNameAndWeight, List<Guid> hostIDs, Guid vmID, Map<String, String> propertiesMap) {
    try {
        // Do not call the scheduler when there is no operation requested from it
        if (scoreNameAndWeight.isEmpty()) {
            return null;
        }
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(SCORE, createScoreArgs(scoreNameAndWeight, hostIDs, vmID, propertiesMap));
        return ExternalSchedulerBrokerObjectBuilder.getScoreResult(result).getHosts();
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while running weight modules", e);
        auditLogFailedToConnect();
        return null;
    }
}
#end_block

#method_before
@Override
public Pair<List<Guid>, Guid> runBalance(String balanceName, List<Guid> hostIDs, Map<String, String> propertiesMap) {
    try {
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(BALANCE, createBalanceArgs(balanceName, hostIDs, propertiesMap));
        return parseBalanceResults(result);
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while balancing", e);
        auditLogFailedToConnect();
        return null;
    }
}
#method_after
@Override
public Pair<List<Guid>, Guid> runBalance(String balanceName, List<Guid> hostIDs, Map<String, String> propertiesMap) {
    try {
        XmlRpcClient client = new XmlRpcClient();
        client.setConfig(config);
        Object result = client.execute(BALANCE, createBalanceArgs(balanceName, hostIDs, propertiesMap));
        return ExternalSchedulerBrokerObjectBuilder.getBalanceResults(result).getResult();
    } catch (XmlRpcException e) {
        log.error("Could not communicate with the external scheduler while balancing", e);
        auditLogFailedToConnect();
        return null;
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    // check template exists
    if (!validate(templateExists())) {
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(vmTemplateId)) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
    }
    // check storage pool valid
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if delete protected
    if (template.isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    fetchImageTemplates();
    List<Guid> storageDomainsList = getParameters().getStorageDomainsList();
    Set<Guid> allDomainsList = getStorageDomainsByDisks(imageTemplates, true);
    // if null or empty list sent, get all template domains for deletion
    if (storageDomainsList == null || storageDomainsList.isEmpty()) {
        // populate all the domains of the template
        getParameters().setStorageDomainsList(new ArrayList<Guid>(allDomainsList));
        getParameters().setRemoveTemplateFromDb(true);
    } else {
        // if some domains sent, check that the sent domains are part of all domains
        List<String> problematicDomains = new ArrayList<String>();
        for (Guid domainId : storageDomainsList) {
            if (!allDomainsList.contains(domainId)) {
                StorageDomainStatic domain = getDbFacade().getStorageDomainStaticDao().get(domainId);
                problematicDomains.add(domain == null ? domainId.toString() : domain.getStorageName());
            }
        }
        if (!problematicDomains.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DOMAINS_LIST_MISMATCH);
            addCanDoActionMessage(String.format("$domainsList %1$s", StringUtils.join(problematicDomains, ",")));
            return false;
        }
        getParameters().setRemoveTemplateFromDb(allDomainsList.size() == storageDomainsList.size());
    }
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = getVmDAO().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<String>();
    for (VM vm : vms) {
        if (getParameters().isRemoveTemplateFromDb()) {
            problematicVmNames.add(vm.getName());
        } else {
            List<DiskImage> vmDIsks = ImagesHandler.filterImageDisks(getDbFacade().getDiskDao().getAllForVm(vm.getId()), false, false, true);
            Set<Guid> domainsIds = getStorageDomainsByDisks(vmDIsks, false);
            for (Guid domainId : domainsIds) {
                if (!getParameters().getStorageDomainsList().contains(domainId)) {
                    problematicVmNames.add(vm.getName());
                }
            }
        }
    }
    if (!problematicVmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
        addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        return false;
    }
    return validate(checkNoDisksBasedOnTemplateDisks());
}
#method_after
@Override
protected boolean canDoAction() {
    Guid vmTemplateId = getVmTemplateId();
    VmTemplate template = getVmTemplate();
    // check template exists
    if (!validate(templateExists())) {
        return false;
    }
    // check not blank template
    if (VmTemplateHandler.BLANK_VM_TEMPLATE_ID.equals(vmTemplateId)) {
        return failCanDoAction(VdcBllMessages.VMT_CANNOT_REMOVE_BLANK_TEMPLATE);
    }
    // check storage pool valid
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // check if delete protected
    if (template.isDeleteProtected()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DELETE_PROTECTION_ENABLED);
    }
    fetchImageTemplates();
    List<Guid> storageDomainsList = getParameters().getStorageDomainsList();
    Set<Guid> allDomainsList = getStorageDomainsByDisks(imageTemplates, true);
    // if null or empty list sent, get all template domains for deletion
    if (storageDomainsList == null || storageDomainsList.isEmpty()) {
        // populate all the domains of the template
        getParameters().setStorageDomainsList(new ArrayList<Guid>(allDomainsList));
        getParameters().setRemoveTemplateFromDb(true);
    } else {
        // if some domains sent, check that the sent domains are part of all domains
        List<String> problematicDomains = new ArrayList<String>();
        for (Guid domainId : storageDomainsList) {
            if (!allDomainsList.contains(domainId)) {
                StorageDomainStatic domain = getDbFacade().getStorageDomainStaticDao().get(domainId);
                problematicDomains.add(domain == null ? domainId.toString() : domain.getStorageName());
            }
        }
        if (!problematicDomains.isEmpty()) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DOMAINS_LIST_MISMATCH);
            addCanDoActionMessage(String.format("$domainsList %1$s", StringUtils.join(problematicDomains, ",")));
            return false;
        }
        getParameters().setRemoveTemplateFromDb(allDomainsList.size() == storageDomainsList.size());
    }
    // check template images for selected domains
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    for (Guid domainId : getParameters().getStorageDomainsList()) {
        if (!isVmTemplateImagesReady(getVmTemplate(), domainId, canDoActionMessages, getParameters().getCheckDisksExists(), true, false, true, storageToDisksMap.get(domainId))) {
            return false;
        }
    }
    // check no vms from this template on selected domains
    List<VM> vms = getVmDAO().getAllWithTemplate(vmTemplateId);
    List<String> problematicVmNames = new ArrayList<String>();
    for (VM vm : vms) {
        if (getParameters().isRemoveTemplateFromDb()) {
            problematicVmNames.add(vm.getName());
        } else {
            List<DiskImage> vmDIsks = ImagesHandler.filterImageDisks(getDbFacade().getDiskDao().getAllForVm(vm.getId()), false, false, true);
            Set<Guid> domainsIds = getStorageDomainsByDisks(vmDIsks, false);
            for (Guid domainId : domainsIds) {
                if (!getParameters().getStorageDomainsList().contains(domainId)) {
                    problematicVmNames.add(vm.getName());
                }
            }
        }
    }
    if (!problematicVmNames.isEmpty()) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_DETECTED_DERIVED_VM);
        addCanDoActionMessage(String.format("$vmsList %1$s", StringUtils.join(problematicVmNames, ",")));
        return false;
    }
    // for base templates, make sure it has no versions that need to be removed first
    if (getParameters().isRemoveTemplateFromDb() && vmTemplateId.equals(template.getBaseTemplateId())) {
        List<VmTemplate> templateVersions = getVmTemplateDAO().getTemplateVersionsForBaseTemplate(vmTemplateId);
        if (!templateVersions.isEmpty()) {
            List<String> templateVersionsNames = new ArrayList<>();
            for (VmTemplate version : templateVersions) {
                templateVersionsNames.add(version.getName());
            }
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_REMOVE_BASE_WITH_VERSIONS);
            addCanDoActionMessage(String.format("$versionsList %1$s", StringUtils.join(templateVersionsNames, ",")));
            return false;
        }
    }
    return validate(checkNoDisksBasedOnTemplateDisks());
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    // if for some reason template doesn't have images, remove it now and not in end action
    final boolean hasImages = imageTemplates.size() > 0;
    if (hasImages) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (removeVmTemplateImages()) {
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        HandleEndAction();
    }
}
#method_after
@Override
protected void executeCommand() {
    // Set VM to lock status immediately, for reducing race condition.
    VmTemplateHandler.lockVmTemplateInTransaction(getVmTemplateId(), getCompensationContext());
    // if for some reason template doesn't have images, remove it now and not in end action
    final boolean hasImages = imageTemplates.size() > 0;
    if (hasImages) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                if (removeVmTemplateImages()) {
                    VmHandler.removeVmInitFromDB(getVmTemplate());
                    setSucceeded(true);
                }
                return null;
            }
        });
    } else {
        HandleEndAction();
    }
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    return Collections.singletonMap(getVmTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, getTemplateExclusiveLockMessage()));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (getVmTemplate() != null) {
        return Collections.singletonMap(getVmTemplateId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.TEMPLATE, getTemplateExclusiveLockMessage()));
    }
    return null;
}
#end_block

#method_before
public ValidationResult diskImagesAlreadyExist() {
    List<String> existingDisksAliases = new ArrayList<String>();
    for (DiskImage diskImage : diskImages) {
        if (isDiskExists(diskImage.getId())) {
            existingDisksAliases.add(diskImage.getDiskAlias());
        }
    }
    if (!existingDisksAliases.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST, String.format("$diskAliases %s", StringUtils.join(existingDisksAliases, ", ")));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult diskImagesAlreadyExist() {
    List<String> existingDisksAliases = new ArrayList<String>();
    for (DiskImage diskImage : diskImages) {
        DiskImage existingDisk = getExistingDisk(diskImage.getId());
        if (existingDisk != null) {
            existingDisksAliases.add(diskImage.getDiskAlias().isEmpty() ? existingDisk.getDiskAlias() : diskImage.getDiskAlias());
        }
    }
    if (!existingDisksAliases.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST, String.format("$diskAliases %s", StringUtils.join(existingDisksAliases, ", ")));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult diskImagesSnapshotsNotAttachedToOtherVms(boolean onlyPlugged) {
    LinkedList<String> pluggedDiskSnapshotInfo = new LinkedList<>();
    for (DiskImage diskImage : diskImages) {
        List<VmDevice> devices = getVmDeviceDAO().getVmDevicesByDeviceId(diskImage.getId(), null);
        for (VmDevice device : devices) {
            if (device.getSnapshotId() != null && (!onlyPlugged || device.getIsPlugged())) {
                VM vm = getVmDAO().get(device.getVmId());
                Snapshot snapshot = getSnapshotDAO().get(device.getSnapshotId());
                pluggedDiskSnapshotInfo.add(String.format("%s (from Snapshot: %s VM attached to: %s) %n", diskImage.getDiskAlias(), snapshot.getDescription(), vm.getName()));
            }
        }
    }
    if (!pluggedDiskSnapshotInfo.isEmpty()) {
        pluggedDiskSnapshotInfo.addFirst(String.format("%n"));
        VdcBllMessages message = onlyPlugged ? VdcBllMessages.ACTION_TYPE_FAILED_VM_DISK_SNAPSHOT_IS_PLUGGED_TO_ANOTHER_VM : VdcBllMessages.ACTION_TYPE_FAILED_VM_DISK_SNAPSHOT_IS_ATTACHED_TO_ANOTHER_VM;
        return new ValidationResult(message, String.format("$disksInfo %s", String.format(StringUtils.join(pluggedDiskSnapshotInfo, "%n"))));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult diskImagesSnapshotsNotAttachedToOtherVms(boolean onlyPlugged) {
    LinkedList<String> pluggedDiskSnapshotInfo = new LinkedList<>();
    for (DiskImage diskImage : diskImages) {
        List<VmDevice> devices = getVmDeviceDAO().getVmDevicesByDeviceId(diskImage.getId(), null);
        for (VmDevice device : devices) {
            if (device.getSnapshotId() != null && (!onlyPlugged || device.getIsPlugged())) {
                VM vm = getVmDAO().get(device.getVmId());
                Snapshot snapshot = getSnapshotDAO().get(device.getSnapshotId());
                pluggedDiskSnapshotInfo.add(String.format("%s ,%s, %s", diskImage.getDiskAlias(), snapshot.getDescription(), vm.getName()));
            }
        }
    }
    if (!pluggedDiskSnapshotInfo.isEmpty()) {
        VdcBllMessages message = onlyPlugged ? VdcBllMessages.ACTION_TYPE_FAILED_VM_DISK_SNAPSHOT_IS_PLUGGED_TO_ANOTHER_VM : VdcBllMessages.ACTION_TYPE_FAILED_VM_DISK_SNAPSHOT_IS_ATTACHED_TO_ANOTHER_VM;
        return new ValidationResult(message, String.format("$disksInfo %s", String.format(StringUtils.join(pluggedDiskSnapshotInfo, "%n"))));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
public ValidationResult diskImagesHaveNoDerivedDisks(Guid storageDomainId) {
    List<String> disksInfo = null;
    for (DiskImage diskImage : diskImages) {
        if (diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType()) {
            List<DiskImage> basedDisks = getDiskImageDAO().getAllSnapshotsForParent(diskImage.getImageId());
            for (DiskImage basedDisk : basedDisks) {
                if (storageDomainId == null || basedDisk.getStorageIds().contains(storageDomainId)) {
                    if (disksInfo == null) {
                        disksInfo = new LinkedList<>();
                    }
                    disksInfo.add(String.format("%s  (%s) ", basedDisk.getDiskAlias(), basedDisk.getId()));
                }
            }
        }
    }
    if (disksInfo != null) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_DERIVED_DISKS, String.format("$disksInfo %s", String.format(StringUtils.join(disksInfo, "%n"))));
    }
    return ValidationResult.VALID;
}
#method_after
public ValidationResult diskImagesHaveNoDerivedDisks(Guid storageDomainId) {
    List<String> disksInfo = new LinkedList<>();
    for (DiskImage diskImage : diskImages) {
        if (diskImage.getVmEntityType() != null && diskImage.getVmEntityType().isTemplateType()) {
            List<DiskImage> basedDisks = getDiskImageDAO().getAllSnapshotsForParent(diskImage.getImageId());
            for (DiskImage basedDisk : basedDisks) {
                if (storageDomainId == null || basedDisk.getStorageIds().contains(storageDomainId)) {
                    disksInfo.add(String.format("%s  (%s) ", basedDisk.getDiskAlias(), basedDisk.getId()));
                }
            }
        }
    }
    if (!disksInfo.isEmpty()) {
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DETECTED_DERIVED_DISKS, String.format("$disksInfo %s", String.format(StringUtils.join(disksInfo, "%n"))));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Test
public void diskImagesAlreadyExistBothExist() {
    doReturn(true).when(validator).isDiskExists(any(Guid.class));
    assertThat(validator.diskImagesAlreadyExist(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST)).and(replacements(hasItem(createAliasReplacements(disk1, disk2)))));
}
#method_after
@Test
public void diskImagesAlreadyExistBothExist() {
    doReturn(new DiskImage()).when(validator).getExistingDisk(any(Guid.class));
    assertThat(validator.diskImagesAlreadyExist(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST)).and(replacements(hasItem(createAliasReplacements(disk1, disk2)))));
}
#end_block

#method_before
@Test
public void diskImagesAlreadyExistOneExist() {
    doReturn(true).when(validator).isDiskExists(disk1.getId());
    doReturn(false).when(validator).isDiskExists(disk2.getId());
    assertThat(validator.diskImagesAlreadyExist(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST)).and(replacements(hasItem(createAliasReplacements(disk1)))));
}
#method_after
@Test
public void diskImagesAlreadyExistOneExist() {
    doReturn(new DiskImage()).when(validator).getExistingDisk(disk1.getId());
    doReturn(null).when(validator).getExistingDisk(disk2.getId());
    assertThat(validator.diskImagesAlreadyExist(), both(failsWith(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_DISKS_ALREADY_EXIST)).and(replacements(hasItem(createAliasReplacements(disk1)))));
}
#end_block

#method_before
@Test
public void diskImagesAlreadyExistBothDoesntExist() {
    doReturn(false).when(validator).isDiskExists(any(Guid.class));
    assertEquals(validator.diskImagesAlreadyExist(), ValidationResult.VALID);
}
#method_after
@Test
public void diskImagesAlreadyExistBothDoesntExist() {
    doReturn(null).when(validator).getExistingDisk(any(Guid.class));
    assertEquals(validator.diskImagesAlreadyExist(), ValidationResult.VALID);
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (getDisk().getDiskStorageType() == DiskStorageType.LUN) {
                return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK_NO_DOMAIN : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK_NO_DOMAIN;
            }
            return getSucceeded() ? AuditLogType.USER_FINISHED_REMOVE_DISK : AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK;
        default:
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
private String convertStreamToString(InputStream is) {
    return new Scanner(is, Charset.defaultCharset().displayName()).useDelimiter("\\A").next().replace("\n", "");
}
#method_after
private String convertStreamToString(InputStream is) {
    return new Scanner(is).useDelimiter("\\A").next().replace("\n", "");
}
#end_block

#method_before
private void createConfigurationProvider() throws ManageDomainsResult {
    String engineConfigProperties = createTempPropFile();
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        if (ldapPort.equals("")) {
            ldapPort = DEFAULT_LDAP_SERVER_PORT;
        }
        String changePasswordUrl = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.ChangePasswordMsg);
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort, changePasswordUrl);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#method_after
private void createConfigurationProvider() throws ManageDomainsResult {
    String engineConfigProperties = createTempPropFile();
    try {
        String engineConfigExecutable = utilityConfiguration.getEngineConfigExecutablePath();
        String adUserName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserName);
        String domainName = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.DomainName);
        String ldapSecurityAuthentication = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPSecurityAuthentication);
        String adUserPassword = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserPassword);
        String adUserId = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.AdUserId);
        String ldapServers = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LdapServers);
        String ldapProviderTypes = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPProviderTypes);
        String ldapPort = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.LDAPServerPort);
        String changePasswordUrl = getConfigValue(engineConfigExecutable, engineConfigProperties, ConfigValues.ChangePasswordMsg);
        configurationProvider = new ConfigurationProvider(adUserName, adUserPassword, domainName, ldapSecurityAuthentication, ldapServers, adUserId, ldapProviderTypes, utilityConfiguration.getEngineConfigExecutablePath(), engineConfigProperties, ldapPort, changePasswordUrl);
    } catch (Throwable e) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.FAILED_READING_CURRENT_CONFIGURATION, e.getMessage());
    }
}
#end_block

#method_before
private String readPasswordFile(String passwordFile) throws FileNotFoundException, IOException {
    try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(passwordFile), Charset.defaultCharset().displayName()))) {
        String readLine = reader.readLine();
        return readLine;
    }
}
#method_after
private String readPasswordFile(String passwordFile) throws FileNotFoundException, IOException {
    FileReader in = new FileReader(passwordFile);
    BufferedReader bufferedReader = new BufferedReader(in);
    String readLine = bufferedReader.readLine();
    closeQuietly(in, bufferedReader);
    return readLine;
}
#end_block

#method_before
private String createTempPropFile() throws ManageDomainsResult {
    File propFile = null;
    try {
        propFile = File.createTempFile("engine-config", "properties");
        propFile.deleteOnExit();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    try (BufferedWriter fw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(propFile), Charset.defaultCharset().displayName()))) {
        fw.write(new StringBuilder().append(ConfigValues.AdUserName.name()).append("=\n").append(ConfigValues.AdUserPassword.name()).append(".type=CompositePassword\n").append(ConfigValues.LDAPSecurityAuthentication.name()).append("=\n").append(ConfigValues.DomainName.name()).append("=\n").append(ConfigValues.AdUserId.name()).append("=\n").append(ConfigValues.LdapServers.name()).append("=\n").append(ConfigValues.LDAPProviderTypes.name()).append("=\n").append(ConfigValues.LDAPServerPort.name()).append("=\n").append(ConfigValues.ChangePasswordMsg.name()).append("=\n").toString());
        fw.flush();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    return propFile.getAbsolutePath();
}
#method_after
private String createTempPropFile() throws ManageDomainsResult {
    File propFile = null;
    try {
        propFile = File.createTempFile("engine-config", "properties");
        propFile.deleteOnExit();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    try (FileWriter fw = new FileWriter(propFile)) {
        fw.write(new StringBuilder().append(ConfigValues.AdUserName.name()).append("=\n").append(ConfigValues.AdUserPassword.name()).append(".type=CompositePassword\n").append(ConfigValues.LDAPSecurityAuthentication.name()).append("=\n").append(ConfigValues.DomainName.name()).append("=\n").append(ConfigValues.AdUserId.name()).append("=\n").append(ConfigValues.LdapServers.name()).append("=\n").append(ConfigValues.LDAPProviderTypes.name()).append("=\n").append(ConfigValues.LDAPServerPort.name()).append("=\n").append(ConfigValues.ChangePasswordMsg.name()).append("=\n").toString());
        fw.flush();
    } catch (IOException ex) {
        throw new ManageDomainsResult(ManageDomainsResultEnum.ERROR_CREATING_PROPERTIES_FILE, ex.getMessage());
    }
    return propFile.getAbsolutePath();
}
#end_block

#method_before
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    List<Properties> configurations = createInternalConfigurations();
    configurations.addAll(createKerberosLdapConfigurations());
    ExtensionManager.getInstance().load(configurations);
    AuthenticationProfileRepository.getInstance();
    KerberosManager.getInstance();
    UsersDomainsCacheManagerService.getInstance().init();
    DbUserCacheManager.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#method_after
@Override
@PostConstruct
public void create() {
    // Create authentication profiles for all the domains that exist in the database:
    // TODO: remove this later, and rely only on the custom and built in extensions directories configuration
    createInternalAAAConfigurations();
    createKerberosLdapAAAConfigurations();
    ExtensionsManager.getInstance().dump();
    AuthenticationProfileRepository.getInstance();
    DbUserCacheManager.getInstance().init();
    AsyncTaskManager.getInstance().initAsyncTaskManager();
    ResourceManager.getInstance().init();
    OvfDataUpdater.getInstance().initOvfDataUpdater();
    SchedulingManager.getInstance().setMigrationHandler(new MigrationHandler() {

        @Override
        public void migrateVM(List<Guid> initialHosts, Guid vmToMigrate) {
            MigrateVmParameters parameters = new MigrateVmParameters(false, vmToMigrate);
            parameters.setInitialHosts(new ArrayList<Guid>(initialHosts));
            Backend.getInstance().runInternalAction(VdcActionType.MigrateVm, parameters, ExecutionHandler.createInternalJobContext());
        }
    });
    ThreadPoolUtil.execute(new Runnable() {

        @Override
        public void run() {
            MacPoolManager.getInstance().initialize();
        }
    });
    StoragePoolStatusHandler.init();
    GlusterJobsManager.init();
    ExternalTrustStoreInitializer.init();
    try {
        log.info("Init VM custom properties utilities");
        VmPropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of vm custom properties failed.", e);
    }
    try {
        log.info("Init device custom properties utilities");
        DevicePropertiesUtils.getInstance().init();
    } catch (InitializationException e) {
        log.error("Initialization of device custom properties failed.", e);
    }
    SchedulingManager.getInstance().init();
    new DwhHeartBeat().init();
}
#end_block

#method_before
public void updateActionAvailability() {
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCustomPreviewCommand().setIsExecutionAllowed(getPreviewCommand().getIsExecutionAllowed());
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#method_after
public void updateActionAvailability() {
    if (getItems() == null) {
        // no need to update action availability
        return;
    }
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCustomPreviewCommand().setIsExecutionAllowed(getPreviewCommand().getIsExecutionAllowed());
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#end_block

#method_before
public static void sendFile(final HttpServletRequest request, final HttpServletResponse response, final File file, final String defaultType, boolean cache) throws IOException {
    // response if it doesn't:
    if (!canReadFile(file)) {
        if (!isWhiteListFiles(file)) {
            log.error("Can't read file \"" + (file != null ? file.getAbsolutePath() : "") + "\" for request \"" + request.getRequestURI() + "\", will send a 404 error response.");
        }
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else {
        boolean send = true;
        if (cache) {
            String eTag = getETag(file);
            // Always include ETag on response
            response.setHeader("ETag", eTag);
            String IfNoneMatch = request.getHeader("If-None-Match");
            if ("*".equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED);
                send = false;
            } else if (eTag.equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                send = false;
            }
        }
        if (send) {
            // Send metadata
            String mime = defaultType;
            if (mime == null) {
                mime = mimeMap.getContentType(file);
            }
            response.setContentType(mime);
            response.setContentLength((int) getFileSize(file));
            // Send content
            writeFileToStream(response.getOutputStream(), file);
        }
    }
}
#method_after
public static void sendFile(final HttpServletRequest request, final HttpServletResponse response, final File file, final String defaultType, boolean cache) throws IOException {
    sendFile(request, response, file, defaultType, cache, true);
}
#end_block

#method_before
public static void sendFile(final HttpServletRequest request, final HttpServletResponse response, final File file, final String defaultType, boolean cache) throws IOException {
    // response if it doesn't:
    if (!canReadFile(file)) {
        if (!isWhiteListFiles(file)) {
            log.error("Can't read file \"" + (file != null ? file.getAbsolutePath() : "") + "\" for request \"" + request.getRequestURI() + "\", will send a 404 error response.");
        }
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else {
        boolean send = true;
        if (cache) {
            String eTag = getETag(file);
            // Always include ETag on response
            response.setHeader("ETag", eTag);
            String IfNoneMatch = request.getHeader("If-None-Match");
            if ("*".equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED);
                send = false;
            } else if (eTag.equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                send = false;
            }
        }
        if (send) {
            // Send metadata
            String mime = defaultType;
            if (mime == null) {
                mime = mimeMap.getContentType(file);
            }
            response.setContentType(mime);
            response.setContentLength((int) getFileSize(file));
            // Send content
            writeFileToStream(response.getOutputStream(), file);
        }
    }
}
#method_after
public static void sendFile(final HttpServletRequest request, final HttpServletResponse response, final File file, final String defaultType, boolean cache, boolean required) throws IOException {
    // response if it doesn't:
    if (!canReadFile(file)) {
        if (required) {
            log.error("Can't read file \"" + (file != null ? file.getAbsolutePath() : "") + "\" for request \"" + request.getRequestURI() + "\", will send a 404 error response.");
        }
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else {
        boolean send = true;
        if (cache) {
            String eTag = getETag(file);
            // Always include ETag on response
            response.setHeader("ETag", eTag);
            String IfNoneMatch = request.getHeader("If-None-Match");
            if ("*".equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_PRECONDITION_FAILED);
                send = false;
            } else if (eTag.equals(IfNoneMatch)) {
                response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
                send = false;
            }
        }
        if (send) {
            // Send metadata
            String mime = defaultType;
            if (mime == null) {
                mime = mimeMap.getContentType(file);
            }
            response.setContentType(mime);
            response.setContentLength((int) getFileSize(file));
            // Send content
            writeFileToStream(response.getOutputStream(), file);
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getDbFacade().getStorageDomainDao().getByName(getParameters().getName(), getUserID(), getParameters().isFiltered()));
}
#method_after
@Override
protected void executeQueryCommand() {
    getQueryReturnValue().setReturnValue(getDbFacade().getStorageDomainStaticDao().getByName(getParameters().getName(), getUserID(), getParameters().isFiltered()));
}
#end_block

#method_before
private Guid getClusterId(Host host) {
    String name = (host.isSetCluster() && host.getCluster().isSetName() ? host.getCluster().getName() : "Default");
    return host.isSetCluster() && host.getCluster().isSetId() ? new Guid(host.getCluster().getId()) : getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), "Cluster: name=" + name).getId();
}
#method_after
private Guid getClusterId(Host host) {
    if (host.isSetCluster()) {
        Cluster cluster = host.getCluster();
        if (cluster.isSetId()) {
            return new Guid(cluster.getId());
        }
        if (cluster.isSetName()) {
            return getClusterIdByName(cluster.getName());
        }
    }
    return getClusterIdByName(DEFAULT_NAME);
}
#end_block

#method_before
@Test
public void testAddHostClusterByName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    // setUpGetEntityExpectations("Cluster: name=" + NAMES[1],
    // SearchType.Cluster,
    // setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpGetCertificateInfo();
    setUpCreationExpectations(VdcActionType.AddVds, AddVdsActionParameters.class, new String[] { "RootPassword" }, new Object[] { ROOT_PASSWORD }, true, true, GUIDS[0], VdcQueryType.GetVdsByVdsId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Host model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Host);
    verifyModel((Host) response.getEntity(), 0);
}
#method_after
@Test
public void testAddHostClusterByName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[1] }, setUpVDSGroup(GUIDS[1]));
    setUpGetCertificateInfo();
    setUpCreationExpectations(VdcActionType.AddVds, AddVdsActionParameters.class, new String[] { "RootPassword" }, new Object[] { ROOT_PASSWORD }, true, true, GUIDS[0], VdcQueryType.GetVdsByVdsId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    Host model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof Host);
    verifyModel((Host) response.getEntity(), 0);
}
#end_block

#method_before
protected VDSGroup lookupClusterByName(String name) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), name);
}
#method_after
protected VDSGroup lookupClusterByName(String name) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), "Cluster: name=" + name);
}
#end_block

#method_before
@Test
public void testRemove() throws Exception {
    setUpGetEntityExpectations(2, GUIDS[0], getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetAllDbUsers, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, getUsers());
    // setUpGetEntityExpectations(VdcQueryType.Search,
    // SearchParameters.class,
    // new String[] {"SearchPattern", "SearchTypeValue"},
    // new Object[] {"users:", SearchType.DBUser},
    // getUsers());
    setUriInfo(setUpActionExpectations(VdcActionType.RemovePermission, PermissionsOperationsParameters.class, new String[] { "Permission.Id" }, new Object[] { GUIDS[0] }, true, true));
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#method_after
@Test
public void testRemove() throws Exception {
    setUpGetEntityExpectations(2, GUIDS[0], getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetAllDbUsers, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, getUsers());
    setUriInfo(setUpActionExpectations(VdcActionType.RemovePermission, PermissionsOperationsParameters.class, new String[] { "Permission.Id" }, new Object[] { GUIDS[0] }, true, true));
    verifyRemove(collection.remove(GUIDS[0].toString()));
}
#end_block

#method_before
@Test
public void testAddByName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetConnection(1);
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[0] }, getEntity(0));
    setUpCreationExpectations(VdcActionType.AttachStorageDomainToPool, DetachStorageDomainFromPoolParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, true, true, null, VdcQueryType.GetStorageDomainByIdAndStoragePoolId, StorageDomainAndPoolQueryParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, getEntity(0));
    StorageDomain model = new StorageDomain();
    model.setName(NAMES[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof StorageDomain);
    verifyModel((StorageDomain) response.getEntity(), 0);
}
#method_after
@Test
public void testAddByName() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetConnection(1);
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[0] }, getEntityStatic(0));
    setUpCreationExpectations(VdcActionType.AttachStorageDomainToPool, DetachStorageDomainFromPoolParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, true, true, null, VdcQueryType.GetStorageDomainByIdAndStoragePoolId, StorageDomainAndPoolQueryParameters.class, new String[] { "StorageDomainId", "StoragePoolId" }, new Object[] { GUIDS[0], GUIDS[NAMES.length - 1] }, getEntity(0));
    StorageDomain model = new StorageDomain();
    model.setName(NAMES[0]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof StorageDomain);
    verifyModel((StorageDomain) response.getEntity(), 0);
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.StorageDomain setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.StorageDomain entity, int index, StorageType storageType) {
    expect(entity.getId()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getStatus()).andReturn(StorageDomainStatus.Active).anyTimes();
    expect(entity.getStorageDomainType()).andReturn(StorageDomainType.Master).anyTimes();
    expect(entity.getStorageType()).andReturn(storageType).anyTimes();
    expect(entity.getStorage()).andReturn(GUIDS[0].toString()).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.StorageDomainStatic setUpEntityExpectations(org.ovirt.engine.core.common.businessentities.StorageDomainStatic entity, int index, StorageType storageType) {
    expect(entity.getId()).andReturn(GUIDS[index]).anyTimes();
    expect(entity.getStorageDomainType()).andReturn(StorageDomainType.Master).anyTimes();
    expect(entity.getStorageType()).andReturn(storageType).anyTimes();
    expect(entity.getStorage()).andReturn(GUIDS[0].toString()).anyTimes();
    return entity;
}
#end_block

#method_before
protected Guid lookupStorageDomainIdByName(String name) {
    if (!isFiltered()) {
        StorageDomain storageDomain = getEntity(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), name);
        if (storageDomain != null) {
            return storageDomain.getId();
        }
        return null;
    } else {
        List<org.ovirt.engine.core.common.businessentities.StorageDomain> storageDomains = getBackendCollection(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetAllStorageDomains, new VdcQueryParametersBase());
        for (org.ovirt.engine.core.common.businessentities.StorageDomain storageDomain : storageDomains) {
            if (storageDomain.getStorageName().equals(name)) {
                return storageDomain.getId();
            }
        }
        return null;
    }
}
#method_after
protected Guid lookupStorageDomainIdByName(String name) {
    if (!isFiltered()) {
        StorageDomainStatic storageDomain = getEntity(org.ovirt.engine.core.common.businessentities.StorageDomainStatic.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), "Storage: name=" + name);
        if (storageDomain != null) {
            return storageDomain.getId();
        }
        return null;
    } else {
        List<org.ovirt.engine.core.common.businessentities.StorageDomain> storageDomains = getBackendCollection(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetAllStorageDomains, new VdcQueryParametersBase());
        for (org.ovirt.engine.core.common.businessentities.StorageDomain storageDomain : storageDomains) {
            if (storageDomain.getStorageName().equals(name)) {
                return storageDomain.getId();
            }
        }
        return null;
    }
}
#end_block

#method_before
@Test
public void testImportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    setUpGetDataCenterByStorageDomainExpectations(STORAGE_DOMAIN_ID);
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    Cluster cluster = new Cluster();
    cluster.setId(GUIDS[1].toString());
    doTestImport(storageDomain, cluster, false);
}
#method_after
@Test
public void testImportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    setUpGetDataCenterByStorageDomainExpectations(STORAGE_DOMAIN_ID);
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    Cluster cluster = new Cluster();
    cluster.setId(GUIDS[1].toString());
    doTestImport(storageDomain, cluster, false);
}
#end_block

#method_before
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), name).getId();
}
#method_after
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(org.ovirt.engine.core.common.businessentities.StorageDomainStatic.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), "Storage: name=" + name).getId();
}
#end_block

#method_before
protected Guid getDataCenterId(Network network) {
    return getEntity(StoragePool.class, VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(network.getDataCenter().getName()), "Datacenter: name=" + network.getDataCenter().getName()).getId();
}
#method_after
protected Guid getDataCenterId(Network network) {
    String networkName = network.getDataCenter().getName();
    return getEntity(StoragePool.class, VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(networkName), "Datacenter: name=" + networkName).getId();
}
#end_block

#method_before
protected void testCopyBySdName(boolean isFiltered) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (isFiltered) {
        setUpFilteredQueryExpectations();
        setUpEntityQueryExpectations(VdcQueryType.GetAllStorageDomains, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, Collections.singletonList(getStorageDomainEntity(0)));
    } else {
        setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainEntity(0));
    }
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveOrCopyDisk, MoveOrCopyImageGroupParameters.class, new String[] { "ImageId", "SourceDomainId", "StorageDomainId", "Operation" }, new Object[] { GUIDS[1], Guid.Empty, GUIDS[3], ImageOperation.Copy }));
    verifyActionResponse(resource.copy(setUpCopyParams(true)));
}
#method_after
protected void testCopyBySdName(boolean isFiltered) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (isFiltered) {
        setUpFilteredQueryExpectations();
        setUpEntityQueryExpectations(VdcQueryType.GetAllStorageDomains, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, Collections.singletonList(getStorageDomainEntity(0)));
    } else {
        setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStaticEntity(0));
    }
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveOrCopyDisk, MoveOrCopyImageGroupParameters.class, new String[] { "ImageId", "SourceDomainId", "StorageDomainId", "Operation" }, new Object[] { GUIDS[1], Guid.Empty, GUIDS[3], ImageOperation.Copy }));
    verifyActionResponse(resource.copy(setUpCopyParams(true)));
}
#end_block

#method_before
static org.ovirt.engine.core.common.businessentities.StorageDomain setUpStorageDomainEntityExpectations(org.ovirt.engine.core.common.businessentities.StorageDomain entity, int index, StorageType storageType) {
    expect(entity.getId()).andReturn(GUIDS[3]).anyTimes();
    expect(entity.getStorageName()).andReturn(NAMES[2]).anyTimes();
    expect(entity.getStatus()).andReturn(StorageDomainStatus.Active).anyTimes();
    expect(entity.getStorageDomainType()).andReturn(StorageDomainType.Master).anyTimes();
    expect(entity.getStorageType()).andReturn(storageType).anyTimes();
    expect(entity.getStorage()).andReturn(GUIDS[0].toString()).anyTimes();
    return entity;
}
#method_after
static org.ovirt.engine.core.common.businessentities.StorageDomainStatic setUpStorageDomainEntityExpectations(org.ovirt.engine.core.common.businessentities.StorageDomainStatic entity, int index, StorageType storageType) {
    expect(entity.getId()).andReturn(GUIDS[3]).anyTimes();
    expect(entity.getStorageName()).andReturn(NAMES[2]).anyTimes();
    expect(entity.getStorageDomainType()).andReturn(StorageDomainType.Master).anyTimes();
    expect(entity.getStorageType()).andReturn(storageType).anyTimes();
    expect(entity.getStorage()).andReturn(GUIDS[0].toString()).anyTimes();
    return entity;
}
#end_block

#method_before
@Test
public void testImportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    setUpGetDataCenterByStorageDomainExpectations(STORAGE_DOMAIN_ID);
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    Cluster cluster = new Cluster();
    cluster.setId(GUIDS[1].toString());
    doTestImport(storageDomain, cluster, false, false);
}
#method_after
@Test
public void testImportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    setUpGetDataCenterByStorageDomainExpectations(STORAGE_DOMAIN_ID);
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    Cluster cluster = new Cluster();
    cluster.setId(GUIDS[1].toString());
    doTestImport(storageDomain, cluster, false, false);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(getParameters().getId());
    List<VmTemplate> templateList = DbFacade.getInstance().getVmTemplateDao().getAllForStorageDomain(pool.getId());
    for (VmTemplate template : templateList) {
        VmHandler.updateVmInitFromDB(template, true);
    }
    VmTemplate blank = DbFacade.getInstance().getVmTemplateDao().get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    if (!templateList.contains(blank)) {
        templateList.add(0, blank);
    }
    getQueryReturnValue().setReturnValue(templateList);
}
#method_after
@Override
protected void executeQueryCommand() {
    StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(getParameters().getId());
    List<VmTemplate> templateList = DbFacade.getInstance().getVmTemplateDao().getAllForStorageDomain(pool.getId());
    // Load VmInit and disks
    for (VmTemplate template : templateList) {
        VmHandler.updateVmInitFromDB(template, true);
        VmTemplateHandler.updateDisksFromDb(template);
    }
    VmTemplate blank = DbFacade.getInstance().getVmTemplateDao().get(VmTemplateHandler.BLANK_VM_TEMPLATE_ID);
    if (!templateList.contains(blank)) {
        templateList.add(0, blank);
    }
    getQueryReturnValue().setReturnValue(templateList);
}
#end_block

#method_before
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(org.ovirt.engine.core.common.businessentities.StorageDomain.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), name).getId();
}
#method_after
protected Guid lookupStorageDomainIdByName(String name) {
    return getEntity(org.ovirt.engine.core.common.businessentities.StorageDomainStatic.class, VdcQueryType.GetStorageDomainByName, new NameQueryParameters(name), "Storage: name=" + name).getId();
}
#end_block

#method_before
@SuppressWarnings("unchecked")
public static StoragePool getStoragePool(Cluster cluster, AbstractBackendResource parent) {
    StoragePool pool = null;
    if (cluster.getDataCenter().isSetId()) {
        String id = cluster.getDataCenter().getId();
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolById, new IdQueryParameters(new Guid(id)), "Datacenter: id=" + id);
    } else {
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(cluster.getDataCenter().getName()), "Datacenter: name=" + cluster.getDataCenter().getName());
        cluster.getDataCenter().setId(pool.getId().toString());
    }
    return pool;
}
#method_after
@SuppressWarnings("unchecked")
public static StoragePool getStoragePool(Cluster cluster, AbstractBackendResource parent) {
    StoragePool pool = null;
    if (cluster.getDataCenter().isSetId()) {
        String id = cluster.getDataCenter().getId();
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolById, new IdQueryParameters(new Guid(id)), "Datacenter: id=" + id);
    } else {
        String clusterName = cluster.getDataCenter().getName();
        pool = parent.getEntity(StoragePool.class, VdcQueryType.GetStoragePoolByDatacenterName, new NameQueryParameters(clusterName), "Datacenter: name=" + clusterName);
        cluster.getDataCenter().setId(pool.getId().toString());
    }
    return pool;
}
#end_block

#method_before
@Test
public void testExportWithStorageDomainName() throws Exception {
    // setUpGetEntityExpectations("Storage: name=" + NAMES[2],
    // SearchType.StorageDomain,
    // getStorageDomain(2));
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestExport(storageDomain, false, false);
}
#method_after
@Test
public void testExportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestExport(storageDomain, false, false);
}
#end_block

#method_before
@Test
public void testMoveWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestMove(storageDomain);
}
#method_after
@Test
public void testMoveWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestMove(storageDomain);
}
#end_block

#method_before
@Test
public void testGet() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetAllDbUsers, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, getUsers());
    setUpGetEntityExpectations();
    control.replay();
    verifyModel(resource.get(), 0);
}
#method_after
@Test
public void testGet() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpEntityQueryExpectations(VdcQueryType.GetAllDbUsers, VdcQueryParametersBase.class, new String[] { "Refresh", "Filtered" }, new Object[] { true, false }, getUsers());
    setUpGetEntityExpectations();
    control.replay();
    verifyModel(resource.get(), 0);
}
#end_block

#method_before
@Test
public void testExportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestExport(storageDomain, false);
}
#method_after
@Test
public void testExportWithStorageDomainName() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    StorageDomain storageDomain = new StorageDomain();
    storageDomain.setName(NAMES[2]);
    doTestExport(storageDomain, false);
}
#end_block

#method_before
protected void testMoveBySdName(boolean isFiltered) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (isFiltered) {
        setUpFilteredQueryExpectations();
        setUpEntityQueryExpectations(VdcQueryType.GetAllStorageDomains, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, Collections.singletonList(getStorageDomain(2)));
    } else {
        setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomain(2));
    }
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveDisks, MoveDisksParameters.class, new String[] {}, new Object[] {}));
    verifyActionResponse(((VmDiskResource) resource).move(setUpMoveParams(true)));
}
#method_after
protected void testMoveBySdName(boolean isFiltered) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    if (isFiltered) {
        setUpFilteredQueryExpectations();
        setUpEntityQueryExpectations(VdcQueryType.GetAllStorageDomains, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, Collections.singletonList(getStorageDomain(2)));
    } else {
        setUpEntityQueryExpectations(VdcQueryType.GetStorageDomainByName, NameQueryParameters.class, new String[] { "Name" }, new Object[] { NAMES[2] }, getStorageDomainStatic(2));
    }
    setUpEntityQueryExpectations(VdcQueryType.GetDiskByDiskId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getEntity(1));
    setUriInfo(setUpActionExpectations(VdcActionType.MoveDisks, MoveDisksParameters.class, new String[] {}, new Object[] {}));
    verifyActionResponse(((VmDiskResource) resource).move(setUpMoveParams(true)));
}
#end_block

#method_before
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#method_after
public VersionCaps generateVersionCaps(Version v) {
    VersionCaps current = null;
    VersionCaps version = new VersionCaps();
    version.setMajor(v.getMajor());
    version.setMinor(v.getMinor());
    version.setId(generateId(v));
    // Not exposing CPU list and power managers on filtered queries
    if (!isFiltered()) {
        version.setCpus(new CPUs());
        for (ServerCpu sc : getServerCpuList(v)) {
            CPU cpu = new CPU();
            cpu.setId(sc.getCpuName());
            cpu.setLevel(sc.getLevel());
            cpu.setArchitecture(CPUMapper.map(sc.getArchitecture(), null));
            version.getCpus().getCPUs().add(cpu);
        }
        addPowerManagers(version, getPowerManagers(v));
    }
    addVmTypes(version, VmType.values());
    addAuthenticationMethods(version, AuthenticationMethod.values());
    addStorageTypes(version, getStorageTypes(v));
    addStorageDomainTypes(version, StorageDomainType.values());
    addFenceTypes(version, FenceType.values());
    addBootDevices(version, BootDevice.values());
    addDisplayTypes(version, DisplayType.values());
    addNicInterfaces(version, NicInterface.values());
    addDiskFormats(version, DiskFormat.values());
    addDiskInterfaces(version, DiskInterface.values());
    addCustomProperties(version, getVmHooksEnvs(v));
    addVmAffinities(version, VmAffinity.values());
    addVmDeviceType(version, VmDeviceType.values());
    addnetworkBootProtocols(version, BootProtocol.values());
    addMigrateOnErrorOptions(version, MigrateOnError.values());
    addStorageFormatOptions(version, StorageFormat.values());
    addOsTypes(version);
    addNfsVersions(version, NfsVersion.values());
    addGlusterTypesAndStates(version);
    // Add States. User can't update States, but he still needs to know which exist.
    addCreationStates(version, CreationStatus.values());
    addStorageDomaintStates(version, StorageDomainStatus.values());
    addPowerManagementStateses(version, PowerManagementStatus.values());
    addHostStates(version, HostStatus.values());
    addHostNonOperationalDetails(version, NonOperationalReason.values());
    addNetworkStates(version, NetworkStatus.values());
    addTemplateStates(version, TemplateStatus.values());
    addVmStates(version, VmStatus.values());
    addVmPauseDetails(version, VmPauseStatus.values());
    addDiskStates(version, DiskStatus.values());
    addHostNICStates(version, NicStatus.values());
    addDataCenterStates(version, DataCenterStatus.values());
    addPermits(version, PermitType.values());
    addSchedulingPolicies(version, SchedulingPolicyType.values());
    addNetworkUsages(version, NetworkUsage.values());
    addPmProxyTypes(version, PmProxyType.values());
    addReportedDeviceTypes(version, ReportedDeviceType.values());
    addIpVersions(version, IpVersion.values());
    addCpuModes(version, CpuMode.values());
    addScsiGenericIoOptions(version, ScsiGenericIO.values());
    addWatchdogActions(version, WatchdogAction.values());
    addWatchdogModels(version, WatchdogModel.values());
    addConfigurationTypes(version, ConfigurationType.values());
    addSnapshotStatuses(version, SnapshotStatus.values());
    addPayloadEncodings(version, PayloadEncoding.values());
    addArchitectureCapabilities(version);
    addSerialNumberPolicies(version, SerialNumberPolicy.values());
    // External tasks types
    addStepEnumTypes(version, StepEnum.values());
    version.setFeatures(featuresHelper.getFeatures(v));
    if (current == null && VersionHelper.equals(v, getCurrentVersion())) {
        current = version;
        current.setCurrent(true);
    } else {
        version.setCurrent(false);
    }
    LinkHelper.<VersionCaps>addLinks(getUriInfo(), version);
    return version;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (entity.getVmInit() == null) {
            entity.setVmInit(new VmInit());
        }
        entity.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.getVersion() != null) {
        if (model.getVersion().getBaseTemplate() != null && StringUtils.isNotEmpty(model.getVersion().getBaseTemplate().getId())) {
            entity.setBaseTemplateId(Guid.createGuidFromString(model.getVersion().getBaseTemplate().getId()));
        }
        if (model.getVersion().isSetVersionName()) {
            entity.setTemplateVersionName(model.getVersion().getVersionName());
        }
    // numbering is generated in the backend, hence even if user specified version number, we ignore it.
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.map(model.getSerialNumber(), entity);
    }
    return entity;
}
#method_after
@Mapping(from = Template.class, to = VmTemplate.class)
public static VmTemplate map(Template model, VmTemplate incoming) {
    VmTemplate entity = incoming != null ? incoming : new VmTemplate();
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        entity.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        entity.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            entity.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            entity.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        entity.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        entity.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        entity.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            entity.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        entity.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        entity.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            entity.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            entity.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setClusterArch(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetCpuShares()) {
        entity.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            entity.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            entity.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            entity.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            entity.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            entity.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                entity.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            entity.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            entity.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            entity.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSetSmartcardEnabled()) {
            entity.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            entity.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (entity.getVmInit() == null) {
            entity.setVmInit(new VmInit());
        }
        entity.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        String timezone = model.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        entity.setTimeZone(timezone);
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        entity.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.getVersion() != null) {
        if (model.getVersion().getBaseTemplate() != null && StringUtils.isNotEmpty(model.getVersion().getBaseTemplate().getId())) {
            entity.setBaseTemplateId(Guid.createGuidFromString(model.getVersion().getBaseTemplate().getId()));
        }
        if (model.getVersion().isSetVersionName()) {
            entity.setTemplateVersionName(model.getVersion().getVersionName());
        }
    // numbering is generated in the backend, hence even if user specified version number, we ignore it.
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setName(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        staticVm.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpuShares()) {
        staticVm.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            staticVm.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        staticVm.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.setTimeZone(model.getTimezone());
    }
    if (model.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.map(model.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#method_after
@Mapping(from = Template.class, to = VmStatic.class)
public static VmStatic map(Template model, VmStatic incoming) {
    VmStatic staticVm = incoming != null ? incoming : new VmStatic();
    if (model.isSetName()) {
        staticVm.setName(model.getName());
    }
    if (model.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetDescription()) {
        staticVm.setDescription(model.getDescription());
    }
    if (model.isSetComment()) {
        staticVm.setComment(model.getComment());
    }
    if (model.isSetCluster() && model.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(model.getCluster().getId()));
    }
    if (model.isSetHighAvailability()) {
        if (model.getHighAvailability().isSetEnabled()) {
            staticVm.setAutoStartup(model.getHighAvailability().isEnabled());
        }
        if (model.getHighAvailability().isSetPriority()) {
            staticVm.setPriority(model.getHighAvailability().getPriority());
        }
    }
    if (model.isSetStateless()) {
        staticVm.setStateless(model.isStateless());
    }
    if (model.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(model.isDeleteProtected());
    }
    if (model.isSetSso() && model.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(model.getSso(), null));
    }
    if (model.isSetType()) {
        VmType vmType = VmType.fromValue(model.getType());
        if (vmType != null) {
            staticVm.setVmType(VmMapper.map(vmType, null));
        }
    }
    if (model.isSetOrigin()) {
        staticVm.setOrigin(VmMapper.map(model.getOrigin(), (OriginType) null));
    }
    if (model.isSetMemory()) {
        staticVm.setMemSizeMb((int) (model.getMemory() / BYTES_PER_MB));
    }
    if (model.isSetCpu() && model.getCpu().isSetTopology()) {
        if (model.getCpu().getTopology().getCores() != null) {
            staticVm.setCpuPerSocket(model.getCpu().getTopology().getCores());
        }
        if (model.getCpu().getTopology().getSockets() != null) {
            staticVm.setNumOfSockets(model.getCpu().getTopology().getSockets());
        }
    }
    if (model.isSetCpuShares()) {
        staticVm.setCpuShares(model.getCpuShares());
    }
    if (model.isSetOs()) {
        if (model.getOs().isSetType()) {
            staticVm.setOsId(VmMapper.mapOsType(model.getOs().getType()));
        }
        if (model.getOs().isSetBoot() && model.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(VmMapper.map(model.getOs().getBoot(), null));
        }
        if (model.getOs().isSetKernel()) {
            staticVm.setKernelUrl(model.getOs().getKernel());
        }
        if (model.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(model.getOs().getInitrd());
        }
        if (model.getOs().isSetCmdline()) {
            staticVm.setKernelParams(model.getOs().getCmdline());
        }
    }
    if (model.isSetDisplay()) {
        if (model.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(model.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(VmMapper.map(displayType, null));
            }
        }
        if (model.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(model.getDisplay().getMonitors());
        }
        if (model.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(model.getDisplay().isSingleQxlPci());
        }
        if (model.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(model.getDisplay().isAllowOverride());
        }
        if (model.getDisplay().isSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(model.getDisplay().isSmartcardEnabled());
        }
        if (model.getDisplay().isSetKeyboardLayout()) {
            String layout = model.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (model.isSetDomain() && model.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        staticVm.getVmInit().setDomain(model.getDomain().getName());
    }
    if (model.isSetTimezone()) {
        staticVm.setTimeZone(model.getTimezone());
    }
    if (model.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(model.getMigrationDowntime()));
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.map(model.getSerialNumber(), entity);
    }
    return entity;
}
#method_after
@Mapping(from = Cluster.class, to = VDSGroup.class)
public static VDSGroup map(Cluster model, VDSGroup template) {
    VDSGroup entity = template != null ? template : new VDSGroup();
    if (model.isSetId()) {
        entity.setId(GuidUtils.asGuid(model.getId()));
    }
    if (model.isSetName()) {
        entity.setName(model.getName());
    }
    if (model.isSetDescription()) {
        entity.setdescription(model.getDescription());
    }
    if (model.isSetComment()) {
        entity.setComment(model.getComment());
    }
    if (model.isSetCpu() && model.getCpu().isSetId()) {
        entity.setcpu_name(model.getCpu().getId());
    }
    if (model.isSetCpu() && model.getCpu().isSetArchitecture()) {
        Architecture archType = Architecture.fromValue(model.getCpu().getArchitecture());
        if (archType != null) {
            entity.setArchitecture(CPUMapper.map(archType, null));
        }
    }
    if (model.isSetDataCenter() && model.getDataCenter().isSetId()) {
        entity.setStoragePoolId(GuidUtils.asGuid(model.getDataCenter().getId()));
    }
    if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null) {
        entity.setcompatibility_version(new org.ovirt.engine.core.compat.Version(model.getVersion().getMajor(), model.getVersion().getMinor()));
    }
    if (model.isSetMemoryPolicy()) {
        entity = map(model.getMemoryPolicy(), entity);
    } else if (model.isSetVersion() && model.getVersion().getMajor() != null && model.getVersion().getMinor() != null && greaterOrEqual(model.getVersion(), min_thp_version)) {
        entity.setTransparentHugepages(true);
    }
    if (model.isSetSchedulingPolicy()) {
        entity = map(model.getSchedulingPolicy(), entity);
    }
    if (model.isSetErrorHandling() && model.getErrorHandling().isSetOnError()) {
        entity.setMigrateOnError(map(model.getErrorHandling().getOnError(), null));
    }
    if (model.isSetVirtService()) {
        entity.setVirtService(model.isVirtService());
    }
    if (model.isSetGlusterService()) {
        entity.setGlusterService(model.isGlusterService());
    }
    if (model.isSetThreadsAsCores()) {
        entity.setCountThreadsAsCores(model.isThreadsAsCores());
    }
    if (model.isSetTunnelMigration()) {
        entity.setTunnelMigration(model.isTunnelMigration());
    }
    if (model.isSetTrustedService()) {
        entity.setTrustedService(model.isTrustedService());
    }
    if (model.isSetHaReservation()) {
        entity.setHaReservation(model.isHaReservation());
    }
    if (model.isSetBallooningEnabled()) {
        entity.setEnableBallooning(model.isBallooningEnabled());
    }
    if (model.isSetKsm() && model.getKsm().isSetEnabled()) {
        entity.setEnableKsm(model.getKsm().isEnabled());
    }
    if (model.isSetDisplay() && model.getDisplay().isSetProxy()) {
        entity.setSpiceProxy("".equals(model.getDisplay().getProxy()) ? null : model.getDisplay().getProxy());
    }
    if (model.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(model.getSerialNumber(), entity);
    }
    return entity;
}
#end_block

#method_before
@Mapping(from = HasSerialNumberPolicy.class, to = SerialNumber.class)
public static SerialNumber map(HasSerialNumberPolicy entity, SerialNumber template) {
    if (template == null) {
        template = new SerialNumber();
    }
    SerialNumberPolicy policy = map(entity.getSerialNumberPolicy(), null);
    if (policy != null) {
        template.setPolicy(policy.value());
    }
    if (policy == SerialNumberPolicy.CUSTOM) {
        template.setValue(entity.getCustomSerialNumber());
    }
    return template;
}
#method_after
@Mapping(from = HasSerialNumberPolicy.class, to = SerialNumber.class)
public static SerialNumber map(HasSerialNumberPolicy entity, SerialNumber template) {
    if (template == null) {
        template = new SerialNumber();
    }
    SerialNumberPolicy policy = map(entity.getSerialNumberPolicy(), null);
    template.setPolicy(policy == null ? "" : policy.value());
    template.setValue(entity.getCustomSerialNumber());
    return template;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        if (staticVm.getVmInit().getDomain() == null) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.map(vm.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate()) {
        if (vm.getTemplate().getId() != null) {
            staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
        }
        // it will be handled by the backend.
        if (vm.isSetUseLatestTemplateVersion()) {
            staticVm.setUseLatestVersion(vm.isUseLatestTemplateVersion());
        }
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetSso() && vm.getSso().isSetMethods()) {
        staticVm.setSsoMethod(SsoMapper.map(vm.getSso(), null));
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    if (vm.isSetMigrationDowntime()) {
        staticVm.setMigrationDowntime(mapMinusOneToNull(vm.getMigrationDowntime()));
    }
    if (vm.isSetInitialization()) {
        staticVm.setVmInit(map(vm.getInitialization(), new VmInit()));
    }
    // if the Domain set via VmInit we ignore it
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        if (staticVm.getVmInit() == null) {
            staticVm.setVmInit(new VmInit());
        }
        // We don't want to override the domain if it set via the Initialization object
        if (!vm.isSetInitialization() || !vm.getInitialization().isSetDomain()) {
            staticVm.getVmInit().setDomain(vm.getDomain().getName());
        }
    }
    if (vm.isSetSerialNumber()) {
        SerialNumberMapper.copySerialNumber(vm.getSerialNumber(), staticVm);
    }
    return staticVm;
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("migration_downtime", template.getMigrationDowntime()).addValue("base_template_id", template.getBaseTemplateId()).addValue("template_version_name", template.getTemplateVersionName()).addValue("serial_number_policy", template.getSerialNumberPolicy() == null ? template.getSerialNumberPolicy().getValue() : null).addValue("custom_serial_number", template.getCustomSerialNumber());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("sso_method", template.getSsoMethod().toString()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name()).addValue("migration_downtime", template.getMigrationDowntime()).addValue("base_template_id", template.getBaseTemplateId()).addValue("template_version_name", template.getTemplateVersionName()).addValue("serial_number_policy", template.getSerialNumberPolicy() == null ? null : template.getSerialNumberPolicy().getValue()).addValue("custom_serial_number", template.getCustomSerialNumber());
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    buildVmData();
    mVmReturn = getBroker().create(createInfo);
    logCommandInfo();
    proceedProxyReturnValue();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vm.getDynamicData(), mVmReturn.mVm);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    buildVmData();
    logCommandInfo();
    mVmReturn = getBroker().create(createInfo);
    proceedProxyReturnValue();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vm.getDynamicData(), mVmReturn.mVm);
}
#end_block

#method_before
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId());
}
#method_after
public boolean isCloudInitUsed() {
    return getInitializationType() == InitializationType.CloudInit && !SimpleDependecyInjector.getInstance().get(OsRepository.class).isWindows(getVmOsId());
}
#end_block

#method_before
protected LdapUser populateUserData(LdapUser user, String domain, boolean populateGroups) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, LdapGroup> groupsDict = new java.util.HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(null, user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    if (user.getUserName() != null && !user.getUserName().contains("@")) {
        user.setUserName(user.getUserName() + "@" + user.getDomainControler());
    }
    if (populateGroups) {
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData currQueryData : partialQueries) {
                populateGroup(currQueryData, getAuthenticationDomain(), groupsDict, getLoginName(), getPassword());
            }
        }
    }
    user.setGroups(groupsDict);
    return user;
}
#method_after
protected LdapUser populateUserData(LdapUser user, String domain, boolean populateGroups) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    HashMap<String, LdapGroup> groupsDict = new HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(null, user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    if (user.getUserName() != null && !user.getUserName().contains("@")) {
        user.setUserName(user.getUserName() + "@" + user.getDomainControler());
    }
    if (populateGroups) {
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData currQueryData : partialQueries) {
                populateGroup(currQueryData, getAuthenticationDomain(), groupsDict, getLoginName(), getPassword());
            }
        }
    }
    user.setGroups(groupsDict);
    return user;
}
#end_block

#method_before
protected void populateGroup(LdapQueryData queryData, String domain, java.util.Map<String, LdapGroup> groupsDict, String loginName, String password) {
    try {
        GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
        List<GroupSearchResult> searchResultCollection = LdapBrokerUtils.performGroupQuery(loginName, password, domain, queryData);
        if (searchResultCollection != null) {
            for (GroupSearchResult searchResult : searchResultCollection) {
                ProceedGroupsSearchResult(searchResult, groupsDict, generator);
            }
        }
        // If generator has results, it means there are parent groups
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData partialQuery : partialQueries) {
                populateGroup(partialQuery, domain, groupsDict, loginName, password);
            }
        }
    } catch (RuntimeException e) {
        log.infoFormat("populateGroup failed. Exception: {0}", e);
    }
}
#method_after
protected void populateGroup(LdapQueryData queryData, String domain, Map<String, LdapGroup> groupsDict, String loginName, String password) {
    try {
        GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
        List<GroupSearchResult> searchResultCollection = LdapBrokerUtils.performGroupQuery(loginName, password, domain, queryData);
        if (searchResultCollection != null) {
            for (GroupSearchResult searchResult : searchResultCollection) {
                ProceedGroupsSearchResult(searchResult, groupsDict, generator);
            }
        }
        // If generator has results, it means there are parent groups
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData partialQuery : partialQueries) {
                populateGroup(partialQuery, domain, groupsDict, loginName, password);
            }
        }
    } catch (RuntimeException e) {
        log.infoFormat("populateGroup failed. Exception: {0}", e);
    }
}
#end_block

#method_before
private void ProceedGroupsSearchResult(GroupSearchResult groupsResult, java.util.Map<String, LdapGroup> groupsDict, GroupsDNQueryGenerator generator) {
    List<String> groupsList = groupsResult.getMemberOf();
    LdapGroup group = new LdapGroup();
    group.setid(groupsResult.getId());
    group.setname(LdapBrokerUtils.generateGroupDisplayValue(groupsResult.getDistinguishedName()));
    group.setMemberOf(groupsResult.getMemberOf());
    group.setDistinguishedName(groupsResult.getDistinguishedName());
    groupsDict.put(group.getname(), group);
    globalGroupsDict.put(group.getname(), group);
    proceedGroupsSearchResult(groupsResult.getId(), groupsList, groupsDict, generator);
}
#method_after
private void ProceedGroupsSearchResult(GroupSearchResult groupsResult, Map<String, LdapGroup> groupsDict, GroupsDNQueryGenerator generator) {
    List<String> groupsList = groupsResult.getMemberOf();
    LdapGroup group = new LdapGroup();
    group.setid(groupsResult.getId());
    group.setname(LdapBrokerUtils.generateGroupDisplayValue(groupsResult.getDistinguishedName()));
    group.setMemberOf(groupsResult.getMemberOf());
    group.setDistinguishedName(groupsResult.getDistinguishedName());
    groupsDict.put(group.getname(), group);
    globalGroupsDict.put(group.getname(), group);
    proceedGroupsSearchResult(groupsResult.getId(), groupsList, groupsDict, generator);
}
#end_block

#method_before
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<LdapUser> results = new ArrayList<LdapUser>();
    for (LdapQueryData queryData : queries) {
        java.util.ArrayList<LdapUser> tempUsers = (java.util.ArrayList<LdapUser>) LdapFactory.getInstance(getDomain()).runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#method_after
private void PopulateUsers() {
    List<LdapQueryData> queries = GenerateUsersQuery();
    List<LdapUser> results = new ArrayList<LdapUser>();
    for (LdapQueryData queryData : queries) {
        ArrayList<LdapUser> tempUsers = (ArrayList<LdapUser>) LdapFactory.getInstance(getDomain()).runAdAction(AdActionType.SearchUserByQuery, new LdapSearchByQueryParameters(getParameters().getSessionId(), getDomain(), queryData)).getReturnValue();
        if (tempUsers != null) {
            results.addAll(tempUsers);
        }
    }
    setReturnValue(results);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isUserCanBeAuthenticated() && attachUserToSession();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = isUserCanBeAuthenticated() && attachUserToSession();
    if (!result) {
        logAutheticationFailure();
    }
    return result;
}
#end_block

#method_before
protected VDSGroup lookupClusterByName(String name) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), "GetVdsGroupByName");
}
#method_after
protected VDSGroup lookupClusterByName(String name) {
    return getEntity(VDSGroup.class, VdcQueryType.GetVdsGroupByName, new NameQueryParameters(name), "Cluster: name=" + name);
}
#end_block

#method_before
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_IS_PASSWORD_AUTH, true);
}
#method_after
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_AUTHENTICATION_CAPABILITIES, AAA_AUTH_CAP_FLAGS_PASSWORD);
}
#end_block

#method_before
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Header authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_IS_NEGOTIATION_AUTH, true);
}
#method_after
@Override
public void init() {
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Header authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_AUTHENTICATION_CAPABILITIES, AAA_AUTH_CAP_FLAGS_NEGOTIATING);
}
#end_block

#method_before
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_IS_PASSWORD_AUTH, true);
    if (passwordChangeMsgPerDomain == null) {
        synchronized (ProvisionalAuthenticator.class) {
            if (passwordChangeMsgPerDomain == null) {
                passwordChangeMsgPerDomain = new HashMap<>();
                String changePasswordUrl = Config.<String>getValue(ConfigValues.ChangePasswordMsg);
                String[] pairs = changePasswordUrl.split(",");
                for (String pair : pairs) {
                    // Split the pair in such a way that if the URL contains :, it will not be split to strings
                    String[] pairParts = pair.split(":", 2);
                    if (pairParts.length >= 2) {
                        try {
                            passwordChangeMsgPerDomain.put(pairParts[0], URLDecoder.decode(pairParts[1], "UTF-8"));
                        } catch (UnsupportedEncodingException e) {
                            throw new AAAExtensionException(AAAExtensionError.INVALID_CONFIGURATION, "error in obtaining the password change message or url for " + pairParts[0]);
                        }
                    }
                }
            }
        }
    }
    String changePasswordMsgOrUrl = passwordChangeMsgPerDomain.get(getProfileName());
    if (changePasswordMsgOrUrl != null) {
        ExtensionProperties key = containsURL(changePasswordMsgOrUrl) ? ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_URL : ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_MSG;
        context.put(key, changePasswordMsgOrUrl);
    }
}
#method_after
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    context.put(ExtensionProperties.AAA_AUTHENTICATION_CAPABILITIES, AAA_AUTH_CAP_FLAGS_PASSWORD);
    if (passwordChangeMsgPerDomain == null) {
        synchronized (ProvisionalAuthenticator.class) {
            if (passwordChangeMsgPerDomain == null) {
                passwordChangeMsgPerDomain = new HashMap<>();
                String changePasswordUrl = Config.<String>getValue(ConfigValues.ChangePasswordMsg);
                String[] pairs = changePasswordUrl.split(",");
                for (String pair : pairs) {
                    // Split the pair in such a way that if the URL contains :, it will not be split to strings
                    String[] pairParts = pair.split(":", 2);
                    if (pairParts.length >= 2) {
                        try {
                            passwordChangeMsgPerDomain.put(pairParts[0], URLDecoder.decode(pairParts[1], "UTF-8"));
                        } catch (UnsupportedEncodingException e) {
                            throw new AAAExtensionException(AAAExtensionError.INVALID_CONFIGURATION, "error in obtaining the password change message or url for " + pairParts[0]);
                        }
                    }
                }
            }
        }
    }
    String changePasswordMsgOrUrl = passwordChangeMsgPerDomain.get(getProfileName());
    if (changePasswordMsgOrUrl != null) {
        ExtensionProperties key = containsURL(changePasswordMsgOrUrl) ? ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_URL : ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_MSG;
        context.put(key, changePasswordMsgOrUrl);
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isUserCanBeAuthenticated() && attachUserToSession();
}
#method_after
@Override
protected boolean canDoAction() {
    boolean result = isUserCanBeAuthenticated() && attachUserToSession();
    if (!result) {
        logAutheticationFailure();
    }
    return result;
}
#end_block

#method_before
public boolean isNegotiationAuth() {
    return context.get(ExtensionProperties.AAA_IS_NEGOTIATION_AUTH) != null ? (Boolean) context.get(ExtensionProperties.AAA_IS_NEGOTIATION_AUTH) : false;
}
#method_after
public boolean isNegotiationAuth() {
    Integer capabilities = (Integer) context.get(ExtensionProperties.AAA_AUTHENTICATION_CAPABILITIES);
    if (capabilities == null) {
        return false;
    } else {
        return (capabilities & AAA_AUTH_CAP_FLAGS_NEGOTIATING) != 0;
    }
}
#end_block

#method_before
public boolean isPasswordAuth() {
    return context.get(ExtensionProperties.AAA_IS_NEGOTIATION_AUTH) != null ? (Boolean) context.get(ExtensionProperties.AAA_IS_PASSWORD_AUTH) : false;
}
#method_after
public boolean isPasswordAuth() {
    Integer capabilities = (Integer) context.get(ExtensionProperties.AAA_AUTHENTICATION_CAPABILITIES);
    if (capabilities == null) {
        return false;
    } else {
        return (capabilities & AAA_AUTH_CAP_FLAGS_PASSWORD) != 0;
    }
}
#end_block

#method_before
@Override
public void initialize() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsFromConfigurationByVmId, new IdQueryParameters(vmId), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response != null && response.getSucceeded()) {
                PreviewSnapshotModel previewSnapshotModel = (PreviewSnapshotModel) model;
                ArrayList<SnapshotModel> snapshotModels = new ArrayList<SnapshotModel>();
                ArrayList<Snapshot> snapshots = response.getReturnValue();
                previewSnapshotModel.sortSnapshots(snapshots);
                Guid activeSnapshotId = null;
                Guid userSelectedSnapshotId = previewSnapshotModel.getSnapshotModel().getEntity().getId();
                for (Snapshot snapshot : snapshots) {
                    SnapshotModel snapshotModel = new SnapshotModel();
                    snapshotModel.setEntity(snapshot);
                    snapshotModel.getMemory().setEntity(false);
                    snapshotModel.setDisks((ArrayList<DiskImage>) snapshot.getDiskImages());
                    snapshotModels.add(snapshotModel);
                    if (snapshot.getType() == Snapshot.SnapshotType.ACTIVE) {
                        activeSnapshotId = snapshot.getId();
                    }
                }
                previewSnapshotModel.getSnapshots().setItems(snapshotModels);
                updateDiskSnapshotsMap();
                // Update disk-snapshots map
                updateDiskSnapshotsMap();
                // First selecting the active snapshot for ensuring default disks selection
                // (i.e. when some disk are missing from the selected snapshot,
                // the corresponding disks from the active snapshot should be selected).
                previewSnapshotModel.selectSnapshot(activeSnapshotId);
                // Selecting the snapshot the was selected by the user
                previewSnapshotModel.selectSnapshot(userSelectedSnapshotId);
            }
        }
    }));
}
#method_after
@Override
public void initialize() {
    Frontend.getInstance().runQuery(VdcQueryType.GetAllVmSnapshotsFromConfigurationByVmId, new IdQueryParameters(vmId), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
            if (response != null && response.getSucceeded()) {
                PreviewSnapshotModel previewSnapshotModel = (PreviewSnapshotModel) model;
                ArrayList<SnapshotModel> snapshotModels = new ArrayList<SnapshotModel>();
                ArrayList<Snapshot> snapshots = response.getReturnValue();
                previewSnapshotModel.sortSnapshots(snapshots);
                Guid activeSnapshotId = null;
                Guid userSelectedSnapshotId = previewSnapshotModel.getSnapshotModel().getEntity().getId();
                for (Snapshot snapshot : snapshots) {
                    SnapshotModel snapshotModel = new SnapshotModel();
                    snapshotModel.setEntity(snapshot);
                    snapshotModel.getMemory().setEntity(false);
                    snapshotModel.setDisks((ArrayList<DiskImage>) snapshot.getDiskImages());
                    snapshotModels.add(snapshotModel);
                    if (snapshot.getType() == Snapshot.SnapshotType.ACTIVE) {
                        activeSnapshotId = snapshot.getId();
                    }
                }
                previewSnapshotModel.getSnapshots().setItems(snapshotModels);
                updateDiskSnapshotsMap();
                // Update disk-snapshots map
                updateDiskSnapshotsMap();
                // First selecting the active snapshot for ensuring default disks selection
                // (i.e. when some disks are missing from the selected snapshot,
                // the corresponding disks from the active snapshot should be selected).
                previewSnapshotModel.selectSnapshot(activeSnapshotId);
                // Selecting the snapshot the was selected by the user
                previewSnapshotModel.selectSnapshot(userSelectedSnapshotId);
            }
        }
    }));
}
#end_block

#method_before
private boolean labelRenamed() {
    return NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getNetwork()) && !getOldNetwork().getLabel().equals(getNetwork().getLabel());
}
#method_after
private boolean labelRenamed() {
    return NetworkUtils.isLabeled(getOldNetwork()) && NetworkUtils.isLabeled(getNetwork()) && labelChanged();
}
#end_block

#method_before
@Test
public void verifyListOfRunningVmsIsSameWithSuccessFromVdsmResponse() {
    prepareForRefreshVmStatsCall();
    mockGetVmStatsCommand(true);
    // start refreshing vm data... VURTI now fetches Vms list from ResourceManager and loop through it
    updater.fetchRunningVms();
    List<VM> runningAndUnchanged = updater.checkVmsStatusChanged();
    Assert.assertTrue("expecting the VM in running VMs map", updater.getRunningVms().containsKey(VM_1));
    Assert.assertFalse(runningAndUnchanged.contains(VM_1));
}
#method_after
@Test
public void verifyListOfRunningVmsIsSameWithSuccessFromVdsmResponse() {
    prepareForRefreshVmStatsCall();
    mockGetVmStatsCommand(true);
    // start refreshing vm data... VURTI now fetches Vms list from ResourceManager and loop through it
    updater.fetchRunningVms();
    List<Guid> staleRunningVms = updater.checkVmsStatusChanged();
    Assert.assertTrue(updater.getRunningVms().containsKey(VM_1));
    Assert.assertFalse(staleRunningVms.contains(VM_1));
}
#end_block

#method_before
@Test
public void verifyListOfRunningVmsIsSameWithFailureOnGetVmStats() {
    prepareForRefreshVmStatsCall();
    mockGetVmStatsCommand(false);
    // start refreshing vm data... VURTI now fetches Vms list from ResourceManager and loop through it
    updater.fetchRunningVms();
    List<VM> runningAndUnchanged = updater.checkVmsStatusChanged();
    Assert.assertTrue("expecting the VM to be missing from the running VMs map", !updater.getRunningVms().containsKey(VM_1));
    Assert.assertFalse(runningAndUnchanged.contains(VM_1));
}
#method_after
@Test
public void verifyListOfRunningVmsIsSameWithFailureOnGetVmStats() {
    prepareForRefreshVmStatsCall();
    mockGetVmStatsCommand(false);
    // start refreshing vm data... VURTI now fetches Vms list from ResourceManager and loop through it
    updater.fetchRunningVms();
    List<Guid> staleRunningVms = updater.checkVmsStatusChanged();
    Assert.assertFalse(updater.getRunningVms().containsKey(VM_1));
    Assert.assertTrue(staleRunningVms.contains(VM_1));
}
#end_block

#method_before
private void prepareForRefreshVmStatsCall() {
    initVm();
    mockUpdater();
    mockListCommand();
    muteNonRelatedMethods();
}
#method_after
private void prepareForRefreshVmStatsCall() {
    initVm();
    mockUpdater();
    mockListCommand();
}
#end_block

#method_before
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#method_after
protected void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    if (fetchRunningVms()) {
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    }
}
#end_block

#method_before
protected List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusNotChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                } else {
                    log.error("failed to fetch vm stats. status remain unchanged");
                    statusNotChanged = true;
                }
            } else {
                statusNotChanged = true;
            }
            if (statusNotChanged) {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#method_after
protected List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            boolean statusChanged = false;
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                    statusChanged = true;
                } else {
                    if (vmToUpdate != null) {
                        log.errorFormat("failed to fetch {0} stats. status remain unchanged ({1})", vmToUpdate.getName(), vmToUpdate.getStatus());
                    }
                }
            }
            if (!statusChanged) {
                // status not changed move to next vm
                staleRunningVms.add(runningVm.getId());
                _runningVms.remove(runningVm.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // reportedAndUnchangedVms handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VDSReturnValue vdsReturnValue;
    if (!_vdsManager.getRefreshStatistics()) {
        vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.List, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.GetAllVmStats, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (vdsReturnValue.getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    } else {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) callException, _vds);
            } else if (callException instanceof VDSProtocolException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.errorFormat("{0} failed with no exception!", vdsReturnValue.toString());
        }
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VDSReturnValue vdsReturnValue;
    VDSCommandType commandType = _vdsManager.getRefreshStatistics() ? VDSCommandType.GetAllVmStats : VDSCommandType.List;
    vdsReturnValue = getResourceManager().runVdsCommand(commandType, new VdsIdAndVdsVDSCommandParametersBase(_vds));
    _runningVms = (Map<Guid, VmInternalData>) vdsReturnValue.getReturnValue();
    if (vdsReturnValue.getSucceeded()) {
        List<Guid> staleRunningVms = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(staleRunningVms);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    } else {
        RuntimeException callException = vdsReturnValue.getExceptionObject();
        if (callException != null) {
            if (callException instanceof VDSErrorException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            } else if (callException instanceof VDSNetworkException) {
                _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) callException, _vds);
            } else if (callException instanceof VDSProtocolException) {
                log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), vdsReturnValue.getExceptionString());
            }
            throw callException;
        } else {
            log.errorFormat("{0} failed with no exception!", commandType.name());
        }
    }
}
#end_block

#method_before
private List<VM> checkVmsStatusChanged() {
    List<VM> running = new ArrayList<VM>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || !EnumSet.of(runningVm.getStatus(), VMStatus.PreparingForHibernate, VMStatus.Up).contains(vmToUpdate.getStatus())) {
                VDSReturnValue vmStats = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vmStats.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vmStats.getReturnValue());
                } else {
                    log.error("failed to fetch vm stats. set to UNKNOWN to ignore it");
                    _runningVms.get(runningVm.getId()).getVmDynamic().setStatus(VMStatus.Unknown);
                }
            } else {
                // status not changed move to next vm
                running.add(vmToUpdate);
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return running;
}
#method_after
private List<Guid> checkVmsStatusChanged() {
    List<Guid> staleRunningVms = new ArrayList<>();
    if (!_vdsManager.getRefreshStatistics()) {
        List<VmDynamic> tempRunningList = new ArrayList<VmDynamic>();
        for (VmInternalData runningVm : _runningVms.values()) {
            tempRunningList.add(runningVm.getVmDynamic());
        }
        for (VmDynamic runningVm : tempRunningList) {
            VM vmToUpdate = _vmDict.get(runningVm.getId());
            if (vmToUpdate == null || (vmToUpdate.getStatus() != runningVm.getStatus() && !(vmToUpdate.getStatus() == VMStatus.PreparingForHibernate && runningVm.getStatus() == VMStatus.Up))) {
                VDSReturnValue vdsReturnValue = getResourceManager().runVdsCommand(VDSCommandType.GetVmStats, new GetVmStatsVDSCommandParameters(_vds, runningVm.getId()));
                if (vdsReturnValue.getSucceeded()) {
                    _runningVms.put(runningVm.getId(), (VmInternalData) vdsReturnValue.getReturnValue());
                } else {
                    _runningVms.remove(runningVm.getId());
                }
            } else {
                // status not changed move to next vm
                staleRunningVms.add(vmToUpdate.getId());
                _runningVms.remove(vmToUpdate.getId());
            }
        }
    }
    return staleRunningVms;
}
#end_block

#method_before
private void updateRepository(List<VM> running) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    running.add(_vmDict.get(runningVm.getId()));
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo && vmToUpdate != null) {
                running.add(vmToUpdate);
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(running);
}
#method_after
private void updateRepository(List<Guid> staleRunningVms) {
    for (VmInternalData vmInternalData : _runningVms.values()) {
        VmDynamic runningVm = vmInternalData.getVmDynamic();
        VM vmToUpdate = _vmDict.get(runningVm.getId());
        // if not migrating here and not down
        if (!inMigrationTo(runningVm, vmToUpdate) && runningVm.getStatus() != VMStatus.Down) {
            if (vmToUpdate != null) {
                if (_vmDict.containsKey(vmToUpdate.getId()) && !StringUtils.equals(runningVm.getClientIp(), vmToUpdate.getClientIp())) {
                    _vmsClientIpChanged.put(vmToUpdate, runningVm);
                }
            }
            if (vmToUpdate != null) {
                logVmStatusTransition(vmToUpdate, runningVm);
                // open spice for dedicated VMs
                if (vmToUpdate.getStatus() != VMStatus.Up && runningVm.getStatus() == VMStatus.Up || vmToUpdate.getStatus() != VMStatus.PoweringUp && runningVm.getStatus() == VMStatus.PoweringUp) {
                    // if no current client ip already connected.
                    if (runningVm.getDisplay() != null) {
                        _poweringUpVms.add(runningVm);
                    } else {
                        log.error("UpdateRepository - runningVm.display is null, cannot start spice for it");
                    }
                }
                // "Up" as this means that the power down operation failed:
                if (vmToUpdate.getStatus() == VMStatus.PoweringDown && runningVm.getStatus() == VMStatus.Up) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_POWER_DOWN_FAILED);
                }
                if (vmToUpdate.getStatus() != VMStatus.Up && vmToUpdate.getStatus() != VMStatus.MigratingFrom && runningVm.getStatus() == VMStatus.Up) {
                    // running handling
                    if (log.isDebugEnabled()) {
                        log.debugFormat("removing VM {0} from successful run VMs list", vmToUpdate.getId());
                    }
                    if (!_succededToRunVms.contains(vmToUpdate.getId())) {
                        _succededToRunVms.add(vmToUpdate.getId());
                    }
                }
                afterMigrationFrom(runningVm, vmToUpdate);
                if (vmToUpdate.getStatus() != VMStatus.NotResponding && runningVm.getStatus() == VMStatus.NotResponding) {
                    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                    auditLog(logable, AuditLogType.VM_NOT_RESPONDING);
                } else // check if vm is suspended and remove it from async list
                if (runningVm.getStatus() == VMStatus.Paused) {
                    _vmsToRemoveFromAsync.add(vmToUpdate.getId());
                    if (vmToUpdate.getStatus() != VMStatus.Paused) {
                        // check exit message to determine why the VM is paused
                        AuditLogType logType = vmPauseStatusToAuditLogType(runningVm.getPauseStatus());
                        if (logType != AuditLogType.UNASSIGNED) {
                            AuditLogableBase logable = new AuditLogableBase(_vds.getId(), vmToUpdate.getId());
                            auditLog(logable, logType);
                        }
                    }
                }
            }
            if (vmToUpdate != null || runningVm.getStatus() != VMStatus.MigratingFrom) {
                RefObject<VM> tempRefObj = new RefObject<VM>(vmToUpdate);
                boolean updateSucceed = updateVmRunTimeInfo(tempRefObj, runningVm);
                vmToUpdate = tempRefObj.argvalue;
                if (updateSucceed) {
                    addVmDynamicToList(vmToUpdate.getDynamicData());
                }
            }
            if (vmToUpdate != null) {
                updateVmStatistics(vmToUpdate);
                if (_vmDict.containsKey(runningVm.getId())) {
                    staleRunningVms.add(runningVm.getId());
                    if (!_vdsManager.getInitialized()) {
                        ResourceManager.getInstance().RemoveVmFromDownVms(_vds.getId(), runningVm.getId());
                    }
                }
            }
        } else {
            if (runningVm.getStatus() == VMStatus.MigratingTo) {
                staleRunningVms.add(runningVm.getId());
            }
            VmDynamic vmDynamic = getDbFacade().getVmDynamicDao().get(runningVm.getId());
            if (vmDynamic == null || vmDynamic.getStatus() != VMStatus.Unknown) {
                _vmDynamicToSave.remove(runningVm.getId());
            }
        }
    }
    // compare between vm in cache and vm from vdsm
    removeVmsFromCache(staleRunningVms);
}
#end_block

#method_before
private void removeVmsFromCache(List<VM> running) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (running.contains(vmToRemove)) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#method_after
private void removeVmsFromCache(List<Guid> staleRunningVms) {
    Guid vmGuid;
    for (VM vmToRemove : _vmDict.values()) {
        if (staleRunningVms.contains(vmToRemove.getId())) {
            continue;
        }
        proceedVmBeforeDeletion(vmToRemove, null);
        boolean isInMigration = false;
        if (vmToRemove.getStatus() == VMStatus.MigratingFrom) {
            isInMigration = true;
            handOverVM(vmToRemove);
        } else {
            clearVm(vmToRemove, VmExitStatus.Error, String.format("Could not find VM %s on host, assuming it went down unexpectedly", vmToRemove.getName()));
        }
        log.infoFormat("VM {0} ({1}) is running in db and not running in VDS {2}", vmToRemove.getName(), vmToRemove.getId(), _vds.getName());
        vmGuid = vmToRemove.getId();
        if (!isInMigration && !_vmsToRerun.contains(vmGuid) && ResourceManager.getInstance().IsVmInAsyncRunningList(vmGuid)) {
            _vmsToRerun.add(vmGuid);
            log.infoFormat("add VM {0} to rerun treatment", vmToRemove.getName());
        } else // or reported from vdsm with error code
        if (vmToRemove.isAutoStartup() && !_autoVmsToRun.contains(vmGuid) && (!_runningVms.containsKey(vmGuid) || (_runningVms.containsKey(vmGuid) && _runningVms.get(vmGuid).getVmDynamic().getExitStatus() != VmExitStatus.Normal))) {
            _autoVmsToRun.add(vmGuid);
            log.infoFormat("add VM {0} to HA rerun treatment", vmToRemove.getName());
        }
    }
}
#end_block

#method_before
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        memCommited += vm.getVmMemSizeMb();
        memCommited += _vds.getGuestOverhead();
        vmsCoresCount += vm.getNumOfCpus();
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#method_after
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        // we shouldn't include them as committed.
        if (vm.getStatus() != VMStatus.WaitForLaunch) {
            memCommited += vm.getVmMemSizeMb();
            memCommited += _vds.getGuestOverhead();
            vmsCoresCount += vm.getNumOfCpus();
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#end_block

#method_before
private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) {
    // do the state transition only if that VM is really running on SRC
    if (curVm.getRunOnVds() != null || curVm.getStatus() != VMStatus.MigratingTo) {
        // Updating the DB
        ResourceManager.getInstance().InternalSetVmStatus(curVm, parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down);
    }
}
#method_after
private void changeStatus(DestroyVmVDSCommandParameters parameters, VM curVm) {
    // do the state transition only if that VM is really running on SRC
    if (getVdsId().equals(curVm.getRunOnVds())) {
        ResourceManager.getInstance().InternalSetVmStatus(curVm, parameters.getGracefully() ? VMStatus.PoweringDown : VMStatus.Down);
    }
}
#end_block

#method_before
@Override
public void initTable(final CommonApplicationConstants constants) {
    getTable().enableColumnResizing();
    initActionButtons(constants);
    disableActiveSnapshotRow();
    getModel().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateMemoryColumnVisibility();
        }
    });
    // Add selection listener
    getModel().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            Snapshot snapshot = (Snapshot) getModel().getSelectedItem();
            if (snapshot != null && !getTable().getSelectionModel().isSelected(snapshot)) {
                getTable().getSelectionModel().setSelected(snapshot, true);
            }
            vmSnapshotInfoPanel.updatePanel(snapshot);
        }
    });
}
#method_after
@Override
public void initTable(final CommonApplicationConstants constants) {
    getTable().enableColumnResizing();
    getTable().setMultiSelectionDisabled(true);
    initActionButtons(constants);
    // Add event listeners
    getModel().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateMemoryColumnVisibility();
        }
    });
    getModel().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateSnapshotInfo();
        }
    });
}
#end_block

#method_before
private void updateMemoryColumnVisibility() {
    VM vm = (VM) getModel().getEntity();
    if (vm == null) {
        return;
    }
    getTable().ensureColumnPresent(SnapshotsViewColumns.dateColumn, constants.dateSnapshot(), true, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(SnapshotsViewColumns.statusColumn, constants.statusSnapshot(), true, // $NON-NLS-1$
    "75px");
    boolean archSnapshotSupported = AsyncDataProvider.isSnapshotSupported(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    boolean memorySnapshotSupported = ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archSnapshotSupported;
    getTable().ensureColumnPresent(SnapshotsViewColumns.memoryColumn, constants.memorySnapshot(), memorySnapshotSupported, // $NON-NLS-1$
    "55px");
    getTable().ensureColumnPresent(SnapshotsViewColumns.descriptionColumn, constants.descriptionSnapshot(), true, // $NON-NLS-1$
    "185px");
}
#method_after
private void updateMemoryColumnVisibility() {
    VM vm = (VM) getModel().getEntity();
    if (vm == null) {
        return;
    }
    getTable().ensureColumnPresent(SnapshotsViewColumns.dateColumn, constants.dateSnapshot(), true, // $NON-NLS-1$
    "150px");
    getTable().ensureColumnPresent(SnapshotsViewColumns.statusColumn, constants.statusSnapshot(), true, // $NON-NLS-1$
    "75px");
    boolean memorySnapshotSupported = ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && isMemorySnapshotSupported(vm);
    getTable().ensureColumnPresent(SnapshotsViewColumns.memoryColumn, constants.memorySnapshot(), memorySnapshotSupported, // $NON-NLS-1$
    "55px");
    getTable().ensureColumnPresent(SnapshotsViewColumns.descriptionColumn, constants.descriptionSnapshot(), true, // $NON-NLS-1$
    "185px");
}
#end_block

#method_before
private void initActionButtons(final CommonApplicationConstants constants) {
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.createSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.previewSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getPreviewCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.commitSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCommitCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.undoSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getUndoCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.deleteSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.cloneSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCloneVmCommand();
        }

        @Override
        public String getButtonToolTip() {
            if (!getModel().getIsCloneVmSupported() && getModel().getEntity() != null) {
                CommandVersionsInfo commandVersionsInfo = AsyncDataProvider.getCommandVersionsInfo(VdcActionType.AddVmFromSnapshot);
                String minimalClusterVersion = commandVersionsInfo != null ? commandVersionsInfo.getClusterVersion().toString(2) : // $NON-NLS-1$
                "";
                return messages.cloneVmNotSupported(minimalClusterVersion);
            } else {
                return this.getTitle();
            }
        }
    });
}
#method_after
private void initActionButtons(final CommonApplicationConstants constants) {
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.createSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getNewCommand();
        }
    });
    List<ActionButtonDefinition<Snapshot>> previewSubActions = new LinkedList<ActionButtonDefinition<Snapshot>>();
    previewSubActions.add(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.customPreviewSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCustomPreviewCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.previewSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getPreviewCommand();
        }
    }, new DropdownActionButton<Snapshot>(previewSubActions, getModel().getSelectedItems()));
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.commitSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCommitCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.commitSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCommitCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.undoSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getUndoCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.deleteSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getRemoveCommand();
        }
    });
    getTable().addActionButton(new UiCommandButtonDefinition<Snapshot>(getEventBus(), constants.cloneSnapshot()) {

        @Override
        protected UICommand resolveCommand() {
            return getModel().getCloneVmCommand();
        }

        @Override
        public String getButtonToolTip() {
            if (!getModel().getIsCloneVmSupported() && getModel().getEntity() != null) {
                CommandVersionsInfo commandVersionsInfo = AsyncDataProvider.getCommandVersionsInfo(VdcActionType.AddVmFromSnapshot);
                String minimalClusterVersion = commandVersionsInfo != null ? commandVersionsInfo.getClusterVersion().toString(2) : // $NON-NLS-1$
                "";
                return messages.cloneVmNotSupported(minimalClusterVersion);
            } else {
                return this.getTitle();
            }
        }
    });
}
#end_block

#method_before
void localize(CommonApplicationConstants constants) {
    descriptionEditor.setLabel(constants.virtualMachineSnapshotCreatePopupDescriptionLabel());
    memoryEditor.setLabel(constants.virtualMachineSnapshotCreatePopupMemoryLabel());
}
#method_after
void localize(CommonApplicationConstants constants) {
    descriptionEditor.setLabel(constants.virtualMachineSnapshotCreatePopupDescriptionLabel());
    memoryEditor.setLabel(constants.virtualMachineSnapshotCreatePopupMemoryLabel());
    disksTableLabel.setText(constants.snapshotDisks());
}
#end_block

#method_before
@Override
public void edit(final SnapshotModel model) {
    driver.edit(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                appendMessage(model.getMessage());
            } else if ("VM".equals(propName)) {
                // $NON-NLS-1$
                updateMemoryBoxVisibility();
            }
        }

        private void updateMemoryBoxVisibility() {
            VM vm = model.getVm();
            if (vm == null) {
                return;
            }
            boolean archSnapshotSupported = AsyncDataProvider.isSnapshotSupported(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
            boolean memorySnapshotSupported = ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archSnapshotSupported;
            memoryEditor.setVisible(memorySnapshotSupported && vm.isRunning());
            // is not visible, we should disable it explicitly
            if (!memoryEditor.isVisible()) {
                model.getMemory().setEntity(false);
            }
        }
    });
}
#method_after
@Override
public void edit(final SnapshotModel model) {
    driver.edit(model);
    editDisksTable(model);
    model.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).propertyName;
            if ("Message".equals(propName)) {
                // $NON-NLS-1$
                appendMessage(model.getMessage());
            } else if ("VM".equals(propName)) {
                // $NON-NLS-1$
                updateMemoryBoxVisibility();
            }
        }

        private void updateMemoryBoxVisibility() {
            VM vm = model.getVm();
            if (vm == null) {
                return;
            }
            boolean archMemorySnapshotSupported = AsyncDataProvider.isMemorySnapshotSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
            boolean memorySnapshotSupported = ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archMemorySnapshotSupported;
            memoryEditor.setVisible(memorySnapshotSupported && vm.isRunning());
            // is not visible, we should disable it explicitly
            if (!memoryEditor.isVisible()) {
                model.getMemory().setEntity(false);
            }
        }
    });
    model.getMemory().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            updateMemoryWarning(model);
        }
    });
}
#end_block

#method_before
@Override
public void setItems(Iterable value) {
    ArrayList<Snapshot> snapshots = value != null ? Linq.<Snapshot>cast(value) : new ArrayList<Snapshot>();
    Collections.sort(snapshots, Collections.reverseOrder(new SnapshotByCreationDateCommparer()));
    ArrayList<Snapshot> sortedSnapshots = new ArrayList<Snapshot>();
    for (Snapshot snapshot : snapshots) {
        SnapshotModel snapshotModel = snapshotsMap.get(snapshot.getId());
        if (snapshotModel == null) {
            snapshotModel = new SnapshotModel();
            snapshotsMap.put(snapshot.getId(), snapshotModel);
        }
        snapshotModel.setEntity(snapshot);
        if ((snapshot.getType() == SnapshotType.ACTIVE && getInType(SnapshotType.PREVIEW, snapshots) == null) || snapshot.getType() == SnapshotType.PREVIEW) {
            sortedSnapshots.add(0, snapshot);
        } else if (snapshot.getType() == SnapshotType.REGULAR || snapshot.getType() == SnapshotType.STATELESS) {
            sortedSnapshots.add(snapshot);
        }
    }
    super.setItems(sortedSnapshots);
    if (isEntityChanged && sortedSnapshots.size() > 1) {
        setSelectedItem(sortedSnapshots.get(1));
    }
    isEntityChanged = false;
    updateActionAvailability();
}
#method_after
@Override
public void setItems(Iterable value) {
    ArrayList<Snapshot> snapshots = value != null ? Linq.<Snapshot>cast(value) : new ArrayList<Snapshot>();
    Collections.sort(snapshots, Collections.reverseOrder(new SnapshotByCreationDateCommparer()));
    ArrayList<Snapshot> sortedSnapshots = new ArrayList<Snapshot>();
    for (Snapshot snapshot : snapshots) {
        SnapshotModel snapshotModel = snapshotsMap.get(snapshot.getId());
        if (snapshotModel == null) {
            snapshotModel = new SnapshotModel();
            snapshotsMap.put(snapshot.getId(), snapshotModel);
        }
        snapshotModel.setEntity(snapshot);
        if ((snapshot.getType() == SnapshotType.ACTIVE && getInType(SnapshotType.PREVIEW, snapshots) == null) || snapshot.getType() == SnapshotType.PREVIEW) {
            sortedSnapshots.add(0, snapshot);
        } else if (snapshot.getType() == SnapshotType.REGULAR || snapshot.getType() == SnapshotType.STATELESS) {
            sortedSnapshots.add(snapshot);
        }
    }
    super.setItems(sortedSnapshots);
    // Try to select the last created snapshot (fallback to active snapshot)
    if (getSelectedItem() == null) {
        setSelectedItem(sortedSnapshots.size() > 1 ? sortedSnapshots.get(1) : sortedSnapshots.get(0));
    }
    updateActionAvailability();
}
#end_block

#method_before
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    if (getEntity() != null) {
        isEntityChanged = true;
        getSearchCommand().execute();
    }
}
#method_after
@Override
protected void onEntityChanged() {
    super.onEntityChanged();
    if (getEntity() != null) {
        getSearchCommand().execute();
    }
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    if (getSelectedItem() != null) {
        Snapshot snapshot = ((Snapshot) getSelectedItem());
        updateVmConfigurationBySnapshot(snapshot.getId());
    }
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#end_block

#method_before
private void onRemove() {
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    VM vm = (VM) getEntity();
    if (vm != null) {
        Frontend.RunAction(VdcActionType.RemoveSnapshot, new RemoveSnapshotParameters(snapshot.getId(), vm.getId()), null, null);
    }
    getCanSelectSnapshot().setEntity(false);
    cancel();
}
#method_after
private void onRemove() {
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    VM vm = (VM) getEntity();
    if (vm != null) {
        Frontend.getInstance().runAction(VdcActionType.RemoveSnapshot, new RemoveSnapshotParameters(snapshot.getId(), vm.getId()), null, null);
    }
    getCanSelectSnapshot().setEntity(false);
    cancel();
}
#end_block

#method_before
private void undo() {
    VM vm = (VM) getEntity();
    if (vm != null) {
        Snapshot snapshot = getPreview();
        Frontend.RunAction(VdcActionType.RestoreAllSnapshots, new RestoreAllSnapshotsParameters(vm.getId(), snapshot.getId()), null, null);
    }
}
#method_after
private void undo() {
    VM vm = (VM) getEntity();
    if (vm != null) {
        Snapshot snapshot = getPreview();
        Frontend.getInstance().runAction(VdcActionType.RestoreAllSnapshots, new RestoreAllSnapshotsParameters(vm.getId(), snapshot.getId()), null, null);
    }
}
#end_block

#method_before
private void commit() {
    VM vm = (VM) getEntity();
    if (vm != null) {
        Snapshot snapshot = getInPreview();
        Frontend.RunAction(VdcActionType.RestoreAllSnapshots, new RestoreAllSnapshotsParameters(vm.getId(), snapshot.getId()), null, null);
    }
}
#method_after
private void commit() {
    VM vm = (VM) getEntity();
    if (vm != null) {
        Snapshot snapshot = getInPreview();
        Frontend.getInstance().runAction(VdcActionType.RestoreAllSnapshots, new RestoreAllSnapshotsParameters(vm.getId(), snapshot.getId()), null, null);
    }
}
#end_block

#method_before
private void preview() {
    VM vm = (VM) getEntity();
    if (vm == null) {
        return;
    }
    Snapshot snapshot = (Snapshot) getSelectedItem();
    // if snapshot doesn't have memory, just trigger preview without showing popup
    if (!isMemorySnapshotSupported() || snapshot.getMemoryVolume().isEmpty()) {
        Frontend.RunAction(VdcActionType.TryBackToAllSnapshotsOfVm, new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId()), null);
    } else // otherwise, show a popup asking whether to use the memory or not
    {
        SnapshotModel model = new SnapshotModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().previewSnapshotTitle());
        // $NON-NLS-1$
        model.setHashName("preview_snapshot");
        model.getCommands().add(// $NON-NLS-1$
        new UICommand("OnPreview", this).setTitle(ConstantsManager.getInstance().getConstants().ok()).setIsDefault(true));
        UICommand cancelCommand = // $NON-NLS-1$
        new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true);
        model.getCommands().add(cancelCommand);
        model.setCancelCommand(cancelCommand);
        model.setCloseCommand(// $NON-NLS-1$
        new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().close()).setIsCancel(true));
    }
}
#method_after
private void preview() {
    VM vm = (VM) getEntity();
    if (vm == null) {
        return;
    }
    Snapshot snapshot = (Snapshot) getSelectedItem();
    // if snapshot doesn't have memory, just trigger preview without showing popup
    if (!isMemorySnapshotSupported() || snapshot.getMemoryVolume().isEmpty()) {
        Frontend.getInstance().runAction(VdcActionType.TryBackToAllSnapshotsOfVm, new TryBackToAllSnapshotsOfVmParameters(vm.getId(), snapshot.getId()), null);
    } else // otherwise, show a popup asking whether to use the memory or not
    {
        SnapshotModel model = new SnapshotModel();
        setWindow(model);
        model.setTitle(ConstantsManager.getInstance().getConstants().previewSnapshotTitle());
        // $NON-NLS-1$
        model.setHashName("preview_snapshot");
        // $NON-NLS-1$
        addCommands(model, "OnPreview");
    }
}
#end_block

#method_before
private void newEntity() {
    VM vm = (VM) getEntity();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.initialize();
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.setCloseCommand(closeCommand);
}
#method_after
private void newEntity() {
    VM vm = (VM) getEntity();
    if (vm == null || getWindow() != null) {
        return;
    }
    SnapshotModel model = new SnapshotModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().createSnapshotTitle());
    // $NON-NLS-1$
    model.setHashName("create_snapshot");
    model.setVm(vm);
    model.initialize();
    model.setCancelCommand(// $NON-NLS-1$
    new UICommand("Cancel", this).setTitle(ConstantsManager.getInstance().getConstants().cancel()).setIsCancel(true));
}
#end_block

#method_before
private void onCloneVM() {
    UnitVmModel model = (UnitVmModel) getWindow();
    CloneVmFromSnapshotModelBehavior behavior = (CloneVmFromSnapshotModelBehavior) model.getBehavior();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    setcurrentVm(behavior.getVm());
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomProperties().getEntity());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    VDS defaultHost = model.getDefaultHost().getSelectedItem();
    getcurrentVm().setDedicatedVmForVds(model.getIsAutoAssign().getEntity() ? null : defaultHost.getId());
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setDiskMap(behavior.getVm().getDiskMap());
    HashMap<Guid, DiskImage> imageToDestinationDomainMap = model.getDisksAllocationModel().getImageToDestinationDomainMap();
    AddVmFromSnapshotParameters parameters = new AddVmFromSnapshotParameters(getcurrentVm().getStaticData(), snapshot.getId());
    parameters.setDiskInfoDestinationMap(imageToDestinationDomainMap);
    setupAddVmFromSnapshotParameters(parameters);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    model.startProgress(null);
    Frontend.RunAction(VdcActionType.AddVmFromSnapshot, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) result.getState();
            vmSnapshotListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmSnapshotListModel.cancel();
                vmSnapshotListModel.updateActionAvailability();
            }
        }
    }, this);
}
#method_after
private void onCloneVM() {
    UnitVmModel model = (UnitVmModel) getWindow();
    CloneVmFromSnapshotModelBehavior behavior = (CloneVmFromSnapshotModelBehavior) model.getBehavior();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    if (snapshot == null) {
        cancel();
        return;
    }
    if (!model.validate()) {
        return;
    }
    setcurrentVm(behavior.getVm());
    String name = model.getName().getEntity();
    // Save changes.
    VmTemplate template = model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType(model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    getcurrentVm().setVmOs(model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors(model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setVmDescription(model.getDescription().getEntity());
    getcurrentVm().setComment(model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb(model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem(model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? (model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets(model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity()) / model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy(model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless(model.getIsStateless().getEntity());
    getcurrentVm().setSmartcardEnabled(model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected(model.getIsDeleteProtected().getEntity());
    getcurrentVm().setSsoMethod(model.extractSelectedSsoMethod());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup(model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl(model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl(model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams(model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomProperties().getEntity());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(model.getQuota().getSelectedItem().getId());
    }
    getcurrentVm().setVncKeyboardLayout(model.getVncKeyboardLayout().getSelectedItem());
    EntityModel<DisplayType> displayProtocolSelectedItem = model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType(displayProtocolSelectedItem.getEntity());
    EntityModel<Integer> prioritySelectedItem = model.getPriority().getSelectedItem();
    getcurrentVm().setPriority(prioritySelectedItem.getEntity());
    VDS defaultHost = model.getDefaultHost().getSelectedItem();
    getcurrentVm().setDedicatedVmForVds(model.getIsAutoAssign().getEntity() ? null : defaultHost.getId());
    getcurrentVm().setMigrationSupport(model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags(model.getHostCpu().getEntity());
    getcurrentVm().setDiskMap(behavior.getVm().getDiskMap());
    HashMap<Guid, DiskImage> imageToDestinationDomainMap = model.getDisksAllocationModel().getImageToDestinationDomainMap();
    AddVmFromSnapshotParameters parameters = new AddVmFromSnapshotParameters(getcurrentVm().getStaticData(), snapshot.getId());
    parameters.setDiskInfoDestinationMap(imageToDestinationDomainMap);
    setupAddVmFromSnapshotParameters(parameters);
    parameters.setConsoleEnabled(model.getIsConsoleDeviceEnabled().getEntity());
    parameters.setVirtioScsiEnabled(model.getIsVirtioScsiEnabled().getEntity());
    model.startProgress(null);
    Frontend.getInstance().runAction(VdcActionType.AddVmFromSnapshot, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmSnapshotListModel vmSnapshotListModel = (VmSnapshotListModel) result.getState();
            vmSnapshotListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmSnapshotListModel.cancel();
                vmSnapshotListModel.updateActionAvailability();
            }
        }
    }, this);
}
#end_block

#method_before
public void updateActionAvailability() {
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#method_after
public void updateActionAvailability() {
    VM vm = (VM) getEntity();
    Snapshot snapshot = (Snapshot) getSelectedItem();
    List<VM> vmList = vm != null ? Collections.singletonList(vm) : Collections.<VM>emptyList();
    boolean isVmDown = vm != null && vm.getStatus() == VMStatus.Down;
    boolean isVmImageLocked = vm != null && vm.getStatus() == VMStatus.ImageLocked;
    boolean isPreviewing = getIsPreviewing();
    boolean isLocked = getIsLocked();
    boolean isSelected = snapshot != null && snapshot.getType() != SnapshotType.ACTIVE;
    boolean isStateless = getIsStateless();
    boolean isCloneVmSupported = getIsCloneVmSupported();
    getCanSelectSnapshot().setEntity(!isPreviewing && !isLocked && !isStateless && VdcActionUtils.canExecute(vmList, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getNewCommand().setIsExecutionAllowed(!isPreviewing && !isLocked && !isVmImageLocked && !isStateless);
    getPreviewCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCustomPreviewCommand().setIsExecutionAllowed(getPreviewCommand().getIsExecutionAllowed());
    getCommitCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getUndoCommand().setIsExecutionAllowed(isPreviewing && isVmDown && !isStateless);
    getRemoveCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && isVmDown && !isStateless);
    getCloneVmCommand().setIsExecutionAllowed(isSelected && !isLocked && !isPreviewing && !isVmImageLocked && !isStateless && isCloneVmSupported);
}
#end_block

#method_before
protected boolean isMemorySnapshotSupported() {
    if (getEntity() == null) {
        return false;
    }
    VM vm = (VM) getEntity();
    boolean archSnapshotSupported = AsyncDataProvider.isSnapshotSupported(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    return ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archSnapshotSupported;
}
#method_after
protected boolean isMemorySnapshotSupported() {
    if (getEntity() == null) {
        return false;
    }
    VM vm = (VM) getEntity();
    boolean archMemorySnapshotSupported = AsyncDataProvider.isMemorySnapshotSupportedByArchitecture(vm.getClusterArch(), vm.getVdsGroupCompatibilityVersion());
    return ((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MemorySnapshotSupported, vm.getVdsGroupCompatibilityVersion().toString())) && archMemorySnapshotSupported;
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getPreviewCommand()) {
        preview();
    } else if (command == getCommitCommand()) {
        commit();
    } else if (command == getUndoCommand()) {
        undo();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getCloneVmCommand()) {
        cloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCloneVM")) {
        onCloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnPreview")) {
        OnPreview();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getPreviewCommand()) {
        preview();
    } else if (command == getCustomPreviewCommand()) {
        customPreview();
    } else if (command == getCommitCommand()) {
        commit();
    } else if (command == getUndoCommand()) {
        undo();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getCloneVmCommand()) {
        cloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCloneVM")) {
        onCloneVM();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnPreview")) {
        onPreview();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnCustomPreview")) {
        onCustomPreview();
    }
}
#end_block

#method_before
protected void initCredentials(String domain) {
    DbUser curUser;
    String curPassword;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        setLoginName(curUser.getLoginName());
        setPassword(curPassword);
        setAuthenticationDomain(curUser.getDomain());
    } else {
        Domain domainObject = UsersDomainsCacheManagerService.getInstance().getDomain(domain);
        if (domainObject != null) {
            setLoginName(domainObject.getUserName());
            setPassword(domainObject.getPassword());
            if (getLoginName().contains("@")) {
                String userDomain = getLoginName().split("@")[1].toLowerCase();
                setAuthenticationDomain(userDomain);
            } else {
                setAuthenticationDomain(domain);
            }
        }
    }
}
#method_after
protected void initCredentials(String domain) {
    setUserDomainCredentials(domain);
}
#end_block

#method_before
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccured = false;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccured = directorySearcher.getException() != null;
    } catch (RuntimeException e) {
        log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
    } finally {
        if (exceptionOccured) {
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#method_after
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccurred = true;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccurred = directorySearcher.getException() != null;
    } finally {
        if (exceptionOccurred) {
            log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#end_block

#method_before
protected LdapUser populateUserData(LdapUser user, String domain) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, LdapGroup> groupsDict = new java.util.HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(null, user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    if (user.getUserName() != null && !user.getUserName().contains("@")) {
        user.setUserName(user.getUserName() + "@" + user.getDomainControler());
    }
    if (user != null) {
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData currQueryData : partialQueries) {
                populateGroup(currQueryData, getAuthenticationDomain(), groupsDict, getLoginName(), getPassword());
            }
        }
    }
    user.setGroups(groupsDict);
    return user;
}
#method_after
protected LdapUser populateUserData(LdapUser user, String domain) {
    return populateUserData(user, domain, true);
}
#end_block

#method_before
protected LdapUser populateUserData(LdapUser user, String domain) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, LdapGroup> groupsDict = new java.util.HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(null, user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    if (user.getUserName() != null && !user.getUserName().contains("@")) {
        user.setUserName(user.getUserName() + "@" + user.getDomainControler());
    }
    if (user != null) {
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData currQueryData : partialQueries) {
                populateGroup(currQueryData, getAuthenticationDomain(), groupsDict, getLoginName(), getPassword());
            }
        }
    }
    user.setGroups(groupsDict);
    return user;
}
#method_after
protected LdapUser populateUserData(LdapUser user, String domain, boolean populateGroups) {
    if (user == null) {
        return null;
    }
    user.setDomainControler(domain);
    // Getting the groups
    java.util.HashMap<String, LdapGroup> groupsDict = new java.util.HashMap<String, LdapGroup>();
    GroupsDNQueryGenerator generator = new GroupsDNQueryGenerator();
    proceedGroupsSearchResult(null, user.getMemberof(), groupsDict, generator);
    user.setGroups(groupsDict);
    if (user.getUserName() != null && !user.getUserName().contains("@")) {
        user.setUserName(user.getUserName() + "@" + user.getDomainControler());
    }
    if (populateGroups) {
        if (generator.getHasValues()) {
            List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
            for (LdapQueryData currQueryData : partialQueries) {
                populateGroup(currQueryData, getAuthenticationDomain(), groupsDict, getLoginName(), getPassword());
            }
        }
    }
    user.setGroups(groupsDict);
    return user;
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        authResult = handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        if (authResult == null) {
            authResult = new UserAuthenticationResult(user, VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        } else if (authResult.getErrorMessages().isEmpty()) {
            authResult.getErrorMessages().add(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        }
    }
    setReturnValue(authResult);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        throw new AAAExtensionException(AAAExtensionError.GENERAL_ERROR, "User failed to authenticate");
    }
    setReturnValue(authResult);
}
#end_block

#method_before
private UserAuthenticationResult handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    VdcBllMessages errorMsg = VdcBllMessages.USER_FAILED_TO_AUTHENTICATE;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        errorMsg = VdcBllMessages.valueOf(result.getVdcBllMessage());
        log.error(result.getDetailedMessage());
    }
    authResult = new UserAuthenticationResult(errorMsg);
    return authResult;
}
#method_after
private void handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    AAAExtensionException aaaException = null;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        log.error(result.getDetailedMessage());
        throw new AAAExtensionException(authResultToExceptionMap.get(result), "");
    }
}
#end_block

#method_before
@Override
protected void handleRootDSEFailure(DirectorySearcher directorySearcher) {
    Exception ex = directorySearcher.getException();
    UserAuthenticationResult authResult = handleDirectorySearcherException(ex);
    setReturnValue(authResult);
}
#method_after
@Override
protected void handleRootDSEFailure(DirectorySearcher directorySearcher) {
    Exception ex = directorySearcher.getException();
    handleDirectorySearcherException(ex);
}
#end_block

#method_before
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccured = false;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccured = directorySearcher.getException() != null;
    } catch (RuntimeException e) {
        log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
    } finally {
        if (exceptionOccured) {
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#method_after
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccurred = true;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccurred = directorySearcher.getException() != null;
    } finally {
        if (exceptionOccurred) {
            log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    DbUser curUser = null;
    String curPassword = null;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        loginName = curUser.getLoginName();
        password = curPassword;
    }
    // Perform the actual authentication:
    try {
        if (!passwordAuthenticator.authenticate(loginName, password)) {
            return false;
        }
    } catch (AAAExtensionException ex) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", loginName, profileName);
        AuditLogType auditLogType = auditLogMap.get(ex.getError());
        // if found matching audit log type, and it's not general login failure audit log (which will be logged anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            LdapBrokerUtils.logEventForUser(loginName, auditLogType);
        }
        VdcBllMessages canDoActionMsg = vdcBllMessagesMap.get(ex.getError());
        String passwordChangeMsg = passwordChangeMsgPerDomain.get(getParameters().getProfileName());
        getReturnValue().setSucceeded(false);
        if (canDoActionMsg == VdcBllMessages.USER_PASSWORD_EXPIRED && passwordChangeMsg != null) {
            if (passwordChangeMsg.indexOf("http") == 0 || passwordChangeMsg.indexOf("https") == 0) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$URL %1$s", passwordChangeMsg));
            } else {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$MSG %1$s", passwordChangeMsg));
            }
        } else {
            getReturnValue().getCanDoActionMessages().add(canDoActionMsg.name());
        }
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    DbUser curUser = null;
    String curPassword = null;
    SessionDataContainer sessionDataContainer = SessionDataContainer.getInstance();
    if (StringUtils.isEmpty(getParameters().getSessionId())) {
        curUser = sessionDataContainer.getUser(false);
        curPassword = sessionDataContainer.getPassword();
    } else {
        curUser = sessionDataContainer.getUser(getParameters().getSessionId(), false);
        curPassword = sessionDataContainer.getPassword(getParameters().getSessionId());
    }
    // verify that in auto login mode , user is not taken from session.
    if (curUser != null && !StringUtils.isEmpty(curPassword)) {
        loginName = curUser.getLoginName();
        password = curPassword;
    }
    // Perform the actual authentication:
    try {
        passwordAuthenticator.authenticate(loginName, password);
    } catch (AAAExtensionException ex) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", loginName, profileName);
        AuditLogType auditLogType = auditLogMap.get(ex.getError());
        // if found matching audit log type, and it's not general login failure audit log (which will be logged anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            LdapBrokerUtils.logEventForUser(loginName, auditLogType);
        }
        VdcBllMessages canDoActionMsg = vdcBllMessagesMap.get(ex.getError());
        getReturnValue().setSucceeded(false);
        if (canDoActionMsg == VdcBllMessages.USER_PASSWORD_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (passwordAuthenticator.getChangeExpiredPasswordMsg() != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$MSG %1$s", passwordAuthenticator.getChangeExpiredPasswordMsg()));
                addedUserPasswordExpiredCDA = true;
            }
            if (passwordAuthenticator.getChangeExpiredPasswordURL() != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$URL %1$s", passwordAuthenticator.getChangeExpiredPasswordURL()));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            getReturnValue().getCanDoActionMessages().add(canDoActionMsg.name());
        }
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            GroupsDNQueryGenerator generator = createGroupsGeneratorForUser(user);
            if (generator.getHasValues()) {
                List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
                for (LdapQueryData currQueryData : partialQueries) {
                    populateGroup(currQueryData, getAuthenticationDomain(), user.getGroups(), getLoginName(), getPassword());
                }
            }
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        throw new AAAExtensionException(ExtensionError.GENERAL_ERROR, "User failed to authenticate");
    }
    setReturnValue(authResult);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            GroupsDNQueryGenerator generator = createGroupsGeneratorForUser(user);
            if (generator.getHasValues()) {
                List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
                for (LdapQueryData currQueryData : partialQueries) {
                    populateGroup(currQueryData, getAuthenticationDomain(), user.getGroups(), getLoginName(), getPassword());
                }
            }
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        throw new AAAExtensionException(AAAExtensionError.GENERAL_ERROR, "User failed to authenticate");
    }
    setReturnValue(authResult);
}
#end_block

#method_before
private void handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    AAAExtensionException aaaException = null;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        log.error(result.getDetailedMessage());
        throw authResultToExceptionMap.get(result);
    }
}
#method_after
private void handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    AAAExtensionException aaaException = null;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        log.error(result.getDetailedMessage());
        throw new AAAExtensionException(authResultToExceptionMap.get(result), "");
    }
}
#end_block

#method_before
public ExtensionError getError() {
    return error;
}
#method_after
public AAAExtensionError getError() {
    return error;
}
#end_block

#method_before
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccured = false;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccured = directorySearcher.getException() != null;
    } catch (RuntimeException e) {
        log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
    } finally {
        if (exceptionOccured) {
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#method_after
@Override
public LdapReturnValueBase execute() {
    boolean exceptionOccurred = true;
    try {
        log.debugFormat("Running LDAP command: {0}", getClass().getName());
        String loginNameForKerberos = LdapBrokerUtils.modifyLoginNameForKerberos(getLoginName(), getAuthenticationDomain());
        LdapCredentials ldapCredentials = new LdapCredentials(loginNameForKerberos, getPassword());
        DirectorySearcher directorySearcher = new DirectorySearcher(ldapCredentials);
        executeQuery(directorySearcher);
        exceptionOccurred = directorySearcher.getException() != null;
    } finally {
        if (exceptionOccurred) {
            log.error(String.format("Failed to run command %s. Domain is %s. User is %s.", getClass().getSimpleName(), getDomain(), getLoginName()));
            _ldapReturnValue.setExceptionString(VdcBllMessages.FAILED_TO_RUN_LDAP_QUERY.name());
            _ldapReturnValue.setSucceeded(false);
        }
    }
    return _ldapReturnValue;
}
#end_block

#method_before
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    // Perform the actual authentication:
    try {
        if (!passwordAuthenticator.authenticate(loginName, password)) {
            return false;
        }
    } catch (AAAExtensionException ex) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", loginName, profileName);
        AuditLogType auditLogType = auditLogMap.get(ex.getError());
        // if found matching audit log type, and it's not general login failure audit log (which will be logged anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            LdapBrokerUtils.logEventForUser(loginName, auditLogType);
        }
        VdcBllMessages canDoActionMsg = vdcBllMessagesMap.get(ex.getError());
        String passwordChangeMsg = passwordChangeMsgPerDomain.get(getParameters().getProfileName());
        getReturnValue().setSucceeded(false);
        if (canDoActionMsg == VdcBllMessages.USER_PASSWORD_EXPIRED && passwordChangeMsg != null) {
            if (passwordChangeMsg.indexOf("http") == 0 || passwordChangeMsg.indexOf("https") == 0) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$URL %1$s", passwordChangeMsg));
            } else {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$MSG %1$s", passwordChangeMsg));
            }
        } else {
            getReturnValue().getCanDoActionMessages().add(canDoActionMsg.name());
        }
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#method_after
protected boolean isUserCanBeAuthenticated() {
    // Check if the user is already logged in:
    DbUser dbUser = SessionDataContainer.getInstance().getUser(false);
    if (dbUser != null) {
        addCanDoActionMessage(VdcBllMessages.USER_IS_ALREADY_LOGGED_IN);
        return false;
    }
    // Verify that the login name and password have been provided:
    String loginName = getParameters().getLoginName();
    if (loginName == null) {
        log.errorFormat("Can't login user because no login name has been provided.");
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    String password = getParameters().getPassword();
    if (password == null) {
        log.errorFormat("Can't login user \"{0}\" because no password has been provided.", loginName);
        return false;
    }
    // Check that the authentication profile name has been provided:
    String profileName = getParameters().getProfileName();
    if (profileName == null) {
        log.errorFormat("Can't login user \"{0}\" because no authentication profile name has been provided.", loginName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authentication profile exists:
    AuthenticationProfile profile = AuthenticationProfileRepository.getInstance().getProfile(profileName);
    if (profile == null) {
        log.errorFormat("Can't login user \"{0}\" because authentication profile \"{1}\" doesn't exist.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    // Check that the authenticator provided by the profile supports password authentication:
    Authenticator authenticator = profile.getAuthenticator();
    if (!(authenticator instanceof PasswordAuthenticator)) {
        log.errorFormat("Can't login user \"{0}\" because the authentication profile \"{1}\" doesn't support password " + "authentication.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_FAILED_TO_AUTHENTICATE);
        return false;
    }
    PasswordAuthenticator passwordAuthenticator = (PasswordAuthenticator) authenticator;
    // Perform the actual authentication:
    try {
        passwordAuthenticator.authenticate(loginName, password);
    } catch (AAAExtensionException ex) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the authentication failed.", loginName, profileName);
        AuditLogType auditLogType = auditLogMap.get(ex.getError());
        // if found matching audit log type, and it's not general login failure audit log (which will be logged anyway due to CommandBase.log)
        if (auditLogType != null && auditLogType != AuditLogType.USER_VDC_LOGIN_FAILED) {
            LdapBrokerUtils.logEventForUser(loginName, auditLogType);
        }
        VdcBllMessages canDoActionMsg = vdcBllMessagesMap.get(ex.getError());
        getReturnValue().setSucceeded(false);
        if (canDoActionMsg == VdcBllMessages.USER_PASSWORD_EXPIRED) {
            boolean addedUserPasswordExpiredCDA = false;
            if (passwordAuthenticator.getChangeExpiredPasswordMsg() != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_MSG_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$MSG %1$s", passwordAuthenticator.getChangeExpiredPasswordMsg()));
                addedUserPasswordExpiredCDA = true;
            }
            if (passwordAuthenticator.getChangeExpiredPasswordURL() != null) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED_CHANGE_URL_PROVIDED);
                getReturnValue().getCanDoActionMessages().add(String.format("$URL %1$s", passwordAuthenticator.getChangeExpiredPasswordURL()));
                addedUserPasswordExpiredCDA = true;
            }
            if (!addedUserPasswordExpiredCDA) {
                addCanDoActionMessage(VdcBllMessages.USER_PASSWORD_EXPIRED);
            }
        } else {
            getReturnValue().getCanDoActionMessages().add(canDoActionMsg.name());
        }
        return false;
    }
    // Check that the user exists in the directory associated to the authentication profile:
    Directory directory = profile.getDirectory();
    DirectoryUser directoryUser = directory.findUser(loginName);
    if (directoryUser == null) {
        log.infoFormat("Can't login user \"{0}\" with authentication profile \"{1}\" because the user doesn't exist in the " + "directory.", loginName, profileName);
        addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
        return false;
    }
    // Check that the user exists in the database, if it doesn't exist then we need to add it now:
    dbUser = getDbUserDAO().getByExternalId(directory.getName(), directoryUser.getId());
    if (dbUser == null) {
        dbUser = new DbUser(directoryUser);
        dbUser.setId(Guid.newGuid());
        String groupIds = DirectoryUtils.getGroupIdsFromUser(directoryUser);
        dbUser.setGroupIds(groupIds);
        getDbUserDAO().save(dbUser);
    }
    // except the login command
    if (!checkUserAndGroupsAuthorization(dbUser.getId(), dbUser.getGroupIds(), getActionType().getActionGroup(), MultiLevelAdministrationHandler.BOTTOM_OBJECT_ID, VdcObjectType.Bottom, true)) {
        addCanDoActionMessage(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION);
        return false;
    }
    // Retrieve the MLA admin status of the user.
    // This may be redundant in some use-cases, but looking forward to Single Sign On,
    // we will want this info
    boolean isAdmin = MultiLevelAdministrationHandler.isAdminUser(dbUser);
    log.debugFormat("Checking if user {0} is an admin, result {1}", dbUser.getLoginName(), isAdmin);
    dbUser.setAdmin(isAdmin);
    setCurrentUser(dbUser);
    // Add the user password to the session, as it will be needed later
    // when trying to log on to virtual machines:
    SessionDataContainer.getInstance().setPassword(password);
    return true;
}
#end_block

#method_before
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
}
#method_after
@Override
public void init() {
    broker = LdapFactory.getInstance(getProfileName());
    context.put(ExtensionProperties.AUTHOR, "The oVirt Project");
    context.put(ExtensionProperties.EXTENSION_NAME, "Internal Kerberos/LDAP authentication (Built-in)");
    context.put(ExtensionProperties.LICENSE, "ASL 2.0");
    context.put(ExtensionProperties.HOME, "http://www.ovirt.org");
    context.put(ExtensionProperties.VERSION, "N/A");
    if (passwordChangeMsgPerDomain == null) {
        synchronized (ProvisionalAuthenticator.class) {
            if (passwordChangeMsgPerDomain == null) {
                passwordChangeMsgPerDomain = new HashMap<>();
                String changePasswordUrl = Config.<String>getValue(ConfigValues.ChangePasswordMsg);
                String[] pairs = changePasswordUrl.split(",");
                for (String pair : pairs) {
                    // Split the pair in such a way that if the URL contains :, it will not be split to strings
                    String[] pairParts = pair.split(":", 2);
                    if (pairParts.length >= 2) {
                        try {
                            passwordChangeMsgPerDomain.put(pairParts[0], URLDecoder.decode(pairParts[1], "UTF-8"));
                        } catch (UnsupportedEncodingException e) {
                            throw new AAAExtensionException(AAAExtensionError.INVALID_CONFIGURATION, "error in obtaining the password change message or url for " + pairParts[0]);
                        }
                    }
                }
            }
        }
    }
    String changePasswordMsgOrUrl = passwordChangeMsgPerDomain.get(getProfileName());
    if (changePasswordMsgOrUrl != null) {
        ExtensionProperties key = containsURL(changePasswordMsgOrUrl) ? ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_URL : ExtensionProperties.AAA_CHANGE_EXPIRED_PASSWORD_MSG;
        context.put(key, changePasswordMsgOrUrl);
    }
}
#end_block

#method_before
@Override
public boolean authenticate(String name, String password) {
    LdapReturnValueBase ldapResult = broker.runAdAction(AdActionType.AuthenticateUser, new LdapUserPasswordBaseParameters(getProfileName(), name, password));
    return ldapResult.getSucceeded();
}
#method_after
@Override
public void authenticate(String name, String password) {
    broker.runAdAction(AdActionType.AuthenticateUser, new LdapUserPasswordBaseParameters(getProfileName(), name, password));
}
#end_block

#method_before
@Override
public boolean authenticate(String name, String password) {
    return true;
}
#method_after
@Override
public void authenticate(String name, String password) {
}
#end_block

#method_before
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            GroupsDNQueryGenerator generator = createGroupsGeneratorForUser(user);
            if (generator.getHasValues()) {
                List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
                for (LdapQueryData currQueryData : partialQueries) {
                    populateGroup(currQueryData, getAuthenticationDomain(), user.getGroups(), getLoginName(), getPassword());
                }
            }
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        throw new AAAExtensionException(ExtensionError.GENERAL_ERROR, "User failed to authenticate");
    }
    setReturnValue(authResult);
}
#method_after
@Override
protected void executeQuery(DirectorySearcher directorySearcher) {
    log.debug("Executing LdapAuthenticateUserCommand");
    directorySearcher.setExplicitAuth(true);
    LdapUser user = null;
    UserAuthenticationResult authResult = null;
    LdapQueryData queryData = new LdapQueryDataImpl();
    if (getLoginName().contains("@")) {
        // the user name is UPN use 'User
        // Principal Name' search
        queryData.setLdapQueryType(LdapQueryType.getUserByPrincipalName);
        // The domain in the UPN must overwrite the domain field. Discrepancies between the UPN domain and
        // the domain may lead failure in Kerberos queries
        String[] loginNameParts = getLoginName().split("@");
        String principalName = constructPrincipalName(loginNameParts[0], loginNameParts[1]);
        String domain = loginNameParts[1].toLowerCase();
        queryData.setFilterParameters(new Object[] { principalName });
        queryData.setDomain(domain);
        setDomain(domain);
        setAuthenticationDomain(domain);
    } else {
        // the user name is NT format use 'SAM Account Name' search
        setAuthenticationDomain(getDomain());
        queryData.setDomain(getDomain());
        queryData.setLdapQueryType(LdapQueryType.getUserByName);
        queryData.setFilterParameters(new Object[] { getLoginName() });
    }
    Object searchResult = directorySearcher.findOne(queryData);
    if (searchResult == null) {
        log.errorFormat("Failed authenticating user: {0} to domain {1}. Ldap Query Type is {2}", getLoginName(), getAuthenticationDomain(), queryData.getLdapQueryType().name());
        setSucceeded(false);
        Exception ex = directorySearcher.getException();
        handleDirectorySearcherException(ex);
    } else {
        user = populateUserData((LdapUser) searchResult, getAuthenticationDomain());
        if (user != null) {
            user.setUserName(getLoginName());
            GroupsDNQueryGenerator generator = createGroupsGeneratorForUser(user);
            if (generator.getHasValues()) {
                List<LdapQueryData> partialQueries = generator.getLdapQueriesData();
                for (LdapQueryData currQueryData : partialQueries) {
                    populateGroup(currQueryData, getAuthenticationDomain(), user.getGroups(), getLoginName(), getPassword());
                }
            }
            authResult = new UserAuthenticationResult(user);
            setSucceeded(true);
        } else {
            log.errorFormat("Failed authenticating. Domain is {0}. User is {1}. The user doesn't have a UPN", getAuthenticationDomain(), getLoginName());
            setSucceeded(false);
        }
    }
    if (!getSucceeded()) {
        throw new AAAExtensionException(AAAExtensionError.GENERAL_ERROR, "User failed to authenticate");
    }
    setReturnValue(authResult);
}
#end_block

#method_before
private void handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    AAAExtensionException aaaException = null;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        log.error(result.getDetailedMessage());
        throw authResultToExceptionMap.get(result);
    }
}
#method_after
private void handleDirectorySearcherException(Exception ex) {
    UserAuthenticationResult authResult = null;
    AAAExtensionException aaaException = null;
    if (ex instanceof AuthenticationResultException) {
        AuthenticationResultException authResultException = (AuthenticationResultException) ex;
        AuthenticationResult result = authResultException.getResult();
        if (result == null) {
            result = AuthenticationResult.OTHER;
        }
        log.error(result.getDetailedMessage());
        throw new AAAExtensionException(authResultToExceptionMap.get(result), "");
    }
}
#end_block

#method_before
@Override
public boolean authenticate(String user, String password) {
    String adminName = Config.<String>getValue(ConfigValues.AdminUser);
    String adminPassword = Config.<String>getValue(ConfigValues.AdminPassword);
    return ObjectUtils.equals(user, adminName) && ObjectUtils.equals(password, adminPassword);
}
#method_after
@Override
public void authenticate(String user, String password) {
    String adminName = Config.<String>getValue(ConfigValues.AdminUser);
    String adminPassword = Config.<String>getValue(ConfigValues.AdminPassword);
    if (!ObjectUtils.equals(user, adminName) || !ObjectUtils.equals(password, adminPassword)) {
        throw new AAAExtensionException(AAAExtensionException.AAAExtensionError.INCORRECT_CREDENTIALS, "");
    }
}
#end_block

#method_before
public void init(final VmBase vm) {
    getWindowsSysprepTimeZoneEnabled().setEntity(false);
    getRegenerateKeysEnabled().setEntity(false);
    getTimeZoneEnabled().setEntity(false);
    getNetworkEnabled().setEntity(false);
    getAttachmentEnabled().setEntity(false);
    getPasswordSet().setEntity(false);
    getPasswordSet().setIsChangable(false);
    getWindowsHostname().setEntity("");
    getInputLocale().setEntity(VmInit.DEFALUT_LOCALE);
    getUiLanguage().setEntity(VmInit.DEFALUT_LOCALE);
    getSystemLocale().setEntity(VmInit.DEFALUT_LOCALE);
    getUserLocale().setEntity(VmInit.DEFALUT_LOCALE);
    getHostname().setEntity("");
    getDomain().setEntity("");
    getRootPassword().setEntity("");
    getRootPasswordVerification().setEntity("");
    getAuthorizedKeys().setEntity("");
    getRegenerateKeysEnabled().setEntity(false);
    getCustomScript().setEntity("");
    Map<String, String> timezones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZoneList().setItems(timezones.entrySet());
    getTimeZoneList().setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    Map<String, String> windowsTimezones = TimeZoneType.WINDOWS_TIMEZONE.getTimeZoneList();
    getWindowsSysprepTimeZone().setItems(windowsTimezones.entrySet());
    getWindowsSysprepTimeZone().setSelectedItem(Linq.firstOrDefault(windowsTimezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    isWindowsOS = vm != null ? AsyncDataProvider.isWindowsOsType(vm.getOsId()) : true;
    VmInit vmInit = (vm != null) ? vm.getVmInit() : null;
    if (vmInit != null) {
        if (!StringHelper.isNullOrEmpty(vmInit.getHostname())) {
            getHostname().setEntity(vmInit.getHostname());
            getWindowsHostname().setEntity(vmInit.getHostname());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getInputLocale())) {
            getInputLocale().setEntity(vmInit.getInputLocale());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getUiLanguage())) {
            getUiLanguage().setEntity(vmInit.getUiLanguage());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getSystemLocale())) {
            getSystemLocale().setEntity(vmInit.getSystemLocale());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getUserLocale())) {
            getUserLocale().setEntity(vmInit.getUserLocale());
        }
        getDomain().setEntity(vmInit.getDomain());
        final String tz = vmInit.getTimeZone();
        if (!StringHelper.isNullOrEmpty(tz)) {
            if (AsyncDataProvider.isWindowsOsType(vm.getOsId())) {
                getWindowsSysprepTimeZoneEnabled().setEntity(true);
                selectTimeZone(getWindowsSysprepTimeZone(), windowsTimezones, tz);
            } else {
                getTimeZoneEnabled().setEntity(true);
                selectTimeZone(getTimeZoneList(), timezones, tz);
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getRootPassword())) {
            getRootPassword().setEntity(vmInit.getRootPassword());
            getRootPasswordVerification().setEntity(vmInit.getRootPassword());
        }
        getPasswordSet().setEntity(vmInit.isPasswordAlreadyStored());
        getPasswordSet().setIsChangable(vmInit.isPasswordAlreadyStored());
        if (!StringHelper.isNullOrEmpty(vmInit.getAuthorizedKeys())) {
            getAuthorizedKeys().setEntity(vmInit.getAuthorizedKeys());
        }
        if (vmInit.getRegenerateKeys() != null) {
            getRegenerateKeysEnabled().setEntity(vmInit.getRegenerateKeys());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getCustomScript())) {
            getCustomScript().setEntity(vmInit.getCustomScript());
        }
        initNetworks(vmInit);
    }
}
#method_after
public void init(final VmBase vm) {
    getWindowsSysprepTimeZoneEnabled().setEntity(false);
    getRegenerateKeysEnabled().setEntity(false);
    getTimeZoneEnabled().setEntity(false);
    getNetworkEnabled().setEntity(false);
    getAttachmentEnabled().setEntity(false);
    getPasswordSet().setEntity(false);
    getPasswordSet().setIsChangable(false);
    getWindowsHostname().setEntity("");
    getHostname().setEntity("");
    getDomain().setEntity("");
    getRootPassword().setEntity("");
    getRootPasswordVerification().setEntity("");
    getAuthorizedKeys().setEntity("");
    getRegenerateKeysEnabled().setEntity(false);
    getCustomScript().setEntity("");
    Map<String, String> timezones = TimeZoneType.GENERAL_TIMEZONE.getTimeZoneList();
    getTimeZoneList().setItems(timezones.entrySet());
    getTimeZoneList().setSelectedItem(Linq.firstOrDefault(timezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    Map<String, String> windowsTimezones = TimeZoneType.WINDOWS_TIMEZONE.getTimeZoneList();
    getWindowsSysprepTimeZone().setItems(windowsTimezones.entrySet());
    getWindowsSysprepTimeZone().setSelectedItem(Linq.firstOrDefault(windowsTimezones.entrySet(), new IPredicate<Map.Entry<String, String>>() {

        @Override
        public boolean match(Map.Entry<String, String> item) {
            // $NON-NLS-1$
            return item.getValue().startsWith("(GMT) Greenwich");
        }
    }));
    isWindowsOS = vm != null ? AsyncDataProvider.isWindowsOsType(vm.getOsId()) : true;
    VmInit vmInit = (vm != null) ? vm.getVmInit() : null;
    if (vmInit != null) {
        if (!StringHelper.isNullOrEmpty(vmInit.getHostname())) {
            getHostname().setEntity(vmInit.getHostname());
            getWindowsHostname().setEntity(vmInit.getHostname());
        }
        getDomain().setEntity(vmInit.getDomain());
        final String tz = vmInit.getTimeZone();
        if (!StringHelper.isNullOrEmpty(tz)) {
            if (AsyncDataProvider.isWindowsOsType(vm.getOsId())) {
                getWindowsSysprepTimeZoneEnabled().setEntity(true);
                selectTimeZone(getWindowsSysprepTimeZone(), windowsTimezones, tz);
            } else {
                getTimeZoneEnabled().setEntity(true);
                selectTimeZone(getTimeZoneList(), timezones, tz);
            }
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getRootPassword())) {
            getRootPassword().setEntity(vmInit.getRootPassword());
            getRootPasswordVerification().setEntity(vmInit.getRootPassword());
        }
        getPasswordSet().setEntity(vmInit.isPasswordAlreadyStored());
        getPasswordSet().setIsChangable(vmInit.isPasswordAlreadyStored());
        if (!StringHelper.isNullOrEmpty(vmInit.getAuthorizedKeys())) {
            getAuthorizedKeys().setEntity(vmInit.getAuthorizedKeys());
        }
        if (vmInit.getRegenerateKeys() != null) {
            getRegenerateKeysEnabled().setEntity(vmInit.getRegenerateKeys());
        }
        if (!StringHelper.isNullOrEmpty(vmInit.getCustomScript())) {
            getCustomScript().setEntity(vmInit.getCustomScript());
        }
        initNetworks(vmInit);
    }
}
#end_block

#method_before
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (isWindowsOS) {
        vmInit.setInputLocale((String) getInputLocale().getEntity());
        vmInit.setUiLanguage((String) getUiLanguage().getEntity());
        vmInit.setSystemLocale((String) getSystemLocale().getEntity());
        vmInit.setUserLocale((String) getUserLocale().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#method_after
public VmInit buildCloudInitParameters() {
    VmInit vmInit = new VmInit();
    if (getHostnameEnabled()) {
        vmInit.setHostname(isWindowsOS ? (String) getWindowsHostname().getEntity() : (String) getHostname().getEntity());
    }
    if (getRootPasswordEnabled()) {
        vmInit.setRootPassword((String) getRootPassword().getEntity());
    }
    vmInit.setAuthorizedKeys((String) getAuthorizedKeys().getEntity());
    if ((Boolean) getRegenerateKeysEnabled().getEntity()) {
        vmInit.setRegenerateKeys(Boolean.TRUE);
    }
    if ((Boolean) getNetworkEnabled().getEntity()) {
        saveNetworkFields();
        if (!networkMap.isEmpty()) {
            for (Map.Entry<String, VmInitNetwork> entry : networkMap.entrySet()) {
                VmInitNetwork params = entry.getValue();
                if (params.getBootProtocol() == NetworkBootProtocol.DHCP) {
                    params.setIp(null);
                    params.setNetmask(null);
                    params.setGateway(null);
                }
                params.setStartOnBoot(networkStartOnBoot.contains(entry.getKey()));
                params.setName(entry.getKey());
            }
            vmInit.setNetworks(new ArrayList(networkMap.values()));
        }
    }
    vmInit.setDnsServers((String) getDnsServers().getEntity());
    vmInit.setDnsSearch((String) getDnsSearchDomains().getEntity());
    vmInit.setCustomScript((String) getCustomScript().getEntity());
    vmInit.setPasswordAlreadyStored((Boolean) getPasswordSet().getEntity());
    return vmInit;
}
#end_block

#method_before
private void removeNetwork() {
    networkMap.remove(getNetworkList().getSelectedItem());
    getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
    getNetworkList().setSelectedItem(Linq.firstOrDefault(networkMap.keySet()));
}
#method_after
private void removeNetwork() {
    networkMap.remove((String) getNetworkList().getSelectedItem());
    getNetworkList().setItems(new ArrayList<String>(networkMap.keySet()));
    getNetworkList().setSelectedItem(Linq.firstOrDefault(networkMap.keySet()));
}
#end_block

#method_before
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1, 0);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetCertuficateExpectations(1, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    VM created = (VM) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#method_after
private void doTestAddAsync(AsyncTaskStatusEnum asyncStatus, CreationStatus creationStatus) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 0);
    setUpGetBallooningExpectations(1, 0);
    setUpGetConsoleExpectations(new int[] { 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0 });
    setUpGetVmOvfExpectations(new int[] { 0 });
    setUpGetCertuficateExpectations(1, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(asyncStatus)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(202, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    VM created = (VM) response.getEntity();
    assertNotNull(created.getCreationStatus());
    assertEquals(creationStatus.value(), created.getCreationStatus().getState());
}
#end_block

#method_before
@Test
public void testAddFromScratch() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetBallooningExpectations(2, 0);
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    Disks disks = new Disks();
    disks.getDisks().add(new Disk());
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId", "DiskInfoList" }, new Object[] { Guid.Empty, mapDisks(disks) }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    model.setDisks(disks);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddFromScratch() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetBallooningExpectations(2, 0);
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    Disks disks = new Disks();
    disks.getDisks().add(new Disk());
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId", "DiskInfoList" }, new Object[] { Guid.Empty, mapDisks(disks) }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    model.setDisks(disks);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddFromScratchWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    addStorageDomainToModel(model);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#method_after
@Test
public void testAddFromScratchWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    addStorageDomainToModel(model);
    model.setCluster(new Cluster());
    model.getCluster().setId(GUIDS[1].toString());
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
    assertNull(((VM) response.getEntity()).getCreationStatus());
}
#end_block

#method_before
@Test
public void testAddFromScratchNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations("Cluster: name=" + NAMES[1], SearchType.Cluster, setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
}
#method_after
@Test
public void testAddFromScratchNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(2, 0);
    setUpGetBallooningExpectations(2, 0);
    setUpGetConsoleExpectations(new int[] { 0, 0 });
    setUpGetVmOvfExpectations(new int[] { 0, 0 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 0 });
    setUpGetCertuficateExpectations(2, 0);
    setUpHttpHeaderExpectations("Expect", "201-created");
    setUpGetEntityExpectations("Cluster: name=" + NAMES[1], SearchType.Cluster, setUpVDSGroup(GUIDS[1]));
    setUpEntityQueryExpectations(VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getVdsGroupEntity());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getTemplateEntity(0));
    setUpCreationExpectations(VdcActionType.AddVmFromScratch, AddVmFromScratchParameters.class, new String[] { "StorageDomainId" }, new Object[] { Guid.Empty }, true, true, GUIDS[0], asList(GUIDS[1]), asList(new AsyncTaskStatus(AsyncTaskStatusEnum.finished)), VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[0] }, getEntity(0));
    VM model = getModel(0);
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    model.setTemplate(new Template());
    model.getTemplate().setId(DEFAULT_TEMPLATE_ID);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 0);
}
#end_block

#method_before
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneWithDisk() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(createDisksCollection()));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testCloneVmFromSnapshot() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(0);
    Map<Guid, org.ovirt.engine.core.common.businessentities.Disk> diskImageMap = new HashMap<Guid, org.ovirt.engine.core.common.businessentities.Disk>();
    diskImageMap.put(Guid.newGuid(), new DiskImage());
    expect(vmConfiguration.getDiskMap()).andReturn(diskImageMap).anyTimes();
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(GUIDS[0]);
    vmStatic.setName(NAMES[0]);
    expect(vmConfiguration.getStaticData()).andReturn(vmStatic).anyTimes();
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 0, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmConfigurationBySnapshot, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, vmConfiguration);
    setUpCreationExpectations(VdcActionType.AddVmFromSnapshot, AddVmFromSnapshotParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(createDisksCollection(), createSnapshotsCollection(1));
    model.setTemplate(null);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testCloneVmFromSnapshot() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(0);
    Map<Guid, org.ovirt.engine.core.common.businessentities.Disk> diskImageMap = new HashMap<Guid, org.ovirt.engine.core.common.businessentities.Disk>();
    diskImageMap.put(Guid.newGuid(), new DiskImage());
    expect(vmConfiguration.getDiskMap()).andReturn(diskImageMap).anyTimes();
    VmStatic vmStatic = new VmStatic();
    vmStatic.setId(GUIDS[0]);
    vmStatic.setName(NAMES[0]);
    expect(vmConfiguration.getStaticData()).andReturn(vmStatic).anyTimes();
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 0, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmConfigurationBySnapshot, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, vmConfiguration);
    setUpCreationExpectations(VdcActionType.AddVmFromSnapshot, AddVmFromSnapshotParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(createDisksCollection(), createSnapshotsCollection(1));
    model.setTemplate(null);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testClone() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(new Disks() {

        {
            setClone(true);
        }
    }));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAdd() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(createModel(null));
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfigurationWithRegenerateTrue() throws Exception {
    setUriInfo(setUpGetMatrixConstraintsExpectations(BackendHostResource.REGENERATE_CONSTRAINT, true, "true", setUpBasicUriExpectations(), false));
    setUpGetPayloadExpectations(1, 3);
    setUpGetBallooningExpectations(1, 3);
    setUpGetCertuficateExpectations(1, 3);
    setUpGetConsoleExpectations(new int[] { 3 });
    setUpGetVirtioScsiExpectations(new int[] { 3 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    Guid newId = GUIDS[3];
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), true }, true, true, newId, VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { newId }, getEntityWithProvidedId(2, newId));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM queriedVm = (VM) response.getEntity();
    assertEquals(newId.toString(), queriedVm.getId());
    queriedVm.setId(GUIDS[2].toString());
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfigurationWithRegenerateTrue() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 3);
    setUpGetBallooningExpectations(1, 3);
    setUpGetCertuficateExpectations(1, 3);
    setUpGetConsoleExpectations(new int[] { 3 });
    setUpGetVmOvfExpectations(new int[] { 3 });
    setUpGetVirtioScsiExpectations(new int[] { 3 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setRegenerateIds(Boolean.TRUE);
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    Guid newId = GUIDS[3];
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), true }, true, true, newId, VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { newId }, getEntityWithProvidedId(2, newId));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    VM queriedVm = (VM) response.getEntity();
    assertEquals(newId.toString(), queriedVm.getId());
    queriedVm.setId(GUIDS[2].toString());
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfiguration() throws Exception {
    setUriInfo(setUpGetMatrixConstraintsExpectations(BackendHostResource.REGENERATE_CONSTRAINT, false, "false", setUpBasicUriExpectations(), false));
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), false }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfiguration() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId", "ImportAsNewEntity" }, new Object[] { returnedVM, Guid.createGuidFromString(model.getCluster().getId()), false }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddFromConfigurationNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    setUpGetEntityExpectations("Cluster: name=" + NAMES[1], SearchType.Cluster, setUpVDSGroup(GUIDS[1]));
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId" }, new Object[] { returnedVM, GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddFromConfigurationNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    VM model = createModel(null);
    org.ovirt.engine.core.common.businessentities.VM returnedVM = getEntity(2);
    model.setInitialization(new Initialization());
    model.getInitialization().setConfiguration(new Configuration());
    model.getInitialization().getConfiguration().setData("asdasdasd");
    model.getInitialization().getConfiguration().setType("ovf");
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[1]);
    setUpGetEntityExpectations("Cluster: name=" + NAMES[1], SearchType.Cluster, setUpVDSGroup(GUIDS[1]));
    setUpGetEntityExpectations(VdcQueryType.GetVmFromConfiguration, GetVmFromConfigurationQueryParameters.class, new String[] { "VmConfiguration", "ConfigurationType" }, new Object[] { model.getInitialization().getConfiguration().getData(), ConfigurationType.OVF }, returnedVM);
    setUpCreationExpectations(VdcActionType.ImportVmFromConfiguration, ImportVmParameters.class, new String[] { "Vm", "VdsGroupId" }, new Object[] { returnedVM, GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, returnedVM);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpGetEntityExpectations("Hosts: name=" + NAMES[1], SearchType.VDS, getHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithPlacementPolicy() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpGetEntityExpectations("Hosts: name=" + NAMES[1], SearchType.VDS, getHost());
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    model.setPlacementPolicy(new VmPlacementPolicy());
    model.getPlacementPolicy().setHost(new Host());
    model.getPlacementPolicy().getHost().setName(NAMES[1]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddWithStorageDomain() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[1] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = createModel(null);
    addStorageDomainToModel(model);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations("Cluster: name=" + NAMES[2], SearchType.Cluster, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
@Test
public void testAddNamedCluster() throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpGetCertuficateExpectations(1, 2);
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpGetEntityExpectations("Cluster: name=" + NAMES[2], SearchType.Cluster, setUpVDSGroup(GUIDS[2]));
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId" }, new Object[] { GUIDS[0] }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    VM model = getModel(2);
    model.setTemplate(new Template());
    model.getTemplate().setId(GUIDS[1].toString());
    model.setCluster(new Cluster());
    model.getCluster().setName(NAMES[2]);
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestAddWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVm, VmManagementParametersBase.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#method_after
private void doTestCloneFromTemplateWithClonePermissions(VM model, boolean copy) throws Exception {
    setUriInfo(setUpBasicUriExpectations());
    setUpTemplateDisksExpectations(GUIDS[1]);
    setUriInfo(setUpBasicUriExpectations());
    setUpGetPayloadExpectations(1, 2);
    setUpGetBallooningExpectations(1, 2);
    setUpGetCertuficateExpectations(1, 2);
    setUpGetConsoleExpectations(new int[] { 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 2 });
    setUpGetVirtioScsiExpectations(new int[] { 2 });
    setUpEntityQueryExpectations(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class, new String[] { "Id" }, new Object[] { GUIDS[1] }, getTemplateEntity(0));
    setUpEntityQueryExpectations(VdcQueryType.GetVdsGroupByVdsGroupId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getVdsGroupEntity());
    setUpCreationExpectations(VdcActionType.AddVmFromTemplate, AddVmFromTemplateParameters.class, new String[] { "StorageDomainId", "CopyTemplatePermissions" }, new Object[] { GUIDS[0], copy }, true, true, GUIDS[2], VdcQueryType.GetVmByVmId, IdQueryParameters.class, new String[] { "Id" }, new Object[] { GUIDS[2] }, getEntity(2));
    Response response = collection.add(model);
    assertEquals(201, response.getStatus());
    assertTrue(response.getEntity() instanceof VM);
    verifyModel((VM) response.getEntity(), 2);
}
#end_block

#method_before
private void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetPayloadExpectations(3);
        setUpGetBallooningExpectations(3);
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetCertuficateExpectations(3);
    }
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
private void testListAllConsoleAware(boolean allContent) throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    if (allContent) {
        List<String> populates = new ArrayList<String>();
        populates.add("true");
        expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
        setUpGetPayloadExpectations(3);
        setUpGetBallooningExpectations(3);
        setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
        setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
        setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
        setUpGetCertuficateExpectations(3);
    }
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
@Test
public void testListAllContent() throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    List<String> populates = new ArrayList<String>();
    populates.add("true");
    expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
    setUpGetPayloadExpectations(3);
    setUpGetBallooningExpectations(3);
    setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
    setUpGetCertuficateExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#method_after
@Test
public void testListAllContent() throws Exception {
    UriInfo uriInfo = setUpUriExpectations(null);
    List<String> populates = new ArrayList<String>();
    populates.add("true");
    expect(httpHeaders.getRequestHeader(BackendResource.POPULATE)).andReturn(populates).anyTimes();
    setUpGetPayloadExpectations(3);
    setUpGetBallooningExpectations(3);
    setUpGetConsoleExpectations(new int[] { 0, 1, 2 });
    setUpGetVmOvfExpectations(new int[] { 0, 1, 2 });
    setUpGetVirtioScsiExpectations(new int[] { 0, 1, 2 });
    setUpGetCertuficateExpectations(3);
    setUpQueryExpectations("");
    collection.setUriInfo(uriInfo);
    verifyCollection(getCollection());
}
#end_block

#method_before
protected org.ovirt.engine.core.common.businessentities.VDSGroup getVdsGroupEntity() {
    return new VDSGroup();
}
#method_after
protected org.ovirt.engine.core.common.businessentities.VDSGroup getVdsGroupEntity() {
    VDSGroup cluster = new VDSGroup();
    cluster.setArchitecture(ArchitectureType.x86_64);
    return cluster;
}
#end_block

#method_before
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm);
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(getClusterId(vm));
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), lookupCluster(staticVm.getVdsGroupId())));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateId);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, storageDomainId);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateId);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#method_after
@Override
public Response add(VM vm) {
    validateParameters(vm, "cluster.id|name");
    validateEnums(VM.class, vm);
    Response response = null;
    if (vm.isSetInitialization() && vm.getInitialization().isSetConfiguration()) {
        validateParameters(vm, "initialization.configuration.type", "initialization.configuration.data");
        response = importVmFromConfiguration(vm);
    } else {
        validateParameters(vm, "name");
        if (isCreateFromSnapshot(vm)) {
            response = createVmFromSnapshot(vm);
        } else {
            validateParameters(vm, "template.id|name");
            Guid templateId = getTemplateId(vm);
            VmStatic staticVm = getMapper(VM.class, VmStatic.class).map(vm, getMapper(VmTemplate.class, VmStatic.class).map(lookupTemplate(templateId), null));
            if (namedCluster(vm)) {
                staticVm.setVdsGroupId(getClusterId(vm));
            }
            VDSGroup cluster = lookupCluster(staticVm.getVdsGroupId());
            if (Guid.Empty.equals(templateId) && !vm.isSetOs()) {
                staticVm.setOsId(OsRepository.AUTO_SELECT_OS);
            }
            if (Guid.Empty.equals(templateId) && !vm.isSetDisplay()) {
                staticVm.setDefaultDisplayType(null);
            }
            staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(vm.getUsb(), cluster));
            if (!isFiltered()) {
                // resolve the host's ID, because it will be needed down the line
                if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost() && vm.getPlacementPolicy().getHost().isSetName() && !vm.getPlacementPolicy().getHost().isSetId()) {
                    staticVm.setDedicatedVmForVds(asGuid(getHostId(vm.getPlacementPolicy().getHost().getName())));
                }
            } else {
                vm.setPlacementPolicy(null);
            }
            Guid storageDomainId = (vm.isSetStorageDomain() && vm.getStorageDomain().isSetId()) ? asGuid(vm.getStorageDomain().getId()) : Guid.Empty;
            if (vm.isSetDisks() && vm.getDisks().isSetClone() && vm.getDisks().isClone()) {
                response = cloneVmFromTemplate(staticVm, vm, templateId);
            } else if (Guid.Empty.equals(templateId)) {
                response = addVmFromScratch(staticVm, vm, storageDomainId);
            } else {
                response = addVm(staticVm, vm, storageDomainId, templateId);
            }
        }
    }
    return removeRestrictedInfoFromResponse(response);
}
#end_block

#method_before
public Response importVmFromConfiguration(VM vm) {
    Configuration config = vm.getInitialization().getConfiguration();
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmFromConfiguration, new GetVmFromConfigurationQueryParameters(VmMapper.map(ConfigurationType.fromValue(config.getType()), null), config.getData().trim()), "");
    VmMapper.map(vm, vmConfiguration.getStaticData());
    Guid clusterId = namedCluster(vm) ? getClusterId(vm) : asGuid(vm.getCluster().getId());
    ImportVmParameters parameters = new ImportVmParameters();
    parameters.setVm(vmConfiguration);
    parameters.setVdsGroupId(clusterId);
    parameters.setImportAsNewEntity(isRegenerate());
    return performCreate(VdcActionType.ImportVmFromConfiguration, parameters, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#method_after
public Response importVmFromConfiguration(VM vm) {
    Initialization initialization = vm.getInitialization();
    Configuration config = initialization.getConfiguration();
    org.ovirt.engine.core.common.businessentities.VM vmConfiguration = getEntity(org.ovirt.engine.core.common.businessentities.VM.class, VdcQueryType.GetVmFromConfiguration, new GetVmFromConfigurationQueryParameters(VmMapper.map(ConfigurationType.fromValue(config.getType()), null), config.getData().trim()), "");
    VmMapper.map(vm, vmConfiguration.getStaticData());
    Guid clusterId = namedCluster(vm) ? getClusterId(vm) : asGuid(vm.getCluster().getId());
    ImportVmParameters parameters = new ImportVmParameters();
    parameters.setVm(vmConfiguration);
    parameters.setVdsGroupId(clusterId);
    if (initialization.isSetRegenerateIds()) {
        parameters.setImportAsNewEntity(initialization.isRegenerateIds());
    }
    return performCreate(VdcActionType.ImportVmFromConfiguration, parameters, new QueryIdResolver<Guid>(VdcQueryType.GetVmByVmId, IdQueryParameters.class));
}
#end_block

#method_before
protected VMs mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities, boolean isFiltered) {
    VMs collection = new VMs();
    for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
        VM vm = map(entity);
        // Filtered users are not allowed to view host related information
        if (isFiltered) {
            removeRestrictedInfoFromVM(vm);
        }
        collection.getVMs().add(addLinks(populate(vm, entity)));
    }
    return collection;
}
#method_after
protected VMs mapCollection(List<org.ovirt.engine.core.common.businessentities.VM> entities, boolean isFiltered) {
    // Fill VmInit for entities - the search query no join the VmInit to Vm
    IdsQueryParameters params = new IdsQueryParameters();
    List<Guid> ids = Entities.getIds(entities);
    params.setId(ids);
    VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
    if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
        List<VmInit> vmInits = queryReturnValue.getReturnValue();
        Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
        for (org.ovirt.engine.core.common.businessentities.VM vm : entities) {
            vm.setVmInit(initMap.get(vm.getId()));
        }
    }
    VMs collection = new VMs();
    for (org.ovirt.engine.core.common.businessentities.VM entity : entities) {
        VM vm = map(entity);
        // Filtered users are not allowed to view host related information
        if (isFiltered) {
            removeRestrictedInfoFromVM(vm);
        }
        collection.getVMs().add(addLinks(populate(vm, entity)));
    }
    return collection;
}
#end_block

#method_before
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    setPayload(model);
    setBallooning(model);
    setConsoleDevice(model);
    setVirtioScsiController(model);
    setCertificateInfo(model);
    return model;
}
#method_after
@Override
protected VM doPopulate(VM model, org.ovirt.engine.core.common.businessentities.VM entity) {
    setPayload(model);
    setBallooning(model);
    setConsoleDevice(model);
    setVirtioScsiController(model);
    setCertificateInfo(model);
    setVmOvfConfiguration(model, entity);
    return model;
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    Map<String, List<NetworkLabelModel>> nicToLabels = new HashMap<String, List<NetworkLabelModel>>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<LogicalNetworkModel>();
    labelToIface = new HashMap<String, String>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        List<NetworkLabelModel> nicLabels = nicToLabels.get(nicName);
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicToNetwork.get(nicName).contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    if (nicLabels == null) {
                        nicLabels = new ArrayList<NetworkLabelModel>();
                        nicToLabels.put(nicName, nicLabels);
                    }
                    nicLabels.add(labelModel);
                }
            }
        }
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<LogicalNetworkModel>();
    labelToIface = new HashMap<String, String>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        String nicName = nic.getName();
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = new ArrayList<NetworkLabelModel>();
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, nicName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicNetworks.contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    if (!labelModel.getNetworks().isEmpty()) {
                        nicLabels.add(labelModel);
                    }
                }
            }
        }
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#end_block

#method_before
private ValidationResult validateDisplayNetworkAvailability(VDS host, boolean onlyRequiredNetworks, VdsNetworkInterface displayNic, Network displayNetwork) {
    if (onlyRequiredNetworks) {
        return ValidationResult.VALID;
    }
    if (displayNetwork == null) {
        return ValidationResult.VALID;
    }
    // Check if display network attached to host and has a proper boot protocol
    if (displayNic == null) {
        log.debugFormat("host {0} is missing the cluster's display network", host.getName());
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_MISSING_DISPLAY_NETWORK);
    }
    if (displayNic.getBootProtocol() == NetworkBootProtocol.NONE) {
        log.debugFormat("Host {0} has the display network {1} configured with improper boot protocol on interface {2}.", host.getName(), displayNetwork.getName(), displayNic.getName());
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_CONFIGURE_DISPLAY_NETWORK_WITHOUT_BOOT_PROTOCOL, String.format("$DisplayNetwork %s", displayNetwork.getName()));
    }
    return ValidationResult.VALID;
}
#method_after
private ValidationResult validateDisplayNetworkAvailability(VDS host, boolean onlyRequiredNetworks, VdsNetworkInterface displayNic, Network displayNetwork) {
    if (onlyRequiredNetworks) {
        return ValidationResult.VALID;
    }
    if (displayNetwork == null) {
        return ValidationResult.VALID;
    }
    // Check if display network attached to host and has a proper boot protocol
    if (displayNic == null) {
        log.debugFormat("host {0} is missing the cluster's display network", host.getName());
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_MISSING_DISPLAY_NETWORK);
    }
    if (displayNic.getBootProtocol() == NetworkBootProtocol.NONE) {
        log.debugFormat("Host {0} has the display network {1} configured with improper boot protocol on interface {2}.", host.getName(), displayNetwork.getName(), displayNic.getName());
        return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_DISPLAY_NETWORK_HAS_NO_BOOT_PROTOCOL, String.format("$DisplayNetwork %s", displayNetwork.getName()));
    }
    return ValidationResult.VALID;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getNic() == null) {
        return failCanDoAction(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
    }
    if (NetworkUtils.isLabeled(getNic()) && getNic().getLabels().contains(getLabel())) {
        return failCanDoAction(VdcBllMessages.INTERFACE_ALREADY_LABELED);
    }
    if (!ValidationUtils.validateInputs(getValidationGroups(), getNic()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.IMPROPER_BOND_IS_LABELED);
    }
    if (Boolean.TRUE.equals(getNic().getBonded())) {
        int slavesCount = 0;
        for (VdsNetworkInterface nic : getHostInterfaces()) {
            if (StringUtils.equals(getNic().getName(), nic.getBondName())) {
                slavesCount++;
                if (slavesCount == 2) {
                    break;
                }
            }
        }
        if (slavesCount < 2) {
            return failCanDoAction(VdcBllMessages.IMPROPER_INTERFACE_IS_LABELED);
        }
    }
    for (VdsNetworkInterface nic : getHostInterfaces()) {
        if (!StringUtils.equals(nic.getName(), getNicName()) && NetworkUtils.isLabeled(nic) && nic.getLabels().contains(getLabel())) {
            return failCanDoAction(VdcBllMessages.OTHER_INTERFACE_ALREADY_LABELED, "$LabeledNic " + nic.getName());
        }
    }
    List<String> assignedNetworks = validateNetworksNotAssignedToIncorrectNics();
    if (!assignedNetworks.isEmpty()) {
        return failCanDoAction(VdcBllMessages.LABELED_NETWORK_ATTACHED_TO_WRONG_INTERFACE, "$AssignedNetworks " + StringUtils.join(assignedNetworks, ", "));
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getNic() == null) {
        return failCanDoAction(VdcBllMessages.HOST_NETWORK_INTERFACE_NOT_EXIST);
    }
    if (NetworkUtils.isLabeled(getNic()) && getNic().getLabels().contains(getLabel())) {
        return failCanDoAction(VdcBllMessages.INTERFACE_ALREADY_LABELED);
    }
    if (!ValidationUtils.validateInputs(getValidationGroups(), getNic()).isEmpty()) {
        return failCanDoAction(VdcBllMessages.IMPROPER_INTERFACE_IS_LABELED);
    }
    if (Boolean.TRUE.equals(getNic().getBonded())) {
        int slavesCount = 0;
        for (VdsNetworkInterface nic : getHostInterfaces()) {
            if (StringUtils.equals(getNic().getName(), nic.getBondName())) {
                slavesCount++;
                if (slavesCount == 2) {
                    break;
                }
            }
        }
        if (slavesCount < 2) {
            return failCanDoAction(VdcBllMessages.IMPROPER_BOND_IS_LABELED);
        }
    }
    for (VdsNetworkInterface nic : getHostInterfaces()) {
        if (!StringUtils.equals(nic.getName(), getNicName()) && NetworkUtils.isLabeled(nic) && nic.getLabels().contains(getLabel())) {
            return failCanDoAction(VdcBllMessages.OTHER_INTERFACE_ALREADY_LABELED, "$LabeledNic " + nic.getName());
        }
    }
    List<String> assignedNetworks = validateNetworksNotAssignedToIncorrectNics();
    if (!assignedNetworks.isEmpty()) {
        return failCanDoAction(VdcBllMessages.LABELED_NETWORK_ATTACHED_TO_WRONG_INTERFACE, "$AssignedNetworks " + StringUtils.join(assignedNetworks, ", "));
    }
    return true;
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initDisplayTypes();
    initNicHotplugSupportMap();
    initDiskHotpluggableInterfacesMap();
    initOsArchitecture();
    initDefaultOSes();
    initMigrationSupportMap();
    initMemorySnapshotSupportMap();
    initSuspendSupportMap();
}
#end_block

#method_before
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (StringHelper.stringsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (StringHelper.stringsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#method_after
public static void getInterfaceOptionsForEditNetwork(final AsyncQuery asyncQuery, final ArrayList<VdsNetworkInterface> interfaceList, final VdsNetworkInterface originalInterface, Network networkToEdit, final Guid vdsID, final StringBuilder defaultInterfaceName) {
    final ArrayList<VdsNetworkInterface> ifacesOptions = new ArrayList<VdsNetworkInterface>();
    for (VdsNetworkInterface i : interfaceList) {
        if (StringHelper.isNullOrEmpty(i.getNetworkName()) && StringHelper.isNullOrEmpty(i.getBondName())) {
            ifacesOptions.add(i);
        }
    }
    if (// no vlan:
    originalInterface.getVlanId() == null) {
        // Filter out the Interfaces that have child vlan Interfaces
        getAllChildVlanInterfaces(vdsID, ifacesOptions, new IFrontendMultipleQueryAsyncCallback() {

            @Override
            public void executed(FrontendMultipleQueryAsyncResult result) {
                ArrayList<VdsNetworkInterface> ifacesOptionsTemp = new ArrayList<VdsNetworkInterface>();
                List<VdcQueryReturnValue> returnValueList = result.getReturnValues();
                for (int i = 0; i < returnValueList.size(); i++) {
                    VdcQueryReturnValue returnValue = returnValueList.get(i);
                    if (returnValue != null && returnValue.getSucceeded() && returnValue.getReturnValue() != null) {
                        ArrayList<VdsNetworkInterface> childVlanInterfaces = (ArrayList<VdsNetworkInterface>) (returnValue.getReturnValue());
                        if (childVlanInterfaces.size() == 0) {
                            ifacesOptionsTemp.add(ifacesOptions.get(i));
                        }
                    }
                }
                ifacesOptions.clear();
                ifacesOptions.addAll(ifacesOptionsTemp);
                if (originalInterface.getBonded() != null && originalInterface.getBonded()) {
                    // (note that choosing one of them will break the bond):
                    for (VdsNetworkInterface i : interfaceList) {
                        if (ObjectUtils.objectsEqual(i.getBondName(), originalInterface.getName())) {
                            ifacesOptions.add(i);
                        }
                    }
                }
                // add the original interface as an option and set it as the default option:
                ifacesOptions.add(originalInterface);
                defaultInterfaceName.append(originalInterface.getName());
                asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
            }
        });
    } else // vlan:
    {
        getVlanParentInterface(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                final VdsNetworkInterface vlanParent = (VdsNetworkInterface) returnValue;
                if (vlanParent != null && vlanParent.getBonded() != null && vlanParent.getBonded()) {
                    interfaceHasSiblingVlanInterfaces(vdsID, originalInterface, new AsyncQuery(asyncQuery, new INewAsyncCallback() {

                        @Override
                        public void onSuccess(Object model, Object returnValue) {
                            Boolean interfaceHasSiblingVlanInterfaces = (Boolean) returnValue;
                            if (!interfaceHasSiblingVlanInterfaces) {
                                // vlanParent.name).ToList());
                                for (VdsNetworkInterface i : interfaceList) {
                                    if (ObjectUtils.objectsEqual(i.getBondName(), vlanParent.getName())) {
                                        ifacesOptions.add(i);
                                    }
                                }
                            }
                            // the vlanParent should already be in ifacesOptions
                            // (since it has no network_name or bond_name).
                            defaultInterfaceName.append(vlanParent.getName());
                            asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                        }
                    }));
                } else {
                    // (since it has no network_name or bond_name).
                    if (vlanParent != null)
                        defaultInterfaceName.append(vlanParent.getName());
                    asyncQuery.asyncCallback.onSuccess(asyncQuery.model, ifacesOptions);
                }
            }
        }));
    }
}
#end_block

#method_before
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Iterable<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#method_after
public static void getAllProvidersByProvidedEntity(AsyncQuery query, final VdcObjectType providedEntity) {
    query.converterCallback = new IAsyncConverter<List<Provider>>() {

        @Override
        public List<Provider> Convert(Object returnValue, AsyncQuery asyncQuery) {
            if (returnValue == null) {
                return new ArrayList<Provider>();
            }
            List<Provider> providers = Linq.toList(Linq.filterProvidersByProvidedType((Collection<Provider>) returnValue, providedEntity));
            Collections.sort(providers, new NameableComparator());
            return providers;
        }
    };
    Frontend.getInstance().runQuery(VdcQueryType.GetAllProviders, new GetAllProvidersParameters(), query);
}
#end_block

#method_before
public static boolean isVersionMatchStorageType(Version version, StorageType type) {
    return !((type == StorageType.LOCALFS && version.compareTo(new Version(2, 2)) <= 0) || (type == StorageType.POSIXFS && version.compareTo(new Version(3, 0)) <= 0) || (type == StorageType.GLUSTERFS && version.compareTo(new Version(3, 2)) <= 0));
}
#method_after
public static boolean isVersionMatchStorageType(Version version, boolean isLocalType) {
    return version.compareTo(new Version(3, 0)) >= 0;
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI }));
    return diskInterfaces;
}
#method_after
public static ArrayList<DiskInterface> getDiskInterfaceList() {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO, DiskInterface.VirtIO_SCSI, DiskInterface.SPAPR_VSCSI }));
    return diskInterfaces;
}
#end_block

#method_before
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#method_after
public static Guid getEntityGuid(Object entity) {
    if (entity instanceof VM) {
        return ((VM) entity).getId();
    } else if (entity instanceof StoragePool) {
        return ((StoragePool) entity).getId();
    } else if (entity instanceof VDSGroup) {
        return ((VDSGroup) entity).getId();
    } else if (entity instanceof VDS) {
        return ((VDS) entity).getId();
    } else if (entity instanceof StorageDomain) {
        return ((StorageDomain) entity).getId();
    } else if (entity instanceof VmTemplate) {
        return ((VmTemplate) entity).getId();
    } else if (entity instanceof VmPool) {
        return ((VmPool) entity).getVmPoolId();
    } else if (entity instanceof DbUser) {
        return ((DbUser) entity).getId();
    } else if (entity instanceof DbGroup) {
        return ((DbGroup) entity).getId();
    } else if (entity instanceof Quota) {
        return ((Quota) entity).getId();
    } else if (entity instanceof DiskImage) {
        return ((DiskImage) entity).getId();
    } else if (entity instanceof GlusterVolumeEntity) {
        return ((GlusterVolumeEntity) entity).getId();
    } else if (entity instanceof Network) {
        return ((Network) entity).getId();
    } else if (entity instanceof VnicProfile) {
        return ((VnicProfile) entity).getId();
    }
    return Guid.Empty;
}
#end_block

#method_before
private HashMap<ArchitectureType, HashMap<Version, Boolean>> getMap(ArchCapabilitiesVerb archCapabilitiesVerb) {
    HashMap<ArchitectureType, HashMap<Version, Boolean>> supportMap = new HashMap<ArchitectureType, HashMap<Version, Boolean>>();
    for (ArchitectureType arch : ArchitectureType.values()) {
        HashMap<Version, Boolean> archMap = new HashMap<Version, Boolean>();
        for (Version version : Version.ALL) {
            boolean isSupported = isSupported(archCapabilitiesVerb, arch, version);
            archMap.put(version, isSupported);
        }
        supportMap.put(arch, archMap);
    }
    return supportMap;
}
#method_after
private static Map<ArchitectureType, Map<Version, Boolean>> getMap(ArchCapabilitiesVerb archCapabilitiesVerb) {
    if (archCapabilitiesVerb == null) {
        return null;
    }
    Map<ArchitectureType, Map<Version, Boolean>> supportMap = new EnumMap<ArchitectureType, Map<Version, Boolean>>(ArchitectureType.class);
    for (ArchitectureType arch : ArchitectureType.values()) {
        Map<Version, Boolean> archMap = new HashMap<Version, Boolean>();
        for (Version version : Version.ALL) {
            archMap.put(version, isSupported(archCapabilitiesVerb, arch, version));
        }
        supportMap.put(arch, archMap);
    }
    return supportMap;
}
#end_block

#method_before
private boolean isSupported(ArchCapabilitiesVerb archCapabilitiesVerb, ArchitectureType architecture, Version version) {
    switch(archCapabilitiesVerb) {
        case GetMigrationSupport:
            return FeatureSupported.isMigrationSupported(architecture, version);
        case GetMemorySnapshotSupport:
            return FeatureSupported.isMemorySnapshotSupportedByArchitecture(architecture, version);
    }
    return false;
}
#method_after
private static boolean isSupported(ArchCapabilitiesVerb archCapabilitiesVerb, ArchitectureType architecture, Version version) {
    switch(archCapabilitiesVerb) {
        case GetMigrationSupport:
            return FeatureSupported.isMigrationSupported(architecture, version);
        case GetMemorySnapshotSupport:
            return FeatureSupported.isMemorySnapshotSupportedByArchitecture(architecture, version);
        case GetSuspendSupport:
            return FeatureSupported.isSuspendSupportedByArchitecture(architecture, version);
    }
    return false;
}
#end_block

#method_before
public static boolean supportedInConfig(ConfigValues feature, Version version) {
    return Config.<Boolean>getValue(feature, version.getValue());
}
#method_after
public static boolean supportedInConfig(ConfigValues feature, Version version, ArchitectureType arch) {
    return Boolean.parseBoolean(((Map<String, String>) Config.<Map>getValue(feature, version.getValue())).get(arch.name()));
}
#end_block

#method_before
public static boolean antiMacSpoofing(Version version) {
    return supportedInConfig(ConfigValues.EnableMACAntiSpoofingFilterRules, version);
}
#method_after
public static boolean antiMacSpoofing(Version version) {
    return supportedInConfig(ConfigValues.MacAntiSpoofingFilterRulesSupported, version);
}
#end_block

#method_before
public static boolean isMigrationSupported(ArchitectureType architecture, Version version) {
    return isFeatureSupportedByArchitecture(ConfigValues.IsMigrationSupported, version, architecture);
}
#method_after
public static boolean isMigrationSupported(ArchitectureType architecture, Version version) {
    return supportedInConfig(ConfigValues.IsMigrationSupported, version, architecture);
}
#end_block

#method_before
public static boolean isMemorySnapshotSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return isFeatureSupportedByArchitecture(ConfigValues.IsMemorySnapshotSupported, version, architecture);
}
#method_after
public static boolean isMemorySnapshotSupportedByArchitecture(ArchitectureType architecture, Version version) {
    return supportedInConfig(ConfigValues.IsMemorySnapshotSupported, version, architecture);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (getParameters().getImportAsTemplate()) {
        if (getParameters().getClusterId() == null) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        setVdsGroupId(getParameters().getClusterId());
        if (getVdsGroup() == null) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // A Template cannot be added in a cluster without a defined architecture
        if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        }
        setStoragePoolId(getParameters().getStoragePoolId());
        // Importing as a template is available only for DC level 3.4 and above
        if (getStoragePool().getcompatibility_version().compareTo(Version.v3_4) < 0) {
            return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        }
    }
    DiskImage diskImage = null;
    try {
        diskImage = getDiskImage();
    } catch (OpenStackImageException e) {
        log.errorFormat("Unable to get the disk image from the provider proxy: {0} ({1})", e.getMessage(), e.getErrorType());
        switch(e.getErrorType()) {
            case UNSUPPORTED_CONTAINER_FORMAT:
            case UNSUPPORTED_DISK_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_NOT_SUPPORTED);
            case UNABLE_TO_DOWNLOAD_IMAGE:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_DOWNLOAD_ERROR);
            case UNRECOGNIZED_IMAGE_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_UNRECOGNIZED);
        }
    }
    if (diskImage == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    if (getParameters().getImportAsTemplate()) {
        if (getParameters().getClusterId() == null) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        setVdsGroupId(getParameters().getClusterId());
        if (getVdsGroup() == null) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        // A Template cannot be added in a cluster without a defined architecture
        if (getVdsGroup().getArchitecture() == ArchitectureType.undefined) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CLUSTER_UNDEFINED_ARCHITECTURE);
        }
        setStoragePoolId(getParameters().getStoragePoolId());
        if (!FeatureSupported.importGlanceImageAsTemplate(getStoragePool().getcompatibility_version())) {
            return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
        }
    }
    DiskImage diskImage = null;
    try {
        diskImage = getDiskImage();
    } catch (OpenStackImageException e) {
        log.errorFormat("Unable to get the disk image from the provider proxy: {0} ({1})", e.getMessage(), e.getErrorType());
        switch(e.getErrorType()) {
            case UNSUPPORTED_CONTAINER_FORMAT:
            case UNSUPPORTED_DISK_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_NOT_SUPPORTED);
            case UNABLE_TO_DOWNLOAD_IMAGE:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_DOWNLOAD_ERROR);
            case UNRECOGNIZED_IMAGE_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_UNRECOGNIZED);
        }
    }
    if (diskImage == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    for (Guid templateGuid : getTemplatesList()) {
        if (getTagId() != null && DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) != null) {
            VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
            if (template != null) {
                appendCustomValue("TemplatesNames", template.getName(), ", ");
            }
            DbFacade.getInstance().getTagDao().detachTemplateFromTag(getTagId(), templateGuid);
            setSucceeded(true);
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    for (Guid templateGuid : getTemplatesList()) {
        if (DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) != null) {
            VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
            if (template != null) {
                appendCustomValue("TemplatesNames", template.getName(), ", ");
                DbFacade.getInstance().getTagDao().detachTemplateFromTag(getTagId(), templateGuid);
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getTagId() != null) {
        for (Guid templateGuid : getTemplatesList()) {
            VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
            if (DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) == null) {
                if (template != null) {
                    appendCustomValue("TemplatesNames", template.getName(), ", ");
                }
                TagsTemplateMap map = new TagsTemplateMap(getTagId(), templateGuid);
                DbFacade.getInstance().getTagDao().attachTemplateToTag(map);
                noActionDone = false;
            } else {
                if (template != null) {
                    appendCustomValue("TemplatesNamesExists", template.getName(), ", ");
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    for (Guid templateGuid : getTemplatesList()) {
        VmTemplate template = DbFacade.getInstance().getVmTemplateDao().get(templateGuid);
        if (template != null) {
            if (DbFacade.getInstance().getTagDao().getTagTemplateByTagIdAndByTemplateId(getTagId(), templateGuid) == null) {
                appendCustomValue("TemplatesNames", template.getName(), ", ");
                TagsTemplateMap map = new TagsTemplateMap(getTagId(), templateGuid);
                DbFacade.getInstance().getTagDao().attachTemplateToTag(map);
                noActionDone = false;
            } else {
                appendCustomValue("TemplatesNamesExists", template.getName(), ", ");
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    Guid clusterId = null;
    VDSGroup cluster = null;
    if (namedCluster(template)) {
        clusterId = getClusterId(template);
        cluster = lookupCluster(clusterId);
    }
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(cluster, template));
    if (namedCluster(template)) {
        staticVm.setVdsGroupId(clusterId);
    }
    staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), cluster != null ? cluster : lookupCluster(staticVm.getVdsGroupId())));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    params.setConsoleEnabled(template.getConsole() != null && template.getConsole().isSetEnabled() ? template.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    params.setVirtioScsiEnabled(template.isSetVirtioScsi() && template.getVirtioScsi().isSetEnabled() ? template.getVirtioScsi().isEnabled() : null);
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    setupCloneVmPermissions(template, params);
    return performCreate(VdcActionType.AddVmTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#method_after
@Override
public Response add(Template template) {
    validateParameters(template, "name", "vm.id|name");
    validateEnums(Template.class, template);
    Guid clusterId = null;
    VDSGroup cluster = null;
    if (namedCluster(template)) {
        clusterId = getClusterId(template);
        cluster = lookupCluster(clusterId);
    }
    if (template.getVersion() != null) {
        validateParameters(template.getVersion(), "baseTemplate");
    }
    VmStatic staticVm = getMapper(Template.class, VmStatic.class).map(template, getVm(cluster, template));
    if (namedCluster(template)) {
        staticVm.setVdsGroupId(clusterId);
    }
    staticVm.setUsbPolicy(VmMapper.getUsbPolicyOnCreate(template.getUsb(), cluster != null ? cluster : lookupCluster(staticVm.getVdsGroupId())));
    // REVISIT: powershell has a IsVmTemlateWithSameNameExist safety check
    AddVmTemplateParameters params = new AddVmTemplateParameters(staticVm, template.getName(), template.getDescription());
    if (template.getVersion() != null) {
        params.setBaseTemplateId(Guid.createGuidFromString(template.getVersion().getBaseTemplate().getId()));
        params.setTemplateVersionName(template.getVersion().getVersionName());
    }
    params.setConsoleEnabled(template.getConsole() != null && template.getConsole().isSetEnabled() ? template.getConsole().isEnabled() : !getConsoleDevicesForEntity(staticVm.getId()).isEmpty());
    params.setVirtioScsiEnabled(template.isSetVirtioScsi() && template.getVirtioScsi().isSetEnabled() ? template.getVirtioScsi().isEnabled() : null);
    boolean isDomainSet = false;
    if (template.isSetStorageDomain() && template.getStorageDomain().isSetId()) {
        params.setDestinationStorageDomainId(asGuid(template.getStorageDomain().getId()));
        isDomainSet = true;
    }
    params.setDiskInfoDestinationMap(getDiskToDestinationMap(template.getVm(), params.getDestinationStorageDomainId(), isDomainSet));
    setupCloneVmPermissions(template, params);
    return performCreate(VdcActionType.AddVmTemplate, params, new QueryIdResolver<Guid>(VdcQueryType.GetVmTemplate, GetVmTemplateParameters.class));
}
#end_block

#method_before
protected Templates mapCollection(List<VmTemplate> entities) {
    Templates collection = new Templates();
    for (VmTemplate entity : entities) {
        collection.getTemplates().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#method_after
protected Templates mapCollection(List<VmTemplate> entities) {
    // Fill VmInit for entities - the search query no join the VmInit to Templates
    IdsQueryParameters params = new IdsQueryParameters();
    List<Guid> ids = Entities.getIds(entities);
    params.setId(ids);
    VdcQueryReturnValue queryReturnValue = runQuery(VdcQueryType.GetVmsInit, params);
    if (queryReturnValue.getSucceeded() && queryReturnValue.getReturnValue() != null) {
        List<VmInit> vmInits = queryReturnValue.getReturnValue();
        Map<Guid, VmInit> initMap = Entities.businessEntitiesById(vmInits);
        for (VmTemplate template : entities) {
            template.setVmInit(initMap.get(template.getId()));
        }
    }
    Templates collection = new Templates();
    for (VmTemplate entity : entities) {
        collection.getTemplates().add(addLinks(populate(map(entity), entity)));
    }
    return collection;
}
#end_block

#method_before
protected java.util.ArrayList<Guid> getTemplatesList() {
    return getParameters().getEntitiesId();
}
#method_after
protected ArrayList<Guid> getTemplatesList() {
    return getParameters().getEntitiesId();
}
#end_block

#method_before
public String getTemplateId() {
    return _templateId;
}
#method_after
public String getTemplateId() {
    return templateId;
}
#end_block

#method_before
@Override
protected Widget getContents() {
    LogicalNetworkModel network = (LogicalNetworkModel) item;
    Image mgmtNetworkImage;
    Image vmImage;
    Image monitorImage;
    Image migrationImage;
    Image notSyncImage;
    Image alertImage;
    if (!network.isManaged()) {
        monitorImage = null;
        mgmtNetworkImage = null;
        vmImage = null;
        migrationImage = null;
        notSyncImage = null;
        alertImage = null;
    } else {
        monitorImage = network.getEntity().getCluster().isDisplay() ? new Image(resources.networkMonitor()) : null;
        mgmtNetworkImage = network.isManagement() ? new Image(resources.mgmtNetwork()) : null;
        vmImage = network.getEntity().isVmNetwork() ? new Image(resources.networkVm()) : null;
        migrationImage = network.getEntity().getCluster().isMigration() ? new Image(resources.migrationNetwork()) : null;
        notSyncImage = !network.isInSync() ? new Image(resources.networkNotSyncImage()) : null;
        alertImage = network.getErrorNicName() != null ? new Image(resources.alertImage()) : null;
        if (network.isManagement()) {
            mgmtNetworkImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().isVmNetwork()) {
            vmImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().getCluster().isDisplay()) {
            monitorImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().getCluster().isMigration()) {
            migrationImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (!network.isInSync()) {
            notSyncImage.setStylePrimaryName(style.networkImageBorder());
        }
    }
    Grid rowPanel = new Grid(1, 9);
    rowPanel.setCellSpacing(3);
    // $NON-NLS-1$
    rowPanel.setWidth("100%");
    // $NON-NLS-1$
    rowPanel.setHeight("100%");
    ColumnFormatter columnFormatter = rowPanel.getColumnFormatter();
    // $NON-NLS-1$
    columnFormatter.setWidth(0, "5px");
    // $NON-NLS-1$
    columnFormatter.setWidth(1, "20px");
    // $NON-NLS-1$
    columnFormatter.setWidth(2, "100%");
    rowPanel.setWidget(0, 0, dragImage);
    Panel statusPanel = new HorizontalPanel();
    rowPanel.setWidget(0, 1, statusPanel);
    if (alertImage != null) {
        statusPanel.add(alertImage);
    }
    ImageResource statusImage = getStatusImage();
    if (statusImage != null) {
        statusPanel.add(new Image(statusImage));
    }
    Label titleLabel = new Label(getItemTitle());
    rowPanel.setWidget(0, 2, titleLabel);
    rowPanel.setWidget(0, 3, actionButton);
    rowPanel.setWidget(0, 4, mgmtNetworkImage);
    rowPanel.setWidget(0, 5, monitorImage);
    rowPanel.setWidget(0, 6, vmImage);
    rowPanel.setWidget(0, 7, migrationImage);
    rowPanel.setWidget(0, 8, notSyncImage);
    return rowPanel;
}
#method_after
@Override
protected Widget getContents() {
    LogicalNetworkModel network = (LogicalNetworkModel) item;
    Image mgmtNetworkImage;
    Image vmImage;
    Image monitorImage;
    Image migrationImage;
    Image notSyncImage;
    Image alertImage;
    if (!network.isManaged()) {
        monitorImage = null;
        mgmtNetworkImage = null;
        vmImage = null;
        migrationImage = null;
        notSyncImage = null;
        alertImage = null;
    } else {
        monitorImage = network.getEntity().getCluster().isDisplay() ? new Image(resources.networkMonitor()) : null;
        mgmtNetworkImage = network.isManagement() ? new Image(resources.mgmtNetwork()) : null;
        vmImage = network.getEntity().isVmNetwork() ? new Image(resources.networkVm()) : null;
        migrationImage = network.getEntity().getCluster().isMigration() ? new Image(resources.migrationNetwork()) : null;
        notSyncImage = !network.isInSync() ? new Image(resources.networkNotSyncImage()) : null;
        alertImage = network.getErrorMessage() != null ? new Image(resources.alertImage()) : null;
        if (network.isManagement()) {
            mgmtNetworkImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().isVmNetwork()) {
            vmImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().getCluster().isDisplay()) {
            monitorImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (network.getEntity().getCluster().isMigration()) {
            migrationImage.setStylePrimaryName(style.networkImageBorder());
        }
        if (!network.isInSync()) {
            notSyncImage.setStylePrimaryName(style.networkImageBorder());
        }
    }
    Grid rowPanel = new Grid(1, 9);
    rowPanel.setCellSpacing(0);
    // $NON-NLS-1$
    rowPanel.setWidth("100%");
    // $NON-NLS-1$
    rowPanel.setHeight("100%");
    ColumnFormatter columnFormatter = rowPanel.getColumnFormatter();
    // $NON-NLS-1$
    columnFormatter.setWidth(0, "5px");
    // $NON-NLS-1$
    columnFormatter.setWidth(1, "20px");
    // $NON-NLS-1$
    columnFormatter.setWidth(2, "100%");
    rowPanel.setWidget(0, 0, dragImage);
    Panel statusPanel = new HorizontalPanel();
    rowPanel.setWidget(0, 1, statusPanel);
    if (alertImage != null) {
        statusPanel.add(alertImage);
    }
    ImageResource statusImage = getStatusImage();
    if (statusImage != null) {
        statusPanel.add(new Image(statusImage));
    }
    Label titleLabel = new Label(getItemTitle());
    rowPanel.setWidget(0, 2, titleLabel);
    rowPanel.setWidget(0, 3, actionButton);
    rowPanel.setWidget(0, 4, mgmtNetworkImage);
    rowPanel.setWidget(0, 5, monitorImage);
    rowPanel.setWidget(0, 6, vmImage);
    rowPanel.setWidget(0, 7, migrationImage);
    rowPanel.setWidget(0, 8, notSyncImage);
    return rowPanel;
}
#end_block

#method_before
public void showItem(NetworkItemModel<?> item, NetworkItemPanel panel) {
    contents.clear();
    if (item instanceof LogicalNetworkModel) {
        showNetwork((LogicalNetworkModel) item);
    } else if (item instanceof NetworkInterfaceModel) {
        showNic((NetworkInterfaceModel) item);
    }
    showRelativeTo(panel);
}
#method_after
public void showItem(NetworkItemModel<?> item, NetworkItemPanel panel) {
    if (item instanceof LogicalNetworkModel) {
        showNetwork((LogicalNetworkModel) item);
    } else if (item instanceof NetworkInterfaceModel) {
        showNic((NetworkInterfaceModel) item);
    } else if (item instanceof NetworkLabelModel) {
        return;
    }
    showRelativeTo(panel);
}
#end_block

#method_before
private void showNetwork(LogicalNetworkModel networkModel) {
    contents.removeAllRows();
    Network entity = networkModel.getEntity();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName()));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
    } else {
        if (networkModel.getErrorNicName() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, SafeHtmlUtils.fromTrustedString(messages.networkLabelConflict(networkModel.getErrorNicName(), networkModel.getEntity().getLabel()))));
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.networkNotInSync()));
        }
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration) {
        // $NON-NLS-1$
        addRow(SafeHtmlUtils.fromString(constants.usageItemInfo() + ":"));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo()));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo()));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo()));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo()));
        }
    }
    // Mtu
    if (entity.getMtu() != 0) {
        addRow(constants.mtuItemInfo(), String.valueOf(entity.getMtu()));
    }
}
#method_after
private void showNetwork(LogicalNetworkModel networkModel) {
    contents.removeAllRows();
    Network entity = networkModel.getEntity();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName()));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
    } else {
        if (networkModel.getErrorMessage() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, templates.maxWidthNteworkItemPopup(networkModel.getErrorMessage())));
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.networkNotInSync()));
        }
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration) {
        // $NON-NLS-1$
        addRow(SafeHtmlUtils.fromString(constants.usageItemInfo() + ":"));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo()));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo()));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo()));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo()));
        }
    }
    // Mtu
    if (entity.getMtu() != 0) {
        addRow(constants.mtuItemInfo(), String.valueOf(entity.getMtu()));
    }
}
#end_block

#method_before
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<String, LogicalNetworkModel>();
    networkLabelMap = new HashMap<String, NetworkLabelModel>();
    for (Network network : allNetworks) {
        LogicalNetworkModel networkModel = new LogicalNetworkModel(network, this);
        networkModels.put(network.getName(), networkModel);
        if (!network.isExternal()) {
            NetworkLabelModel labelModel = networkLabelMap.get(network.getLabel());
            if (labelModel == null) {
                labelModel = new NetworkLabelModel(network.getLabel(), this);
                networkLabelMap.put(network.getLabel(), labelModel);
            }
            labelModel.getNetworks().add(networkModel);
        }
    }
    setNetworks(networkModels);
}
#method_after
private void initNetworkModels() {
    Map<String, LogicalNetworkModel> networkModels = new HashMap<String, LogicalNetworkModel>();
    networkLabelMap = new HashMap<String, NetworkLabelModel>();
    for (Network network : allNetworks) {
        LogicalNetworkModel networkModel = new LogicalNetworkModel(network, this);
        networkModels.put(network.getName(), networkModel);
        if (!network.isExternal()) {
            NetworkLabelModel labelModel = networkLabelMap.get(network.getLabel());
            if (labelModel == null) {
                labelModel = new NetworkLabelModel(network.getLabel(), this);
                networkLabelMap.put(network.getLabel(), labelModel);
            }
            // The network model is candidate to be drawn as part of the label.
            // This doesn't yet consider whether it actually exists on the interface.
            labelModel.getNetworks().add(networkModel);
        }
    }
    setNetworks(networkModels);
}
#end_block

#method_before
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    Map<String, List<NetworkLabelModel>> nicToLabels = new HashMap<String, List<NetworkLabelModel>>();
    labelToIface = new HashMap<String, String>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, ifName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicToNetwork.get(ifName).contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            // It means this network couldn't be attached to the nic
                            // because it has a conflict with the other networks on the nic.
                            iter.remove();
                            networkModel.setErrorNicName(ifName);
                        }
                    }
                    // attach label itself to nic
                    List<NetworkLabelModel> nicLabels = nicToLabels.get(ifName);
                    if (nicLabels == null) {
                        nicLabels = new ArrayList<NetworkLabelModel>();
                        nicToLabels.put(ifName, nicLabels);
                    }
                    nicLabels.add(labelModel);
                }
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = nicToLabels.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    setNics(nicModels);
}
#method_after
private void initNicModels() {
    Map<String, NetworkInterfaceModel> nicModels = new HashMap<String, NetworkInterfaceModel>();
    Map<String, VdsNetworkInterface> nicMap = new HashMap<String, VdsNetworkInterface>();
    List<VdsNetworkInterface> physicalNics = new ArrayList<VdsNetworkInterface>();
    Map<String, List<VdsNetworkInterface>> bondToNic = new HashMap<String, List<VdsNetworkInterface>>();
    Map<String, Set<LogicalNetworkModel>> nicToNetwork = new HashMap<String, Set<LogicalNetworkModel>>();
    Map<String, List<NetworkLabelModel>> nicToLabels = new HashMap<String, List<NetworkLabelModel>>();
    List<LogicalNetworkModel> errorLabelNetworks = new ArrayList<LogicalNetworkModel>();
    labelToIface = new HashMap<String, String>();
    // map all nics
    for (VdsNetworkInterface nic : allNics) {
        nicMap.put(nic.getName(), nic);
    }
    // pass over all nics
    for (VdsNetworkInterface nic : allNics) {
        // is this a management nic? (comes from backend)
        final boolean isNicManagement = nic.getIsManagement();
        final String nicName = nic.getName();
        final String networkName = nic.getNetworkName();
        final String bondName = nic.getBondName();
        final Integer vlanId = nic.getVlanId();
        final int dotpos = nicName.indexOf('.');
        if (vlanId == null) {
            // physical interface (rather than virtual VLAN interface)
            physicalNics.add(nic);
        }
        // is the nic bonded?
        if (bondName != null) {
            if (bondToNic.containsKey(bondName)) {
                bondToNic.get(bondName).add(nicMap.get(nicName));
            } else {
                List<VdsNetworkInterface> bondedNics = new ArrayList<VdsNetworkInterface>();
                bondedNics.add(nicMap.get(nicName));
                bondToNic.put(bondName, bondedNics);
            }
        }
        // bridge name is either <nic>, <nic.vlanid> or <bond.vlanid>
        String ifName;
        if (dotpos > 0) {
            ifName = nicName.substring(0, dotpos);
        } else {
            ifName = nicName;
        }
        // initialize this nic's network list if it hadn't been initialized
        if (!nicToNetwork.containsKey(ifName)) {
            nicToNetwork.put(ifName, new HashSet<LogicalNetworkModel>());
        }
        // does this nic have a network?
        if (networkName != null) {
            LogicalNetworkModel networkModel = networkMap.get(networkName);
            if (networkModel == null) {
                networkModel = createUnmanagedNetworkModel(networkName, nic);
            } else {
                // The real vlanId, isBridged and mtu configured on the host can be not synced with the values
                // configured in the networks table (dc networks).
                // The real values configured on the host should be displayed.
                networkModel.getEntity().setVlanId(nic.getVlanId());
                networkModel.getEntity().setMtu(nic.getMtu());
                networkModel.getEntity().setVmNetwork(nic.isBridged());
            }
            // is this a management network (from backend)?
            if (isNicManagement) {
                networkModel.setManagement(true);
            }
            Collection<LogicalNetworkModel> nicNetworks = new ArrayList<LogicalNetworkModel>();
            nicNetworks.add(networkModel);
            // set iface bridge to network
            NetworkInterfaceModel existingEridge = networkModel.getVlanNic();
            // $NON-NLS-1$
            assert existingEridge == null : "should have only one bridge, but found " + existingEridge;
            networkModel.setBridge(new NetworkInterfaceModel(nic, nicNetworks, null, this));
            nicToNetwork.get(ifName).add(networkModel);
            if (!networkModel.isInSync() && networkModel.isManaged()) {
                netToBeforeSyncParams.put(networkName, new NetworkParameters(nic));
            }
        }
        // does this nic have any labels?
        Set<String> labels = nic.getLabels();
        if (labels != null) {
            for (String label : labels) {
                labelToIface.put(label, ifName);
                NetworkLabelModel labelModel = networkLabelMap.get(label);
                if (labelModel != null) {
                    // attach label networks to nic
                    for (Iterator<LogicalNetworkModel> iter = labelModel.getNetworks().iterator(); iter.hasNext(); ) {
                        LogicalNetworkModel networkModel = iter.next();
                        if (nicToNetwork.get(ifName).contains(networkModel)) {
                            networkModel.attachViaLabel();
                        } else {
                            // The network has the same label as the nic but not attached to the nic.
                            iter.remove();
                            errorLabelNetworks.add(networkModel);
                        }
                    }
                    // attach label itself to nic
                    List<NetworkLabelModel> nicLabels = nicToLabels.get(ifName);
                    if (nicLabels == null) {
                        nicLabels = new ArrayList<NetworkLabelModel>();
                        nicToLabels.put(ifName, nicLabels);
                    }
                    nicLabels.add(labelModel);
                }
            }
        }
    }
    // calculate the next available bond name
    List<String> bondNames = new ArrayList<String>(bondToNic.keySet());
    Collections.sort(bondNames, new LexoNumericComparator());
    nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + 0;
    for (int i = 0; i < bondNames.size(); ++i) {
        if (nextBondName.equals(bondNames.get(i))) {
            nextBondName = BusinessEntitiesDefinitions.BOND_NAME_PREFIX + (i + 1);
        } else {
            break;
        }
    }
    // build models
    for (VdsNetworkInterface nic : physicalNics) {
        String nicName = nic.getName();
        // dont show bonded nics
        if (nic.getBondName() != null) {
            continue;
        }
        Collection<LogicalNetworkModel> nicNetworks = nicToNetwork.get(nicName);
        List<NetworkLabelModel> nicLabels = nicToLabels.get(nicName);
        List<VdsNetworkInterface> bondedNics = bondToNic.get(nicName);
        NetworkInterfaceModel nicModel;
        if (bondedNics != null) {
            List<NetworkInterfaceModel> bondedModels = new ArrayList<NetworkInterfaceModel>();
            for (VdsNetworkInterface bonded : bondedNics) {
                NetworkInterfaceModel bondedModel = new NetworkInterfaceModel(bonded, this);
                bondedModel.setBonded(true);
                bondedModels.add(bondedModel);
            }
            nicModel = new BondNetworkInterfaceModel(nic, nicNetworks, nicLabels, bondedModels, this);
        } else {
            nicModel = new NetworkInterfaceModel(nic, nicNetworks, nicLabels, this);
        }
        nicModels.put(nicName, nicModel);
    }
    initLabeledNetworksErrorMessages(errorLabelNetworks, nicModels);
    setNics(nicModels);
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.updateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.updateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    getDbFacade().getLunDao().updateAllInBatch(vmLunDisksToSave);
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    getVdsEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, false, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName());
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#method_after
public void afterRefreshTreatment() {
    try {
        if (processHardwareCapsNeeded) {
            monitoringStrategy.processHardwareCapabilities(_vds);
            markIsSetNonOperationalExecuted();
        }
        if (refreshedCapabilities) {
            getVdsEventListener().handleVdsVersion(_vds.getId());
            markIsSetNonOperationalExecuted();
        }
        if (_vds.getStatus() == VDSStatus.Maintenance) {
            try {
                getVdsEventListener().vdsMovedToMaintenance(_vds);
            } catch (RuntimeException ex) {
                log.errorFormat("Host encounter a problem moving to maintenance mode, probably error during disconnecting it from pool {0}. The Host will stay in Maintenance", ex.getMessage());
            }
        } else if (_vds.getStatus() == VDSStatus.NonOperational && _firstStatus != VDSStatus.NonOperational) {
            if (!_vdsManager.isSetNonOperationalExecuted()) {
                ResourceManager.getInstance().getEventListener().vdsNonOperational(_vds.getId(), _vds.getNonOperationalReason(), false, true, Guid.Empty);
            } else {
                log.infoFormat("Host {0} : {1} is already in NonOperational status for reason {2}. SetNonOperationalVds command is skipped.", _vds.getId(), _vds.getName(), (_vds.getNonOperationalReason() != null) ? _vds.getNonOperationalReason().name() : "unknown");
            }
        }
        // rerun all vms from rerun list
        for (Guid vm_guid : _vmsToRerun) {
            log.errorFormat("Rerun vm {0}. Called from vds {1}", vm_guid, _vds.getName());
            ResourceManager.getInstance().RerunFailedCommand(vm_guid, _vds.getId());
        }
        for (Guid vm_guid : _succededToRunVms) {
            _vdsManager.succededToRunVm(vm_guid);
        }
        // Refrain from auto-start HA VM during its re-run attempts.
        _autoVmsToRun.removeAll(_vmsToRerun);
        // run all vms that crushed that marked with auto startup
        getVdsEventListener().runFailedAutoStartVMs(_autoVmsToRun);
        // process all vms that their ip changed.
        for (Entry<VM, VmDynamic> pair : _vmsClientIpChanged.entrySet()) {
            getVdsEventListener().processOnClientIpChange(_vds, pair.getValue().getId());
        }
        // process all vms that powering up.
        for (VmDynamic runningVm : _poweringUpVms) {
            ResourceManager.getInstance().getEventListener().processOnVmPoweringUp(_vds.getId(), runningVm.getId(), runningVm.getDisplayIp(), runningVm.getDisplay());
        }
        // process all vms that went down
        for (Guid vm_guid : _vmsMovedToDown) {
            getVdsEventListener().processOnVmStop(vm_guid);
        }
        for (Guid vm_guid : _vmsToRemoveFromAsync) {
            ResourceManager.getInstance().RemoveAsyncRunningVm(vm_guid);
        }
    } catch (IRSErrorException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        if (log.isDebugEnabled()) {
            log.error(ExceptionUtils.getMessage(ex), ex);
        }
    } catch (RuntimeException ex) {
        logFailureMessage("ResourceManager::RerunFailedCommand:", ex);
        log.error(ExceptionUtils.getMessage(ex), ex);
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>getValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
        updateLunDisks();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#end_block

#method_before
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        // we shouldn't include them as committed.
        if (!VMStatus.WaitForLaunch.equals(vm.getStatus())) {
            memCommited += vm.getVmMemSizeMb();
            memCommited += _vds.getGuestOverhead();
            vmsCoresCount += vm.getNumOfCpus();
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#method_after
private void refreshCommitedMemory() {
    Integer memCommited = _vds.getGuestOverhead();
    int vmsCoresCount = 0;
    for (VM vm : _vmDict.values()) {
        // we shouldn't include them as committed.
        if (vm.getStatus() != VMStatus.WaitForLaunch) {
            memCommited += vm.getVmMemSizeMb();
            memCommited += _vds.getGuestOverhead();
            vmsCoresCount += vm.getNumOfCpus();
        }
    }
    if (memCommited == null || !memCommited.equals(_vds.getMemCommited())) {
        _vds.setMemCommited(memCommited);
        _saveVdsDynamic = true;
    }
    if (_vds.getVmsCoresCount() == null || !_vds.getVmsCoresCount().equals(vmsCoresCount)) {
        _vds.setVmsCoresCount(vmsCoresCount);
        _saveVdsDynamic = true;
    }
}
#end_block

#method_before
public void deserialize(String value) {
    if (allKeyValueMap == null) {
        saveEntity = value;
        return;
    }
    if (value != null) {
        // always reset the list of items when the item changes
        keyValueMap_used = new HashMap<String, String>();
        if (!value.isEmpty()) {
            String[] lines = value.split(PROPERTIES_DELIMETER);
            keyValueMap_used = new HashMap<String, String>();
            String[] splitLine;
            for (String line : lines) {
                if (line.isEmpty()) {
                    continue;
                }
                splitLine = line.split(KEY_VALUE_DELIMETER, 2);
                String key = splitLine[0];
                if (allKeyValueMap.containsKey(key)) {
                    keyValueMap_used.put(key, splitLine[1]);
                }
            }
        }
    }
    init(allKeyValueMap.keySet(), keyValueMap_used.keySet());
}
#method_after
public void deserialize(String value) {
    if (allKeyValueMap == null) {
        saveEntity = value;
        return;
    }
    // always reset the list of items when the item changes
    keyValueMap_used = new HashMap<String, String>();
    if (value != null && !value.isEmpty()) {
        String[] lines = value.split(PROPERTIES_DELIMETER);
        String[] splitLine;
        for (String line : lines) {
            if (line.isEmpty()) {
                continue;
            }
            splitLine = line.split(KEY_VALUE_DELIMETER, 2);
            String key = splitLine[0];
            if (allKeyValueMap.containsKey(key)) {
                keyValueMap_used.put(key, splitLine[1]);
            }
        }
    }
    init(allKeyValueMap.keySet(), keyValueMap_used.keySet());
}
#end_block

#method_before
protected static RoleNode createSystemRoleTree() {
    return new RoleNode(getConstants().systemRoleTree(), new RoleNode(getConstants().configureSystemRoleTree(), new RoleNode[] { new RoleNode(ActionGroup.MANIPULATE_USERS, getConstants().allowToAddRemoveUsersFromTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.MANIPULATE_PERMISSIONS, getConstants().allowToAddUsersFromDirectoryOnObjectsInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.ADD_NON_EXISTING_USERS, getConstants().allowToAddNonExistingUsersAndGroupsOnObjectsInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.MANIPULATE_ROLES, getConstants().allowToDefineConfigureRolesInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.LOGIN, getConstants().allowToLoginToTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.TAG_MANAGEMENT, getConstants().allowToManageTags()), new RoleNode(ActionGroup.BOOKMARK_MANAGEMENT, getConstants().allowToManageBookmarks()), new RoleNode(ActionGroup.EVENT_NOTIFICATION_MANAGEMENT, getConstants().allowToManageEventNotifications()), new RoleNode(ActionGroup.CONFIGURE_ENGINE, getConstants().allowToGetOrSetSystemConfigurationRoleTreeTooltip()) }));
}
#method_after
protected static RoleNode createSystemRoleTree() {
    return new RoleNode(getConstants().systemRoleTree(), new RoleNode(getConstants().configureSystemRoleTree(), new RoleNode[] { new RoleNode(ActionGroup.MANIPULATE_USERS, getConstants().allowToAddRemoveUsersFromTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.MANIPULATE_PERMISSIONS, getConstants().allowToAddRemovePermissionsForUsersOnObjectsInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.ADD_USERS_AND_GROUPS_FROM_DIRECTORY, getConstants().allowToAddUsersAndGroupsFromDirectoryOnObjectsInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.MANIPULATE_ROLES, getConstants().allowToDefineConfigureRolesInTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.LOGIN, getConstants().allowToLoginToTheSystemRoleTreeTooltip()), new RoleNode(ActionGroup.TAG_MANAGEMENT, getConstants().allowToManageTags()), new RoleNode(ActionGroup.BOOKMARK_MANAGEMENT, getConstants().allowToManageBookmarks()), new RoleNode(ActionGroup.EVENT_NOTIFICATION_MANAGEMENT, getConstants().allowToManageEventNotifications()), new RoleNode(ActionGroup.CONFIGURE_ENGINE, getConstants().allowToGetOrSetSystemConfigurationRoleTreeTooltip()) }));
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    Permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && dbUser == null) {
        permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), ActionGroup.ADD_USERS_FROM_DIRECTORY));
    }
    return permissionsSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    Permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if ((getParameters().getUser() != null && dbUser == null) || (getParameters().getGroup() != null && dbGroup == null)) {
        permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), ActionGroup.ADD_USERS_AND_GROUPS_FROM_DIRECTORY));
    }
    return permissionsSubject;
}
#end_block

#method_before
void initEntityModelCellTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    networks.enableColumnResizing();
    boolean multipleSelectionAllowed = networks.asEditor().flush().isMultiCluster();
    CheckboxHeader assignAllHeader = new CheckboxHeader(templates.textForCheckBoxHeader(constants.assignAll())) {

        @Override
        protected void selectionChanged(Boolean value) {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditAssign(clusterNetworkManageModel)) {
                    changeIsAttached(clusterNetworkManageModel, value);
                }
            }
            refreshNetworksTable();
        }

        @Override
        public Boolean getValue() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditAssign(clusterNetworkManageModel)) {
                    if (!clusterNetworkManageModel.isAttached()) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (clusterNetworkManageModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }
    };
    networks.addColumn(new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).getDisplayedName();
        }
    }, constants.nameNetwork(), // $NON-NLS-1$
    "85px");
    networks.addColumn(new CheckboxColumn<EntityModel>(new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            changeIsAttached(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isAttached();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            return ClusterManageNetworkPopupView.this.canEditAssign(model);
        }

        @Override
        public void render(Context context, EntityModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.assign()));
        }
    }, assignAllHeader, // $NON-NLS-1$
    "90px");
    CheckboxHeader requiredAllHeader = new CheckboxHeader(templates.textForCheckBoxHeader(constants.requiredAll())) {

        @Override
        protected void selectionChanged(Boolean value) {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditRequired(clusterNetworkManageModel)) {
                    clusterNetworkManageModel.setRequired(value);
                }
                refreshNetworksTable();
            }
        }

        @Override
        public Boolean getValue() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditRequired(clusterNetworkManageModel)) {
                    if (!clusterNetworkManageModel.isRequired()) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (clusterNetworkManageModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }
    };
    networks.addColumn(new CheckboxColumn<EntityModel>(new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ((ClusterNetworkModel) model).setRequired(value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isRequired();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            return canEditRequired(model);
        }

        @Override
        public void render(Context context, EntityModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.required()));
        }
    }, requiredAllHeader, // $NON-NLS-1$
    "110px");
    SafeHtmlWithSafeHtmlTooltipColumn<EntityModel> vmColumn = new SafeHtmlWithSafeHtmlTooltipColumn<EntityModel>() {

        @Override
        public SafeHtml getValue(EntityModel model) {
            List<SafeHtml> images = new LinkedList<SafeHtml>();
            if (((ClusterNetworkModel) model).isVmNetwork()) {
                images.add(vmImage);
            } else {
                images.add(emptyImage);
            }
            return NetworkRoleColumnHelper.getValue(images);
        }

        @Override
        public SafeHtml getTooltip(EntityModel model) {
            Map<SafeHtml, String> imagesToText = new LinkedHashMap<SafeHtml, String>();
            if (((ClusterNetworkModel) model).isVmNetwork()) {
                imagesToText.put(vmImage, constants.vmItemInfo());
            }
            return NetworkRoleColumnHelper.getTooltip(imagesToText);
        }
    };
    // $NON-NLS-1$
    networks.addColumn(vmColumn, constants.vmNetwork(), "80px");
    networks.addColumn(new CheckboxColumn<EntityModel>(multipleSelectionAllowed, new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            networks.asEditor().flush().setDisplayNetwork(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isDisplayNetwork();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            ClusterNetworkModel clusterNetworkModel = (ClusterNetworkModel) model;
            return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
        }
    }, constants.displayNetwork(), // $NON-NLS-1$
    "100px");
    networks.addColumn(new CheckboxColumn<EntityModel>(multipleSelectionAllowed, new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            networks.asEditor().flush().setMigrationNetwork(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isMigrationNetwork();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            ClusterNetworkModel clusterNetworkModel = ((ClusterNetworkModel) model);
            Boolean migrationNetworkEnabled = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationNetworkEnabled, clusterNetworkModel.getCluster().getcompatibility_version().toString());
            return migrationNetworkEnabled && clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
        }
    }, constants.migrationNetwork(), // $NON-NLS-1$
    "105px");
}
#method_after
void initEntityModelCellTable(final ApplicationConstants constants, final ApplicationTemplates templates) {
    networks.enableColumnResizing();
    boolean multipleSelectionAllowed = networks.asEditor().flush().isMultiCluster();
    CheckboxHeader assignAllHeader = new CheckboxHeader(templates.textForCheckBoxHeader(constants.assignAll())) {

        @Override
        protected void selectionChanged(Boolean value) {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditAssign(clusterNetworkManageModel)) {
                    changeIsAttached(clusterNetworkManageModel, value);
                }
            }
            refreshNetworksTable();
        }

        @Override
        public Boolean getValue() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditAssign(clusterNetworkManageModel)) {
                    if (!clusterNetworkManageModel.isAttached()) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (clusterNetworkManageModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }
    };
    networks.addColumn(new TextColumnWithTooltip<EntityModel>() {

        @Override
        public String getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).getDisplayedName();
        }
    }, constants.nameNetwork(), // $NON-NLS-1$
    "85px");
    networks.addColumn(new CheckboxColumn<EntityModel>(new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            changeIsAttached(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isAttached();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            return ClusterManageNetworkPopupView.this.canEditAssign(model);
        }

        @Override
        public void render(Context context, EntityModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.assign()));
        }
    }, assignAllHeader, // $NON-NLS-1$
    "90px");
    CheckboxHeader requiredAllHeader = new CheckboxHeader(templates.textForCheckBoxHeader(constants.requiredAll())) {

        @Override
        protected void selectionChanged(Boolean value) {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditRequired(clusterNetworkManageModel)) {
                    clusterNetworkManageModel.setRequired(value);
                }
                refreshNetworksTable();
            }
        }

        @Override
        public Boolean getValue() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (canEditRequired(clusterNetworkManageModel)) {
                    if (!clusterNetworkManageModel.isRequired()) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public boolean isEnabled() {
            for (EntityModel model : getNetworksTableItems()) {
                ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
                if (clusterNetworkManageModel.getIsChangable()) {
                    return true;
                }
            }
            return false;
        }
    };
    networks.addColumn(new CheckboxColumn<EntityModel>(new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ((ClusterNetworkModel) model).setRequired(value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isRequired();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            return canEditRequired(model);
        }

        @Override
        public void render(Context context, EntityModel object, SafeHtmlBuilder sb) {
            super.render(context, object, sb);
            sb.append(templates.textForCheckBox(constants.required()));
        }
    }, requiredAllHeader, // $NON-NLS-1$
    "110px");
    SafeHtmlWithSafeHtmlTooltipColumn<ClusterNetworkModel> vmColumn = new SafeHtmlWithSafeHtmlTooltipColumn<ClusterNetworkModel>() {

        @Override
        public SafeHtml getValue(ClusterNetworkModel model) {
            return NetworkRoleColumnHelper.getValue(Collections.singletonList(model.isVmNetwork() ? vmImage : emptyImage));
        }

        @Override
        public SafeHtml getTooltip(ClusterNetworkModel model) {
            return NetworkRoleColumnHelper.getTooltip(model.isVmNetwork() ? Collections.singletonMap(vmImage, constants.vmItemInfo()) : Collections.<SafeHtml, String>emptyMap());
        }
    };
    // $NON-NLS-1$
    networks.addColumn(vmColumn, constants.vmNetwork(), "80px");
    networks.addColumn(new CheckboxColumn<EntityModel>(multipleSelectionAllowed, new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            networks.asEditor().flush().setDisplayNetwork(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isDisplayNetwork();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            ClusterNetworkModel clusterNetworkModel = (ClusterNetworkModel) model;
            return clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
        }
    }, constants.displayNetwork(), // $NON-NLS-1$
    "100px");
    networks.addColumn(new CheckboxColumn<EntityModel>(multipleSelectionAllowed, new FieldUpdater<EntityModel, Boolean>() {

        @Override
        public void update(int index, EntityModel model, Boolean value) {
            ClusterNetworkModel clusterNetworkManageModel = (ClusterNetworkModel) model;
            networks.asEditor().flush().setMigrationNetwork(clusterNetworkManageModel, value);
            refreshNetworksTable();
        }
    }) {

        @Override
        public Boolean getValue(EntityModel model) {
            return ((ClusterNetworkModel) model).isMigrationNetwork();
        }

        @Override
        protected boolean canEdit(EntityModel model) {
            ClusterNetworkModel clusterNetworkModel = ((ClusterNetworkModel) model);
            Boolean migrationNetworkEnabled = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MigrationNetworkEnabled, clusterNetworkModel.getCluster().getcompatibility_version().toString());
            return migrationNetworkEnabled && clusterNetworkModel.isAttached() && !clusterNetworkModel.isExternal();
        }
    }, constants.migrationNetwork(), // $NON-NLS-1$
    "105px");
}
#end_block

#method_before
public void showItem(NetworkItemModel<?> item, NetworkItemPanel panel) {
    if (item instanceof LogicalNetworkModel) {
        showNetwork((LogicalNetworkModel) item);
        showRelativeTo(panel);
    } else if (item instanceof NetworkInterfaceModel) {
        showNic((NetworkInterfaceModel) item);
        showRelativeTo(panel);
    }
}
#method_after
public void showItem(NetworkItemModel<?> item, NetworkItemPanel panel) {
    if (item instanceof LogicalNetworkModel) {
        showNetwork((LogicalNetworkModel) item);
    } else if (item instanceof NetworkInterfaceModel) {
        showNic((NetworkInterfaceModel) item);
    } else if (item instanceof NetworkLabelModel) {
        return;
    }
    showRelativeTo(panel);
}
#end_block

#method_before
private void showNetwork(LogicalNetworkModel networkModel) {
    contents.removeAllRows();
    Network entity = networkModel.getEntity();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName()));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
    } else {
        if (networkModel.getErrorNicName() != null) {
            addRow(templates.imageTextSetupNetwork(alertImage, SafeHtmlUtils.fromTrustedString(messages.networkLabelConflict(networkModel.getErrorNicName(), networkModel.getEntity().getLabel()))));
        }
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.networkNotInSync()));
        }
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration) {
        // $NON-NLS-1$
        addRow(SafeHtmlUtils.fromString(constants.usageItemInfo() + ":"));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo()));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo()));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo()));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo()));
        }
    }
    // Mtu
    if (entity.getMtu() != 0) {
        addRow(constants.mtuItemInfo(), String.valueOf(entity.getMtu()));
    }
}
#method_after
private void showNetwork(LogicalNetworkModel networkModel) {
    contents.removeAllRows();
    Network entity = networkModel.getEntity();
    addRow(templates.titleSetupNetworkTooltip(networkModel.getName()));
    // Not managed
    if (!networkModel.isManaged()) {
        addRow(templates.imageTextSetupNetwork(unknownImage, constants.unmanagedNetworkItemInfo()));
        addRow(SafeHtmlUtils.fromString(constants.unmanagedNetworkDescriptionItemInfo()));
    } else {
        // Description
        if (entity.getDescription() != null && !entity.getDescription().trim().equals("")) {
            // $NON-NLS-1$
            addRow(SafeHtmlUtils.fromString(entity.getDescription()));
        }
        // Not in sync
        if (!networkModel.isInSync()) {
            addRow(templates.imageTextSetupNetwork(notInSyncImage, constants.networkNotInSync()));
        }
    }
    boolean isDisplay = false;
    boolean isMigration = false;
    if (entity.getCluster() != null) {
        isDisplay = entity.getCluster().isDisplay();
        isMigration = entity.getCluster().isMigration();
    }
    // Usages
    if (networkModel.isManagement() || isDisplay || entity.isVmNetwork() || isMigration) {
        // $NON-NLS-1$
        addRow(SafeHtmlUtils.fromString(constants.usageItemInfo() + ":"));
        if (networkModel.isManagement()) {
            addRow(templates.imageTextSetupNetworkUsage(mgmtNetworkImage, constants.managementItemInfo()));
        }
        if (isDisplay) {
            addRow(templates.imageTextSetupNetworkUsage(monitorImage, constants.displayItemInfo()));
        }
        if (entity.isVmNetwork()) {
            addRow(templates.imageTextSetupNetworkUsage(vmImage, constants.vmItemInfo()));
        }
        if (isMigration) {
            addRow(templates.imageTextSetupNetworkUsage(migrationImage, constants.migrationItemInfo()));
        }
    }
    // Mtu
    if (entity.getMtu() != 0) {
        addRow(constants.mtuItemInfo(), String.valueOf(entity.getMtu()));
    }
}
#end_block

#method_before
private void updatePortMirroringChangability() {
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            List<VM> vms = (List<VM>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            if (vms != null && !vms.isEmpty()) {
                getPortMirroring().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().portMirroringNotChangedIfUsedByVms());
                getPortMirroring().setIsChangable(false);
            }
            stopProgress();
        }
    };
    IdQueryParameters params = new IdQueryParameters(getProfile().getId());
    startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsByVnicProfileId, params, asyncQuery);
}
#method_after
private void updatePortMirroringChangability() {
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            Collection<VM> vms = (Collection<VM>) ((VdcQueryReturnValue) ReturnValue).getReturnValue();
            if (vms != null && !vms.isEmpty()) {
                getPortMirroring().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().portMirroringNotChangedIfUsedByVms());
                getPortMirroring().setIsChangable(false);
            }
            stopProgress();
        }
    };
    IdQueryParameters params = new IdQueryParameters(getProfile().getId());
    startProgress(null);
    Frontend.getInstance().runQuery(VdcQueryType.GetVmsByVnicProfileId, params, asyncQuery);
}
#end_block

#method_before
private void showContextMenu(NetworkItemPanel panel, int clientX, int clientY) {
    if (menu.size() > 0) {
        menuPopup.setWidget(menu);
        menuPopup.setPopupPosition(clientX, clientY);
        menuPopup.show();
    }
}
#method_after
private void showContextMenu(NetworkItemPanel panel, int clientX, int clientY) {
    if (!menu.isEmpty()) {
        menuPopup.setWidget(menu);
        menuPopup.setPopupPosition(clientX, clientY);
        menuPopup.show();
    }
}
#end_block

