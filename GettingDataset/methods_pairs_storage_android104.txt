324
#method_before
@VisibleForTesting
public void updatePhoneType() {
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mRestrictedState = new RestrictedState();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzUpdatedTime = false;
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
        mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
        mCi.setOnRestrictedStateChanged(this, EVENT_RESTRICTED_STATE_CHANGED, null);
    } else {
        // clear GSM regsitrations first
        mCi.unregisterForAvailable(this);
        mCi.unSetOnRestrictedStateChanged(this);
        if (mPhone.isPhoneTypeCdmaLte()) {
            mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that we've thrown away state and are starting over with
    // empty, detached ServiceStates.
    mVoiceRoamingOffRegistrants.notifyRegistrants();
    mDataRoamingOffRegistrants.notifyRegistrants();
    mDetachedRegistrants.notifyRegistrants();
    notifyDataRegStateRilRadioTechnologyChanged();
}
#method_after
@VisibleForTesting
public void updatePhoneType() {
    // we change back to non-roaming.
    if (mSS != null && mSS.getVoiceRoaming()) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    // we change back to non-roaming.
    if (mSS != null && mSS.getDataRoaming()) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    // If we are previously in service, we need to notify that we are out of service now.
    if (mSS != null && mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE) {
        mDetachedRegistrants.notifyRegistrants();
    }
    mSS = new ServiceState();
    mNewSS = new ServiceState();
    mLastCellInfoListTime = 0;
    mLastCellInfoList = null;
    mSignalStrength = new SignalStrength();
    mRestrictedState = new RestrictedState();
    mStartedGprsRegCheck = false;
    mReportedGprsNoReg = false;
    mMdn = null;
    mMin = null;
    mPrlVersion = null;
    mIsMinInfoReady = false;
    mNitzUpdatedTime = false;
    // cancel any pending pollstate request on voice tech switching
    cancelPollState();
    if (mPhone.isPhoneTypeGsm()) {
        // clear CDMA registrations first
        if (mCdmaSSM != null) {
            mCdmaSSM.dispose(this);
        }
        mCi.unregisterForCdmaPrlChanged(this);
        mPhone.unregisterForEriFileLoaded(this);
        mCi.unregisterForCdmaOtaProvision(this);
        mPhone.unregisterForSimRecordsLoaded(this);
        mCellLoc = new GsmCellLocation();
        mNewCellLoc = new GsmCellLocation();
        mCi.registerForAvailable(this, EVENT_RADIO_AVAILABLE, null);
        mCi.setOnRestrictedStateChanged(this, EVENT_RESTRICTED_STATE_CHANGED, null);
    } else {
        // clear GSM regsitrations first
        mCi.unregisterForAvailable(this);
        mCi.unSetOnRestrictedStateChanged(this);
        if (mPhone.isPhoneTypeCdmaLte()) {
            mPhone.registerForSimRecordsLoaded(this, EVENT_SIM_RECORDS_LOADED, null);
        }
        mCellLoc = new CdmaCellLocation();
        mNewCellLoc = new CdmaCellLocation();
        mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(mPhone.getContext(), mCi, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
        mIsSubscriptionFromRuim = (mCdmaSSM.getCdmaSubscriptionSource() == CdmaSubscriptionSourceManager.SUBSCRIPTION_FROM_RUIM);
        mCi.registerForCdmaPrlChanged(this, EVENT_CDMA_PRL_VERSION_CHANGED, null);
        mPhone.registerForEriFileLoaded(this, EVENT_ERI_FILE_LOADED, null);
        mCi.registerForCdmaOtaProvision(this, EVENT_OTA_PROVISION_STATUS_CHANGE, null);
        mHbpcdUtils = new HbpcdUtils(mPhone.getContext());
        // update OTASP state in case previously set by another service
        updateOtaspState();
    }
    // This should be done after the technology specific initializations above since it relies
    // on fields like mIsSubscriptionFromRuim (which is updated above)
    onUpdateIccAvailability();
    mPhone.setSystemProperty(TelephonyProperties.PROPERTY_DATA_NETWORK_TYPE, ServiceState.rilRadioTechnologyToString(ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN));
    // Query signal strength from the modem after service tracker is created (i.e. boot up,
    // switching between GSM and CDMA phone), because the unsolicited signal strength
    // information might come late or even never come. This will get the accurate signal
    // strength information displayed on the UI.
    mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
    sendMessage(obtainMessage(EVENT_PHONE_TYPE_SWITCHED));
    logPhoneTypeChange();
    // Tell everybody that the registration state and RAT have changed.
    notifyDataRegStateRilRadioTechnologyChanged();
}
#end_block

#method_before
public void dispose() {
    mCi.unSetOnSignalStrengthUpdate(this);
    mUiccController.unregisterForIccChanged(this);
    mCi.unregisterForCellInfoList(this);
    mSubscriptionManager.removeOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
    mCi.unregisterForImsNetworkStateChanged(this);
}
#method_after
public void dispose() {
    mCi.unSetOnSignalStrengthUpdate(this);
    mUiccController.unregisterForIccChanged(this);
    mCi.unregisterForCellInfoList(this);
    mSubscriptionManager.removeOnSubscriptionsChangedListener(mOnSubscriptionsChangedListener);
    mCi.unregisterForImsNetworkStateChanged(this);
    mPhone.getCarrierActionAgent().unregisterForCarrierAction(this, CARRIER_ACTION_SET_RADIO_ENABLED);
}
#end_block

#method_before
public void registerForDataRoamingOff(Handler h, int what, Object obj) {
    Registrant r = new Registrant(h, what, obj);
    mDataRoamingOffRegistrants.add(r);
    if (!mSS.getDataRoaming()) {
        r.notifyRegistrant();
    }
}
#method_after
public void registerForDataRoamingOff(Handler h, int what, Object obj, boolean notifyNow) {
    Registrant r = new Registrant(h, what, obj);
    mDataRoamingOffRegistrants.add(r);
    if (notifyNow && !mSS.getDataRoaming()) {
        r.notifyRegistrant();
    }
}
#end_block

#method_before
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        // GSM
        case EVENT_RADIO_AVAILABLE:
            // setPowerStateToDesired();
            break;
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                String[] states = (String[]) ar.result;
                if (mPhone.isPhoneTypeGsm()) {
                    int lac = -1;
                    int cid = -1;
                    if (states.length >= 3) {
                        try {
                            if (states[1] != null && states[1].length() > 0) {
                                lac = (int) Long.parseLong(states[1], 16);
                            }
                            if (states[2] != null && states[2].length() > 0) {
                                cid = (int) Long.parseLong(states[2], 16);
                            }
                        } catch (NumberFormatException ex) {
                            Rlog.w(LOG_TAG, "error parsing location: " + ex);
                        }
                    }
                    ((GsmCellLocation) mCellLoc).setLacAndCid(lac, cid);
                } else {
                    int baseStationId = -1;
                    int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                    int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                    int systemId = -1;
                    int networkId = -1;
                    if (states.length > 9) {
                        try {
                            if (states[4] != null) {
                                baseStationId = Integer.parseInt(states[4]);
                            }
                            if (states[5] != null) {
                                baseStationLatitude = Integer.parseInt(states[5]);
                            }
                            if (states[6] != null) {
                                baseStationLongitude = Integer.parseInt(states[6]);
                            }
                            // Some carriers only return lat-lngs of 0,0
                            if (baseStationLatitude == 0 && baseStationLongitude == 0) {
                                baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                                baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                            }
                            if (states[8] != null) {
                                systemId = Integer.parseInt(states[8]);
                            }
                            if (states[9] != null) {
                                networkId = Integer.parseInt(states[9]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("error parsing cell location data: " + ex);
                        }
                    }
                    ((CdmaCellLocation) mCellLoc).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
                }
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#method_after
@Override
public void handleMessage(Message msg) {
    AsyncResult ar;
    int[] ints;
    Message message;
    if (VDBG)
        log("received event " + msg.what);
    switch(msg.what) {
        case EVENT_SET_RADIO_POWER_OFF:
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff && (msg.arg1 == mPendingRadioPowerOffAfterDataOffTag)) {
                    if (DBG)
                        log("EVENT_SET_RADIO_OFF, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOffTag += 1;
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_SET_RADIO_OFF is stale arg1=" + msg.arg1 + "!= tag=" + mPendingRadioPowerOffAfterDataOffTag);
                }
            }
            break;
        case EVENT_ICC_CHANGED:
            onUpdateIccAvailability();
            break;
        case EVENT_GET_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                CellInfoResult result = (CellInfoResult) ar.userObj;
                synchronized (result.lockObj) {
                    if (ar.exception != null) {
                        log("EVENT_GET_CELL_INFO_LIST: error ret null, e=" + ar.exception);
                        result.list = null;
                    } else {
                        result.list = (List<CellInfo>) ar.result;
                        if (VDBG) {
                            log("EVENT_GET_CELL_INFO_LIST: size=" + result.list.size() + " list=" + result.list);
                        }
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = result.list;
                    result.lockObj.notify();
                }
                break;
            }
        case EVENT_UNSOL_CELL_INFO_LIST:
            {
                ar = (AsyncResult) msg.obj;
                if (ar.exception != null) {
                    log("EVENT_UNSOL_CELL_INFO_LIST: error ignoring, e=" + ar.exception);
                } else {
                    List<CellInfo> list = (List<CellInfo>) ar.result;
                    if (VDBG) {
                        log("EVENT_UNSOL_CELL_INFO_LIST: size=" + list.size() + " list=" + list);
                    }
                    mLastCellInfoListTime = SystemClock.elapsedRealtime();
                    mLastCellInfoList = list;
                    mPhone.notifyCellInfo(list);
                }
                break;
            }
        case // received unsol
        EVENT_IMS_STATE_CHANGED:
            mCi.getImsRegistrationState(this.obtainMessage(EVENT_IMS_STATE_DONE));
            break;
        case EVENT_IMS_STATE_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                int[] responseArray = (int[]) ar.result;
                mImsRegistered = (responseArray[0] == 1) ? true : false;
            }
            break;
        // GSM
        case EVENT_RADIO_AVAILABLE:
            // setPowerStateToDesired();
            break;
        case EVENT_SIM_READY:
            // Reset the mPreviousSubId so we treat a SIM power bounce
            // as a first boot.  See b/19194287
            mOnSubscriptionsChangedListener.mPreviousSubId.set(-1);
            pollState();
            // Signal strength polling stops when radio is off
            queueNextSignalStrengthPoll();
            break;
        case EVENT_RADIO_STATE_CHANGED:
        case EVENT_PHONE_TYPE_SWITCHED:
            if (!mPhone.isPhoneTypeGsm() && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_ON) {
                handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
                // Signal strength polling stops when radio is off.
                queueNextSignalStrengthPoll();
            }
            // This will do nothing in the 'radio not available' case
            setPowerStateToDesired();
            // These events are modem triggered, so pollState() needs to be forced
            modemTriggeredPollState();
            break;
        case EVENT_NETWORK_STATE_CHANGED:
            modemTriggeredPollState();
            break;
        case EVENT_GET_SIGNAL_STRENGTH:
            if (!(mCi.getRadioState().isOn())) {
                // Polling will continue when radio turns back on
                return;
            }
            ar = (AsyncResult) msg.obj;
            onSignalStrengthResult(ar);
            queueNextSignalStrengthPoll();
            break;
        case EVENT_GET_LOC_DONE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                processCellLocationInfo(mCellLoc, (VoiceRegStateResult) ar.result);
                mPhone.notifyLocationChanged();
            }
            // Release any temporary cell lock, which could have been
            // acquired to allow a single-shot location update.
            disableSingleLocationUpdate();
            break;
        case EVENT_POLL_STATE_REGISTRATION:
        case EVENT_POLL_STATE_GPRS:
        case EVENT_POLL_STATE_OPERATOR:
            ar = (AsyncResult) msg.obj;
            handlePollStateResult(msg.what, ar);
            break;
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            if (DBG)
                log("EVENT_POLL_STATE_NETWORK_SELECTION_MODE");
            ar = (AsyncResult) msg.obj;
            if (mPhone.isPhoneTypeGsm()) {
                handlePollStateResult(msg.what, ar);
            } else {
                if (ar.exception == null && ar.result != null) {
                    ints = (int[]) ar.result;
                    if (ints[0] == 1) {
                        // Manual selection.
                        mPhone.setNetworkSelectionModeAutomatic(null);
                    }
                } else {
                    log("Unable to getNetworkSelectionMode");
                }
            }
            break;
        case EVENT_POLL_SIGNAL_STRENGTH:
            // Just poll signal strength...not part of pollState()
            mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
            break;
        case EVENT_NITZ_TIME:
            ar = (AsyncResult) msg.obj;
            String nitzString = (String) ((Object[]) ar.result)[0];
            long nitzReceiveTime = ((Long) ((Object[]) ar.result)[1]).longValue();
            setTimeFromNITZString(nitzString, nitzReceiveTime);
            break;
        case EVENT_SIGNAL_STRENGTH_UPDATE:
            // This is a notification from CommandsInterface.setOnSignalStrengthUpdate
            ar = (AsyncResult) msg.obj;
            // The radio is telling us about signal strength changes
            // we don't have to ask it
            mDontPollSignalStrength = true;
            onSignalStrengthResult(ar);
            break;
        case EVENT_SIM_RECORDS_LOADED:
            log("EVENT_SIM_RECORDS_LOADED: what=" + msg.what);
            updatePhoneObject();
            updateOtaspState();
            if (mPhone.isPhoneTypeGsm()) {
                updateSpnDisplay();
            }
            break;
        case EVENT_LOCATION_UPDATES_ENABLED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mCi.getVoiceRegistrationState(obtainMessage(EVENT_GET_LOC_DONE, null));
            }
            break;
        case EVENT_SET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            // Don't care the result, only use for dereg network (COPS=2)
            message = obtainMessage(EVENT_RESET_PREFERRED_NETWORK_TYPE, ar.userObj);
            mCi.setPreferredNetworkType(mPreferredNetworkType, message);
            break;
        case EVENT_RESET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.userObj != null) {
                AsyncResult.forMessage(((Message) ar.userObj)).exception = ar.exception;
                ((Message) ar.userObj).sendToTarget();
            }
            break;
        case EVENT_GET_PREFERRED_NETWORK_TYPE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                mPreferredNetworkType = ((int[]) ar.result)[0];
            } else {
                mPreferredNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            }
            message = obtainMessage(EVENT_SET_PREFERRED_NETWORK_TYPE, ar.userObj);
            int toggledNetworkType = RILConstants.NETWORK_MODE_GLOBAL;
            mCi.setPreferredNetworkType(toggledNetworkType, message);
            break;
        case EVENT_CHECK_REPORT_GPRS:
            if (mPhone.isPhoneTypeGsm() && mSS != null && !isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
                // Can't register data service while voice service is ok
                // i.e. CREG is ok while CGREG is not
                // possible a network or baseband side error
                GsmCellLocation loc = ((GsmCellLocation) mPhone.getCellLocation());
                EventLog.writeEvent(EventLogTags.DATA_NETWORK_REGISTRATION_FAIL, mSS.getOperatorNumeric(), loc != null ? loc.getCid() : -1);
                mReportedGprsNoReg = true;
            }
            mStartedGprsRegCheck = false;
            break;
        case EVENT_RESTRICTED_STATE_CHANGED:
            if (mPhone.isPhoneTypeGsm()) {
                if (DBG)
                    log("EVENT_RESTRICTED_STATE_CHANGED");
                ar = (AsyncResult) msg.obj;
                onRestrictedStateChanged(ar);
            }
            break;
        case EVENT_ALL_DATA_DISCONNECTED:
            int dds = SubscriptionManager.getDefaultDataSubscriptionId();
            ProxyController.getInstance().unregisterForAllDataDisconnected(dds, this);
            synchronized (this) {
                if (mPendingRadioPowerOffAfterDataOff) {
                    if (DBG)
                        log("EVENT_ALL_DATA_DISCONNECTED, turn radio off now.");
                    hangupAndPowerOff();
                    mPendingRadioPowerOffAfterDataOff = false;
                } else {
                    log("EVENT_ALL_DATA_DISCONNECTED is stale");
                }
            }
            break;
        case EVENT_CHANGE_IMS_STATE:
            if (DBG)
                log("EVENT_CHANGE_IMS_STATE:");
            setPowerStateToDesired();
            break;
        case EVENT_IMS_CAPABILITY_CHANGED:
            if (DBG)
                log("EVENT_IMS_CAPABILITY_CHANGED");
            updateSpnDisplay();
            break;
        // CDMA
        case EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED:
            handleCdmaSubscriptionSource(mCdmaSSM.getCdmaSubscriptionSource());
            break;
        case EVENT_RUIM_READY:
            if (mPhone.getLteOnCdmaMode() == PhoneConstants.LTE_ON_CDMA_TRUE) {
                // Subscription will be read from SIM I/O
                if (DBG)
                    log("Receive EVENT_RUIM_READY");
                pollState();
            } else {
                if (DBG)
                    log("Receive EVENT_RUIM_READY and Send Request getCDMASubscription.");
                getSubscriptionInfoAndStartPollingThreads();
            }
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            break;
        case EVENT_NV_READY:
            updatePhoneObject();
            // Only support automatic selection mode in CDMA.
            mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE));
            // For Non-RUIM phones, the subscription information is stored in
            // Non Volatile. Here when Non-Volatile is ready, we can poll the CDMA
            // subscription info.
            getSubscriptionInfoAndStartPollingThreads();
            break;
        case // Handle RIL_CDMA_SUBSCRIPTION
        EVENT_POLL_STATE_CDMA_SUBSCRIPTION:
            if (!mPhone.isPhoneTypeGsm()) {
                ar = (AsyncResult) msg.obj;
                if (ar.exception == null) {
                    String[] cdmaSubscription = (String[]) ar.result;
                    if (cdmaSubscription != null && cdmaSubscription.length >= 5) {
                        mMdn = cdmaSubscription[0];
                        parseSidNid(cdmaSubscription[1], cdmaSubscription[2]);
                        mMin = cdmaSubscription[3];
                        mPrlVersion = cdmaSubscription[4];
                        if (DBG)
                            log("GET_CDMA_SUBSCRIPTION: MDN=" + mMdn);
                        mIsMinInfoReady = true;
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                        if (!mIsSubscriptionFromRuim && mIccRecords != null) {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION set imsi in mIccRecords");
                            }
                            mIccRecords.setImsi(getImsi());
                        } else {
                            if (DBG) {
                                log("GET_CDMA_SUBSCRIPTION either mIccRecords is null or NV " + "type device - not setting Imsi in mIccRecords");
                            }
                        }
                    } else {
                        if (DBG) {
                            log("GET_CDMA_SUBSCRIPTION: error parsing cdmaSubscription " + "params num=" + cdmaSubscription.length);
                        }
                    }
                }
            }
            break;
        case EVENT_RUIM_RECORDS_LOADED:
            if (!mPhone.isPhoneTypeGsm()) {
                log("EVENT_RUIM_RECORDS_LOADED: what=" + msg.what);
                updatePhoneObject();
                if (mPhone.isPhoneTypeCdma()) {
                    updateSpnDisplay();
                } else {
                    RuimRecords ruim = (RuimRecords) mIccRecords;
                    if (ruim != null) {
                        if (ruim.isProvisioned()) {
                            mMdn = ruim.getMdn();
                            mMin = ruim.getMin();
                            parseSidNid(ruim.getSid(), ruim.getNid());
                            mPrlVersion = ruim.getPrlVersion();
                            mIsMinInfoReady = true;
                        }
                        updateOtaspState();
                        // Notify apps subscription info is ready
                        notifyCdmaSubscriptionInfoReady();
                    }
                    // SID/NID/PRL is loaded. Poll service state
                    // again to update to the roaming state with
                    // the latest variables.
                    pollState();
                }
            }
            break;
        case EVENT_ERI_FILE_LOADED:
            // Repoll the state once the ERI file has been loaded.
            if (DBG)
                log("ERI file has been loaded, repolling.");
            pollState();
            break;
        case EVENT_OTA_PROVISION_STATUS_CHANGE:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                int otaStatus = ints[0];
                if (otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_COMMITTED || otaStatus == Phone.CDMA_OTA_PROVISION_STATUS_OTAPA_STOPPED) {
                    if (DBG)
                        log("EVENT_OTA_PROVISION_STATUS_CHANGE: Complete, Reload MDN");
                    mCi.getCDMASubscription(obtainMessage(EVENT_POLL_STATE_CDMA_SUBSCRIPTION));
                }
            }
            break;
        case EVENT_CDMA_PRL_VERSION_CHANGED:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                ints = (int[]) ar.result;
                mPrlVersion = Integer.toString(ints[0]);
            }
            break;
        case EVENT_RADIO_POWER_FROM_CARRIER:
            ar = (AsyncResult) msg.obj;
            if (ar.exception == null) {
                boolean enable = (boolean) ar.result;
                if (DBG)
                    log("EVENT_RADIO_POWER_FROM_CARRIER: " + enable);
                setRadioPowerFromCarrier(enable);
            }
            break;
        default:
            log("Unhandled message with number: " + msg.what);
            break;
    }
}
#end_block

#method_before
public int getOtasp() {
    int provisioningState;
    // if sim is not loaded, return otasp uninitialized
    if (!mPhone.getIccRecordsLoaded()) {
        if (DBG)
            log("getOtasp: otasp uninitialized due to sim not loaded");
        return OTASP_UNINITIALIZED;
    }
    // if voice tech is Gsm, return otasp not needed
    if (mPhone.isPhoneTypeGsm()) {
        if (DBG)
            log("getOtasp: otasp not needed for GSM");
        return OTASP_NOT_NEEDED;
    }
    // for ruim, min is null means require otasp.
    if (mIsSubscriptionFromRuim && mMin == null) {
        return OTASP_NEEDED;
    }
    if (mMin == null || (mMin.length() < 6)) {
        if (DBG)
            log("getOtasp: bad mMin='" + mMin + "'");
        provisioningState = OTASP_UNKNOWN;
    } else {
        if ((mMin.equals(UNACTIVATED_MIN_VALUE) || mMin.substring(0, 6).equals(UNACTIVATED_MIN2_VALUE)) || SystemProperties.getBoolean("test_cdma_setup", false)) {
            provisioningState = OTASP_NEEDED;
        } else {
            provisioningState = OTASP_NOT_NEEDED;
        }
    }
    if (DBG)
        log("getOtasp: state=" + provisioningState);
    return provisioningState;
}
#method_after
public int getOtasp() {
    int provisioningState;
    // if sim is not loaded, return otasp uninitialized
    if (!mPhone.getIccRecordsLoaded()) {
        if (DBG)
            log("getOtasp: otasp uninitialized due to sim not loaded");
        return TelephonyManager.OTASP_UNINITIALIZED;
    }
    // if voice tech is Gsm, return otasp not needed
    if (mPhone.isPhoneTypeGsm()) {
        if (DBG)
            log("getOtasp: otasp not needed for GSM");
        return TelephonyManager.OTASP_NOT_NEEDED;
    }
    // for ruim, min is null means require otasp.
    if (mIsSubscriptionFromRuim && mMin == null) {
        return TelephonyManager.OTASP_NEEDED;
    }
    if (mMin == null || (mMin.length() < 6)) {
        if (DBG)
            log("getOtasp: bad mMin='" + mMin + "'");
        provisioningState = TelephonyManager.OTASP_UNKNOWN;
    } else {
        if ((mMin.equals(UNACTIVATED_MIN_VALUE) || mMin.substring(0, 6).equals(UNACTIVATED_MIN2_VALUE)) || SystemProperties.getBoolean("test_cdma_setup", false)) {
            provisioningState = TelephonyManager.OTASP_NEEDED;
        } else {
            provisioningState = TelephonyManager.OTASP_NOT_NEEDED;
        }
    }
    if (DBG)
        log("getOtasp: state=" + provisioningState);
    return provisioningState;
}
#end_block

#method_before
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                mNewSS.setVoiceRoaming(isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS));
            }
            // For CDMA, voice and data should have the same roaming status
            final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
            final int dataRegType = mNewSS.getRilDataRadioTechnology();
            if (isVoiceInService && ServiceState.isCdma(dataRegType)) {
                mNewSS.setDataRoaming(mNewSS.getVoiceRoaming());
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#method_after
protected void handlePollStateResult(int what, AsyncResult ar) {
    // Ignore stale requests from last poll
    if (ar.userObj != mPollingContext)
        return;
    if (ar.exception != null) {
        CommandException.Error err = null;
        if (ar.exception instanceof CommandException) {
            err = ((CommandException) (ar.exception)).getCommandError();
        }
        if (err == CommandException.Error.RADIO_NOT_AVAILABLE) {
            // Radio has crashed or turned off
            cancelPollState();
            return;
        }
        if (err != CommandException.Error.OP_NOT_ALLOWED_BEFORE_REG_NW) {
            loge("RIL implementation has returned an error where it must succeed" + ar.exception);
        }
    } else
        try {
            handlePollStateResultMessage(what, ar);
        } catch (RuntimeException ex) {
            loge("Exception while polling service state. Probably malformed RIL response." + ex);
        }
    mPollingContext[0]--;
    if (mPollingContext[0] == 0) {
        if (mPhone.isPhoneTypeGsm()) {
            updateRoamingState();
            mNewSS.setEmergencyOnly(mEmergencyOnly);
        } else {
            boolean namMatch = false;
            if (!isSidsAllZeros() && isHomeSid(mNewSS.getSystemId())) {
                namMatch = true;
            }
            // Setting SS Roaming (general)
            if (mIsSubscriptionFromRuim) {
                boolean isRoamingBetweenOperators = isRoamingBetweenOperators(mNewSS.getVoiceRoaming(), mNewSS);
                if (isRoamingBetweenOperators != mNewSS.getVoiceRoaming()) {
                    log("isRoamingBetweenOperators=" + isRoamingBetweenOperators + ". Override CDMA voice roaming to " + isRoamingBetweenOperators);
                    mNewSS.setVoiceRoaming(isRoamingBetweenOperators);
                }
            }
            /**
             * For CDMA, voice and data should have the same roaming status.
             * If voice is not in service, use TSB58 roaming indicator to set
             * data roaming status. If TSB58 roaming indicator is not in the
             * carrier-specified list of ERIs for home system then set roaming.
             */
            final int dataRat = mNewSS.getRilDataRadioTechnology();
            if (ServiceState.isCdma(dataRat)) {
                final boolean isVoiceInService = (mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE);
                if (isVoiceInService) {
                    boolean isVoiceRoaming = mNewSS.getVoiceRoaming();
                    if (mNewSS.getDataRoaming() != isVoiceRoaming) {
                        log("Data roaming != Voice roaming. Override data roaming to " + isVoiceRoaming);
                        mNewSS.setDataRoaming(isVoiceRoaming);
                    }
                } else {
                    /**
                     * As per VoiceRegStateResult from radio types.hal the TSB58
                     * Roaming Indicator shall be sent if device is registered
                     * on a CDMA or EVDO system.
                     */
                    boolean isRoamIndForHomeSystem = isRoamIndForHomeSystem(Integer.toString(mRoamingIndicator));
                    if (mNewSS.getDataRoaming() == isRoamIndForHomeSystem) {
                        log("isRoamIndForHomeSystem=" + isRoamIndForHomeSystem + ", override data roaming to " + !isRoamIndForHomeSystem);
                        mNewSS.setDataRoaming(!isRoamIndForHomeSystem);
                    }
                }
            }
            // Setting SS CdmaRoamingIndicator and CdmaDefaultRoamingIndicator
            mNewSS.setCdmaDefaultRoamingIndicator(mDefaultRoamingIndicator);
            mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
            boolean isPrlLoaded = true;
            if (TextUtils.isEmpty(mPrlVersion)) {
                isPrlLoaded = false;
            }
            if (!isPrlLoaded || (mNewSS.getRilVoiceRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) {
                log("Turn off roaming indicator if !isPrlLoaded or voice RAT is unknown");
                mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
            } else if (!isSidsAllZeros()) {
                if (!namMatch && !mIsInPrl) {
                    // Use default
                    mNewSS.setCdmaRoamingIndicator(mDefaultRoamingIndicator);
                } else if (namMatch && !mIsInPrl) {
                    // TODO this will be removed when we handle roaming on LTE on CDMA+LTE phones
                    if (ServiceState.isLte(mNewSS.getRilVoiceRadioTechnology())) {
                        log("Turn off roaming indicator as voice is LTE");
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_FLASH);
                    }
                } else if (!namMatch && mIsInPrl) {
                    // Use the one from PRL/ERI
                    mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                } else {
                    // It means namMatch && mIsInPrl
                    if ((mRoamingIndicator <= 2)) {
                        mNewSS.setCdmaRoamingIndicator(EriInfo.ROAMING_INDICATOR_OFF);
                    } else {
                        // Use the one from PRL/ERI
                        mNewSS.setCdmaRoamingIndicator(mRoamingIndicator);
                    }
                }
            }
            int roamingIndicator = mNewSS.getCdmaRoamingIndicator();
            mNewSS.setCdmaEriIconIndex(mPhone.mEriManager.getCdmaEriIconIndex(roamingIndicator, mDefaultRoamingIndicator));
            mNewSS.setCdmaEriIconMode(mPhone.mEriManager.getCdmaEriIconMode(roamingIndicator, mDefaultRoamingIndicator));
            if (DBG) {
                log("Set CDMA Roaming Indicator to: " + mNewSS.getCdmaRoamingIndicator() + ". voiceRoaming = " + mNewSS.getVoiceRoaming() + ". dataRoaming = " + mNewSS.getDataRoaming() + ", isPrlLoaded = " + isPrlLoaded + ". namMatch = " + namMatch + " , mIsInPrl = " + mIsInPrl + ", mRoamingIndicator = " + mRoamingIndicator + ", mDefaultRoamingIndicator= " + mDefaultRoamingIndicator);
            }
        }
        pollStateDone();
    }
}
#end_block

#method_before
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    String[] states;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    states = (String[]) ar.result;
                    int lac = -1;
                    int cid = -1;
                    int type = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
                    int reasonRegStateDenied = -1;
                    int psc = -1;
                    int cssIndicator = 0;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            if (states.length >= 3) {
                                if (states[1] != null && states[1].length() > 0) {
                                    lac = (int) Long.parseLong(states[1], 16);
                                }
                                if (states[2] != null && states[2].length() > 0) {
                                    cid = (int) Long.parseLong(states[2], 16);
                                }
                                // states[3] (if present) is the current radio technology
                                if (states.length >= 4 && states[3] != null) {
                                    type = Integer.parseInt(states[3]);
                                }
                            }
                            if (states.length >= 8 && (states[7] != null)) {
                                cssIndicator = Integer.parseInt(states[7]);
                            }
                            if (states.length > 14) {
                                if (states[14] != null && states[14].length() > 0) {
                                    psc = (int) Long.parseLong(states[14], 16);
                                }
                            }
                        } catch (NumberFormatException ex) {
                            loge("error parsing RegistrationState: " + ex);
                        }
                    }
                    mGsmRoaming = regCodeIsRoaming(regState);
                    mNewSS.setVoiceRegState(regCodeToServiceState(regState));
                    mNewSS.setRilVoiceRadioTechnology(type);
                    mNewSS.setCssIndicator(cssIndicator);
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if ((regState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED || regState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                    // LAC and CID are -1 if not avail
                    ((GsmCellLocation) mNewCellLoc).setLacAndCid(lac, cid);
                    ((GsmCellLocation) mNewCellLoc).setPsc(psc);
                } else {
                    states = (String[]) ar.result;
                    // [0] registrationState
                    int registrationState = 4;
                    // [3] radioTechnology
                    int radioTechnology = -1;
                    // [4] baseStationId
                    int baseStationId = -1;
                    // [5] baseStationLatitude
                    int baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                    // [6] baseStationLongitude
                    int baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                    // [7] init with 0, because it is treated as a boolean
                    int cssIndicator = 0;
                    // [8] systemId
                    int systemId = 0;
                    // [9] networkId
                    int networkId = 0;
                    // [10] Roaming indicator
                    int roamingIndicator = -1;
                    // [11] Indicates if current system is in PRL
                    int systemIsInPrl = 0;
                    // [12] Is default roaming indicator from PRL
                    int defaultRoamingIndicator = 0;
                    // [13] Denial reason if registrationState = 3
                    int reasonForDenial = 0;
                    if (states.length >= 14) {
                        try {
                            if (states[0] != null) {
                                registrationState = Integer.parseInt(states[0]);
                            }
                            if (states[3] != null) {
                                radioTechnology = Integer.parseInt(states[3]);
                            }
                            if (states[4] != null) {
                                baseStationId = Integer.parseInt(states[4]);
                            }
                            if (states[5] != null) {
                                baseStationLatitude = Integer.parseInt(states[5]);
                            }
                            if (states[6] != null) {
                                baseStationLongitude = Integer.parseInt(states[6]);
                            }
                            // Some carriers only return lat-lngs of 0,0
                            if (baseStationLatitude == 0 && baseStationLongitude == 0) {
                                baseStationLatitude = CdmaCellLocation.INVALID_LAT_LONG;
                                baseStationLongitude = CdmaCellLocation.INVALID_LAT_LONG;
                            }
                            if (states[7] != null) {
                                cssIndicator = Integer.parseInt(states[7]);
                            }
                            if (states[8] != null) {
                                systemId = Integer.parseInt(states[8]);
                            }
                            if (states[9] != null) {
                                networkId = Integer.parseInt(states[9]);
                            }
                            if (states[10] != null) {
                                roamingIndicator = Integer.parseInt(states[10]);
                            }
                            if (states[11] != null) {
                                systemIsInPrl = Integer.parseInt(states[11]);
                            }
                            if (states[12] != null) {
                                defaultRoamingIndicator = Integer.parseInt(states[12]);
                            }
                            if (states[13] != null) {
                                reasonForDenial = Integer.parseInt(states[13]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("EVENT_POLL_STATE_REGISTRATION_CDMA: error parsing: " + ex);
                        }
                    } else {
                        throw new RuntimeException("Warning! Wrong number of parameters returned from " + "RIL_REQUEST_REGISTRATION_STATE: expected 14 or more " + "strings and got " + states.length + " strings");
                    }
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(states[10]);
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                    mNewSS.setRilVoiceRadioTechnology(radioTechnology);
                    mNewSS.setCssIndicator(cssIndicator);
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    // Values are -1 if not available.
                    ((CdmaCellLocation) mNewCellLoc).setCellLocationData(baseStationId, baseStationLatitude, baseStationLongitude, systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    states = (String[]) ar.result;
                    int type = 0;
                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
                    mNewReasonDataDenied = -1;
                    mNewMaxDataCalls = 1;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            // states[3] (if present) is the current radio technology
                            if (states.length >= 4 && states[3] != null) {
                                type = Integer.parseInt(states[3]);
                            }
                            if ((states.length >= 5) && (regState == ServiceState.RIL_REG_STATE_DENIED)) {
                                mNewReasonDataDenied = Integer.parseInt(states[4]);
                            }
                            if (states.length >= 6) {
                                mNewMaxDataCalls = Integer.parseInt(states[5]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("error parsing GprsRegistrationState: " + ex);
                        }
                    }
                    int dataRegState = regCodeToServiceState(regState);
                    mNewSS.setDataRegState(dataRegState);
                    mDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setRilDataRadioTechnology(type);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + type);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    states = (String[]) ar.result;
                    if (DBG) {
                        log("handlePollStateResultMessage: EVENT_POLL_STATE_GPRS states.length=" + states.length + " states=" + states);
                    }
                    int regState = ServiceState.RIL_REG_STATE_UNKNOWN;
                    int dataRadioTechnology = 0;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            // states[3] (if present) is the current radio technology
                            if (states.length >= 4 && states[3] != null) {
                                dataRadioTechnology = Integer.parseInt(states[3]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("handlePollStateResultMessage: error parsing GprsRegistrationState: " + ex);
                        }
                    }
                    int dataRegState = regCodeToServiceState(regState);
                    mNewSS.setDataRegState(dataRegState);
                    mNewSS.setRilDataRadioTechnology(dataRadioTechnology);
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + dataRadioTechnology);
                    }
                } else {
                    states = (String[]) ar.result;
                    if (DBG) {
                        log("handlePollStateResultMessage: EVENT_POLL_STATE_GPRS states.length=" + states.length + " states=" + states);
                    }
                    int newDataRAT = ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN;
                    int regState = -1;
                    if (states.length > 0) {
                        try {
                            regState = Integer.parseInt(states[0]);
                            // states[3] (if present) is the current radio technology
                            if (states.length >= 4 && states[3] != null) {
                                newDataRAT = Integer.parseInt(states[3]);
                            }
                        } catch (NumberFormatException ex) {
                            loge("handlePollStateResultMessage: error parsing GprsRegistrationState: " + ex);
                        }
                    }
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if ((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN && newDataRAT != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRAT)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRAT))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    mNewSS.setRilDataRadioTechnology(newDataRAT);
                    int dataRegState = regCodeToServiceState(regState);
                    mNewSS.setDataRegState(dataRegState);
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    mNewSS.setDataRoaming(regCodeIsRoaming(regState));
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRAT);
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#method_after
void handlePollStateResultMessage(int what, AsyncResult ar) {
    int[] ints;
    switch(what) {
        case EVENT_POLL_STATE_REGISTRATION:
            {
                VoiceRegStateResult voiceRegStateResult = (VoiceRegStateResult) ar.result;
                int registrationState = getRegStateFromHalRegState(voiceRegStateResult.regState);
                int cssIndicator = voiceRegStateResult.cssSupported ? 1 : 0;
                mNewSS.setVoiceRegState(regCodeToServiceState(registrationState));
                mNewSS.setCssIndicator(cssIndicator);
                mNewSS.setRilVoiceRadioTechnology(voiceRegStateResult.rat);
                // Denial reason if registrationState = 3
                int reasonForDenial = voiceRegStateResult.reasonForDenial;
                if (mPhone.isPhoneTypeGsm()) {
                    mGsmRoaming = regCodeIsRoaming(registrationState);
                    mNewRejectCode = reasonForDenial;
                    boolean isVoiceCapable = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_voice_capable);
                    if (((registrationState == ServiceState.RIL_REG_STATE_DENIED_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_NOT_REG_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_SEARCHING_EMERGENCY_CALL_ENABLED) || (registrationState == ServiceState.RIL_REG_STATE_UNKNOWN_EMERGENCY_CALL_ENABLED)) && isVoiceCapable) {
                        mEmergencyOnly = true;
                    } else {
                        mEmergencyOnly = false;
                    }
                } else {
                    int roamingIndicator = voiceRegStateResult.roamingIndicator;
                    // Indicates if current system is in PR
                    int systemIsInPrl = voiceRegStateResult.systemIsInPrl;
                    // Is default roaming indicator from PRL
                    int defaultRoamingIndicator = voiceRegStateResult.defaultRoamingIndicator;
                    mRegistrationState = registrationState;
                    // When registration state is roaming and TSB58
                    // roaming indicator is not in the carrier-specified
                    // list of ERIs for home system, mCdmaRoaming is true.
                    boolean cdmaRoaming = regCodeIsRoaming(registrationState) && !isRoamIndForHomeSystem(Integer.toString(roamingIndicator));
                    mNewSS.setVoiceRoaming(cdmaRoaming);
                    mRoamingIndicator = roamingIndicator;
                    mIsInPrl = (systemIsInPrl == 0) ? false : true;
                    mDefaultRoamingIndicator = defaultRoamingIndicator;
                    int systemId = 0;
                    int networkId = 0;
                    if (voiceRegStateResult.cellIdentity.cellInfoType == CellInfoType.CDMA && voiceRegStateResult.cellIdentity.cellIdentityCdma.size() == 1) {
                        android.hardware.radio.V1_0.CellIdentityCdma cellIdentityCdma = voiceRegStateResult.cellIdentity.cellIdentityCdma.get(0);
                        systemId = cellIdentityCdma.systemId;
                        networkId = cellIdentityCdma.networkId;
                    }
                    mNewSS.setSystemAndNetworkId(systemId, networkId);
                    if (reasonForDenial == 0) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_GEN;
                    } else if (reasonForDenial == 1) {
                        mRegistrationDeniedReason = ServiceStateTracker.REGISTRATION_DENIED_AUTH;
                    } else {
                        mRegistrationDeniedReason = "";
                    }
                    if (mRegistrationState == 3) {
                        if (DBG)
                            log("Registration denied, " + mRegistrationDeniedReason);
                    }
                }
                processCellLocationInfo(mNewCellLoc, voiceRegStateResult);
                if (DBG) {
                    log("handlPollVoiceRegResultMessage: regState=" + registrationState + " radioTechnology=" + voiceRegStateResult.rat);
                }
                break;
            }
        case EVENT_POLL_STATE_GPRS:
            {
                DataRegStateResult dataRegStateResult = (DataRegStateResult) ar.result;
                int regState = getRegStateFromHalRegState(dataRegStateResult.regState);
                int dataRegState = regCodeToServiceState(regState);
                int newDataRat = dataRegStateResult.rat;
                mNewSS.setDataRegState(dataRegState);
                mNewSS.setRilDataRadioTechnology(newDataRat);
                if (mPhone.isPhoneTypeGsm()) {
                    mNewReasonDataDenied = dataRegStateResult.reasonDataDenied;
                    mNewMaxDataCalls = dataRegStateResult.maxDataCalls;
                    mDataRoaming = regCodeIsRoaming(regState);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(mDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: GsmSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else if (mPhone.isPhoneTypeCdma()) {
                    boolean isDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: cdma setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                } else {
                    // If the unsolicited signal strength comes just before data RAT family changes
                    // (i.e. from UNKNOWN to LTE, CDMA to LTE, LTE to CDMA), the signal bar might
                    // display the wrong information until the next unsolicited signal strength
                    // information coming from the modem, which might take a long time to come or
                    // even not come at all.  In order to provide the best user experience, we
                    // query the latest signal information so it will show up on the UI on time.
                    int oldDataRAT = mSS.getRilDataRadioTechnology();
                    if (((oldDataRAT == ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN) && (newDataRat != ServiceState.RIL_RADIO_TECHNOLOGY_UNKNOWN)) || (ServiceState.isCdma(oldDataRAT) && ServiceState.isLte(newDataRat)) || (ServiceState.isLte(oldDataRAT) && ServiceState.isCdma(newDataRat))) {
                        mCi.getSignalStrength(obtainMessage(EVENT_GET_SIGNAL_STRENGTH));
                    }
                    // voice roaming state in done while handling EVENT_POLL_STATE_REGISTRATION_CDMA
                    boolean isDataRoaming = regCodeIsRoaming(regState);
                    mNewSS.setDataRoaming(isDataRoaming);
                    // Save the data roaming state reported by modem registration before resource
                    // overlay or carrier config possibly overrides it.
                    mNewSS.setDataRoamingFromRegistration(isDataRoaming);
                    if (DBG) {
                        log("handlPollStateResultMessage: CdmaLteSST setDataRegState=" + dataRegState + " regState=" + regState + " dataRadioTechnology=" + newDataRat);
                    }
                }
                updateServiceStateLteEarfcnBoost(mNewSS, getLteEarfcn(dataRegStateResult));
                break;
            }
        case EVENT_POLL_STATE_OPERATOR:
            {
                if (mPhone.isPhoneTypeGsm()) {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // FIXME: Giving brandOverride higher precedence, is this desired?
                        String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                        if (brandOverride != null) {
                            log("EVENT_POLL_STATE_OPERATOR: use brandOverride=" + brandOverride);
                            mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                        } else {
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        }
                    }
                } else {
                    String[] opNames = (String[]) ar.result;
                    if (opNames != null && opNames.length >= 3) {
                        // If the NUMERIC field isn't valid use PROPERTY_CDMA_HOME_OPERATOR_NUMERIC
                        if ((opNames[2] == null) || (opNames[2].length() < 5) || ("00000".equals(opNames[2]))) {
                            opNames[2] = SystemProperties.get(GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC, "00000");
                            if (DBG) {
                                log("RIL_REQUEST_OPERATOR.response[2], the numeric, " + " is bad. Using SystemProperties '" + GsmCdmaPhone.PROPERTY_CDMA_HOME_OPERATOR_NUMERIC + "'= " + opNames[2]);
                            }
                        }
                        if (!mIsSubscriptionFromRuim) {
                            // NV device (as opposed to CSIM)
                            mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                        } else {
                            String brandOverride = mUiccController.getUiccCard(getPhoneId()) != null ? mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() : null;
                            if (brandOverride != null) {
                                mNewSS.setOperatorName(brandOverride, brandOverride, opNames[2]);
                            } else {
                                mNewSS.setOperatorName(opNames[0], opNames[1], opNames[2]);
                            }
                        }
                    } else {
                        if (DBG)
                            log("EVENT_POLL_STATE_OPERATOR_CDMA: error parsing opNames");
                    }
                }
                break;
            }
        case EVENT_POLL_STATE_NETWORK_SELECTION_MODE:
            {
                ints = (int[]) ar.result;
                mNewSS.setIsManualSelection(ints[0] == 1);
                if ((ints[0] == 1) && (!mPhone.isManualNetSelAllowed())) {
                    /*
                         * modem is currently in manual selection but manual
                         * selection is not allowed in the current mode so
                         * switch to automatic registration
                         */
                    mPhone.setNetworkSelectionModeAutomatic(null);
                    log(" Forcing Automatic Network Selection, " + "manual selection is not allowed");
                }
                break;
            }
        default:
            loge("handlePollStateResultMessage: Unexpected RIL response received: " + what);
    }
}
#end_block

#method_before
private boolean isRoamIndForHomeSystem(String roamInd) {
    // retrieve the carrier-specified list of ERIs for home system
    String[] homeRoamIndicators = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.config_cdma_home_system);
    if (homeRoamIndicators != null) {
        // return true if one is found.
        for (String homeRoamInd : homeRoamIndicators) {
            if (homeRoamInd.equals(roamInd)) {
                return true;
            }
        }
        // no matches found against the list!
        return false;
    }
    // no system property found for the roaming indicators for home system
    return false;
}
#method_after
private boolean isRoamIndForHomeSystem(String roamInd) {
    // retrieve the carrier-specified list of ERIs for home system
    String[] homeRoamIndicators = Resources.getSystem().getStringArray(com.android.internal.R.array.config_cdma_home_system);
    log("isRoamIndForHomeSystem: homeRoamIndicators=" + Arrays.toString(homeRoamIndicators));
    if (homeRoamIndicators != null) {
        // return true if one is found.
        for (String homeRoamInd : homeRoamIndicators) {
            if (homeRoamInd.equals(roamInd)) {
                return true;
            }
        }
        // no matches found against the list!
        log("isRoamIndForHomeSystem: No match found against list for roamInd=" + roamInd);
        return false;
    }
    // no system property found for the roaming indicators for home system
    log("isRoamIndForHomeSystem: No list found");
    return false;
}
#end_block

#method_before
protected void updateRoamingState() {
    if (mPhone.isPhoneTypeGsm()) {
        /**
         * Since the roaming state of gsm service (from +CREG) and
         * data service (from +CGREG) could be different, the new SS
         * is set to roaming when either is true.
         *
         * There are exceptions for the above rule.
         * The new SS is not set as roaming while gsm service reports
         * roaming but indeed it is same operator.
         * And the operator is considered non roaming.
         *
         * The test for the operators is to handle special roaming
         * agreements and MVNO's.
         */
        boolean roaming = (mGsmRoaming || mDataRoaming);
        if (mGsmRoaming && !isOperatorConsideredRoaming(mNewSS) && (isSameNamedOperators(mNewSS) || isOperatorConsideredNonRoaming(mNewSS))) {
            roaming = false;
        }
        // Save the roaming state before carrier config possibly overrides it.
        mNewSS.setDataRoamingFromRegistration(roaming);
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    roaming = false;
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set non roaming:" + mNewSS.getOperatorNumeric());
                    roaming = false;
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric());
                    roaming = true;
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        mNewSS.setVoiceRoaming(roaming);
        mNewSS.setDataRoaming(roaming);
    } else {
        // Save the roaming state before carrier config possibly overrides it.
        mNewSS.setDataRoamingFromRegistration(mNewSS.getDataRoaming());
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                String systemId = Integer.toString(mNewSS.getSystemId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    setRoamingOff();
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isNonRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set non-roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOff();
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOn();
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
            mNewSS.setVoiceRoaming(true);
            mNewSS.setDataRoaming(true);
        }
    }
}
#method_after
protected void updateRoamingState() {
    if (mPhone.isPhoneTypeGsm()) {
        /**
         * Since the roaming state of gsm service (from +CREG) and
         * data service (from +CGREG) could be different, the new SS
         * is set to roaming when either is true.
         *
         * There are exceptions for the above rule.
         * The new SS is not set as roaming while gsm service reports
         * roaming but indeed it is same operator.
         * And the operator is considered non roaming.
         *
         * The test for the operators is to handle special roaming
         * agreements and MVNO's.
         */
        boolean roaming = (mGsmRoaming || mDataRoaming);
        if (mGsmRoaming && !isOperatorConsideredRoaming(mNewSS) && (isSameNamedOperators(mNewSS) || isOperatorConsideredNonRoaming(mNewSS))) {
            log("updateRoamingState: resource override set non roaming.isSameNamedOperators=" + isSameNamedOperators(mNewSS) + ",isOperatorConsideredNonRoaming=" + isOperatorConsideredNonRoaming(mNewSS));
            roaming = false;
        }
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    roaming = false;
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set non roaming:" + mNewSS.getOperatorNumeric());
                    roaming = false;
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric())) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric());
                    roaming = true;
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        mNewSS.setVoiceRoaming(roaming);
        mNewSS.setDataRoaming(roaming);
    } else {
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                String systemId = Integer.toString(mNewSS.getSystemId());
                if (alwaysOnHomeNetwork(b)) {
                    log("updateRoamingState: carrier config override always on home network");
                    setRoamingOff();
                } else if (isNonRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isNonRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set non-roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOff();
                } else if (isRoamingInGsmNetwork(b, mNewSS.getOperatorNumeric()) || isRoamingInCdmaNetwork(b, systemId)) {
                    log("updateRoamingState: carrier config override set roaming:" + mNewSS.getOperatorNumeric() + ", " + systemId);
                    setRoamingOn();
                }
            } catch (Exception e) {
                loge("updateRoamingState: unable to access carrier config service");
            }
        } else {
            log("updateRoamingState: no carrier config service available");
        }
        if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
            mNewSS.setVoiceRoaming(true);
            mNewSS.setDataRoaming(true);
        }
    }
}
#end_block

#method_before
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
        // In Wi-Fi Calling mode show SPN+WiFi
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (mSS.getVoiceRegState() == ServiceState.STATE_OUT_OF_SERVICE || mSS.getVoiceRegState() == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            if (mEmergencyOnly) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlphaLong contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#method_after
protected void updateSpnDisplay() {
    updateOperatorNameFromEri();
    String wfcVoiceSpnFormat = null;
    String wfcDataSpnFormat = null;
    if (mPhone.getImsPhone() != null && mPhone.getImsPhone().isWifiCallingEnabled()) {
        // In Wi-Fi Calling mode show SPN+WiFi
        String[] wfcSpnFormats = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.wfcSpnFormats);
        int voiceIdx = 0;
        int dataIdx = 0;
        CarrierConfigManager configLoader = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
        if (configLoader != null) {
            try {
                PersistableBundle b = configLoader.getConfigForSubId(mPhone.getSubId());
                if (b != null) {
                    voiceIdx = b.getInt(CarrierConfigManager.KEY_WFC_SPN_FORMAT_IDX_INT);
                    dataIdx = b.getInt(CarrierConfigManager.KEY_WFC_DATA_SPN_FORMAT_IDX_INT);
                }
            } catch (Exception e) {
                loge("updateSpnDisplay: carrier config error: " + e);
            }
        }
        wfcVoiceSpnFormat = wfcSpnFormats[voiceIdx];
        wfcDataSpnFormat = wfcSpnFormats[dataIdx];
    }
    int combinedRegState = getCombinedRegState();
    if (mPhone.isPhoneTypeGsm()) {
        // The values of plmn/showPlmn change in different scenarios.
        // 1) No service but emergency call allowed -> expected
        // to show "Emergency call only"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "Emergency call only"
        // 2) No service at all --> expected to show "No service"
        // EXTRA_SHOW_PLMN = true
        // EXTRA_PLMN = "No service"
        // 3) Normal operation in either home or roaming service
        // EXTRA_SHOW_PLMN = depending on IccRecords rule
        // EXTRA_PLMN = plmn
        // 4) No service due to power off, aka airplane mode
        // EXTRA_SHOW_PLMN = false
        // EXTRA_PLMN = null
        IccRecords iccRecords = mIccRecords;
        String plmn = null;
        boolean showPlmn = false;
        int rule = (iccRecords != null) ? iccRecords.getDisplayRule(mSS.getOperatorNumeric()) : 0;
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE || combinedRegState == ServiceState.STATE_EMERGENCY_ONLY) {
            showPlmn = true;
            if (mEmergencyOnly) {
                // No service but emergency call allowed
                plmn = Resources.getSystem().getText(com.android.internal.R.string.emergency_calls_only).toString();
            } else {
                // No service at all
                plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            }
            if (DBG)
                log("updateSpnDisplay: radio is on but out " + "of service, set plmn='" + plmn + "'");
        } else if (combinedRegState == ServiceState.STATE_IN_SERVICE) {
            // In either home or roaming service
            plmn = mSS.getOperatorAlpha();
            showPlmn = !TextUtils.isEmpty(plmn) && ((rule & SIMRecords.SPN_RULE_SHOW_PLMN) == SIMRecords.SPN_RULE_SHOW_PLMN);
        } else {
            // Power off state, such as airplane mode, show plmn as "No service"
            showPlmn = true;
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG)
                log("updateSpnDisplay: radio is off w/ showPlmn=" + showPlmn + " plmn=" + plmn);
        }
        // The value of spn/showSpn are same in different scenarios.
        // EXTRA_SHOW_SPN = depending on IccRecords rule and radio/IMS state
        // EXTRA_SPN = spn
        // EXTRA_DATA_SPN = dataSpn
        String spn = (iccRecords != null) ? iccRecords.getServiceProviderName() : "";
        String dataSpn = spn;
        boolean showSpn = !TextUtils.isEmpty(spn) && ((rule & SIMRecords.SPN_RULE_SHOW_SPN) == SIMRecords.SPN_RULE_SHOW_SPN);
        if (!TextUtils.isEmpty(spn) && !TextUtils.isEmpty(wfcVoiceSpnFormat) && !TextUtils.isEmpty(wfcDataSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalSpn = spn.trim();
            spn = String.format(wfcVoiceSpnFormat, originalSpn);
            dataSpn = String.format(wfcDataSpnFormat, originalSpn);
            showSpn = true;
            showPlmn = false;
        } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF || (showPlmn && TextUtils.equals(spn, plmn))) {
            // airplane mode or spn equals plmn, do not show spn
            spn = null;
            showSpn = false;
        }
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        // Update SPN_STRINGS_UPDATED_ACTION IFF any value changes
        if (mSubId != subId || showPlmn != mCurShowPlmn || showSpn != mCurShowSpn || !TextUtils.equals(spn, mCurSpn) || !TextUtils.equals(dataSpn, mCurDataSpn) || !TextUtils.equals(plmn, mCurPlmn)) {
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent rule=" + rule + " showPlmn='%b' plmn='%s' showSpn='%b' spn='%s' dataSpn='%s' " + "subId='%d'", showPlmn, plmn, showSpn, spn, dataSpn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, showSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, spn);
            intent.putExtra(TelephonyIntents.EXTRA_DATA_SPN, dataSpn);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, showSpn, spn)) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = showSpn;
        mCurShowPlmn = showPlmn;
        mCurSpn = spn;
        mCurDataSpn = dataSpn;
        mCurPlmn = plmn;
    } else {
        // mOperatorAlphaLong contains the ERI text
        String plmn = mSS.getOperatorAlpha();
        boolean showPlmn = false;
        showPlmn = plmn != null;
        int subId = SubscriptionManager.INVALID_SUBSCRIPTION_ID;
        int[] subIds = SubscriptionManager.getSubId(mPhone.getPhoneId());
        if (subIds != null && subIds.length > 0) {
            subId = subIds[0];
        }
        if (!TextUtils.isEmpty(plmn) && !TextUtils.isEmpty(wfcVoiceSpnFormat)) {
            // In Wi-Fi Calling mode show SPN+WiFi
            String originalPlmn = plmn.trim();
            plmn = String.format(wfcVoiceSpnFormat, originalPlmn);
        } else if (mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
            // todo: temporary hack; should have a better fix. This is to avoid using operator
            // name from ServiceState (populated in resetServiceStateInIwlanMode()) until
            // wifi calling is actually enabled
            log("updateSpnDisplay: overwriting plmn from " + plmn + " to null as radio " + "state is off");
            plmn = null;
        }
        if (combinedRegState == ServiceState.STATE_OUT_OF_SERVICE) {
            plmn = Resources.getSystem().getText(com.android.internal.R.string.lockscreen_carrier_default).toString();
            if (DBG) {
                log("updateSpnDisplay: radio is on but out of svc, set plmn='" + plmn + "'");
            }
        }
        if (mSubId != subId || !TextUtils.equals(plmn, mCurPlmn)) {
            // "No Service". Now showPlmn is set to true for any non null string.
            if (DBG) {
                log(String.format("updateSpnDisplay: changed sending intent" + " showPlmn='%b' plmn='%s' subId='%d'", showPlmn, plmn, subId));
            }
            Intent intent = new Intent(TelephonyIntents.SPN_STRINGS_UPDATED_ACTION);
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_SPN, false);
            intent.putExtra(TelephonyIntents.EXTRA_SPN, "");
            intent.putExtra(TelephonyIntents.EXTRA_SHOW_PLMN, showPlmn);
            intent.putExtra(TelephonyIntents.EXTRA_PLMN, plmn);
            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mPhone.getPhoneId());
            mPhone.getContext().sendStickyBroadcastAsUser(intent, UserHandle.ALL);
            if (!mSubscriptionController.setPlmnSpn(mPhone.getPhoneId(), showPlmn, plmn, false, "")) {
                mSpnUpdatePending = true;
            }
        }
        mSubId = subId;
        mCurShowSpn = false;
        mCurShowPlmn = showPlmn;
        mCurSpn = "";
        mCurPlmn = plmn;
    }
}
#end_block

#method_before
protected void setPowerStateToDesired() {
    if (DBG) {
        log("mDeviceShuttingDown=" + mDeviceShuttingDown + ", mDesiredPowerState=" + mDesiredPowerState + ", getRadioState=" + mCi.getRadioState() + ", mPowerOffDelayNeed=" + mPowerOffDelayNeed + ", mAlarmSwitch=" + mAlarmSwitch + ", mRadioDisabledByCarrier=" + mRadioDisabledByCarrier);
    }
    if (mPhone.isPhoneTypeGsm() && mAlarmSwitch) {
        if (DBG)
            log("mAlarmSwitch == true");
        Context context = mPhone.getContext();
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        am.cancel(mRadioOffIntent);
        mAlarmSwitch = false;
    }
    // If we want it on and it's off, turn it on
    if (mDesiredPowerState && !mRadioDisabledByCarrier && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
        mCi.setRadioPower(true, null);
    } else if ((!mDesiredPowerState || mRadioDisabledByCarrier) && mCi.getRadioState().isOn()) {
        // If it's on and available and we want it off gracefully
        if (mPhone.isPhoneTypeGsm() && mPowerOffDelayNeed) {
            if (mImsRegistrationOnOff && !mAlarmSwitch) {
                if (DBG)
                    log("mImsRegistrationOnOff == true");
                Context context = mPhone.getContext();
                AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
                Intent intent = new Intent(ACTION_RADIO_OFF);
                mRadioOffIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
                mAlarmSwitch = true;
                if (DBG)
                    log("Alarm setting");
                am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 3000, mRadioOffIntent);
            } else {
                DcTracker dcTracker = mPhone.mDcTracker;
                powerOffRadioSafely(dcTracker);
            }
        } else {
            DcTracker dcTracker = mPhone.mDcTracker;
            powerOffRadioSafely(dcTracker);
        }
    } else if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
        mCi.requestShutdown(null);
    }
}
#method_after
protected void setPowerStateToDesired() {
    if (DBG) {
        String tmpLog = "mDeviceShuttingDown=" + mDeviceShuttingDown + ", mDesiredPowerState=" + mDesiredPowerState + ", getRadioState=" + mCi.getRadioState() + ", mPowerOffDelayNeed=" + mPowerOffDelayNeed + ", mAlarmSwitch=" + mAlarmSwitch + ", mRadioDisabledByCarrier=" + mRadioDisabledByCarrier;
        log(tmpLog);
        mRadioPowerLog.log(tmpLog);
    }
    if (mPhone.isPhoneTypeGsm() && mAlarmSwitch) {
        if (DBG)
            log("mAlarmSwitch == true");
        Context context = mPhone.getContext();
        AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        am.cancel(mRadioOffIntent);
        mAlarmSwitch = false;
    }
    // If we want it on and it's off, turn it on
    if (mDesiredPowerState && !mRadioDisabledByCarrier && mCi.getRadioState() == CommandsInterface.RadioState.RADIO_OFF) {
        mCi.setRadioPower(true, null);
    } else if ((!mDesiredPowerState || mRadioDisabledByCarrier) && mCi.getRadioState().isOn()) {
        // If it's on and available and we want it off gracefully
        if (mPhone.isPhoneTypeGsm() && mPowerOffDelayNeed) {
            if (mImsRegistrationOnOff && !mAlarmSwitch) {
                if (DBG)
                    log("mImsRegistrationOnOff == true");
                Context context = mPhone.getContext();
                AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
                Intent intent = new Intent(ACTION_RADIO_OFF);
                mRadioOffIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
                mAlarmSwitch = true;
                if (DBG)
                    log("Alarm setting");
                am.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 3000, mRadioOffIntent);
            } else {
                DcTracker dcTracker = mPhone.mDcTracker;
                powerOffRadioSafely(dcTracker);
            }
        } else {
            DcTracker dcTracker = mPhone.mDcTracker;
            powerOffRadioSafely(dcTracker);
        }
    } else if (mDeviceShuttingDown && mCi.getRadioState().isAvailable()) {
        mCi.requestShutdown(null);
    }
}
#end_block

#method_before
public boolean isConcurrentVoiceAndDataAllowed() {
    if (mSS.getCssIndicator() == 1) {
        // Using the Conncurrent Service Supported flag for GSM and CdmaLte devices.
        return true;
    } else if (mPhone.isPhoneTypeGsm()) {
        return (mSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
    } else {
        // For the time-being, the return value will be false.
        return false;
    }
}
#method_after
public boolean isConcurrentVoiceAndDataAllowed() {
    if (mSS.getCssIndicator() == 1) {
        // Checking the Concurrent Service Supported flag first for all phone types.
        return true;
    } else if (mPhone.isPhoneTypeGsm()) {
        return (mSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_UMTS);
    } else {
        return false;
    }
}
#end_block

#method_before
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            // or we're on IWLAN
            if (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology()) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#method_after
public void pollState(boolean modemTriggered) {
    mPollingContext = new int[1];
    mPollingContext[0] = 0;
    log("pollState: modemTriggered=" + modemTriggered);
    switch(mCi.getRadioState()) {
        case RADIO_UNAVAILABLE:
            mNewSS.setStateOutOfService();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            pollStateDone();
            break;
        case RADIO_OFF:
            mNewSS.setStateOff();
            mNewCellLoc.setStateInvalid();
            setSignalStrengthDefaultValues();
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
            // (they sent us new radio data) and current network is not IWLAN
            if (mDeviceShuttingDown || (!modemTriggered && ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN != mSS.getRilDataRadioTechnology())) {
                pollStateDone();
                break;
            }
        default:
            // Issue all poll-related commands at once then count down the responses, which
            // are allowed to arrive out-of-order
            mPollingContext[0]++;
            mCi.getOperator(obtainMessage(EVENT_POLL_STATE_OPERATOR, mPollingContext));
            mPollingContext[0]++;
            mCi.getDataRegistrationState(obtainMessage(EVENT_POLL_STATE_GPRS, mPollingContext));
            mPollingContext[0]++;
            mCi.getVoiceRegistrationState(obtainMessage(EVENT_POLL_STATE_REGISTRATION, mPollingContext));
            if (mPhone.isPhoneTypeGsm()) {
                mPollingContext[0]++;
                mCi.getNetworkSelectionMode(obtainMessage(EVENT_POLL_STATE_NETWORK_SELECTION_MODE, mPollingContext));
            }
            break;
    }
}
#end_block

#method_before
private void pollStateDone() {
    if (mPhone.isPhoneTypeGsm()) {
        pollStateDoneGsm();
    } else if (mPhone.isPhoneTypeCdma()) {
        pollStateDoneCdma();
    } else {
        pollStateDoneCdmaLte();
    }
}
#method_after
private void pollStateDone() {
    if (!mPhone.isPhoneTypeGsm()) {
        updateRoamingState();
    }
    if (Build.IS_DEBUGGABLE && SystemProperties.getBoolean(PROP_FORCE_ROAMING, false)) {
        mNewSS.setVoiceRoaming(true);
        mNewSS.setDataRoaming(true);
    }
    useDataRegStateForDataOnlyDevices();
    resetServiceStateInIwlanMode();
    if (DBG) {
        log("Poll ServiceState done: " + " oldSS=[" + mSS + "] newSS=[" + mNewSS + "]" + " oldMaxDataCalls=" + mMaxDataCalls + " mNewMaxDataCalls=" + mNewMaxDataCalls + " oldReasonDataDenied=" + mReasonDataDenied + " mNewReasonDataDenied=" + mNewReasonDataDenied);
    }
    boolean hasRegistered = mSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDeregistered = mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getVoiceRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataAttached = mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE;
    boolean hasDataDetached = mSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && mNewSS.getDataRegState() != ServiceState.STATE_IN_SERVICE;
    boolean hasDataRegStateChanged = mSS.getDataRegState() != mNewSS.getDataRegState();
    boolean hasVoiceRegStateChanged = mSS.getVoiceRegState() != mNewSS.getVoiceRegState();
    boolean hasLocationChanged = !mNewCellLoc.equals(mCellLoc);
    // until cell change
    if (!hasLocationChanged) {
        mRatRatcheter.ratchetRat(mSS, mNewSS);
    }
    boolean hasRilVoiceRadioTechnologyChanged = mSS.getRilVoiceRadioTechnology() != mNewSS.getRilVoiceRadioTechnology();
    boolean hasRilDataRadioTechnologyChanged = mSS.getRilDataRadioTechnology() != mNewSS.getRilDataRadioTechnology();
    boolean hasChanged = !mNewSS.equals(mSS);
    boolean hasVoiceRoamingOn = !mSS.getVoiceRoaming() && mNewSS.getVoiceRoaming();
    boolean hasVoiceRoamingOff = mSS.getVoiceRoaming() && !mNewSS.getVoiceRoaming();
    boolean hasDataRoamingOn = !mSS.getDataRoaming() && mNewSS.getDataRoaming();
    boolean hasDataRoamingOff = mSS.getDataRoaming() && !mNewSS.getDataRoaming();
    boolean hasRejectCauseChanged = mRejectCode != mNewRejectCode;
    boolean hasCssIndicatorChanged = (mSS.getCssIndicator() != mNewSS.getCssIndicator());
    boolean has4gHandoff = false;
    boolean hasMultiApnSupport = false;
    boolean hasLostMultiApnSupport = false;
    if (mPhone.isPhoneTypeCdmaLte()) {
        has4gHandoff = mNewSS.getDataRegState() == ServiceState.STATE_IN_SERVICE && ((ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) || ((mSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD) && ServiceState.isLte(mNewSS.getRilDataRadioTechnology())));
        hasMultiApnSupport = ((ServiceState.isLte(mNewSS.getRilDataRadioTechnology()) || (mNewSS.getRilDataRadioTechnology() == ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)) && (!ServiceState.isLte(mSS.getRilDataRadioTechnology()) && (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_EHRPD)));
        hasLostMultiApnSupport = ((mNewSS.getRilDataRadioTechnology() >= ServiceState.RIL_RADIO_TECHNOLOGY_IS95A) && (mNewSS.getRilDataRadioTechnology() <= ServiceState.RIL_RADIO_TECHNOLOGY_EVDO_A));
    }
    if (DBG) {
        log("pollStateDone:" + " hasRegistered=" + hasRegistered + " hasDeregistered=" + hasDeregistered + " hasDataAttached=" + hasDataAttached + " hasDataDetached=" + hasDataDetached + " hasDataRegStateChanged=" + hasDataRegStateChanged + " hasRilVoiceRadioTechnologyChanged= " + hasRilVoiceRadioTechnologyChanged + " hasRilDataRadioTechnologyChanged=" + hasRilDataRadioTechnologyChanged + " hasChanged=" + hasChanged + " hasVoiceRoamingOn=" + hasVoiceRoamingOn + " hasVoiceRoamingOff=" + hasVoiceRoamingOff + " hasDataRoamingOn=" + hasDataRoamingOn + " hasDataRoamingOff=" + hasDataRoamingOff + " hasLocationChanged=" + hasLocationChanged + " has4gHandoff = " + has4gHandoff + " hasMultiApnSupport=" + hasMultiApnSupport + " hasLostMultiApnSupport=" + hasLostMultiApnSupport + " hasCssIndicatorChanged=" + hasCssIndicatorChanged);
    }
    // Add an event log when connection state changes
    if (hasVoiceRegStateChanged || hasDataRegStateChanged) {
        EventLog.writeEvent(mPhone.isPhoneTypeGsm() ? EventLogTags.GSM_SERVICE_STATE_CHANGE : EventLogTags.CDMA_SERVICE_STATE_CHANGE, mSS.getVoiceRegState(), mSS.getDataRegState(), mNewSS.getVoiceRegState(), mNewSS.getDataRegState());
    }
    if (mPhone.isPhoneTypeGsm()) {
        // i.e. check preferred network setting, only switch to 2G, etc
        if (hasRilVoiceRadioTechnologyChanged) {
            int cid = -1;
            GsmCellLocation loc = (GsmCellLocation) mNewCellLoc;
            if (loc != null)
                cid = loc.getCid();
            // NOTE: this code was previously located after mSS and mNewSS are swapped, so
            // existing logs were incorrectly using the new state for "network_from"
            // and STATE_OUT_OF_SERVICE for "network_to". To avoid confusion, use a new log tag
            // to record the correct states.
            EventLog.writeEvent(EventLogTags.GSM_RAT_SWITCHED_NEW, cid, mSS.getRilVoiceRadioTechnology(), mNewSS.getRilVoiceRadioTechnology());
            if (DBG) {
                log("RAT switched " + ServiceState.rilRadioTechnologyToString(mSS.getRilVoiceRadioTechnology()) + " -> " + ServiceState.rilRadioTechnologyToString(mNewSS.getRilVoiceRadioTechnology()) + " at cell " + cid);
            }
        }
        if (hasCssIndicatorChanged) {
            mPhone.notifyDataConnection(Phone.REASON_CSS_INDICATOR_CHANGED);
        }
        mReasonDataDenied = mNewReasonDataDenied;
        mMaxDataCalls = mNewMaxDataCalls;
        mRejectCode = mNewRejectCode;
    }
    // swap mSS and mNewSS to put new state in mSS
    ServiceState tss = mSS;
    mSS = mNewSS;
    mNewSS = tss;
    // clean slate for next time
    mNewSS.setStateOutOfService();
    // swap mCellLoc and mNewCellLoc to put new state in mCellLoc
    CellLocation tcl = mCellLoc;
    mCellLoc = mNewCellLoc;
    mNewCellLoc = tcl;
    if (hasRilVoiceRadioTechnologyChanged) {
        updatePhoneObject();
    }
    TelephonyManager tm = (TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE);
    if (hasRilDataRadioTechnologyChanged) {
        tm.setDataNetworkTypeForPhone(mPhone.getPhoneId(), mSS.getRilDataRadioTechnology());
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            log("pollStateDone: IWLAN enabled");
        }
    }
    if (hasRegistered) {
        mNetworkAttachedRegistrants.notifyRegistrants();
        if (DBG) {
            log("pollStateDone: registering current mNitzUpdatedTime=" + mNitzUpdatedTime + " changing to false");
        }
        mNitzUpdatedTime = false;
    }
    if (hasDeregistered) {
        mNetworkDetachedRegistrants.notifyRegistrants();
    }
    if (hasRejectCauseChanged) {
        setNotification(mRejectCode == 0 ? CS_REJECT_CAUSE_DISABLED : CS_REJECT_CAUSE_ENABLED);
    }
    if (hasChanged) {
        updateSpnDisplay();
        tm.setNetworkOperatorNameForPhone(mPhone.getPhoneId(), mSS.getOperatorAlpha());
        String prevOperatorNumeric = tm.getNetworkOperatorForPhone(mPhone.getPhoneId());
        String operatorNumeric = mSS.getOperatorNumeric();
        if (!mPhone.isPhoneTypeGsm()) {
            // try to fix the invalid Operator Numeric
            if (isInvalidOperatorNumeric(operatorNumeric)) {
                int sid = mSS.getSystemId();
                operatorNumeric = fixUnknownMcc(operatorNumeric, sid);
            }
        }
        tm.setNetworkOperatorNumericForPhone(mPhone.getPhoneId(), operatorNumeric);
        updateCarrierMccMncConfiguration(operatorNumeric, prevOperatorNumeric, mPhone.getContext());
        if (isInvalidOperatorNumeric(operatorNumeric)) {
            if (DBG)
                log("operatorNumeric " + operatorNumeric + " is invalid");
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), "");
            mGotCountryCode = false;
            mNitzUpdatedTime = false;
        } else if (mSS.getRilDataRadioTechnology() != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN) {
            // Update time zone, ISO, and IDD.
            // 
            // If the device is on IWLAN, modems manufacture a ServiceState with the MCC/MNC of
            // the SIM as if we were talking to towers. Telephony code then uses that with
            // mccTable to suggest a timezone. We shouldn't do that if the MCC/MNC is from IWLAN
            String iso = "";
            String mcc = "";
            try {
                mcc = operatorNumeric.substring(0, 3);
                iso = MccTable.countryCodeForMcc(Integer.parseInt(mcc));
            } catch (NumberFormatException | StringIndexOutOfBoundsException ex) {
                loge("pollStateDone: countryCodeForMcc error: " + ex);
            }
            tm.setNetworkCountryIsoForPhone(mPhone.getPhoneId(), iso);
            mGotCountryCode = true;
            if (!mNitzUpdatedTime && !mcc.equals("000") && !TextUtils.isEmpty(iso) && getAutoTimeZone()) {
                // Test both paths if ignore nitz is true
                boolean testOneUniqueOffsetPath = SystemProperties.getBoolean(TelephonyProperties.PROPERTY_IGNORE_NITZ, false) && ((SystemClock.uptimeMillis() & 1) == 0);
                List<String> uniqueZoneIds = TimeUtils.getTimeZoneIdsWithUniqueOffsets(iso);
                if ((uniqueZoneIds.size() == 1) || testOneUniqueOffsetPath) {
                    String zoneId = uniqueZoneIds.get(0);
                    if (DBG) {
                        log("pollStateDone: no nitz but one TZ for iso-cc=" + iso + " with zone.getID=" + zoneId + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath);
                    }
                    mTimeZoneLog.log("pollStateDone: set time zone=" + zoneId + " mcc=" + mcc + " iso=" + iso);
                    setAndBroadcastNetworkSetTimeZone(zoneId);
                } else {
                    if (DBG) {
                        log("pollStateDone: there are " + uniqueZoneIds.size() + " unique offsets for iso-cc='" + iso + " testOneUniqueOffsetPath=" + testOneUniqueOffsetPath + "', do nothing");
                    }
                }
            }
            if (!mPhone.isPhoneTypeGsm()) {
                setOperatorIdd(operatorNumeric);
            }
            if (shouldFixTimeZoneNow(mPhone, operatorNumeric, prevOperatorNumeric, mNeedFixZoneAfterNitz)) {
                fixTimeZone(iso);
            }
        }
        tm.setNetworkRoamingForPhone(mPhone.getPhoneId(), mPhone.isPhoneTypeGsm() ? mSS.getVoiceRoaming() : (mSS.getVoiceRoaming() || mSS.getDataRoaming()));
        setRoamingType(mSS);
        log("Broadcasting ServiceState : " + mSS);
        // notify using PhoneStateListener and the legacy intent ACTION_SERVICE_STATE_CHANGED
        mPhone.notifyServiceStateChanged(mSS);
        // insert into ServiceStateProvider. This will trigger apps to wake through JobScheduler
        mPhone.getContext().getContentResolver().insert(getUriForSubscriptionId(mPhone.getSubId()), getContentValuesForServiceState(mSS));
        TelephonyMetrics.getInstance().writeServiceStateChanged(mPhone.getPhoneId(), mSS);
    }
    if (hasDataAttached || has4gHandoff || hasDataDetached || hasRegistered || hasDeregistered) {
        logAttachChange();
    }
    if (hasDataAttached || has4gHandoff) {
        mAttachedRegistrants.notifyRegistrants();
    }
    if (hasDataDetached) {
        mDetachedRegistrants.notifyRegistrants();
    }
    if (hasRilDataRadioTechnologyChanged || hasRilVoiceRadioTechnologyChanged) {
        logRatChange();
    }
    if (hasDataRegStateChanged || hasRilDataRadioTechnologyChanged) {
        notifyDataRegStateRilRadioTechnologyChanged();
        if (ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN == mSS.getRilDataRadioTechnology()) {
            mPhone.notifyDataConnection(Phone.REASON_IWLAN_AVAILABLE);
        } else {
            mPhone.notifyDataConnection(null);
        }
    }
    if (hasVoiceRoamingOn || hasVoiceRoamingOff || hasDataRoamingOn || hasDataRoamingOff) {
        logRoamingChange();
    }
    if (hasVoiceRoamingOn) {
        mVoiceRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasVoiceRoamingOff) {
        mVoiceRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOn) {
        mDataRoamingOnRegistrants.notifyRegistrants();
    }
    if (hasDataRoamingOff) {
        mDataRoamingOffRegistrants.notifyRegistrants();
    }
    if (hasLocationChanged) {
        mPhone.notifyLocationChanged();
    }
    if (mPhone.isPhoneTypeGsm()) {
        if (!isGprsConsistent(mSS.getDataRegState(), mSS.getVoiceRegState())) {
            if (!mStartedGprsRegCheck && !mReportedGprsNoReg) {
                mStartedGprsRegCheck = true;
                int check_period = Settings.Global.getInt(mPhone.getContext().getContentResolver(), Settings.Global.GPRS_REGISTER_CHECK_PERIOD_MS, DEFAULT_GPRS_CHECK_PERIOD_MILLIS);
                sendMessageDelayed(obtainMessage(EVENT_CHECK_REPORT_GPRS), check_period);
            }
        } else {
            mReportedGprsNoReg = false;
        }
    }
}
#end_block

#method_before
private void updateOperatorNameFromEri() {
    if (mPhone.isPhoneTypeCdma()) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
    } else if (mPhone.isPhoneTypeCdmaLte()) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name))) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlpha();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
    }
}
#method_after
private void updateOperatorNameFromEri() {
    if (mPhone.isPhoneTypeCdma()) {
        if ((mCi.getRadioState().isOn()) && (!mIsSubscriptionFromRuim)) {
            String eriText;
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used for
                // mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
    } else if (mPhone.isPhoneTypeCdmaLte()) {
        boolean hasBrandOverride = mUiccController.getUiccCard(getPhoneId()) != null && mUiccController.getUiccCard(getPhoneId()).getOperatorBrandOverride() != null;
        if (!hasBrandOverride && (mCi.getRadioState().isOn()) && (mPhone.isEriFileLoaded()) && (!ServiceState.isLte(mSS.getRilVoiceRadioTechnology()) || mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_LTE_eri_for_network_name))) {
            // Only when CDMA is in service, ERI will take effect
            String eriText = mSS.getOperatorAlpha();
            // Now the Phone sees the new ServiceState so it can get the new ERI text
            if (mSS.getVoiceRegState() == ServiceState.STATE_IN_SERVICE) {
                eriText = mPhone.getCdmaEriText();
            } else if (mSS.getVoiceRegState() == ServiceState.STATE_POWER_OFF) {
                eriText = (mIccRecords != null) ? mIccRecords.getServiceProviderName() : null;
                if (TextUtils.isEmpty(eriText)) {
                    // Sets operator alpha property by retrieving from
                    // build-time system property
                    eriText = SystemProperties.get("ro.cdma.home.operator.alpha");
                }
            } else if (mSS.getDataRegState() != ServiceState.STATE_IN_SERVICE) {
                // Note that ServiceState.STATE_OUT_OF_SERVICE is valid used
                // for mRegistrationState 0,2,3 and 4
                eriText = mPhone.getContext().getText(com.android.internal.R.string.roamingTextSearching).toString();
            }
            mSS.setOperatorAlphaLong(eriText);
        }
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY && mIccRecords != null && getCombinedRegState() == ServiceState.STATE_IN_SERVICE && !ServiceState.isLte(mSS.getRilVoiceRadioTechnology())) {
            // SIM is found on the device. If ERI roaming is OFF, and SID/NID matches
            // one configured in SIM, use operator name from CSIM record. Note that ERI, SID,
            // and NID are CDMA only, not applicable to LTE.
            boolean showSpn = ((RuimRecords) mIccRecords).getCsimSpnDisplayCondition();
            int iconIndex = mSS.getCdmaEriIconIndex();
            if (showSpn && (iconIndex == EriInfo.ROAMING_INDICATOR_OFF) && isInHomeSidNid(mSS.getSystemId(), mSS.getNetworkId()) && mIccRecords != null) {
                mSS.setOperatorAlphaLong(mIccRecords.getServiceProviderName());
            }
        }
    }
}
#end_block

#method_before
protected void fixTimeZone(String isoCountryCode) {
    TimeZone zone = null;
    // If the offset is (0, false) and the time zone property
    // is set, use the time zone property rather than GMT.
    String zoneName = SystemProperties.get(TIMEZONE_PROPERTY);
    if (DBG) {
        log("fixTimeZone zoneName='" + zoneName + "' mZoneOffset=" + mZoneOffset + " mZoneDst=" + mZoneDst + " iso-cc='" + isoCountryCode + "' iso-cc-idx=" + Arrays.binarySearch(GMT_COUNTRY_CODES, isoCountryCode));
    }
    if ("".equals(isoCountryCode) && mNeedFixZoneAfterNitz) {
        // Country code not found.  This is likely a test network.
        // Get a TimeZone based only on the NITZ parameters (best guess).
        zone = getNitzTimeZone(mZoneOffset, mZoneDst, mZoneTime);
        if (DBG)
            log("pollStateDone: using NITZ TimeZone");
    } else if ((mZoneOffset == 0) && (mZoneDst == false) && (zoneName != null) && (zoneName.length() > 0) && (Arrays.binarySearch(GMT_COUNTRY_CODES, isoCountryCode) < 0)) {
        // For NITZ string without time zone,
        // need adjust time to reflect default time zone setting
        zone = TimeZone.getDefault();
        if (mNeedFixZoneAfterNitz) {
            long ctm = System.currentTimeMillis();
            long tzOffset = zone.getOffset(ctm);
            if (DBG) {
                log("fixTimeZone: tzOffset=" + tzOffset + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            if (getAutoTime()) {
                long adj = ctm - tzOffset;
                if (DBG)
                    log("fixTimeZone: adj ltod=" + TimeUtils.logTimeOfDay(adj));
                setAndBroadcastNetworkSetTime(adj);
            } else {
                // Adjust the saved NITZ time to account for tzOffset.
                mSavedTime = mSavedTime - tzOffset;
                if (DBG)
                    log("fixTimeZone: adj mSavedTime=" + mSavedTime);
            }
        }
        if (DBG)
            log("fixTimeZone: using default TimeZone");
    } else {
        zone = TimeUtils.getTimeZone(mZoneOffset, mZoneDst, mZoneTime, isoCountryCode);
        if (DBG)
            log("fixTimeZone: using getTimeZone(off, dst, time, iso)");
    }
    mNeedFixZoneAfterNitz = false;
    if (zone != null) {
        log("fixTimeZone: zone != null zone.getID=" + zone.getID());
        if (getAutoTimeZone()) {
            setAndBroadcastNetworkSetTimeZone(zone.getID());
        } else {
            log("fixTimeZone: skip changing zone as getAutoTimeZone was false");
        }
        saveNitzTimeZone(zone.getID());
    } else {
        log("fixTimeZone: zone == null, do nothing for zone");
    }
}
#method_after
protected void fixTimeZone(String isoCountryCode) {
    TimeZone zone = null;
    // If the offset is (0, false) and the time zone property
    // is set, use the time zone property rather than GMT.
    final String zoneName = SystemProperties.get(TIMEZONE_PROPERTY);
    if (DBG) {
        log("fixTimeZone zoneName='" + zoneName + "' mZoneOffset=" + mZoneOffset + " mZoneDst=" + mZoneDst + " iso-cc='" + isoCountryCode + "' iso-cc-idx=" + Arrays.binarySearch(GMT_COUNTRY_CODES, isoCountryCode));
    }
    if ("".equals(isoCountryCode) && mNeedFixZoneAfterNitz) {
        // Country code not found.  This is likely a test network.
        // Get a TimeZone based only on the NITZ parameters (best guess).
        zone = getNitzTimeZone(mZoneOffset, mZoneDst, mZoneTime);
        if (DBG)
            log("pollStateDone: using NITZ TimeZone");
    } else if ((mZoneOffset == 0) && (mZoneDst == false) && (zoneName != null) && (zoneName.length() > 0) && (Arrays.binarySearch(GMT_COUNTRY_CODES, isoCountryCode) < 0)) {
        // For NITZ string without time zone,
        // need adjust time to reflect default time zone setting
        zone = TimeZone.getDefault();
        if (mNeedFixZoneAfterNitz) {
            long ctm = System.currentTimeMillis();
            long tzOffset = zone.getOffset(ctm);
            if (DBG) {
                log("fixTimeZone: tzOffset=" + tzOffset + " ltod=" + TimeUtils.logTimeOfDay(ctm));
            }
            if (getAutoTime()) {
                long adj = ctm - tzOffset;
                if (DBG)
                    log("fixTimeZone: adj ltod=" + TimeUtils.logTimeOfDay(adj));
                setAndBroadcastNetworkSetTime(adj);
            } else {
                // Adjust the saved NITZ time to account for tzOffset.
                mSavedTime = mSavedTime - tzOffset;
                if (DBG)
                    log("fixTimeZone: adj mSavedTime=" + mSavedTime);
            }
        }
        if (DBG)
            log("fixTimeZone: using default TimeZone");
    } else {
        zone = TimeUtils.getTimeZone(mZoneOffset, mZoneDst, mZoneTime, isoCountryCode);
        if (DBG)
            log("fixTimeZone: using getTimeZone(off, dst, time, iso)");
    }
    final String tmpLog = "fixTimeZone zoneName=" + zoneName + " mZoneOffset=" + mZoneOffset + " mZoneDst=" + mZoneDst + " iso-cc=" + isoCountryCode + " mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz + " zone=" + (zone != null ? zone.getID() : "NULL");
    mTimeZoneLog.log(tmpLog);
    if (zone != null) {
        log("fixTimeZone: zone != null zone.getID=" + zone.getID());
        if (getAutoTimeZone()) {
            setAndBroadcastNetworkSetTimeZone(zone.getID());
        } else {
            log("fixTimeZone: skip changing zone as getAutoTimeZone was false");
        }
        if (mNeedFixZoneAfterNitz) {
            saveNitzTimeZone(zone.getID());
        }
    } else {
        log("fixTimeZone: zone == null, do nothing for zone");
    }
    mNeedFixZoneAfterNitz = false;
}
#end_block

#method_before
private int regCodeToServiceState(int code) {
    switch(code) {
        case 0:
        // 2 is "searching"
        case 2:
        // 3 is "registration denied"
        case 3:
        // 4 is "unknown" no vaild in current baseband
        case 4:
        // same as 0, but indicates that emergency call is possible.
        case 10:
        // same as 2, but indicates that emergency call is possible.
        case 12:
        // same as 3, but indicates that emergency call is possible.
        case 13:
        case // same as 4, but indicates that emergency call is possible.
        14:
            return ServiceState.STATE_OUT_OF_SERVICE;
        case 1:
        case // 5 is "registered, roaming"
        5:
            return ServiceState.STATE_IN_SERVICE;
        default:
            loge("regCodeToServiceState: unexpected service state " + code);
            return ServiceState.STATE_OUT_OF_SERVICE;
    }
}
#method_after
private int regCodeToServiceState(int code) {
    switch(code) {
        case ServiceState.RIL_REG_STATE_HOME:
        case ServiceState.RIL_REG_STATE_ROAMING:
            return ServiceState.STATE_IN_SERVICE;
        default:
            return ServiceState.STATE_OUT_OF_SERVICE;
    }
}
#end_block

#method_before
private boolean isOperatorConsideredNonRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    String[] numericArray = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.config_operatorConsideredNonRoaming);
    if (numericArray.length == 0 || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isOperatorConsideredNonRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    final CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    String[] numericArray = null;
    if (configManager != null) {
        PersistableBundle config = configManager.getConfigForSubId(mPhone.getSubId());
        if (config != null) {
            numericArray = config.getStringArray(CarrierConfigManager.KEY_NON_ROAMING_OPERATOR_STRING_ARRAY);
        }
    }
    if (ArrayUtils.isEmpty(numericArray) || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (!TextUtils.isEmpty(numeric) && operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private boolean isOperatorConsideredRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    String[] numericArray = mPhone.getContext().getResources().getStringArray(com.android.internal.R.array.config_sameNamedOperatorConsideredRoaming);
    if (numericArray.length == 0 || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isOperatorConsideredRoaming(ServiceState s) {
    String operatorNumeric = s.getOperatorNumeric();
    final CarrierConfigManager configManager = (CarrierConfigManager) mPhone.getContext().getSystemService(Context.CARRIER_CONFIG_SERVICE);
    String[] numericArray = null;
    if (configManager != null) {
        PersistableBundle config = configManager.getConfigForSubId(mPhone.getSubId());
        if (config != null) {
            numericArray = config.getStringArray(CarrierConfigManager.KEY_ROAMING_OPERATOR_STRING_ARRAY);
        }
    }
    if (ArrayUtils.isEmpty(numericArray) || operatorNumeric == null) {
        return false;
    }
    for (String numeric : numericArray) {
        if (!TextUtils.isEmpty(numeric) && operatorNumeric.startsWith(numeric)) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
private void onRestrictedStateChanged(AsyncResult ar) {
    RestrictedState newRs = new RestrictedState();
    if (DBG)
        log("onRestrictedStateChanged: E rs " + mRestrictedState);
    if (ar.exception == null) {
        int[] ints = (int[]) ar.result;
        int state = ints[0];
        newRs.setCsEmergencyRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_EMERGENCY) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
        // ignore the normal call and data restricted state before SIM READY
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY) {
            newRs.setCsNormalRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_NORMAL) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
            newRs.setPsRestricted((state & RILConstants.RIL_RESTRICTED_STATE_PS_ALL) != 0);
        }
        if (DBG)
            log("onRestrictedStateChanged: new rs " + newRs);
        if (!mRestrictedState.isPsRestricted() && newRs.isPsRestricted()) {
            mPsRestrictEnabledRegistrants.notifyRegistrants();
            setNotification(PS_ENABLED);
        } else if (mRestrictedState.isPsRestricted() && !newRs.isPsRestricted()) {
            mPsRestrictDisabledRegistrants.notifyRegistrants();
            setNotification(PS_DISABLED);
        }
        /**
         * There are two kind of cs restriction, normal and emergency. So
         * there are 4 x 4 combinations in current and new restricted states
         * and we only need to notify when state is changed.
         */
        if (mRestrictedState.isCsRestricted()) {
            if (!newRs.isCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (!newRs.isCsNormalRestricted()) {
                // remove normal restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (!newRs.isCsEmergencyRestricted()) {
                // remove emergency restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (mRestrictedState.isCsEmergencyRestricted() && !mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // remove emergency restriction and enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (!mRestrictedState.isCsEmergencyRestricted() && mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // remove normal restriction and enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            }
        } else {
            if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        }
        mRestrictedState = newRs;
    }
    log("onRestrictedStateChanged: X rs " + mRestrictedState);
}
#method_after
private void onRestrictedStateChanged(AsyncResult ar) {
    RestrictedState newRs = new RestrictedState();
    if (DBG)
        log("onRestrictedStateChanged: E rs " + mRestrictedState);
    if (ar.exception == null && ar.result != null) {
        int state = (int) ar.result;
        newRs.setCsEmergencyRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_EMERGENCY) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
        // ignore the normal call and data restricted state before SIM READY
        if (mUiccApplcation != null && mUiccApplcation.getState() == AppState.APPSTATE_READY) {
            newRs.setCsNormalRestricted(((state & RILConstants.RIL_RESTRICTED_STATE_CS_NORMAL) != 0) || ((state & RILConstants.RIL_RESTRICTED_STATE_CS_ALL) != 0));
            newRs.setPsRestricted((state & RILConstants.RIL_RESTRICTED_STATE_PS_ALL) != 0);
        }
        if (DBG)
            log("onRestrictedStateChanged: new rs " + newRs);
        if (!mRestrictedState.isPsRestricted() && newRs.isPsRestricted()) {
            mPsRestrictEnabledRegistrants.notifyRegistrants();
            setNotification(PS_ENABLED);
        } else if (mRestrictedState.isPsRestricted() && !newRs.isPsRestricted()) {
            mPsRestrictDisabledRegistrants.notifyRegistrants();
            setNotification(PS_DISABLED);
        }
        /**
         * There are two kind of cs restriction, normal and emergency. So
         * there are 4 x 4 combinations in current and new restricted states
         * and we only need to notify when state is changed.
         */
        if (mRestrictedState.isCsRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (!newRs.isCsNormalRestricted()) {
                // remove normal restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (!newRs.isCsEmergencyRestricted()) {
                // remove emergency restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (mRestrictedState.isCsEmergencyRestricted() && !mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // remove emergency restriction and enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        } else if (!mRestrictedState.isCsEmergencyRestricted() && mRestrictedState.isCsNormalRestricted()) {
            if (!newRs.isAnyCsRestricted()) {
                // remove all restriction
                setNotification(CS_DISABLED);
            } else if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // remove normal restriction and enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            }
        } else {
            if (newRs.isCsRestricted()) {
                // enable all restriction
                setNotification(CS_ENABLED);
            } else if (newRs.isCsEmergencyRestricted()) {
                // enable emergency restriction
                setNotification(CS_EMERGENCY_ENABLED);
            } else if (newRs.isCsNormalRestricted()) {
                // enable normal restriction
                setNotification(CS_NORMAL_ENABLED);
            }
        }
        mRestrictedState = newRs;
    }
    log("onRestrictedStateChanged: X rs " + mRestrictedState);
}
#end_block

#method_before
public CellLocation getCellLocation() {
    if (((GsmCellLocation) mCellLoc).getLac() >= 0 && ((GsmCellLocation) mCellLoc).getCid() >= 0) {
        if (DBG)
            log("getCellLocation(): X good mCellLoc=" + mCellLoc);
        return mCellLoc;
    } else {
        List<CellInfo> result = getAllCellInfo();
        if (result != null) {
            // A hack to allow tunneling of LTE information via GsmCellLocation
            // so that older Network Location Providers can return some information
            // on LTE only networks, see bug 9228974.
            // 
            // We'll search the return CellInfo array preferring GSM/WCDMA
            // data, but if there is none we'll tunnel the first LTE information
            // in the list.
            // 
            // The tunnel'd LTE information is returned as follows:
            // LAC = TAC field
            // CID = CI field
            // PSC = 0.
            GsmCellLocation cellLocOther = new GsmCellLocation();
            for (CellInfo ci : result) {
                if (ci instanceof CellInfoGsm) {
                    CellInfoGsm cellInfoGsm = (CellInfoGsm) ci;
                    CellIdentityGsm cellIdentityGsm = cellInfoGsm.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityGsm.getLac(), cellIdentityGsm.getCid());
                    cellLocOther.setPsc(cellIdentityGsm.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret GSM info=" + cellLocOther);
                    return cellLocOther;
                } else if (ci instanceof CellInfoWcdma) {
                    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ci;
                    CellIdentityWcdma cellIdentityWcdma = cellInfoWcdma.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityWcdma.getLac(), cellIdentityWcdma.getCid());
                    cellLocOther.setPsc(cellIdentityWcdma.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret WCDMA info=" + cellLocOther);
                    return cellLocOther;
                } else if ((ci instanceof CellInfoLte) && ((cellLocOther.getLac() < 0) || (cellLocOther.getCid() < 0))) {
                    // We'll return the first good LTE info we get if there is no better answer
                    CellInfoLte cellInfoLte = (CellInfoLte) ci;
                    CellIdentityLte cellIdentityLte = cellInfoLte.getCellIdentity();
                    if ((cellIdentityLte.getTac() != Integer.MAX_VALUE) && (cellIdentityLte.getCi() != Integer.MAX_VALUE)) {
                        cellLocOther.setLacAndCid(cellIdentityLte.getTac(), cellIdentityLte.getCi());
                        cellLocOther.setPsc(0);
                        if (DBG) {
                            log("getCellLocation(): possible LTE cellLocOther=" + cellLocOther);
                        }
                    }
                }
            }
            if (DBG) {
                log("getCellLocation(): X ret best answer cellLocOther=" + cellLocOther);
            }
            return cellLocOther;
        } else {
            if (DBG) {
                log("getCellLocation(): X empty mCellLoc and CellInfo mCellLoc=" + mCellLoc);
            }
            return mCellLoc;
        }
    }
}
#method_after
public CellLocation getCellLocation(WorkSource workSource) {
    if (((GsmCellLocation) mCellLoc).getLac() >= 0 && ((GsmCellLocation) mCellLoc).getCid() >= 0) {
        if (DBG)
            log("getCellLocation(): X good mCellLoc=" + mCellLoc);
        return mCellLoc;
    } else {
        List<CellInfo> result = getAllCellInfo(workSource);
        if (result != null) {
            // A hack to allow tunneling of LTE information via GsmCellLocation
            // so that older Network Location Providers can return some information
            // on LTE only networks, see bug 9228974.
            // 
            // We'll search the return CellInfo array preferring GSM/WCDMA
            // data, but if there is none we'll tunnel the first LTE information
            // in the list.
            // 
            // The tunnel'd LTE information is returned as follows:
            // LAC = TAC field
            // CID = CI field
            // PSC = 0.
            GsmCellLocation cellLocOther = new GsmCellLocation();
            for (CellInfo ci : result) {
                if (ci instanceof CellInfoGsm) {
                    CellInfoGsm cellInfoGsm = (CellInfoGsm) ci;
                    CellIdentityGsm cellIdentityGsm = cellInfoGsm.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityGsm.getLac(), cellIdentityGsm.getCid());
                    cellLocOther.setPsc(cellIdentityGsm.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret GSM info=" + cellLocOther);
                    return cellLocOther;
                } else if (ci instanceof CellInfoWcdma) {
                    CellInfoWcdma cellInfoWcdma = (CellInfoWcdma) ci;
                    CellIdentityWcdma cellIdentityWcdma = cellInfoWcdma.getCellIdentity();
                    cellLocOther.setLacAndCid(cellIdentityWcdma.getLac(), cellIdentityWcdma.getCid());
                    cellLocOther.setPsc(cellIdentityWcdma.getPsc());
                    if (DBG)
                        log("getCellLocation(): X ret WCDMA info=" + cellLocOther);
                    return cellLocOther;
                } else if ((ci instanceof CellInfoLte) && ((cellLocOther.getLac() < 0) || (cellLocOther.getCid() < 0))) {
                    // We'll return the first good LTE info we get if there is no better answer
                    CellInfoLte cellInfoLte = (CellInfoLte) ci;
                    CellIdentityLte cellIdentityLte = cellInfoLte.getCellIdentity();
                    if ((cellIdentityLte.getTac() != Integer.MAX_VALUE) && (cellIdentityLte.getCi() != Integer.MAX_VALUE)) {
                        cellLocOther.setLacAndCid(cellIdentityLte.getTac(), cellIdentityLte.getCi());
                        cellLocOther.setPsc(0);
                        if (DBG) {
                            log("getCellLocation(): possible LTE cellLocOther=" + cellLocOther);
                        }
                    }
                }
            }
            if (DBG) {
                log("getCellLocation(): X ret best answer cellLocOther=" + cellLocOther);
            }
            return cellLocOther;
        } else {
            if (DBG) {
                log("getCellLocation(): X empty mCellLoc and CellInfo mCellLoc=" + mCellLoc);
            }
            return mCellLoc;
        }
    }
}
#end_block

#method_before
private void setTimeFromNITZString(String nitz, long nitzReceiveTime) {
    // "yy/mm/dd,hh:mm:ss(+/-)tz"
    // tz is in number of quarter-hours
    long start = SystemClock.elapsedRealtime();
    if (DBG) {
        log("NITZ: " + nitz + "," + nitzReceiveTime + " start=" + start + " delay=" + (start - nitzReceiveTime));
    }
    try {
        /* NITZ time (hour:min:sec) will be in UTC but it supplies the timezone
             * offset as well (which we won't worry about until later) */
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.clear();
        c.set(Calendar.DST_OFFSET, 0);
        String[] nitzSubs = nitz.split("[/:,+-]");
        int year = 2000 + Integer.parseInt(nitzSubs[0]);
        if (year > MAX_NITZ_YEAR) {
            if (DBG)
                loge("NITZ year: " + year + " exceeds limit, skip NITZ time update");
            return;
        }
        c.set(Calendar.YEAR, year);
        // month is 0 based!
        int month = Integer.parseInt(nitzSubs[1]) - 1;
        c.set(Calendar.MONTH, month);
        int date = Integer.parseInt(nitzSubs[2]);
        c.set(Calendar.DATE, date);
        int hour = Integer.parseInt(nitzSubs[3]);
        c.set(Calendar.HOUR, hour);
        int minute = Integer.parseInt(nitzSubs[4]);
        c.set(Calendar.MINUTE, minute);
        int second = Integer.parseInt(nitzSubs[5]);
        c.set(Calendar.SECOND, second);
        boolean sign = (nitz.indexOf('-') == -1);
        int tzOffset = Integer.parseInt(nitzSubs[6]);
        int dst = (nitzSubs.length >= 8) ? Integer.parseInt(nitzSubs[7]) : 0;
        // The zone offset received from NITZ is for current local time,
        // so DST correction is already applied.  Don't add it again.
        // 
        // tzOffset += dst * 4;
        // 
        // We could unapply it if we wanted the raw offset.
        tzOffset = (sign ? 1 : -1) * tzOffset * 15 * 60 * 1000;
        TimeZone zone = null;
        // so we need to convert the ! into /
        if (nitzSubs.length >= 9) {
            String tzname = nitzSubs[8].replace('!', '/');
            zone = TimeZone.getTimeZone(tzname);
        }
        String iso = ((TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE)).getNetworkCountryIsoForPhone(mPhone.getPhoneId());
        if (zone == null) {
            if (mGotCountryCode) {
                if (iso != null && iso.length() > 0) {
                    zone = TimeUtils.getTimeZone(tzOffset, dst != 0, c.getTimeInMillis(), iso);
                } else {
                    // We don't have a valid iso country code.  This is
                    // most likely because we're on a test network that's
                    // using a bogus MCC (eg, "001"), so get a TimeZone
                    // based only on the NITZ parameters.
                    zone = getNitzTimeZone(tzOffset, (dst != 0), c.getTimeInMillis());
                }
            }
        }
        if ((zone == null) || (mZoneOffset != tzOffset) || (mZoneDst != (dst != 0))) {
            // We got the time before the country or the zone has changed
            // so we don't know how to identify the DST rules yet.  Save
            // the information and hope to fix it up later.
            mNeedFixZoneAfterNitz = true;
            mZoneOffset = tzOffset;
            mZoneDst = dst != 0;
            mZoneTime = c.getTimeInMillis();
        }
        if (DBG) {
            log("NITZ: tzOffset=" + tzOffset + " dst=" + dst + " zone=" + (zone != null ? zone.getID() : "NULL") + " iso=" + iso + " mGotCountryCode=" + mGotCountryCode + " mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
        }
        if (zone != null) {
            if (getAutoTimeZone()) {
                setAndBroadcastNetworkSetTimeZone(zone.getID());
            }
            saveNitzTimeZone(zone.getID());
        }
        String ignore = SystemProperties.get("gsm.ignore-nitz");
        if (ignore != null && ignore.equals("yes")) {
            log("NITZ: Not setting clock because gsm.ignore-nitz is set");
            return;
        }
        try {
            mWakeLock.acquire();
            if (!mPhone.isPhoneTypeGsm() || getAutoTime()) {
                long millisSinceNitzReceived = SystemClock.elapsedRealtime() - nitzReceiveTime;
                if (millisSinceNitzReceived < 0) {
                    // Sanity check: something is wrong
                    if (DBG) {
                        log("NITZ: not setting time, clock has rolled " + "backwards since NITZ time was received, " + nitz);
                    }
                    return;
                }
                if (millisSinceNitzReceived > Integer.MAX_VALUE) {
                    // If the time is this far off, something is wrong > 24 days!
                    if (DBG) {
                        log("NITZ: not setting time, processing has taken " + (millisSinceNitzReceived / (1000 * 60 * 60 * 24)) + " days");
                    }
                    return;
                }
                // Note: with range checks above, cast to int is safe
                c.add(Calendar.MILLISECOND, (int) millisSinceNitzReceived);
                if (DBG) {
                    log("NITZ: Setting time of day to " + c.getTime() + " NITZ receive delay(ms): " + millisSinceNitzReceived + " gained(ms): " + (c.getTimeInMillis() - System.currentTimeMillis()) + " from " + nitz);
                }
                if (mPhone.isPhoneTypeGsm()) {
                    setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                    Rlog.i(LOG_TAG, "NITZ: after Setting time of day");
                } else {
                    if (getAutoTime()) {
                        /**
                         * Update system time automatically
                         */
                        long gained = c.getTimeInMillis() - System.currentTimeMillis();
                        long timeSinceLastUpdate = SystemClock.elapsedRealtime() - mSavedAtTime;
                        int nitzUpdateSpacing = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_SPACING, mNitzUpdateSpacing);
                        int nitzUpdateDiff = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_DIFF, mNitzUpdateDiff);
                        if ((mSavedAtTime == 0) || (timeSinceLastUpdate > nitzUpdateSpacing) || (Math.abs(gained) > nitzUpdateDiff)) {
                            if (DBG) {
                                log("NITZ: Auto updating time of day to " + c.getTime() + " NITZ receive delay=" + millisSinceNitzReceived + "ms gained=" + gained + "ms from " + nitz);
                            }
                            setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                        } else {
                            if (DBG) {
                                log("NITZ: ignore, a previous update was " + timeSinceLastUpdate + "ms ago and gained=" + gained + "ms");
                            }
                            return;
                        }
                    }
                }
            }
            SystemProperties.set("gsm.nitz.time", String.valueOf(c.getTimeInMillis()));
            saveNitzTime(c.getTimeInMillis());
            mNitzUpdatedTime = true;
        } finally {
            if (DBG) {
                long end = SystemClock.elapsedRealtime();
                log("NITZ: end=" + end + " dur=" + (end - start));
            }
            mWakeLock.release();
        }
    } catch (RuntimeException ex) {
        loge("NITZ: Parsing NITZ time " + nitz + " ex=" + ex);
    }
}
#method_after
private void setTimeFromNITZString(String nitz, long nitzReceiveTime) {
    // "yy/mm/dd,hh:mm:ss(+/-)tz"
    // tz is in number of quarter-hours
    long start = SystemClock.elapsedRealtime();
    if (DBG) {
        log("NITZ: " + nitz + "," + nitzReceiveTime + " start=" + start + " delay=" + (start - nitzReceiveTime));
    }
    try {
        /* NITZ time (hour:min:sec) will be in UTC but it supplies the timezone
             * offset as well (which we won't worry about until later) */
        Calendar c = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        c.clear();
        c.set(Calendar.DST_OFFSET, 0);
        String[] nitzSubs = nitz.split("[/:,+-]");
        int year = 2000 + Integer.parseInt(nitzSubs[0]);
        if (year > MAX_NITZ_YEAR) {
            if (DBG)
                loge("NITZ year: " + year + " exceeds limit, skip NITZ time update");
            return;
        }
        c.set(Calendar.YEAR, year);
        // month is 0 based!
        int month = Integer.parseInt(nitzSubs[1]) - 1;
        c.set(Calendar.MONTH, month);
        int date = Integer.parseInt(nitzSubs[2]);
        c.set(Calendar.DATE, date);
        int hour = Integer.parseInt(nitzSubs[3]);
        c.set(Calendar.HOUR, hour);
        int minute = Integer.parseInt(nitzSubs[4]);
        c.set(Calendar.MINUTE, minute);
        int second = Integer.parseInt(nitzSubs[5]);
        c.set(Calendar.SECOND, second);
        boolean sign = (nitz.indexOf('-') == -1);
        int tzOffset = Integer.parseInt(nitzSubs[6]);
        int dst = (nitzSubs.length >= 8) ? Integer.parseInt(nitzSubs[7]) : 0;
        // The zone offset received from NITZ is for current local time,
        // so DST correction is already applied.  Don't add it again.
        // 
        // tzOffset += dst * 4;
        // 
        // We could unapply it if we wanted the raw offset.
        tzOffset = (sign ? 1 : -1) * tzOffset * 15 * 60 * 1000;
        TimeZone zone = null;
        // so we need to convert the ! into /
        if (nitzSubs.length >= 9) {
            String tzname = nitzSubs[8].replace('!', '/');
            zone = TimeZone.getTimeZone(tzname);
        }
        String iso = ((TelephonyManager) mPhone.getContext().getSystemService(Context.TELEPHONY_SERVICE)).getNetworkCountryIsoForPhone(mPhone.getPhoneId());
        if (zone == null) {
            if (mGotCountryCode) {
                if (iso != null && iso.length() > 0) {
                    zone = TimeUtils.getTimeZone(tzOffset, dst != 0, c.getTimeInMillis(), iso);
                } else {
                    // We don't have a valid iso country code.  This is
                    // most likely because we're on a test network that's
                    // using a bogus MCC (eg, "001"), so get a TimeZone
                    // based only on the NITZ parameters.
                    zone = getNitzTimeZone(tzOffset, (dst != 0), c.getTimeInMillis());
                }
            }
        }
        if ((zone == null) || (mZoneOffset != tzOffset) || (mZoneDst != (dst != 0))) {
            // We got the time before the country or the zone has changed
            // so we don't know how to identify the DST rules yet.  Save
            // the information and hope to fix it up later.
            mNeedFixZoneAfterNitz = true;
            mZoneOffset = tzOffset;
            mZoneDst = dst != 0;
            mZoneTime = c.getTimeInMillis();
        }
        String tmpLog = "NITZ: nitz=" + nitz + " nitzReceiveTime=" + nitzReceiveTime + " tzOffset=" + tzOffset + " dst=" + dst + " zone=" + (zone != null ? zone.getID() : "NULL") + " iso=" + iso + " mGotCountryCode=" + mGotCountryCode + " mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz + " getAutoTimeZone()=" + getAutoTimeZone();
        if (DBG) {
            log(tmpLog);
        }
        mTimeZoneLog.log(tmpLog);
        if (zone != null) {
            if (getAutoTimeZone()) {
                setAndBroadcastNetworkSetTimeZone(zone.getID());
            }
            saveNitzTimeZone(zone.getID());
        }
        String ignore = SystemProperties.get("gsm.ignore-nitz");
        if (ignore != null && ignore.equals("yes")) {
            log("NITZ: Not setting clock because gsm.ignore-nitz is set");
            return;
        }
        try {
            mWakeLock.acquire();
            if (!mPhone.isPhoneTypeGsm() || getAutoTime()) {
                long millisSinceNitzReceived = SystemClock.elapsedRealtime() - nitzReceiveTime;
                if (millisSinceNitzReceived < 0) {
                    // Sanity check: something is wrong
                    if (DBG) {
                        log("NITZ: not setting time, clock has rolled " + "backwards since NITZ time was received, " + nitz);
                    }
                    return;
                }
                if (millisSinceNitzReceived > Integer.MAX_VALUE) {
                    // If the time is this far off, something is wrong > 24 days!
                    if (DBG) {
                        log("NITZ: not setting time, processing has taken " + (millisSinceNitzReceived / (1000 * 60 * 60 * 24)) + " days");
                    }
                    return;
                }
                // Note: with range checks above, cast to int is safe
                c.add(Calendar.MILLISECOND, (int) millisSinceNitzReceived);
                tmpLog = "NITZ: nitz=" + nitz + " nitzReceiveTime=" + nitzReceiveTime + " Setting time of day to " + c.getTime() + " NITZ receive delay(ms): " + millisSinceNitzReceived + " gained(ms): " + (c.getTimeInMillis() - System.currentTimeMillis()) + " from " + nitz;
                if (DBG) {
                    log(tmpLog);
                }
                mTimeLog.log(tmpLog);
                if (mPhone.isPhoneTypeGsm()) {
                    setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                    Rlog.i(LOG_TAG, "NITZ: after Setting time of day");
                } else {
                    if (getAutoTime()) {
                        /**
                         * Update system time automatically
                         */
                        long gained = c.getTimeInMillis() - System.currentTimeMillis();
                        long timeSinceLastUpdate = SystemClock.elapsedRealtime() - mSavedAtTime;
                        int nitzUpdateSpacing = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_SPACING, mNitzUpdateSpacing);
                        int nitzUpdateDiff = Settings.Global.getInt(mCr, Settings.Global.NITZ_UPDATE_DIFF, mNitzUpdateDiff);
                        if ((mSavedAtTime == 0) || (timeSinceLastUpdate > nitzUpdateSpacing) || (Math.abs(gained) > nitzUpdateDiff)) {
                            if (DBG) {
                                log("NITZ: Auto updating time of day to " + c.getTime() + " NITZ receive delay=" + millisSinceNitzReceived + "ms gained=" + gained + "ms from " + nitz);
                            }
                            setAndBroadcastNetworkSetTime(c.getTimeInMillis());
                        } else {
                            if (DBG) {
                                log("NITZ: ignore, a previous update was " + timeSinceLastUpdate + "ms ago and gained=" + gained + "ms");
                            }
                            return;
                        }
                    }
                }
            }
            SystemProperties.set("gsm.nitz.time", String.valueOf(c.getTimeInMillis()));
            saveNitzTime(c.getTimeInMillis());
            mNitzUpdatedTime = true;
        } finally {
            if (DBG) {
                long end = SystemClock.elapsedRealtime();
                log("NITZ: end=" + end + " dur=" + (end - start));
            }
            mWakeLock.release();
        }
    } catch (RuntimeException ex) {
        loge("NITZ: Parsing NITZ time " + nitz + " ex=" + ex);
    }
}
#end_block

#method_before
private void revertToNitzTime() {
    if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME, 0) == 0) {
        return;
    }
    if (DBG) {
        log("Reverting to NITZ Time: mSavedTime=" + mSavedTime + " mSavedAtTime=" + mSavedAtTime);
    }
    if (mSavedTime != 0 && mSavedAtTime != 0) {
        setAndBroadcastNetworkSetTime(mSavedTime + (SystemClock.elapsedRealtime() - mSavedAtTime));
    }
}
#method_after
private void revertToNitzTime() {
    if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME, 0) == 0) {
        return;
    }
    if (DBG) {
        log("Reverting to NITZ Time: mSavedTime=" + mSavedTime + " mSavedAtTime=" + mSavedAtTime);
    }
    if (mSavedTime != 0 && mSavedAtTime != 0) {
        long currTime = SystemClock.elapsedRealtime();
        mTimeLog.log("Reverting to NITZ time, currTime=" + currTime + " mSavedAtTime=" + mSavedAtTime + " mSavedTime=" + mSavedTime);
        setAndBroadcastNetworkSetTime(mSavedTime + (currTime - mSavedAtTime));
    }
}
#end_block

#method_before
private void revertToNitzTimeZone() {
    if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME_ZONE, 0) == 0) {
        return;
    }
    if (DBG)
        log("Reverting to NITZ TimeZone: tz='" + mSavedTimeZone);
    if (mSavedTimeZone != null) {
        setAndBroadcastNetworkSetTimeZone(mSavedTimeZone);
    }
}
#method_after
private void revertToNitzTimeZone() {
    if (Settings.Global.getInt(mCr, Settings.Global.AUTO_TIME_ZONE, 0) == 0) {
        return;
    }
    String tmpLog = "Reverting to NITZ TimeZone: tz=" + mSavedTimeZone;
    if (DBG)
        log(tmpLog);
    mTimeZoneLog.log(tmpLog);
    if (mSavedTimeZone != null) {
        setAndBroadcastNetworkSetTimeZone(mSavedTimeZone);
    }
}
#end_block

#method_before
private void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CharSequence details = "";
    CharSequence title = context.getText(com.android.internal.R.string.RestrictedOnData);
    int notificationId = CS_NOTIFICATION;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            details = context.getText(com.android.internal.R.string.RestrictedOnData);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            details = context.getText(com.android.internal.R.string.RestrictedOnAllVoice);
            break;
        case CS_NORMAL_ENABLED:
            details = context.getText(com.android.internal.R.string.RestrictedOnNormal);
            break;
        case CS_EMERGENCY_ENABLED:
            details = context.getText(com.android.internal.R.string.RestrictedOnEmergency);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
    }
    if (DBG)
        log("setNotification: put notification " + title + " / " + details);
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(com.android.internal.R.drawable.stat_sys_warning).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#method_after
@VisibleForTesting
public void setNotification(int notifyType) {
    if (DBG)
        log("setNotification: create notification " + notifyType);
    // Needed because sprout RIL sends these when they shouldn't?
    boolean isSetNotification = mPhone.getContext().getResources().getBoolean(com.android.internal.R.bool.config_user_notification_of_restrictied_mobile_access);
    if (!isSetNotification) {
        if (DBG)
            log("Ignore all the notifications");
        return;
    }
    Context context = mPhone.getContext();
    CarrierConfigManager configManager = (CarrierConfigManager) context.getSystemService(Context.CARRIER_CONFIG_SERVICE);
    if (configManager != null) {
        PersistableBundle bundle = configManager.getConfig();
        if (bundle != null) {
            boolean disableVoiceBarringNotification = bundle.getBoolean(CarrierConfigManager.KEY_DISABLE_VOICE_BARRING_NOTIFICATION_BOOL, false);
            if (disableVoiceBarringNotification && (notifyType == CS_ENABLED || notifyType == CS_NORMAL_ENABLED || notifyType == CS_EMERGENCY_ENABLED)) {
                if (DBG)
                    log("Voice/emergency call barred notification disabled");
                return;
            }
        }
    }
    CharSequence details = "";
    CharSequence title = "";
    int notificationId = CS_NOTIFICATION;
    int icon = com.android.internal.R.drawable.stat_sys_warning;
    switch(notifyType) {
        case PS_ENABLED:
            long dataSubId = SubscriptionManager.getDefaultDataSubscriptionId();
            if (dataSubId != mPhone.getSubId()) {
                return;
            }
            notificationId = PS_NOTIFICATION;
            title = context.getText(com.android.internal.R.string.RestrictedOnDataTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnDataContent);
            break;
        case PS_DISABLED:
            notificationId = PS_NOTIFICATION;
            break;
        case CS_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnAllVoiceContent);
            break;
        case CS_NORMAL_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnNormalTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnNormalContent);
            break;
        case CS_EMERGENCY_ENABLED:
            title = context.getText(com.android.internal.R.string.RestrictedOnEmergencyTitle);
            details = context.getText(com.android.internal.R.string.RestrictedOnEmergencyContent);
            break;
        case CS_DISABLED:
            // do nothing and cancel the notification later
            break;
        case CS_REJECT_CAUSE_ENABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            int resId = selectResourceForRejectCode(mRejectCode);
            if (0 == resId) {
                // cancel notification because current reject code is not handled.
                notifyType = CS_REJECT_CAUSE_DISABLED;
            } else {
                icon = com.android.internal.R.drawable.stat_notify_mmcc_indication_icn;
                title = Resources.getSystem().getString(resId);
                details = null;
            }
            break;
        case CS_REJECT_CAUSE_DISABLED:
            notificationId = CS_REJECT_CAUSE_NOTIFICATION;
            break;
    }
    if (DBG) {
        log("setNotification, create notification, notifyType: " + notifyType + ", title: " + title + ", details: " + details);
    }
    mNotification = new Notification.Builder(context).setWhen(System.currentTimeMillis()).setAutoCancel(true).setSmallIcon(icon).setTicker(title).setColor(context.getResources().getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentText(details).build();
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notifyType == PS_DISABLED || notifyType == CS_DISABLED || notifyType == CS_REJECT_CAUSE_DISABLED) {
        // cancel previous post notification
        notificationManager.cancel(notificationId);
    } else {
        // update restricted state notification
        notificationManager.notify(notificationId, mNotification);
    }
}
#end_block

#method_before
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    // override isGsm for CDMA LTE
    if (mPhone.isPhoneTypeGsm() || (mPhone.isPhoneTypeCdmaLte() && ServiceState.isLte(mSS.getRilDataRadioTechnology()))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        mSignalStrength.setGsm(isGsm);
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#method_after
protected boolean onSignalStrengthResult(AsyncResult ar) {
    boolean isGsm = false;
    int dataRat = mSS.getRilDataRadioTechnology();
    int voiceRat = mSS.getRilVoiceRadioTechnology();
    // Set isGsm to true if the RAT belongs to GSM family and not IWLAN
    if ((dataRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(dataRat)) || (voiceRat != ServiceState.RIL_RADIO_TECHNOLOGY_IWLAN && ServiceState.isGsm(voiceRat))) {
        isGsm = true;
    }
    if ((ar.exception == null) && (ar.result != null)) {
        mSignalStrength = (SignalStrength) ar.result;
        mSignalStrength.validateInput();
        mSignalStrength.setGsm(isGsm);
        mSignalStrength.setLteRsrpBoost(mSS.getLteEarfcnRsrpBoost());
    } else {
        log("onSignalStrengthResult() Exception from RIL : " + ar.exception);
        mSignalStrength = new SignalStrength(isGsm);
    }
    boolean ssChanged = notifySignalStrength();
    return ssChanged;
}
#end_block

#method_before
public List<CellInfo> getAllCellInfo() {
    CellInfoResult result = new CellInfoResult();
    if (VDBG)
        log("SST.getAllCellInfo(): E");
    int ver = mCi.getRilVersion();
    if (ver >= 8) {
        if (isCallerOnDifferentThread()) {
            if ((SystemClock.elapsedRealtime() - mLastCellInfoListTime) > LAST_CELL_INFO_LIST_MAX_AGE_MS) {
                Message msg = obtainMessage(EVENT_GET_CELL_INFO_LIST, result);
                synchronized (result.lockObj) {
                    result.list = null;
                    mCi.getCellInfoList(msg);
                    try {
                        result.lockObj.wait(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } else {
                if (DBG)
                    log("SST.getAllCellInfo(): return last, back to back calls");
                result.list = mLastCellInfoList;
            }
        } else {
            if (DBG)
                log("SST.getAllCellInfo(): return last, same thread can't block");
            result.list = mLastCellInfoList;
        }
    } else {
        if (DBG)
            log("SST.getAllCellInfo(): not implemented");
        result.list = null;
    }
    synchronized (result.lockObj) {
        if (result.list != null) {
            if (VDBG)
                log("SST.getAllCellInfo(): X size=" + result.list.size() + " list=" + result.list);
            return result.list;
        } else {
            if (DBG)
                log("SST.getAllCellInfo(): X size=0 list=null");
            return null;
        }
    }
}
#method_after
public List<CellInfo> getAllCellInfo(WorkSource workSource) {
    CellInfoResult result = new CellInfoResult();
    if (VDBG)
        log("SST.getAllCellInfo(): E");
    int ver = mCi.getRilVersion();
    if (ver >= 8) {
        if (isCallerOnDifferentThread()) {
            if ((SystemClock.elapsedRealtime() - mLastCellInfoListTime) > LAST_CELL_INFO_LIST_MAX_AGE_MS) {
                Message msg = obtainMessage(EVENT_GET_CELL_INFO_LIST, result);
                synchronized (result.lockObj) {
                    result.list = null;
                    mCi.getCellInfoList(msg, workSource);
                    try {
                        result.lockObj.wait(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            } else {
                if (DBG)
                    log("SST.getAllCellInfo(): return last, back to back calls");
                result.list = mLastCellInfoList;
            }
        } else {
            if (DBG)
                log("SST.getAllCellInfo(): return last, same thread can't block");
            result.list = mLastCellInfoList;
        }
    } else {
        if (DBG)
            log("SST.getAllCellInfo(): not implemented");
        result.list = null;
    }
    synchronized (result.lockObj) {
        if (result.list != null) {
            if (VDBG)
                log("SST.getAllCellInfo(): X size=" + result.list.size() + " list=" + result.list);
            return result.list;
        } else {
            if (DBG)
                log("SST.getAllCellInfo(): X size=0 list=null");
            return null;
        }
    }
}
#end_block

#method_before
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + mCellLoc);
    pw.println(" mNewCellLoc=" + mNewCellLoc);
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#method_after
public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    pw.println("ServiceStateTracker:");
    pw.println(" mSubId=" + mSubId);
    pw.println(" mSS=" + mSS);
    pw.println(" mNewSS=" + mNewSS);
    pw.println(" mVoiceCapable=" + mVoiceCapable);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPollingContext=" + mPollingContext + " - " + (mPollingContext != null ? mPollingContext[0] : ""));
    pw.println(" mDesiredPowerState=" + mDesiredPowerState);
    pw.println(" mDontPollSignalStrength=" + mDontPollSignalStrength);
    pw.println(" mSignalStrength=" + mSignalStrength);
    pw.println(" mLastSignalStrength=" + mLastSignalStrength);
    pw.println(" mRestrictedState=" + mRestrictedState);
    pw.println(" mPendingRadioPowerOffAfterDataOff=" + mPendingRadioPowerOffAfterDataOff);
    pw.println(" mPendingRadioPowerOffAfterDataOffTag=" + mPendingRadioPowerOffAfterDataOffTag);
    pw.println(" mCellLoc=" + mCellLoc);
    pw.println(" mNewCellLoc=" + mNewCellLoc);
    pw.println(" mLastCellInfoListTime=" + mLastCellInfoListTime);
    dumpCellInfoList(pw);
    pw.flush();
    pw.println(" mPreferredNetworkType=" + mPreferredNetworkType);
    pw.println(" mMaxDataCalls=" + mMaxDataCalls);
    pw.println(" mNewMaxDataCalls=" + mNewMaxDataCalls);
    pw.println(" mReasonDataDenied=" + mReasonDataDenied);
    pw.println(" mNewReasonDataDenied=" + mNewReasonDataDenied);
    pw.println(" mGsmRoaming=" + mGsmRoaming);
    pw.println(" mDataRoaming=" + mDataRoaming);
    pw.println(" mEmergencyOnly=" + mEmergencyOnly);
    pw.println(" mNeedFixZoneAfterNitz=" + mNeedFixZoneAfterNitz);
    pw.flush();
    pw.println(" mZoneOffset=" + mZoneOffset);
    pw.println(" mZoneDst=" + mZoneDst);
    pw.println(" mZoneTime=" + mZoneTime);
    pw.println(" mGotCountryCode=" + mGotCountryCode);
    pw.println(" mNitzUpdatedTime=" + mNitzUpdatedTime);
    pw.println(" mSavedTimeZone=" + mSavedTimeZone);
    pw.println(" mSavedTime=" + mSavedTime);
    pw.println(" mSavedAtTime=" + mSavedAtTime);
    pw.println(" mStartedGprsRegCheck=" + mStartedGprsRegCheck);
    pw.println(" mReportedGprsNoReg=" + mReportedGprsNoReg);
    pw.println(" mNotification=" + mNotification);
    pw.println(" mWakeLock=" + mWakeLock);
    pw.println(" mCurSpn=" + mCurSpn);
    pw.println(" mCurDataSpn=" + mCurDataSpn);
    pw.println(" mCurShowSpn=" + mCurShowSpn);
    pw.println(" mCurPlmn=" + mCurPlmn);
    pw.println(" mCurShowPlmn=" + mCurShowPlmn);
    pw.flush();
    pw.println(" mCurrentOtaspMode=" + mCurrentOtaspMode);
    pw.println(" mRoamingIndicator=" + mRoamingIndicator);
    pw.println(" mIsInPrl=" + mIsInPrl);
    pw.println(" mDefaultRoamingIndicator=" + mDefaultRoamingIndicator);
    pw.println(" mRegistrationState=" + mRegistrationState);
    pw.println(" mMdn=" + mMdn);
    pw.println(" mHomeSystemId=" + mHomeSystemId);
    pw.println(" mHomeNetworkId=" + mHomeNetworkId);
    pw.println(" mMin=" + mMin);
    pw.println(" mPrlVersion=" + mPrlVersion);
    pw.println(" mIsMinInfoReady=" + mIsMinInfoReady);
    pw.println(" mIsEriTextLoaded=" + mIsEriTextLoaded);
    pw.println(" mIsSubscriptionFromRuim=" + mIsSubscriptionFromRuim);
    pw.println(" mCdmaSSM=" + mCdmaSSM);
    pw.println(" mRegistrationDeniedReason=" + mRegistrationDeniedReason);
    pw.println(" mCurrentCarrier=" + mCurrentCarrier);
    pw.flush();
    pw.println(" mImsRegistered=" + mImsRegistered);
    pw.println(" mImsRegistrationOnOff=" + mImsRegistrationOnOff);
    pw.println(" mAlarmSwitch=" + mAlarmSwitch);
    pw.println(" mRadioDisabledByCarrier" + mRadioDisabledByCarrier);
    pw.println(" mPowerOffDelayNeed=" + mPowerOffDelayNeed);
    pw.println(" mDeviceShuttingDown=" + mDeviceShuttingDown);
    pw.println(" mSpnUpdatePending=" + mSpnUpdatePending);
    pw.println(" mLteRsrpBoost=" + mLteRsrpBoost);
    dumpEarfcnPairList(pw);
    pw.println(" Roaming Log:");
    IndentingPrintWriter ipw = new IndentingPrintWriter(pw, "  ");
    ipw.increaseIndent();
    mRoamingLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Attach Log:");
    ipw.increaseIndent();
    mAttachLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Phone Change Log:");
    ipw.increaseIndent();
    mPhoneTypeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Rat Change Log:");
    ipw.increaseIndent();
    mRatLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Radio power Log:");
    ipw.increaseIndent();
    mRadioPowerLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time Logs:");
    ipw.increaseIndent();
    mTimeLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
    ipw.println(" Time zone Logs:");
    ipw.increaseIndent();
    mTimeZoneLog.dump(fd, ipw, args);
    ipw.decreaseIndent();
}
#end_block

#method_before
@Override
public int hashCode() {
    return address.hashCode() + 11 * prefixLength + 19 * flags;
}
#method_after
@Override
public int hashCode() {
    return address.hashCode() + 11 * prefixLength + 19 * flags + 43 * scope;
}
#end_block

#method_before
@SmallTest
public void testHashCodeIsNotConstant() {
    IpPrefix[] prefixes = { new IpPrefix("2001:db8:f00::ace:d00d/127"), new IpPrefix("192.0.2.0/23"), new IpPrefix("::/0"), new IpPrefix("0.0.0.0/0") };
    for (int i = 0; i < prefixes.length; i++) {
        for (int j = i + 1; j < prefixes.length; j++) {
            assertNotEquals(prefixes[i].hashCode(), prefixes[j].hashCode());
        }
    }
}
#method_after
@Test
public void testHashCodeIsNotConstant() {
    IpPrefix[] prefixes = { new IpPrefix("2001:db8:f00::ace:d00d/127"), new IpPrefix("192.0.2.0/23"), new IpPrefix("::/0"), new IpPrefix("0.0.0.0/0") };
    for (int i = 0; i < prefixes.length; i++) {
        for (int j = i + 1; j < prefixes.length; j++) {
            assertNotEquals(prefixes[i].hashCode(), prefixes[j].hashCode());
        }
    }
}
#end_block

#method_before
static void testBadInterfaceMethod() {
    BadInterface badiface = new BadIfaceImpl();
    try {
        badiface.internalClone();
    } catch (IncompatibleClassChangeError icce) {
        System.out.println("Got expected IncompatibleClassChangeError (interface)");
        if (VERBOSE)
            System.out.println("--- " + icce);
    }
}
#method_after
static void testBadInterfaceMethod() {
    BadInterface badiface = new BadIfaceImpl();
    try {
        badiface.internalClone();
    } catch (IncompatibleClassChangeError icce) {
        // TODO b/64274113 This should really be an NSME
        System.out.println("Got expected IncompatibleClassChangeError (interface)");
        if (VERBOSE)
            System.out.println("--- " + icce);
    }
}
#end_block

#method_before
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities networkCapabilities) {
    // Only enforce that capabilities are not removed, allowing addition. http://b/64125969
    if (nai.everConnected && !nai.networkCapabilities.satisfiedByNetworkCapabilities(networkCapabilities)) {
        // TODO: consider allowing a network agent to also degrade its capabilities if this
        // does not cause any request (that is not a listn) currently matching that agent to
        // stop being matched by the updated agent.
        String diff = nai.networkCapabilities.describeImmutableDifferences(networkCapabilities);
        if (!TextUtils.isEmpty(diff)) {
            Slog.wtf(TAG, "BUG: " + nai + " changed immutable capabilities:" + diff);
        }
    }
    // Don't modify caller's NetworkCapabilities.
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    if (nai.lastValidated) {
        networkCapabilities.addCapability(NET_CAPABILITY_VALIDATED);
    } else {
        networkCapabilities.removeCapability(NET_CAPABILITY_VALIDATED);
    }
    if (nai.lastCaptivePortalDetected) {
        networkCapabilities.addCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    } else {
        networkCapabilities.removeCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    }
    if (nai.isBackgroundNetwork()) {
        networkCapabilities.removeCapability(NET_CAPABILITY_FOREGROUND);
    } else {
        networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    if (Objects.equals(nai.networkCapabilities, networkCapabilities))
        return;
    final String oldPermission = getNetworkPermission(nai.networkCapabilities);
    final String newPermission = getNetworkPermission(networkCapabilities);
    if (!Objects.equals(oldPermission, newPermission) && nai.created && !nai.isVPN()) {
        try {
            mNetd.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc = nai.networkCapabilities;
    synchronized (nai) {
        nai.networkCapabilities = networkCapabilities;
    }
    if (nai.getCurrentScore() == oldScore && networkCapabilities.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
}
#method_after
private void updateCapabilities(int oldScore, NetworkAgentInfo nai, NetworkCapabilities networkCapabilities) {
    // Once a NetworkAgent is connected, complain if some immutable capabilities are removed.
    if (nai.everConnected && !nai.networkCapabilities.satisfiedByNetworkCapabilities(networkCapabilities)) {
        // TODO: consider not complaining when a network agent degrade its capabilities if this
        // does not cause any request (that is not a listen) currently matching that agent to
        // stop being matched by the updated agent.
        String diff = nai.networkCapabilities.describeImmutableDifferences(networkCapabilities);
        if (!TextUtils.isEmpty(diff)) {
            Slog.wtf(TAG, "BUG: " + nai + " lost immutable capabilities:" + diff);
        }
    }
    // Don't modify caller's NetworkCapabilities.
    networkCapabilities = new NetworkCapabilities(networkCapabilities);
    if (nai.lastValidated) {
        networkCapabilities.addCapability(NET_CAPABILITY_VALIDATED);
    } else {
        networkCapabilities.removeCapability(NET_CAPABILITY_VALIDATED);
    }
    if (nai.lastCaptivePortalDetected) {
        networkCapabilities.addCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    } else {
        networkCapabilities.removeCapability(NET_CAPABILITY_CAPTIVE_PORTAL);
    }
    if (nai.isBackgroundNetwork()) {
        networkCapabilities.removeCapability(NET_CAPABILITY_FOREGROUND);
    } else {
        networkCapabilities.addCapability(NET_CAPABILITY_FOREGROUND);
    }
    if (Objects.equals(nai.networkCapabilities, networkCapabilities))
        return;
    final String oldPermission = getNetworkPermission(nai.networkCapabilities);
    final String newPermission = getNetworkPermission(networkCapabilities);
    if (!Objects.equals(oldPermission, newPermission) && nai.created && !nai.isVPN()) {
        try {
            mNetd.setNetworkPermission(nai.network.netId, newPermission);
        } catch (RemoteException e) {
            loge("Exception in setNetworkPermission: " + e);
        }
    }
    final NetworkCapabilities prevNc = nai.networkCapabilities;
    synchronized (nai) {
        nai.networkCapabilities = networkCapabilities;
    }
    if (nai.getCurrentScore() == oldScore && networkCapabilities.equalRequestableCapabilities(prevNc)) {
        // If the requestable capabilities haven't changed, and the score hasn't changed, then
        // the change we're processing can't affect any requests, it can only affect the listens
        // on this network. We might have been called by rematchNetworkAndRequests when a
        // network changed foreground state.
        processListenRequests(nai, true);
    } else {
        // If the requestable capabilities have changed or the score changed, we can't have been
        // called by rematchNetworkAndRequests, so it's safe to start a rematch.
        rematchAllNetworksAndRequests(nai, oldScore);
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_CAP_CHANGED);
    }
}
#end_block

#method_before
private static String connectDetail(FileDescriptor fd, InetAddress inetAddress, int port, int timeoutMs, Exception cause) {
    // Figure out source address from fd.
    InetAddress localAddress = null;
    int localPort = -1;
    try {
        localAddress = getSocketLocalAddress(fd);
        localPort = getSocketLocalPort(fd);
    } catch (SocketException ignored) {
    }
    String detail = "failed to connect to " + inetAddress + ":" + port;
    if (localAddress != null) {
        detail += " from " + localAddress + ":" + localPort;
    }
    if (timeoutMs > 0) {
        detail += " after " + timeoutMs + "ms";
    }
    if (cause != null) {
        detail += ": " + cause.getMessage();
    }
    return detail;
}
#method_after
private static String connectDetail(FileDescriptor fd, InetAddress inetAddress, int port, int timeoutMs, Exception cause) {
    // Figure out source address from fd.
    InetSocketAddress localAddress = null;
    try {
        localAddress = getLocalInetSocketAddress(fd);
    } catch (SocketException ignored) {
    }
    StringBuilder sb = new StringBuilder("failed to connect").append(" to ").append(inetAddress).append(" (port ").append(port).append(")");
    if (localAddress != null) {
        sb.append(" from ").append(localAddress.getAddress()).append(" (port ").append(localAddress.getPort()).append(")");
    }
    if (timeoutMs > 0) {
        sb.append(" after ").append(timeoutMs).append("ms");
    }
    if (cause != null) {
        sb.append(": ").append(cause.getMessage());
    }
    return sb.toString();
}
#end_block

#method_before
public void test_parse_returnType() {
    DecimalFormat form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    Number number = form.parse("23.1", new ParsePosition(0));
    assertTrue(number instanceof Double);
    // Test parsed object of type double when
    // parseBigDecimal is set to true
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    number = form.parse("23.1", new ParsePosition(0));
    assertTrue(number instanceof Double);
    form.setParseBigDecimal(true);
    number = form.parse("23.1", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    assertEquals(new BigDecimal("23.1"), number);
    // When parseIntegerOnly set to true, all numbers will be parsed
    // into Long unless the value is out of the bound of Long or
    // some special values such as NaN or Infinity.
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    form.setParseIntegerOnly(true);
    number = form.parse("23.1f", new ParsePosition(0));
    assertTrue(number instanceof Long);
    number = form.parse("23.0", new ParsePosition(0));
    assertTrue(number instanceof Long);
    number = form.parse("-0.0", new ParsePosition(0));
    assertTrue(number instanceof Long);
    assertTrue(new Long(0).equals(number));
    // The last integers representable by long.
    number = form.parse("9223372036854775807.00", new ParsePosition(0));
    assertEquals(Double.class, number.getClass());
    number = form.parse("9223372036854775808.00", new ParsePosition(0));
    assertEquals(Double.class, number.getClass());
    // The first integers that need to be represented by double.
    number = form.parse("-9223372036854775808.00", new ParsePosition(0));
    assertEquals(Double.class, number.getClass());
    number = form.parse("-9223372036854775809.00", new ParsePosition(0));
    assertEquals(Double.class, number.getClass());
    // Even if parseIntegerOnly is set to true, NaN will be parsed to Double
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    form.setParseIntegerOnly(true);
    DecimalFormatSymbols symbols = new DecimalFormatSymbols();
    number = form.parse(symbols.getNaN(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    // Even if parseIntegerOnly is set to true, Infinity will still be
    // parsed to Double
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    form.setParseIntegerOnly(true);
    symbols = new DecimalFormatSymbols();
    number = form.parse(symbols.getInfinity(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    // ParseBigDecimal take precedence of parseBigInteger
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    form.setParseIntegerOnly(true);
    form.setParseBigDecimal(true);
    number = form.parse("23.1f", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    number = form.parse("23.0", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    number = form.parse("-92,233,720,368,547,758,080.00", new ParsePosition(0));
    assertFalse(number instanceof BigInteger);
    assertTrue(number instanceof BigDecimal);
    // Test whether the parsed object is of type float. (To be specific,
    // they are of type Double)
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    number = form.parse("23.1f", new ParsePosition(0));
    assertTrue(number instanceof Double);
    form.setParseBigDecimal(true);
    number = form.parse("23.1f", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    assertEquals(new BigDecimal("23.1"), number);
    // Integer will be parsed to Long, unless parseBigDecimal is set to true
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    number = form.parse("123", new ParsePosition(0));
    assertTrue(number instanceof Long);
    form.setParseBigDecimal(true);
    number = form.parse("123", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    assertEquals(new BigDecimal("123"), number);
    // NaN will be parsed to Double, no matter parseBigDecimal set or not.
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    symbols = new DecimalFormatSymbols();
    number = form.parse(symbols.getNaN() + "", new ParsePosition(0));
    assertTrue(number instanceof Double);
    form.setParseBigDecimal(true);
    number = form.parse(symbols.getNaN() + "", new ParsePosition(0));
    assertTrue(number instanceof Double);
    // Infinity will be parsed to Double, no matter parseBigDecimal set or
    // not.
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    symbols = new DecimalFormatSymbols();
    number = form.parse(symbols.getInfinity(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("Infinity", number.toString());
    // When set bigDecimal to true, the result of parsing infinity
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    symbols = new DecimalFormatSymbols();
    form.setParseBigDecimal(true);
    number = form.parse(symbols.getInfinity(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("Infinity", number.toString());
    // Negative infinity will be parsed to double no matter parseBigDecimal
    // set or not
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    symbols = new DecimalFormatSymbols();
    number = form.parse("-" + symbols.getInfinity(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("-Infinity", number.toString());
    // When set bigDecimal to true, the result of parsing minus infinity
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    symbols = new DecimalFormatSymbols();
    form.setParseBigDecimal(true);
    number = form.parse("-" + symbols.getInfinity(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("-Infinity", number.toString());
    // -0.0 will be parsed to different type according to the combination of
    // parseBigDecimal and parseIntegerOnly
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    // parseBigDecimal == true;
    // parseIntegerOnly == false;
    form.setParseBigDecimal(true);
    number = form.parse("-0", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    number = form.parse("-0.0", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    // parseBigDecimal == false;
    // parseIntegerOnly == true;
    form.setParseBigDecimal(false);
    form.setParseIntegerOnly(true);
    number = form.parse("-0", new ParsePosition(0));
    assertTrue(number instanceof Long);
    number = form.parse("-0.0", new ParsePosition(0));
    assertTrue(number instanceof Long);
    // parseBigDecimal == false;
    // parseIntegerOnly == false;
    form.setParseBigDecimal(false);
    form.setParseIntegerOnly(false);
    number = form.parse("-0", new ParsePosition(0));
    assertTrue(number instanceof Double);
    number = form.parse("-0.0", new ParsePosition(0));
    assertTrue(number instanceof Double);
    // parseBigDecimal == true;
    // parseIntegerOnly == true;
    // parseBigDecimal take precedence of parseBigInteger
    form.setParseBigDecimal(true);
    form.setParseIntegerOnly(true);
    number = form.parse("-0", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    number = form.parse("-0.0", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    number = form.parse("12.4", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    // When parseBigDecimal is set to false, no matter how massive the
    // mantissa part of a number is, the number will be parsed into Double
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    number = form.parse("9,223,372,036,854,775,808.00", new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("9.223372036854776E18", number.toString());
    number = form.parse("-92,233,720,368,547,758,080.00", new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("-9.223372036854776E19", number.toString());
    // When parseBigDecimal is set to true, if mantissa part of number
    // exceeds Long.MAX_VALUE, the number will be parsed into BigDecimal
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    form.setParseBigDecimal(true);
    number = form.parse("9,223,372,036,854,775,808.00", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    assertEquals(9.223372036854776E18, number.doubleValue(), 0);
    number = form.parse("-92,233,720,368,547,758,080.00", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    assertEquals(-9.223372036854776E19, number.doubleValue(), 0);
    // The minimum value of Long will be parsed to Long when parseBigDecimal
    // is not set
    ParsePosition pos = new ParsePosition(0);
    DecimalFormat df = new DecimalFormat();
    pos = new ParsePosition(0);
    Number nb = df.parse("" + Long.MIN_VALUE, pos);
    assertTrue(nb instanceof Double);
    // The maximum value of Long will be parsed to Long when parseBigDecimal
    // is set
    pos = new ParsePosition(0);
    df = new DecimalFormat();
    pos = new ParsePosition(0);
    nb = df.parse("" + Long.MAX_VALUE, pos);
    assertTrue(nb instanceof Double);
    // When parsing invalid string( which is neither consist of digits nor
    // NaN/Infinity), a null will be returned.
    pos = new ParsePosition(0);
    df = new DecimalFormat();
    try {
        nb = df.parse("invalid", pos);
        assertNull(nb);
    } catch (NullPointerException e) {
        fail("Should not throw NPE");
    }
}
#method_after
public void test_parse_returnType() {
    DecimalFormat form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    Number number = form.parse("23.1", new ParsePosition(0));
    assertTrue(number instanceof Double);
    // Test parsed object of type double when
    // parseBigDecimal is set to true
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    number = form.parse("23.1", new ParsePosition(0));
    assertTrue(number instanceof Double);
    form.setParseBigDecimal(true);
    number = form.parse("23.1", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    assertEquals(new BigDecimal("23.1"), number);
    // When parseIntegerOnly set to true, all numbers will be parsed
    // into Long unless the value is out of the bound of Long or
    // some special values such as NaN or Infinity.
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    form.setParseIntegerOnly(true);
    number = form.parse("23.1f", new ParsePosition(0));
    assertTrue(number instanceof Long);
    number = form.parse("23.0", new ParsePosition(0));
    assertTrue(number instanceof Long);
    number = form.parse("-0.0", new ParsePosition(0));
    assertTrue(number instanceof Long);
    assertTrue(new Long(0).equals(number));
    // The last integers representable by long.
    number = form.parse("9223372036854775807.00", new ParsePosition(0));
    assertEquals(Long.class, number.getClass());
    number = form.parse("9223372036854775808.00", new ParsePosition(0));
    assertEquals(Double.class, number.getClass());
    // The first integers that need to be represented by double.
    number = form.parse("-9223372036854775808.00", new ParsePosition(0));
    assertEquals(Long.class, number.getClass());
    number = form.parse("-9223372036854775809.00", new ParsePosition(0));
    assertEquals(Double.class, number.getClass());
    // Even if parseIntegerOnly is set to true, NaN will be parsed to Double
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    form.setParseIntegerOnly(true);
    DecimalFormatSymbols symbols = new DecimalFormatSymbols();
    number = form.parse(symbols.getNaN(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    // Even if parseIntegerOnly is set to true, Infinity will still be
    // parsed to Double
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    form.setParseIntegerOnly(true);
    symbols = new DecimalFormatSymbols();
    number = form.parse(symbols.getInfinity(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    // ParseBigDecimal take precedence of parseBigInteger
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    form.setParseIntegerOnly(true);
    form.setParseBigDecimal(true);
    number = form.parse("23.1f", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    number = form.parse("23.0", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    number = form.parse("-92,233,720,368,547,758,080.00", new ParsePosition(0));
    assertFalse(number instanceof BigInteger);
    assertTrue(number instanceof BigDecimal);
    // Test whether the parsed object is of type float. (To be specific,
    // they are of type Double)
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    number = form.parse("23.1f", new ParsePosition(0));
    assertTrue(number instanceof Double);
    form.setParseBigDecimal(true);
    number = form.parse("23.1f", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    assertEquals(new BigDecimal("23.1"), number);
    // Integer will be parsed to Long, unless parseBigDecimal is set to true
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    number = form.parse("123", new ParsePosition(0));
    assertTrue(number instanceof Long);
    form.setParseBigDecimal(true);
    number = form.parse("123", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    assertEquals(new BigDecimal("123"), number);
    // NaN will be parsed to Double, no matter parseBigDecimal set or not.
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    symbols = new DecimalFormatSymbols();
    number = form.parse(symbols.getNaN() + "", new ParsePosition(0));
    assertTrue(number instanceof Double);
    form.setParseBigDecimal(true);
    number = form.parse(symbols.getNaN() + "", new ParsePosition(0));
    assertTrue(number instanceof Double);
    // Infinity will be parsed to Double, no matter parseBigDecimal set or
    // not.
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    symbols = new DecimalFormatSymbols();
    number = form.parse(symbols.getInfinity(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("Infinity", number.toString());
    // When set bigDecimal to true, the result of parsing infinity
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    symbols = new DecimalFormatSymbols();
    form.setParseBigDecimal(true);
    number = form.parse(symbols.getInfinity(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("Infinity", number.toString());
    // Negative infinity will be parsed to double no matter parseBigDecimal
    // set or not
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    symbols = new DecimalFormatSymbols();
    number = form.parse("-" + symbols.getInfinity(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("-Infinity", number.toString());
    // When set bigDecimal to true, the result of parsing minus infinity
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    symbols = new DecimalFormatSymbols();
    form.setParseBigDecimal(true);
    number = form.parse("-" + symbols.getInfinity(), new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("-Infinity", number.toString());
    // -0.0 will be parsed to different type according to the combination of
    // parseBigDecimal and parseIntegerOnly
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    // parseBigDecimal == true;
    // parseIntegerOnly == false;
    form.setParseBigDecimal(true);
    number = form.parse("-0", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    number = form.parse("-0.0", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    // parseBigDecimal == false;
    // parseIntegerOnly == true;
    form.setParseBigDecimal(false);
    form.setParseIntegerOnly(true);
    number = form.parse("-0", new ParsePosition(0));
    assertTrue(number instanceof Long);
    number = form.parse("-0.0", new ParsePosition(0));
    assertTrue(number instanceof Long);
    // parseBigDecimal == false;
    // parseIntegerOnly == false;
    form.setParseBigDecimal(false);
    form.setParseIntegerOnly(false);
    number = form.parse("-0", new ParsePosition(0));
    assertTrue(number instanceof Double);
    number = form.parse("-0.0", new ParsePosition(0));
    assertTrue(number instanceof Double);
    // parseBigDecimal == true;
    // parseIntegerOnly == true;
    // parseBigDecimal take precedence of parseBigInteger
    form.setParseBigDecimal(true);
    form.setParseIntegerOnly(true);
    number = form.parse("-0", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    number = form.parse("-0.0", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    number = form.parse("12.4", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    // When parseBigDecimal is set to false, no matter how massive the
    // mantissa part of a number is, the number will be parsed into Double
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    number = form.parse("9,223,372,036,854,775,808.00", new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("9.223372036854776E18", number.toString());
    number = form.parse("-92,233,720,368,547,758,080.00", new ParsePosition(0));
    assertTrue(number instanceof Double);
    assertEquals("-9.223372036854776E19", number.toString());
    // When parseBigDecimal is set to true, if mantissa part of number
    // exceeds Long.MAX_VALUE, the number will be parsed into BigDecimal
    form = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    form.setParseBigDecimal(true);
    number = form.parse("9,223,372,036,854,775,808.00", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    assertEquals(9.223372036854776E18, number.doubleValue(), 0);
    number = form.parse("-92,233,720,368,547,758,080.00", new ParsePosition(0));
    assertTrue(number instanceof BigDecimal);
    assertEquals(-9.223372036854776E19, number.doubleValue(), 0);
    // The minimum value of Long will be parsed to Long when parseBigDecimal
    // is not set
    ParsePosition pos = new ParsePosition(0);
    DecimalFormat df = new DecimalFormat();
    pos = new ParsePosition(0);
    Number nb = df.parse("" + Long.MIN_VALUE, pos);
    assertTrue(nb instanceof Long);
    // The maximum value of Long will be parsed to Long when parseBigDecimal
    // is set
    pos = new ParsePosition(0);
    df = new DecimalFormat();
    pos = new ParsePosition(0);
    nb = df.parse("" + Long.MAX_VALUE, pos);
    assertTrue(nb instanceof Long);
    // When parsing invalid string( which is neither consist of digits nor
    // NaN/Infinity), a null will be returned.
    pos = new ParsePosition(0);
    df = new DecimalFormat();
    try {
        nb = df.parse("invalid", pos);
        assertNull(nb);
    } catch (NullPointerException e) {
        fail("Should not throw NPE");
    }
}
#end_block

#method_before
public void test_setPositivePrefix() throws Exception {
    DecimalFormat format = new DecimalFormat();
    assertEquals("", format.getPositivePrefix());
    format.setPositivePrefix("PosPrf");
    assertEquals("PosPrf", format.getPositivePrefix());
    assertTrue(format.parse("PosPrf123.45").doubleValue() == 123.45);
    format.setPositivePrefix("");
    assertEquals("", format.getPositivePrefix());
    format.setPositivePrefix(null);
    assertNotNull(format.getPositivePrefix());
}
#method_after
public void test_setPositivePrefix() throws Exception {
    DecimalFormat format = new DecimalFormat();
    assertEquals("", format.getPositivePrefix());
    format.setPositivePrefix("PosPrf");
    assertEquals("PosPrf", format.getPositivePrefix());
    assertTrue(format.parse("PosPrf123.45").doubleValue() == 123.45);
    format.setPositivePrefix("");
    assertEquals("", format.getPositivePrefix());
    try {
        format.setPositivePrefix(null);
        fail();
    } catch (NullPointerException expected) {
    }
    assertNotNull(format.getPositivePrefix());
}
#end_block

#method_before
public void test_setPositiveSuffix() throws Exception {
    DecimalFormat format = new DecimalFormat();
    assertEquals("", format.getPositiveSuffix());
    format.setPositiveSuffix("PosSfx");
    assertEquals("PosSfx", format.getPositiveSuffix());
    assertTrue(format.parse("123.45PosSfx").doubleValue() == 123.45);
    format.setPositiveSuffix("");
    assertEquals("", format.getPositiveSuffix());
    format.setPositiveSuffix(null);
    assertNotNull(format.getPositiveSuffix());
}
#method_after
public void test_setPositiveSuffix() throws Exception {
    DecimalFormat format = new DecimalFormat();
    assertEquals("", format.getPositiveSuffix());
    format.setPositiveSuffix("PosSfx");
    assertEquals("PosSfx", format.getPositiveSuffix());
    assertTrue(format.parse("123.45PosSfx").doubleValue() == 123.45);
    format.setPositiveSuffix("");
    assertEquals("", format.getPositiveSuffix());
    try {
        format.setPositiveSuffix(null);
        fail();
    } catch (NullPointerException expected) {
    }
    assertNotNull(format.getPositiveSuffix());
}
#end_block

#method_before
public void test_setNegativePrefix() throws Exception {
    DecimalFormat format = new DecimalFormat();
    assertEquals("-", format.getNegativePrefix());
    format.setNegativePrefix("NegPrf");
    assertEquals("NegPrf", format.getNegativePrefix());
    assertTrue(format.parse("NegPrf123.45").doubleValue() == -123.45);
    format.setNegativePrefix("");
    assertEquals("", format.getNegativePrefix());
    format.setNegativePrefix(null);
    assertNotNull(format.getNegativePrefix());
}
#method_after
public void test_setNegativePrefix() throws Exception {
    DecimalFormat format = new DecimalFormat();
    assertEquals("-", format.getNegativePrefix());
    format.setNegativePrefix("NegPrf");
    assertEquals("NegPrf", format.getNegativePrefix());
    assertTrue(format.parse("NegPrf123.45").doubleValue() == -123.45);
    format.setNegativePrefix("");
    assertEquals("", format.getNegativePrefix());
    try {
        format.setNegativePrefix(null);
        fail();
    } catch (NullPointerException expected) {
    }
    assertNotNull(format.getNegativePrefix());
}
#end_block

#method_before
public void test_setNegativeSuffix() throws Exception {
    DecimalFormat format = new DecimalFormat();
    assertEquals("", format.getNegativeSuffix());
    format.setNegativeSuffix("NegSfx");
    assertEquals("NegSfx", format.getNegativeSuffix());
    assertTrue(format.parse("123.45NegSfx").doubleValue() == -123.45);
    format.setNegativeSuffix("");
    assertEquals("", format.getNegativeSuffix());
    format.setNegativeSuffix(null);
    assertNotNull(format.getNegativeSuffix());
}
#method_after
public void test_setNegativeSuffix() throws Exception {
    DecimalFormat format = new DecimalFormat();
    assertEquals("", format.getNegativeSuffix());
    format.setNegativeSuffix("NegSfx");
    assertEquals("NegSfx", format.getNegativeSuffix());
    assertTrue(format.parse("123.45NegSfx").doubleValue() == -123.45);
    format.setNegativeSuffix("");
    assertEquals("", format.getNegativeSuffix());
    try {
        format.setNegativeSuffix(null);
        fail();
    } catch (NullPointerException expected) {
    }
    assertNotNull(format.getNegativeSuffix());
}
#end_block

#method_before
public void testConstructor_string() {
    // Test for method java.text.DecimalFormat(java.lang.String)
    // the constructor form that specifies a pattern is equal to the form
    // constructed with no pattern and applying that pattern using the
    // applyPattern call
    DecimalFormat format = new DecimalFormat("'$'0000.0000");
    DecimalFormat format1 = new DecimalFormat();
    format1.applyPattern("'$'0000.0000");
    assertTrue("Constructed format did not match applied format object", format.equals(format1));
    new DecimalFormat("####.##");
    new DecimalFormat("######.######");
    new DecimalFormat("000000.000000");
    new DecimalFormat("######.000000");
    new DecimalFormat("000000.######");
    new DecimalFormat(" ###.###");
    new DecimalFormat("$#####.######");
    new DecimalFormat("$$####.######");
    new DecimalFormat("%#,##,###,####");
    new DecimalFormat("#,##0.00;(#,##0.00)");
    try {
        new DecimalFormat(null);
    } catch (NullPointerException unexpected) {
        fail();
    }
    try {
        new DecimalFormat("%#,##,###,####'");
        fail();
    } catch (IllegalArgumentException expected) {
    }
    try {
        new DecimalFormat("#.##0.00");
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#method_after
public void testConstructor_string() {
    // Test for method java.text.DecimalFormat(java.lang.String)
    // the constructor form that specifies a pattern is equal to the form
    // constructed with no pattern and applying that pattern using the
    // applyPattern call
    DecimalFormat format = new DecimalFormat("'$'0000.0000");
    DecimalFormat format1 = new DecimalFormat();
    format1.applyPattern("'$'0000.0000");
    assertTrue("Constructed format did not match applied format object", format.equals(format1));
    new DecimalFormat("####.##");
    new DecimalFormat("######.######");
    new DecimalFormat("000000.000000");
    new DecimalFormat("######.000000");
    new DecimalFormat("000000.######");
    new DecimalFormat(" ###.###");
    new DecimalFormat("$#####.######");
    new DecimalFormat("$$####.######");
    new DecimalFormat("%#,##,###,####");
    new DecimalFormat("#,##0.00;(#,##0.00)");
    try {
        new DecimalFormat(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        new DecimalFormat("%#,##,###,####'");
        fail();
    } catch (IllegalArgumentException expected) {
    }
    try {
        new DecimalFormat("#.##0.00");
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#end_block

#method_before
public void testConstructor_stringAndSymbols() {
    // case 1: Try to construct object using correct pattern and format
    // symbols.
    DecimalFormatSymbols dfs = new DecimalFormatSymbols(Locale.CANADA);
    DecimalFormat format1 = new DecimalFormat("'$'1000.0000", dfs);
    DecimalFormat format2 = new DecimalFormat();
    format2.applyPattern("'$'1000.0000");
    format2.setDecimalFormatSymbols(dfs);
    assertTrue("Constructed format did not match applied format object", format2.equals(format1));
    assertTrue("Constructed format did not match applied format object", !format1.equals(new DecimalFormat("'$'1000.0000", new DecimalFormatSymbols(Locale.CHINA))));
    // case 2: Try to construct object using null arguments.
    try {
        new DecimalFormat("'$'1000.0000", (DecimalFormatSymbols) null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        new DecimalFormat(null, new DecimalFormatSymbols());
    } catch (NullPointerException unexpected) {
        fail();
    }
    try {
        new DecimalFormat(null, (DecimalFormatSymbols) null);
        fail();
    } catch (NullPointerException expected) {
    }
    // case 3: Try to construct object using incorrect pattern.
    try {
        new DecimalFormat("$'", new DecimalFormatSymbols());
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#method_after
public void testConstructor_stringAndSymbols() {
    // case 1: Try to construct object using correct pattern and format
    // symbols.
    DecimalFormatSymbols dfs = new DecimalFormatSymbols(Locale.CANADA);
    DecimalFormat format1 = new DecimalFormat("'$'1000.0000", dfs);
    DecimalFormat format2 = new DecimalFormat();
    format2.applyPattern("'$'1000.0000");
    format2.setDecimalFormatSymbols(dfs);
    assertTrue("Constructed format did not match applied format object", format2.equals(format1));
    assertTrue("Constructed format did not match applied format object", !format1.equals(new DecimalFormat("'$'1000.0000", new DecimalFormatSymbols(Locale.CHINA))));
    // case 2: Try to construct object using null arguments.
    try {
        new DecimalFormat("'$'1000.0000", (DecimalFormatSymbols) null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        new DecimalFormat(null, new DecimalFormatSymbols());
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        new DecimalFormat(null, (DecimalFormatSymbols) null);
        fail();
    } catch (NullPointerException expected) {
    }
    // case 3: Try to construct object using incorrect pattern.
    try {
        new DecimalFormat("$'", new DecimalFormatSymbols());
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#end_block

#method_before
public void test_applyPattern() {
    DecimalFormat format = new DecimalFormat("#.#");
    assertEquals("Wrong pattern 1", "0.#", format.toPattern());
    format = new DecimalFormat("#.");
    assertEquals("Wrong pattern 2", "0.", format.toPattern());
    format = new DecimalFormat("#");
    assertEquals("Wrong pattern 3", "0", format.toPattern());
    format = new DecimalFormat(".#");
    assertEquals("Wrong pattern 4", "#.0", format.toPattern());
    // Regression for HARMONY-6485
    format = new DecimalFormat();
    format.setMinimumIntegerDigits(0);
    format.setMinimumFractionDigits(0);
    format.setMaximumFractionDigits(0);
    format.applyPattern("00.0#");
    assertEquals("Minimum integer digits not set", 2, format.getMinimumIntegerDigits());
    assertEquals("Minimum fraction digits not set", 1, format.getMinimumFractionDigits());
    assertEquals("Maximum fraction digits not set", 2, format.getMaximumFractionDigits());
    try {
        format.applyPattern(null);
    } catch (NullPointerException unexpected) {
        fail();
    }
    try {
        format.applyPattern("%#,##,###,####'");
        fail();
    } catch (IllegalArgumentException expected) {
    }
    try {
        format.applyPattern("#.##0.00");
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#method_after
public void test_applyPattern() {
    DecimalFormat format = new DecimalFormat("#.#");
    assertEquals("Wrong pattern 1", "0.#", format.toPattern());
    format = new DecimalFormat("#.");
    assertEquals("Wrong pattern 2", "0.", format.toPattern());
    format = new DecimalFormat("#");
    assertEquals("Wrong pattern 3", "0", format.toPattern());
    format = new DecimalFormat(".#");
    assertEquals("Wrong pattern 4", "#.0", format.toPattern());
    // Regression for HARMONY-6485
    format = new DecimalFormat();
    format.setMinimumIntegerDigits(0);
    format.setMinimumFractionDigits(0);
    format.setMaximumFractionDigits(0);
    format.applyPattern("00.0#");
    assertEquals("Minimum integer digits not set", 2, format.getMinimumIntegerDigits());
    assertEquals("Minimum fraction digits not set", 1, format.getMinimumFractionDigits());
    assertEquals("Maximum fraction digits not set", 2, format.getMaximumFractionDigits());
    try {
        format.applyPattern(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        format.applyPattern("%#,##,###,####'");
        fail();
    } catch (IllegalArgumentException expected) {
    }
    try {
        format.applyPattern("#.##0.00");
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#end_block

#method_before
public void test_applyLocalizedPattern() throws Exception {
    DecimalFormat format = new DecimalFormat();
    // case 1: Try to apply correct variants of pattern.
    format.applyLocalizedPattern("#.#");
    assertEquals("Wrong pattern 1", "0.#", format.toLocalizedPattern());
    format.applyLocalizedPattern("#.");
    assertEquals("Wrong pattern 2", "0.", format.toLocalizedPattern());
    format.applyLocalizedPattern("#");
    assertEquals("Wrong pattern 3", "0", format.toLocalizedPattern());
    format.applyLocalizedPattern(".#");
    assertEquals("Wrong pattern 4", "#.0", format.toLocalizedPattern());
    // case 2: Try to apply malformed patten.
    try {
        format.applyLocalizedPattern("'#,#:#0.0#;(#)");
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // case 3: Try to apply null pattern.
    try {
        format.applyLocalizedPattern((String) null);
    } catch (NullPointerException unexpected) {
        fail();
    }
}
#method_after
public void test_applyLocalizedPattern() throws Exception {
    DecimalFormat format = new DecimalFormat();
    // case 1: Try to apply correct variants of pattern.
    format.applyLocalizedPattern("#.#");
    assertEquals("Wrong pattern 1", "0.#", format.toLocalizedPattern());
    format.applyLocalizedPattern("#.");
    assertEquals("Wrong pattern 2", "0.", format.toLocalizedPattern());
    format.applyLocalizedPattern("#");
    assertEquals("Wrong pattern 3", "0", format.toLocalizedPattern());
    format.applyLocalizedPattern(".#");
    assertEquals("Wrong pattern 4", "#.0", format.toLocalizedPattern());
    // case 2: Try to apply malformed patten.
    try {
        format.applyLocalizedPattern("'#,#:#0.0#;(#)");
        fail();
    } catch (IllegalArgumentException expected) {
    }
    // case 3: Try to apply null pattern.
    try {
        format.applyLocalizedPattern((String) null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_formatDouble_minimumFractionDigits() {
    DecimalFormat df = new DecimalFormat("###0.##", new DecimalFormatSymbols(Locale.US));
    df.setMinimumFractionDigits(4);
    assertEquals(4, df.getMinimumFractionDigits());
    assertEquals("1.2300", df.format(1.23));
    df.setMaximumFractionDigits(2);
    assertEquals(2, df.getMinimumFractionDigits());
    assertEquals("456.0000", df.format(456));
    df = new DecimalFormat("##0.#", new DecimalFormatSymbols(Locale.US));
    df.setMinimumFractionDigits(30);
    assertEquals("0.000000000000000000000000000000", df.format(0.0));
    assertEquals("-0.000000000000000000000000000000", df.format(-0.0));
    assertEquals("1.000000000000000000000000000000", df.format(1.0));
    assertEquals("-1.000000000000000000000000000000", df.format(-1.0));
}
#method_after
public void test_formatDouble_minimumFractionDigits() {
    DecimalFormat df = new DecimalFormat("###0.##", new DecimalFormatSymbols(Locale.US));
    df.setMinimumFractionDigits(4);
    assertEquals(4, df.getMinimumFractionDigits());
    assertEquals("1.2300", df.format(1.23));
    df.setMaximumFractionDigits(2);
    assertEquals(2, df.getMinimumFractionDigits());
    assertEquals("456.00", df.format(456));
    df = new DecimalFormat("##0.#", new DecimalFormatSymbols(Locale.US));
    df.setMinimumFractionDigits(30);
    assertEquals("0.000000000000000000000000000000", df.format(0.0));
    assertEquals("-0.000000000000000000000000000000", df.format(-0.0));
    assertEquals("1.000000000000000000000000000000", df.format(1.0));
    assertEquals("-1.000000000000000000000000000000", df.format(-1.0));
}
#end_block

#method_before
// This test serves as a regression test for Android's behavior.
// There are many patterns that produce different output from the RI but are sometimes the
public void test_formatDouble_scientificNotation() {
    FormatTester formatTester = new FormatTester();
    final DecimalFormatSymbols dfs = new DecimalFormatSymbols(Locale.US);
    DecimalFormat df = new DecimalFormat("00.0#E0", dfs);
    // ["00.0#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=2,
    // maxFractionDigits=2,minIntegerDigits=2,minFractionDigits=1,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (2) + "max fractional digits (2) == 4
    formatTester.format(df, "0.00E0", 0.0);
    formatTester.format(df, "10.0E-1", 1.0);
    formatTester.format(df, "12.0E0", 12.0);
    formatTester.format(df, "12.3E1", 123.0);
    formatTester.format(df, "12.34E2", 1234.0);
    formatTester.format(df, "12.35E3", 12346.0);
    formatTester.format(df, "10.0E4", 99999.0);
    formatTester.format(df, "12.0E-1", 1.2);
    formatTester.format(df, "12.3E0", 12.3);
    formatTester.format(df, "12.34E1", 123.4);
    formatTester.format(df, "12.35E2", 1234.6);
    formatTester.format(df, "10.0E3", 9999.9);
    formatTester.format(df, "10.0E-2", 0.1);
    formatTester.format(df, "12.0E-2", 0.12);
    formatTester.format(df, "12.3E-2", 0.123);
    formatTester.format(df, "12.34E-2", 0.1234);
    formatTester.format(df, "12.35E-2", 0.12346);
    formatTester.format(df, "10.0E-1", 0.99999);
    formatTester.format(df, "-10.0E-1", -1.0);
    formatTester.format(df, "-12.0E0", -12.0);
    formatTester.format(df, "-12.3E1", -123.0);
    formatTester.format(df, "-12.34E2", -1234.0);
    formatTester.format(df, "-12.35E3", -12346.0);
    formatTester.format(df, "-10.0E4", -99999.0);
    df = new DecimalFormat("#00.0##E0", dfs);
    // ["#00.0##E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=3,
    // maxFractionDigits=3,minIntegerDigits=2,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (3).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (2) + "max fractional digits (3) == 5
    formatTester.format(df, "100E-3", 0.1);
    formatTester.format(df, "120E-3", 0.12);
    formatTester.format(df, "123E-3", 0.123);
    formatTester.format(df, "123.4E-3", 0.1234);
    formatTester.format(df, "123.46E-3", 0.1234567);
    formatTester.format(df, "10.0E-3", 0.01);
    formatTester.format(df, "12.0E-3", 0.012);
    formatTester.format(df, "12.3E-3", 0.0123);
    formatTester.format(df, "12.34E-3", 0.01234);
    formatTester.format(df, "12.346E-3", 0.01234567);
    formatTester.format(df, "10.0E-4", 0.001);
    formatTester.format(df, "12.0E-4", 0.0012);
    formatTester.format(df, "12.3E-4", 0.00123);
    formatTester.format(df, "12.34E-4", 0.001234);
    formatTester.format(df, "12.346E-4", 0.001234567);
    formatTester.format(df, "100E-6", 0.0001);
    formatTester.format(df, "120E-6", 0.00012);
    formatTester.format(df, "123E-6", 0.000123);
    formatTester.format(df, "123.4E-6", 0.0001234);
    formatTester.format(df, "123.46E-6", 0.0001234567);
    formatTester.format(df, "0.00E0", 0.0);
    formatTester.format(df, "10.0E-1", 1.0);
    formatTester.format(df, "12.0E0", 12.0);
    formatTester.format(df, "123E0", 123.0);
    formatTester.format(df, "12.34E2", 1234.0);
    formatTester.format(df, "12.345E3", 12345.0);
    formatTester.format(df, "123.46E3", 123456.0);
    formatTester.format(df, "12.346E5", 1234567.0);
    formatTester.format(df, "12.346E6", 12345678.0);
    formatTester.format(df, "100E6", 99999999.0);
    df = new DecimalFormat("#.0E0", dfs);
    // ["#.0E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=1,
    // maxFractionDigits=1,minIntegerDigits=0,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (1).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (0) + "max fractional digits (1) == 1
    formatTester.format(df, "0E0", 0.0);
    formatTester.format(df, "1E0", 1.0);
    formatTester.format(df, "1E1", 12.0);
    formatTester.format(df, "1E2", 123.0);
    formatTester.format(df, "1E3", 1234.0);
    formatTester.format(df, "1E4", 9999.0);
    df = new DecimalFormat("0.E0", dfs);
    // ["0.E0",isDecimalSeparatorAlwaysShown=true,groupingSize=0,multiplier=1,negativePrefix=-,
    // negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=1,maxFractionDigits=0,
    // minIntegerDigits=1,minFractionDigits=0,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (0) == 1
    formatTester.format(df, "0.E0", 0.0);
    formatTester.format(df, "1.E0", 1.0);
    formatTester.format(df, "1.E1", 12.0);
    formatTester.format(df, "1.E2", 123.0);
    formatTester.format(df, "1.E3", 1234.0);
    formatTester.format(df, "1.E4", 9999.0);
    df = new DecimalFormat("##0.00#E0", dfs);
    // ["##0.00#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=3,
    // maxFractionDigits=3,minIntegerDigits=1,minFractionDigits=2,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (3).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (3) == 4
    formatTester.format(df, "100E-3", 0.1);
    formatTester.format(df, "123.5E-3", 0.1234567);
    formatTester.format(df, "1.00E0", 0.9999999);
    formatTester.format(df, "10.0E-3", 0.01);
    formatTester.format(df, "12.35E-3", 0.01234567);
    formatTester.format(df, "100E-3", 0.09999999);
    formatTester.format(df, "1.00E-3", 0.001);
    formatTester.format(df, "1.235E-3", 0.001234567);
    formatTester.format(df, "10.0E-3", 0.009999999);
    formatTester.format(df, "100E-6", 0.0001);
    formatTester.format(df, "123.5E-6", 0.0001234567);
    formatTester.format(df, "1.00E-3", 0.0009999999);
    df = new DecimalFormat("###0.00#E0", dfs);
    // ["###0.00#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=4,
    // maxFractionDigits=3,minIntegerDigits=1,minFractionDigits=2,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (4).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (3) == 4
    formatTester.format(df, "1000E-4", 0.1);
    formatTester.format(df, "1235E-4", 0.12345678);
    formatTester.format(df, "1.00E0", 0.99999999);
    formatTester.format(df, "100E-4", 0.01);
    formatTester.format(df, "123.5E-4", 0.012345678);
    formatTester.format(df, "1000E-4", 0.099999999);
    formatTester.format(df, "10.0E-4", 0.001);
    formatTester.format(df, "12.35E-4", 0.0012345678);
    formatTester.format(df, "100E-4", 0.0099999999);
    formatTester.format(df, "1.00E-4", 0.0001);
    formatTester.format(df, "1.235E-4", 0.00012345678);
    formatTester.format(df, "10.0E-4", 0.00099999999);
    formatTester.format(df, "1000E-8", 0.00001);
    formatTester.format(df, "1235E-8", 0.000012345678);
    formatTester.format(df, "1.00E-4", 0.000099999999);
    df = new DecimalFormat("###0.0#E0", dfs);
    // ["###0.0#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=4,
    // maxFractionDigits=2,minIntegerDigits=1,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (4).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (2) == 3
    formatTester.format(df, "1000E-4", 0.1);
    formatTester.format(df, "1230E-4", 0.1234567);
    formatTester.format(df, "1.0E0", 0.9999999);
    formatTester.format(df, "100E-4", 0.01);
    formatTester.format(df, "123E-4", 0.01234567);
    formatTester.format(df, "1000E-4", 0.09999999);
    formatTester.format(df, "10E-4", 0.001);
    formatTester.format(df, "12.3E-4", 0.001234567);
    formatTester.format(df, "100E-4", 0.009999999);
    formatTester.format(df, "1.0E-4", 0.0001);
    formatTester.format(df, "1.23E-4", 0.0001234567);
    formatTester.format(df, "10E-4", 0.0009999999);
    formatTester.format(df, "1000E-8", 0.00001);
    formatTester.format(df, "1230E-8", 0.00001234567);
    formatTester.format(df, "1.0E-4", 0.00009999999);
    df = new DecimalFormat("##0.0E0", dfs);
    // ["##0.0E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=3,
    // maxFractionDigits=1,minIntegerDigits=1,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (3).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (1) == 2
    formatTester.format(df, "0.0E0", 0.0);
    formatTester.format(df, "1.0E0", 1.0);
    formatTester.format(df, "12E0", 12.0);
    formatTester.format(df, "120E0", 123.0);
    formatTester.format(df, "1.2E3", 1234.0);
    formatTester.format(df, "12E3", 12346.0);
    formatTester.format(df, "100E3", 99999.0);
    formatTester.format(df, "1.0E6", 999999.0);
    df = new DecimalFormat("0.#E0", dfs);
    // ["0.#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=1,
    // maxFractionDigits=1,minIntegerDigits=1,minFractionDigits=0,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (1) == 2
    formatTester.format(df, "0E0", 0.0);
    formatTester.format(df, "1E0", 1.0);
    formatTester.format(df, "1.2E1", 12.0);
    formatTester.format(df, "1.2E2", 123.0);
    formatTester.format(df, "1.2E3", 1234.0);
    formatTester.format(df, "1E4", 9999.0);
    df = new DecimalFormat(".0E0", dfs);
    // [".0E0",isDecimalSeparatorAlwaysShown=true,groupingSize=0,multiplier=1,negativePrefix=-,
    // negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=0,maxFractionDigits=1,
    // minIntegerDigits=0,minFractionDigits=1,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (0) + "max fractional digits (1) == 2
    formatTester.format(df, ".0E0", 0.0);
    formatTester.format(df, ".1E1", 1.0);
    formatTester.format(df, ".1E2", 12.0);
    formatTester.format(df, ".1E3", 123.0);
    formatTester.format(df, ".1E4", 1234.0);
    formatTester.format(df, ".1E5", 9999.0);
    formatTester.throwFailures();
}
#method_after
// This test serves as a regression test for Android's behavior.
// There are many patterns that produce different output from the RI but are sometimes the
public void test_formatDouble_scientificNotation() {
    FormatTester formatTester = new FormatTester();
    final DecimalFormatSymbols dfs = new DecimalFormatSymbols(Locale.US);
    DecimalFormat df = new DecimalFormat("00.0#E0", dfs);
    // ["00.0#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=2,
    // maxFractionDigits=2,minIntegerDigits=2,minFractionDigits=1,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (2) + "max fractional digits (2) == 4
    formatTester.format(df, "0.00E0", 0.0);
    formatTester.format(df, "10.0E-1", 1.0);
    formatTester.format(df, "12.0E0", 12.0);
    formatTester.format(df, "12.3E1", 123.0);
    formatTester.format(df, "12.34E2", 1234.0);
    formatTester.format(df, "12.35E3", 12346.0);
    formatTester.format(df, "10.0E4", 99999.0);
    formatTester.format(df, "12.0E-1", 1.2);
    formatTester.format(df, "12.3E0", 12.3);
    formatTester.format(df, "12.34E1", 123.4);
    formatTester.format(df, "12.35E2", 1234.6);
    formatTester.format(df, "10.0E3", 9999.9);
    formatTester.format(df, "10.0E-2", 0.1);
    formatTester.format(df, "12.0E-2", 0.12);
    formatTester.format(df, "12.3E-2", 0.123);
    formatTester.format(df, "12.34E-2", 0.1234);
    formatTester.format(df, "12.35E-2", 0.12346);
    formatTester.format(df, "10.0E-1", 0.99999);
    formatTester.format(df, "-10.0E-1", -1.0);
    formatTester.format(df, "-12.0E0", -12.0);
    formatTester.format(df, "-12.3E1", -123.0);
    formatTester.format(df, "-12.34E2", -1234.0);
    formatTester.format(df, "-12.35E3", -12346.0);
    formatTester.format(df, "-10.0E4", -99999.0);
    df = new DecimalFormat("#00.0##E0", dfs);
    // ["#00.0##E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=3,
    // maxFractionDigits=3,minIntegerDigits=2,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (3).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (2) + "max fractional digits (3) == 5
    formatTester.format(df, "100E-3", 0.1);
    formatTester.format(df, "120E-3", 0.12);
    formatTester.format(df, "123E-3", 0.123);
    formatTester.format(df, "123.4E-3", 0.1234);
    formatTester.format(df, "123.46E-3", 0.1234567);
    formatTester.format(df, "10.0E-3", 0.01);
    formatTester.format(df, "12.0E-3", 0.012);
    formatTester.format(df, "12.3E-3", 0.0123);
    formatTester.format(df, "12.34E-3", 0.01234);
    formatTester.format(df, "12.346E-3", 0.01234567);
    formatTester.format(df, "1.00E-3", 0.001);
    formatTester.format(df, "1.20E-3", 0.0012);
    formatTester.format(df, "1.23E-3", 0.00123);
    formatTester.format(df, "1.234E-3", 0.001234);
    formatTester.format(df, "1.2346E-3", 0.001234567);
    formatTester.format(df, "100E-6", 0.0001);
    formatTester.format(df, "120E-6", 0.00012);
    formatTester.format(df, "123E-6", 0.000123);
    formatTester.format(df, "123.4E-6", 0.0001234);
    formatTester.format(df, "123.46E-6", 0.0001234567);
    formatTester.format(df, "0.00E0", 0.0);
    formatTester.format(df, "1.00E0", 1.0);
    formatTester.format(df, "12.0E0", 12.0);
    formatTester.format(df, "123E0", 123.0);
    formatTester.format(df, "1.234E3", 1234.0);
    formatTester.format(df, "12.345E3", 12345.0);
    formatTester.format(df, "123.46E3", 123456.0);
    formatTester.format(df, "1.2346E6", 1234567.0);
    formatTester.format(df, "12.346E6", 12345678.0);
    formatTester.format(df, "100E6", 99999999.0);
    df = new DecimalFormat("#.0E0", dfs);
    // ["#.0E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=1,
    // maxFractionDigits=1,minIntegerDigits=0,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (1).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (0) + "max fractional digits (1) == 1
    formatTester.format(df, "0E0", 0.0);
    formatTester.format(df, "1E0", 1.0);
    formatTester.format(df, "1E1", 12.0);
    formatTester.format(df, "1E2", 123.0);
    formatTester.format(df, "1E3", 1234.0);
    formatTester.format(df, "1E4", 9999.0);
    df = new DecimalFormat("0.E0", dfs);
    // ["0.E0",isDecimalSeparatorAlwaysShown=true,groupingSize=0,multiplier=1,negativePrefix=-,
    // negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=1,maxFractionDigits=0,
    // minIntegerDigits=1,minFractionDigits=0,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (0) == 1
    formatTester.format(df, "0.E0", 0.0);
    formatTester.format(df, "1.E0", 1.0);
    formatTester.format(df, "1.E1", 12.0);
    formatTester.format(df, "1.E2", 123.0);
    formatTester.format(df, "1.E3", 1234.0);
    formatTester.format(df, "1.E4", 9999.0);
    df = new DecimalFormat("##0.00#E0", dfs);
    // ["##0.00#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=3,
    // maxFractionDigits=3,minIntegerDigits=1,minFractionDigits=2,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (3).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (3) == 4
    formatTester.format(df, "100E-3", 0.1);
    formatTester.format(df, "123.5E-3", 0.1234567);
    formatTester.format(df, "1.00E0", 0.9999999);
    formatTester.format(df, "10.0E-3", 0.01);
    formatTester.format(df, "12.35E-3", 0.01234567);
    formatTester.format(df, "100E-3", 0.09999999);
    formatTester.format(df, "1.00E-3", 0.001);
    formatTester.format(df, "1.235E-3", 0.001234567);
    formatTester.format(df, "10.0E-3", 0.009999999);
    formatTester.format(df, "100E-6", 0.0001);
    formatTester.format(df, "123.5E-6", 0.0001234567);
    formatTester.format(df, "1.00E-3", 0.0009999999);
    df = new DecimalFormat("###0.00#E0", dfs);
    // ["###0.00#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=4,
    // maxFractionDigits=3,minIntegerDigits=1,minFractionDigits=2,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (4).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (3) == 4
    formatTester.format(df, "1000E-4", 0.1);
    formatTester.format(df, "1235E-4", 0.12345678);
    formatTester.format(df, "1.00E0", 0.99999999);
    formatTester.format(df, "100E-4", 0.01);
    formatTester.format(df, "123.5E-4", 0.012345678);
    formatTester.format(df, "1000E-4", 0.099999999);
    formatTester.format(df, "10.0E-4", 0.001);
    formatTester.format(df, "12.35E-4", 0.0012345678);
    formatTester.format(df, "100E-4", 0.0099999999);
    formatTester.format(df, "1.00E-4", 0.0001);
    formatTester.format(df, "1.235E-4", 0.00012345678);
    formatTester.format(df, "10.0E-4", 0.00099999999);
    formatTester.format(df, "1000E-8", 0.00001);
    formatTester.format(df, "1235E-8", 0.000012345678);
    formatTester.format(df, "1.00E-4", 0.000099999999);
    df = new DecimalFormat("###0.0#E0", dfs);
    // ["###0.0#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=4,
    // maxFractionDigits=2,minIntegerDigits=1,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (4).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (2) == 3
    formatTester.format(df, "1000E-4", 0.1);
    formatTester.format(df, "1230E-4", 0.1234567);
    formatTester.format(df, "1.0E0", 0.9999999);
    formatTester.format(df, "100E-4", 0.01);
    formatTester.format(df, "123E-4", 0.01234567);
    formatTester.format(df, "1000E-4", 0.09999999);
    formatTester.format(df, "10E-4", 0.001);
    formatTester.format(df, "12.3E-4", 0.001234567);
    formatTester.format(df, "100E-4", 0.009999999);
    formatTester.format(df, "1.0E-4", 0.0001);
    formatTester.format(df, "1.23E-4", 0.0001234567);
    formatTester.format(df, "10E-4", 0.0009999999);
    formatTester.format(df, "1000E-8", 0.00001);
    formatTester.format(df, "1230E-8", 0.00001234567);
    formatTester.format(df, "1.0E-4", 0.00009999999);
    df = new DecimalFormat("##0.0E0", dfs);
    // ["##0.0E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=3,
    // maxFractionDigits=1,minIntegerDigits=1,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (3).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (1) == 2
    formatTester.format(df, "0.0E0", 0.0);
    formatTester.format(df, "1.0E0", 1.0);
    formatTester.format(df, "12E0", 12.0);
    formatTester.format(df, "120E0", 123.0);
    formatTester.format(df, "1.2E3", 1234.0);
    formatTester.format(df, "12E3", 12346.0);
    formatTester.format(df, "100E3", 99999.0);
    formatTester.format(df, "1.0E6", 999999.0);
    df = new DecimalFormat("0.#E0", dfs);
    // ["0.#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=1,
    // maxFractionDigits=1,minIntegerDigits=1,minFractionDigits=0,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (1) == 2
    formatTester.format(df, "0E0", 0.0);
    formatTester.format(df, "1E0", 1.0);
    formatTester.format(df, "1.2E1", 12.0);
    formatTester.format(df, "1.2E2", 123.0);
    formatTester.format(df, "1.2E3", 1234.0);
    formatTester.format(df, "1E4", 9999.0);
    df = new DecimalFormat(".0E0", dfs);
    // [".0E0",isDecimalSeparatorAlwaysShown=true,groupingSize=0,multiplier=1,negativePrefix=-,
    // negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=0,maxFractionDigits=1,
    // minIntegerDigits=0,minFractionDigits=1,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (0) + "max fractional digits (1) == 2
    formatTester.format(df, ".0E0", 0.0);
    formatTester.format(df, ".1E1", 1.0);
    formatTester.format(df, ".1E2", 12.0);
    formatTester.format(df, ".1E3", 123.0);
    formatTester.format(df, ".1E4", 1234.0);
    formatTester.format(df, ".1E5", 9999.0);
    formatTester.throwFailures();
}
#end_block

#method_before
public void test_formatLong_minimumIntegerDigits() {
    DecimalFormat df = new DecimalFormat("###0.##", new DecimalFormatSymbols(Locale.US));
    df.setMinimumIntegerDigits(3);
    assertEquals(3, df.getMinimumIntegerDigits());
    assertEquals("012", df.format(12));
    df.setMaximumIntegerDigits(2);
    assertEquals(2, df.getMinimumIntegerDigits());
    assertEquals("000.7", df.format(0.7));
}
#method_after
public void test_formatLong_minimumIntegerDigits() {
    DecimalFormat df = new DecimalFormat("###0.##", new DecimalFormatSymbols(Locale.US));
    df.setMinimumIntegerDigits(3);
    assertEquals(3, df.getMinimumIntegerDigits());
    assertEquals("012", df.format(12));
    df.setMaximumIntegerDigits(2);
    assertEquals(2, df.getMinimumIntegerDigits());
    assertEquals("00.7", df.format(0.7));
}
#end_block

#method_before
public void test_formatLong_scientificNotation() {
    FormatTester formatTester = new FormatTester();
    final DecimalFormatSymbols dfs = new DecimalFormatSymbols(Locale.US);
    DecimalFormat df = new DecimalFormat("00.0#E0", dfs);
    // ["00.0#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=2,
    // maxFractionDigits=2,minIntegerDigits=2,minFractionDigits=1,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (2) + "max fractional digits (2) == 4
    formatTester.format(df, "0.00E0", 0);
    formatTester.format(df, "10.0E-1", 1);
    formatTester.format(df, "12.0E0", 12);
    formatTester.format(df, "12.3E1", 123);
    formatTester.format(df, "12.34E2", 1234);
    formatTester.format(df, "12.35E3", 12346);
    formatTester.format(df, "10.0E4", 99999);
    formatTester.format(df, "-10.0E-1", -1);
    formatTester.format(df, "-12.0E0", -12);
    formatTester.format(df, "-12.3E1", -123);
    formatTester.format(df, "-12.34E2", -1234);
    formatTester.format(df, "-12.35E3", -12346);
    formatTester.format(df, "-10.0E4", -99999);
    df = new DecimalFormat("##0.0E0", dfs);
    // ["##0.0E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=3,
    // maxFractionDigits=1,minIntegerDigits=1,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (3).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (1) == 2
    formatTester.format(df, "0.0E0", 0);
    formatTester.format(df, "1.0E0", 1);
    formatTester.format(df, "12E0", 12);
    formatTester.format(df, "120E0", 123);
    formatTester.format(df, "1.2E3", 1234);
    formatTester.format(df, "12E3", 12346);
    formatTester.format(df, "100E3", 99999);
    formatTester.format(df, "1.0E6", 999999);
    df = new DecimalFormat("#00.0##E0", dfs);
    // ["##0.0E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=3,
    // maxFractionDigits=1,minIntegerDigits=1,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (3).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (2) + "max fractional digits (3) == 5
    formatTester.format(df, "0.00E0", 0);
    formatTester.format(df, "10.0E-1", 1);
    formatTester.format(df, "12.0E0", 12);
    formatTester.format(df, "123E0", 123);
    formatTester.format(df, "12.34E2", 1234);
    formatTester.format(df, "12.345E3", 12345);
    formatTester.format(df, "123.46E3", 123456);
    formatTester.format(df, "12.346E5", 1234567);
    formatTester.format(df, "12.346E6", 12345678);
    formatTester.format(df, "100E6", 99999999);
    df = new DecimalFormat("#.0E0", dfs);
    // ["#.0E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=1,
    // maxFractionDigits=1,minIntegerDigits=0,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (1).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (0) + "max fractional digits (1) == 1
    formatTester.format(df, "0E0", 0);
    formatTester.format(df, "1E0", 1);
    formatTester.format(df, "1E1", 12);
    formatTester.format(df, "1E2", 123);
    formatTester.format(df, "1E3", 1234);
    formatTester.format(df, "1E4", 9999);
    df = new DecimalFormat("0.#E0", dfs);
    // ["0.#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=1,
    // maxFractionDigits=1,minIntegerDigits=1,minFractionDigits=0,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (1) == 2
    formatTester.format(df, "0E0", 0);
    formatTester.format(df, "1E0", 1);
    formatTester.format(df, "1.2E1", 12);
    formatTester.format(df, "1.2E2", 123);
    formatTester.format(df, "1.2E3", 1234);
    formatTester.format(df, "1E4", 9999);
    df = new DecimalFormat(".0E0", dfs);
    // [".0E0",isDecimalSeparatorAlwaysShown=true,groupingSize=0,multiplier=1,negativePrefix=-,
    // negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=0,maxFractionDigits=1,
    // minIntegerDigits=0,minFractionDigits=1,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (0) + "max fractional digits (1) == 1
    formatTester.format(df, ".0E0", 0);
    formatTester.format(df, ".1E1", 1);
    formatTester.format(df, ".1E2", 12);
    formatTester.format(df, ".1E3", 123);
    formatTester.format(df, ".1E4", 1234);
    formatTester.format(df, ".1E5", 9999);
    formatTester.throwFailures();
}
#method_after
public void test_formatLong_scientificNotation() {
    FormatTester formatTester = new FormatTester();
    final DecimalFormatSymbols dfs = new DecimalFormatSymbols(Locale.US);
    DecimalFormat df = new DecimalFormat("00.0#E0", dfs);
    // ["00.0#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=2,
    // maxFractionDigits=2,minIntegerDigits=2,minFractionDigits=1,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (2) + "max fractional digits (2) == 4
    formatTester.format(df, "0.00E0", 0);
    formatTester.format(df, "10.0E-1", 1);
    formatTester.format(df, "12.0E0", 12);
    formatTester.format(df, "12.3E1", 123);
    formatTester.format(df, "12.34E2", 1234);
    formatTester.format(df, "12.35E3", 12346);
    formatTester.format(df, "10.0E4", 99999);
    formatTester.format(df, "-10.0E-1", -1);
    formatTester.format(df, "-12.0E0", -12);
    formatTester.format(df, "-12.3E1", -123);
    formatTester.format(df, "-12.34E2", -1234);
    formatTester.format(df, "-12.35E3", -12346);
    formatTester.format(df, "-10.0E4", -99999);
    df = new DecimalFormat("##0.0E0", dfs);
    // ["##0.0E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=3,
    // maxFractionDigits=1,minIntegerDigits=1,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (3).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (1) == 2
    formatTester.format(df, "0.0E0", 0);
    formatTester.format(df, "1.0E0", 1);
    formatTester.format(df, "12E0", 12);
    formatTester.format(df, "120E0", 123);
    formatTester.format(df, "1.2E3", 1234);
    formatTester.format(df, "12E3", 12346);
    formatTester.format(df, "100E3", 99999);
    formatTester.format(df, "1.0E6", 999999);
    df = new DecimalFormat("#00.0##E0", dfs);
    // ["##0.0E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=3,
    // maxFractionDigits=1,minIntegerDigits=1,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (3).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (2) + "max fractional digits (3) == 5
    formatTester.format(df, "0.00E0", 0);
    formatTester.format(df, "1.00E0", 1);
    formatTester.format(df, "12.0E0", 12);
    formatTester.format(df, "123E0", 123);
    formatTester.format(df, "1.234E3", 1234);
    formatTester.format(df, "12.345E3", 12345);
    formatTester.format(df, "123.46E3", 123456);
    formatTester.format(df, "1.2346E6", 1234567);
    formatTester.format(df, "12.346E6", 12345678);
    formatTester.format(df, "100E6", 99999999);
    df = new DecimalFormat("#.0E0", dfs);
    // ["#.0E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=1,
    // maxFractionDigits=1,minIntegerDigits=0,minFractionDigits=1,grouping=false]
    // Because maximum integer digit count is set: The exponent must be a multiple of it (1).
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (0) + "max fractional digits (1) == 1
    formatTester.format(df, "0E0", 0);
    formatTester.format(df, "1E0", 1);
    formatTester.format(df, "1E1", 12);
    formatTester.format(df, "1E2", 123);
    formatTester.format(df, "1E3", 1234);
    formatTester.format(df, "1E4", 9999);
    df = new DecimalFormat("0.#E0", dfs);
    // ["0.#E0",isDecimalSeparatorAlwaysShown=false,groupingSize=0,multiplier=1,
    // negativePrefix=-,negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=1,
    // maxFractionDigits=1,minIntegerDigits=1,minFractionDigits=0,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (1) + "max fractional digits (1) == 2
    formatTester.format(df, "0E0", 0);
    formatTester.format(df, "1E0", 1);
    formatTester.format(df, "1.2E1", 12);
    formatTester.format(df, "1.2E2", 123);
    formatTester.format(df, "1.2E3", 1234);
    formatTester.format(df, "1E4", 9999);
    df = new DecimalFormat(".0E0", dfs);
    // [".0E0",isDecimalSeparatorAlwaysShown=true,groupingSize=0,multiplier=1,negativePrefix=-,
    // negativeSuffix=,positivePrefix=,positiveSuffix=,maxIntegerDigits=0,maxFractionDigits=1,
    // minIntegerDigits=0,minFractionDigits=1,grouping=false]
    // Because maximum integer digit was not explicitly set: The exponent can be any integer.
    // Scientific notation => use significant digit logic
    // '@' not present: Significant digits: Min: 1,
    // Max: "min integer digits" (0) + "max fractional digits (1) == 1
    formatTester.format(df, ".0E0", 0);
    formatTester.format(df, ".1E1", 1);
    formatTester.format(df, ".1E2", 12);
    formatTester.format(df, ".1E3", 123);
    formatTester.format(df, ".1E4", 1234);
    formatTester.format(df, ".1E5", 9999);
    formatTester.throwFailures();
}
#end_block

#method_before
public void test_parse_withParsePosition() {
    DecimalFormat format = (DecimalFormat) NumberFormat.getNumberInstance(Locale.ENGLISH);
    ParsePosition pos = new ParsePosition(0);
    Number result = format.parse("9223372036854775807", pos);
    assertTrue("Wrong result type for Long.MAX_VALUE", result.getClass() == Double.class);
    assertTrue("Wrong result Long.MAX_VALUE", result.longValue() == Long.MAX_VALUE);
    pos = new ParsePosition(0);
    result = format.parse("-9223372036854775808", pos);
    assertTrue("Wrong result type for Long.MIN_VALUE", result.getClass() == Double.class);
    assertTrue("Wrong result Long.MIN_VALUE: " + result.longValue(), result.longValue() == Long.MIN_VALUE);
    pos = new ParsePosition(0);
    result = format.parse("9223372036854775808", pos);
    assertTrue("Wrong result type for Long.MAX_VALUE+1", result.getClass() == Double.class);
    assertTrue("Wrong result Long.MAX_VALUE + 1", result.doubleValue() == (double) Long.MAX_VALUE + 1);
    pos = new ParsePosition(0);
    result = format.parse("-9223372036854775809", pos);
    assertTrue("Wrong result type for Long.MIN_VALUE+1", result.getClass() == Double.class);
    assertTrue("Wrong result Long.MIN_VALUE - 1", result.doubleValue() == (double) Long.MIN_VALUE - 1);
    pos = new ParsePosition(0);
    result = format.parse("18446744073709551629", pos);
    assertTrue("Wrong result type for overflow", result.getClass() == Double.class);
    assertTrue("Wrong result for overflow", result.doubleValue() == 18446744073709551629d);
    pos = new ParsePosition(0);
    result = format.parse("42325917317067571199", pos);
    assertTrue("Wrong result type for overflow a: " + result, result.getClass() == Double.class);
    assertTrue("Wrong result for overflow a: " + result, result.doubleValue() == 42325917317067571199d);
    pos = new ParsePosition(0);
    result = format.parse("4232591731706757119E1", pos);
    assertTrue("Wrong result type for overflow b: " + result, result.getClass() == Double.class);
    assertTrue("Wrong result for overflow b: " + result, result.doubleValue() == 42325917317067571190d);
    pos = new ParsePosition(0);
    result = format.parse(".42325917317067571199E20", pos);
    assertTrue("Wrong result type for overflow c: " + result, result.getClass() == Double.class);
    assertTrue("Wrong result for overflow c: " + result, result.doubleValue() == 42325917317067571199d);
    pos = new ParsePosition(0);
    result = format.parse("922337203685477580.9E1", pos);
    assertTrue("Wrong result type for overflow d: " + result, result.getClass() == Double.class);
    assertTrue("Wrong result for overflow d: " + result, result.doubleValue() == 9223372036854775809d);
    pos = new ParsePosition(0);
    result = format.parse("9.223372036854775809E18", pos);
    assertTrue("Wrong result type for overflow e: " + result, result.getClass() == Double.class);
    assertTrue("Wrong result for overflow e: " + result, result.doubleValue() == 9223372036854775809d);
}
#method_after
public void test_parse_withParsePosition() {
    DecimalFormat format = (DecimalFormat) NumberFormat.getNumberInstance(Locale.ENGLISH);
    ParsePosition pos = new ParsePosition(0);
    Number result = format.parse("9223372036854775807", pos);
    assertTrue("Wrong result type for Long.MAX_VALUE", result.getClass() == Long.class);
    assertTrue("Wrong result Long.MAX_VALUE", result.longValue() == Long.MAX_VALUE);
    pos = new ParsePosition(0);
    result = format.parse("-9223372036854775808", pos);
    assertTrue("Wrong result type for Long.MIN_VALUE", result.getClass() == Long.class);
    assertTrue("Wrong result Long.MIN_VALUE: " + result.longValue(), result.longValue() == Long.MIN_VALUE);
    pos = new ParsePosition(0);
    result = format.parse("9223372036854775808", pos);
    assertTrue("Wrong result type for Long.MAX_VALUE+1", result.getClass() == Double.class);
    assertTrue("Wrong result Long.MAX_VALUE + 1", result.doubleValue() == (double) Long.MAX_VALUE + 1);
    pos = new ParsePosition(0);
    result = format.parse("-9223372036854775809", pos);
    assertTrue("Wrong result type for Long.MIN_VALUE+1", result.getClass() == Double.class);
    assertTrue("Wrong result Long.MIN_VALUE - 1", result.doubleValue() == (double) Long.MIN_VALUE - 1);
    pos = new ParsePosition(0);
    result = format.parse("18446744073709551629", pos);
    assertTrue("Wrong result type for overflow", result.getClass() == Double.class);
    assertTrue("Wrong result for overflow", result.doubleValue() == 18446744073709551629d);
    pos = new ParsePosition(0);
    result = format.parse("42325917317067571199", pos);
    assertTrue("Wrong result type for overflow a: " + result, result.getClass() == Double.class);
    assertTrue("Wrong result for overflow a: " + result, result.doubleValue() == 42325917317067571199d);
    pos = new ParsePosition(0);
    result = format.parse("4232591731706757119E1", pos);
    assertTrue("Wrong result type for overflow b: " + result, result.getClass() == Double.class);
    assertTrue("Wrong result for overflow b: " + result, result.doubleValue() == 42325917317067571190d);
    pos = new ParsePosition(0);
    result = format.parse(".42325917317067571199E20", pos);
    assertTrue("Wrong result type for overflow c: " + result, result.getClass() == Double.class);
    assertTrue("Wrong result for overflow c: " + result, result.doubleValue() == 42325917317067571199d);
    pos = new ParsePosition(0);
    result = format.parse("922337203685477580.9E1", pos);
    assertTrue("Wrong result type for overflow d: " + result, result.getClass() == Double.class);
    assertTrue("Wrong result for overflow d: " + result, result.doubleValue() == 9223372036854775809d);
    pos = new ParsePosition(0);
    result = format.parse("9.223372036854775809E18", pos);
    assertTrue("Wrong result type for overflow e: " + result, result.getClass() == Double.class);
    assertTrue("Wrong result for overflow e: " + result, result.doubleValue() == 9223372036854775809d);
}
#end_block

#method_before
public void test_parse_withMultiplier() {
    DecimalFormat format = (DecimalFormat) NumberFormat.getNumberInstance(Locale.ENGLISH);
    Number result;
    format.setMultiplier(100);
    result = format.parse("9223372036854775807", new ParsePosition(0));
    assertEquals("Wrong result type multiplier 100: " + result, Long.class, result.getClass());
    assertEquals("Wrong result for multiplier 100: " + result, 92233720368547758.07d, result.doubleValue());
    format.setMultiplier(1000);
    result = format.parse("9223372036854775807", new ParsePosition(0));
    assertEquals("Wrong result type multiplier 1000: " + result, Long.class, result.getClass());
    assertEquals("Wrong result for multiplier 1000: " + result, 9223372036854775.807d, result.doubleValue());
    format.setMultiplier(10000);
    result = format.parse("9223372036854775807", new ParsePosition(0));
    assertEquals("Wrong result type multiplier 10000: " + result, Double.class, result.getClass());
    assertEquals("Wrong result for multiplier 10000: " + result, 922337203685477.5807d, result.doubleValue());
}
#method_after
public void test_parse_withMultiplier() {
    DecimalFormat format = (DecimalFormat) NumberFormat.getNumberInstance(Locale.ENGLISH);
    Number result;
    format.setMultiplier(100);
    result = format.parse("9223372036854775807", new ParsePosition(0));
    assertEquals("Wrong result type multiplier 100: " + result, Double.class, result.getClass());
    assertEquals("Wrong result for multiplier 100: " + result, 92233720368547758.07d, result.doubleValue());
    format.setMultiplier(1000);
    result = format.parse("9223372036854775807", new ParsePosition(0));
    assertEquals("Wrong result type multiplier 1000: " + result, Double.class, result.getClass());
    assertEquals("Wrong result for multiplier 1000: " + result, 9223372036854775.807d, result.doubleValue());
    format.setMultiplier(10000);
    result = format.parse("9223372036854775807", new ParsePosition(0));
    assertEquals("Wrong result type multiplier 10000: " + result, Double.class, result.getClass());
    assertEquals("Wrong result for multiplier 10000: " + result, 922337203685477.5807d, result.doubleValue());
}
#end_block

#method_before
public void testSetZeroDigitForPattern() {
    DecimalFormatSymbols decimalFormatSymbols = new DecimalFormatSymbols();
    decimalFormatSymbols.setZeroDigit('a');
    DecimalFormat formatter = new DecimalFormat();
    formatter.setDecimalFormatSymbols(decimalFormatSymbols);
    formatter.applyLocalizedPattern("#.aa");
    assertEquals("e.aa", formatter.format(4.50));
}
#method_after
public void testSetZeroDigitForPattern() {
    DecimalFormatSymbols decimalFormatSymbols = new DecimalFormatSymbols();
    decimalFormatSymbols.setZeroDigit('a');
    DecimalFormat formatter = new DecimalFormat();
    formatter.setDecimalFormatSymbols(decimalFormatSymbols);
    formatter.applyLocalizedPattern("#.aa");
    assertEquals("e.fa", formatter.format(4.50));
}
#end_block

#method_before
public void testBug15081434() throws Exception {
    DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.US);
    try {
        df.parse(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        df.applyLocalizedPattern(null);
    } catch (NullPointerException unexpected) {
        fail();
    }
    try {
        df.applyPattern(null);
    } catch (NullPointerException unexpected) {
        fail();
    }
    try {
        df.applyPattern(null);
    } catch (NullPointerException unexpected) {
        fail();
    }
    try {
        df.format(null, new StringBuffer(), new FieldPosition(0));
        fail();
    } catch (IllegalArgumentException expected) {
    }
    try {
        df.parse(null, new ParsePosition(0));
        fail();
    } catch (NullPointerException expected) {
    }
    // This just ignores null.
    df.setDecimalFormatSymbols(null);
    try {
        df.setCurrency(null);
        fail();
    } catch (NullPointerException expected) {
    }
    // These just ignore null.
    df.setNegativePrefix(null);
    df.setNegativeSuffix(null);
    df.setPositivePrefix(null);
    df.setPositiveSuffix(null);
    try {
        df.setRoundingMode(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#method_after
public void testBug15081434() throws Exception {
    DecimalFormat df = (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.US);
    try {
        df.parse(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        df.applyLocalizedPattern(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        df.applyPattern(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        df.applyPattern(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        df.format(null, new StringBuffer(), new FieldPosition(0));
        fail();
    } catch (IllegalArgumentException expected) {
    }
    try {
        df.parse(null, new ParsePosition(0));
        fail();
    } catch (NullPointerException expected) {
    }
    // This just ignores null.
    df.setDecimalFormatSymbols(null);
    try {
        df.setCurrency(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        df.setNegativePrefix(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        df.setNegativeSuffix(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        df.setPositivePrefix(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        df.setPositiveSuffix(null);
        fail();
    } catch (NullPointerException expected) {
    }
    try {
        df.setRoundingMode(null);
        fail();
    } catch (NullPointerException expected) {
    }
}
#end_block

#method_before
public void test_nextIntI() throws IOException {
    s = new Scanner("123 456");
    assertEquals(123, s.nextInt(10));
    assertEquals(456, s.nextInt(10));
    try {
        s.nextInt(10);
        fail();
    } catch (NoSuchElementException expected) {
    }
    // If the radix is different from 10
    s = new Scanner("123 456");
    assertEquals(38, s.nextInt(5));
    try {
        s.nextInt(5);
        fail();
    } catch (InputMismatchException expected) {
    }
    // If the number is out of range
    s = new Scanner("123456789123456789123456789123456789");
    try {
        s.nextInt(10);
        fail();
    } catch (InputMismatchException expected) {
    }
    /*
         * Different locale can only recognize corresponding locale sensitive
         * string. ',' is used in many locales as group separator.
         */
    s = new Scanner("23,456 23,456");
    s.useLocale(Locale.GERMANY);
    try {
        s.nextInt(10);
        fail();
    } catch (InputMismatchException expected) {
    }
    s.useLocale(Locale.ENGLISH);
    // If exception is thrown out, input will not be advanced.
    assertEquals(23456, s.nextInt(10));
    assertEquals(23456, s.nextInt(10));
    /*
         * ''' is used in many locales as group separator.
         */
    s = new Scanner("23’456 23’456");
    s.useLocale(Locale.GERMANY);
    try {
        s.nextInt(10);
        fail();
    } catch (InputMismatchException expected) {
    }
    s.useLocale(new Locale("it", "CH"));
    // If exception is thrown out, input will not be advanced.
    assertEquals(23456, s.nextInt(10));
    assertEquals(23456, s.nextInt(10));
    /*
         * The input string has Arabic-Indic digits.
         */
    s = new Scanner("1\u06602 1\u06662");
    assertEquals(102, s.nextInt(10));
    try {
        s.nextInt(5);
        fail();
    } catch (InputMismatchException expected) {
    }
    assertEquals(162, s.nextInt(10));
    /*
         * '.' is used in many locales as group separator. The input string
         * has Arabic-Indic digits .
         */
    s = new Scanner("23.45\u0666 23.456");
    s.useLocale(Locale.CHINESE);
    try {
        s.nextInt(10);
        fail();
    } catch (InputMismatchException expected) {
    }
    s.useLocale(Locale.GERMANY);
    // If exception is thrown out, input will not be advanced.
    assertEquals(23456, s.nextInt(10));
    assertEquals(23456, s.nextInt(10));
    // The input string starts with zero
    s = new Scanner("03,456");
    s.useLocale(Locale.ENGLISH);
    try {
        s.nextInt(10);
        fail();
    } catch (InputMismatchException expected) {
    }
    s = new Scanner("03456");
    assertEquals(3456, s.nextInt(10));
    s = new Scanner("\u06603,456");
    s.useLocale(Locale.ENGLISH);
    assertEquals(3456, s.nextInt(10));
    s = new Scanner("E3456");
    assertEquals(930902, s.nextInt(16));
    // The following test case fails on RI, because RI does not support
    // letter as leading digit
    s = new Scanner("E3,456");
    s.useLocale(Locale.ENGLISH);
    assertEquals(930902, s.nextInt(16));
    /*
         * There are 3 types of zero digit in all locales, '0' '\u0966' '\u0e50'
         * respectively, but they are not differentiated.
         */
    s = new Scanner("12300");
    s.useLocale(Locale.CHINESE);
    assertEquals(12300, s.nextInt(10));
    s = new Scanner("123\u0966\u0966");
    s.useLocale(Locale.CHINESE);
    assertEquals(12300, s.nextInt(10));
    s = new Scanner("123\u0e50\u0e50");
    s.useLocale(Locale.CHINESE);
    assertEquals(12300, s.nextInt(10));
    s = new Scanner("-123 123-");
    s.useLocale(new Locale("ar", "AE"));
    assertEquals(-123, s.nextInt());
    try {
        s.nextInt();
        fail();
    } catch (InputMismatchException expected) {
    }
    s = new Scanner("-123 -123-");
    s.useLocale(new Locale("ar", "AE"));
    assertEquals(-123, s.nextInt());
    try {
        s.nextInt();
        fail();
    } catch (InputMismatchException expected) {
    }
    s = new Scanner("-123 123-");
    s.useLocale(new Locale("mk", "MK"));
    assertEquals(-123, s.nextInt(10));
    try {
        s.nextInt();
        fail();
    } catch (InputMismatchException expected) {
    }
    // Skip the un-recognizable token 123-.
    assertEquals("123-", s.next());
    // RI
    try {
        s.nextInt(Character.MIN_RADIX - 1);
        fail();
    } catch (IllegalArgumentException expected) {
    }
    try {
        s.nextInt(Character.MAX_RADIX + 1);
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#method_after
public void test_nextIntI() throws IOException {
    s = new Scanner("123 456");
    assertEquals(123, s.nextInt(10));
    assertEquals(456, s.nextInt(10));
    try {
        s.nextInt(10);
        fail();
    } catch (NoSuchElementException expected) {
    }
    // If the radix is different from 10
    s = new Scanner("123 456");
    assertEquals(38, s.nextInt(5));
    try {
        s.nextInt(5);
        fail();
    } catch (InputMismatchException expected) {
    }
    // If the number is out of range
    s = new Scanner("123456789123456789123456789123456789");
    try {
        s.nextInt(10);
        fail();
    } catch (InputMismatchException expected) {
    }
    /*
         * Different locale can only recognize corresponding locale sensitive
         * string. ',' is used in many locales as group separator.
         */
    s = new Scanner("23,456 23,456");
    s.useLocale(Locale.GERMANY);
    try {
        s.nextInt(10);
        fail();
    } catch (InputMismatchException expected) {
    }
    s.useLocale(Locale.ENGLISH);
    // If exception is thrown out, input will not be advanced.
    assertEquals(23456, s.nextInt(10));
    assertEquals(23456, s.nextInt(10));
    /*
         * '’' is used in many locales as group separator.
         */
    s = new Scanner("23’456 23’456");
    s.useLocale(Locale.GERMANY);
    try {
        s.nextInt(10);
        fail();
    } catch (InputMismatchException expected) {
    }
    s.useLocale(new Locale("it", "CH"));
    // If exception is thrown out, input will not be advanced.
    assertEquals(23456, s.nextInt(10));
    assertEquals(23456, s.nextInt(10));
    /*
         * The input string has Arabic-Indic digits.
         */
    s = new Scanner("1\u06602 1\u06662");
    assertEquals(102, s.nextInt(10));
    try {
        s.nextInt(5);
        fail();
    } catch (InputMismatchException expected) {
    }
    assertEquals(162, s.nextInt(10));
    /*
         * '.' is used in many locales as group separator. The input string
         * has Arabic-Indic digits .
         */
    s = new Scanner("23.45\u0666 23.456");
    s.useLocale(Locale.CHINESE);
    try {
        s.nextInt(10);
        fail();
    } catch (InputMismatchException expected) {
    }
    s.useLocale(Locale.GERMANY);
    // If exception is thrown out, input will not be advanced.
    assertEquals(23456, s.nextInt(10));
    assertEquals(23456, s.nextInt(10));
    // The input string starts with zero
    s = new Scanner("03,456");
    s.useLocale(Locale.ENGLISH);
    try {
        s.nextInt(10);
        fail();
    } catch (InputMismatchException expected) {
    }
    s = new Scanner("03456");
    assertEquals(3456, s.nextInt(10));
    s = new Scanner("\u06603,456");
    s.useLocale(Locale.ENGLISH);
    assertEquals(3456, s.nextInt(10));
    s = new Scanner("E3456");
    assertEquals(930902, s.nextInt(16));
    // The following test case fails on RI, because RI does not support
    // letter as leading digit
    s = new Scanner("E3,456");
    s.useLocale(Locale.ENGLISH);
    assertEquals(930902, s.nextInt(16));
    /*
         * There are 3 types of zero digit in all locales, '0' '\u0966' '\u0e50'
         * respectively, but they are not differentiated.
         */
    s = new Scanner("12300");
    s.useLocale(Locale.CHINESE);
    assertEquals(12300, s.nextInt(10));
    s = new Scanner("123\u0966\u0966");
    s.useLocale(Locale.CHINESE);
    assertEquals(12300, s.nextInt(10));
    s = new Scanner("123\u0e50\u0e50");
    s.useLocale(Locale.CHINESE);
    assertEquals(12300, s.nextInt(10));
    s = new Scanner("-123 123-");
    s.useLocale(new Locale("ar", "AE"));
    assertEquals(-123, s.nextInt());
    try {
        s.nextInt();
        fail();
    } catch (InputMismatchException expected) {
    }
    s = new Scanner("-123 -123-");
    s.useLocale(new Locale("ar", "AE"));
    assertEquals(-123, s.nextInt());
    try {
        s.nextInt();
        fail();
    } catch (InputMismatchException expected) {
    }
    s = new Scanner("-123 123-");
    s.useLocale(new Locale("mk", "MK"));
    assertEquals(-123, s.nextInt(10));
    try {
        s.nextInt();
        fail();
    } catch (InputMismatchException expected) {
    }
    // Skip the un-recognizable token 123-.
    assertEquals("123-", s.next());
    // RI
    try {
        s.nextInt(Character.MIN_RADIX - 1);
        fail();
    } catch (IllegalArgumentException expected) {
    }
    try {
        s.nextInt(Character.MAX_RADIX + 1);
        fail();
    } catch (IllegalArgumentException expected) {
    }
}
#end_block

#method_before
public void test_sigDigitPatterns() throws Exception {
    DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    format.applyPattern("@@@");
    assertEquals("sigDigit doesn't work", "12300", format.format(12345));
    assertEquals("sigDigit doesn't work", "0.123", format.format(0.12345));
    format.applyPattern("@@##");
    assertEquals("sigDigit doesn't work", "3.142", format.format(3.14159));
    assertEquals("sigDigit doesn't work", "1.23", format.format(1.23004));
    format.applyPattern("@@###E0");
    assertEquals("1.23E1", format.format(12.3));
    format.applyPattern("0.0###E0");
    assertEquals("1.23E1", format.format(12.3));
    try {
        format.applyPattern("@00");
        fail("expected IllegalArgumentException was not thrown for " + "pattern \"@00\".");
    } catch (IllegalArgumentException e) {
    // expected
    }
    try {
        format.applyPattern("@.###");
    } catch (IllegalArgumentException e) {
        fail("unexpected IllegalArgumentException was thrown for " + "pattern \"@.###\".");
    }
}
#method_after
public void test_sigDigitPatterns() throws Exception {
    DecimalFormat format = (DecimalFormat) NumberFormat.getInstance(Locale.US);
    format.applyPattern("@@@");
    assertEquals("sigDigit doesn't work", "12300", format.format(12345));
    assertEquals("sigDigit doesn't work", "0.123", format.format(0.12345));
    format.applyPattern("@@##");
    assertEquals("sigDigit doesn't work", "3.142", format.format(3.14159));
    assertEquals("sigDigit doesn't work", "1.23", format.format(1.23004));
    format.applyPattern("@@###E0");
    assertEquals("1.23E1", format.format(12.3));
    format.applyPattern("0.0###E0");
    assertEquals("1.23E1", format.format(12.3));
    try {
        format.applyPattern("@00");
        fail("expected IllegalArgumentException was not thrown for " + "pattern \"@00\".");
    } catch (IllegalArgumentException e) {
    // expected
    }
}
#end_block

#method_before
public void test_positiveExponentSign() throws Exception {
    format.applyPattern("0.###E+0");
    assertEquals("1E+2", format.format(100));
    assertEquals("1E-2", format.format(0.01));
    assertEquals(100, format.parse("1E+2").intValue());
    assertEquals(0.01f, format.parse("1E-2").floatValue());
    format.applyPattern("0.###E0 m/s");
    assertEquals("1E2 m/s", format.format(100));
    assertEquals(100, format.parse("1E2 m/s").intValue());
    format.applyPattern("00.###E0");
    assertEquals("12.3E-4", format.format(0.00123));
    assertEquals(0.00123f, format.parse("12.3E-4").floatValue());
    format.applyPattern("##0.####E0");
    assertEquals("12.345E3", format.format(12345));
    assertEquals(12345, format.parse("12.345E3").intValue());
    try {
        format.applyPattern("#,##0.##E0");
    } catch (IllegalArgumentException e) {
        fail("unexpected IllegalArgumentException was thrown for " + "pattern \"#,##0.##E0\".");
    }
}
#method_after
public void test_positiveExponentSign() throws Exception {
    format.applyPattern("0.###E+0");
    assertEquals("1E+2", format.format(100));
    assertEquals("1E-2", format.format(0.01));
    assertEquals(100, format.parse("1E+2").intValue());
    assertEquals(0.01f, format.parse("1E-2").floatValue());
    format.applyPattern("0.###E0 m/s");
    assertEquals("1E2 m/s", format.format(100));
    assertEquals(100, format.parse("1E2 m/s").intValue());
    format.applyPattern("00.###E0");
    assertEquals("12.3E-4", format.format(0.00123));
    assertEquals(0.00123f, format.parse("12.3E-4").floatValue());
    format.applyPattern("##0.####E0");
    assertEquals("12.345E3", format.format(12345));
    assertEquals(12345, format.parse("12.345E3").intValue());
    try {
        format.applyPattern("#,##0.##E0");
        fail("expected IllegalArgumentException was not thrown for " + "pattern \"#,##0.##E0\".");
    } catch (IllegalArgumentException e) {
    // expected
    }
}
#end_block

#method_before
public void test_setMaximumIntegerDigits() {
    NumberFormat format = NumberFormat.getInstance();
    format.setMaximumIntegerDigits(2);
    assertEquals("Wrong result: case 1", "23", format.format(123));
    format.setMaximumIntegerDigits(Integer.MIN_VALUE);
    assertEquals("Wrong result: case 2", "3", format.format(123));
}
#method_after
public void test_setMaximumIntegerDigits() {
    NumberFormat format = NumberFormat.getInstance();
    format.setMaximumIntegerDigits(2);
    assertEquals("Wrong result: case 1", "23", format.format(123));
    format.setMaximumIntegerDigits(Integer.MIN_VALUE);
    assertEquals("Wrong result: case 2", ".0", format.format(123));
}
#end_block

#method_before
public void test_equals() {
    NumberFormat nf1 = NumberFormat.getInstance();
    NumberFormat nf2 = NumberFormat.getInstance();
    assertTrue("Objects are not equal", nf1.equals(nf2));
    assertTrue("THe same Objects are not equal", nf1.equals(nf1));
    nf2.setMaximumIntegerDigits(100);
    assertFalse("Different NumberFormat are equal", nf1.equals(nf2));
    nf2.setMaximumIntegerDigits(nf1.getMaximumIntegerDigits());
    assertFalse("THe same Objects are equal", nf1.equals(nf2));
    nf1 = NumberFormat.getIntegerInstance();
    nf2 = NumberFormat.getIntegerInstance(Locale.CHINA);
    assertFalse("Different NumberFormat are equal", nf1.equals(nf2));
    assertFalse("Object is equal null", nf1.equals(null));
}
#method_after
public void test_equals() {
    NumberFormat nf1 = NumberFormat.getInstance();
    NumberFormat nf2 = NumberFormat.getInstance();
    assertTrue("Objects are not equal", nf1.equals(nf2));
    assertTrue("THe same Objects are not equal", nf1.equals(nf1));
    nf2.setMaximumIntegerDigits(100);
    assertFalse("Different NumberFormat are equal", nf1.equals(nf2));
    nf1 = NumberFormat.getIntegerInstance();
    nf2 = NumberFormat.getIntegerInstance(Locale.CHINA);
    assertFalse("Different NumberFormat are equal", nf1.equals(nf2));
    assertFalse("Object is equal null", nf1.equals(null));
}
#end_block

#method_before
public void test_getCurrencyInstanceLjava_util_Locale() {
    Locale usLocale = Locale.US;
    NumberFormat format = NumberFormat.getCurrencyInstance(usLocale);
    assertNotSame("Instance is null", null, format);
    assertTrue(format instanceof NumberFormat);
    assertEquals("$35.76", format.format(35.76));
    assertEquals("$123,456.79", format.format(123456.789));
    assertEquals("$0.10", format.format(0.1));
    assertEquals("$1.00", format.format(0.999));
    Locale atLocale = new Locale("de", "AT");
    format = NumberFormat.getCurrencyInstance(atLocale);
    // BEGIN Android-changed: ICU uses non-breaking space after the euro sign; the RI uses ' '.
    assertEquals("\u20ac\u00a035,76", format.format(35.76));
    assertEquals("\u20ac\u00a0123.456,79", format.format(123456.789));
    assertEquals("\u20ac\u00a00,10", format.format(0.1));
    assertEquals("\u20ac\u00a01,00", format.format(0.999));
    try {
        NumberFormat.getCurrencyInstance(null);
        fail("java.lang.NullPointerException is not thrown");
    } catch (java.lang.NullPointerException expected) {
    }
}
#method_after
public void test_getCurrencyInstanceLjava_util_Locale() {
    Locale usLocale = Locale.US;
    NumberFormat format = NumberFormat.getCurrencyInstance(usLocale);
    assertNotSame("Instance is null", null, format);
    assertTrue(format instanceof NumberFormat);
    assertEquals("$35.76", format.format(35.76));
    assertEquals("$123,456.79", format.format(123456.789));
    assertEquals("$0.10", format.format(0.1));
    assertEquals("$1.00", format.format(0.999));
    Locale atLocale = new Locale("de", "AT");
    format = NumberFormat.getCurrencyInstance(atLocale);
    // BEGIN Android-changed: ICU uses non-breaking space after the euro sign; the RI uses ' '.
    assertEquals("\u20ac\u00a035,76", format.format(35.76));
    assertEquals("\u20ac\u00a0123\u00a0456,79", format.format(123456.789));
    assertEquals("\u20ac\u00a00,10", format.format(0.1));
    assertEquals("\u20ac\u00a01,00", format.format(0.999));
    try {
        NumberFormat.getCurrencyInstance(null);
        fail("java.lang.NullPointerException is not thrown");
    } catch (java.lang.NullPointerException expected) {
    }
}
#end_block

#method_before
private void generateCachedNewInstanceInsns(MutatableCode mutatableCode) {
    if (newInstanceCachedInsns != null) {
        return;
    }
    newInstanceCachedInsns = new ArrayList<MInsn>();
    for (MInsn mInsn : mutatableCode.getInstructions()) {
        if (mInsn.insn.info.opcode == Opcode.NEW_ARRAY) {
            newInstanceCachedInsns.add(mInsn);
        }
    }
}
#method_after
private void generateCachedNewInstanceInsns(MutatableCode mutatableCode) {
    if (newInstanceCachedInsns != null) {
        return;
    }
    newInstanceCachedInsns = new ArrayList<MInsn>();
    for (MInsn mInsn : mutatableCode.getInstructions()) {
        if (mInsn.insn.info.opcode == Opcode.NEW_INSTANCE) {
            newInstanceCachedInsns.add(mInsn);
        }
    }
}
#end_block

#method_before
@Override
protected boolean canMutate(MutatableCode mutatableCode) {
    for (MInsn mInsn : mutatableCode.getInstructions()) {
        return (mInsn.insn.info.opcode == Opcode.NEW_INSTANCE);
    }
    Log.debug("No New Instance in method, skipping...");
    return false;
}
#method_after
@Override
protected boolean canMutate(MutatableCode mutatableCode) {
    // Cannot change the pool index with only one type.
    if (mutatableCode.program.getTotalPoolIndicesByKind(PoolIndexKind.Type) < 2) {
        Log.debug("Cannot mutate, only one type, skipping...");
        return false;
    }
    for (MInsn mInsn : mutatableCode.getInstructions()) {
        if (mInsn.insn.info.opcode == Opcode.NEW_INSTANCE) {
            return true;
        }
    }
    Log.debug("No New Instance in method, skipping...");
    return false;
}
#end_block

#method_before
@Override
protected Mutation generateMutation(MutatableCode mutatableCode) {
    generateCachedNewInstanceInsns(mutatableCode);
    int newInstanceIdx = rng.nextInt(newInstanceCachedInsns.size());
    int newInstanceTypeIdx = rng.nextInt(mutatableCode.program.getTotalPoolIndicesByKind(PoolIndexKind.Type));
    AssociatedMutation mutation = new AssociatedMutation();
    mutation.setup(this.getClass(), mutatableCode);
    mutation.newInstanceToChangeIdx = newInstanceIdx;
    mutation.newInstanceTypeIdx = newInstanceTypeIdx;
    return mutation;
}
#method_after
@Override
protected Mutation generateMutation(MutatableCode mutatableCode) {
    generateCachedNewInstanceInsns(mutatableCode);
    int newInstanceIdxInCache = rng.nextInt(newInstanceCachedInsns.size());
    MInsn newInstanceInsn = newInstanceCachedInsns.get(newInstanceIdxInCache);
    int oldTypeIdx = (int) newInstanceInsn.insn.vregB;
    int newTypeIdx = 0;
    int totalPoolIndices = mutatableCode.program.getTotalPoolIndicesByKind(PoolIndexKind.Type);
    if (totalPoolIndices < 2) {
        Log.errorAndQuit("Less than two types present, quitting...");
    }
    while (newTypeIdx == oldTypeIdx) {
        newTypeIdx = rng.nextInt(totalPoolIndices);
    }
    AssociatedMutation mutation = new AssociatedMutation();
    mutation.setup(this.getClass(), mutatableCode);
    mutation.newInstanceToChangeIdx = newInstanceIdxInCache;
    mutation.newInstanceTypeIdx = newTypeIdx;
    return mutation;
}
#end_block

#method_before
@Override
protected void applyMutation(Mutation uncastMutation) {
    // Cast the Mutation to our AssociatedMutation, so we can access its fields.
    AssociatedMutation mutation = (AssociatedMutation) uncastMutation;
    MutatableCode mutatableCode = mutation.mutatableCode;
    generateCachedNewInstanceInsns(mutatableCode);
    MInsn newInstanceInsnInCache = newInstanceCachedInsns.get(mutation.newInstanceToChangeIdx);
    int newInstanceInsnIdx;
    // Find the instruction in the method.
    for (newInstanceInsnIdx = 0; newInstanceInsnIdx < mutatableCode.getInstructionCount(); newInstanceInsnIdx++) {
        if (mutatableCode.getInstructionAt(newInstanceInsnIdx) == newInstanceInsnInCache) {
            break;
        }
    }
    String oldInsnString = newInstanceInsnInCache.toString();
    MInsn foundInsn = mutatableCode.getInstructionAt(newInstanceInsnIdx);
    // Bail if the instruction is not found in the method.
    if (foundInsn != newInstanceInsnInCache) {
        return;
    }
    foundInsn.insn.vregB = mutation.newInstanceTypeIdx;
    Log.info("Changed " + oldInsnString + " to " + newInstanceInsnIdx);
    stats.incrementStat("Changed new instance.");
    // Clear cache.
    newInstanceCachedInsns = null;
}
#method_after
@Override
protected void applyMutation(Mutation uncastMutation) {
    // Cast the Mutation to our AssociatedMutation, so we can access its fields.
    AssociatedMutation mutation = (AssociatedMutation) uncastMutation;
    MutatableCode mutatableCode = mutation.mutatableCode;
    generateCachedNewInstanceInsns(mutatableCode);
    MInsn newInstanceInsn = newInstanceCachedInsns.get(mutation.newInstanceToChangeIdx);
    ContainsPoolIndex poolIndex = ((ContainsPoolIndex) newInstanceInsn.insn.info.format);
    poolIndex.setPoolIndex(newInstanceInsn.insn, mutation.newInstanceTypeIdx);
    Log.info("Changed the type of " + newInstanceInsn.toString() + " to " + mutation.newInstanceTypeIdx);
    int foundNewInstanceInsnIdx = foundInsnIdx(mutatableCode, newInstanceCachedInsns.get(mutation.newInstanceToChangeIdx));
    changeInvokeDirect(foundNewInstanceInsnIdx, mutation);
    stats.incrementStat("Changed new instance.");
    // Clear cache.
    newInstanceCachedInsns = null;
}
#end_block

#method_before
public String getIsimImpi(int subId) {
    Phone phone = getPhone(subId);
    mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
    IsimRecords isim = phone.getIsimRecords();
    if (isim != null) {
        return isim.getIsimImpi();
    } else {
        return null;
    }
}
#method_after
public String getIsimImpi(int subId) {
    Phone phone = getPhone(subId);
    if (phone != null) {
        mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
        IsimRecords isim = phone.getIsimRecords();
        if (isim != null) {
            return isim.getIsimImpi();
        } else {
            return null;
        }
    } else {
        loge("getIsimImpi phone is null for Subscription:" + subId);
        return null;
    }
}
#end_block

#method_before
public String getIsimDomain(int subId) {
    Phone phone = getPhone(subId);
    mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
    IsimRecords isim = phone.getIsimRecords();
    if (isim != null) {
        return isim.getIsimDomain();
    } else {
        return null;
    }
}
#method_after
public String getIsimDomain(int subId) {
    Phone phone = getPhone(subId);
    if (phone != null) {
        mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
        IsimRecords isim = phone.getIsimRecords();
        if (isim != null) {
            return isim.getIsimDomain();
        } else {
            return null;
        }
    } else {
        loge("getIsimDomain phone is null for Subscription:" + subId);
        return null;
    }
}
#end_block

#method_before
public String[] getIsimImpu(int subId) {
    Phone phone = getPhone(subId);
    mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
    IsimRecords isim = phone.getIsimRecords();
    if (isim != null) {
        return isim.getIsimImpu();
    } else {
        return null;
    }
}
#method_after
public String[] getIsimImpu(int subId) {
    Phone phone = getPhone(subId);
    if (phone != null) {
        mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
        IsimRecords isim = phone.getIsimRecords();
        if (isim != null) {
            return isim.getIsimImpu();
        } else {
            return null;
        }
    } else {
        loge("getIsimImpu phone is null for Subscription:" + subId);
        return null;
    }
}
#end_block

#method_before
public String getIsimIst(int subId) throws RemoteException {
    Phone phone = getPhone(subId);
    mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
    IsimRecords isim = phone.getIsimRecords();
    if (isim != null) {
        return isim.getIsimIst();
    } else {
        return null;
    }
}
#method_after
public String getIsimIst(int subId) throws RemoteException {
    Phone phone = getPhone(subId);
    if (phone != null) {
        mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
        IsimRecords isim = phone.getIsimRecords();
        if (isim != null) {
            return isim.getIsimIst();
        } else {
            return null;
        }
    } else {
        loge("getIsimIst phone is null for Subscription:" + subId);
        return null;
    }
}
#end_block

#method_before
public String[] getIsimPcscf(int subId) throws RemoteException {
    Phone phone = getPhone(subId);
    mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
    IsimRecords isim = phone.getIsimRecords();
    if (isim != null) {
        return isim.getIsimPcscf();
    } else {
        return null;
    }
}
#method_after
public String[] getIsimPcscf(int subId) throws RemoteException {
    Phone phone = getPhone(subId);
    if (phone != null) {
        mContext.enforceCallingOrSelfPermission(READ_PRIVILEGED_PHONE_STATE, "Requires READ_PRIVILEGED_PHONE_STATE");
        IsimRecords isim = phone.getIsimRecords();
        if (isim != null) {
            return isim.getIsimPcscf();
        } else {
            return null;
        }
    } else {
        loge("getIsimPcscf phone is null for Subscription:" + subId);
        return null;
    }
}
#end_block

#method_before
@VisibleForTesting
protected void showTetheredNotification(int icon, boolean tetheringOn) {
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notificationManager == null) {
        return;
    }
    if (mLastNotificationId != 0) {
        if (mLastNotificationId == icon) {
            return;
        }
        notificationManager.cancelAsUser(null, mLastNotificationId, UserHandle.ALL);
        mLastNotificationId = 0;
    }
    Intent intent = new Intent();
    intent.setClassName("com.android.settings", "com.android.settings.TetherSettings");
    intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    PendingIntent pi = PendingIntent.getActivityAsUser(mContext, 0, intent, 0, null, UserHandle.CURRENT);
    Resources r = Resources.getSystem();
    final CharSequence title;
    final CharSequence message;
    if (tetheringOn) {
        title = r.getText(com.android.internal.R.string.tethered_notification_title);
        message = r.getText(com.android.internal.R.string.tethered_notification_message);
    } else {
        title = r.getText(com.android.internal.R.string.untethered_notification_title);
        message = r.getText(com.android.internal.R.string.untethered_notification_message);
    }
    if (mTetheredNotificationBuilder == null) {
        mTetheredNotificationBuilder = new Notification.Builder(mContext);
        mTetheredNotificationBuilder.setWhen(0).setOngoing(true).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setVisibility(Notification.VISIBILITY_PUBLIC).setCategory(Notification.CATEGORY_STATUS);
    }
    mTetheredNotificationBuilder.setSmallIcon(icon).setContentTitle(title).setContentText(message).setContentIntent(pi);
    mLastNotificationId = icon;
    notificationManager.notifyAsUser(null, mLastNotificationId, mTetheredNotificationBuilder.buildInto(new Notification()), UserHandle.ALL);
}
#method_after
@VisibleForTesting
protected void showTetheredNotification(int icon, boolean tetheringOn) {
    NotificationManager notificationManager = (NotificationManager) mContext.getSystemService(Context.NOTIFICATION_SERVICE);
    if (notificationManager == null) {
        return;
    }
    if (mLastNotificationId != 0) {
        if (mLastNotificationId == icon) {
            return;
        }
        notificationManager.cancelAsUser(null, mLastNotificationId, UserHandle.ALL);
        mLastNotificationId = 0;
    }
    Intent intent = new Intent();
    intent.setClassName("com.android.settings", "com.android.settings.TetherSettings");
    intent.setFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
    PendingIntent pi = PendingIntent.getActivityAsUser(mContext, 0, intent, 0, null, UserHandle.CURRENT);
    Resources r = Resources.getSystem();
    final CharSequence title;
    final CharSequence message;
    if (tetheringOn) {
        title = r.getText(com.android.internal.R.string.tethered_notification_title);
        message = r.getText(com.android.internal.R.string.tethered_notification_message);
    } else {
        title = r.getText(com.android.internal.R.string.disable_tether_notification_title);
        message = r.getText(com.android.internal.R.string.disable_tether_notification_message);
    }
    if (mTetheredNotificationBuilder == null) {
        mTetheredNotificationBuilder = new Notification.Builder(mContext);
        mTetheredNotificationBuilder.setWhen(0).setOngoing(true).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setVisibility(Notification.VISIBILITY_PUBLIC).setCategory(Notification.CATEGORY_STATUS);
    }
    mTetheredNotificationBuilder.setSmallIcon(icon).setContentTitle(title).setContentText(message).setContentIntent(pi);
    mLastNotificationId = icon;
    notificationManager.notifyAsUser(null, mLastNotificationId, mTetheredNotificationBuilder.buildInto(new Notification()), UserHandle.ALL);
}
#end_block

#method_before
public void onUserRestrictionsChanged(int userId, Bundle newRestrictions, Bundle prevRestrictions) {
    final boolean newlyDisallowed = newRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_TETHERING);
    final boolean previouslyDisallowed = prevRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_TETHERING);
    final boolean tetheringDisallowedChanged = (newlyDisallowed != previouslyDisallowed);
    if (!tetheringDisallowedChanged) {
        return;
    }
    mWrapper.clearTetheredNotification();
    final boolean isTetheringActiveOnDevice = (mWrapper.getTetheredIfaces().length != 0);
    if (newlyDisallowed && isTetheringActiveOnDevice) {
        mWrapper.showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general, false);
        mWrapper.postToMasterSMHandler(() -> {
            mWrapper.untetherAll();
        });
    // mWrapper.mTetherMasterSM.getHandler().post(() -> { mWrapper.untetherAll(); });
    }
}
#method_after
public void onUserRestrictionsChanged(int userId, Bundle newRestrictions, Bundle prevRestrictions) {
    final boolean newlyDisallowed = newRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_TETHERING);
    final boolean previouslyDisallowed = prevRestrictions.getBoolean(UserManager.DISALLOW_CONFIG_TETHERING);
    final boolean tetheringDisallowedChanged = (newlyDisallowed != previouslyDisallowed);
    if (!tetheringDisallowedChanged) {
        return;
    }
    mWrapper.clearTetheredNotification();
    final boolean isTetheringActiveOnDevice = (mWrapper.getTetheredIfaces().length != 0);
    if (newlyDisallowed && isTetheringActiveOnDevice) {
        mWrapper.showTetheredNotification(com.android.internal.R.drawable.stat_sys_tether_general, false);
        mWrapper.untetherAll();
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_usb_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_wifi_regexs)).thenReturn(new String[] { "test_wlan\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mNMService.listInterfaces()).thenReturn(new String[] { "test_rmnet_data0", mTestIfname });
    when(mNMService.getInterfaceConfig(anyString())).thenReturn(new InterfaceConfiguration());
    mServiceContext = new MockContext(mContext);
    mContentResolver = new MockContentResolver(mServiceContext);
    mContentResolver.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
    mIntents = new Vector<>();
    mBroadcastReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mIntents.addElement(intent);
        }
    };
    mServiceContext.registerReceiver(mBroadcastReceiver, new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
    when(mTetheringDependencies.getOffloadHardwareInterface(any(Handler.class), any(SharedLog.class))).thenReturn(mOffloadHardwareInterface);
    LocalServices.removeServiceForTest(UserManagerInternal.class);
    mUserManager = mock(UserManagerInternal.class);
    LocalServices.addService(UserManagerInternal.class, mUserManager);
    mTethering = new Tethering(mServiceContext, mNMService, mStatsService, mPolicyManager, mLooper.getLooper(), mSystemProperties, mTetheringDependencies);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_dhcp_range)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_usb_regexs)).thenReturn(new String[0]);
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_wifi_regexs)).thenReturn(new String[] { "test_wlan\\d" });
    when(mResources.getStringArray(com.android.internal.R.array.config_tether_bluetooth_regexs)).thenReturn(new String[0]);
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[0]);
    when(mNMService.listInterfaces()).thenReturn(new String[] { "test_rmnet_data0", mTestIfname });
    when(mNMService.getInterfaceConfig(anyString())).thenReturn(new InterfaceConfiguration());
    mServiceContext = new MockContext(mContext);
    mContentResolver = new MockContentResolver(mServiceContext);
    mContentResolver.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
    mIntents = new Vector<>();
    mBroadcastReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            mIntents.addElement(intent);
        }
    };
    mServiceContext.registerReceiver(mBroadcastReceiver, new IntentFilter(ConnectivityManager.ACTION_TETHER_STATE_CHANGED));
    when(mTetheringDependencies.getOffloadHardwareInterface(any(Handler.class), any(SharedLog.class))).thenReturn(mOffloadHardwareInterface);
    mTethering = new Tethering(mServiceContext, mNMService, mStatsService, mPolicyManager, mLooper.getLooper(), mSystemProperties, mTetheringDependencies);
}
#end_block

#method_before
public void workingWifiTethering(boolean enrichedApBroadcast) throws Exception {
    when(mConnectivityManager.isTetheringSupported()).thenReturn(true);
    when(mWifiManager.startSoftAp(any(WifiConfiguration.class))).thenReturn(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(ConnectivityManager.TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).startSoftAp(null);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(mTestIfname, true);
    if (enrichedApBroadcast) {
        sendWifiApStateChanged(WIFI_AP_STATE_ENABLED, mTestIfname, IFACE_IP_MODE_TETHERED);
    } else {
        sendWifiApStateChanged(WIFI_AP_STATE_ENABLED);
    }
    mLooper.dispatchAll();
    verifyInterfaceServingModeStarted(enrichedApBroadcast);
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_AVAILABLE_TETHER);
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    verify(mNMService, times(1)).startTethering(any(String[].class));
    verifyNoMoreInteractions(mNMService);
    verify(mWifiManager).updateInterfaceIpState(mTestIfname, WifiManager.IFACE_IP_MODE_TETHERED);
    verifyNoMoreInteractions(mWifiManager);
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_ACTIVE_TETHER);
    // UpstreamNetworkMonitor will be started, and will register two callbacks:
    // a "listen all" and a "track default".
    verify(mConnectivityManager, times(1)).registerNetworkCallback(any(NetworkRequest.class), any(NetworkCallback.class), any(Handler.class));
    verify(mConnectivityManager, times(1)).registerDefaultNetworkCallback(any(NetworkCallback.class), any(Handler.class));
    // In tethering mode, in the default configuration, an explicit request
    // for a mobile network is also made.
    verify(mConnectivityManager, times(1)).requestNetwork(any(NetworkRequest.class), any(NetworkCallback.class), eq(0), anyInt(), any(Handler.class));
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    verify(mConnectivityManager, atLeastOnce()).isTetheringSupported();
    verifyNoMoreInteractions(mConnectivityManager);
    // ///
    // We do not currently emulate any upstream being found.
    // 
    // This is why there are no calls to verify mNMService.enableNat() or`
    // mNMService.startInterfaceForwarding().
    // ///
    // Emulate pressing the WiFi tethering button.
    mTethering.stopTethering(ConnectivityManager.TETHERING_WIFI);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).stopSoftAp();
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, when tethering mode
    // is being torn down.
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_DISABLED);
    mTethering.interfaceRemoved(mTestIfname);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).untetherInterface(mTestIfname);
    // TODO: Why is {g,s}etInterfaceConfig() called more than once?
    verify(mNMService, atLeastOnce()).getInterfaceConfig(mTestIfname);
    verify(mNMService, atLeastOnce()).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).stopTethering();
    verify(mNMService, times(1)).setIpForwardingEnabled(false);
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
    // Asking for the last error after the per-interface state machine
    // has been reaped yields an unknown interface error.
    assertEquals(ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE, mTethering.getLastTetherError(mTestIfname));
}
#method_after
public void workingWifiTethering(boolean enrichedApBroadcast) throws Exception {
    when(mConnectivityManager.isTetheringSupported()).thenReturn(true);
    when(mWifiManager.startSoftAp(any(WifiConfiguration.class))).thenReturn(true);
    // Emulate pressing the WiFi tethering button.
    mTethering.startTethering(ConnectivityManager.TETHERING_WIFI, null, false);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).startSoftAp(null);
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, causing the
    // per-interface state machine to start up, and telling us that
    // tethering mode is to be started.
    mTethering.interfaceStatusChanged(mTestIfname, true);
    if (enrichedApBroadcast) {
        sendWifiApStateChanged(WIFI_AP_STATE_ENABLED, mTestIfname, IFACE_IP_MODE_TETHERED);
    } else {
        sendWifiApStateChanged(WIFI_AP_STATE_ENABLED);
    }
    mLooper.dispatchAll();
    verifyInterfaceServingModeStarted(enrichedApBroadcast);
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_AVAILABLE_TETHER);
    verify(mNMService, times(1)).setIpForwardingEnabled(true);
    verify(mNMService, times(1)).startTethering(any(String[].class));
    verifyNoMoreInteractions(mNMService);
    verify(mWifiManager).updateInterfaceIpState(mTestIfname, WifiManager.IFACE_IP_MODE_TETHERED);
    verifyNoMoreInteractions(mWifiManager);
    verifyTetheringBroadcast(mTestIfname, ConnectivityManager.EXTRA_ACTIVE_TETHER);
    // UpstreamNetworkMonitor will be started, and will register two callbacks:
    // a "listen all" and a "track default".
    verify(mConnectivityManager, times(1)).registerNetworkCallback(any(NetworkRequest.class), any(NetworkCallback.class), any(Handler.class));
    verify(mConnectivityManager, times(1)).registerDefaultNetworkCallback(any(NetworkCallback.class), any(Handler.class));
    // In tethering mode, in the default configuration, an explicit request
    // for a mobile network is also made.
    verify(mConnectivityManager, times(1)).requestNetwork(any(NetworkRequest.class), any(NetworkCallback.class), eq(0), anyInt(), any(Handler.class));
    // TODO: Figure out why this isn't exactly once, for sendTetherStateChangedBroadcast().
    verify(mConnectivityManager, atLeastOnce()).isTetheringSupported();
    verifyNoMoreInteractions(mConnectivityManager);
    // ///
    // We do not currently emulate any upstream being found.
    // 
    // This is why there are no calls to verify mNMService.enableNat() or
    // mNMService.startInterfaceForwarding().
    // ///
    // Emulate pressing the WiFi tethering button.
    mTethering.stopTethering(ConnectivityManager.TETHERING_WIFI);
    mLooper.dispatchAll();
    verify(mWifiManager, times(1)).stopSoftAp();
    verifyNoMoreInteractions(mWifiManager);
    verifyNoMoreInteractions(mConnectivityManager);
    verifyNoMoreInteractions(mNMService);
    // Emulate externally-visible WifiManager effects, when tethering mode
    // is being torn down.
    sendWifiApStateChanged(WifiManager.WIFI_AP_STATE_DISABLED);
    mTethering.interfaceRemoved(mTestIfname);
    mLooper.dispatchAll();
    verify(mNMService, times(1)).untetherInterface(mTestIfname);
    // TODO: Why is {g,s}etInterfaceConfig() called more than once?
    verify(mNMService, atLeastOnce()).getInterfaceConfig(mTestIfname);
    verify(mNMService, atLeastOnce()).setInterfaceConfig(eq(mTestIfname), any(InterfaceConfiguration.class));
    verify(mNMService, times(1)).stopTethering();
    verify(mNMService, times(1)).setIpForwardingEnabled(false);
    verifyNoMoreInteractions(mNMService);
    verifyNoMoreInteractions(mWifiManager);
    // Asking for the last error after the per-interface state machine
    // has been reaped yields an unknown interface error.
    assertEquals(ConnectivityManager.TETHER_ERROR_UNKNOWN_IFACE, mTethering.getLastTetherError(mTestIfname));
}
#end_block

#method_before
public void heyItsMe(IBazCallback cb) {
    Log.d(TAG, "SERVER: heyItsMe");
}
#method_after
public void heyItsMe(IBazCallback cb) throws RemoteException {
    mCalled = true;
    cb.heyItsMe(null);
}
#end_block

#method_before
public void hey() {
    Log.d(TAG, "SERVER: hey");
}
#method_after
public void hey() {
    mCalled = true;
}
#end_block

#method_before
private void client() throws RemoteException {
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService("baz");
        baseProxy.someBaseMethod();
    }
    IBaz proxy = IBaz.getService("baz");
    proxy.someBaseMethod();
    {
        Expect(proxy.interfaceDescriptor(), IBaz.kInterfaceName);
    }
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        Expect(toString(result), "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])");
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        Expect(toString(outputArray), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        Expect(fooVecToString(outputVec), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        Expect(toString(out), "VectorOfArray(" + "0c:0d:0e:0f:10:11, " + "06:07:08:09:0a:0b, " + "00:01:02:03:04:05)");
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        Expect(macAddressVecToString(out), "[0c:0d:0e:0f:10:11, 06:07:08:09:0a:0b, 00:01:02:03:04:05]");
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    {
        String[][] in = new String[5][3];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    Expect(toString(proxy.someBoolMethod(true)), "false");
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        Expect(toString(proxy.someBoolArrayMethod(someBoolArray)), "[false, true, false, true]");
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        Expect(booleanVecToString(proxy.someBoolVectorMethod(someBoolVec)), "[false, true, false]");
    }
    proxy.doThis(1.0f);
    Expect(toString(proxy.doThatAndReturnSomething(1)), "666");
    Expect(toString(proxy.doQuiteABit(1, 2L, 3.0f, 4.0)), "666.5");
    {
        int[] paramArray = new int[15];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
        }
        Expect(toString(proxy.doSomethingElse(paramArray)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, " + "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1, 2]");
        Expect(integerVecToString(proxy.mapThisVector(paramVec)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]");
    }
    Expect(toString(proxy.doStuffAndReturnAString()), "'Hello, world!'");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    Expect(toString(proxy.useAnEnum(IBaz.SomeEnum.goober)), "-64");
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        Expect(toString(proxy.haveSomeStrings(stringArray)), "['Hello', 'World']");
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        Expect(stringVecToString(proxy.haveAStringVec(stringVec)), "['Hello', 'World']");
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    ArrayList<NestedStruct> structs = proxy.getNestedStructs();
    ExpectTrue(structs.size() == 5);
    ExpectTrue(structs.get(1).matrices.size() == 6);
    {
        IBaz.Everything e = new IBaz.Everything();
        Expect(e.toString(), "{.number = 0, .anotherNumber = 0, .s = , " + ".vs = [], .multidimArray = [[null, null], [null, null]], " + ".sArray = [null, null, null], .anotherStruct = {.first = , .last = }, .bf = }");
        e.s = "string!";
        e.number = 127;
        e.anotherNumber = 100;
        e.vs.addAll(Arrays.asList("One", "Two", "Three"));
        for (int i = 0; i < e.multidimArray.length; i++) for (int j = 0; j < e.multidimArray[i].length; j++) e.multidimArray[i][j] = Integer.toString(i) + Integer.toString(j);
        e.bf = IBaz.BitField.VALL;
        e.anotherStruct.first = "James";
        e.anotherStruct.last = "Bond";
        Expect(e.toString(), "{.number = 127, .anotherNumber = 100, .s = string!, " + ".vs = [One, Two, Three], .multidimArray = [[00, 01], [10, 11]], " + ".sArray = [null, null, null], .anotherStruct = {.first = James, .last = Bond}, " + ".bf = V0 | V1 | V2 | V3 | VALL}");
        Expect(IBaz.BitField.toString(IBaz.BitField.VALL), "VALL");
        Expect(IBaz.BitField.toString((byte) (IBaz.BitField.V0 | IBaz.BitField.V2)), "0x5");
        Expect(IBaz.BitField.dumpBitfield(IBaz.BitField.VALL), "V0 | V1 | V2 | V3 | VALL");
        Expect(IBaz.BitField.dumpBitfield((byte) (IBaz.BitField.V1 | IBaz.BitField.V3 | 0xF0)), "V1 | V3 | 0xf0");
    }
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#method_after
private void client() throws RemoteException {
    {
        // Test access through base interface binder.
        IBase baseProxy = IBase.getService("baz");
        baseProxy.someBaseMethod();
    }
    IBaz proxy = IBaz.getService("baz");
    proxy.someBaseMethod();
    {
        Expect(proxy.interfaceDescriptor(), IBaz.kInterfaceName);
    }
    {
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        IBase.Foo result = proxy.someOtherBaseMethod(foo);
        Expect(toString(result), "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])");
    }
    {
        IBase.Foo[] inputArray = new IBase.Foo[2];
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputArray[0] = foo;
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputArray[1] = foo;
        IBase.Foo[] outputArray = proxy.someMethodWithFooArrays(inputArray);
        Expect(toString(outputArray), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        ArrayList<IBase.Foo> inputVec = new ArrayList<IBase.Foo>();
        IBase.Foo foo = new IBase.Foo();
        foo.x = 1;
        for (int i = 0; i < 5; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 1.0f + (float) i * 0.01f;
            bar.s = "Hello, world " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 3.14f;
        foo.y.s = "Lorem ipsum...";
        inputVec.add(foo);
        foo = new IBase.Foo();
        foo.x = 2;
        for (int i = 0; i < 3; ++i) {
            IBase.Foo.Bar bar = new IBase.Foo.Bar();
            bar.z = 2.0f - (float) i * 0.01f;
            bar.s = "Lorem ipsum " + i;
            foo.aaa.add(bar);
        }
        foo.y.z = 1.1414f;
        foo.y.s = "Et tu brute?";
        inputVec.add(foo);
        ArrayList<IBase.Foo> outputVec = proxy.someMethodWithFooVectors(inputVec);
        Expect(fooVecToString(outputVec), "[Foo(x = 2, " + "y = Bar(z = 1.1414, s = 'Et tu brute?'), " + "aaa = [Bar(z = 2.0, s = 'Lorem ipsum 0'), " + "Bar(z = 1.99, s = 'Lorem ipsum 1'), " + "Bar(z = 1.98, s = 'Lorem ipsum 2')]), " + "Foo(x = 1, " + "y = Bar(z = 3.14, s = 'Lorem ipsum...'), " + "aaa = [Bar(z = 1.0, s = 'Hello, world 0'), " + "Bar(z = 1.01, s = 'Hello, world 1'), " + "Bar(z = 1.02, s = 'Hello, world 2'), " + "Bar(z = 1.03, s = 'Hello, world 3'), " + "Bar(z = 1.04, s = 'Hello, world 4')])]");
    }
    {
        IBase.VectorOfArray in = new IBase.VectorOfArray();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.addresses.add(mac);
        }
        IBase.VectorOfArray out = proxy.someMethodWithVectorOfArray(in);
        Expect(toString(out), "VectorOfArray(" + "0c:0d:0e:0f:10:11, " + "06:07:08:09:0a:0b, " + "00:01:02:03:04:05)");
    }
    {
        ArrayList<byte[]> in = new ArrayList<byte[]>();
        int k = 0;
        for (int i = 0; i < 3; ++i) {
            byte[] mac = new byte[6];
            for (int j = 0; j < 6; ++j, ++k) {
                mac[j] = (byte) k;
            }
            in.add(mac);
        }
        ArrayList<byte[]> out = proxy.someMethodTakingAVectorOfArray(in);
        Expect(macAddressVecToString(out), "[0c:0d:0e:0f:10:11, 06:07:08:09:0a:0b, 00:01:02:03:04:05]");
    }
    {
        IBase.StringMatrix5x3 in = new IBase.StringMatrix5x3();
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in.s[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        IBase.StringMatrix3x5 out = proxy.transpose(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    {
        String[][] in = new String[5][3];
        for (int i = 0; i < 5; ++i) {
            for (int j = 0; j < 3; ++j) {
                in[i][j] = numberToEnglish(3 * i + j + 1);
            }
        }
        String[][] out = proxy.transpose2(in);
        // [[1 2 3] [4 5 6] [7 8 9] [10 11 12] [13 14 15]]^T
        // = [[1 4 7 10 13] [2 5 8 11 14] [3 6 9 12 15]]
        Expect(toString(out), "[['one', 'four', 'seven', 'ten', 'thirteen'], " + "['two', 'five', 'eight', 'eleven', 'fourteen'], " + "['three', 'six', 'nine', 'twelve', 'fifteen']]");
    }
    Expect(toString(proxy.someBoolMethod(true)), "false");
    {
        boolean[] someBoolArray = new boolean[3];
        someBoolArray[0] = true;
        someBoolArray[1] = false;
        someBoolArray[2] = true;
        Expect(toString(proxy.someBoolArrayMethod(someBoolArray)), "[false, true, false, true]");
        ArrayList<Boolean> someBoolVec = new ArrayList<Boolean>();
        someBoolVec.add(true);
        someBoolVec.add(false);
        someBoolVec.add(true);
        Expect(booleanVecToString(proxy.someBoolVectorMethod(someBoolVec)), "[false, true, false]");
    }
    proxy.doThis(1.0f);
    Expect(toString(proxy.doThatAndReturnSomething(1)), "666");
    Expect(toString(proxy.doQuiteABit(1, 2L, 3.0f, 4.0)), "666.5");
    {
        int[] paramArray = new int[15];
        ArrayList<Integer> paramVec = new ArrayList<Integer>();
        for (int i = 0; i < paramArray.length; ++i) {
            paramArray[i] = i;
            paramVec.add(i);
        }
        Expect(toString(proxy.doSomethingElse(paramArray)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, " + "0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1, 2]");
        Expect(integerVecToString(proxy.mapThisVector(paramVec)), "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28]");
    }
    Expect(toString(proxy.doStuffAndReturnAString()), "'Hello, world!'");
    BazCallback cb = new BazCallback();
    ExpectTrue(!cb.wasCalled());
    proxy.callMe(cb);
    ExpectTrue(cb.wasCalled());
    Expect(toString(proxy.useAnEnum(IBaz.SomeEnum.goober)), "-64");
    {
        String[] stringArray = new String[3];
        stringArray[0] = "one";
        stringArray[1] = "two";
        stringArray[2] = "three";
        Expect(toString(proxy.haveSomeStrings(stringArray)), "['Hello', 'World']");
        ArrayList<String> stringVec = new ArrayList<String>();
        stringVec.add("one");
        stringVec.add("two");
        stringVec.add("three");
        Expect(stringVecToString(proxy.haveAStringVec(stringVec)), "['Hello', 'World']");
    }
    proxy.returnABunchOfStrings(new IBaz.returnABunchOfStringsCallback() {

        @Override
        public void onValues(String a, String b, String c) {
            Expect(a, "Eins");
            Expect(b, "Zwei");
            Expect(c, "Drei");
        }
    });
    proxy.returnABunchOfStrings((a, b, c) -> Expect(a + b + c, "EinsZweiDrei"));
    proxy.callMeLater(new BazCallback());
    System.gc();
    proxy.iAmFreeNow();
    {
        IBaz.T t1 = new IBaz.T();
        IBaz.T t2 = new IBaz.T();
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 3; j++) {
                t1.matrix5x3[i][j] = t2.matrix5x3[i][j] = (i + 1) * (j + 1);
            }
        }
        ExpectTrue(t1.equals(t2));
        ExpectTrue(t1.hashCode() == t2.hashCode());
        t2.matrix5x3[4][2] = -60;
        ExpectTrue(!t1.equals(t2));
    }
    ArrayList<NestedStruct> structs = proxy.getNestedStructs();
    ExpectTrue(structs.size() == 5);
    ExpectTrue(structs.get(1).matrices.size() == 6);
    {
        IBaz.Everything e = new IBaz.Everything();
        Expect(e.toString(), "{.number = 0, .anotherNumber = 0, .s = , " + ".vs = [], .multidimArray = [[null, null], [null, null]], " + ".sArray = [null, null, null], .anotherStruct = {.first = , .last = }, .bf = }");
        e.s = "string!";
        e.number = 127;
        e.anotherNumber = 100;
        e.vs.addAll(Arrays.asList("One", "Two", "Three"));
        for (int i = 0; i < e.multidimArray.length; i++) for (int j = 0; j < e.multidimArray[i].length; j++) e.multidimArray[i][j] = Integer.toString(i) + Integer.toString(j);
        e.bf = IBaz.BitField.VALL;
        e.anotherStruct.first = "James";
        e.anotherStruct.last = "Bond";
        Expect(e.toString(), "{.number = 127, .anotherNumber = 100, .s = string!, " + ".vs = [One, Two, Three], .multidimArray = [[00, 01], [10, 11]], " + ".sArray = [null, null, null], .anotherStruct = {.first = James, .last = Bond}, " + ".bf = V0 | V1 | V2 | V3 | VALL}");
        Expect(IBaz.BitField.toString(IBaz.BitField.VALL), "VALL");
        Expect(IBaz.BitField.toString((byte) (IBaz.BitField.V0 | IBaz.BitField.V2)), "0x5");
        Expect(IBaz.BitField.dumpBitfield(IBaz.BitField.VALL), "V0 | V1 | V2 | V3 | VALL");
        Expect(IBaz.BitField.dumpBitfield((byte) (IBaz.BitField.V1 | IBaz.BitField.V3 | 0xF0)), "V1 | V3 | 0xf0");
        Expect(proxy.toString(), IBaz.kInterfaceName + "@Proxy");
    }
    // --- DEATH RECIPIENT TESTING ---
    // This must always be done last, since it will kill the native server process
    HidlDeathRecipient recipient1 = new HidlDeathRecipient();
    HidlDeathRecipient recipient2 = new HidlDeathRecipient();
    final int cookie1 = 0x1481;
    final int cookie2 = 0x1482;
    ExpectTrue(proxy.linkToDeath(recipient1, cookie1));
    ExpectTrue(proxy.linkToDeath(recipient2, cookie2));
    ExpectTrue(proxy.unlinkToDeath(recipient2));
    try {
        proxy.dieNow();
    } catch (RemoteException e) {
    // Expected
    }
    ExpectTrue(recipient1.waitUntilServiceDied(2000));
    ExpectTrue(!recipient2.waitUntilServiceDied(2000));
    ExpectTrue(recipient1.cookieMatches(cookie1));
    Log.d(TAG, "OK, exiting");
}
#end_block

#method_before
public void showNotification(int id, NotificationType notifyType, NetworkAgentInfo nai, NetworkAgentInfo switchToNai, PendingIntent intent, boolean highPriority) {
    final String tag = tagFor(id);
    final int eventId = notifyType.eventId;
    final int transportType;
    final String extraInfo;
    if (nai != null) {
        transportType = getFirstTransportType(nai);
        extraInfo = nai.networkInfo.getExtraInfo();
        // Only notify for Internet-capable networks.
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET))
            return;
    } else {
        // Legacy notifications.
        transportType = TRANSPORT_CELLULAR;
        extraInfo = null;
    }
    // Clear any previous notification with lower priority, otherwise return. http://b/63676954.
    // A new SIGN_IN notification with a new intent should override any existing one.
    final int previousEventId = mNotificationTypeMap.get(id);
    if (priority(previousEventId) > priority(eventId)) {
        Slog.d(TAG, String.format("ignoring notification %s for network %s with existing notification %s", notifyType, id, NotificationType.getFromId(previousEventId)));
        return;
    }
    clearNotification(id);
    if (DBG) {
        Slog.d(TAG, String.format("showNotification tag=%s event=%s transport=%s extraInfo=%s highPrioriy=%s", tag, nameOf(eventId), getTransportName(transportType), extraInfo, highPriority));
    }
    Resources r = Resources.getSystem();
    CharSequence title;
    CharSequence details;
    int icon = getIcon(transportType);
    if (notifyType == NotificationType.NO_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, 0);
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.LOST_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, 0);
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.SIGN_IN) {
        switch(transportType) {
            case TRANSPORT_WIFI:
                title = r.getString(R.string.wifi_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, extraInfo);
                break;
            case TRANSPORT_CELLULAR:
                title = r.getString(R.string.network_available_sign_in, 0);
                // TODO: Change this to pull from NetworkInfo once a printable
                // name has been added to it
                details = mTelephonyManager.getNetworkOperatorName();
                break;
            default:
                title = r.getString(R.string.network_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, extraInfo);
                break;
        }
    } else if (notifyType == NotificationType.NETWORK_SWITCH) {
        String fromTransport = getTransportName(transportType);
        String toTransport = getTransportName(getFirstTransportType(switchToNai));
        title = r.getString(R.string.network_switch_metered, toTransport);
        details = r.getString(R.string.network_switch_metered_detail, toTransport, fromTransport);
    } else {
        Slog.wtf(TAG, "Unknown notification type " + notifyType + " on network transport " + getTransportName(transportType));
        return;
    }
    Notification.Builder builder = new Notification.Builder(mContext).setWhen(System.currentTimeMillis()).setShowWhen(notifyType == NotificationType.NETWORK_SWITCH).setSmallIcon(icon).setAutoCancel(true).setTicker(title).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentIntent(intent).setLocalOnly(true).setPriority(highPriority ? Notification.PRIORITY_HIGH : Notification.PRIORITY_DEFAULT).setDefaults(highPriority ? Notification.DEFAULT_ALL : 0).setOnlyAlertOnce(true);
    if (notifyType == NotificationType.NETWORK_SWITCH) {
        builder.setStyle(new Notification.BigTextStyle().bigText(details));
    } else {
        builder.setContentText(details);
    }
    Notification notification = builder.build();
    mNotificationTypeMap.put(id, eventId);
    try {
        mNotificationManager.notifyAsUser(tag, eventId, notification, UserHandle.ALL);
    } catch (NullPointerException npe) {
        Slog.d(TAG, "setNotificationVisible: visible notificationManager error", npe);
    }
}
#method_after
public void showNotification(int id, NotificationType notifyType, NetworkAgentInfo nai, NetworkAgentInfo switchToNai, PendingIntent intent, boolean highPriority) {
    final String tag = tagFor(id);
    final int eventId = notifyType.eventId;
    final int transportType;
    final String extraInfo;
    if (nai != null) {
        transportType = getFirstTransportType(nai);
        extraInfo = nai.networkInfo.getExtraInfo();
        // Only notify for Internet-capable networks.
        if (!nai.networkCapabilities.hasCapability(NET_CAPABILITY_INTERNET))
            return;
    } else {
        // Legacy notifications.
        transportType = TRANSPORT_CELLULAR;
        extraInfo = null;
    }
    // Clear any previous notification with lower priority, otherwise return. http://b/63676954.
    // A new SIGN_IN notification with a new intent should override any existing one.
    final int previousEventId = mNotificationTypeMap.get(id);
    final NotificationType previousNotifyType = NotificationType.getFromId(previousEventId);
    if (priority(previousNotifyType) > priority(notifyType)) {
        Slog.d(TAG, String.format("ignoring notification %s for network %s with existing notification %s", notifyType, id, previousNotifyType));
        return;
    }
    clearNotification(id);
    if (DBG) {
        Slog.d(TAG, String.format("showNotification tag=%s event=%s transport=%s extraInfo=%s highPrioriy=%s", tag, nameOf(eventId), getTransportName(transportType), extraInfo, highPriority));
    }
    Resources r = Resources.getSystem();
    CharSequence title;
    CharSequence details;
    int icon = getIcon(transportType);
    if (notifyType == NotificationType.NO_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, 0);
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.LOST_INTERNET && transportType == TRANSPORT_WIFI) {
        title = r.getString(R.string.wifi_no_internet, 0);
        details = r.getString(R.string.wifi_no_internet_detailed);
    } else if (notifyType == NotificationType.SIGN_IN) {
        switch(transportType) {
            case TRANSPORT_WIFI:
                title = r.getString(R.string.wifi_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, extraInfo);
                break;
            case TRANSPORT_CELLULAR:
                title = r.getString(R.string.network_available_sign_in, 0);
                // TODO: Change this to pull from NetworkInfo once a printable
                // name has been added to it
                details = mTelephonyManager.getNetworkOperatorName();
                break;
            default:
                title = r.getString(R.string.network_available_sign_in, 0);
                details = r.getString(R.string.network_available_sign_in_detailed, extraInfo);
                break;
        }
    } else if (notifyType == NotificationType.NETWORK_SWITCH) {
        String fromTransport = getTransportName(transportType);
        String toTransport = getTransportName(getFirstTransportType(switchToNai));
        title = r.getString(R.string.network_switch_metered, toTransport);
        details = r.getString(R.string.network_switch_metered_detail, toTransport, fromTransport);
    } else {
        Slog.wtf(TAG, "Unknown notification type " + notifyType + " on network transport " + getTransportName(transportType));
        return;
    }
    Notification.Builder builder = new Notification.Builder(mContext).setWhen(System.currentTimeMillis()).setShowWhen(notifyType == NotificationType.NETWORK_SWITCH).setSmallIcon(icon).setAutoCancel(true).setTicker(title).setColor(mContext.getColor(com.android.internal.R.color.system_notification_accent_color)).setContentTitle(title).setContentIntent(intent).setLocalOnly(true).setPriority(highPriority ? Notification.PRIORITY_HIGH : Notification.PRIORITY_DEFAULT).setDefaults(highPriority ? Notification.DEFAULT_ALL : 0).setOnlyAlertOnce(true);
    if (notifyType == NotificationType.NETWORK_SWITCH) {
        builder.setStyle(new Notification.BigTextStyle().bigText(details));
    } else {
        builder.setContentText(details);
    }
    Notification notification = builder.build();
    mNotificationTypeMap.put(id, eventId);
    try {
        mNotificationManager.notifyAsUser(tag, eventId, notification, UserHandle.ALL);
    } catch (NullPointerException npe) {
        Slog.d(TAG, "setNotificationVisible: visible notificationManager error", npe);
    }
}
#end_block

#method_before
private int priority(int eventId) {
    switch(eventId) {
        case MetricsEvent.NOTIFICATION_NETWORK_SIGN_IN:
            return 4;
        case MetricsEvent.NOTIFICATION_NETWORK_NO_INTERNET:
            return 3;
        case MetricsEvent.NOTIFICATION_NETWORK_SWITCH:
            return 2;
        case MetricsEvent.NOTIFICATION_NETWORK_LOST_INTERNET:
            return 1;
        default:
            return 0;
    }
}
#method_after
private static int priority(NotificationType t) {
    if (t == null) {
        return 0;
    }
    switch(t) {
        case SIGN_IN:
            return 4;
        case NO_INTERNET:
            return 3;
        case NETWORK_SWITCH:
            return 2;
        case LOST_INTERNET:
            return 1;
        default:
            return 0;
    }
}
#end_block

#method_before
@Override
protected void applyMutation(Mutation uncastMutation) {
    // Cast the Mutation to our AssociatedMutation, so we can access its fields.
    AssociatedMutation mutation = (AssociatedMutation) uncastMutation;
    MutatableCode mutatableCode = mutation.mutatableCode;
    MInsn newArrayInsn = newArrayLengthInsns.get(mutation.newArrayToChangeIdx);
    int newArrayInsnIdx = mutatableCode.getInstructionIndex(newArrayInsn);
    MInsn newInsn = new MInsn();
    newInsn.insn = new Instruction();
    newInsn.insn.info = Instruction.getOpcodeInfo(Opcode.CONST_16);
    newArrayInsn.insn.vregB = mutatableCode.getTemporaryVReg(0);
    newInsn.insn.vregA = (int) newArrayInsn.insn.vregB;
    // New length chosen randomly between 1 to 100.
    newInsn.insn.vregB = rng.nextInt(100);
    mutatableCode.insertInstructionAt(newInsn, newArrayInsnIdx);
    Log.info("Changed the length of the array to " + newInsn.insn.vregB);
    stats.incrementStat("Changed length of new array");
}
#method_after
@Override
protected void applyMutation(Mutation uncastMutation) {
    // Cast the Mutation to our AssociatedMutation, so we can access its fields.
    AssociatedMutation mutation = (AssociatedMutation) uncastMutation;
    MutatableCode mutatableCode = mutation.mutatableCode;
    MInsn newArrayInsn = newArrayLengthInsns.get(mutation.newArrayToChangeIdx);
    int newArrayInsnIdx = mutatableCode.getInstructionIndex(newArrayInsn);
    // bail by doing nothing.
    if (newArrayInsnIdx < 0) {
        newArrayInsnIdx = scanNewArray(mutatableCode);
        if (newArrayInsnIdx == -1) {
            return;
        }
    }
    MInsn newInsn = new MInsn();
    newInsn.insn = new Instruction();
    newInsn.insn.info = Instruction.getOpcodeInfo(Opcode.CONST_16);
    mutatableCode.allocateTemporaryVRegs(1);
    newArrayInsn.insn.vregB = mutatableCode.getTemporaryVReg(0);
    newInsn.insn.vregA = (int) newArrayInsn.insn.vregB;
    // New length chosen randomly between 1 to 100.
    newInsn.insn.vregB = rng.nextInt(100);
    mutatableCode.insertInstructionAt(newInsn, newArrayInsnIdx);
    Log.info("Changed the length of the array to " + newInsn.insn.vregB);
    stats.incrementStat("Changed length of new array");
    mutatableCode.finishedUsingTemporaryVRegs();
}
#end_block

#method_before
public void probeAll() {
    Set<InetAddress> ipProbeList = new HashSet<InetAddress>();
    synchronized (mLock) {
        ipProbeList.addAll(mIpWatchList.keySet());
    }
    if (!ipProbeList.isEmpty() && stillRunning()) {
        // Keep the CPU awake long enough to allow all ARP/ND
        // probes a reasonable chance at success. See b/23197666.
        // 
        // The wakelock we use is (by default) refcounted, and this version
        // of acquire(timeout) queues a release message to keep acquisitions
        // and releases balanced.
        mConfig.acquireWakeLock(getProbeWakeLockDuration());
    }
    for (InetAddress target : ipProbeList) {
        if (!stillRunning()) {
            break;
        }
        final int returnValue = probeNeighbor(mInterfaceIndex, target);
        mLog.log(String.format("put neighbor %s into NUD_PROBE state (rval=%d)", target.getHostAddress(), returnValue));
        logEvent(IpReachabilityEvent.PROBE, returnValue);
    }
    mLastProbeTimeMs = SystemClock.elapsedRealtime();
}
#method_after
public void probeAll() {
    Set<InetAddress> ipProbeList = new HashSet<InetAddress>();
    synchronized (mLock) {
        ipProbeList.addAll(mIpWatchList.keySet());
    }
    if (!ipProbeList.isEmpty() && stillRunning()) {
        // Keep the CPU awake long enough to allow all ARP/ND
        // probes a reasonable chance at success. See b/23197666.
        // 
        // The wakelock we use is (by default) refcounted, and this version
        // of acquire(timeout) queues a release message to keep acquisitions
        // and releases balanced.
        mDependencies.acquireWakeLock(getProbeWakeLockDuration());
    }
    for (InetAddress target : ipProbeList) {
        if (!stillRunning()) {
            break;
        }
        final int returnValue = probeNeighbor(mInterfaceIndex, target);
        mLog.log(String.format("put neighbor %s into NUD_PROBE state (rval=%d)", target.getHostAddress(), returnValue));
        logEvent(IpReachabilityEvent.PROBE, returnValue);
    }
    mLastProbeTimeMs = SystemClock.elapsedRealtime();
}
#end_block

#method_before
private static int getInterfaceIndex(String iface) {
    try {
        return NetworkInterface.getByName(iface).getIndex();
    } catch (SocketException e) {
        throw new IllegalArgumentException("invalid interface '" + iface + "': ", e);
    }
}
#method_after
private static int getInterfaceIndex(String ifname) {
    final NetworkInterface iface;
    try {
        iface = NetworkInterface.getByName(ifname);
    } catch (SocketException e) {
        throw new IllegalArgumentException("invalid interface '" + ifname + "': ", e);
    }
    if (iface == null) {
        throw new IllegalArgumentException("NetworkInterface was null for " + ifname);
    }
    return iface.getIndex();
}
#end_block

#method_before
IpReachabilityMonitor makeMonitor() {
    return new IpReachabilityMonitor("fake0", 1, mLog, mCallback, null, mConfig);
}
#method_after
IpReachabilityMonitor makeMonitor() {
    return new IpReachabilityMonitor("fake0", 1, mLog, mCallback, null, mDependencies);
}
#end_block

#method_before
@Test
public void test_singleFile() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path file = Paths.get(filesSetup.getTestDir(), "directory/file");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(file));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE
    Files.createFile(file);
    assertWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1)), true);
    assertNull(watchService.poll());
    // emit EVENT_MODIFY
    Files.write(file, "hello1".getBytes());
    assertWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_MODIFY)), true);
    // http:///b/35346596
    // Sometimes we receive a second, latent EVENT_MODIFY that happens shortly
    // after the first one. This will intercept it and make sure it won't
    // mess with ENTRY_DELETE later.
    Thread.sleep(500);
    WatchKey doubleModifyKey = watchService.poll();
    if (doubleModifyKey != null) {
        List<WatchEvent<?>> event = doubleModifyKey.pollEvents();
        assertEquals(ENTRY_MODIFY, event.get(0).kind());
        doubleModifyKey.reset();
    }
    assertNull(watchService.poll());
    // emit EVENT_DELETE
    Files.delete(file);
    assertWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_DELETE, 1)), true);
    // Assert no more events
    assertNull(watchService.poll());
    watchService.close();
}
#method_after
@Test
public void test_singleFile() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path file = Paths.get(filesSetup.getTestDir(), "directory/file");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(file));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE
    Files.createFile(file);
    checkWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1)), true);
    assertNull(watchService.poll());
    // emit EVENT_MODIFY
    Files.write(file, "hello1".getBytes());
    checkWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_MODIFY)), true);
    // http:///b/35346596
    // Sometimes we receive a second, latent EVENT_MODIFY that happens shortly
    // after the first one. This will intercept it and make sure it won't
    // mess with ENTRY_DELETE later.
    Thread.sleep(500);
    WatchKey doubleModifyKey = watchService.poll();
    if (doubleModifyKey != null) {
        List<WatchEvent<?>> event = doubleModifyKey.pollEvents();
        assertEquals(ENTRY_MODIFY, event.get(0).kind());
        doubleModifyKey.reset();
    }
    assertNull(watchService.poll());
    // emit EVENT_DELETE
    Files.delete(file);
    checkWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_DELETE, 1)), true);
    // Assert no more events
    assertNull(watchService.poll());
    watchService.close();
}
#end_block

#method_before
@Test
public void test_EventMask() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    WatchEvent.Kind<?>[] events = { ENTRY_DELETE };
    Path file = Paths.get(filesSetup.getTestDir(), "directory/file");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(file));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, events);
    // emit EVENT_CREATE
    Files.createFile(file);
    // emit EVENT_MODIFY (masked)
    Files.write(file, "hello1".getBytes());
    // emit EVENT_DELETE (masked)
    Files.delete(file);
    assertWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_DELETE, 1)), true);
    assertNull(watchService.poll());
    watchService.close();
}
#method_after
@Test
public void test_EventMask() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    WatchEvent.Kind<?>[] events = { ENTRY_DELETE };
    Path file = Paths.get(filesSetup.getTestDir(), "directory/file");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(file));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, events);
    // emit EVENT_CREATE
    Files.createFile(file);
    // emit EVENT_MODIFY (masked)
    Files.write(file, "hello1".getBytes());
    // emit EVENT_DELETE (masked)
    Files.delete(file);
    checkWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_DELETE, 1)), true);
    assertNull(watchService.poll());
    watchService.close();
}
#end_block

#method_before
@Test
public void test_singleDirectory() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path dirInDir = Paths.get(filesSetup.getTestDir(), "directory/dir");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(dirInDir));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE
    Files.createDirectories(dirInDir);
    // Shouldn't emit EVENT_MODIFY
    Path dirInDirInDir = Paths.get(filesSetup.getTestDir(), "directory/dir/dir");
    Files.createDirectories(dirInDirInDir);
    Files.delete(dirInDirInDir);
    // emit EVENT_DELETE
    Files.delete(dirInDir);
    assertWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), true);
    assertNull(watchService.poll());
    watchService.close();
    watchService.close();
}
#method_after
@Test
public void test_singleDirectory() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path dirInDir = Paths.get(filesSetup.getTestDir(), "directory/dir");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(dirInDir));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE
    Files.createDirectories(dirInDir);
    // Shouldn't emit EVENT_MODIFY
    Path dirInDirInDir = Paths.get(filesSetup.getTestDir(), "directory/dir/dir");
    Files.createDirectories(dirInDirInDir);
    Files.delete(dirInDirInDir);
    // emit EVENT_DELETE
    Files.delete(dirInDir);
    checkWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), true);
    assertNull(watchService.poll());
    watchService.close();
    watchService.close();
}
#end_block

#method_before
@Test
public void test_cancel() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path file = Paths.get(filesSetup.getTestDir(), "directory/file");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(file));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE
    Files.createFile(file);
    // Canceling the key may prevent the EVENT_CREATE from being picked-up...
    // TODO: Fix this (b/35190858).
    Thread.sleep(500);
    // Cancel the key
    directoryKey1.cancel();
    assertFalse(directoryKey1.isValid());
    // Shouldn't emit EVENT_MODIFY and EVENT_DELETE
    Files.write(file, "hello1".getBytes());
    Files.delete(file);
    assertWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1)), false);
    assertNull(watchService.poll());
    watchService.close();
}
#method_after
@Test
public void test_cancel() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path file = Paths.get(filesSetup.getTestDir(), "directory/file");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(file));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE
    Files.createFile(file);
    // Canceling the key may prevent the EVENT_CREATE from being picked-up...
    // TODO: Fix this (b/35190858).
    Thread.sleep(500);
    // Cancel the key
    directoryKey1.cancel();
    assertFalse(directoryKey1.isValid());
    // Shouldn't emit EVENT_MODIFY and EVENT_DELETE
    Files.write(file, "hello1".getBytes());
    Files.delete(file);
    checkWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1)), false);
    assertNull(watchService.poll());
    watchService.close();
}
#end_block

#method_before
@Test
public void test_removeTarget() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path file = Paths.get(filesSetup.getTestDir(), "directory/file");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(file));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE x1
    Files.createFile(file);
    Files.delete(file);
    // Delete underlying target.
    assertTrue(directoryKey1.isValid());
    Files.delete(directory);
    // deletion
    while (directoryKey1.isValid()) {
        Thread.sleep(500);
    }
    assertWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), false);
    assertNull(watchService.poll());
    watchService.close();
}
#method_after
@Test
public void test_removeTarget() throws Exception {
    WatchService watchService = FileSystems.getDefault().newWatchService();
    Path file = Paths.get(filesSetup.getTestDir(), "directory/file");
    Path directory = Paths.get(filesSetup.getTestDir(), "directory");
    assertFalse(Files.exists(file));
    Files.createDirectories(directory);
    WatchKey directoryKey1 = directory.register(watchService, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE x1
    Files.createFile(file);
    Files.delete(file);
    // Delete underlying target.
    assertTrue(directoryKey1.isValid());
    Files.delete(directory);
    // deletion
    while (directoryKey1.isValid()) {
        Thread.sleep(500);
    }
    checkWatchServiceEvent(watchService, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), false);
    assertNull(watchService.poll());
    watchService.close();
}
#end_block

#method_before
@Test
public void test_multipleKeys() throws Exception {
    WatchService watchService1 = FileSystems.getDefault().newWatchService();
    Path directory1 = Paths.get(filesSetup.getTestDir(), "directory1");
    Path directory2 = Paths.get(filesSetup.getTestDir(), "directory2");
    Path dir1file1 = Paths.get(filesSetup.getTestDir(), "directory1/file1");
    assertFalse(Files.exists(dir1file1));
    Path dir2file1 = Paths.get(filesSetup.getTestDir(), "directory2/file1");
    assertFalse(Files.exists(dir2file1));
    Files.createDirectories(directory1);
    Files.createDirectories(directory2);
    WatchKey directoryKey1 = directory1.register(watchService1, ALL_EVENTS_KINDS);
    WatchKey directoryKey2 = directory2.register(watchService1, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE/DELETE for all
    Path[] allFiles = new Path[] { dir1file1, dir2file1 };
    for (Path path : allFiles) {
        Files.createFile(path);
        Files.delete(path);
    }
    Map<WatchKey, List<WatchEventResult>> expected = new HashMap<>();
    expected.put(directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)));
    expected.put(directoryKey2, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)));
    assertWatchServiceEventMultipleKeys(watchService1, expected, true);
    assertNull(watchService1.poll());
    watchService1.close();
}
#method_after
@Test
public void test_multipleKeys() throws Exception {
    WatchService watchService1 = FileSystems.getDefault().newWatchService();
    Path directory1 = Paths.get(filesSetup.getTestDir(), "directory1");
    Path directory2 = Paths.get(filesSetup.getTestDir(), "directory2");
    Path dir1file1 = Paths.get(filesSetup.getTestDir(), "directory1/file1");
    assertFalse(Files.exists(dir1file1));
    Path dir2file1 = Paths.get(filesSetup.getTestDir(), "directory2/file1");
    assertFalse(Files.exists(dir2file1));
    Files.createDirectories(directory1);
    Files.createDirectories(directory2);
    WatchKey directoryKey1 = directory1.register(watchService1, ALL_EVENTS_KINDS);
    WatchKey directoryKey2 = directory2.register(watchService1, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE/DELETE for all
    Path[] allFiles = new Path[] { dir1file1, dir2file1 };
    for (Path path : allFiles) {
        Files.createFile(path);
        Files.delete(path);
    }
    Map<WatchKey, List<WatchEventResult>> expected = new HashMap<>();
    expected.put(directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)));
    expected.put(directoryKey2, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)));
    checkWatchServiceEventMultipleKeys(watchService1, expected, true);
    assertNull(watchService1.poll());
    watchService1.close();
}
#end_block

#method_before
@Test
public void test_multipleServices() throws Exception {
    WatchService watchService1 = FileSystems.getDefault().newWatchService();
    WatchService watchService2 = FileSystems.getDefault().newWatchService();
    Path directory1 = Paths.get(filesSetup.getTestDir(), "directory1");
    Path directory2 = Paths.get(filesSetup.getTestDir(), "directory2");
    Path dir1file1 = Paths.get(filesSetup.getTestDir(), "directory1/file1");
    assertFalse(Files.exists(dir1file1));
    Path dir2file1 = Paths.get(filesSetup.getTestDir(), "directory2/file1");
    assertFalse(Files.exists(dir2file1));
    Files.createDirectories(directory1);
    Files.createDirectories(directory2);
    // 2 services listening for distinct directories
    WatchKey directoryKey1 = directory1.register(watchService1, ALL_EVENTS_KINDS);
    WatchKey directoryKey2 = directory2.register(watchService2, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE/DELETE for all
    Path[] allFiles = new Path[] { dir1file1, dir2file1 };
    for (Path path : allFiles) {
        Files.createFile(path);
        Files.delete(path);
    }
    assertWatchServiceEvent(watchService1, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), true);
    assertWatchServiceEvent(watchService2, directoryKey2, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), true);
    // 2 services listening for a same directory
    WatchKey directoryKey3 = directory1.register(watchService2, ALL_EVENTS_KINDS);
    {
        Files.createFile(dir1file1);
        Files.delete(dir1file1);
    }
    assertWatchServiceEvent(watchService1, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), true);
    assertWatchServiceEvent(watchService2, directoryKey3, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), true);
    assertNull(watchService1.poll());
    watchService1.close();
    assertNull(watchService2.poll());
    watchService2.close();
}
#method_after
@Test
public void test_multipleServices() throws Exception {
    WatchService watchService1 = FileSystems.getDefault().newWatchService();
    WatchService watchService2 = FileSystems.getDefault().newWatchService();
    Path directory1 = Paths.get(filesSetup.getTestDir(), "directory1");
    Path directory2 = Paths.get(filesSetup.getTestDir(), "directory2");
    Path dir1file1 = Paths.get(filesSetup.getTestDir(), "directory1/file1");
    assertFalse(Files.exists(dir1file1));
    Path dir2file1 = Paths.get(filesSetup.getTestDir(), "directory2/file1");
    assertFalse(Files.exists(dir2file1));
    Files.createDirectories(directory1);
    Files.createDirectories(directory2);
    // 2 services listening for distinct directories
    WatchKey directoryKey1 = directory1.register(watchService1, ALL_EVENTS_KINDS);
    WatchKey directoryKey2 = directory2.register(watchService2, ALL_EVENTS_KINDS);
    // emit EVENT_CREATE/DELETE for all
    Path[] allFiles = new Path[] { dir1file1, dir2file1 };
    for (Path path : allFiles) {
        Files.createFile(path);
        Files.delete(path);
    }
    checkWatchServiceEvent(watchService1, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), true);
    checkWatchServiceEvent(watchService2, directoryKey2, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), true);
    // 2 services listening for a same directory
    WatchKey directoryKey3 = directory1.register(watchService2, ALL_EVENTS_KINDS);
    {
        Files.createFile(dir1file1);
        Files.delete(dir1file1);
    }
    checkWatchServiceEvent(watchService1, directoryKey1, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), true);
    checkWatchServiceEvent(watchService2, directoryKey3, Arrays.asList(new WatchEventResult(ENTRY_CREATE, 1), new WatchEventResult(ENTRY_DELETE, 1)), true);
    assertNull(watchService1.poll());
    watchService1.close();
    assertNull(watchService2.poll());
    watchService2.close();
}
#end_block

#method_before
public final void release() throws RemoteException {
    synchronized (IpSecService.this) {
        if (isReferenced()) {
            throw new IllegalStateException("Cannot release a resource that has active references!");
        }
        if (mResourceId == INVALID_RESOURCE_ID) {
            return;
        }
        releaseResources();
        getResourceTracker().give();
        if (mBinder != null) {
            mBinder.unlinkToDeath(this, 0);
        }
        mBinder = null;
        mResourceId = INVALID_RESOURCE_ID;
    }
}
#method_after
public final void release() throws RemoteException {
    synchronized (IpSecService.this) {
        if (isReferenced()) {
            throw new IllegalStateException("Cannot release a resource that has active references!");
        }
        if (mResourceId == INVALID_RESOURCE_ID) {
            return;
        }
        releaseResources();
        if (mBinder != null) {
            mBinder.unlinkToDeath(this, 0);
        }
        mBinder = null;
        mResourceId = INVALID_RESOURCE_ID;
    }
}
#end_block

#method_before
T get(int key) {
    T val = mArray.get(key);
    val.checkOwnerOrSystemAndThrow();
    return val;
}
#method_after
T get(int key) {
    T val = mArray.get(key);
    // (since we do not allow null resources to be added).
    if (val != null) {
        val.checkOwnerOrSystemAndThrow();
    }
    return val;
}
#end_block

#method_before
@Override
protected void releaseResources() {
    for (int direction : DIRECTIONS) {
        int spi = mSpis[direction].getSpi();
        try {
            getNetdInstance().ipSecDeleteSecurityAssociation(mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", spi);
        } catch (ServiceSpecificException e) {
        // FIXME: get the error code and throw is at an IOException from Errno Exception
        } catch (RemoteException e) {
            Log.e(TAG, "Failed to delete SA with ID: " + mResourceId);
        }
    }
    for (int direction : DIRECTIONS) {
        mSpis[direction].removeReference();
    }
    if (mSocket != null) {
        mSocket.removeReference();
    }
}
#method_after
@Override
protected void releaseResources() {
    for (int direction : DIRECTIONS) {
        int spi = mSpis[direction].getSpi();
        try {
            mSrvConfig.getNetdInstance().ipSecDeleteSecurityAssociation(mResourceId, direction, (mConfig.getLocalAddress() != null) ? mConfig.getLocalAddress().getHostAddress() : "", (mConfig.getRemoteAddress() != null) ? mConfig.getRemoteAddress().getHostAddress() : "", spi);
        } catch (ServiceSpecificException e) {
        // FIXME: get the error code and throw is at an IOException from Errno Exception
        } catch (RemoteException e) {
            Log.e(TAG, "Failed to delete SA with ID: " + mResourceId);
        }
    }
    for (int direction : DIRECTIONS) {
        mSpis[direction].removeReference();
    }
    if (mSocket != null) {
        mSocket.removeReference();
    }
}
#end_block

#method_before
@Override
protected void releaseResources() {
    if (mOwnedByTransform) {
        Log.d(TAG, "Cannot release Spi " + mSpi + ": Currently locked by a Transform");
        // they are applied in a Transform object.
        return;
    }
    try {
        getNetdInstance().ipSecDeleteSecurityAssociation(mResourceId, mDirection, mLocalAddress, mRemoteAddress, mSpi);
    } catch (ServiceSpecificException e) {
    // FIXME: get the error code and throw is at an IOException from Errno Exception
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to delete SPI reservation with ID: " + mResourceId);
    }
    mSpi = IpSecManager.INVALID_SECURITY_PARAMETER_INDEX;
}
#method_after
@Override
protected void releaseResources() {
    if (mOwnedByTransform) {
        Log.d(TAG, "Cannot release Spi " + mSpi + ": Currently locked by a Transform");
        // they are applied in a Transform object.
        return;
    }
    try {
        mSrvConfig.getNetdInstance().ipSecDeleteSecurityAssociation(mResourceId, mDirection, mLocalAddress, mRemoteAddress, mSpi);
    } catch (ServiceSpecificException e) {
    // FIXME: get the error code and throw is at an IOException from Errno Exception
    } catch (RemoteException e) {
        Log.e(TAG, "Failed to delete SPI reservation with ID: " + mResourceId);
    }
    mSpi = IpSecManager.INVALID_SECURITY_PARAMETER_INDEX;
}
#end_block

#method_before
public void setOwnedByTransform() {
    if (mOwnedByTransform) {
        // Programming error
        new IllegalStateException("Cannot own an SPI twice!");
    }
    mOwnedByTransform = true;
}
#method_after
public void setOwnedByTransform() {
    if (mOwnedByTransform) {
        // Programming error
        throw new IllegalStateException("Cannot own an SPI twice!");
    }
    mOwnedByTransform = true;
}
#end_block

#method_before
private void connectNativeNetdService() {
    // Avoid blocking the system server to do this
    Thread t = new Thread(new Runnable() {

        @Override
        public void run() {
            synchronized (IpSecService.this) {
                NetdService.get(NETD_FETCH_TIMEOUT);
            }
        }
    });
    t.run();
}
#method_after
private void connectNativeNetdService() {
    // Avoid blocking the system server to do this
    new Thread() {

        @Override
        public void run() {
            synchronized (IpSecService.this) {
                NetdService.get(NETD_FETCH_TIMEOUT_MS);
            }
        }
    }.start();
}
#end_block

#method_before
synchronized boolean isNetdAlive() {
    try {
        final INetd netd = getNetdInstance();
        if (netd == null) {
            return false;
        }
        return netd.isAlive();
    } catch (RemoteException re) {
        return false;
    }
}
#method_after
synchronized boolean isNetdAlive() {
    try {
        final INetd netd = mSrvConfig.getNetdInstance();
        if (netd == null) {
            return false;
        }
        return netd.isAlive();
    } catch (RemoteException re) {
        return false;
    }
}
#end_block

#method_before
@Override
public synchronized /**
 * Get a new SPI and maintain the reservation in the system server
 */
IpSecSpiResponse reserveSecurityParameterIndex(int direction, String remoteAddress, int requestedSpi, IBinder binder) throws RemoteException {
    int resourceId = mNextResourceId.getAndIncrement();
    int spi = IpSecManager.INVALID_SECURITY_PARAMETER_INDEX;
    String localAddress = "";
    try {
        if (!mUserQuotaTracker.getUserRecord(Binder.getCallingUid()).spi.isAvailable()) {
            return new IpSecSpiResponse(IpSecManager.Status.RESOURCE_UNAVAILABLE, IpSecManager.INVALID_RESOURCE_ID, spi);
        }
        spi = getNetdInstance().ipSecAllocateSpi(resourceId, direction, localAddress, remoteAddress, requestedSpi);
        Log.d(TAG, "Allocated SPI " + spi);
        mSpiRecords.put(resourceId, new SpiRecord(resourceId, binder, direction, localAddress, remoteAddress, spi));
    } catch (ServiceSpecificException e) {
        /* TODO: Add appropriate checks when other ServiceSpecificException types are supported */
        return new IpSecSpiResponse(IpSecManager.Status.SPI_UNAVAILABLE, INVALID_RESOURCE_ID, spi);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return new IpSecSpiResponse(IpSecManager.Status.OK, resourceId, spi);
}
#method_after
@Override
public synchronized /**
 * Get a new SPI and maintain the reservation in the system server
 */
IpSecSpiResponse reserveSecurityParameterIndex(int direction, String remoteAddress, int requestedSpi, IBinder binder) throws RemoteException {
    int resourceId = mNextResourceId.getAndIncrement();
    int spi = IpSecManager.INVALID_SECURITY_PARAMETER_INDEX;
    String localAddress = "";
    try {
        spi = mSrvConfig.getNetdInstance().ipSecAllocateSpi(resourceId, direction, localAddress, remoteAddress, requestedSpi);
        Log.d(TAG, "Allocated SPI " + spi);
        mSpiRecords.put(resourceId, new SpiRecord(resourceId, binder, direction, localAddress, remoteAddress, spi));
    } catch (ServiceSpecificException e) {
        // TODO: Add appropriate checks when other ServiceSpecificException types are supported
        return new IpSecSpiResponse(IpSecManager.Status.SPI_UNAVAILABLE, IpSecManager.INVALID_RESOURCE_ID, spi);
    } catch (RemoteException e) {
        throw e.rethrowFromSystemServer();
    }
    return new IpSecSpiResponse(IpSecManager.Status.OK, resourceId, spi);
}
#end_block

#method_before
@Override
public synchronized IpSecUdpEncapResponse openUdpEncapsulationSocket(int port, IBinder binder) throws RemoteException {
    if (port != 0 && (port < FREE_PORT_MIN || port > PORT_MAX)) {
        throw new IllegalArgumentException("Specified port number must be a valid non-reserved UDP port");
    }
    int resourceId = mNextResourceId.getAndIncrement();
    FileDescriptor sockFd = null;
    try {
        if (!mUserQuotaTracker.getUserRecord(Binder.getCallingUid()).spi.isAvailable()) {
            return new IpSecUdpEncapResponse(IpSecManager.Status.RESOURCE_UNAVAILABLE);
        }
        sockFd = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if (port != 0) {
            Log.v(TAG, "Binding to port " + port);
            Os.bind(sockFd, INADDR_ANY, port);
        } else {
            bindToRandomPort(sockFd);
        }
        // This code is common to both the unspecified and specified port cases
        Os.setsockoptInt(sockFd, OsConstants.IPPROTO_UDP, OsConstants.UDP_ENCAP, OsConstants.UDP_ENCAP_ESPINUDP);
        mUdpSocketRecords.put(resourceId, new UdpSocketRecord(resourceId, binder, sockFd, port));
        return new IpSecUdpEncapResponse(IpSecManager.Status.OK, resourceId, port, sockFd);
    } catch (IOException | ErrnoException e) {
        IoUtils.closeQuietly(sockFd);
    }
    // The only reasonable condition that would cause that is resource unavailable.
    return new IpSecUdpEncapResponse(IpSecManager.Status.RESOURCE_UNAVAILABLE);
}
#method_after
@Override
public synchronized IpSecUdpEncapResponse openUdpEncapsulationSocket(int port, IBinder binder) throws RemoteException {
    if (port != 0 && (port < FREE_PORT_MIN || port > PORT_MAX)) {
        throw new IllegalArgumentException("Specified port number must be a valid non-reserved UDP port");
    }
    int resourceId = mNextResourceId.getAndIncrement();
    FileDescriptor sockFd = null;
    try {
        sockFd = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        if (port != 0) {
            Log.v(TAG, "Binding to port " + port);
            Os.bind(sockFd, INADDR_ANY, port);
        } else {
            bindToRandomPort(sockFd);
        }
        // This code is common to both the unspecified and specified port cases
        Os.setsockoptInt(sockFd, OsConstants.IPPROTO_UDP, OsConstants.UDP_ENCAP, OsConstants.UDP_ENCAP_ESPINUDP);
        mUdpSocketRecords.put(resourceId, new UdpSocketRecord(resourceId, binder, sockFd, port));
        return new IpSecUdpEncapResponse(IpSecManager.Status.OK, resourceId, port, sockFd);
    } catch (IOException | ErrnoException e) {
        IoUtils.closeQuietly(sockFd);
    }
    // The only reasonable condition that would cause that is resource unavailable.
    return new IpSecUdpEncapResponse(IpSecManager.Status.RESOURCE_UNAVAILABLE);
}
#end_block

#method_before
@Override
public synchronized IpSecTransformResponse createTransportModeTransform(IpSecConfig c, IBinder binder) throws RemoteException {
    int resourceId = mNextResourceId.getAndIncrement();
    if (!mUserQuotaTracker.getUserRecord(Binder.getCallingUid()).spi.isAvailable()) {
        return new IpSecTransformResponse(IpSecManager.Status.RESOURCE_UNAVAILABLE);
    }
    SpiRecord[] spis = new SpiRecord[DIRECTIONS.length];
    // TODO: Basic input validation here since it's coming over the Binder
    int encapType, encapLocalPort = 0, encapRemotePort = 0;
    UdpSocketRecord socketRecord = null;
    encapType = c.getEncapType();
    if (encapType != IpSecTransform.ENCAP_NONE) {
        socketRecord = mUdpSocketRecords.get(c.getEncapLocalResourceId());
        encapLocalPort = socketRecord.getPort();
        encapRemotePort = c.getEncapRemotePort();
    }
    for (int direction : DIRECTIONS) {
        IpSecAlgorithm auth = c.getAuthentication(direction);
        IpSecAlgorithm crypt = c.getEncryption(direction);
        spis[direction] = mSpiRecords.get(c.getSpiResourceId(direction));
        int spi = spis[direction].getSpi();
        try {
            int result = getNetdInstance().ipSecAddSecurityAssociation(resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", (c.getNetwork() != null) ? c.getNetwork().getNetworkHandle() : 0, spi, (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "", (crypt != null) ? crypt.getKey() : null, (crypt != null) ? crypt.getTruncationLengthBits() : 0, encapType, encapLocalPort, encapRemotePort);
            if (result != spi) {
                // TODO: cleanup the first SA if creation of second SA fails
                return new IpSecTransformResponse(IpSecManager.Status.SPI_UNAVAILABLE);
            }
        } catch (ServiceSpecificException e) {
        // FIXME: get the error code and throw is at an IOException from Errno Exception
        }
    }
    // Both SAs were created successfully, time to construct a record and lock it away
    mTransformRecords.put(resourceId, new TransformRecord(resourceId, binder, c, spis, socketRecord));
    return new IpSecTransformResponse(IpSecManager.Status.OK, resourceId);
}
#method_after
@Override
public synchronized IpSecTransformResponse createTransportModeTransform(IpSecConfig c, IBinder binder) throws RemoteException {
    int resourceId = mNextResourceId.getAndIncrement();
    SpiRecord[] spis = new SpiRecord[DIRECTIONS.length];
    // TODO: Basic input validation here since it's coming over the Binder
    int encapType, encapLocalPort = 0, encapRemotePort = 0;
    UdpSocketRecord socketRecord = null;
    encapType = c.getEncapType();
    if (encapType != IpSecTransform.ENCAP_NONE) {
        socketRecord = mUdpSocketRecords.get(c.getEncapLocalResourceId());
        encapLocalPort = socketRecord.getPort();
        encapRemotePort = c.getEncapRemotePort();
    }
    for (int direction : DIRECTIONS) {
        IpSecAlgorithm auth = c.getAuthentication(direction);
        IpSecAlgorithm crypt = c.getEncryption(direction);
        spis[direction] = mSpiRecords.get(c.getSpiResourceId(direction));
        int spi = spis[direction].getSpi();
        try {
            mSrvConfig.getNetdInstance().ipSecAddSecurityAssociation(resourceId, c.getMode(), direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", (c.getNetwork() != null) ? c.getNetwork().getNetworkHandle() : 0, spi, (auth != null) ? auth.getName() : "", (auth != null) ? auth.getKey() : null, (auth != null) ? auth.getTruncationLengthBits() : 0, (crypt != null) ? crypt.getName() : "", (crypt != null) ? crypt.getKey() : null, (crypt != null) ? crypt.getTruncationLengthBits() : 0, encapType, encapLocalPort, encapRemotePort);
        } catch (ServiceSpecificException e) {
            // FIXME: get the error code and throw is at an IOException from Errno Exception
            return new IpSecTransformResponse(IpSecManager.Status.RESOURCE_UNAVAILABLE);
        }
    }
    // Both SAs were created successfully, time to construct a record and lock it away
    mTransformRecords.put(resourceId, new TransformRecord(resourceId, binder, c, spis, socketRecord));
    return new IpSecTransformResponse(IpSecManager.Status.OK, resourceId);
}
#end_block

#method_before
@Override
public synchronized void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException {
    // Synchronize liberally here because we are using ManagedResources in this block
    TransformRecord info;
    // FIXME: this code should be factored out into a security check + getter
    info = mTransformRecords.get(resourceId);
    if (info == null) {
        throw new IllegalArgumentException("Transform " + resourceId + " is not active");
    }
    // TODO: make this a function.
    if (info.pid != getCallingPid() || info.uid != getCallingUid()) {
        throw new SecurityException("Only the owner of an IpSec Transform may apply it!");
    }
    IpSecConfig c = info.getConfig();
    try {
        for (int direction : DIRECTIONS) {
            getNetdInstance().ipSecApplyTransportModeTransform(socket.getFileDescriptor(), resourceId, direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", info.getSpiRecord(direction).getSpi());
        }
    } catch (ServiceSpecificException e) {
    // FIXME: get the error code and throw is at an IOException from Errno Exception
    }
}
#method_after
@Override
public synchronized void applyTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException {
    // Synchronize liberally here because we are using ManagedResources in this block
    TransformRecord info;
    // FIXME: this code should be factored out into a security check + getter
    info = mTransformRecords.get(resourceId);
    if (info == null) {
        throw new IllegalArgumentException("Transform " + resourceId + " is not active");
    }
    // TODO: make this a function.
    if (info.pid != getCallingPid() || info.uid != getCallingUid()) {
        throw new SecurityException("Only the owner of an IpSec Transform may apply it!");
    }
    IpSecConfig c = info.getConfig();
    try {
        for (int direction : DIRECTIONS) {
            mSrvConfig.getNetdInstance().ipSecApplyTransportModeTransform(socket.getFileDescriptor(), resourceId, direction, (c.getLocalAddress() != null) ? c.getLocalAddress().getHostAddress() : "", (c.getRemoteAddress() != null) ? c.getRemoteAddress().getHostAddress() : "", info.getSpiRecord(direction).getSpi());
        }
    } catch (ServiceSpecificException e) {
    // FIXME: get the error code and throw is at an IOException from Errno Exception
    }
}
#end_block

#method_before
@Override
public void removeTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException {
    try {
        getNetdInstance().ipSecRemoveTransportModeTransform(socket.getFileDescriptor());
    } catch (ServiceSpecificException e) {
    // FIXME: get the error code and throw is at an IOException from Errno Exception
    }
}
#method_after
@Override
public void removeTransportModeTransform(ParcelFileDescriptor socket, int resourceId) throws RemoteException {
    try {
        mSrvConfig.getNetdInstance().ipSecRemoveTransportModeTransform(socket.getFileDescriptor());
    } catch (ServiceSpecificException e) {
    // FIXME: get the error code and throw is at an IOException from Errno Exception
    }
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    mContext.enforceCallingOrSelfPermission(DUMP, TAG);
    // TODO: Add dump code to print out a log of all the resources being tracked
    pw.println("IpSecService Log:");
    pw.println("NetdNativeService Connection: " + (isNetdAlive() ? "alive" : "dead"));
    pw.println();
    dumpUserQuota(pw);
    dumpTransformRecords(pw);
}
#method_after
@Override
protected synchronized void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
    mContext.enforceCallingOrSelfPermission(DUMP, TAG);
    pw.println("IpSecService dump:");
    pw.println("NetdNativeService Connection: " + (isNetdAlive() ? "alive" : "dead"));
    pw.println();
    pw.println("mTransformRecords:");
    pw.println(mTransformRecords);
    pw.println("mUdpSocketRecords:");
    pw.println(mUdpSocketRecords);
    pw.println("mSpiRecords:");
    pw.println(mSpiRecords);
}
#end_block

#method_before
private boolean handleParentProc(int pid, FileDescriptor[] descriptors, FileDescriptor pipeFd, Arguments parsedArgs) {
    if (pid > 0) {
        setChildPgid(pid);
    }
    if (descriptors != null) {
        for (FileDescriptor fd : descriptors) {
            IoUtils.closeQuietly(fd);
        }
    }
    boolean usingWrapper = false;
    if (pipeFd != null && pid > 0) {
        int innerPid = -1;
        try {
            // Do a busy loop here. We can't guarantee that a failure (and thus an exception
            // bail) happens in a timely manner.
            // Bytes in an int.
            final int BYTES_REQUIRED = 4;
            StructPollfd[] fds = new StructPollfd[] { new StructPollfd() };
            byte[] data = new byte[BYTES_REQUIRED];
            int remainingSleepTime = WRAPPED_PID_SLEEP_IN_MS;
            int dataIndex = 0;
            long startTime = System.nanoTime();
            while (dataIndex < data.length && remainingSleepTime > 0) {
                fds[0].fd = pipeFd;
                fds[0].events = (short) POLLIN;
                fds[0].revents = 0;
                fds[0].userData = null;
                int res = android.system.Os.poll(fds, remainingSleepTime);
                long endTime = System.nanoTime();
                int elapsedTimeMs = (int) ((endTime - startTime) / 1000000l);
                remainingSleepTime = WRAPPED_PID_SLEEP_IN_MS - elapsedTimeMs;
                if (res > 0) {
                    if ((fds[0].revents & POLLIN) != 0) {
                        // Only read one byte, so as not to block.
                        int readBytes = android.system.Os.read(pipeFd, data, dataIndex, 1);
                        if (readBytes < 0) {
                            throw new RuntimeException("Some error");
                        }
                        dataIndex += readBytes;
                    } else {
                        // Error case. revents should contain one of the error bits.
                        break;
                    }
                } else if (res == 0) {
                    Log.w(TAG, "Timed out waiting for child.");
                }
            }
            if (dataIndex == data.length) {
                DataInputStream is = new DataInputStream(new ByteArrayInputStream(data));
                innerPid = is.readInt();
            }
            if (innerPid == -1) {
                Log.w(TAG, "Error reading pid from wrapped process, child may have died");
            }
        } catch (Exception ex) {
            Log.w(TAG, "Error reading pid from wrapped process, child may have died", ex);
        }
        // child process that we forked, or a descendant of it.
        if (innerPid > 0) {
            int parentPid = innerPid;
            while (parentPid > 0 && parentPid != pid) {
                parentPid = Process.getParentPid(parentPid);
            }
            if (parentPid > 0) {
                Log.i(TAG, "Wrapped process has pid " + innerPid);
                pid = innerPid;
                usingWrapper = true;
            } else {
                Log.w(TAG, "Wrapped process reported a pid that is not a child of " + "the process that we forked: childPid=" + pid + " innerPid=" + innerPid);
            }
        }
    }
    try {
        mSocketOutStream.writeInt(pid);
        mSocketOutStream.writeBoolean(usingWrapper);
    } catch (IOException ex) {
        Log.e(TAG, "Error writing to command socket", ex);
        return true;
    }
    return false;
}
#method_after
private boolean handleParentProc(int pid, FileDescriptor[] descriptors, FileDescriptor pipeFd, Arguments parsedArgs) {
    if (pid > 0) {
        setChildPgid(pid);
    }
    if (descriptors != null) {
        for (FileDescriptor fd : descriptors) {
            IoUtils.closeQuietly(fd);
        }
    }
    boolean usingWrapper = false;
    if (pipeFd != null && pid > 0) {
        int innerPid = -1;
        try {
            // Do a busy loop here. We can't guarantee that a failure (and thus an exception
            // bail) happens in a timely manner.
            // Bytes in an int.
            final int BYTES_REQUIRED = 4;
            StructPollfd[] fds = new StructPollfd[] { new StructPollfd() };
            byte[] data = new byte[BYTES_REQUIRED];
            int remainingSleepTime = WRAPPED_PID_TIMEOUT_MILLIS;
            int dataIndex = 0;
            long startTime = System.nanoTime();
            while (dataIndex < data.length && remainingSleepTime > 0) {
                fds[0].fd = pipeFd;
                fds[0].events = (short) POLLIN;
                fds[0].revents = 0;
                fds[0].userData = null;
                int res = android.system.Os.poll(fds, remainingSleepTime);
                long endTime = System.nanoTime();
                int elapsedTimeMs = (int) ((endTime - startTime) / 1000000l);
                remainingSleepTime = WRAPPED_PID_TIMEOUT_MILLIS - elapsedTimeMs;
                if (res > 0) {
                    if ((fds[0].revents & POLLIN) != 0) {
                        // Only read one byte, so as not to block.
                        int readBytes = android.system.Os.read(pipeFd, data, dataIndex, 1);
                        if (readBytes < 0) {
                            throw new RuntimeException("Some error");
                        }
                        dataIndex += readBytes;
                    } else {
                        // Error case. revents should contain one of the error bits.
                        break;
                    }
                } else if (res == 0) {
                    Log.w(TAG, "Timed out waiting for child.");
                }
            }
            if (dataIndex == data.length) {
                DataInputStream is = new DataInputStream(new ByteArrayInputStream(data));
                innerPid = is.readInt();
            }
            if (innerPid == -1) {
                Log.w(TAG, "Error reading pid from wrapped process, child may have died");
            }
        } catch (Exception ex) {
            Log.w(TAG, "Error reading pid from wrapped process, child may have died", ex);
        }
        // child process that we forked, or a descendant of it.
        if (innerPid > 0) {
            int parentPid = innerPid;
            while (parentPid > 0 && parentPid != pid) {
                parentPid = Process.getParentPid(parentPid);
            }
            if (parentPid > 0) {
                Log.i(TAG, "Wrapped process has pid " + innerPid);
                pid = innerPid;
                usingWrapper = true;
            } else {
                Log.w(TAG, "Wrapped process reported a pid that is not a child of " + "the process that we forked: childPid=" + pid + " innerPid=" + innerPid);
            }
        }
    }
    try {
        mSocketOutStream.writeInt(pid);
        mSocketOutStream.writeBoolean(usingWrapper);
    } catch (IOException ex) {
        Log.e(TAG, "Error writing to command socket", ex);
        return true;
    }
    return false;
}
#end_block

#method_before
public void applyPattern(String pattern) {
    icuDecimalFormat.applyPattern(pattern);
    updateFieldsFromIcu();
    icuDecimalFormat.setPositivePrefix(icuDecimalFormat.getPositivePrefix());
    icuDecimalFormat.setPositiveSuffix(icuDecimalFormat.getPositiveSuffix());
    icuDecimalFormat.setNegativePrefix(icuDecimalFormat.getNegativePrefix());
    icuDecimalFormat.setNegativeSuffix(icuDecimalFormat.getNegativeSuffix());
    icuDecimalFormat.setGroupingSize(icuDecimalFormat.getGroupingSize());
    icuDecimalFormat.setRoundingMode(convertRoundingMode(roundingMode));
    icuDecimalFormat.setMaximumIntegerDigits(icuDecimalFormat.getMaximumIntegerDigits());
    icuDecimalFormat.setMinimumIntegerDigits(icuDecimalFormat.getMinimumIntegerDigits());
    icuDecimalFormat.setMaximumFractionDigits(icuDecimalFormat.getMaximumFractionDigits());
    icuDecimalFormat.setMinimumFractionDigits(icuDecimalFormat.getMinimumFractionDigits());
}
#method_after
public void applyPattern(String pattern) {
    icuDecimalFormat.applyPattern(pattern);
    updateFieldsFromIcu();
}
#end_block

#method_before
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    ObjectInputStream.GetField fields = stream.readFields();
    this.symbols = (DecimalFormatSymbols) fields.get("symbols", null);
    init("#");
    icuDecimalFormat.setPositivePrefix((String) fields.get("positivePrefix", ""));
    icuDecimalFormat.setPositiveSuffix((String) fields.get("positiveSuffix", ""));
    icuDecimalFormat.setNegativePrefix((String) fields.get("negativePrefix", "-"));
    icuDecimalFormat.setNegativeSuffix((String) fields.get("negativeSuffix", ""));
    icuDecimalFormat.setMultiplier(fields.get("multiplier", 1));
    icuDecimalFormat.setGroupingUsed(fields.get("groupingUsed", true));
    icuDecimalFormat.setGroupingSize(fields.get("groupingSize", (byte) 3));
    icuDecimalFormat.setDecimalSeparatorAlwaysShown(fields.get("decimalSeparatorAlwaysShown", false));
    setRoundingMode((RoundingMode) fields.get("roundingMode", RoundingMode.HALF_EVEN));
    final int maximumIntegerDigits = fields.get("maximumIntegerDigits", 309);
    final int minimumIntegerDigits = fields.get("minimumIntegerDigits", 309);
    final int maximumFractionDigits = fields.get("maximumFractionDigits", 340);
    final int minimumFractionDigits = fields.get("minimumFractionDigits", 340);
    // Tell ICU what we want, then ask it what we can have, and then
    // set that in our Java object. This isn't RI-compatible, but then very little of our
    // behavior in this area is, and it's not obvious how we can second-guess ICU (or tell
    // it to just do exactly what we ask). We only need to do this with maximumIntegerDigits
    // because ICU doesn't seem to have its own ideas about the other options.
    icuDecimalFormat.setMaximumIntegerDigits(maximumIntegerDigits);
    super.setMaximumIntegerDigits(icuDecimalFormat.getMaximumIntegerDigits());
    setMinimumIntegerDigits(minimumIntegerDigits);
    setMinimumFractionDigits(minimumFractionDigits);
    setMaximumFractionDigits(maximumFractionDigits);
    setParseBigDecimal(fields.get("parseBigDecimal", false));
    if (fields.get("serialVersionOnStream", 0) < 3) {
        setMaximumIntegerDigits(super.getMaximumIntegerDigits());
        setMinimumIntegerDigits(super.getMinimumIntegerDigits());
        setMaximumFractionDigits(super.getMaximumFractionDigits());
        setMinimumFractionDigits(super.getMinimumFractionDigits());
    }
}
#method_after
private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {
    ObjectInputStream.GetField fields = stream.readFields();
    this.symbols = (DecimalFormatSymbols) fields.get("symbols", null);
    init("#");
    // Calling a setter method on an ICU DecimalFormat object will change the object's internal
    // state, even if the value set is the same as the default value (ICU Ticket #13266).
    // 
    // In an attempt to create objects that are equals() to the ones that were serialized, it's
    // therefore assumed here that any values that are the same as the default values were the
    // default values (ie. no setter was called to explicitly set that value).
    String positivePrefix = (String) fields.get("positivePrefix", "");
    if (!Objects.equals(positivePrefix, icuDecimalFormat.getPositivePrefix())) {
        icuDecimalFormat.setPositivePrefix(positivePrefix);
    }
    String positiveSuffix = (String) fields.get("positiveSuffix", "");
    if (!Objects.equals(positiveSuffix, icuDecimalFormat.getPositiveSuffix())) {
        icuDecimalFormat.setPositiveSuffix(positiveSuffix);
    }
    String negativePrefix = (String) fields.get("negativePrefix", "-");
    if (!Objects.equals(negativePrefix, icuDecimalFormat.getNegativePrefix())) {
        icuDecimalFormat.setNegativePrefix(negativePrefix);
    }
    String negativeSuffix = (String) fields.get("negativeSuffix", "");
    if (!Objects.equals(negativeSuffix, icuDecimalFormat.getNegativeSuffix())) {
        icuDecimalFormat.setNegativeSuffix(negativeSuffix);
    }
    int multiplier = fields.get("multiplier", 1);
    if (multiplier != icuDecimalFormat.getMultiplier()) {
        icuDecimalFormat.setMultiplier(multiplier);
    }
    boolean groupingUsed = fields.get("groupingUsed", true);
    if (groupingUsed != icuDecimalFormat.isGroupingUsed()) {
        icuDecimalFormat.setGroupingUsed(groupingUsed);
    }
    int groupingSize = fields.get("groupingSize", (byte) 3);
    if (groupingSize != icuDecimalFormat.getGroupingSize()) {
        icuDecimalFormat.setGroupingSize(groupingSize);
    }
    boolean decimalSeparatorAlwaysShown = fields.get("decimalSeparatorAlwaysShown", false);
    if (decimalSeparatorAlwaysShown != icuDecimalFormat.isDecimalSeparatorAlwaysShown()) {
        icuDecimalFormat.setDecimalSeparatorAlwaysShown(decimalSeparatorAlwaysShown);
    }
    RoundingMode roundingMode = (RoundingMode) fields.get("roundingMode", RoundingMode.HALF_EVEN);
    if (convertRoundingMode(roundingMode) != icuDecimalFormat.getRoundingMode()) {
        setRoundingMode(roundingMode);
    }
    int maximumIntegerDigits = fields.get("maximumIntegerDigits", 309);
    if (maximumIntegerDigits != icuDecimalFormat.getMaximumIntegerDigits()) {
        icuDecimalFormat.setMaximumIntegerDigits(maximumIntegerDigits);
    }
    int minimumIntegerDigits = fields.get("minimumIntegerDigits", 309);
    if (minimumIntegerDigits != icuDecimalFormat.getMinimumIntegerDigits()) {
        icuDecimalFormat.setMinimumIntegerDigits(minimumIntegerDigits);
    }
    int maximumFractionDigits = fields.get("maximumFractionDigits", 340);
    if (maximumFractionDigits != icuDecimalFormat.getMaximumFractionDigits()) {
        icuDecimalFormat.setMaximumFractionDigits(maximumFractionDigits);
    }
    int minimumFractionDigits = fields.get("minimumFractionDigits", 340);
    if (minimumFractionDigits != icuDecimalFormat.getMinimumFractionDigits()) {
        icuDecimalFormat.setMinimumFractionDigits(minimumFractionDigits);
    }
    boolean parseBigDecimal = fields.get("parseBigDecimal", true);
    if (parseBigDecimal != icuDecimalFormat.isParseBigDecimal()) {
        icuDecimalFormat.setParseBigDecimal(parseBigDecimal);
    }
    updateFieldsFromIcu();
    if (fields.get("serialVersionOnStream", 0) < 3) {
        setMaximumIntegerDigits(super.getMaximumIntegerDigits());
        setMinimumIntegerDigits(super.getMinimumIntegerDigits());
        setMaximumFractionDigits(super.getMaximumFractionDigits());
        setMinimumFractionDigits(super.getMinimumFractionDigits());
    }
}
#end_block

#method_before
protected void setUp() throws Exception {
    super.setUp();
    // mCM = (ConnectivityManager) getContext().getSystemService(Context.CONNECTIVITY_SERVICE);
    mCM = mock(ConnectivityManager.class);
    mockContext = mock(Context.class);
    mockIpSecService = mock(IpSecService.class);
    when(mockIpSecService.reserveSecurityParameterIndex(anyInt(), anyString(), eq(DROID_SPI), anyObject())).thenReturn(expectedSpiResp);
    when(mockIpSecService.reserveSecurityParameterIndex(anyInt(), anyString(), anyInt(), anyObject())).thenReturn(expectedSpiResp);
    try {
        FileDescriptor sockFd = Os.socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
        ipSecUdpEncapResp = new IpSecUdpEncapResponse(IpSecManager.Status.OK, 0x1, TEST_UDP_ENCAP_PORT, sockFd);
        when(mockIpSecService.openUdpEncapsulationSocket(eq(TEST_UDP_ENCAP_PORT), anyObject())).thenReturn(ipSecUdpEncapResp);
        local = InetAddress.getByAddress(new byte[] { 127, 0, 0, 1 });
    } catch (Exception e) {
        throw new IllegalArgumentException("Cannot set up tests correctly " + e.getMessage());
    }
    mISM = new IpSecManager(mockIpSecService);
}
#method_after
@Before
public void setUp() throws Exception {
    mMockIpSecService = mock(IpSecService.class);
    mIpSecManager = new IpSecManager(mMockIpSecService);
}
#end_block

#method_before
public void testAllocSpi() throws Exception {
    for (InetAddress addr : GOOGLE_DNS_LIST) {
        IpSecManager.SecurityParameterIndex randomSpi = null, droidSpi = null;
        randomSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_OUT, addr);
        assertTrue("Failed to receive a valid SPI", randomSpi.getSpi() != IpSecManager.INVALID_SECURITY_PARAMETER_INDEX);
        droidSpi = mISM.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, addr, DROID_SPI);
        assertTrue("Failed to allocate specified SPI, " + DROID_SPI, droidSpi.getSpi() == DROID_SPI);
        randomSpi.close();
        droidSpi.close();
    }
}
#method_after
@Test
public void testAllocSpi() throws Exception {
    int resourceId = 1;
    IpSecSpiResponse spiResp = new IpSecSpiResponse(IpSecManager.Status.OK, resourceId, DROID_SPI);
    when(mMockIpSecService.reserveSecurityParameterIndex(eq(IpSecTransform.DIRECTION_IN), eq(GOOGLE_DNS_4.getHostAddress()), eq(DROID_SPI), anyObject())).thenReturn(spiResp);
    IpSecManager.SecurityParameterIndex droidSpi = mIpSecManager.reserveSecurityParameterIndex(IpSecTransform.DIRECTION_IN, GOOGLE_DNS_4, DROID_SPI);
    assertEquals(DROID_SPI, droidSpi.getSpi());
    droidSpi.close();
    verify(mMockIpSecService).releaseSecurityParameterIndex(resourceId);
}
#end_block

#method_before
public void testHashcode() {
    StructTimespec allZero1 = new StructTimespec(0, 0);
    StructTimespec allZero2 = new StructTimespec(0, 0);
    StructTimespec val1 = new StructTimespec(23, 42);
    StructTimespec val2 = new StructTimespec(23, 42);
    StructTimespec secZero1 = new StructTimespec(0, 42);
    StructTimespec secZero2 = new StructTimespec(0, 42);
    StructTimespec nsecZero1 = new StructTimespec(23, 0);
    StructTimespec nsecZero2 = new StructTimespec(23, 0);
    // Equal objects should have same hash code
    assertEquals(allZero1.hashCode(), allZero2.hashCode());
    assertEquals(val1.hashCode(), val2.hashCode());
    assertEquals(secZero1.hashCode(), secZero2.hashCode());
    assertEquals(nsecZero1.hashCode(), nsecZero2.hashCode());
    // Hash codes do not have to be unique, but they should be reasonably well distributed.
    // Let's test for less than 5% collisions. This is excessive, hence it should not cause test
    // flakiness.
    StructTimespec[] randomSpecs = new StructTimespec[10000];
    Random random = new Random();
    for (int i = 0; i < 10000; i++) {
        randomSpecs[i] = new StructTimespec(random.nextLong(), Math.abs(random.nextLong()) % 1_000_000_000);
    }
    // Sort by hash code so that all collisions are after each other.
    Arrays.sort(randomSpecs, Comparator.comparingInt(StructTimespec::hashCode));
    // Only need to compare to the direct neighbor
    ArrayList<String> collisions = new ArrayList<>();
    for (int i = 0; i < 9999; i++) {
        if (!randomSpecs[i].equals(randomSpecs[i + 1])) {
            if (randomSpecs[i].hashCode() == randomSpecs[i + 1].hashCode()) {
                collisions.add(randomSpecs[i] + " == " + randomSpecs[i + 1]);
            }
        }
    }
    assertTrue("Too many collisions " + collisions, collisions.size() < 500);
}
#method_after
public void testHashcode() {
    StructTimespec allZero1 = new StructTimespec(0, 0);
    StructTimespec allZero2 = new StructTimespec(0, 0);
    StructTimespec val1 = new StructTimespec(23, 42);
    StructTimespec val2 = new StructTimespec(23, 42);
    StructTimespec secZero1 = new StructTimespec(0, 42);
    StructTimespec secZero2 = new StructTimespec(0, 42);
    StructTimespec nsecZero1 = new StructTimespec(23, 0);
    StructTimespec nsecZero2 = new StructTimespec(23, 0);
    // Equal objects should have same hash code
    assertEquals(allZero1.hashCode(), allZero2.hashCode());
    assertEquals(val1.hashCode(), val2.hashCode());
    assertEquals(secZero1.hashCode(), secZero2.hashCode());
    assertEquals(nsecZero1.hashCode(), nsecZero2.hashCode());
}
#end_block

#method_before
@Test
public void testDefaultProvisioningConfiguration() throws Exception {
    final String iface = "test_wlan0";
    final IpManager ipm = new IpManager(mContext, iface, mCb, mNMService);
    ProvisioningConfiguration config = new ProvisioningConfiguration.Builder().withoutIPv4().withoutIpReachabilityMonitor().build();
    ipm.startProvisioning(config);
    verify(mCb, times(1)).setNeighborDiscoveryOffload(true);
    verify(mNMService, timeout(100).times(1)).disableIpv6(iface);
    verify(mNMService, timeout(100).times(1)).clearInterfaceAddresses(iface);
    verify(mCb, timeout(100).times(1)).setFallbackMulticastFilter(false);
    verify(mCb, never()).onProvisioningFailure(any());
    ipm.stop();
    verify(mNMService, timeout(100).times(1)).disableIpv6(iface);
    verify(mNMService, timeout(100).times(1)).clearInterfaceAddresses(iface);
}
#method_after
@Test
public void testDefaultProvisioningConfiguration() throws Exception {
    final String iface = "test_wlan0";
    final IpManager ipm = makeIpManager(iface);
    ProvisioningConfiguration config = new ProvisioningConfiguration.Builder().withoutIPv4().withoutIpReachabilityMonitor().build();
    ipm.startProvisioning(config);
    verify(mCb, times(1)).setNeighborDiscoveryOffload(true);
    verify(mCb, timeout(100).times(1)).setFallbackMulticastFilter(false);
    verify(mCb, never()).onProvisioningFailure(any());
    ipm.stop();
    verify(mNMService, timeout(100).times(1)).disableIpv6(iface);
    verify(mNMService, timeout(100).times(1)).clearInterfaceAddresses(iface);
}
#end_block

#method_before
@Override
public void dumpHeapFinished(String path) {
    synchronized (this) {
        if (Binder.getCallingPid() != mMemWatchDumpPid) {
            Slog.w(TAG, "dumpHeapFinished: Calling pid " + Binder.getCallingPid() + " does not match last pid " + mMemWatchDumpPid);
            return;
        }
        if (mMemWatchDumpFile == null || !mMemWatchDumpFile.equals(path)) {
            Slog.w(TAG, "dumpHeapFinished: Calling path " + path + " does not match last path " + mMemWatchDumpFile);
            return;
        }
        if (DEBUG_PSS)
            Slog.d(TAG_PSS, "Dump heap finished for " + path);
        mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);
        System.gc();
    }
}
#method_after
@Override
public void dumpHeapFinished(String path) {
    synchronized (this) {
        if (Binder.getCallingPid() != mMemWatchDumpPid) {
            Slog.w(TAG, "dumpHeapFinished: Calling pid " + Binder.getCallingPid() + " does not match last pid " + mMemWatchDumpPid);
            return;
        }
        if (mMemWatchDumpFile == null || !mMemWatchDumpFile.equals(path)) {
            Slog.w(TAG, "dumpHeapFinished: Calling path " + path + " does not match last path " + mMemWatchDumpFile);
            return;
        }
        if (DEBUG_PSS)
            Slog.d(TAG_PSS, "Dump heap finished for " + path);
        mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);
        // Forced gc to clean up the remnant hprof fd.
        Runtime.getRuntime().gc();
    }
}
#end_block

#method_before
// We don't required x-UTF-32BE-BOM or x-UTF-32LE-BOM to exist.
private byte[] toByteArray(int[] ints) {
    byte[] result = new byte[ints.length];
    for (int i = 0; i < ints.length; ++i) {
        result[i] = (byte) ints[i];
    }
    return result;
}
#method_after
private byte[] toByteArray(int[] ints) {
    byte[] result = new byte[ints.length];
    for (int i = 0; i < ints.length; ++i) {
        result[i] = (byte) ints[i];
    }
    return result;
}
#end_block

#method_before
private void updateVtsRunnerTestConfig(JSONObject jsonObject) throws IOException, JSONException, RuntimeException {
    configReader = new VtsVendorConfigFileUtil();
    if (configReader.LoadVendorConfig(mBuildInfo)) {
        JSONObject vendorConfigJson = configReader.GetVendorConfigJson();
        if (vendorConfigJson != null) {
            JsonUtil.deepMergeJsonObjects(jsonObject, vendorConfigJson);
        }
    }
    CLog.i("Load original test config %s %s", mTestCaseDataDir, mTestConfigPath);
    String content = null;
    if (mTestConfigPath != null) {
        content = FileUtil.readStringFromFile(new File(Paths.get(mTestCaseDataDir, mTestConfigPath).toString()));
        CLog.i("Loaded original test config %s", content);
        if (content != null) {
            JsonUtil.deepMergeJsonObjects(jsonObject, new JSONObject(content));
        }
    }
    populateDefaultJsonFields(jsonObject, mTestCaseDataDir);
    CLog.i("Built a Json object using the loaded original test config");
    JSONArray deviceArray = new JSONArray();
    JSONObject deviceItemObject = new JSONObject();
    deviceItemObject.put(SERIAL, mDevice.getSerialNumber());
    boolean coverageBuild = false;
    try {
        deviceItemObject.put("product_type", mDevice.getProductType());
        deviceItemObject.put("product_variant", mDevice.getProductVariant());
        deviceItemObject.put("build_alias", mDevice.getBuildAlias());
        deviceItemObject.put("build_id", mDevice.getBuildId());
        deviceItemObject.put("build_flavor", mDevice.getBuildFlavor());
        String coverageProperty = mDevice.getProperty(COVERAGE_PROPERTY);
        coverageBuild = coverageProperty != null && coverageProperty.equals("1");
    } catch (DeviceNotAvailableException e) {
        CLog.e("A device not available - continuing");
        throw new RuntimeException("Failed to get device information");
    }
    deviceArray.put(deviceItemObject);
    JSONArray testBedArray = (JSONArray) jsonObject.get("test_bed");
    if (testBedArray.length() == 0) {
        JSONObject device = new JSONObject();
        String testName;
        if (mTestModuleName != null) {
            testName = mTestModuleName;
        } else {
            CLog.w("--test-module-name not set (not recommended); deriving automatically");
            if (mTestConfigPath != null) {
                testName = new File(mTestConfigPath).getName();
                testName = testName.replace(CONFIG_FILE_EXTENSION, "");
            } else if (mTestCasePath != null) {
                testName = new File(mTestCasePath).getName();
            } else {
                throw new RuntimeException("Failed to derive test module name; use --test-module-name option");
            }
        }
        CLog.logAndDisplay(LogLevel.INFO, "Setting test name as %s", testName);
        device.put(NAME, testName);
        device.put(ANDROIDDEVICE, deviceArray);
        testBedArray.put(device);
    } else if (testBedArray.length() == 1) {
        JSONObject device = (JSONObject) testBedArray.get(0);
        device.put(ANDROIDDEVICE, deviceArray);
    } else {
        CLog.e("Multi-device not yet supported: %d devices requested", testBedArray.length());
        throw new RuntimeException("Failed to produce VTS runner test config");
    }
    jsonObject.put(DATA_FILE_PATH, mTestCaseDataDir);
    CLog.i("Added %s = %s to the Json object", DATA_FILE_PATH, mTestCaseDataDir);
    JSONObject build = new JSONObject();
    build.put(BUILD_ID, mBuildInfo.getBuildId());
    build.put(BUILD_TARGET, mBuildInfo.getBuildTargetName());
    jsonObject.put(BUILD, build);
    CLog.i("Added %s to the Json object", BUILD);
    JSONObject suite = new JSONObject();
    suite.put(NAME, mBuildInfo.getTestTag());
    suite.put(INCLUDE_FILTER, new JSONArray(mIncludeFilters));
    CLog.i("Added include filter to test suite: %s", mIncludeFilters);
    suite.put(EXCLUDE_FILTER, new JSONArray(mExcludeFilters));
    CLog.i("Added exclude filter to test suite: %s", mExcludeFilters);
    jsonObject.put(TEST_SUITE, suite);
    CLog.i("Added %s to the Json object", TEST_SUITE);
    jsonObject.put(TEST_TIMEOUT, mTestTimeout);
    CLog.i("Added %s to the Json object: %d", TEST_TIMEOUT, mTestTimeout);
    if (mAbi != null) {
        jsonObject.put(ABI_NAME, mAbi.getName());
        CLog.i("Added %s to the Json object", ABI_NAME);
        jsonObject.put(ABI_BITNESS, mAbi.getBitness());
        CLog.i("Added %s to the Json object", ABI_BITNESS);
    }
    if (mSkipOn32BitAbi) {
        jsonObject.put(SKIP_ON_32BIT_ABI, mSkipOn32BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_32BIT_ABI);
    }
    if (mSkipOn64BitAbi) {
        jsonObject.put(SKIP_ON_64BIT_ABI, mSkipOn64BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_64BIT_ABI);
    } else if (mRun32bBitOn64BitAbi) {
        jsonObject.put(RUN_32BIT_ON_64BIT_ABI, mRun32bBitOn64BitAbi);
        CLog.i("Added %s to the Json object", RUN_32BIT_ON_64BIT_ABI);
    }
    if (mSkipIfThermalThrottling) {
        jsonObject.put(SKIP_IF_THERMAL_THROTTLING, mSkipIfThermalThrottling);
        CLog.i("Added %s to the Json object", SKIP_IF_THERMAL_THROTTLING);
    }
    if (!mBinaryTestSource.isEmpty()) {
        jsonObject.put(BINARY_TEST_SOURCE, new JSONArray(mBinaryTestSource));
        CLog.i("Added %s to the Json object", BINARY_TEST_SOURCE);
    }
    if (!mBinaryTestWorkingDirectory.isEmpty()) {
        jsonObject.put(BINARY_TEST_WORKING_DIRECTORY, new JSONArray(mBinaryTestWorkingDirectory));
        CLog.i("Added %s to the Json object", BINARY_TEST_WORKING_DIRECTORY);
    }
    if (!mBinaryTestEnvp.isEmpty()) {
        jsonObject.put(BINARY_TEST_ENVP, new JSONArray(mBinaryTestEnvp));
        CLog.i("Added %s to the Json object", BINARY_TEST_ENVP);
    }
    if (!mBinaryTestArgs.isEmpty()) {
        jsonObject.put(BINARY_TEST_ARGS, new JSONArray(mBinaryTestArgs));
        CLog.i("Added %s to the Json object", BINARY_TEST_ARGS);
    }
    if (!mBinaryTestLdLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_LD_LIBRARY_PATH, new JSONArray(mBinaryTestLdLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_LD_LIBRARY_PATH);
    }
    if (mEnableProfiling) {
        jsonObject.put(ENABLE_PROFILING, mEnableProfiling);
        CLog.i("Added %s to the Json object", ENABLE_PROFILING);
    }
    if (mSaveTraceFileRemote) {
        jsonObject.put(SAVE_TRACE_FIEL_REMOTE, mSaveTraceFileRemote);
        CLog.i("Added %s to the Json object", SAVE_TRACE_FIEL_REMOTE);
    }
    if (mEnableSystrace) {
        jsonObject.put(ENABLE_SYSTRACE, mEnableSystrace);
        CLog.i("Added %s to the Json object", ENABLE_SYSTRACE);
    }
    if (mEnableCoverage) {
        jsonObject.put(GLOBAL_COVERAGE, mGlobalCoverage);
        if (coverageBuild) {
            jsonObject.put(ENABLE_COVERAGE, mEnableCoverage);
            CLog.i("Added %s to the Json object", ENABLE_COVERAGE);
        } else {
            CLog.i("Device build has coverage disabled");
        }
    }
    if (mOutputCoverageReport) {
        jsonObject.put(OUTPUT_COVERAGE_REPORT, mOutputCoverageReport);
        CLog.i("Added %s to the Json object", OUTPUT_COVERAGE_REPORT);
    }
    if (mPreconditionHwBinderServiceName != null) {
        jsonObject.put(PRECONDITION_HWBINDER_SERVICE, mPreconditionHwBinderServiceName);
        CLog.i("Added %s to the Json object", PRECONDITION_HWBINDER_SERVICE);
    }
    if (mPreconditionFeature != null) {
        jsonObject.put(PRECONDITION_FEATURE, mPreconditionFeature);
        CLog.i("Added %s to the Json object", PRECONDITION_FEATURE);
    }
    if (mPreconditionFilePathPrefix != null) {
        jsonObject.put(PRECONDITION_FILE_PATH_PREFIX, mPreconditionFilePathPrefix);
        CLog.i("Added %s to the Json object", PRECONDITION_FILE_PATH_PREFIX);
    }
    if (mPreconditionLshal != null) {
        jsonObject.put(PRECONDITION_LSHAL, mPreconditionLshal);
        CLog.i("Added %s to the Json object", PRECONDITION_LSHAL);
    }
    if (mPreconditionVintf != null) {
        jsonObject.put(PRECONDITION_VINTF, mPreconditionVintf);
        CLog.i("Added %s to the Json object", PRECONDITION_VINTF);
    }
    if (!mBinaryTestProfilingLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_PROFILING_LIBRARY_PATH, new JSONArray(mBinaryTestProfilingLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_PROFILING_LIBRARY_PATH);
    }
    if (mBinaryTestDisableFramework) {
        jsonObject.put(BINARY_TEST_DISABLE_FRAMEWORK, mBinaryTestDisableFramework);
        CLog.i("Added %s to the Json object", BINARY_TEST_DISABLE_FRAMEWORK);
    }
    if (mBinaryTestStopNativeServers) {
        jsonObject.put(BINARY_TEST_STOP_NATIVE_SERVERS, mBinaryTestStopNativeServers);
        CLog.i("Added %s to the Json object", BINARY_TEST_STOP_NATIVE_SERVERS);
    }
    if (!mNativeServerProcessName.isEmpty()) {
        jsonObject.put(NATIVE_SERVER_PROCESS_NAME, new JSONArray(mNativeServerProcessName));
        CLog.i("Added %s to the Json object", NATIVE_SERVER_PROCESS_NAME);
    }
    if (!mHalHidlReplayTestTracePaths.isEmpty()) {
        jsonObject.put(HAL_HIDL_REPLAY_TEST_TRACE_PATHS, new JSONArray(mHalHidlReplayTestTracePaths));
        CLog.i("Added %s to the Json object", HAL_HIDL_REPLAY_TEST_TRACE_PATHS);
    }
    if (mHalHidlPackageName != null) {
        jsonObject.put(HAL_HIDL_PACKAGE_NAME, mHalHidlPackageName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mSystraceProcessName != null) {
        jsonObject.put(SYSTRACE_PROCESS_NAME, mSystraceProcessName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mPassthroughMode) {
        jsonObject.put(PASSTHROUGH_MODE, mPassthroughMode);
        CLog.i("Added %s to the Json object", PASSTHROUGH_MODE);
    }
    if (mGtestBatchMode) {
        jsonObject.put(GTEST_BATCH_MODE, mGtestBatchMode);
        CLog.i("Added %s to the Json object", GTEST_BATCH_MODE);
    }
}
#method_after
private void updateVtsRunnerTestConfig(JSONObject jsonObject) throws IOException, JSONException, RuntimeException {
    configReader = new VtsVendorConfigFileUtil();
    if (configReader.LoadVendorConfig(mBuildInfo)) {
        JSONObject vendorConfigJson = configReader.GetVendorConfigJson();
        if (vendorConfigJson != null) {
            JsonUtil.deepMergeJsonObjects(jsonObject, vendorConfigJson);
        }
    }
    CLog.i("Load original test config %s %s", mTestCaseDataDir, mTestConfigPath);
    String content = null;
    if (mTestConfigPath != null) {
        content = FileUtil.readStringFromFile(new File(Paths.get(mTestCaseDataDir, mTestConfigPath).toString()));
        CLog.i("Loaded original test config %s", content);
        if (content != null) {
            JsonUtil.deepMergeJsonObjects(jsonObject, new JSONObject(content));
        }
    }
    populateDefaultJsonFields(jsonObject, mTestCaseDataDir);
    CLog.i("Built a Json object using the loaded original test config");
    JSONArray deviceArray = new JSONArray();
    JSONObject deviceItemObject = new JSONObject();
    deviceItemObject.put(SERIAL, mDevice.getSerialNumber());
    boolean coverageBuild = false;
    try {
        deviceItemObject.put("product_type", mDevice.getProductType());
        deviceItemObject.put("product_variant", mDevice.getProductVariant());
        deviceItemObject.put("build_alias", mDevice.getBuildAlias());
        deviceItemObject.put("build_id", mDevice.getBuildId());
        deviceItemObject.put("build_flavor", mDevice.getBuildFlavor());
        String coverageProperty = mDevice.getProperty(COVERAGE_PROPERTY);
        coverageBuild = coverageProperty != null && coverageProperty.equals("1");
    } catch (DeviceNotAvailableException e) {
        CLog.e("A device not available - continuing");
        throw new RuntimeException("Failed to get device information");
    }
    deviceArray.put(deviceItemObject);
    JSONArray testBedArray = (JSONArray) jsonObject.get("test_bed");
    if (testBedArray.length() == 0) {
        JSONObject testBedItemObject = new JSONObject();
        String testName;
        if (mTestModuleName != null) {
            testName = mTestModuleName;
        } else {
            CLog.w("--test-module-name not set (not recommended); deriving automatically");
            if (mTestConfigPath != null) {
                testName = new File(mTestConfigPath).getName();
                testName = testName.replace(CONFIG_FILE_EXTENSION, "");
            } else if (mTestCasePath != null) {
                testName = new File(mTestCasePath).getName();
            } else {
                throw new RuntimeException("Failed to derive test module name; use --test-module-name option");
            }
        }
        CLog.logAndDisplay(LogLevel.INFO, "Setting test name as %s", testName);
        testBedItemObject.put(NAME, testName);
        testBedItemObject.put(ANDROIDDEVICE, deviceArray);
        testBedArray.put(testBedItemObject);
    } else if (testBedArray.length() == 1) {
        JSONObject testBedItemObject = (JSONObject) testBedArray.get(0);
        testBedItemObject.put(ANDROIDDEVICE, deviceArray);
    } else {
        CLog.e("Multi-device not yet supported: %d devices requested", testBedArray.length());
        throw new RuntimeException("Failed to produce VTS runner test config");
    }
    jsonObject.put(DATA_FILE_PATH, mTestCaseDataDir);
    CLog.i("Added %s = %s to the Json object", DATA_FILE_PATH, mTestCaseDataDir);
    JSONObject build = new JSONObject();
    build.put(BUILD_ID, mBuildInfo.getBuildId());
    build.put(BUILD_TARGET, mBuildInfo.getBuildTargetName());
    jsonObject.put(BUILD, build);
    CLog.i("Added %s to the Json object", BUILD);
    JSONObject suite = new JSONObject();
    suite.put(NAME, mBuildInfo.getTestTag());
    suite.put(INCLUDE_FILTER, new JSONArray(mIncludeFilters));
    CLog.i("Added include filter to test suite: %s", mIncludeFilters);
    suite.put(EXCLUDE_FILTER, new JSONArray(mExcludeFilters));
    CLog.i("Added exclude filter to test suite: %s", mExcludeFilters);
    jsonObject.put(TEST_SUITE, suite);
    CLog.i("Added %s to the Json object", TEST_SUITE);
    jsonObject.put(TEST_MAX_TIMEOUT, mTestTimeout);
    CLog.i("Added %s to the Json object: %d", TEST_MAX_TIMEOUT, mTestTimeout);
    if (mAbi != null) {
        jsonObject.put(ABI_NAME, mAbi.getName());
        CLog.i("Added %s to the Json object", ABI_NAME);
        jsonObject.put(ABI_BITNESS, mAbi.getBitness());
        CLog.i("Added %s to the Json object", ABI_BITNESS);
    }
    if (mSkipOn32BitAbi) {
        jsonObject.put(SKIP_ON_32BIT_ABI, mSkipOn32BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_32BIT_ABI);
    }
    if (mSkipOn64BitAbi) {
        jsonObject.put(SKIP_ON_64BIT_ABI, mSkipOn64BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_64BIT_ABI);
    } else if (mRun32bBitOn64BitAbi) {
        jsonObject.put(RUN_32BIT_ON_64BIT_ABI, mRun32bBitOn64BitAbi);
        CLog.i("Added %s to the Json object", RUN_32BIT_ON_64BIT_ABI);
    }
    if (mSkipIfThermalThrottling) {
        jsonObject.put(SKIP_IF_THERMAL_THROTTLING, mSkipIfThermalThrottling);
        CLog.i("Added %s to the Json object", SKIP_IF_THERMAL_THROTTLING);
    }
    if (!mBinaryTestSource.isEmpty()) {
        jsonObject.put(BINARY_TEST_SOURCE, new JSONArray(mBinaryTestSource));
        CLog.i("Added %s to the Json object", BINARY_TEST_SOURCE);
    }
    if (!mBinaryTestWorkingDirectory.isEmpty()) {
        jsonObject.put(BINARY_TEST_WORKING_DIRECTORY, new JSONArray(mBinaryTestWorkingDirectory));
        CLog.i("Added %s to the Json object", BINARY_TEST_WORKING_DIRECTORY);
    }
    if (!mBinaryTestEnvp.isEmpty()) {
        jsonObject.put(BINARY_TEST_ENVP, new JSONArray(mBinaryTestEnvp));
        CLog.i("Added %s to the Json object", BINARY_TEST_ENVP);
    }
    if (!mBinaryTestArgs.isEmpty()) {
        jsonObject.put(BINARY_TEST_ARGS, new JSONArray(mBinaryTestArgs));
        CLog.i("Added %s to the Json object", BINARY_TEST_ARGS);
    }
    if (!mBinaryTestLdLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_LD_LIBRARY_PATH, new JSONArray(mBinaryTestLdLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_LD_LIBRARY_PATH);
    }
    if (mEnableProfiling) {
        jsonObject.put(ENABLE_PROFILING, mEnableProfiling);
        CLog.i("Added %s to the Json object", ENABLE_PROFILING);
    }
    if (mSaveTraceFileRemote) {
        jsonObject.put(SAVE_TRACE_FIEL_REMOTE, mSaveTraceFileRemote);
        CLog.i("Added %s to the Json object", SAVE_TRACE_FIEL_REMOTE);
    }
    if (mEnableSystrace) {
        jsonObject.put(ENABLE_SYSTRACE, mEnableSystrace);
        CLog.i("Added %s to the Json object", ENABLE_SYSTRACE);
    }
    if (mEnableCoverage) {
        jsonObject.put(GLOBAL_COVERAGE, mGlobalCoverage);
        if (coverageBuild) {
            jsonObject.put(ENABLE_COVERAGE, mEnableCoverage);
            CLog.i("Added %s to the Json object", ENABLE_COVERAGE);
        } else {
            CLog.i("Device build has coverage disabled");
        }
    }
    if (mOutputCoverageReport) {
        jsonObject.put(OUTPUT_COVERAGE_REPORT, mOutputCoverageReport);
        CLog.i("Added %s to the Json object", OUTPUT_COVERAGE_REPORT);
    }
    if (mPreconditionHwBinderServiceName != null) {
        jsonObject.put(PRECONDITION_HWBINDER_SERVICE, mPreconditionHwBinderServiceName);
        CLog.i("Added %s to the Json object", PRECONDITION_HWBINDER_SERVICE);
    }
    if (mPreconditionFeature != null) {
        jsonObject.put(PRECONDITION_FEATURE, mPreconditionFeature);
        CLog.i("Added %s to the Json object", PRECONDITION_FEATURE);
    }
    if (mPreconditionFilePathPrefix != null) {
        jsonObject.put(PRECONDITION_FILE_PATH_PREFIX, mPreconditionFilePathPrefix);
        CLog.i("Added %s to the Json object", PRECONDITION_FILE_PATH_PREFIX);
    }
    if (mPreconditionLshal != null) {
        jsonObject.put(PRECONDITION_LSHAL, mPreconditionLshal);
        CLog.i("Added %s to the Json object", PRECONDITION_LSHAL);
    }
    if (mPreconditionVintf != null) {
        jsonObject.put(PRECONDITION_VINTF, mPreconditionVintf);
        CLog.i("Added %s to the Json object", PRECONDITION_VINTF);
    }
    if (!mBinaryTestProfilingLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_PROFILING_LIBRARY_PATH, new JSONArray(mBinaryTestProfilingLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_PROFILING_LIBRARY_PATH);
    }
    if (mBinaryTestDisableFramework) {
        jsonObject.put(BINARY_TEST_DISABLE_FRAMEWORK, mBinaryTestDisableFramework);
        CLog.i("Added %s to the Json object", BINARY_TEST_DISABLE_FRAMEWORK);
    }
    if (mBinaryTestStopNativeServers) {
        jsonObject.put(BINARY_TEST_STOP_NATIVE_SERVERS, mBinaryTestStopNativeServers);
        CLog.i("Added %s to the Json object", BINARY_TEST_STOP_NATIVE_SERVERS);
    }
    if (!mNativeServerProcessName.isEmpty()) {
        jsonObject.put(NATIVE_SERVER_PROCESS_NAME, new JSONArray(mNativeServerProcessName));
        CLog.i("Added %s to the Json object", NATIVE_SERVER_PROCESS_NAME);
    }
    if (!mHalHidlReplayTestTracePaths.isEmpty()) {
        jsonObject.put(HAL_HIDL_REPLAY_TEST_TRACE_PATHS, new JSONArray(mHalHidlReplayTestTracePaths));
        CLog.i("Added %s to the Json object", HAL_HIDL_REPLAY_TEST_TRACE_PATHS);
    }
    if (mHalHidlPackageName != null) {
        jsonObject.put(HAL_HIDL_PACKAGE_NAME, mHalHidlPackageName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mSystraceProcessName != null) {
        jsonObject.put(SYSTRACE_PROCESS_NAME, mSystraceProcessName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mPassthroughMode) {
        jsonObject.put(PASSTHROUGH_MODE, mPassthroughMode);
        CLog.i("Added %s to the Json object", PASSTHROUGH_MODE);
    }
    if (mGtestBatchMode) {
        jsonObject.put(GTEST_BATCH_MODE, mGtestBatchMode);
        CLog.i("Added %s to the Json object", GTEST_BATCH_MODE);
    }
}
#end_block

#method_before
private void doRunTest(ITestRunListener listener) throws RuntimeException, IllegalArgumentException {
    CLog.i("Device serial number: " + mDevice.getSerialNumber());
    JSONObject jsonObject = new JSONObject();
    File vtsRunnerLogDir = null;
    try {
        vtsRunnerLogDir = FileUtil.createTempDir("vts-runner-log");
        updateVtsRunnerTestConfig(jsonObject);
        jsonObject.put(LOG_PATH, vtsRunnerLogDir.getAbsolutePath());
        CLog.i("Added %s to the Json object", LOG_PATH);
    } catch (IOException e) {
        throw new RuntimeException("Failed to read test config json file");
    } catch (JSONException e) {
        throw new RuntimeException("Failed to build updated test config json data");
    }
    CLog.i("config json: %s", jsonObject.toString());
    String jsonFilePath = null;
    try {
        File tmpFile = FileUtil.createTempFile(mBuildInfo.getTestTag() + "-config-" + mBuildInfo.getDeviceSerial(), ".json");
        jsonFilePath = tmpFile.getAbsolutePath();
        CLog.i("config json file path: %s", jsonFilePath);
        FileWriter fw = new FileWriter(jsonFilePath);
        fw.write(jsonObject.toString());
        fw.close();
    } catch (IOException e) {
        throw new RuntimeException("Failed to create device config json file");
    }
    if (mPythonBin == null) {
        mPythonBin = getPythonBinary();
    }
    String[] baseOpts = { mPythonBin, "-m" };
    String[] testModule = { mTestCasePath.replace("/", "."), jsonFilePath };
    String[] cmd;
    cmd = ArrayUtil.buildArray(baseOpts, testModule);
    printToDeviceLogcatAboutTestModuleStatus("BEGIN");
    CommandResult commandResult = mRunUtil.runTimedCmd(mTestTimeout + TEST_ABORT_TIMEOUT, cmd);
    if (commandResult != null) {
        CommandStatus commandStatus = commandResult.getStatus();
        if (commandStatus != CommandStatus.SUCCESS && commandStatus != CommandStatus.TIMED_OUT) {
            CLog.e("Python process failed");
            CLog.e("Python path: %s", mPythonPath);
            CLog.e("Stderr: %s", commandResult.getStderr());
            CLog.e("Stdout: %s", commandResult.getStdout());
            printVtsLogs(vtsRunnerLogDir);
            printToDeviceLogcatAboutTestModuleStatus("ERROR");
            throw new RuntimeException("Failed to run VTS test");
        }
        CLog.i("Standard output is: %s", commandResult.getStdout());
        CLog.i("Parsing test result: %s", commandResult.getStderr());
        printToDeviceLogcatAboutTestModuleStatus("END");
    } else {
        printToDeviceLogcatAboutTestModuleStatus("FRAMEWORK_ERROR");
    }
    VtsMultiDeviceTestResultParser parser = new VtsMultiDeviceTestResultParser(listener, mRunName);
    if (mUseStdoutLogs) {
        if (commandResult.getStdout() == null) {
            CLog.e("The std:out is null for CommandResult.");
            throw new RuntimeException("The std:out is null for CommandResult.");
        }
        parser.processNewLines(commandResult.getStdout().split("\n"));
    } else {
        // parse from test_run_summary.json instead of stdout
        String jsonData = null;
        JSONObject object = null;
        File testRunSummary = getFileTestRunSummary(vtsRunnerLogDir);
        if (testRunSummary == null) {
            throw new RuntimeException("Couldn't locate the file : " + TEST_RUN_SUMMARY_FILE_NAME);
        }
        try {
            jsonData = FileUtil.readStringFromFile(testRunSummary);
            CLog.i("Test Result Summary: %s", jsonData);
            object = new JSONObject(jsonData);
        } catch (IOException e) {
            CLog.e("Error occurred in parsing Json file : %s", testRunSummary.toPath());
        } catch (JSONException e) {
            CLog.e("Error occurred in parsing Json String : %s", jsonData);
        }
        if (object == null) {
            CLog.e("Json object is null.");
            throw new RuntimeException("Json object is null.");
        }
        parser.processJsonFile(object);
        try {
            JSONObject planObject = object.getJSONObject(TESTMODULE);
            String test_module_name = planObject.getString("Name");
            long test_module_timestamp = planObject.getLong("Timestamp");
            AddTestModuleKeys(test_module_name, test_module_timestamp);
        } catch (JSONException e) {
            CLog.d("Key '%s' not found in result json summary", TESTMODULE);
        }
    }
    printVtsLogs(vtsRunnerLogDir);
    File reportMsg;
    int waitCount = 0;
    // Wait python process to finish for 3 minutes at most
    while ((reportMsg = FileUtil.findFile(vtsRunnerLogDir, REPORT_MESSAGE_FILE_NAME)) == null && waitCount < 180) {
        try {
            Thread.sleep(1000);
        } catch (Exception e) {
            System.out.println(e);
        }
        waitCount++;
    }
    CLog.i("Report message path: %s", reportMsg);
    if (reportMsg == null) {
        CLog.e("Cannot find report message proto file.");
    } else if (reportMsg.length() > 0) {
        CLog.i("Uploading report message. File size: %s", reportMsg.length());
        VtsDashboardUtil dashboardUtil = new VtsDashboardUtil(configReader);
        dashboardUtil.Upload(reportMsg.getAbsolutePath());
    } else {
        CLog.i("Result uploading is not enabled.");
    }
    FileUtil.recursiveDelete(vtsRunnerLogDir);
    CLog.i("Deleted the runner log dir, %s.", vtsRunnerLogDir);
    if (jsonFilePath != null) {
        FileUtil.deleteFile(new File(jsonFilePath));
        CLog.i("Deleted the runner json config file, %s.", jsonFilePath);
    }
}
#method_after
private void doRunTest(ITestRunListener listener) throws RuntimeException, IllegalArgumentException {
    CLog.i("Device serial number: " + mDevice.getSerialNumber());
    JSONObject jsonObject = new JSONObject();
    File vtsRunnerLogDir = null;
    try {
        vtsRunnerLogDir = FileUtil.createTempDir("vts-runner-log");
        updateVtsRunnerTestConfig(jsonObject);
        jsonObject.put(LOG_PATH, vtsRunnerLogDir.getAbsolutePath());
        CLog.i("Added %s to the Json object", LOG_PATH);
    } catch (IOException e) {
        throw new RuntimeException("Failed to read test config json file");
    } catch (JSONException e) {
        throw new RuntimeException("Failed to build updated test config json data");
    }
    CLog.i("config json: %s", jsonObject.toString());
    String jsonFilePath = null;
    try {
        File tmpFile = FileUtil.createTempFile(mBuildInfo.getTestTag() + "-config-" + mBuildInfo.getDeviceSerial(), ".json");
        jsonFilePath = tmpFile.getAbsolutePath();
        CLog.i("config json file path: %s", jsonFilePath);
        FileWriter fw = new FileWriter(jsonFilePath);
        fw.write(jsonObject.toString());
        fw.close();
    } catch (IOException e) {
        throw new RuntimeException("Failed to create device config json file");
    }
    if (mPythonBin == null) {
        mPythonBin = getPythonBinary();
    }
    String[] baseOpts = { mPythonBin, "-m" };
    String[] testModule = { mTestCasePath.replace("/", "."), jsonFilePath };
    String[] cmd;
    cmd = ArrayUtil.buildArray(baseOpts, testModule);
    printToDeviceLogcatAboutTestModuleStatus("BEGIN");
    CommandResult commandResult = mRunUtil.runTimedCmd(mTestTimeout + TEST_ABORT_TIMEOUT_MSECS, cmd);
    if (commandResult != null) {
        CommandStatus commandStatus = commandResult.getStatus();
        if (commandStatus != CommandStatus.SUCCESS && commandStatus != CommandStatus.TIMED_OUT) {
            CLog.e("Python process failed");
            CLog.e("Python path: %s", mPythonPath);
            CLog.e("Stderr: %s", commandResult.getStderr());
            CLog.e("Stdout: %s", commandResult.getStdout());
            printVtsLogs(vtsRunnerLogDir);
            printToDeviceLogcatAboutTestModuleStatus("ERROR");
            throw new RuntimeException("Failed to run VTS test");
        }
        CLog.i("Standard output is: %s", commandResult.getStdout());
        CLog.i("Parsing test result: %s", commandResult.getStderr());
        printToDeviceLogcatAboutTestModuleStatus("END");
    } else {
        printToDeviceLogcatAboutTestModuleStatus("FRAMEWORK_ERROR");
    }
    VtsMultiDeviceTestResultParser parser = new VtsMultiDeviceTestResultParser(listener, mRunName);
    if (mUseStdoutLogs) {
        if (commandResult.getStdout() == null) {
            CLog.e("The std:out is null for CommandResult.");
            throw new RuntimeException("The std:out is null for CommandResult.");
        }
        parser.processNewLines(commandResult.getStdout().split("\n"));
    } else {
        // parse from test_run_summary.json instead of stdout
        String jsonData = null;
        JSONObject object = null;
        File testRunSummary = getFileTestRunSummary(vtsRunnerLogDir);
        if (testRunSummary == null) {
            throw new RuntimeException("Couldn't locate the file : " + TEST_RUN_SUMMARY_FILE_NAME);
        }
        try {
            jsonData = FileUtil.readStringFromFile(testRunSummary);
            CLog.i("Test Result Summary: %s", jsonData);
            object = new JSONObject(jsonData);
        } catch (IOException e) {
            CLog.e("Error occurred in parsing Json file : %s", testRunSummary.toPath());
        } catch (JSONException e) {
            CLog.e("Error occurred in parsing Json String : %s", jsonData);
        }
        if (object == null) {
            CLog.e("Json object is null.");
            throw new RuntimeException("Json object is null.");
        }
        parser.processJsonFile(object);
        try {
            JSONObject planObject = object.getJSONObject(TESTMODULE);
            String test_module_name = planObject.getString("Name");
            long test_module_timestamp = planObject.getLong("Timestamp");
            AddTestModuleKeys(test_module_name, test_module_timestamp);
        } catch (JSONException e) {
            CLog.d("Key '%s' not found in result json summary", TESTMODULE);
        }
    }
    printVtsLogs(vtsRunnerLogDir);
    File reportMsg;
    int waitCount = 0;
    // Wait python process to finish for 3 minutes at most
    while ((reportMsg = FileUtil.findFile(vtsRunnerLogDir, REPORT_MESSAGE_FILE_NAME)) == null && waitCount < 180) {
        try {
            Thread.sleep(1000);
        } catch (Exception e) {
            System.out.println(e);
        }
        waitCount++;
    }
    CLog.i("Report message path: %s", reportMsg);
    if (reportMsg == null) {
        CLog.e("Cannot find report message proto file.");
    } else if (reportMsg.length() > 0) {
        CLog.i("Uploading report message. File size: %s", reportMsg.length());
        VtsDashboardUtil dashboardUtil = new VtsDashboardUtil(configReader);
        dashboardUtil.Upload(reportMsg.getAbsolutePath());
    } else {
        CLog.i("Result uploading is not enabled.");
    }
    FileUtil.recursiveDelete(vtsRunnerLogDir);
    CLog.i("Deleted the runner log dir, %s.", vtsRunnerLogDir);
    if (jsonFilePath != null) {
        FileUtil.deleteFile(new File(jsonFilePath));
        CLog.i("Deleted the runner json config file, %s.", jsonFilePath);
    }
}
#end_block

#method_before
private void dispatchChange(boolean selfChange, Uri uri, int userId) {
    if (mHandler == null) {
        synchronized (mLock) {
            if (mTransport != null) {
                onChange(selfChange, uri, userId);
            }
        }
    } else {
        mHandler.post(new NotificationRunnable(selfChange, uri, userId));
    }
}
#method_after
private void dispatchChange(boolean selfChange, Uri uri, int userId) {
    if (mHandler == null) {
        synchronized (mLock) {
            if (mTransport == null) {
                return;
            }
        }
        onChange(selfChange, uri, userId);
    } else {
        mHandler.post(new NotificationRunnable(selfChange, uri, userId));
    }
}
#end_block

#method_before
@Override
public void run() {
    synchronized (mLock) {
        if (mTransport != null) {
            ContentObserver.this.onChange(mSelfChange, mUri, mUserId);
        }
    }
}
#method_after
@Override
public void run() {
    synchronized (mLock) {
        if (mTransport == null) {
            return;
        }
    }
    ContentObserver.this.onChange(mSelfChange, mUri, mUserId);
}
#end_block

#method_before
static Bitmap.NativeWrapper allocNativeStorage(int width, int height) {
    int nativeData;
    synchronized (Bitmap.class) {
        nativeData = sSerial++;
    }
    Bitmap.NativeWrapper wrapper = new Bitmap.NativeWrapper(nativeData);
    PhantomWrapper phan = new PhantomWrapper(wrapper, sPhantomQueue, nativeData);
    sPhantomList.add(phan);
    return wrapper;
}
#method_after
static Bitmap.NativeWrapper allocNativeStorage(int width, int height) {
    int nativeData;
    synchronized (Bitmap.class) {
        nativeData = sSerial++;
    }
    Bitmap.NativeWrapper wrapper = new Bitmap.NativeWrapper(nativeData);
    PhantomWrapper phan = new PhantomWrapper(wrapper, sPhantomQueue, nativeData);
    sPhantomList.add(phan);
    wrapper.mPhantomWrapper = phan;
    return wrapper;
}
#end_block

#method_before
static void freeNativeStorage(int nativeDataPtr) {
    System.out.println("freeNativeStorage: " + nativeDataPtr);
    Main.freeNativeStoragePrinted = true;
}
#method_after
static void freeNativeStorage(int nativeDataPtr, CountDownLatch freeSignal) {
    System.out.println("freeNativeStorage: " + nativeDataPtr);
    // Wake up the main thread that is [or will be] blocked until this native data is freed.
    freeSignal.countDown();
}
#end_block

#method_before
public void run() {
    while (true) {
        try {
            PhantomWrapper ref = (PhantomWrapper) mQueue.remove();
            // System.out.println("dequeued ref " + ref.mNativeData +
            // " - " + ref);
            Bitmap.freeNativeStorage(ref.mNativeData);
        // ref.clear();
        } catch (InterruptedException ie) {
            System.out.println("intr");
            break;
        }
    }
}
#method_after
public void run() {
    while (true) {
        try {
            PhantomWrapper ref = (PhantomWrapper) mQueue.remove();
            // System.out.println("dequeued ref " + ref.mNativeData +
            // " - " + ref);
            Bitmap.freeNativeStorage(ref.mNativeData, ref.mFreeSignal);
        } catch (InterruptedException ie) {
            System.out.println("intr");
            break;
        }
    }
}
#end_block

#method_before
public static void main(String[] args) {
    System.out.println("start");
    Main main = new Main();
    main.run();
    sleep(1000);
    System.out.println("done");
}
#method_after
public static void main(String[] args) {
    System.out.println("start");
    Main main = new Main();
    main.run();
    System.out.println("done");
}
#end_block

#method_before
public void run() {
    createBitmaps();
    Runtime.getRuntime().gc();
    sleep(250);
    mBitmap2.drawAt(0, 0);
    System.out.println("nulling 1");
    mBitmap1 = null;
    Runtime.getRuntime().gc();
    while (!freeNativeStoragePrinted) {
        sleep(500);
    }
    freeNativeStoragePrinted = false;
    System.out.println("nulling 2");
    mBitmap2 = null;
    Runtime.getRuntime().gc();
    sleep(500);
    System.out.println("nulling 3");
    mBitmap3 = null;
    Runtime.getRuntime().gc();
    sleep(500);
    System.out.println("nulling 4");
    mBitmap4 = null;
    Runtime.getRuntime().gc();
    while (!freeNativeStoragePrinted) {
        sleep(500);
    }
    Bitmap.shutDown();
}
#method_after
public void run() {
    createBitmaps();
    Runtime.getRuntime().gc();
    sleep(250);
    mBitmap2.drawAt(0, 0);
    System.out.println("nulling 1");
    mBitmap1 = null;
    Runtime.getRuntime().gc();
    try {
        // Block until dataA is definitely freed.
        mFreeSignalA.await();
    } catch (InterruptedException e) {
        System.out.println("got unexpected InterruptedException e: " + e);
    }
    System.out.println("nulling 2");
    mBitmap2 = null;
    Runtime.getRuntime().gc();
    sleep(200);
    System.out.println("nulling 3");
    mBitmap3 = null;
    Runtime.getRuntime().gc();
    sleep(200);
    System.out.println("nulling 4");
    mBitmap4 = null;
    Runtime.getRuntime().gc();
    try {
        // Block until dataB is definitely freed.
        mFreeSignalB.await();
    } catch (InterruptedException e) {
        System.out.println("got unexpected InterruptedException e: " + e);
    }
    Bitmap.shutDown();
}
#end_block

#method_before
public void createBitmaps() {
    Bitmap.NativeWrapper dataA = Bitmap.allocNativeStorage(10, 10);
    Bitmap.NativeWrapper dataB = Bitmap.allocNativeStorage(20, 20);
    mBitmap1 = new Bitmap("one", 10, 10, dataA);
    mBitmap2 = new Bitmap("two", 20, 20, dataB);
    mBitmap3 = mBitmap4 = new Bitmap("three/four", 20, 20, dataB);
}
#method_after
public void createBitmaps() {
    Bitmap.NativeWrapper dataA = Bitmap.allocNativeStorage(10, 10);
    mFreeSignalA = dataA.mPhantomWrapper.mFreeSignal;
    Bitmap.NativeWrapper dataB = Bitmap.allocNativeStorage(20, 20);
    mFreeSignalB = dataB.mPhantomWrapper.mFreeSignal;
    mBitmap1 = new Bitmap("one", 10, 10, dataA);
    mBitmap2 = new Bitmap("two", 20, 20, dataB);
    mBitmap3 = mBitmap4 = new Bitmap("three/four", 20, 20, dataB);
}
#end_block

#method_before
@Override
public void tearDown() throws Exception {
    mFile.delete();
}
#method_after
@Override
public void tearDown() throws Exception {
    for (File file : temporaryFiles) {
        file.delete();
    }
    temporaryFiles.clear();
    super.tearDown();
}
#end_block

#method_before
public void test_utf8FileNames() throws Exception {
    // Create a zip file containing non-ASCII filenames.
    List<String> filenames = Arrays.asList("us-ascii", // russian
    "\u043c\u0430\u0440\u0442\u0430", // greek
    "\u1f00\u03c0\u1f78", // japanese
    "\u30b3\u30f3\u30cb\u30c1\u30cf");
    ZipOutputStream out = new ZipOutputStream(new FileOutputStream(mFile));
    for (String filename : filenames) {
        out.putNextEntry(new ZipEntry(filename));
        // Empty files are fine.
        out.closeEntry();
    }
    out.close();
    // Read it back, and check we find all those names.
    // This failed when we were mangling the encoding.
    ZipFile zipFile = new ZipFile(mFile);
    for (String filename : filenames) {
        assertNotNull(filename, zipFile.getEntry(filename));
    }
    // Check that ZipInputStream works too.
    ZipInputStream in = new ZipInputStream(new FileInputStream(mFile));
    ZipEntry entry;
    int entryCount = 0;
    while ((entry = in.getNextEntry()) != null) {
        assertTrue(entry.getName(), filenames.contains(entry.getName()));
        ++entryCount;
    }
    assertEquals(filenames.size(), entryCount);
    in.close();
}
#method_after
public void test_utf8FileNames() throws Exception {
    // Create a zip file containing non-ASCII filenames.
    File f = File.createTempFile("your", "mum");
    List<String> filenames = Arrays.asList("us-ascii", // russian
    "\u043c\u0430\u0440\u0442\u0430", // greek
    "\u1f00\u03c0\u1f78", // japanese
    "\u30b3\u30f3\u30cb\u30c1\u30cf");
    ZipOutputStream out = new ZipOutputStream(new FileOutputStream(f));
    for (String filename : filenames) {
        out.putNextEntry(new ZipEntry(filename));
        // Empty files are fine.
        out.closeEntry();
    }
    out.close();
    // Read it back, and check we find all those names.
    // This failed when we were mangling the encoding.
    ZipFile zipFile = new ZipFile(f);
    for (String filename : filenames) {
        assertNotNull(filename, zipFile.getEntry(filename));
    }
    // Check that ZipInputStream works too.
    ZipInputStream in = new ZipInputStream(new FileInputStream(f));
    ZipEntry entry;
    int entryCount = 0;
    while ((entry = in.getNextEntry()) != null) {
        assertTrue(entry.getName(), filenames.contains(entry.getName()));
        ++entryCount;
    }
    assertEquals(filenames.size(), entryCount);
    in.close();
}
#end_block

#method_before
public void testMaxLengthName() throws Exception {
    String maxLengthName = makeString(65535, "z");
    ZipOutputStream out = createZipOutputStream(mFile);
    out.putNextEntry(new ZipEntry(maxLengthName));
    out.closeEntry();
    out.close();
    // Read it back, and check that we see the entry.
    ZipFile zipFile = new ZipFile(mFile);
    assertNotNull(zipFile.getEntry(maxLengthName));
    zipFile.close();
}
#method_after
public void testMaxLengthName() throws Exception {
    String maxLengthName = makeString(65535, "z");
    File f = createTemporaryZipFile();
    ZipOutputStream out = createZipOutputStream(f);
    out.putNextEntry(new ZipEntry(maxLengthName));
    out.closeEntry();
    out.close();
    // Read it back, and check that we see the entry.
    ZipFile zipFile = new ZipFile(f);
    assertNotNull(zipFile.getEntry(maxLengthName));
    zipFile.close();
}
#end_block

#method_before
public void testMaxLengthExtra() throws Exception {
    byte[] maxLengthExtra = new byte[65535];
    ZipOutputStream out = createZipOutputStream(mFile);
    ZipEntry ze = new ZipEntry("x");
    ze.setSize(0);
    ze.setTime(ENTRY_TIME);
    ze.setExtra(maxLengthExtra);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back, and check that we see the entry.
    ZipFile zipFile = new ZipFile(mFile);
    assertEquals(maxLengthExtra.length, zipFile.getEntry("x").getExtra().length);
    zipFile.close();
}
#method_after
public void testMaxLengthExtra() throws Exception {
    byte[] maxLengthExtra = new byte[65535];
    File f = createTemporaryZipFile();
    ZipOutputStream out = createZipOutputStream(f);
    ZipEntry ze = new ZipEntry("x");
    ze.setSize(0);
    ze.setTime(ENTRY_TIME);
    ze.setExtra(maxLengthExtra);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back, and check that we see the entry.
    ZipFile zipFile = new ZipFile(f);
    assertEquals(maxLengthExtra.length, zipFile.getEntry("x").getExtra().length);
    zipFile.close();
}
#end_block

#method_before
private void checkSetTime(long time) throws IOException {
    ZipOutputStream out = createZipOutputStream(mFile);
    ZipEntry ze = new ZipEntry("x");
    ze.setSize(0);
    ze.setTime(time);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back, and check that we see the entry.
    ZipFile zipFile = new ZipFile(mFile);
    assertEquals(time, zipFile.getEntry("x").getTime());
    zipFile.close();
}
#method_after
private void checkSetTime(long time) throws IOException {
    File f = createTemporaryZipFile();
    ZipOutputStream out = createZipOutputStream(f);
    ZipEntry ze = new ZipEntry("x");
    ze.setSize(0);
    ze.setTime(time);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back, and check that we see the entry.
    ZipFile zipFile = new ZipFile(f);
    assertEquals(time, zipFile.getEntry("x").getTime());
    zipFile.close();
}
#end_block

#method_before
public void testMaxLengthComment() throws Exception {
    String maxLengthComment = makeString(65535, "z");
    ZipOutputStream out = createZipOutputStream(mFile);
    ZipEntry ze = new ZipEntry("x");
    ze.setComment(maxLengthComment);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back, and check that we see the entry.
    ZipFile zipFile = new ZipFile(mFile);
    assertEquals(maxLengthComment, zipFile.getEntry("x").getComment());
    zipFile.close();
}
#method_after
public void testMaxLengthComment() throws Exception {
    String maxLengthComment = makeString(65535, "z");
    File f = createTemporaryZipFile();
    ZipOutputStream out = createZipOutputStream(f);
    ZipEntry ze = new ZipEntry("x");
    ze.setComment(maxLengthComment);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back, and check that we see the entry.
    ZipFile zipFile = new ZipFile(f);
    assertEquals(maxLengthComment, zipFile.getEntry("x").getComment());
    zipFile.close();
}
#end_block

#method_before
public void testCommentAndExtraInSameOrder() throws Exception {
    String comment = makeString(17, "z");
    byte[] extra = makeString(11, "a").getBytes();
    ZipOutputStream out = createZipOutputStream(mFile);
    // Regular (non zip64) format.
    ZipEntry ze = new ZipEntry("x");
    ze.setSize(0);
    ze.setTime(ENTRY_TIME);
    ze.setExtra(extra);
    ze.setComment(comment);
    out.putNextEntry(ze);
    out.closeEntry();
    // An entry without a length is assumed to be zip64.
    ze = new ZipEntry("y");
    ze.setTime(ENTRY_TIME);
    ze.setExtra(extra);
    ze.setComment(comment);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back and make sure comments and extra are in the right order
    ZipFile zipFile = new ZipFile(mFile);
    try {
        assertEquals(comment, zipFile.getEntry("x").getComment());
        assertTrue(Arrays.equals(extra, zipFile.getEntry("x").getExtra()));
        assertEquals(comment, zipFile.getEntry("y").getComment());
        assertTrue(Arrays.equals(extra, zipFile.getEntry("y").getExtra()));
    } finally {
        zipFile.close();
    }
}
#method_after
public void testCommentAndExtraInSameOrder() throws Exception {
    String comment = makeString(17, "z");
    byte[] extra = makeString(11, "a").getBytes();
    File f = createTemporaryZipFile();
    ZipOutputStream out = createZipOutputStream(f);
    // Regular (non zip64) format.
    ZipEntry ze = new ZipEntry("x");
    ze.setSize(0);
    ze.setTime(ENTRY_TIME);
    ze.setExtra(extra);
    ze.setComment(comment);
    out.putNextEntry(ze);
    out.closeEntry();
    // An entry without a length is assumed to be zip64.
    ze = new ZipEntry("y");
    ze.setTime(ENTRY_TIME);
    ze.setExtra(extra);
    ze.setComment(comment);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back and make sure comments and extra are in the right order
    ZipFile zipFile = new ZipFile(f);
    try {
        assertEquals(comment, zipFile.getEntry("x").getComment());
        assertTrue(Arrays.equals(extra, zipFile.getEntry("x").getExtra()));
        assertEquals(comment, zipFile.getEntry("y").getComment());
        assertTrue(Arrays.equals(extra, zipFile.getEntry("y").getExtra()));
    } finally {
        zipFile.close();
    }
}
#end_block

#method_before
public void testMaxLengthExtra() throws Exception {
    byte[] maxLengthExtra = new byte[65535];
    File f = createTemporaryZipFile();
    ZipOutputStream out = createZipOutputStream(f);
    ZipEntry ze = new ZipEntry("x");
    ze.setSize(0);
    ze.setTime(TEST_TIME);
    ze.setExtra(maxLengthExtra);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back, and check that we see the entry.
    ZipFile zipFile = new ZipFile(f);
    assertEquals(maxLengthExtra.length, zipFile.getEntry("x").getExtra().length);
    zipFile.close();
}
#method_after
public void testMaxLengthExtra() throws Exception {
    byte[] maxLengthExtra = new byte[65535];
    File f = createTemporaryZipFile();
    ZipOutputStream out = createZipOutputStream(f);
    ZipEntry ze = new ZipEntry("x");
    ze.setSize(0);
    ze.setTime(ENTRY_TIME);
    ze.setExtra(maxLengthExtra);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back, and check that we see the entry.
    ZipFile zipFile = new ZipFile(f);
    assertEquals(maxLengthExtra.length, zipFile.getEntry("x").getExtra().length);
    zipFile.close();
}
#end_block

#method_before
public void testCommentAndExtraInSameOrder() throws Exception {
    String comment = makeString(17, "z");
    byte[] extra = makeString(11, "a").getBytes();
    File f = createTemporaryZipFile();
    ZipOutputStream out = createZipOutputStream(f);
    // Regular (non zip64) format.
    ZipEntry ze = new ZipEntry("x");
    ze.setSize(0);
    ze.setTime(TEST_TIME);
    ze.setExtra(extra);
    ze.setComment(comment);
    out.putNextEntry(ze);
    out.closeEntry();
    // An entry without a length is assumed to be zip64.
    ze = new ZipEntry("y");
    ze.setTime(TEST_TIME);
    ze.setExtra(extra);
    ze.setComment(comment);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back and make sure comments and extra are in the right order
    ZipFile zipFile = new ZipFile(f);
    try {
        assertEquals(comment, zipFile.getEntry("x").getComment());
        assertTrue(Arrays.equals(extra, zipFile.getEntry("x").getExtra()));
        assertEquals(comment, zipFile.getEntry("y").getComment());
        assertTrue(Arrays.equals(extra, zipFile.getEntry("y").getExtra()));
    } finally {
        zipFile.close();
    }
}
#method_after
public void testCommentAndExtraInSameOrder() throws Exception {
    String comment = makeString(17, "z");
    byte[] extra = makeString(11, "a").getBytes();
    File f = createTemporaryZipFile();
    ZipOutputStream out = createZipOutputStream(f);
    // Regular (non zip64) format.
    ZipEntry ze = new ZipEntry("x");
    ze.setSize(0);
    ze.setTime(ENTRY_TIME);
    ze.setExtra(extra);
    ze.setComment(comment);
    out.putNextEntry(ze);
    out.closeEntry();
    // An entry without a length is assumed to be zip64.
    ze = new ZipEntry("y");
    ze.setTime(ENTRY_TIME);
    ze.setExtra(extra);
    ze.setComment(comment);
    out.putNextEntry(ze);
    out.closeEntry();
    out.close();
    // Read it back and make sure comments and extra are in the right order
    ZipFile zipFile = new ZipFile(f);
    try {
        assertEquals(comment, zipFile.getEntry("x").getComment());
        assertTrue(Arrays.equals(extra, zipFile.getEntry("x").getExtra()));
        assertEquals(comment, zipFile.getEntry("y").getComment());
        assertTrue(Arrays.equals(extra, zipFile.getEntry("y").getExtra()));
    } finally {
        zipFile.close();
    }
}
#end_block

#method_before
static PackageTracker create(Context context) {
    PackageTrackerHelperImpl helperImpl = new PackageTrackerHelperImpl(context);
    return new PackageTracker(helperImpl, /* clock */
    helperImpl, /* configHelper */
    helperImpl, /* packageManagerHelper */
    new PackageStatusStorage(Environment.getDataDirectory()), new IntentHelperImpl(context));
}
#method_after
static PackageTracker create(Context context) {
    PackageTrackerHelperImpl helperImpl = new PackageTrackerHelperImpl(context);
    // TODO(nfuller): Switch to FileUtils.createDir() when available. http://b/31008728
    File storageDir = new File(Environment.getDataSystemDirectory(), "timezone");
    if (!storageDir.exists()) {
        storageDir.mkdir();
    }
    return new PackageTracker(helperImpl, /* clock */
    helperImpl, /* configHelper */
    helperImpl, /* packageManagerHelper */
    new PackageStatusStorage(storageDir), new IntentHelperImpl(context));
}
#end_block

#method_before
void increment(int imp) {
    imp = imp < 0 ? 0 : imp > NUM_IMPORTANCES - 1 ? NUM_IMPORTANCES - 1 : imp;
    mCount[imp]++;
}
#method_after
void increment(int imp) {
    imp = Math.max(0, Math.min(imp, mCount.length - 1));
    mCount[imp]++;
}
#end_block

#method_before
@Override
public void Print() {
    System.out.println(whitespace(cnt) + "=> " + m);
}
#method_after
@Override
public void Print() {
    System.out.println(whitespace(cnt) + "=> " + methodToString(m));
}
#end_block

#method_before
private static String genericToString(Object val) {
    if (val == null) {
        return "null";
    } else if (val.getClass().isArray()) {
        return arrayToString(val);
    } else if (val instanceof Throwable) {
        StringWriter w = new StringWriter();
        ((Throwable) val).printStackTrace(new PrintWriter(w));
        return w.toString();
    } else {
        return val.toString();
    }
}
#method_after
private static String genericToString(Object val) {
    if (val == null) {
        return "null";
    } else if (val.getClass().isArray()) {
        return arrayToString(val);
    } else if (val instanceof Throwable) {
        StringWriter w = new StringWriter();
        Throwable thr = ((Throwable) val);
        w.write(thr.getClass().getName() + ": " + thr.getMessage() + "\n");
        for (StackTraceElement e : thr.getStackTrace()) {
            if (e.getClassName().startsWith("art.")) {
                w.write("\t" + e + "\n");
            } else {
                w.write("\t<additional hidden frames>\n");
                break;
            }
        }
        return w.toString();
    } else {
        return val.toString();
    }
}
#end_block

#method_before
@Override
public void Print() {
    String print;
    if (NON_DETERMINISTIC_OUTPUT_METHODS.contains(m)) {
        print = "<non-deterministic>";
    } else {
        print = genericToString(val);
    }
    Class<?> klass = null;
    if (val != null) {
        klass = val.getClass();
    }
    System.out.println(whitespace(cnt) + "<= " + m + " -> <" + klass + ": " + print + ">");
}
#method_after
@Override
public void Print() {
    String print;
    if (NON_DETERMINISTIC_OUTPUT_METHODS.contains(m)) {
        print = "<non-deterministic>";
    } else {
        print = genericToString(val);
    }
    Class<?> klass = null;
    if (val != null) {
        klass = val.getClass();
    }
    String klass_print;
    if (klass == null) {
        klass_print = "null";
    } else if (NON_DETERMINISTIC_OUTPUT_TYPE_METHODS.contains(m)) {
        klass_print = "<non-deterministic>";
    } else {
        klass_print = klass.toString();
    }
    System.out.println(whitespace(cnt) + "<= " + methodToString(m) + " -> <" + klass_print + ": " + print + ">");
}
#end_block

#method_before
@Override
public void Print() {
    System.out.println(whitespace(cnt) + "<= " + m + " EXCEPTION");
}
#method_after
@Override
public void Print() {
    System.out.println(whitespace(cnt) + "<= " + methodToString(m) + " EXCEPTION");
}
#end_block

#method_before
public static void notifyMethodEntry(Object m) {
    // Called by native code when a method is entered. This method is ignored by the native
    // entry and exit hooks.
    results.add(new MethodEntry(m, cnt));
    cnt++;
}
#method_after
public static void notifyMethodEntry(Object m) {
    // Called by native code when a method is entered. This method is ignored by the native
    // entry and exit hooks.
    cnt++;
    if ((cnt - 1) > METHOD_TRACING_IGNORE_DEPTH && sMethodTracingIgnore) {
        return;
    }
    results.add(new MethodEntry(m, cnt - 1));
}
#end_block

#method_before
public static void notifyMethodExit(Object m, boolean exception, Object result) {
    cnt--;
    if (exception) {
        results.add(new MethodThrownThrough(m, cnt));
    } else {
        results.add(new MethodReturn(m, result, cnt));
    }
}
#method_after
public static void notifyMethodExit(Object m, boolean exception, Object result) {
    cnt--;
    if (cnt > METHOD_TRACING_IGNORE_DEPTH && sMethodTracingIgnore) {
        return;
    }
    if (exception) {
        results.add(new MethodThrownThrough(m, cnt));
    } else {
        results.add(new MethodReturn(m, result, cnt));
    }
}
#end_block

#method_before
public static void run() throws Exception {
    // call this here so it is linked. It doesn't actually do anything here.
    loadAllClasses();
    Trace.disableTracing(Thread.currentThread());
    Trace.enableMethodTracing(Test988.class, Test988.class.getDeclaredMethod("notifyMethodEntry", Object.class), Test988.class.getDeclaredMethod("notifyMethodExit", Object.class, Boolean.TYPE, Object.class), Thread.currentThread());
    doFibTest(30, new IterOp());
    doFibTest(5, new RecurOp());
    doFibTest(-19, new IterOp());
    doFibTest(-19, new RecurOp());
    Long.compare(123L, 456L);
    // Turn off method tracing so we don't have to deal with print internals.
    Trace.disableTracing(Thread.currentThread());
    printResults();
}
#method_after
public static void run() throws Exception {
    // call this here so it is linked. It doesn't actually do anything here.
    loadAllClasses();
    Trace.disableTracing(Thread.currentThread());
    Trace.enableMethodTracing(Test988.class, Test988.class.getDeclaredMethod("notifyMethodEntry", Object.class), Test988.class.getDeclaredMethod("notifyMethodExit", Object.class, Boolean.TYPE, Object.class), Thread.currentThread());
    doFibTest(30, new IterOp());
    doFibTest(5, new RecurOp());
    doFibTest(-19, new IterOp());
    doFibTest(-19, new RecurOp());
    sMethodTracingIgnore = true;
    IntrinsicsTest.doTest();
    sMethodTracingIgnore = false;
    // Turn off method tracing so we don't have to deal with print internals.
    Trace.disableTracing(Thread.currentThread());
    printResults();
}
#end_block

#method_before
// This ensures that all classes we touch are loaded before we start recording traces. This
public static void loadAllClasses() {
    MethodThrownThrough.class.toString();
    MethodEntry.class.toString();
    MethodReturn.class.toString();
    FibResult.class.toString();
    FibThrow.class.toString();
    Printable.class.toString();
    ArrayList.class.toString();
    RecurOp.class.toString();
    IterOp.class.toString();
    StringBuilder.class.toString();
}
#method_after
// This ensures that all classes we touch are loaded before we start recording traces. This
public static void loadAllClasses() {
    MethodThrownThrough.class.toString();
    MethodEntry.class.toString();
    MethodReturn.class.toString();
    FibResult.class.toString();
    FibThrow.class.toString();
    Printable.class.toString();
    ArrayList.class.toString();
    RecurOp.class.toString();
    IterOp.class.toString();
    StringBuilder.class.toString();
    // ensure <clinit> is executed prior to tracing.
    IntrinsicsTest.initialize();
}
#end_block

#method_before
private void handleCmd(CatCmdMessage cmdMsg, int slotId) {
    if (cmdMsg == null) {
        return;
    }
    // save local reference for state tracking.
    mStkContext[slotId].mCurrentCmd = cmdMsg;
    boolean waitForUsersResponse = true;
    mStkContext[slotId].mIsInputPending = false;
    mStkContext[slotId].mIsMenuPending = false;
    mStkContext[slotId].mIsDialogPending = false;
    CatLog.d(LOG_TAG, "[handleCmd]" + cmdMsg.getCmdType().name());
    switch(cmdMsg.getCmdType()) {
        case DISPLAY_TEXT:
            TextMessage msg = cmdMsg.geTextMessage();
            waitForUsersResponse = msg.responseNeeded;
            if (mStkContext[slotId].lastSelectedItem != null) {
                msg.title = mStkContext[slotId].lastSelectedItem;
            } else if (mStkContext[slotId].mMainCmd != null) {
                msg.title = mStkContext[slotId].mMainCmd.getMenu().title;
            } else {
                // TODO: get the carrier name from the SIM
                msg.title = "";
            }
            // proactive command (Refer to ETSI TS 102 384 section 27.22.4.1.4.4.2).
            if (!(msg.isHighPriority || mStkContext[slotId].mMenuIsVisible || mStkContext[slotId].mDisplayTextDlgIsVisibile || isTopOfStack())) {
                if (!isScreenIdle()) {
                    CatLog.d(LOG_TAG, "Screen is not idle");
                    sendScreenBusyResponse(slotId);
                } else {
                    launchTextDialog(slotId);
                }
            } else {
                launchTextDialog(slotId);
            }
            break;
        case SELECT_ITEM:
            CatLog.d(LOG_TAG, "SELECT_ITEM +");
            mStkContext[slotId].mCurrentMenuCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenu = cmdMsg.getMenu();
            launchMenuActivity(cmdMsg.getMenu(), slotId);
            break;
        case SET_UP_MENU:
            mStkContext[slotId].mCmdInProgress = false;
            mStkContext[slotId].mMainCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenuCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenu = cmdMsg.getMenu();
            CatLog.d(LOG_TAG, "SET_UP_MENU [" + removeMenu(slotId) + "]");
            if (removeMenu(slotId)) {
                int i = 0;
                CatLog.d(LOG_TAG, "removeMenu() - Uninstall App");
                mStkContext[slotId].mCurrentMenu = null;
                mStkContext[slotId].mMainCmd = null;
                // Check other setup menu state. If all setup menu are removed, uninstall apk.
                for (i = PhoneConstants.SIM_ID_1; i < mSimCount; i++) {
                    if (i != slotId && (mStkContext[slotId].mSetupMenuState == STATE_UNKNOWN || mStkContext[slotId].mSetupMenuState == STATE_EXIST)) {
                        CatLog.d(LOG_TAG, "Not Uninstall App:" + i + "," + mStkContext[slotId].mSetupMenuState);
                        break;
                    }
                }
                if (i == mSimCount) {
                    StkAppInstaller.unInstall(mContext);
                }
            } else {
                CatLog.d(LOG_TAG, "install App");
                StkAppInstaller.install(mContext);
            }
            if (mStkContext[slotId].mMenuIsVisible) {
                launchMenuActivity(null, slotId);
            }
            break;
        case GET_INPUT:
        case GET_INKEY:
            launchInputActivity(slotId);
            break;
        case SET_UP_IDLE_MODE_TEXT:
            waitForUsersResponse = false;
            mStkContext[slotId].mIdleModeTextCmd = mStkContext[slotId].mCurrentCmd;
            TextMessage idleModeText = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if (idleModeText == null) {
                launchIdleText(slotId);
                mStkContext[slotId].mIdleModeTextCmd = null;
            }
            mStkContext[slotId].mCurrentCmd = mStkContext[slotId].mMainCmd;
            if ((mStkContext[slotId].mIdleModeTextCmd != null) && isScreenIdle()) {
                CatLog.d(this, "set up idle mode");
                launchIdleText(slotId);
            }
            break;
        case SEND_DTMF:
        case SEND_SMS:
        case SEND_SS:
        case SEND_USSD:
        case GET_CHANNEL_STATUS:
            waitForUsersResponse = false;
            launchEventMessage(slotId);
            break;
        case LAUNCH_BROWSER:
            // The device setup process should not be interrupted by launching browser.
            if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0) == 0) {
                CatLog.d(this, "The command is not performed if the setup has not been completed.");
                sendScreenBusyResponse(slotId);
                break;
            }
            TextMessage alphaId = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if ((mStkContext[slotId].mCurrentCmd.getBrowserSettings().mode == LaunchBrowserMode.LAUNCH_IF_NOT_ALREADY_LAUNCHED) && ((alphaId == null) || TextUtils.isEmpty(alphaId.text))) {
                // don't need user confirmation in this case
                // just launch the browser or spawn a new tab
                CatLog.d(this, "Browser mode is: launch if not already launched " + "and user confirmation is not currently needed.\n" + "supressing confirmation dialogue and confirming silently...");
                mStkContext[slotId].launchBrowser = true;
                mStkContext[slotId].mBrowserSettings = mStkContext[slotId].mCurrentCmd.getBrowserSettings();
                sendResponse(RES_ID_CONFIRM, slotId, true);
            } else {
                launchConfirmationDialog(alphaId, slotId);
            }
            break;
        case SET_UP_CALL:
            TextMessage mesg = mStkContext[slotId].mCurrentCmd.getCallSettings().confirmMsg;
            if ((mesg != null) && (mesg.text == null || mesg.text.length() == 0)) {
                mesg.text = getResources().getString(R.string.default_setup_call_msg);
            }
            CatLog.d(this, "SET_UP_CALL mesg.text " + mesg.text);
            launchConfirmationDialog(mesg, slotId);
            break;
        case PLAY_TONE:
            handlePlayTone(slotId);
            break;
        case OPEN_CHANNEL:
            launchOpenChannelDialog(slotId);
            break;
        case CLOSE_CHANNEL:
        case RECEIVE_DATA:
        case SEND_DATA:
            TextMessage m = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if ((m != null) && (m.text == null)) {
                switch(cmdMsg.getCmdType()) {
                    case CLOSE_CHANNEL:
                        m.text = getResources().getString(R.string.default_close_channel_msg);
                        break;
                    case RECEIVE_DATA:
                        m.text = getResources().getString(R.string.default_receive_data_msg);
                        break;
                    case SEND_DATA:
                        m.text = getResources().getString(R.string.default_send_data_msg);
                        break;
                }
            }
            /*
             * Display indication in the form of a toast to the user if required.
             */
            launchEventMessage(slotId);
            break;
        case SET_UP_EVENT_LIST:
            mStkContext[slotId].mSetupEventListSettings = mStkContext[slotId].mCurrentCmd.getSetEventList();
            mStkContext[slotId].mCurrentSetupEventCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentCmd = mStkContext[slotId].mMainCmd;
            if (isScreenIdle()) {
                CatLog.d(this, " Check if IDLE_SCREEN_AVAILABLE_EVENT is present in List");
                checkForSetupEvent(IDLE_SCREEN_AVAILABLE_EVENT, null, slotId);
            }
            break;
    }
    if (!waitForUsersResponse) {
        if (mStkContext[slotId].mCmdsQ.size() != 0) {
            callDelayedMsg(slotId);
        } else {
            mStkContext[slotId].mCmdInProgress = false;
        }
    }
}
#method_after
private void handleCmd(CatCmdMessage cmdMsg, int slotId) {
    if (cmdMsg == null) {
        return;
    }
    // save local reference for state tracking.
    mStkContext[slotId].mCurrentCmd = cmdMsg;
    boolean waitForUsersResponse = true;
    mStkContext[slotId].mIsInputPending = false;
    mStkContext[slotId].mIsMenuPending = false;
    mStkContext[slotId].mIsDialogPending = false;
    CatLog.d(LOG_TAG, "[handleCmd]" + cmdMsg.getCmdType().name());
    switch(cmdMsg.getCmdType()) {
        case DISPLAY_TEXT:
            TextMessage msg = cmdMsg.geTextMessage();
            waitForUsersResponse = msg.responseNeeded;
            if (mStkContext[slotId].lastSelectedItem != null) {
                msg.title = mStkContext[slotId].lastSelectedItem;
            } else if (mStkContext[slotId].mMainCmd != null) {
                msg.title = mStkContext[slotId].mMainCmd.getMenu().title;
            } else {
                // TODO: get the carrier name from the SIM
                msg.title = "";
            }
            // proactive command (Refer to ETSI TS 102 384 section 27.22.4.1.4.4.2).
            if (!(msg.isHighPriority || mStkContext[slotId].mMenuIsVisible || mStkContext[slotId].mDisplayTextDlgIsVisibile || isTopOfStack())) {
                if (!isScreenIdle()) {
                    CatLog.d(LOG_TAG, "Screen is not idle");
                    sendScreenBusyResponse(slotId);
                } else {
                    launchTextDialog(slotId);
                }
            } else {
                launchTextDialog(slotId);
            }
            break;
        case SELECT_ITEM:
            CatLog.d(LOG_TAG, "SELECT_ITEM +");
            mStkContext[slotId].mCurrentMenuCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenu = cmdMsg.getMenu();
            launchMenuActivity(cmdMsg.getMenu(), slotId);
            break;
        case SET_UP_MENU:
            mStkContext[slotId].mCmdInProgress = false;
            mStkContext[slotId].mMainCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenuCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentMenu = cmdMsg.getMenu();
            CatLog.d(LOG_TAG, "SET_UP_MENU [" + removeMenu(slotId) + "]");
            if (removeMenu(slotId)) {
                int i = 0;
                CatLog.d(LOG_TAG, "removeMenu() - Uninstall App");
                mStkContext[slotId].mCurrentMenu = null;
                mStkContext[slotId].mMainCmd = null;
                // Check other setup menu state. If all setup menu are removed, uninstall apk.
                for (i = PhoneConstants.SIM_ID_1; i < mSimCount; i++) {
                    if (i != slotId && (mStkContext[slotId].mSetupMenuState == STATE_UNKNOWN || mStkContext[slotId].mSetupMenuState == STATE_EXIST)) {
                        CatLog.d(LOG_TAG, "Not Uninstall App:" + i + "," + mStkContext[slotId].mSetupMenuState);
                        break;
                    }
                }
                if (i == mSimCount) {
                    StkAppInstaller.unInstall(mContext);
                }
            } else {
                CatLog.d(LOG_TAG, "install App");
                StkAppInstaller.install(mContext);
            }
            if (mStkContext[slotId].mMenuIsVisible) {
                launchMenuActivity(null, slotId);
            }
            break;
        case GET_INPUT:
        case GET_INKEY:
            launchInputActivity(slotId);
            break;
        case SET_UP_IDLE_MODE_TEXT:
            waitForUsersResponse = false;
            mStkContext[slotId].mIdleModeTextCmd = mStkContext[slotId].mCurrentCmd;
            TextMessage idleModeText = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if (idleModeText == null) {
                launchIdleText(slotId);
                mStkContext[slotId].mIdleModeTextCmd = null;
            }
            mStkContext[slotId].mCurrentCmd = mStkContext[slotId].mMainCmd;
            if ((mStkContext[slotId].mIdleModeTextCmd != null) && isScreenIdle()) {
                CatLog.d(this, "set up idle mode");
                launchIdleText(slotId);
            }
            break;
        case SEND_DTMF:
        case SEND_SMS:
        case SEND_SS:
        case SEND_USSD:
        case GET_CHANNEL_STATUS:
            waitForUsersResponse = false;
            launchEventMessage(slotId);
            break;
        case LAUNCH_BROWSER:
            // The device setup process should not be interrupted by launching browser.
            if (Settings.Global.getInt(mContext.getContentResolver(), Settings.Global.DEVICE_PROVISIONED, 0) == 0) {
                CatLog.d(this, "The command is not performed if the setup has not been completed.");
                sendScreenBusyResponse(slotId);
                break;
            }
            /* Check if Carrier would not want to launch browser */
            if (getBooleanCarrierConfig(mContext, CarrierConfigManager.KEY_STK_DISABLE_LAUNCH_BROWSER_BOOL)) {
                CatLog.d(this, "Browser is not launched as per carrier.");
                sendResponse(RES_ID_DONE, slotId, true);
                break;
            }
            TextMessage alphaId = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if ((mStkContext[slotId].mCurrentCmd.getBrowserSettings().mode == LaunchBrowserMode.LAUNCH_IF_NOT_ALREADY_LAUNCHED) && ((alphaId == null) || TextUtils.isEmpty(alphaId.text))) {
                // don't need user confirmation in this case
                // just launch the browser or spawn a new tab
                CatLog.d(this, "Browser mode is: launch if not already launched " + "and user confirmation is not currently needed.\n" + "supressing confirmation dialogue and confirming silently...");
                mStkContext[slotId].launchBrowser = true;
                mStkContext[slotId].mBrowserSettings = mStkContext[slotId].mCurrentCmd.getBrowserSettings();
                sendResponse(RES_ID_CONFIRM, slotId, true);
            } else {
                launchConfirmationDialog(alphaId, slotId);
            }
            break;
        case SET_UP_CALL:
            TextMessage mesg = mStkContext[slotId].mCurrentCmd.getCallSettings().confirmMsg;
            if ((mesg != null) && (mesg.text == null || mesg.text.length() == 0)) {
                mesg.text = getResources().getString(R.string.default_setup_call_msg);
            }
            CatLog.d(this, "SET_UP_CALL mesg.text " + mesg.text);
            launchConfirmationDialog(mesg, slotId);
            break;
        case PLAY_TONE:
            handlePlayTone(slotId);
            break;
        case OPEN_CHANNEL:
            launchOpenChannelDialog(slotId);
            break;
        case CLOSE_CHANNEL:
        case RECEIVE_DATA:
        case SEND_DATA:
            TextMessage m = mStkContext[slotId].mCurrentCmd.geTextMessage();
            if ((m != null) && (m.text == null)) {
                switch(cmdMsg.getCmdType()) {
                    case CLOSE_CHANNEL:
                        m.text = getResources().getString(R.string.default_close_channel_msg);
                        break;
                    case RECEIVE_DATA:
                        m.text = getResources().getString(R.string.default_receive_data_msg);
                        break;
                    case SEND_DATA:
                        m.text = getResources().getString(R.string.default_send_data_msg);
                        break;
                }
            }
            /*
             * Display indication in the form of a toast to the user if required.
             */
            launchEventMessage(slotId);
            break;
        case SET_UP_EVENT_LIST:
            mStkContext[slotId].mSetupEventListSettings = mStkContext[slotId].mCurrentCmd.getSetEventList();
            mStkContext[slotId].mCurrentSetupEventCmd = mStkContext[slotId].mCurrentCmd;
            mStkContext[slotId].mCurrentCmd = mStkContext[slotId].mMainCmd;
            if (isScreenIdle()) {
                CatLog.d(this, " Check if IDLE_SCREEN_AVAILABLE_EVENT is present in List");
                checkForSetupEvent(IDLE_SCREEN_AVAILABLE_EVENT, null, slotId);
            }
            break;
    }
    if (!waitForUsersResponse) {
        if (mStkContext[slotId].mCmdsQ.size() != 0) {
            callDelayedMsg(slotId);
        } else {
            mStkContext[slotId].mCmdInProgress = false;
        }
    }
}
#end_block

#method_before
private void playTone(boolean showUserInfo, int slotId) {
    // Start playing tone and vibration
    ToneSettings settings = mStkContext[slotId].mCurrentCmd.getToneSettings();
    mVibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE);
    mTonePlayer = new TonePlayer();
    mTonePlayer.play(settings.tone);
    int timeout = StkApp.calculateDurationInMilis(settings.duration);
    if (timeout == 0) {
        timeout = StkApp.TONE_DFEAULT_TIMEOUT;
    }
    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = OP_STOP_TONE;
    msg.arg2 = slotId;
    msg.obj = (Integer) (showUserInfo ? 1 : 0);
    msg.what = STOP_TONE_WHAT;
    mServiceHandler.sendMessageDelayed(msg, timeout);
    if (settings.vibrate) {
        mVibrator.vibrate(timeout);
    }
    // Start Tone dialog Activity to show user the information.
    if (showUserInfo) {
        Intent newIntent = new Intent(sInstance, ToneDialog.class);
        String uriString = STK_TONE_URI + slotId;
        Uri uriData = Uri.parse(uriString);
        newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_NO_HISTORY | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS | getFlagActivityNoUserAction(InitiatedByUserAction.unknown, slotId));
        newIntent.putExtra("TEXT", mStkContext[slotId].mCurrentCmd.geTextMessage());
        newIntent.putExtra(SLOT_ID, slotId);
        newIntent.setData(uriData);
        startActivity(newIntent);
    }
}
#method_after
private void playTone(boolean showUserInfo, int slotId) {
    // Start playing tone and vibration
    ToneSettings settings = mStkContext[slotId].mCurrentCmd.getToneSettings();
    if (null == settings) {
        CatLog.d(this, "null settings, not playing tone.");
        return;
    }
    mVibrator = (Vibrator) getSystemService(VIBRATOR_SERVICE);
    mTonePlayer = new TonePlayer();
    mTonePlayer.play(settings.tone);
    int timeout = StkApp.calculateDurationInMilis(settings.duration);
    if (timeout == 0) {
        timeout = StkApp.TONE_DEFAULT_TIMEOUT;
    }
    Message msg = mServiceHandler.obtainMessage();
    msg.arg1 = OP_STOP_TONE;
    msg.arg2 = slotId;
    msg.obj = (Integer) (showUserInfo ? 1 : 0);
    msg.what = STOP_TONE_WHAT;
    mServiceHandler.sendMessageDelayed(msg, timeout);
    if (settings.vibrate) {
        mVibrator.vibrate(timeout);
    }
    // Start Tone dialog Activity to show user the information.
    if (showUserInfo) {
        Intent newIntent = new Intent(sInstance, ToneDialog.class);
        String uriString = STK_TONE_URI + slotId;
        Uri uriData = Uri.parse(uriString);
        newIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_NO_HISTORY | Intent.FLAG_ACTIVITY_SINGLE_TOP | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS | getFlagActivityNoUserAction(InitiatedByUserAction.unknown, slotId));
        newIntent.putExtra("TEXT", mStkContext[slotId].mCurrentCmd.geTextMessage());
        newIntent.putExtra(SLOT_ID, slotId);
        newIntent.setData(uriData);
        startActivity(newIntent);
    }
}
#end_block

#method_before
public List<String> getSubsetAids() {
    final ArrayList<String> subsetAids = new ArrayList<String>();
    for (AidGroup group : getAidGroups()) {
        for (String aid : group.aids) {
            if (aid.endsWith("@")) {
                subsetAids.add(aid);
            }
        }
    }
    return subsetAids;
}
#method_after
public List<String> getSubsetAids() {
    final ArrayList<String> subsetAids = new ArrayList<String>();
    for (AidGroup group : getAidGroups()) {
        for (String aid : group.aids) {
            if (aid.endsWith("#")) {
                subsetAids.add(aid);
            }
        }
    }
    return subsetAids;
}
#end_block

#method_before
public static boolean isValidAid(String aid) {
    if (aid == null)
        return false;
    // If a prefix/subset AID, the total length must be odd (even # of AID chars + '*')
    if ((aid.endsWith("*") || aid.endsWith("@")) && ((aid.length() % 2) == 0)) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    // If not a prefix/subset AID, the total length must be even (even # of AID chars)
    if ((!(aid.endsWith("*") || aid.endsWith("@"))) && ((aid.length() % 2) != 0)) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    // Verify hex characters
    if (!aid.matches("[0-9A-Fa-f]{10,32}\\*?\\@?")) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    return true;
}
#method_after
public static boolean isValidAid(String aid) {
    if (aid == null)
        return false;
    // If a prefix/subset AID, the total length must be odd (even # of AID chars + '*')
    if ((aid.endsWith("*") || aid.endsWith("#")) && ((aid.length() % 2) == 0)) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    // If not a prefix/subset AID, the total length must be even (even # of AID chars)
    if ((!(aid.endsWith("*") || aid.endsWith("#"))) && ((aid.length() % 2) != 0)) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    // Verify hex characters
    if (!aid.matches("[0-9A-Fa-f]{10,32}\\*?\\#?")) {
        Log.e(TAG, "AID " + aid + " is not a valid AID.");
        return false;
    }
    return true;
}
#end_block

#method_before
public void connect(boolean validated) {
    assertEquals("MockNetworkAgents can only be connected once", mNetworkInfo.getDetailedState(), DetailedState.IDLE);
    assertFalse(mNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));
    NetworkCallback callback = null;
    final ConditionVariable validatedCv = new ConditionVariable();
    if (validated) {
        mWrappedNetworkMonitor.gen204ProbeResult = 204;
        NetworkRequest request = new NetworkRequest.Builder().addTransportType(mNetworkCapabilities.getTransportTypes()[0]).build();
        callback = new NetworkCallback() {

            public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                if (network.equals(getNetwork()) && networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED)) {
                    validatedCv.open();
                }
            }
        };
        mCm.registerNetworkCallback(request, callback);
    }
    addCapability(NET_CAPABILITY_INTERNET);
    connectWithoutInternet();
    if (validated) {
        // Wait for network to validate.
        waitFor(validatedCv);
        mWrappedNetworkMonitor.gen204ProbeResult = 500;
    }
    if (callback != null)
        mCm.unregisterNetworkCallback(callback);
}
#method_after
public void connect(boolean validated) {
    connect(validated, true);
}
#end_block

#method_before
public void connect(boolean validated) {
    assertEquals("MockNetworkAgents can only be connected once", mNetworkInfo.getDetailedState(), DetailedState.IDLE);
    assertFalse(mNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));
    NetworkCallback callback = null;
    final ConditionVariable validatedCv = new ConditionVariable();
    if (validated) {
        mWrappedNetworkMonitor.gen204ProbeResult = 204;
        NetworkRequest request = new NetworkRequest.Builder().addTransportType(mNetworkCapabilities.getTransportTypes()[0]).build();
        callback = new NetworkCallback() {

            public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                if (network.equals(getNetwork()) && networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED)) {
                    validatedCv.open();
                }
            }
        };
        mCm.registerNetworkCallback(request, callback);
    }
    addCapability(NET_CAPABILITY_INTERNET);
    connectWithoutInternet();
    if (validated) {
        // Wait for network to validate.
        waitFor(validatedCv);
        mWrappedNetworkMonitor.gen204ProbeResult = 500;
    }
    if (callback != null)
        mCm.unregisterNetworkCallback(callback);
}
#method_after
public void connect(boolean validated, boolean hasInternet) {
    assertEquals("MockNetworkAgents can only be connected once", mNetworkInfo.getDetailedState(), DetailedState.IDLE);
    assertFalse(mNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));
    NetworkCallback callback = null;
    final ConditionVariable validatedCv = new ConditionVariable();
    if (validated) {
        mWrappedNetworkMonitor.gen204ProbeResult = 204;
        NetworkRequest request = new NetworkRequest.Builder().addTransportType(mNetworkCapabilities.getTransportTypes()[0]).build();
        callback = new NetworkCallback() {

            public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                if (network.equals(getNetwork()) && networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED)) {
                    validatedCv.open();
                }
            }
        };
        mCm.registerNetworkCallback(request, callback);
    }
    if (hasInternet) {
        addCapability(NET_CAPABILITY_INTERNET);
    }
    connectWithoutInternet();
    if (validated) {
        // Wait for network to validate.
        waitFor(validatedCv);
        mWrappedNetworkMonitor.gen204ProbeResult = 500;
    }
    if (callback != null)
        mCm.unregisterNetworkCallback(callback);
}
#end_block

#method_before
@SmallTest
public void testNoMutableNetworkRequests() throws Exception {
    PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent("a"), 0);
    NetworkRequest request1 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    NetworkRequest request2 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    Class<IllegalArgumentException> expected = IllegalArgumentException.class;
    assertException(() -> {
        mCm.requestNetwork(request1, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request1, pendingIntent);
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, pendingIntent);
    }, expected);
}
#method_after
@SmallTest
public void testNoMutableNetworkRequests() throws Exception {
    PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent("a"), 0);
    NetworkRequest request1 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    NetworkRequest request2 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    Class<IllegalArgumentException> expected = IllegalArgumentException.class;
    assertException(() -> {
        mCm.requestNetwork(request1, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request1, pendingIntent);
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, pendingIntent);
    }, expected);
}
#end_block

#method_before
@SmallTest
public void testNetworkInfoOfTypeNone() {
    ConditionVariable broadcastCV = waitForConnectivityBroadcasts(1);
    verifyNoNetwork();
    MockNetworkAgent lowpanNetwork = new MockNetworkAgent(TRANSPORT_LOWPAN);
    assertNull(mCm.getActiveNetworkInfo());
    // Bring up lowpan.
    lowpanNetwork.connect(true);
    waitForIdle();
    verifyActiveNetwork(TRANSPORT_LOWPAN);
    assertLength(1, mCm.getAllNetworks());
    NetworkInfo info = mCm.getActiveNetworkInfo();
    Network network = mCm.getActiveNetwork();
    NetworkCapabilities capabilities = mCm.getNetworkCapabilities(network);
    assertNotNull(info);
    assertNotNull(network);
    assertNotNull(capabilities);
    assertEquals(TYPE_NONE, info.getType());
    assertTrue(capabilities.hasTransport(TRANSPORT_LOWPAN));
    // Disconnect lowpan.
    lowpanNetwork.disconnect();
    waitForIdle();
    verifyNoNetwork();
    if (broadcastCV.block(10)) {
        fail("expected no broadcast, but got CONNECTIVITY_ACTION broadcast");
    }
}
#method_after
@SmallTest
public void testNetworkInfoOfTypeNone() {
    ConditionVariable broadcastCV = waitForConnectivityBroadcasts(1);
    verifyNoNetwork();
    MockNetworkAgent lowpanNetwork = new MockNetworkAgent(TRANSPORT_LOWPAN);
    assertNull(mCm.getActiveNetworkInfo());
    Network[] allNetworks = mCm.getAllNetworks();
    assertLength(1, allNetworks);
    Network network = allNetworks[0];
    NetworkCapabilities capabilities = mCm.getNetworkCapabilities(network);
    assertTrue(capabilities.hasTransport(TRANSPORT_LOWPAN));
    final NetworkRequest request = new NetworkRequest.Builder().addTransportType(TRANSPORT_LOWPAN).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    // Bring up lowpan.
    lowpanNetwork.connect(false, false);
    callback.expectAvailableCallbacks(lowpanNetwork);
    assertNull(mCm.getActiveNetworkInfo());
    assertNull(mCm.getActiveNetwork());
    // TODO: getAllNetworkInfo is dirty and returns a non-empty array rght from the start
    // of this test. Fix it and uncomment the assert below.
    // assertEmpty(mCm.getAllNetworkInfo());
    // Disconnect lowpan.
    lowpanNetwork.disconnect();
    callback.expectCallback(CallbackState.LOST, lowpanNetwork);
    mCm.unregisterNetworkCallback(callback);
    verifyNoNetwork();
    if (broadcastCV.block(10)) {
        fail("expected no broadcast, but got CONNECTIVITY_ACTION broadcast");
    }
}
#end_block

#method_before
@SmallTest
public void testDeprecatedAndUnsupportedOperations() throws Exception {
    final int TYPE_NONE = ConnectivityManager.TYPE_NONE;
    assertNull(mCm.getNetworkInfo(TYPE_NONE));
    assertNull(mCm.getNetworkForType(TYPE_NONE));
    assertNull(mCm.getLinkProperties(TYPE_NONE));
    assertFalse(mCm.isNetworkSupported(TYPE_NONE));
    assertException(() -> {
        mCm.networkCapabilitiesForType(TYPE_NONE);
    }, IllegalArgumentException.class);
    Class<UnsupportedOperationException> unsupported = UnsupportedOperationException.class;
    assertException(() -> {
        mCm.startUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.stopUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.requestRouteToHostAddress(TYPE_NONE, null);
    }, unsupported);
}
#method_after
@SmallTest
public void testDeprecatedAndUnsupportedOperations() throws Exception {
    final int TYPE_NONE = ConnectivityManager.TYPE_NONE;
    assertNull(mCm.getNetworkInfo(TYPE_NONE));
    assertNull(mCm.getNetworkForType(TYPE_NONE));
    assertNull(mCm.getLinkProperties(TYPE_NONE));
    assertFalse(mCm.isNetworkSupported(TYPE_NONE));
    assertException(() -> {
        mCm.networkCapabilitiesForType(TYPE_NONE);
    }, IllegalArgumentException.class);
    Class<UnsupportedOperationException> unsupported = UnsupportedOperationException.class;
    assertException(() -> {
        mCm.startUsingNetworkFeature(TYPE_WIFI, "");
    }, unsupported);
    assertException(() -> {
        mCm.stopUsingNetworkFeature(TYPE_WIFI, "");
    }, unsupported);
    // TODO: let test context have configuration application target sdk version
    // and test that pre-M requesting for TYPE_NONE sends back APN_REQUEST_FAILED
    assertException(() -> {
        mCm.startUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.stopUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.requestRouteToHostAddress(TYPE_NONE, null);
    }, unsupported);
}
#end_block

#method_before
public void connect(boolean validated) {
    assertEquals("MockNetworkAgents can only be connected once", mNetworkInfo.getDetailedState(), DetailedState.IDLE);
    assertFalse(mNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));
    NetworkCallback callback = null;
    final ConditionVariable validatedCv = new ConditionVariable();
    if (validated) {
        mWrappedNetworkMonitor.gen204ProbeResult = 204;
        NetworkRequest request = new NetworkRequest.Builder().addTransportType(mNetworkCapabilities.getTransportTypes()[0]).build();
        callback = new NetworkCallback() {

            public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                if (network.equals(getNetwork()) && networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED)) {
                    validatedCv.open();
                }
            }
        };
        mCm.registerNetworkCallback(request, callback);
    }
    addCapability(NET_CAPABILITY_INTERNET);
    connectWithoutInternet();
    if (validated) {
        // Wait for network to validate.
        waitFor(validatedCv);
        mWrappedNetworkMonitor.gen204ProbeResult = 500;
    }
    if (callback != null)
        mCm.unregisterNetworkCallback(callback);
}
#method_after
public void connect(boolean validated) {
    connect(validated, true);
}
#end_block

#method_before
public void connect(boolean validated) {
    assertEquals("MockNetworkAgents can only be connected once", mNetworkInfo.getDetailedState(), DetailedState.IDLE);
    assertFalse(mNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));
    NetworkCallback callback = null;
    final ConditionVariable validatedCv = new ConditionVariable();
    if (validated) {
        mWrappedNetworkMonitor.gen204ProbeResult = 204;
        NetworkRequest request = new NetworkRequest.Builder().addTransportType(mNetworkCapabilities.getTransportTypes()[0]).build();
        callback = new NetworkCallback() {

            public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                if (network.equals(getNetwork()) && networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED)) {
                    validatedCv.open();
                }
            }
        };
        mCm.registerNetworkCallback(request, callback);
    }
    addCapability(NET_CAPABILITY_INTERNET);
    connectWithoutInternet();
    if (validated) {
        // Wait for network to validate.
        waitFor(validatedCv);
        mWrappedNetworkMonitor.gen204ProbeResult = 500;
    }
    if (callback != null)
        mCm.unregisterNetworkCallback(callback);
}
#method_after
public void connect(boolean validated, boolean hasInternet) {
    assertEquals("MockNetworkAgents can only be connected once", mNetworkInfo.getDetailedState(), DetailedState.IDLE);
    assertFalse(mNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));
    NetworkCallback callback = null;
    final ConditionVariable validatedCv = new ConditionVariable();
    if (validated) {
        mWrappedNetworkMonitor.gen204ProbeResult = 204;
        NetworkRequest request = new NetworkRequest.Builder().addTransportType(mNetworkCapabilities.getTransportTypes()[0]).build();
        callback = new NetworkCallback() {

            public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                if (network.equals(getNetwork()) && networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED)) {
                    validatedCv.open();
                }
            }
        };
        mCm.registerNetworkCallback(request, callback);
    }
    if (hasInternet) {
        addCapability(NET_CAPABILITY_INTERNET);
    }
    connectWithoutInternet();
    if (validated) {
        // Wait for network to validate.
        waitFor(validatedCv);
        mWrappedNetworkMonitor.gen204ProbeResult = 500;
    }
    if (callback != null)
        mCm.unregisterNetworkCallback(callback);
}
#end_block

#method_before
@SmallTest
public void testNoMutableNetworkRequests() throws Exception {
    PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent("a"), 0);
    NetworkRequest request1 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    NetworkRequest request2 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    Class<IllegalArgumentException> expected = IllegalArgumentException.class;
    assertException(() -> {
        mCm.requestNetwork(request1, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request1, pendingIntent);
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, pendingIntent);
    }, expected);
}
#method_after
@SmallTest
public void testNoMutableNetworkRequests() throws Exception {
    PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent("a"), 0);
    NetworkRequest request1 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    NetworkRequest request2 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    Class<IllegalArgumentException> expected = IllegalArgumentException.class;
    assertException(() -> {
        mCm.requestNetwork(request1, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request1, pendingIntent);
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, pendingIntent);
    }, expected);
}
#end_block

#method_before
@SmallTest
public void testNetworkInfoOfTypeNone() {
    ConditionVariable broadcastCV = waitForConnectivityBroadcasts(1);
    verifyNoNetwork();
    MockNetworkAgent lowpanNetwork = new MockNetworkAgent(TRANSPORT_LOWPAN);
    assertNull(mCm.getActiveNetworkInfo());
    // Bring up lowpan.
    lowpanNetwork.connect(true);
    waitForIdle();
    verifyActiveNetwork(TRANSPORT_LOWPAN);
    assertLength(1, mCm.getAllNetworks());
    NetworkInfo info = mCm.getActiveNetworkInfo();
    Network network = mCm.getActiveNetwork();
    NetworkCapabilities capabilities = mCm.getNetworkCapabilities(network);
    assertNotNull(info);
    assertNotNull(network);
    assertNotNull(capabilities);
    assertEquals(TYPE_NONE, info.getType());
    assertTrue(capabilities.hasTransport(TRANSPORT_LOWPAN));
    // Disconnect lowpan.
    lowpanNetwork.disconnect();
    waitForIdle();
    verifyNoNetwork();
    if (broadcastCV.block(10)) {
        fail("expected no broadcast, but got CONNECTIVITY_ACTION broadcast");
    }
}
#method_after
@SmallTest
public void testNetworkInfoOfTypeNone() {
    ConditionVariable broadcastCV = waitForConnectivityBroadcasts(1);
    verifyNoNetwork();
    MockNetworkAgent lowpanNetwork = new MockNetworkAgent(TRANSPORT_LOWPAN);
    assertNull(mCm.getActiveNetworkInfo());
    Network[] allNetworks = mCm.getAllNetworks();
    assertLength(1, allNetworks);
    Network network = allNetworks[0];
    NetworkCapabilities capabilities = mCm.getNetworkCapabilities(network);
    assertTrue(capabilities.hasTransport(TRANSPORT_LOWPAN));
    final NetworkRequest request = new NetworkRequest.Builder().addTransportType(TRANSPORT_LOWPAN).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    // Bring up lowpan.
    lowpanNetwork.connect(false, false);
    callback.expectAvailableCallbacks(lowpanNetwork);
    assertNull(mCm.getActiveNetworkInfo());
    assertNull(mCm.getActiveNetwork());
    // TODO: getAllNetworkInfo is dirty and returns a non-empty array rght from the start
    // of this test. Fix it and uncomment the assert below.
    // assertEmpty(mCm.getAllNetworkInfo());
    // Disconnect lowpan.
    lowpanNetwork.disconnect();
    callback.expectCallback(CallbackState.LOST, lowpanNetwork);
    mCm.unregisterNetworkCallback(callback);
    verifyNoNetwork();
    if (broadcastCV.block(10)) {
        fail("expected no broadcast, but got CONNECTIVITY_ACTION broadcast");
    }
}
#end_block

#method_before
@SmallTest
public void testDeprecatedAndUnsupportedOperations() throws Exception {
    final int TYPE_NONE = ConnectivityManager.TYPE_NONE;
    assertNull(mCm.getNetworkInfo(TYPE_NONE));
    assertNull(mCm.getNetworkForType(TYPE_NONE));
    assertNull(mCm.getLinkProperties(TYPE_NONE));
    assertFalse(mCm.isNetworkSupported(TYPE_NONE));
    assertException(() -> {
        mCm.networkCapabilitiesForType(TYPE_NONE);
    }, IllegalArgumentException.class);
    Class<UnsupportedOperationException> unsupported = UnsupportedOperationException.class;
    assertException(() -> {
        mCm.startUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.stopUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.requestRouteToHostAddress(TYPE_NONE, null);
    }, unsupported);
}
#method_after
@SmallTest
public void testDeprecatedAndUnsupportedOperations() throws Exception {
    final int TYPE_NONE = ConnectivityManager.TYPE_NONE;
    assertNull(mCm.getNetworkInfo(TYPE_NONE));
    assertNull(mCm.getNetworkForType(TYPE_NONE));
    assertNull(mCm.getLinkProperties(TYPE_NONE));
    assertFalse(mCm.isNetworkSupported(TYPE_NONE));
    assertException(() -> {
        mCm.networkCapabilitiesForType(TYPE_NONE);
    }, IllegalArgumentException.class);
    Class<UnsupportedOperationException> unsupported = UnsupportedOperationException.class;
    assertException(() -> {
        mCm.startUsingNetworkFeature(TYPE_WIFI, "");
    }, unsupported);
    assertException(() -> {
        mCm.stopUsingNetworkFeature(TYPE_WIFI, "");
    }, unsupported);
    // TODO: let test context have configuration application target sdk version
    // and test that pre-M requesting for TYPE_NONE sends back APN_REQUEST_FAILED
    assertException(() -> {
        mCm.startUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.stopUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.requestRouteToHostAddress(TYPE_NONE, null);
    }, unsupported);
}
#end_block

#method_before
public void connect(boolean validated) {
    assertEquals("MockNetworkAgents can only be connected once", mNetworkInfo.getDetailedState(), DetailedState.IDLE);
    assertFalse(mNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));
    NetworkCallback callback = null;
    final ConditionVariable validatedCv = new ConditionVariable();
    if (validated) {
        mWrappedNetworkMonitor.gen204ProbeResult = 204;
        NetworkRequest request = new NetworkRequest.Builder().addTransportType(mNetworkCapabilities.getTransportTypes()[0]).build();
        callback = new NetworkCallback() {

            public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                if (network.equals(getNetwork()) && networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED)) {
                    validatedCv.open();
                }
            }
        };
        mCm.registerNetworkCallback(request, callback);
    }
    addCapability(NET_CAPABILITY_INTERNET);
    connectWithoutInternet();
    if (validated) {
        // Wait for network to validate.
        waitFor(validatedCv);
        mWrappedNetworkMonitor.gen204ProbeResult = 500;
    }
    if (callback != null)
        mCm.unregisterNetworkCallback(callback);
}
#method_after
public void connect(boolean validated) {
    connect(validated, true);
}
#end_block

#method_before
public void connect(boolean validated) {
    assertEquals("MockNetworkAgents can only be connected once", mNetworkInfo.getDetailedState(), DetailedState.IDLE);
    assertFalse(mNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));
    NetworkCallback callback = null;
    final ConditionVariable validatedCv = new ConditionVariable();
    if (validated) {
        mWrappedNetworkMonitor.gen204ProbeResult = 204;
        NetworkRequest request = new NetworkRequest.Builder().addTransportType(mNetworkCapabilities.getTransportTypes()[0]).build();
        callback = new NetworkCallback() {

            public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                if (network.equals(getNetwork()) && networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED)) {
                    validatedCv.open();
                }
            }
        };
        mCm.registerNetworkCallback(request, callback);
    }
    addCapability(NET_CAPABILITY_INTERNET);
    connectWithoutInternet();
    if (validated) {
        // Wait for network to validate.
        waitFor(validatedCv);
        mWrappedNetworkMonitor.gen204ProbeResult = 500;
    }
    if (callback != null)
        mCm.unregisterNetworkCallback(callback);
}
#method_after
public void connect(boolean validated, boolean hasInternet) {
    assertEquals("MockNetworkAgents can only be connected once", mNetworkInfo.getDetailedState(), DetailedState.IDLE);
    assertFalse(mNetworkCapabilities.hasCapability(NET_CAPABILITY_INTERNET));
    NetworkCallback callback = null;
    final ConditionVariable validatedCv = new ConditionVariable();
    if (validated) {
        mWrappedNetworkMonitor.gen204ProbeResult = 204;
        NetworkRequest request = new NetworkRequest.Builder().addTransportType(mNetworkCapabilities.getTransportTypes()[0]).build();
        callback = new NetworkCallback() {

            public void onCapabilitiesChanged(Network network, NetworkCapabilities networkCapabilities) {
                if (network.equals(getNetwork()) && networkCapabilities.hasCapability(NET_CAPABILITY_VALIDATED)) {
                    validatedCv.open();
                }
            }
        };
        mCm.registerNetworkCallback(request, callback);
    }
    if (hasInternet) {
        addCapability(NET_CAPABILITY_INTERNET);
    }
    connectWithoutInternet();
    if (validated) {
        // Wait for network to validate.
        waitFor(validatedCv);
        mWrappedNetworkMonitor.gen204ProbeResult = 500;
    }
    if (callback != null)
        mCm.unregisterNetworkCallback(callback);
}
#end_block

#method_before
static private void waitFor(ConditionVariable conditionVariable) {
    assertTrue(conditionVariable.block(TIMEOUT_MS));
}
#method_after
static private void waitFor(ConditionVariable conditionVariable) {
    if (conditionVariable.block(TIMEOUT_MS)) {
        return;
    }
    fail("ConditionVariable was blocked for more than " + TIMEOUT_MS + "ms");
}
#end_block

#method_before
private static int transportToLegacyType(int transport) {
    switch(transport) {
        case TRANSPORT_ETHERNET:
            return TYPE_ETHERNET;
        case TRANSPORT_WIFI:
            return TYPE_WIFI;
        case TRANSPORT_CELLULAR:
            return TYPE_MOBILE;
        default:
            throw new IllegalStateException("Unknown transport " + transport);
    }
}
#method_after
private static int transportToLegacyType(int transport) {
    switch(transport) {
        case TRANSPORT_ETHERNET:
            return TYPE_ETHERNET;
        case TRANSPORT_WIFI:
            return TYPE_WIFI;
        case TRANSPORT_CELLULAR:
            return TYPE_MOBILE;
        default:
            return TYPE_NONE;
    }
}
#end_block

#method_before
private void verifyActiveNetwork(int transport) {
    // Test getActiveNetworkInfo()
    assertNotNull(mCm.getActiveNetworkInfo());
    assertEquals(transportToLegacyType(transport), mCm.getActiveNetworkInfo().getType());
    // Test getActiveNetwork()
    assertNotNull(mCm.getActiveNetwork());
    assertEquals(mCm.getActiveNetwork(), mCm.getActiveNetworkForUid(Process.myUid()));
    switch(transport) {
        case TRANSPORT_WIFI:
            assertEquals(mCm.getActiveNetwork(), mWiFiNetworkAgent.getNetwork());
            break;
        case TRANSPORT_CELLULAR:
            assertEquals(mCm.getActiveNetwork(), mCellNetworkAgent.getNetwork());
            break;
        default:
            throw new IllegalStateException("Unknown transport" + transport);
    }
    // Test getNetworkInfo(Network)
    assertNotNull(mCm.getNetworkInfo(mCm.getActiveNetwork()));
    assertEquals(transportToLegacyType(transport), mCm.getNetworkInfo(mCm.getActiveNetwork()).getType());
    // Test getNetworkCapabilities(Network)
    assertNotNull(mCm.getNetworkCapabilities(mCm.getActiveNetwork()));
    assertTrue(mCm.getNetworkCapabilities(mCm.getActiveNetwork()).hasTransport(transport));
}
#method_after
private void verifyActiveNetwork(int transport) {
    // Test getActiveNetworkInfo()
    assertNotNull(mCm.getActiveNetworkInfo());
    assertEquals(transportToLegacyType(transport), mCm.getActiveNetworkInfo().getType());
    // Test getActiveNetwork()
    assertNotNull(mCm.getActiveNetwork());
    assertEquals(mCm.getActiveNetwork(), mCm.getActiveNetworkForUid(Process.myUid()));
    if (!NetworkCapabilities.isValidTransport(transport)) {
        throw new IllegalStateException("Unknown transport " + transport);
    }
    switch(transport) {
        case TRANSPORT_WIFI:
            assertEquals(mCm.getActiveNetwork(), mWiFiNetworkAgent.getNetwork());
            break;
        case TRANSPORT_CELLULAR:
            assertEquals(mCm.getActiveNetwork(), mCellNetworkAgent.getNetwork());
            break;
        default:
            break;
    }
    // Test getNetworkInfo(Network)
    assertNotNull(mCm.getNetworkInfo(mCm.getActiveNetwork()));
    assertEquals(transportToLegacyType(transport), mCm.getNetworkInfo(mCm.getActiveNetwork()).getType());
    // Test getNetworkCapabilities(Network)
    assertNotNull(mCm.getNetworkCapabilities(mCm.getActiveNetwork()));
    assertTrue(mCm.getNetworkCapabilities(mCm.getActiveNetwork()).hasTransport(transport));
}
#end_block

#method_before
@SmallTest
public void testNoMutableNetworkRequests() throws Exception {
    PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent("a"), 0);
    NetworkRequest request1 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    NetworkRequest request2 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    Class<IllegalArgumentException> expected = IllegalArgumentException.class;
    assertException(() -> {
        mCm.requestNetwork(request1, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request1, pendingIntent);
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, pendingIntent);
    }, expected);
}
#method_after
@SmallTest
public void testNoMutableNetworkRequests() throws Exception {
    PendingIntent pendingIntent = PendingIntent.getBroadcast(mContext, 0, new Intent("a"), 0);
    NetworkRequest request1 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_VALIDATED).build();
    NetworkRequest request2 = new NetworkRequest.Builder().addCapability(NET_CAPABILITY_CAPTIVE_PORTAL).build();
    Class<IllegalArgumentException> expected = IllegalArgumentException.class;
    assertException(() -> {
        mCm.requestNetwork(request1, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request1, pendingIntent);
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, new NetworkCallback());
    }, expected);
    assertException(() -> {
        mCm.requestNetwork(request2, pendingIntent);
    }, expected);
}
#end_block

#method_before
@SmallTest
public void testNetworkInfoOfTypeNone() {
    MockNetworkAgent net = new MockNetworkAgent(TRANSPORT_LOWPAN, ConnectivityManager.TYPE_NONE);
    verifyNoNetwork();
    // Test bringing up validated cellular.
    ConditionVariable cv = waitForConnectivityBroadcasts(1);
    net.connect(true);
    // should timeout
    waitFor(cv);
    verifyActiveNetwork(TRANSPORT_LOWPAN);
    assertEquals(0, mCm.getAllNetworks().length);
    assertNull(mCm.getActiveNetworkInfo());
    assertNull(mCm.getActiveNetwork());
    verifyNoNetwork();
    // Test cellular linger timeout.
    waitFor(mCellNetworkAgent.getDisconnectedCV());
    waitForIdle();
    // Test disconnect.
    cv = waitForConnectivityBroadcasts(1);
    net.disconnect();
    waitFor(cv);
    verifyNoNetwork();
}
#method_after
@SmallTest
public void testNetworkInfoOfTypeNone() {
    ConditionVariable broadcastCV = waitForConnectivityBroadcasts(1);
    verifyNoNetwork();
    MockNetworkAgent lowpanNetwork = new MockNetworkAgent(TRANSPORT_LOWPAN);
    assertNull(mCm.getActiveNetworkInfo());
    Network[] allNetworks = mCm.getAllNetworks();
    assertEquals(1, allNetworks.length);
    Network network = allNetworks[0];
    NetworkCapabilities capabilities = mCm.getNetworkCapabilities(network);
    assertTrue(capabilities.hasTransport(TRANSPORT_LOWPAN));
    final NetworkRequest request = new NetworkRequest.Builder().addTransportType(TRANSPORT_LOWPAN).build();
    final TestNetworkCallback callback = new TestNetworkCallback();
    mCm.registerNetworkCallback(request, callback);
    // Bring up lowpan.
    lowpanNetwork.connect(false, false);
    callback.expectAvailableCallbacks(lowpanNetwork);
    assertNull(mCm.getActiveNetworkInfo());
    assertNull(mCm.getActiveNetwork());
    // TODO: getAllNetworkInfo is dirty and returns a non-empty array rght from the start
    // of this test. Fix it and uncomment the assert below.
    // assertEquals(0, mCm.getAllNetworkInfo().length);
    // Disconnect lowpan.
    lowpanNetwork.disconnect();
    callback.expectCallback(CallbackState.LOST, lowpanNetwork);
    mCm.unregisterNetworkCallback(callback);
    verifyNoNetwork();
    if (broadcastCV.block(10)) {
        fail("expected no broadcast, but got CONNECTIVITY_ACTION broadcast");
    }
}
#end_block

#method_before
@SmallTest
public void testDeprecatedAndUnsupportedOperations() throws Exception {
    final int TYPE_NONE = ConnectivityManager.TYPE_NONE;
    assertNull(mCm.getNetworkInfo(TYPE_NONE));
    assertNull(mCm.getNetworkForType(TYPE_NONE));
    assertNull(mCm.getLinkProperties(TYPE_NONE));
    assertFalse(mCm.isNetworkSupported(TYPE_NONE));
    assertException(() -> {
        mCm.networkCapabilitiesForType(TYPE_NONE);
    }, IllegalArgumentException.class);
    Class<UnsupportedOperationException> unsupported = UnsupportedOperationException.class;
    assertException(() -> {
        mCm.startUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.stopUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.requestRouteToHostAddress(TYPE_NONE, null);
    }, unsupported);
}
#method_after
@SmallTest
public void testDeprecatedAndUnsupportedOperations() throws Exception {
    final int TYPE_NONE = ConnectivityManager.TYPE_NONE;
    assertNull(mCm.getNetworkInfo(TYPE_NONE));
    assertNull(mCm.getNetworkForType(TYPE_NONE));
    assertNull(mCm.getLinkProperties(TYPE_NONE));
    assertFalse(mCm.isNetworkSupported(TYPE_NONE));
    assertException(() -> {
        mCm.networkCapabilitiesForType(TYPE_NONE);
    }, IllegalArgumentException.class);
    Class<UnsupportedOperationException> unsupported = UnsupportedOperationException.class;
    assertException(() -> {
        mCm.startUsingNetworkFeature(TYPE_WIFI, "");
    }, unsupported);
    assertException(() -> {
        mCm.stopUsingNetworkFeature(TYPE_WIFI, "");
    }, unsupported);
    // TODO: let test context have configuration application target sdk version
    // and test that pre-M requesting for TYPE_NONE sends back APN_REQUEST_FAILED
    assertException(() -> {
        mCm.startUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.stopUsingNetworkFeature(TYPE_NONE, "");
    }, unsupported);
    assertException(() -> {
        mCm.requestRouteToHostAddress(TYPE_NONE, null);
    }, unsupported);
}
#end_block

#method_before
static private <T> void assertException(Runnable block, Class<T> expected) {
    try {
        block.run();
        fail("Expected exception of type " + expected);
    } catch (Exception got) {
        if (!got.getClass().equals(expected)) {
            fail("Expected exception of type " + expected + " but got " + got);
        }
        return;
    }
}
#method_after
private static <T> void assertException(Runnable block, Class<T> expected) {
    try {
        block.run();
        fail("Expected exception of type " + expected);
    } catch (Exception got) {
        if (!got.getClass().equals(expected)) {
            fail("Expected exception of type " + expected + " but got " + got);
        }
        return;
    }
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
private static boolean isValidTransport(int transportType) {
    return (MIN_TRANSPORT <= transportType) && (transportType <= MAX_TRANSPORT);
}
#method_after
public static boolean isValidTransport(int transportType) {
    return (MIN_TRANSPORT <= transportType) && (transportType <= MAX_TRANSPORT);
}
#end_block

#method_before
public NetworkCapabilities addTransportType(int transportType) {
    if (!isValidTransport(transportType)) {
        throw new IllegalArgumentException("TransportType out of range: " + transportType);
    }
    mTransportTypes |= 1 << transportType;
    // used for exception checking
    setNetworkSpecifier(mNetworkSpecifier);
    return this;
}
#method_after
public NetworkCapabilities addTransportType(int transportType) {
    checkValidTransportType(transportType);
    mTransportTypes |= 1 << transportType;
    // used for exception checking
    setNetworkSpecifier(mNetworkSpecifier);
    return this;
}
#end_block

#method_before
public NetworkCapabilities removeTransportType(int transportType) {
    if (!isValidTransport(transportType)) {
        throw new IllegalArgumentException("TransportType out of range: " + transportType);
    }
    mTransportTypes &= ~(1 << transportType);
    // used for exception checking
    setNetworkSpecifier(mNetworkSpecifier);
    return this;
}
#method_after
public NetworkCapabilities removeTransportType(int transportType) {
    checkValidTransportType(transportType);
    mTransportTypes &= ~(1 << transportType);
    // used for exception checking
    setNetworkSpecifier(mNetworkSpecifier);
    return this;
}
#end_block

#method_before
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        if (DBG) {
            log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
        }
        // disconnect the channel.
        if (nai.networkInfo.isConnected()) {
            nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
        }
        final boolean wasDefault = isDefaultNetwork(nai);
        if (wasDefault) {
            mDefaultInetConditionPublished = 0;
            // Log default network disconnection before required book-keeping.
            // Let rematchAllNetworksAndRequests() below record a new default network event
            // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
            // whose timestamps tell how long it takes to recover a default network.
            logDefaultNetworkEvent(null, nai);
        }
        notifyIfacesChangedForNetworkStats();
        // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
        // by other networks that are already connected. Perhaps that can be done by
        // sending all CALLBACK_LOST messages (for requests, not listens) at the end
        // of rematchAllNetworksAndRequests
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
        mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
        mNetworkAgentInfos.remove(msg.replyTo);
        updateClat(null, nai.linkProperties, nai);
        synchronized (mNetworkForNetId) {
            // Remove the NetworkAgent, but don't mark the netId as
            // available until we've told netd to delete it below.
            mNetworkForNetId.remove(nai.network.netId);
        }
        // Remove all previously satisfied requests.
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest request = nai.requestAt(i);
            NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(request.requestId);
            if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
                mNetworkForRequestId.remove(request.requestId);
                sendUpdatedScoreToFactories(request, 0);
            }
        }
        nai.clearLingerState();
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            removeDataActivityTracking(nai);
            notifyLockdownVpn(nai);
            ensureNetworkTransitionWakelock(nai.name());
        }
        mLegacyTypeTracker.remove(nai, wasDefault);
        rematchAllNetworksAndRequests(null, 0);
        mLingerMonitor.noteDisconnect(nai);
        if (nai.created) {
            // long time.
            try {
                mNetd.removeNetwork(nai.network.netId);
            } catch (Exception e) {
                loge("Exception removing network: " + e);
            }
        }
        synchronized (mNetworkForNetId) {
            mNetIdInUse.delete(nai.network.netId);
        }
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#method_after
private void handleAsyncChannelDisconnected(Message msg) {
    NetworkAgentInfo nai = mNetworkAgentInfos.get(msg.replyTo);
    if (nai != null) {
        if (DBG) {
            log(nai.name() + " got DISCONNECTED, was satisfying " + nai.numNetworkRequests());
        }
        // disconnect the channel.
        if (nai.networkInfo.isConnected()) {
            nai.networkInfo.setDetailedState(NetworkInfo.DetailedState.DISCONNECTED, null, null);
        }
        final boolean wasDefault = isDefaultNetwork(nai);
        if (wasDefault) {
            mDefaultInetConditionPublished = 0;
            // Log default network disconnection before required book-keeping.
            // Let rematchAllNetworksAndRequests() below record a new default network event
            // if there is a fallback. Taken together, the two form a X -> 0, 0 -> Y sequence
            // whose timestamps tell how long it takes to recover a default network.
            logDefaultNetworkEvent(null, nai);
        }
        notifyIfacesChangedForNetworkStats();
        // TODO - we shouldn't send CALLBACK_LOST to requests that can be satisfied
        // by other networks that are already connected. Perhaps that can be done by
        // sending all CALLBACK_LOST messages (for requests, not listens) at the end
        // of rematchAllNetworksAndRequests
        notifyNetworkCallbacks(nai, ConnectivityManager.CALLBACK_LOST);
        mKeepaliveTracker.handleStopAllKeepalives(nai, ConnectivityManager.PacketKeepalive.ERROR_INVALID_NETWORK);
        for (String iface : nai.linkProperties.getAllInterfaceNames()) {
            // Disable wakeup packet monitoring for each interface.
            wakeupModifyInterface(iface, nai.networkCapabilities, false);
        }
        nai.networkMonitor.sendMessage(NetworkMonitor.CMD_NETWORK_DISCONNECTED);
        mNetworkAgentInfos.remove(msg.replyTo);
        updateClat(null, nai.linkProperties, nai);
        synchronized (mNetworkForNetId) {
            // Remove the NetworkAgent, but don't mark the netId as
            // available until we've told netd to delete it below.
            mNetworkForNetId.remove(nai.network.netId);
        }
        // Remove all previously satisfied requests.
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            NetworkRequest request = nai.requestAt(i);
            NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(request.requestId);
            if (currentNetwork != null && currentNetwork.network.netId == nai.network.netId) {
                mNetworkForRequestId.remove(request.requestId);
                sendUpdatedScoreToFactories(request, 0);
            }
        }
        nai.clearLingerState();
        if (nai.isSatisfyingRequest(mDefaultRequest.requestId)) {
            removeDataActivityTracking(nai);
            notifyLockdownVpn(nai);
            ensureNetworkTransitionWakelock(nai.name());
        }
        mLegacyTypeTracker.remove(nai, wasDefault);
        rematchAllNetworksAndRequests(null, 0);
        mLingerMonitor.noteDisconnect(nai);
        if (nai.created) {
            // long time.
            try {
                mNetd.removeNetwork(nai.network.netId);
            } catch (Exception e) {
                loge("Exception removing network: " + e);
            }
        }
        synchronized (mNetworkForNetId) {
            mNetIdInUse.delete(nai.network.netId);
        }
    } else {
        NetworkFactoryInfo nfi = mNetworkFactoryInfos.remove(msg.replyTo);
        if (DBG && nfi != null)
            log("unregisterNetworkFactory for " + nfi.name);
    }
}
#end_block

#method_before
private void updateInterfaces(LinkProperties newLp, LinkProperties oldLp, int netId, NetworkCapabilities caps) {
    CompareResult<String> interfaceDiff = new CompareResult<String>();
    if (oldLp != null) {
        interfaceDiff = oldLp.compareAllInterfaceNames(newLp);
    } else if (newLp != null) {
        interfaceDiff.added = newLp.getAllInterfaceNames();
    }
    for (String iface : interfaceDiff.added) {
        try {
            if (DBG)
                log("Adding iface " + iface + " to network " + netId);
            mNetd.addInterfaceToNetwork(iface, netId);
            wakeupAddInterface(iface, caps);
        } catch (Exception e) {
            loge("Exception adding interface: " + e);
        }
    }
    for (String iface : interfaceDiff.removed) {
        try {
            if (DBG)
                log("Removing iface " + iface + " from network " + netId);
            mNetd.removeInterfaceFromNetwork(iface, netId);
            wakeupDelInterface(iface, caps);
        } catch (Exception e) {
            loge("Exception removing interface: " + e);
        }
    }
}
#method_after
private void updateInterfaces(LinkProperties newLp, LinkProperties oldLp, int netId, NetworkCapabilities caps) {
    CompareResult<String> interfaceDiff = new CompareResult<String>();
    if (oldLp != null) {
        interfaceDiff = oldLp.compareAllInterfaceNames(newLp);
    } else if (newLp != null) {
        interfaceDiff.added = newLp.getAllInterfaceNames();
    }
    for (String iface : interfaceDiff.added) {
        try {
            if (DBG)
                log("Adding iface " + iface + " to network " + netId);
            mNetd.addInterfaceToNetwork(iface, netId);
            wakeupModifyInterface(iface, caps, true);
        } catch (Exception e) {
            loge("Exception adding interface: " + e);
        }
    }
    for (String iface : interfaceDiff.removed) {
        try {
            if (DBG)
                log("Removing iface " + iface + " from network " + netId);
            wakeupModifyInterface(iface, caps, false);
            mNetd.removeInterfaceFromNetwork(iface, netId);
        } catch (Exception e) {
            loge("Exception removing interface: " + e);
        }
    }
}
#end_block

#method_before
private static void verifyLogLines(String[] expected, SharedLog log) {
    final ByteArrayOutputStream ostream = new ByteArrayOutputStream();
    final PrintWriter pw = new PrintWriter(ostream, true);
    log.dump(null, pw, null);
    final String dumpOutput = ostream.toString();
    assertTrue(dumpOutput != null);
    assertTrue(!"".equals(dumpOutput));
    final String[] lines = dumpOutput.split("\n");
    assertEquals(expected.length, lines.length);
    for (int i = 0; i < expected.length; i++) {
        String got = lines[i];
        String want = expected[i];
        assertTrue(String.format("'%s' did not contain '%s'", got, want), got.endsWith(want));
        assertTrue(String.format("'%s' did not contain a HH:MM:SS.xxx timestamp", got), got.replaceFirst(TIMESTAMP_PATTERN, TIMESTAMP).contains(TIMESTAMP));
    }
}
#method_after
private static void verifyLogLines(String[] expected, SharedLog log) {
    final ByteArrayOutputStream ostream = new ByteArrayOutputStream();
    final PrintWriter pw = new PrintWriter(ostream, true);
    log.dump(null, pw, null);
    final String dumpOutput = ostream.toString();
    assertTrue(dumpOutput != null);
    assertTrue(!"".equals(dumpOutput));
    final String[] lines = dumpOutput.split("\n");
    assertEquals(expected.length, lines.length);
    for (int i = 0; i < expected.length; i++) {
        String got = lines[i];
        String want = expected[i];
        assertTrue(String.format("'%s' did not contain '%s'", got, want), got.endsWith(want));
        assertTrue(String.format("'%s' did not contain a %s timestamp", got, TIMESTAMP), got.replaceFirst(TIMESTAMP_PATTERN, TIMESTAMP).contains(TIMESTAMP));
    }
}
#end_block

#method_before
public static void waitForIdleHandler(HandlerThread handlerThread, long timeoutMs) {
    waitForIdleLooper(handlerThread.getLooper(), timeoutMs);
}
#method_after
public static void waitForIdleHandler(HandlerThread handlerThread, long timeoutMs) {
    // TODO: convert to getThreadHandler once it is available on aosp
    waitForIdleLooper(handlerThread.getLooper(), timeoutMs);
}
#end_block

#method_before
public void testSkipOnLargeFiles() throws Exception {
    File largeFile = File.createTempFile("FileInputStreamTest_testSkipOnLargeFiles", "");
    // 1 MiB
    int blockSize = 1024 * 1024;
    // Required space is 3.1 GB: 3GB for file plus 100M headroom.
    final long requiredFreeSpaceBytes = 3172L * blockSize;
    // If system doesn't have enough space free for this test, skip it.
    final StructStatVfs statVfs = Os.statvfs(largeFile.getPath());
    final long freeSpaceAvailableBytes = statVfs.f_bsize * statVfs.f_bavail;
    if (freeSpaceAvailableBytes < requiredFreeSpaceBytes) {
        return;
    }
    try {
        long numBlocks = 3 * 1024;
        // 3 GiB
        long fileSize = numBlocks * blockSize;
        boolean successfullyAllocated = false;
        // fallocate is much faster than writing the file (<<1sec rather than 21sec on Nexus 6P)
        try {
            int resultCode = new ProcessBuilder().command("fallocate", "-l", "3G", largeFile.getPath()).start().waitFor();
            successfullyAllocated = (resultCode == 0);
        } catch (IOException e) {
        // fallocate is not available
        }
        if (!successfullyAllocated) {
            // fall back to writing the file
            try (FileOutputStream fos = new FileOutputStream(largeFile)) {
                byte[] buffer = new byte[blockSize];
                for (int i = 0; i < numBlocks; i++) {
                    fos.write(buffer);
                }
            }
        }
        assertEquals(fileSize, largeFile.length());
        try (FileInputStream fis = new FileInputStream(largeFile)) {
            long lastByte = fileSize - 1;
            assertEquals(0, Libcore.os.lseek(fis.getFD(), 0, OsConstants.SEEK_CUR));
            assertEquals(lastByte, fis.skip(lastByte));
        }
    } finally {
        // Proactively cleanup - it's a pretty large file.
        assertTrue(largeFile.delete());
    }
}
#method_after
public void testSkipOnLargeFiles() throws Exception {
    File largeFile = File.createTempFile("FileInputStreamTest_testSkipOnLargeFiles", "");
    // Required space is 3.1 GB: 3GB for file plus 100M headroom.
    final long requiredFreeSpaceBytes = 3172L * 1024 * 1024;
    // 3 GiB
    long fileSize = 3 * 1024L * 1024 * 1024;
    // If system doesn't have enough space free for this test, skip it.
    final StructStatVfs statVfs = Os.statvfs(largeFile.getPath());
    final long freeSpaceAvailableBytes = statVfs.f_bsize * statVfs.f_bavail;
    if (freeSpaceAvailableBytes < requiredFreeSpaceBytes) {
        return;
    }
    try {
        allocateEmptyFile(largeFile, fileSize);
        assertEquals(fileSize, largeFile.length());
        try (FileInputStream fis = new FileInputStream(largeFile)) {
            long lastByte = fileSize - 1;
            assertEquals(0, Libcore.os.lseek(fis.getFD(), 0, OsConstants.SEEK_CUR));
            assertEquals(lastByte, fis.skip(lastByte));
        }
    } finally {
        // Proactively cleanup - it's a pretty large file.
        assertTrue(largeFile.delete());
    }
}
#end_block

#method_before
private void startOffloadController() {
    mOffloadController.start();
    updateOffloadExemptPrefixes(null);
}
#method_after
private void startOffloadController() {
    mOffloadController.start();
    mOffloadController.updateExemptPrefixes(mUpstreamNetworkMonitor.getOffloadExemptPrefixes());
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // This transitions us out of TetherModeAliveState,
                    // either to InitialState or an error state.
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (TetherInterfaceStateMachine o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case EVENT_IFACE_UPDATE_LINKPROPERTIES:
            {
                final LinkProperties newLp = (LinkProperties) message.obj;
                if (message.arg1 == IControlsTethering.STATE_TETHERED) {
                    mOffloadController.notifyDownstreamLinkProperties(newLp);
                } else {
                    mOffloadController.removeDownstreamInterface(newLp.getInterfaceName());
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (!mUpstreamWanted)
                    break;
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        case EVENT_EXEMPT_PREFIXES_UPDATE:
            updateOffloadExemptPrefixes((Set<IpPrefix>) message.obj);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // This transitions us out of TetherModeAliveState,
                    // either to InitialState or an error state.
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (TetherInterfaceStateMachine o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case EVENT_IFACE_UPDATE_LINKPROPERTIES:
            {
                final LinkProperties newLp = (LinkProperties) message.obj;
                if (message.arg1 == IControlsTethering.STATE_TETHERED) {
                    mOffloadController.notifyDownstreamLinkProperties(newLp);
                } else {
                    mOffloadController.removeDownstreamInterface(newLp.getInterfaceName());
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (mUpstreamWanted) {
                    handleUpstreamNetworkMonitorCallback(message.arg1, message.obj);
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    reset(mContext);
    reset(mCS);
    reset(mLog);
    when(mLog.forSubComponent(anyString())).thenReturn(mLog);
    mCM = spy(new TestConnectivityManager(mContext, mCS));
    mSM = new TestStateMachine();
    mUNM = new UpstreamNetworkMonitor((ConnectivityManager) mCM, mSM, mLog, EVENT_UNM_UPDATE, EVENT_PFX_UPDATE);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    reset(mContext);
    reset(mCS);
    reset(mLog);
    when(mLog.forSubComponent(anyString())).thenReturn(mLog);
    mCM = spy(new TestConnectivityManager(mContext, mCS));
    mSM = new TestStateMachine();
    mUNM = new UpstreamNetworkMonitor((ConnectivityManager) mCM, mSM, mLog, EVENT_UNM_UPDATE);
}
#end_block

#method_before
@Test
public void testOffloadExemptPrefixes() throws Exception {
    mUNM.start();
    // [0] Test minimum set of exempt prefixes.
    Set<IpPrefix> exempt = mUNM.getOffloadExemptPrefixes();
    final String[] MINSET = { "127.0.0.1/32", "127.0.0.0/8", "::1/128", "fe80::/64" };
    assertPrefixSet(exempt, INCLUDES, MINSET);
    final Set<String> alreadySeen = new HashSet<>();
    Collections.addAll(alreadySeen, MINSET);
    assertEquals(alreadySeen.size(), exempt.size());
    // [1] Pretend Wi-Fi connects.
    final TestNetworkAgent wifiAgent = new TestNetworkAgent(mCM, TRANSPORT_WIFI);
    final LinkProperties wifiLp = new LinkProperties();
    wifiLp.setInterfaceName("wlan0");
    final String[] WIFI_ADDRS = { "fe80::827a:bfff:fe6f:374d", "100.112.103.18", "2001:db8:4:fd00:827a:bfff:fe6f:374d", "2001:db8:4:fd00:6dea:325a:fdae:4ef4", // ULA address for good measure.
    "fd6a:a640:60bf:e985::123" };
    for (String addrStr : WIFI_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/64" : "/20";
        wifiLp.addLinkAddress(new LinkAddress(addrStr + cidr));
    }
    wifiAgent.fakeConnect();
    wifiAgent.sendLinkProperties(wifiLp);
    exempt = mUNM.getOffloadExemptPrefixes();
    assertPrefixSet(exempt, INCLUDES, alreadySeen);
    for (String addrStr : WIFI_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/128" : "/32";
        final String prefixStr = addrStr + cidr;
        assertPrefixSet(exempt, INCLUDES, prefixStr);
        Collections.addAll(alreadySeen, prefixStr);
    }
    final String[] wifiLinkPrefixes = { "100.112.96.0/20", "2001:db8:4:fd00::/64", "fd6a:a640:60bf:e985::/64" };
    assertPrefixSet(exempt, INCLUDES, wifiLinkPrefixes);
    Collections.addAll(alreadySeen, wifiLinkPrefixes);
    assertEquals(alreadySeen.size(), exempt.size());
    // [2] Pretend mobile connects.
    final TestNetworkAgent cellAgent = new TestNetworkAgent(mCM, TRANSPORT_CELLULAR);
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName("rmnet_data0");
    final String[] CELL_ADDRS = { "10.102.211.48", "2001:db8:0:1:b50e:70d9:10c9:433d" };
    for (String addrStr : CELL_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/64" : "/27";
        cellLp.addLinkAddress(new LinkAddress(addrStr + cidr));
    }
    cellAgent.fakeConnect();
    cellAgent.sendLinkProperties(cellLp);
    exempt = mUNM.getOffloadExemptPrefixes();
    assertPrefixSet(exempt, INCLUDES, alreadySeen);
    for (String addrStr : CELL_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/128" : "/32";
        final String prefixStr = addrStr + cidr;
        assertPrefixSet(exempt, INCLUDES, prefixStr);
        Collections.addAll(alreadySeen, prefixStr);
    }
    final String[] cellLinkPrefixes = { "10.102.211.32/27", "2001:db8:0:1::/64" };
    assertPrefixSet(exempt, INCLUDES, cellLinkPrefixes);
    Collections.addAll(alreadySeen, cellLinkPrefixes);
    assertEquals(alreadySeen.size(), exempt.size());
    // [3] Pretend DUN connects.
    final TestNetworkAgent dunAgent = new TestNetworkAgent(mCM, TRANSPORT_CELLULAR);
    dunAgent.networkCapabilities.addCapability(NET_CAPABILITY_DUN);
    final LinkProperties dunLp = new LinkProperties();
    dunLp.setInterfaceName("rmnet_data1");
    final String[] DUN_ADDRS = { "192.0.2.48", "2001:db8:1:2:b50e:70d9:10c9:433d" };
    for (String addrStr : DUN_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/64" : "/27";
        cellLp.addLinkAddress(new LinkAddress(addrStr + cidr));
    }
    dunAgent.fakeConnect();
    dunAgent.sendLinkProperties(dunLp);
    exempt = mUNM.getOffloadExemptPrefixes();
    assertPrefixSet(exempt, INCLUDES, alreadySeen);
    for (String addrStr : DUN_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/128" : "/32";
        final String prefixStr = addrStr + cidr;
        assertPrefixSet(exempt, INCLUDES, prefixStr);
        Collections.addAll(alreadySeen, prefixStr);
    }
    final String[] dunLinkPrefixes = { "192.0.2.32/27", "2001:db8:1:2::/64" };
    assertPrefixSet(exempt, INCLUDES, dunLinkPrefixes);
    Collections.addAll(alreadySeen, dunLinkPrefixes);
    assertEquals(alreadySeen.size(), exempt.size());
    // [4] Pretend Wi-Fi disconnected.  It's addresses/prefixes should no
    // longer be included (should be properly removed).
    wifiAgent.fakeDisconnect();
    exempt = mUNM.getOffloadExemptPrefixes();
    assertPrefixSet(exempt, INCLUDES, MINSET);
    for (String addrStr : WIFI_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/128" : "/32";
        assertPrefixSet(exempt, EXCLUDES, addrStr + cidr);
    }
    for (String addrStr : CELL_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/128" : "/32";
        assertPrefixSet(exempt, INCLUDES, addrStr + cidr);
    }
    assertPrefixSet(exempt, INCLUDES, cellLinkPrefixes);
    for (String addrStr : DUN_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/128" : "/32";
        assertPrefixSet(exempt, INCLUDES, addrStr + cidr);
    }
    assertPrefixSet(exempt, INCLUDES, dunLinkPrefixes);
}
#method_after
@Test
public void testOffloadExemptPrefixes() throws Exception {
    mUNM.start();
    // [0] Test minimum set of exempt prefixes.
    Set<IpPrefix> exempt = mUNM.getOffloadExemptPrefixes();
    final String[] MINSET = { "127.0.0.0/8", "169.254.0.0/16", "::/3", "fe80::/64", "fc00::/7", "ff00::/8" };
    assertPrefixSet(exempt, INCLUDES, MINSET);
    final Set<String> alreadySeen = new HashSet<>();
    Collections.addAll(alreadySeen, MINSET);
    assertEquals(alreadySeen.size(), exempt.size());
    // [1] Pretend Wi-Fi connects.
    final TestNetworkAgent wifiAgent = new TestNetworkAgent(mCM, TRANSPORT_WIFI);
    final LinkProperties wifiLp = new LinkProperties();
    wifiLp.setInterfaceName("wlan0");
    final String[] WIFI_ADDRS = { "fe80::827a:bfff:fe6f:374d", "100.112.103.18", "2001:db8:4:fd00:827a:bfff:fe6f:374d", "2001:db8:4:fd00:6dea:325a:fdae:4ef4", // ULA address for good measure.
    "fd6a:a640:60bf:e985::123" };
    for (String addrStr : WIFI_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/64" : "/20";
        wifiLp.addLinkAddress(new LinkAddress(addrStr + cidr));
    }
    wifiAgent.fakeConnect();
    wifiAgent.sendLinkProperties(wifiLp);
    exempt = mUNM.getOffloadExemptPrefixes();
    assertPrefixSet(exempt, INCLUDES, alreadySeen);
    final String[] wifiLinkPrefixes = { // Excludes link-local as that's already tested within MINSET.
    "100.112.96.0/20", "2001:db8:4:fd00::/64", "fd6a:a640:60bf:e985::/64" };
    assertPrefixSet(exempt, INCLUDES, wifiLinkPrefixes);
    Collections.addAll(alreadySeen, wifiLinkPrefixes);
    assertEquals(alreadySeen.size(), exempt.size());
    // [2] Pretend mobile connects.
    final TestNetworkAgent cellAgent = new TestNetworkAgent(mCM, TRANSPORT_CELLULAR);
    final LinkProperties cellLp = new LinkProperties();
    cellLp.setInterfaceName("rmnet_data0");
    final String[] CELL_ADDRS = { "10.102.211.48", "2001:db8:0:1:b50e:70d9:10c9:433d" };
    for (String addrStr : CELL_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/64" : "/27";
        cellLp.addLinkAddress(new LinkAddress(addrStr + cidr));
    }
    cellAgent.fakeConnect();
    cellAgent.sendLinkProperties(cellLp);
    exempt = mUNM.getOffloadExemptPrefixes();
    assertPrefixSet(exempt, INCLUDES, alreadySeen);
    final String[] cellLinkPrefixes = { "10.102.211.32/27", "2001:db8:0:1::/64" };
    assertPrefixSet(exempt, INCLUDES, cellLinkPrefixes);
    Collections.addAll(alreadySeen, cellLinkPrefixes);
    assertEquals(alreadySeen.size(), exempt.size());
    // [3] Pretend DUN connects.
    final TestNetworkAgent dunAgent = new TestNetworkAgent(mCM, TRANSPORT_CELLULAR);
    dunAgent.networkCapabilities.addCapability(NET_CAPABILITY_DUN);
    final LinkProperties dunLp = new LinkProperties();
    dunLp.setInterfaceName("rmnet_data1");
    final String[] DUN_ADDRS = { "192.0.2.48", "2001:db8:1:2:b50e:70d9:10c9:433d" };
    for (String addrStr : DUN_ADDRS) {
        final String cidr = addrStr.contains(":") ? "/64" : "/27";
        cellLp.addLinkAddress(new LinkAddress(addrStr + cidr));
    }
    dunAgent.fakeConnect();
    dunAgent.sendLinkProperties(dunLp);
    exempt = mUNM.getOffloadExemptPrefixes();
    assertPrefixSet(exempt, INCLUDES, alreadySeen);
    final String[] dunLinkPrefixes = { "192.0.2.32/27", "2001:db8:1:2::/64" };
    assertPrefixSet(exempt, INCLUDES, dunLinkPrefixes);
    Collections.addAll(alreadySeen, dunLinkPrefixes);
    assertEquals(alreadySeen.size(), exempt.size());
    // [4] Pretend Wi-Fi disconnected.  It's addresses/prefixes should no
    // longer be included (should be properly removed).
    wifiAgent.fakeDisconnect();
    exempt = mUNM.getOffloadExemptPrefixes();
    assertPrefixSet(exempt, INCLUDES, MINSET);
    assertPrefixSet(exempt, EXCLUDES, wifiLinkPrefixes);
    assertPrefixSet(exempt, INCLUDES, cellLinkPrefixes);
    assertPrefixSet(exempt, INCLUDES, dunLinkPrefixes);
}
#end_block

#method_before
public Set<IpPrefix> getOffloadExemptPrefixes() {
    return mOffloadExemptPrefixes;
}
#method_after
public Set<IpPrefix> getOffloadExemptPrefixes() {
    return (Set<IpPrefix>) mOffloadExemptPrefixes.clone();
}
#end_block

#method_before
private void recomputeOffloadExemptPrefixes() {
    final Set<IpPrefix> exemptPrefixes = allOffloadExemptPrefixes(mNetworkMap.values());
    if (!mOffloadExemptPrefixes.equals(exemptPrefixes)) {
        mOffloadExemptPrefixes.clear();
        mOffloadExemptPrefixes.addAll(exemptPrefixes);
        mTarget.sendMessage(mPrefixesUpdateCode, 0, 0, exemptPrefixes);
    }
}
#method_after
private void recomputeOffloadExemptPrefixes() {
    final HashSet<IpPrefix> exemptPrefixes = allOffloadExemptPrefixes(mNetworkMap.values());
    if (!mOffloadExemptPrefixes.equals(exemptPrefixes)) {
        mOffloadExemptPrefixes = exemptPrefixes;
        notifyTarget(NOTIFY_EXEMPT_PREFIXES, exemptPrefixes.clone());
    }
}
#end_block

#method_before
private void notifyTarget(int which, NetworkState netstate) {
    mTarget.sendMessage(mUpstreamUpdateCode, which, 0, netstate);
}
#method_after
private void notifyTarget(int which, Object obj) {
    mTarget.sendMessage(mWhat, which, 0, obj);
}
#end_block

#method_before
static private TypeStatePair findFirstAvailableUpstreamByType(Iterable<NetworkState> netStates, Iterable<Integer> preferredTypes) {
    final TypeStatePair result = new TypeStatePair();
    for (int type : preferredTypes) {
        NetworkCapabilities nc;
        try {
            nc = ConnectivityManager.networkCapabilitiesForType(type);
        } catch (IllegalArgumentException iae) {
            Log.e(TAG, "No NetworkCapabilities mapping for legacy type: " + ConnectivityManager.getNetworkTypeName(type));
            continue;
        }
        for (NetworkState value : netStates) {
            if (!nc.satisfiedByNetworkCapabilities(value.networkCapabilities)) {
                continue;
            }
            result.type = type;
            result.ns = value;
            return result;
        }
    }
    return result;
}
#method_after
private static TypeStatePair findFirstAvailableUpstreamByType(Iterable<NetworkState> netStates, Iterable<Integer> preferredTypes) {
    final TypeStatePair result = new TypeStatePair();
    for (int type : preferredTypes) {
        NetworkCapabilities nc;
        try {
            nc = ConnectivityManager.networkCapabilitiesForType(type);
        } catch (IllegalArgumentException iae) {
            Log.e(TAG, "No NetworkCapabilities mapping for legacy type: " + ConnectivityManager.getNetworkTypeName(type));
            continue;
        }
        for (NetworkState value : netStates) {
            if (!nc.satisfiedByNetworkCapabilities(value.networkCapabilities)) {
                continue;
            }
            result.type = type;
            result.ns = value;
            return result;
        }
    }
    return result;
}
#end_block

#method_before
static private Set<IpPrefix> allOffloadExemptPrefixes(Iterable<NetworkState> networkStates) {
    final HashSet<IpPrefix> prefixSet = new HashSet<>();
    addDefaultLocalPrefixes(prefixSet);
    for (NetworkState ns : networkStates) {
        addOffloadExemptPrefixes(prefixSet, ns);
    }
    return prefixSet;
}
#method_after
private static HashSet<IpPrefix> allOffloadExemptPrefixes(Iterable<NetworkState> netStates) {
    final HashSet<IpPrefix> prefixSet = new HashSet<>();
    addDefaultLocalPrefixes(prefixSet);
    for (NetworkState ns : netStates) {
        addOffloadExemptPrefixes(prefixSet, ns.linkProperties);
    }
    return prefixSet;
}
#end_block

#method_before
static private void addDefaultLocalPrefixes(Set<IpPrefix> prefixSet) {
    for (String prefix : MINIMUM_LOCAL_PREFIXES_SET) {
        prefixSet.add(new IpPrefix(prefix));
    }
}
#method_after
private static void addDefaultLocalPrefixes(Set<IpPrefix> prefixSet) {
    Collections.addAll(prefixSet, MINIMUM_LOCAL_PREFIXES_SET);
}
#end_block

#method_before
static private void addOffloadExemptPrefixes(Set<IpPrefix> prefixSet, NetworkState ns) {
    if (ns.linkProperties == null)
        return;
    for (LinkAddress linkAddr : ns.linkProperties.getAllLinkAddresses()) {
        // Add a prefix for each IP address (i.e. a /32 or a /128), and an
        // IpPrefix representation of the LinkAddress.
        final InetAddress ip = linkAddr.getAddress();
        prefixSet.add(new IpPrefix(ip, NetworkConstants.prefixLengthForAddress(ip)));
        prefixSet.add(new IpPrefix(ip, linkAddr.getPrefixLength()));
    }
// TODO: Consider adding other non-default routes associated with this
// network. Traffic to these destinations should perhaps not go through
// the Internet (upstream).
}
#method_after
private static void addOffloadExemptPrefixes(Set<IpPrefix> prefixSet, LinkProperties lp) {
    if (lp == null)
        return;
    for (LinkAddress linkAddr : lp.getAllLinkAddresses()) {
        prefixSet.add(new IpPrefix(linkAddr.getAddress(), linkAddr.getPrefixLength()));
    }
// TODO: Consider adding other non-default routes associated with this
// network. Traffic to these destinations should perhaps not go through
// the Internet (upstream).
}
#end_block

#method_before
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", score, newNetwork.getCurrentScore(), oldDefaultNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#method_after
// Handles a network appearing or improving its score.
// 
// - Evaluates all current NetworkRequests that can be
// satisfied by newNetwork, and reassigns to newNetwork
// any such requests for which newNetwork is the best.
// 
// - Lingers any validated Networks that as a result are no longer
// needed. A network is needed if it is the best network for
// one or more NetworkRequests, or if it is a VPN.
// 
// - Tears down newNetwork if it just became validated
// but turns out to be unneeded.
// 
// - If reapUnvalidatedNetworks==REAP, tears down unvalidated
// networks that have no chance (i.e. even if validated)
// of becoming the highest scoring network.
// 
// NOTE: This function only adds NetworkRequests that "newNetwork" could satisfy,
// it does not remove NetworkRequests that other Networks could better satisfy.
// If you need to handle decreases in score, use {@link rematchAllNetworksAndRequests}.
// This function should be used when possible instead of {@code rematchAllNetworksAndRequests}
// as it performs better by a factor of the number of Networks.
// 
// @param newNetwork is the network to be matched against NetworkRequests.
// @param reapUnvalidatedNetworks indicates if an additional pass over all networks should be
// performed to tear down unvalidated networks that have no chance (i.e. even if
private void rematchNetworkAndRequests(NetworkAgentInfo newNetwork, ReapUnvalidatedNetworks reapUnvalidatedNetworks, long now) {
    if (!newNetwork.everConnected)
        return;
    boolean keep = newNetwork.isVPN();
    boolean isNewDefault = false;
    NetworkAgentInfo oldDefaultNetwork = null;
    final boolean wasBackgroundNetwork = newNetwork.isBackgroundNetwork();
    final int score = newNetwork.getCurrentScore();
    if (VDBG)
        log("rematching " + newNetwork.name());
    // Find and migrate to this Network any NetworkRequests for
    // which this network is now the best.
    ArrayList<NetworkAgentInfo> affectedNetworks = new ArrayList<NetworkAgentInfo>();
    ArrayList<NetworkRequestInfo> addedRequests = new ArrayList<NetworkRequestInfo>();
    NetworkCapabilities nc = newNetwork.networkCapabilities;
    if (VDBG)
        log(" network has: " + nc);
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        // requests or not, and doesn't affect the network's score.
        if (nri.request.isListen())
            continue;
        final NetworkAgentInfo currentNetwork = mNetworkForRequestId.get(nri.request.requestId);
        final boolean satisfies = newNetwork.satisfies(nri.request);
        if (newNetwork == currentNetwork && satisfies) {
            if (VDBG) {
                log("Network " + newNetwork.name() + " was already satisfying" + " request " + nri.request.requestId + ". No change.");
            }
            keep = true;
            continue;
        }
        // check if it satisfies the NetworkCapabilities
        if (VDBG)
            log("  checking if request is satisfied: " + nri.request);
        if (satisfies) {
            // this request
            if (VDBG) {
                log("currentScore = " + (currentNetwork != null ? currentNetwork.getCurrentScore() : 0) + ", newScore = " + score);
            }
            if (currentNetwork == null || currentNetwork.getCurrentScore() < score) {
                if (VDBG)
                    log("rematch for " + newNetwork.name());
                if (currentNetwork != null) {
                    if (VDBG)
                        log("   accepting network in place of " + currentNetwork.name());
                    currentNetwork.removeRequest(nri.request.requestId);
                    currentNetwork.lingerRequest(nri.request, now, mLingerDelayMs);
                    affectedNetworks.add(currentNetwork);
                } else {
                    if (VDBG)
                        log("   accepting network in place of null");
                }
                newNetwork.unlingerRequest(nri.request);
                mNetworkForRequestId.put(nri.request.requestId, newNetwork);
                if (!newNetwork.addRequest(nri.request)) {
                    Slog.wtf(TAG, "BUG: " + newNetwork.name() + " already has " + nri.request);
                }
                addedRequests.add(nri);
                keep = true;
                // Tell NetworkFactories about the new score, so they can stop
                // trying to connect if they know they cannot match it.
                // TODO - this could get expensive if we have alot of requests for this
                // network.  Think about if there is a way to reduce this.  Push
                // netid->request mapping to each factory?
                sendUpdatedScoreToFactories(nri.request, score);
                if (isDefaultRequest(nri)) {
                    isNewDefault = true;
                    oldDefaultNetwork = currentNetwork;
                    if (currentNetwork != null) {
                        mLingerMonitor.noteLingerDefaultNetwork(currentNetwork, newNetwork);
                    }
                }
            }
        } else if (newNetwork.isSatisfyingRequest(nri.request.requestId)) {
            // longer satisfies "nri" when "currentNetwork" does not equal "newNetwork".
            if (DBG) {
                log("Network " + newNetwork.name() + " stopped satisfying" + " request " + nri.request.requestId);
            }
            newNetwork.removeRequest(nri.request.requestId);
            if (currentNetwork == newNetwork) {
                mNetworkForRequestId.remove(nri.request.requestId);
                sendUpdatedScoreToFactories(nri.request, 0);
            } else {
                Slog.wtf(TAG, "BUG: Removing request " + nri.request.requestId + " from " + newNetwork.name() + " without updating mNetworkForRequestId or factories!");
            }
            // TODO: Technically, sending CALLBACK_LOST here is
            // incorrect if there is a replacement network currently
            // connected that can satisfy nri, which is a request
            // (not a listen). However, the only capability that can both
            // a) be requested and b) change is NET_CAPABILITY_TRUSTED,
            // so this code is only incorrect for a network that loses
            // the TRUSTED capability, which is a rare case.
            callCallbackForRequest(nri, newNetwork, ConnectivityManager.CALLBACK_LOST, 0);
        }
    }
    if (isNewDefault) {
        // Notify system services that this network is up.
        makeDefault(newNetwork);
        // Log 0 -> X and Y -> X default network transitions, where X is the new default.
        logDefaultNetworkEvent(newNetwork, oldDefaultNetwork);
        // Have a new default network, release the transition wakelock in
        scheduleReleaseNetworkTransitionWakelock();
    }
    if (!newNetwork.networkCapabilities.equalRequestableCapabilities(nc)) {
        Slog.wtf(TAG, String.format("BUG: %s changed requestable capabilities during rematch: %s -> %s", nc, newNetwork.networkCapabilities));
    }
    if (newNetwork.getCurrentScore() != score) {
        Slog.wtf(TAG, String.format("BUG: %s changed score during rematch: %d -> %d", newNetwork.name(), score, newNetwork.getCurrentScore()));
    }
    // Second pass: process all listens.
    if (wasBackgroundNetwork != newNetwork.isBackgroundNetwork()) {
        // If the network went from background to foreground or vice versa, we need to update
        // its foreground state. It is safe to do this after rematching the requests because
        // NET_CAPABILITY_FOREGROUND does not affect requests, as is not a requestable
        // capability and does not affect the network's score (see the Slog.wtf call above).
        updateCapabilities(score, newNetwork, newNetwork.networkCapabilities);
    } else {
        processListenRequests(newNetwork, false);
    }
    // before LegacyTypeTracker sends legacy broadcasts
    for (NetworkRequestInfo nri : addedRequests) notifyNetworkAvailable(newNetwork, nri);
    // available callback for newNetwork.
    for (NetworkAgentInfo nai : affectedNetworks) {
        updateLingerState(nai, now);
    }
    // Possibly unlinger newNetwork. Unlingering a network does not send any callbacks so it
    // does not need to be done in any particular order.
    updateLingerState(newNetwork, now);
    if (isNewDefault) {
        // the new one connected.
        if (oldDefaultNetwork != null) {
            mLegacyTypeTracker.remove(oldDefaultNetwork.networkInfo.getType(), oldDefaultNetwork, true);
        }
        mDefaultInetConditionPublished = newNetwork.lastValidated ? 100 : 0;
        mLegacyTypeTracker.add(newNetwork.networkInfo.getType(), newNetwork);
        notifyLockdownVpn(newNetwork);
    }
    if (keep) {
        // TODO: Avoid redoing this; this must only be done once when a network comes online.
        try {
            final IBatteryStats bs = BatteryStatsService.getService();
            final int type = newNetwork.networkInfo.getType();
            final String baseIface = newNetwork.linkProperties.getInterfaceName();
            bs.noteNetworkInterfaceType(baseIface, type);
            for (LinkProperties stacked : newNetwork.linkProperties.getStackedLinks()) {
                final String stackedIface = stacked.getInterfaceName();
                bs.noteNetworkInterfaceType(stackedIface, type);
                NetworkStatsFactory.noteStackedIface(stackedIface, baseIface);
            }
        } catch (RemoteException ignored) {
        }
        // This is on top of the multiple intent sequencing referenced in the todo above.
        for (int i = 0; i < newNetwork.numNetworkRequests(); i++) {
            NetworkRequest nr = newNetwork.requestAt(i);
            if (nr.legacyType != TYPE_NONE && nr.isRequest()) {
                // legacy type tracker filters out repeat adds
                mLegacyTypeTracker.add(nr.legacyType, newNetwork);
            }
        }
        // newNetwork to the tracker explicitly (it's a no-op if it has already been added).
        if (newNetwork.isVPN()) {
            mLegacyTypeTracker.add(TYPE_VPN, newNetwork);
        }
    }
    if (reapUnvalidatedNetworks == ReapUnvalidatedNetworks.REAP) {
        for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
            if (unneeded(nai, UnneededFor.TEARDOWN)) {
                if (nai.getLingerExpiry() > 0) {
                    // This network has active linger timers and no requests, but is not
                    // lingering. Linger it.
                    // 
                    // One way (the only way?) this can happen if this network is unvalidated
                    // and became unneeded due to another network improving its score to the
                    // point where this network will no longer be able to satisfy any requests
                    // even if it validates.
                    updateLingerState(nai, now);
                } else {
                    if (DBG)
                        log("Reaping " + nai.name());
                    teardownUnneededNetwork(nai);
                }
            }
        }
    }
}
#end_block

#method_before
@Override
boolean build() {
    if (super.build()) {
        File tempFile = new File(inputFile.folder, destFileName);
        try {
            if (!inputFile.fileName.equals(tempFile)) {
                copyFile(inputFile.fileName, tempFile);
            } else {
                tempFile = null;
            }
        } catch (IOException e) {
            System.err.println("io exception:" + e.getMessage());
            e.printStackTrace();
            return false;
        }
        File outDir = outputFile.fileName.getParentFile();
        if (!outDir.exists() && !outDir.mkdirs()) {
            System.err.println("failed to create output dir: " + outDir.getAbsolutePath());
            return false;
        }
        File absoluteFile = new File(inputFile.folder.getAbsolutePath(), destFileName);
        if (!absoluteFile.exists()) {
            // Something went wrong.
            throw new IllegalArgumentException(absoluteFile.getAbsolutePath());
        }
        try (JarOutputStream jarOut = new JarOutputStream(new FileOutputStream(outputFile.fileName.getAbsolutePath()))) {
            JarEntry entry = new JarEntry(destFileName);
            entry.setTime(absoluteFile.lastModified());
            jarOut.putNextEntry(entry);
            try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(absoluteFile))) {
                byte[] buffer = new byte[4096];
                for (; ; ) {
                    int read = bis.read(buffer);
                    if (read < 0) {
                        break;
                    }
                    jarOut.write(buffer, 0, read);
                }
            }
            jarOut.closeEntry();
        } catch (Exception e) {
            System.err.println("exception in JarBuildStep for " + outputFile.fileName.getAbsolutePath() + ", " + destFileName);
            e.printStackTrace(System.err);
            new File(outputFile.fileName.getAbsolutePath()).delete();
            return false;
        }
        // Clean up.
        if (tempFile != null) {
            tempFile.delete();
        }
        if (deleteInputFileAfterBuild) {
            inputFile.fileName.delete();
        }
        return true;
    }
    return false;
}
#method_after
@Override
boolean build() {
    if (super.build()) {
        File tempFile = new File(inputFile.folder, outputJarEntryName);
        try {
            if (!inputFile.fileName.equals(tempFile)) {
                copyFile(inputFile.fileName, tempFile);
            } else {
                tempFile = null;
            }
        } catch (IOException e) {
            System.err.println("io exception:" + e.getMessage());
            e.printStackTrace();
            return false;
        }
        File outDir = outputFile.fileName.getParentFile();
        if (!outDir.exists() && !outDir.mkdirs()) {
            System.err.println("failed to create output dir: " + outDir.getAbsolutePath());
            return false;
        }
        // Find the input. We'll need to look into the input folder, but check with the
        // (relative) destination filename (this is effectively removing the inputFile folder
        // from the entry path in the jar file).
        Path absoluteInputPath = Paths.get(inputFile.folder.getAbsolutePath()).resolve(outputJarEntryName);
        File absoluteInputFile = absoluteInputPath.toFile();
        if (!absoluteInputFile.exists()) {
            // Something went wrong.
            throw new IllegalArgumentException(absoluteInputFile.getAbsolutePath());
        }
        // Use a JarOutputStream to create the output jar file.
        File jarOutFile = outputFile.fileName;
        try (JarOutputStream jarOut = new JarOutputStream(new FileOutputStream(jarOutFile))) {
            // Create the JAR entry for the file. Use destFileName, and copy the timestamp
            // from the input.
            JarEntry entry = new JarEntry(outputJarEntryName);
            entry.setTime(absoluteInputFile.lastModified());
            // Push the entry. The stream will then be ready to accept content.
            jarOut.putNextEntry(entry);
            // Copy absoluteInputFile into the jar file.
            Files.copy(absoluteInputPath, jarOut);
            // Finish the entry.
            jarOut.closeEntry();
        // (Implicitly close the stream, finishing the jar file.)
        } catch (Exception e) {
            System.err.println("exception in JarBuildStep for " + outputFile.fileName.getAbsolutePath() + ", " + outputJarEntryName);
            e.printStackTrace(System.err);
            jarOutFile.delete();
            return false;
        }
        // Clean up.
        if (tempFile != null) {
            tempFile.delete();
        }
        if (deleteInputFileAfterBuild) {
            inputFile.fileName.delete();
        }
        return true;
    }
    return false;
}
#end_block

#method_before
@Override
public int hashCode() {
    return inputFile.hashCode() ^ outputFile.hashCode() ^ destFileName.hashCode();
}
#method_after
@Override
public int hashCode() {
    return inputFile.hashCode() ^ outputFile.hashCode() ^ outputJarEntryName.hashCode();
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (super.equals(obj)) {
        JarBuildStep other = (JarBuildStep) obj;
        return inputFile.equals(other.inputFile) && outputFile.equals(other.outputFile) && destFileName.equals(other.destFileName);
    }
    return false;
}
#method_after
@Override
public boolean equals(Object obj) {
    if (super.equals(obj)) {
        JarBuildStep other = (JarBuildStep) obj;
        return inputFile.equals(other.inputFile) && outputFile.equals(other.outputFile) && outputJarEntryName.equals(other.outputJarEntryName);
    }
    return false;
}
#end_block

#method_before
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    UserService userService = UserServiceFactory.getUserService();
    User currentUser = userService.getCurrentUser();
    RequestDispatcher dispatcher = null;
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    List<TestDisplay> displayedTests = new ArrayList<>();
    List<String> allTestNames = new ArrayList<>();
    List<Key> unprocessedTestKeys = new ArrayList<>();
    // map from table key to TestDisplay
    Map<Key, TestDisplay> testMap = new HashMap<>();
    Map<String, String> subscriptionMap = new HashMap<>();
    boolean showAll = request.getParameter("showAll") != null;
    String header;
    String buttonLabel;
    String buttonIcon;
    String buttonLink;
    String error = null;
    Query q = new Query(TestEntity.KIND).setKeysOnly();
    for (Entity test : datastore.prepare(q).asIterable()) {
        allTestNames.add(test.getKey().getName());
        ;
        unprocessedTestKeys.add(test.getKey());
    }
    q = new Query(TestStatusEntity.KIND).addProjection(new PropertyProjection(TestStatusEntity.PASS_COUNT, Long.class)).addProjection(new PropertyProjection(TestStatusEntity.FAIL_COUNT, Long.class));
    for (Entity status : datastore.prepare(q).asIterable()) {
        TestStatusEntity statusEntity = TestStatusEntity.fromEntity(status);
        if (statusEntity == null)
            continue;
        Key testKey = KeyFactory.createKey(TestEntity.KIND, statusEntity.testName);
        if (!unprocessedTestKeys.contains(testKey))
            continue;
        TestDisplay display = new TestDisplay(testKey, statusEntity.passCount, statusEntity.failCount);
        testMap.put(testKey, display);
        unprocessedTestKeys.remove(testKey);
    }
    // Process tests without statuses
    for (Key testKey : unprocessedTestKeys) {
        TestDisplay display = new TestDisplay(testKey, -1, -1);
        testMap.put(testKey, display);
    }
    if (testMap.size() == 0) {
        error = NO_TESTS_ERROR;
    }
    if (showAll) {
        for (Key testKey : testMap.keySet()) {
            displayedTests.add(testMap.get(testKey));
        }
        header = ALL_HEADER;
        buttonLabel = FAVORITES_BUTTON;
        buttonIcon = UP_ARROW;
        buttonLink = DASHBOARD_FAVORITES_LINK;
    } else {
        if (testMap.size() > 0) {
            Filter userFilter = new FilterPredicate(UserFavoriteEntity.USER, FilterOperator.EQUAL, currentUser);
            q = new Query(UserFavoriteEntity.KIND).setFilter(userFilter);
            for (Entity favorite : datastore.prepare(q).asIterable()) {
                Key testKey = (Key) favorite.getProperty(UserFavoriteEntity.TEST_KEY);
                if (!testMap.containsKey(testKey)) {
                    continue;
                }
                displayedTests.add(testMap.get(testKey));
                subscriptionMap.put(testKey.getName(), KeyFactory.keyToString(favorite.getKey()));
            }
        }
        header = FAVORITES_HEADER;
        buttonLabel = ALL_BUTTON;
        buttonIcon = DOWN_ARROW;
        buttonLink = DASHBOARD_ALL_LINK;
    }
    Collections.sort(displayedTests);
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("allTestsJson", new Gson().toJson(allTestNames));
    request.setAttribute("subscriptionMapJson", new Gson().toJson(subscriptionMap));
    request.setAttribute("testNames", displayedTests);
    request.setAttribute("headerLabel", header);
    request.setAttribute("showAll", showAll);
    request.setAttribute("buttonLabel", buttonLabel);
    request.setAttribute("buttonIcon", buttonIcon);
    request.setAttribute("buttonLink", buttonLink);
    request.setAttribute("error", error);
    dispatcher = request.getRequestDispatcher(DASHBOARD_MAIN_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
    }
}
#method_after
@Override
public void doGetHandler(HttpServletRequest request, HttpServletResponse response) throws IOException {
    UserService userService = UserServiceFactory.getUserService();
    User currentUser = userService.getCurrentUser();
    RequestDispatcher dispatcher = null;
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    List<TestDisplay> displayedTests = new ArrayList<>();
    List<String> allTestNames = new ArrayList<>();
    List<Key> unprocessedTestKeys = new ArrayList<>();
    // map from table key to TestDisplay
    Map<Key, TestDisplay> testMap = new HashMap<>();
    Map<String, String> subscriptionMap = new HashMap<>();
    boolean showAll = request.getParameter("showAll") != null;
    String header;
    String buttonLabel;
    String buttonIcon;
    String buttonLink;
    String error = null;
    Query query = new Query(TestEntity.KIND).setKeysOnly();
    for (Entity test : datastore.prepare(query).asIterable()) {
        allTestNames.add(test.getKey().getName());
        unprocessedTestKeys.add(test.getKey());
    }
    query = new Query(TestStatusEntity.KIND).addProjection(new PropertyProjection(TestStatusEntity.PASS_COUNT, Long.class)).addProjection(new PropertyProjection(TestStatusEntity.FAIL_COUNT, Long.class));
    for (Entity status : datastore.prepare(query).asIterable()) {
        TestStatusEntity statusEntity = TestStatusEntity.fromEntity(status);
        if (statusEntity == null)
            continue;
        Key testKey = KeyFactory.createKey(TestEntity.KIND, statusEntity.testName);
        if (!unprocessedTestKeys.contains(testKey))
            continue;
        TestDisplay display = new TestDisplay(testKey, statusEntity.passCount, statusEntity.failCount);
        testMap.put(testKey, display);
        unprocessedTestKeys.remove(testKey);
    }
    // Process tests without statuses
    for (Key testKey : unprocessedTestKeys) {
        TestDisplay display = new TestDisplay(testKey, -1, -1);
        testMap.put(testKey, display);
    }
    if (testMap.size() == 0) {
        error = NO_TESTS_ERROR;
    }
    if (showAll) {
        for (Key testKey : testMap.keySet()) {
            displayedTests.add(testMap.get(testKey));
        }
        header = ALL_HEADER;
        buttonLabel = FAVORITES_BUTTON;
        buttonIcon = UP_ARROW;
        buttonLink = DASHBOARD_FAVORITES_LINK;
    } else {
        if (testMap.size() > 0) {
            Filter userFilter = new FilterPredicate(UserFavoriteEntity.USER, FilterOperator.EQUAL, currentUser);
            query = new Query(UserFavoriteEntity.KIND).setFilter(userFilter);
            for (Entity favorite : datastore.prepare(query).asIterable()) {
                Key testKey = (Key) favorite.getProperty(UserFavoriteEntity.TEST_KEY);
                if (!testMap.containsKey(testKey)) {
                    continue;
                }
                displayedTests.add(testMap.get(testKey));
                subscriptionMap.put(testKey.getName(), KeyFactory.keyToString(favorite.getKey()));
            }
        }
        header = FAVORITES_HEADER;
        buttonLabel = ALL_BUTTON;
        buttonIcon = DOWN_ARROW;
        buttonLink = DASHBOARD_ALL_LINK;
    }
    Collections.sort(displayedTests);
    response.setStatus(HttpServletResponse.SC_OK);
    request.setAttribute("allTestsJson", new Gson().toJson(allTestNames));
    request.setAttribute("subscriptionMapJson", new Gson().toJson(subscriptionMap));
    request.setAttribute("testNames", displayedTests);
    request.setAttribute("headerLabel", header);
    request.setAttribute("showAll", showAll);
    request.setAttribute("buttonLabel", buttonLabel);
    request.setAttribute("buttonIcon", buttonIcon);
    request.setAttribute("buttonLink", buttonLink);
    request.setAttribute("error", error);
    dispatcher = request.getRequestDispatcher(DASHBOARD_MAIN_JSP);
    try {
        dispatcher.forward(request, response);
    } catch (ServletException e) {
        logger.log(Level.SEVERE, "Servlet Excpetion caught : ", e);
    }
}
#end_block

#method_before
public static void main(String[] args) {
    System.out.println($opt$noinline$foo(new Main()));
    System.out.println($noinline$runSmaliTest("$opt$noinline$foo", new Main()));
    System.out.println($opt$noinline$foo(new SubMain()));
    System.out.println($noinline$runSmaliTest("$opt$noinline$foo", new SubMain()));
    System.out.println($opt$noinline$foo(new SubSubMain()));
    System.out.println($noinline$runSmaliTest("$opt$noinline$foo", new SubSubMain()));
}
#method_after
public static void main(String[] args) {
    System.out.println($noinline$runSmaliTest("$opt$noinline$foo", new Main()));
    System.out.println($noinline$runSmaliTest("$opt$noinline$foo", new SubMain()));
    System.out.println($noinline$runSmaliTest("$opt$noinline$foo", new SubSubMain()));
}
#end_block

#method_before
public void test_ConstructorLjava_lang_String() {
    try {
        JarFile jarFile = new JarFile("Wrong.file");
        fail("Should throw IOException");
    } catch (IOException e) {
    // expected
    }
    try {
        File file = Support_Resources.copyFile(resources, null, jarName);
        String fileName = (file).getCanonicalPath();
        JarFile jarFile = new JarFile(fileName);
        jarFile.close();
    } catch (IOException e) {
        fail("Should not throw IOException");
    }
}
#method_after
public void test_ConstructorLjava_lang_String() {
    try {
        JarFile jarFile = new JarFile("Wrong.file");
        fail("Should throw IOException");
    } catch (IOException e) {
    // expected
    }
    try {
        File file = Support_Resources.copyFile(resources, null, jarName);
        String fileName = file.getCanonicalPath();
        JarFile jarFile = new JarFile(fileName);
        jarFile.close();
    } catch (IOException e) {
        fail("Should not throw IOException");
    }
}
#end_block

#method_before
public void testGetJarEntry() throws Exception {
    {
        File file = Support_Resources.copyFile(resources, null, jarName);
        JarFile jarFile = new JarFile(file);
        assertEquals("Error in returned entry", 311, jarFile.getEntry(entryName).getSize());
        jarFile.close();
    }
    // tests for signed jars
    // test all signed jars in the /Testres/Internal/SignedJars directory
    String jarDirUrl = Support_Resources.getResourceURL("/../internalres/signedjars");
    Vector<String> signedJars = new Vector<String>();
    try {
        InputStream is = new URL(jarDirUrl + "/jarlist.txt").openStream();
        while (is.available() > 0) {
            // Typical line
            StringBuilder linebuff = new StringBuilder(80);
            // length
            done: while (true) {
                int nextByte = is.read();
                switch(nextByte) {
                    case -1:
                        break done;
                    case (byte) '\r':
                        if (linebuff.length() == 0) {
                        // ignore
                        }
                        break done;
                    case (byte) '\n':
                        if (linebuff.length() == 0) {
                        // ignore
                        }
                        break done;
                    default:
                        linebuff.append((char) nextByte);
                }
            }
            if (linebuff.length() == 0) {
                break;
            }
            String line = linebuff.toString();
            signedJars.add(line);
        }
        is.close();
    } catch (IOException e) {
    // no list of jars found
    }
    for (int i = 0; i < signedJars.size(); i++) {
        String jarName = signedJars.get(i);
        try {
            File file = Support_Resources.getExternalLocalFile(jarDirUrl + "/" + jarName);
            JarFile jarFile = new JarFile(file, true);
            boolean foundCerts = false;
            Enumeration<JarEntry> e = jarFile.entries();
            while (e.hasMoreElements()) {
                JarEntry entry = e.nextElement();
                InputStream is = jarFile.getInputStream(entry);
                is.skip(100000);
                is.close();
                Certificate[] certs = entry.getCertificates();
                if (certs != null && certs.length > 0) {
                    foundCerts = true;
                    break;
                }
            }
            assertTrue("No certificates found during signed jar test for jar \"" + jarName + "\"", foundCerts);
            jarFile.close();
        } catch (IOException e) {
            fail("Exception during signed jar test for jar \"" + jarName + "\": " + e.toString());
        }
    }
}
#method_after
public void testGetJarEntry() throws Exception {
    File file = Support_Resources.copyFile(resources, null, jarName);
    JarFile jarFile = new JarFile(file);
    assertEquals("Error in returned entry", 311, jarFile.getEntry(entryName).getSize());
    jarFile.close();
    // tests for signed jars
    // test all signed jars in the /Testres/Internal/SignedJars directory
    String jarDirUrl = Support_Resources.getResourceURL("/../internalres/signedjars");
    Vector<String> signedJars = new Vector<String>();
    try {
        InputStream is = new URL(jarDirUrl + "/jarlist.txt").openStream();
        while (is.available() > 0) {
            // Typical line
            StringBuilder linebuff = new StringBuilder(80);
            // length
            done: while (true) {
                int nextByte = is.read();
                switch(nextByte) {
                    case -1:
                        break done;
                    case (byte) '\r':
                        if (linebuff.length() == 0) {
                        // ignore
                        }
                        break done;
                    case (byte) '\n':
                        if (linebuff.length() == 0) {
                        // ignore
                        }
                        break done;
                    default:
                        linebuff.append((char) nextByte);
                }
            }
            if (linebuff.length() == 0) {
                break;
            }
            String line = linebuff.toString();
            signedJars.add(line);
        }
        is.close();
    } catch (IOException e) {
    // no list of jars found
    }
    for (int i = 0; i < signedJars.size(); i++) {
        String jarName = signedJars.get(i);
        try {
            file = Support_Resources.getExternalLocalFile(jarDirUrl + "/" + jarName);
            jarFile = new JarFile(file, true);
            boolean foundCerts = false;
            Enumeration<JarEntry> e = jarFile.entries();
            while (e.hasMoreElements()) {
                JarEntry entry = e.nextElement();
                InputStream is = jarFile.getInputStream(entry);
                is.skip(100000);
                is.close();
                Certificate[] certs = entry.getCertificates();
                if (certs != null && certs.length > 0) {
                    foundCerts = true;
                    break;
                }
            }
            assertTrue("No certificates found during signed jar test for jar \"" + jarName + "\"", foundCerts);
            jarFile.close();
        } catch (IOException e) {
            fail("Exception during signed jar test for jar \"" + jarName + "\": " + e.toString());
        }
    }
}
#end_block

#method_before
// / CHECK-START: long Main.booleanToLong(boolean) builder (after)
// / CHECK:         <<Arg:z\d+>>           ParameterValue
// / CHECK-DAG:     <<Zero:i\d+>>          IntConstant 0
// / CHECK-DAG:     <<LZero:j\d+>>         LongConstant 0
// / CHECK-DAG:     <<LOne:j\d+>>          LongConstant 1
// / CHECK-DAG:     <<Cond:z\d+>>          Equal [<<Arg>>,<<Zero>>]
// / CHECK-DAG:                            If [<<Cond>>]
// / CHECK-DAG:     <<Phi:j\d+>>           Phi [<<LOne>>,<<LZero>>]
// / CHECK-DAG:                            Return [<<Phi>>]
// / CHECK-START: long Main.booleanToLong(boolean) select_generator (after)
// / CHECK-NOT:                            IntConstant
// / CHECK-NOT:                            Equal
// / CHECK-NOT:                            If
// / CHECK-NOT:                            Phi
// / CHECK-START: long Main.booleanToLong(boolean) select_generator (after)
// / CHECK:         <<Arg:z\d+>>           ParameterValue
// / CHECK-DAG:     <<Zero:j\d+>>          LongConstant 0
// / CHECK-DAG:     <<One:j\d+>>           LongConstant 1
// / CHECK-DAG:     <<Sel:j\d+>>           Select [<<Zero>>,<<One>>,<<Arg>>]
// / CHECK-DAG:                            Return [<<Sel>>]
// As of now, the code is not optimized any further than the above.
// TODO: Re-enable checks below after simplifier is updated to handle this pattern: b/63064517
// CHECK-START: long Main.booleanToLong(boolean) instruction_simplifier$after_bce (after)
// CHECK:         <<Arg:z\d+>>           ParameterValue
// CHECK-DAG:     <<ZToJ:j\d+>>          TypeConversion [<<Arg>>]
// CHECK-DAG:                            Return [<<ZToJ>>]
static long booleanToLong(boolean b) {
    return b ? 1 : 0;
}
#method_after
// / CHECK-START: long Main.booleanToLong(boolean) builder (after)
// / CHECK:         <<Arg:z\d+>>           ParameterValue
// / CHECK-DAG:     <<IZero:i\d+>>         IntConstant 0
// / CHECK-DAG:     <<Zero:j\d+>>          LongConstant 0
// / CHECK-DAG:     <<One:j\d+>>           LongConstant 1
// / CHECK-DAG:     <<Cond:z\d+>>          Equal [<<Arg>>,<<IZero>>]
// / CHECK-DAG:                            If [<<Cond>>]
// / CHECK-DAG:     <<Phi:j\d+>>           Phi [<<One>>,<<Zero>>]
// / CHECK-DAG:                            Return [<<Phi>>]
// / CHECK-START: long Main.booleanToLong(boolean) select_generator (after)
// / CHECK-NOT:                            IntConstant
// / CHECK-NOT:                            Equal
// / CHECK-NOT:                            If
// / CHECK-NOT:                            Phi
// / CHECK-START: long Main.booleanToLong(boolean) select_generator (after)
// / CHECK:         <<Arg:z\d+>>           ParameterValue
// / CHECK-DAG:     <<Zero:j\d+>>          LongConstant 0
// / CHECK-DAG:     <<One:j\d+>>           LongConstant 1
// / CHECK-DAG:     <<Sel:j\d+>>           Select [<<Zero>>,<<One>>,<<Arg>>]
// / CHECK-DAG:                            Return [<<Sel>>]
// As of now, the code is not optimized any further than the above.
// TODO: Re-enable checks below after simplifier is updated to handle this pattern: b/63064517
// CHECK-START: long Main.booleanToLong(boolean) instruction_simplifier$after_bce (after)
// CHECK:         <<Arg:z\d+>>           ParameterValue
// CHECK-DAG:     <<ZToJ:j\d+>>          TypeConversion [<<Arg>>]
// CHECK-DAG:                            Return [<<ZToJ>>]
static long booleanToLong(boolean b) {
    return b ? 1 : 0;
}
#end_block

#method_before
public TestStatusEntity getTestStatus(TestStatusEntity status, String link, Map<String, TestCase> failedTestCaseMap, List<String> emailAddresses, List<Message> messages) throws IOException {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    String footer = getFooter(link);
    TestRunEntity mostRecentRun = null;
    Map<String, TestCaseResult> mostRecentTestCaseResults = new HashMap<>();
    Map<String, TestCase> testCaseBreakageMap = new HashMap<>();
    int passingTestcaseCount = 0;
    List<TestCaseReference> failingTestCases = new ArrayList<>();
    Set<String> fixedTestcases = new HashSet<>();
    Set<String> newTestcaseFailures = new HashSet<>();
    Set<String> continuedTestcaseFailures = new HashSet<>();
    Set<String> skippedTestcaseFailures = new HashSet<>();
    Set<String> transientTestcaseFailures = new HashSet<>();
    String testName = status.testName;
    Key testKey = KeyFactory.createKey(TestEntity.KIND, testName);
    Filter testTypeFilter = FilterUtil.getTestTypeFilter(false, true, false);
    Filter runFilter = FilterUtil.getTimeFilter(testKey, TestRunEntity.KIND, status.timestamp + 1, null, testTypeFilter);
    Query q = new Query(TestRunEntity.KIND).setAncestor(testKey).setFilter(runFilter).addSort(Entity.KEY_RESERVED_PROPERTY, SortDirection.DESCENDING);
    for (Entity testRun : datastore.prepare(q).asIterable(FetchOptions.Builder.withLimit(MAX_RUN_COUNT))) {
        TestRunEntity testRunEntity = TestRunEntity.fromEntity(testRun);
        if (testRunEntity == null) {
            logger.log(Level.WARNING, "Invalid test run detected: " + testRun.getKey());
        }
        if (mostRecentRun == null) {
            mostRecentRun = testRunEntity;
        }
        List<Key> testCaseKeys = new ArrayList<>();
        for (long testCaseId : testRunEntity.testCaseIds) {
            testCaseKeys.add(KeyFactory.createKey(TestCaseRunEntity.KIND, testCaseId));
        }
        Map<Key, Entity> entityMap = datastore.get(testCaseKeys);
        for (Key testCaseKey : testCaseKeys) {
            if (!entityMap.containsKey(testCaseKey)) {
                logger.log(Level.WARNING, "Test case entity missing: " + testCaseKey);
                continue;
            }
            Entity testCaseRun = entityMap.get(testCaseKey);
            TestCaseRunEntity testCaseRunEntity = TestCaseRunEntity.fromEntity(testCaseRun);
            if (testCaseRunEntity == null) {
                logger.log(Level.WARNING, "Invalid test case run: " + testCaseRun.getKey());
                continue;
            }
            for (TestCase testCase : testCaseRunEntity.testCases) {
                String testCaseName = testCase.name;
                TestCaseResult result = TestCaseResult.valueOf(testCase.result);
                if (mostRecentRun == testRunEntity) {
                    mostRecentTestCaseResults.put(testCaseName, result);
                } else {
                    if (!mostRecentTestCaseResults.containsKey(testCaseName)) {
                        // Deprecate notifications for tests that are not present on newer runs
                        continue;
                    }
                    TestCaseResult mostRecentRes = mostRecentTestCaseResults.get(testCaseName);
                    if (mostRecentRes == TestCaseResult.TEST_CASE_RESULT_SKIP) {
                        mostRecentTestCaseResults.put(testCaseName, result);
                    } else if (mostRecentRes == TestCaseResult.TEST_CASE_RESULT_PASS) {
                        // Test is passing now, witnessed a transient failure
                        if (result != TestCaseResult.TEST_CASE_RESULT_PASS && result != TestCaseResult.TEST_CASE_RESULT_SKIP) {
                            transientTestcaseFailures.add(testCaseName);
                        }
                    }
                }
                // Record test case breakages
                if (result != TestCaseResult.TEST_CASE_RESULT_PASS && result != TestCaseResult.TEST_CASE_RESULT_SKIP) {
                    testCaseBreakageMap.put(testCaseName, testCase);
                }
            }
        }
    }
    if (mostRecentRun == null) {
        notifyIfInactive(status, link, emailAddresses, messages);
        return null;
    }
    for (String testCaseName : mostRecentTestCaseResults.keySet()) {
        TestCaseResult mostRecentResult = mostRecentTestCaseResults.get(testCaseName);
        boolean previouslyFailed = failedTestCaseMap.containsKey(testCaseName);
        if (mostRecentResult == TestCaseResult.TEST_CASE_RESULT_SKIP) {
            // persist previous status
            if (previouslyFailed) {
                failingTestCases.add(new TestCaseReference(failedTestCaseMap.get(testCaseName)));
            } else {
                ++passingTestcaseCount;
            }
        } else if (mostRecentResult == TestCaseResult.TEST_CASE_RESULT_PASS) {
            ++passingTestcaseCount;
            if (previouslyFailed && !transientTestcaseFailures.contains(testCaseName)) {
                fixedTestcases.add(testCaseName);
            }
        } else {
            if (!previouslyFailed) {
                newTestcaseFailures.add(testCaseName);
                failingTestCases.add(new TestCaseReference(testCaseBreakageMap.get(testCaseName)));
            } else {
                continuedTestcaseFailures.add(testCaseName);
                failingTestCases.add(new TestCaseReference(failedTestCaseMap.get(testCaseName)));
            }
        }
    }
    Set<String> buildIdList = new HashSet<>();
    Query deviceQuery = new Query(DeviceInfoEntity.KIND).setAncestor(mostRecentRun.key);
    for (Entity device : datastore.prepare(deviceQuery).asIterable()) {
        DeviceInfoEntity deviceEntity = DeviceInfoEntity.fromEntity(device);
        if (deviceEntity == null) {
            continue;
        }
        buildIdList.add(deviceEntity.buildId);
    }
    String buildId = StringUtils.join(buildIdList, ",");
    String summary = new String();
    if (newTestcaseFailures.size() + continuedTestcaseFailures.size() > 0) {
        summary += "The following test cases failed in the latest test run:<br>";
        // Add new test case failures to top of summary in bold font.
        List<String> sortedNewTestcaseFailures = new ArrayList<>(newTestcaseFailures);
        Collections.sort(sortedNewTestcaseFailures);
        for (String testcaseName : sortedNewTestcaseFailures) {
            summary += "- " + "<b>" + testcaseName + "</b><br>";
        }
        // Add continued test case failures to summary.
        List<String> sortedContinuedTestcaseFailures = new ArrayList<>(continuedTestcaseFailures);
        Collections.sort(sortedContinuedTestcaseFailures);
        for (String testcaseName : sortedContinuedTestcaseFailures) {
            summary += "- " + testcaseName + "<br>";
        }
    }
    if (fixedTestcases.size() > 0) {
        // Add fixed test cases to summary.
        summary += "<br><br>The following test cases were fixed in the latest test run:<br>";
        List<String> sortedFixedTestcases = new ArrayList<>(fixedTestcases);
        Collections.sort(sortedFixedTestcases);
        for (String testcaseName : sortedFixedTestcases) {
            summary += "- <i>" + testcaseName + "</i><br>";
        }
    }
    if (transientTestcaseFailures.size() > 0) {
        // Add transient test case failures to summary.
        summary += "<br><br>The following transient test case failures occured:<br>";
        List<String> sortedTransientTestcaseFailures = new ArrayList<>(transientTestcaseFailures);
        Collections.sort(sortedTransientTestcaseFailures);
        for (String testcaseName : sortedTransientTestcaseFailures) {
            summary += "- " + testcaseName + "<br>";
        }
    }
    if (skippedTestcaseFailures.size() > 0) {
        // Add skipped test case failures to summary.
        summary += "<br><br>The following test cases have not been run since failing:<br>";
        List<String> sortedSkippedTestcaseFailures = new ArrayList<>(skippedTestcaseFailures);
        Collections.sort(sortedSkippedTestcaseFailures);
        for (String testcaseName : sortedSkippedTestcaseFailures) {
            summary += "- " + testcaseName + "<br>";
        }
    }
    Date lastUpload = new Date(TimeUnit.MICROSECONDS.toMillis(status.timestamp));
    String uploadDateString = new SimpleDateFormat("MM/dd/yyyy").format(lastUpload);
    String subject = "VTS Test Alert for " + testName + " at " + uploadDateString;
    if (newTestcaseFailures.size() > 0) {
        String body = "Hello,<br><br>Test cases are starting to fail in " + testName + " for device build ID(s): " + buildId + ".<br><br>" + summary + footer;
        try {
            messages.add(EmailHelper.composeEmail(emailAddresses, subject, body));
        } catch (MessagingException | UnsupportedEncodingException e) {
            logger.log(Level.WARNING, "Error composing email : ", e);
        }
    } else if (continuedTestcaseFailures.size() > 0) {
        String body = "Hello,<br><br>Test cases are continuously failing in " + testName + " for device build ID(s): " + buildId + ".<br><br>" + summary + footer;
        try {
            messages.add(EmailHelper.composeEmail(emailAddresses, subject, body));
        } catch (MessagingException | UnsupportedEncodingException e) {
            logger.log(Level.WARNING, "Error composing email : ", e);
        }
    } else if (transientTestcaseFailures.size() > 0) {
        String body = "Hello,<br><br>Some test cases transiently failed in " + testName + " but tests all " + "are passing in the latest device build(s): " + buildId + ".<br><br>" + summary + footer;
        try {
            messages.add(EmailHelper.composeEmail(emailAddresses, subject, body));
        } catch (MessagingException | UnsupportedEncodingException e) {
            logger.log(Level.WARNING, "Error composing email : ", e);
        }
    } else if (fixedTestcases.size() > 0) {
        String body = "Hello,<br><br>All test cases passed in " + testName + " for device build ID(s): " + buildId + "!<br><br>" + summary + footer;
        try {
            messages.add(EmailHelper.composeEmail(emailAddresses, subject, body));
        } catch (MessagingException | UnsupportedEncodingException e) {
            logger.log(Level.WARNING, "Error composing email : ", e);
        }
    }
    return new TestStatusEntity(status.testName, mostRecentRun.startTimestamp, passingTestcaseCount, failingTestCases.size(), failingTestCases);
}
#method_after
public TestStatusEntity getTestStatus(TestStatusEntity status, String link, Map<String, TestCase> failedTestCaseMap, List<String> emailAddresses, List<Message> messages) throws IOException {
    DatastoreService datastore = DatastoreServiceFactory.getDatastoreService();
    String footer = getFooter(link);
    TestRunEntity mostRecentRun = null;
    Map<String, TestCaseResult> mostRecentTestCaseResults = new HashMap<>();
    Map<String, TestCase> testCaseBreakageMap = new HashMap<>();
    int passingTestcaseCount = 0;
    List<TestCaseReference> failingTestCases = new ArrayList<>();
    Set<String> fixedTestcases = new HashSet<>();
    Set<String> newTestcaseFailures = new HashSet<>();
    Set<String> continuedTestcaseFailures = new HashSet<>();
    Set<String> skippedTestcaseFailures = new HashSet<>();
    Set<String> transientTestcaseFailures = new HashSet<>();
    String testName = status.testName;
    Key testKey = KeyFactory.createKey(TestEntity.KIND, testName);
    Filter testTypeFilter = FilterUtil.getTestTypeFilter(false, true, false);
    Filter runFilter = FilterUtil.getTimeFilter(testKey, TestRunEntity.KIND, status.timestamp + 1, null, testTypeFilter);
    Query q = new Query(TestRunEntity.KIND).setAncestor(testKey).setFilter(runFilter).addSort(Entity.KEY_RESERVED_PROPERTY, SortDirection.DESCENDING);
    for (Entity testRun : datastore.prepare(q).asIterable(FetchOptions.Builder.withLimit(MAX_RUN_COUNT))) {
        TestRunEntity testRunEntity = TestRunEntity.fromEntity(testRun);
        if (testRunEntity == null) {
            logger.log(Level.WARNING, "Invalid test run detected: " + testRun.getKey());
        }
        if (mostRecentRun == null) {
            mostRecentRun = testRunEntity;
        }
        List<Key> testCaseKeys = new ArrayList<>();
        for (long testCaseId : testRunEntity.testCaseIds) {
            testCaseKeys.add(KeyFactory.createKey(TestCaseRunEntity.KIND, testCaseId));
        }
        Map<Key, Entity> entityMap = datastore.get(testCaseKeys);
        for (Key testCaseKey : testCaseKeys) {
            if (!entityMap.containsKey(testCaseKey)) {
                logger.log(Level.WARNING, "Test case entity missing: " + testCaseKey);
                continue;
            }
            Entity testCaseRun = entityMap.get(testCaseKey);
            TestCaseRunEntity testCaseRunEntity = TestCaseRunEntity.fromEntity(testCaseRun);
            if (testCaseRunEntity == null) {
                logger.log(Level.WARNING, "Invalid test case run: " + testCaseRun.getKey());
                continue;
            }
            for (TestCase testCase : testCaseRunEntity.testCases) {
                String testCaseName = testCase.name;
                TestCaseResult result = TestCaseResult.valueOf(testCase.result);
                if (mostRecentRun == testRunEntity) {
                    mostRecentTestCaseResults.put(testCaseName, result);
                } else {
                    if (!mostRecentTestCaseResults.containsKey(testCaseName)) {
                        // Deprecate notifications for tests that are not present on newer runs
                        continue;
                    }
                    TestCaseResult mostRecentRes = mostRecentTestCaseResults.get(testCaseName);
                    if (mostRecentRes == TestCaseResult.TEST_CASE_RESULT_SKIP) {
                        mostRecentTestCaseResults.put(testCaseName, result);
                    } else if (mostRecentRes == TestCaseResult.TEST_CASE_RESULT_PASS) {
                        // Test is passing now, witnessed a transient failure
                        if (result != TestCaseResult.TEST_CASE_RESULT_PASS && result != TestCaseResult.TEST_CASE_RESULT_SKIP) {
                            transientTestcaseFailures.add(testCaseName);
                        }
                    }
                }
                // Record test case breakages
                if (result != TestCaseResult.TEST_CASE_RESULT_PASS && result != TestCaseResult.TEST_CASE_RESULT_SKIP) {
                    testCaseBreakageMap.put(testCaseName, testCase);
                }
            }
        }
    }
    if (mostRecentRun == null) {
        notifyIfInactive(status, link, emailAddresses, messages);
        return null;
    }
    for (String testCaseName : mostRecentTestCaseResults.keySet()) {
        TestCaseResult mostRecentResult = mostRecentTestCaseResults.get(testCaseName);
        boolean previouslyFailed = failedTestCaseMap.containsKey(testCaseName);
        if (mostRecentResult == TestCaseResult.TEST_CASE_RESULT_SKIP) {
            // persist previous status
            if (previouslyFailed) {
                failingTestCases.add(new TestCaseReference(failedTestCaseMap.get(testCaseName)));
            } else {
                ++passingTestcaseCount;
            }
        } else if (mostRecentResult == TestCaseResult.TEST_CASE_RESULT_PASS) {
            ++passingTestcaseCount;
            if (previouslyFailed && !transientTestcaseFailures.contains(testCaseName)) {
                fixedTestcases.add(testCaseName);
            }
        } else {
            if (!previouslyFailed) {
                newTestcaseFailures.add(testCaseName);
                failingTestCases.add(new TestCaseReference(testCaseBreakageMap.get(testCaseName)));
            } else {
                continuedTestcaseFailures.add(testCaseName);
                failingTestCases.add(new TestCaseReference(failedTestCaseMap.get(testCaseName)));
            }
        }
    }
    Set<String> buildIdList = new HashSet<>();
    Query deviceQuery = new Query(DeviceInfoEntity.KIND).setAncestor(mostRecentRun.key);
    for (Entity device : datastore.prepare(deviceQuery).asIterable()) {
        DeviceInfoEntity deviceEntity = DeviceInfoEntity.fromEntity(device);
        if (deviceEntity == null) {
            continue;
        }
        buildIdList.add(deviceEntity.buildId);
    }
    String buildId = StringUtils.join(buildIdList, ",");
    String summary = new String();
    if (newTestcaseFailures.size() + continuedTestcaseFailures.size() > 0) {
        summary += "The following test cases failed in the latest test run:<br>";
        // Add new test case failures to top of summary in bold font.
        List<String> sortedNewTestcaseFailures = new ArrayList<>(newTestcaseFailures);
        Collections.sort(sortedNewTestcaseFailures);
        for (String testcaseName : sortedNewTestcaseFailures) {
            summary += "- " + "<b>" + testcaseName + "</b><br>";
        }
        // Add continued test case failures to summary.
        List<String> sortedContinuedTestcaseFailures = new ArrayList<>(continuedTestcaseFailures);
        Collections.sort(sortedContinuedTestcaseFailures);
        for (String testcaseName : sortedContinuedTestcaseFailures) {
            summary += "- " + testcaseName + "<br>";
        }
    }
    if (fixedTestcases.size() > 0) {
        // Add fixed test cases to summary.
        summary += "<br><br>The following test cases were fixed in the latest test run:<br>";
        List<String> sortedFixedTestcases = new ArrayList<>(fixedTestcases);
        Collections.sort(sortedFixedTestcases);
        for (String testcaseName : sortedFixedTestcases) {
            summary += "- <i>" + testcaseName + "</i><br>";
        }
    }
    if (transientTestcaseFailures.size() > 0) {
        // Add transient test case failures to summary.
        summary += "<br><br>The following transient test case failures occured:<br>";
        List<String> sortedTransientTestcaseFailures = new ArrayList<>(transientTestcaseFailures);
        Collections.sort(sortedTransientTestcaseFailures);
        for (String testcaseName : sortedTransientTestcaseFailures) {
            summary += "- " + testcaseName + "<br>";
        }
    }
    if (skippedTestcaseFailures.size() > 0) {
        // Add skipped test case failures to summary.
        summary += "<br><br>The following test cases have not been run since failing:<br>";
        List<String> sortedSkippedTestcaseFailures = new ArrayList<>(skippedTestcaseFailures);
        Collections.sort(sortedSkippedTestcaseFailures);
        for (String testcaseName : sortedSkippedTestcaseFailures) {
            summary += "- " + testcaseName + "<br>";
        }
    }
    Date lastUpload = new Date(TimeUnit.MICROSECONDS.toMillis(mostRecentRun.startTimestamp));
    String uploadDateString = new SimpleDateFormat("MM/dd/yyyy").format(lastUpload);
    String subject = "VTS Test Alert: " + testName + " @ " + uploadDateString;
    if (newTestcaseFailures.size() > 0) {
        String body = "Hello,<br><br>New test case failure(s) in " + testName + " for device build ID(s): " + buildId + ".<br><br>" + summary + footer;
        try {
            messages.add(EmailHelper.composeEmail(emailAddresses, subject, body));
        } catch (MessagingException | UnsupportedEncodingException e) {
            logger.log(Level.WARNING, "Error composing email : ", e);
        }
    } else if (continuedTestcaseFailures.size() > 0) {
        String body = "Hello,<br><br>Continuous test case failure(s) in " + testName + " for device build ID(s): " + buildId + ".<br><br>" + summary + footer;
        try {
            messages.add(EmailHelper.composeEmail(emailAddresses, subject, body));
        } catch (MessagingException | UnsupportedEncodingException e) {
            logger.log(Level.WARNING, "Error composing email : ", e);
        }
    } else if (transientTestcaseFailures.size() > 0) {
        String body = "Hello,<br><br>Transient test case failure(s) in " + testName + " but tests all " + "are passing in the latest device build(s): " + buildId + ".<br><br>" + summary + footer;
        try {
            messages.add(EmailHelper.composeEmail(emailAddresses, subject, body));
        } catch (MessagingException | UnsupportedEncodingException e) {
            logger.log(Level.WARNING, "Error composing email : ", e);
        }
    } else if (fixedTestcases.size() > 0) {
        String body = "Hello,<br><br>All test cases passed in " + testName + " for device build ID(s): " + buildId + "!<br><br>" + summary + footer;
        try {
            messages.add(EmailHelper.composeEmail(emailAddresses, subject, body));
        } catch (MessagingException | UnsupportedEncodingException e) {
            logger.log(Level.WARNING, "Error composing email : ", e);
        }
    }
    return new TestStatusEntity(status.testName, mostRecentRun.startTimestamp, passingTestcaseCount, failingTestCases.size(), failingTestCases);
}
#end_block

#method_before
/**
 * Test simplification of the `~~var` pattern.
 * The transformation tested is implemented in `InstructionSimplifierVisitor::VisitNot`.
 */
// / CHECK-START: long Main.$noinline$NotNot1(long) instruction_simplifier (before)
// / CHECK-DAG:     <<Arg:j\d+>>       ParameterValue
// / CHECK-DAG:     <<ConstNeg1:j\d+>> LongConstant -1
// / CHECK-DAG:     <<Not1:j\d+>>      Xor [<<Arg>>,<<ConstNeg1>>]
// / CHECK-DAG:     <<Not2:j\d+>>      Xor [<<Not1>>,<<ConstNeg1>>]
// / CHECK-DAG:                        Return [<<Not2>>]
// / CHECK-START: long Main.$noinline$NotNot1(long) instruction_simplifier (after)
// / CHECK-DAG:     <<Arg:j\d+>>      ParameterValue
// / CHECK-DAG:                       Return [<<Arg>>]
// / CHECK-START: long Main.$noinline$NotNot1(long) instruction_simplifier (after)
// / CHECK-NOT:                       Not
public static long $noinline$NotNot1(long arg) {
    if (doThrow) {
        throw new Error();
    }
    return ~~arg;
}
#method_after
/**
 * Test simplification of the `~~var` pattern.
 * The transformation tested is implemented in `InstructionSimplifierVisitor::VisitNot`.
 */
// / CHECK-START: long Main.$noinline$NotNot1(long) instruction_simplifier (before)
// / CHECK-DAG:     <<Arg:j\d+>>       ParameterValue
// / CHECK-DAG:     <<ConstNeg1:j\d+>> LongConstant -1
// / CHECK-DAG:     <<Not1:j\d+>>      Xor [<<Arg>>,<<ConstNeg1>>]
// / CHECK-DAG:     <<Not2:j\d+>>      Xor [<<Not1>>,<<ConstNeg1>>]
// / CHECK-DAG:                        Return [<<Not2>>]
// / CHECK-START: long Main.$noinline$NotNot1(long) instruction_simplifier (after)
// / CHECK-DAG:     <<Arg:j\d+>>      ParameterValue
// / CHECK-DAG:                       Return [<<Arg>>]
// / CHECK-START: long Main.$noinline$NotNot1(long) instruction_simplifier (after)
// / CHECK-NOT:                       Xor
public static long $noinline$NotNot1(long arg) {
    if (doThrow) {
        throw new Error();
    }
    return ~~arg;
}
#end_block

#method_before
// / CHECK-START: int Main.$noinline$NotNot2(int) instruction_simplifier (before)
// / CHECK-DAG:     <<Arg:i\d+>>       ParameterValue
// / CHECK-DAG:     <<ConstNeg1:i\d+>> IntConstant -1
// / CHECK-DAG:     <<Not1:i\d+>>      Xor [<<Arg>>,<<ConstNeg1>>]
// / CHECK-DAG:     <<Not2:i\d+>>      Xor [<<Not1>>,<<ConstNeg1>>]
// / CHECK-DAG:     <<Add:i\d+>>       Add [<<Not2>>,<<Not1>>]
// / CHECK-DAG:                        Return [<<Add>>]
// / CHECK-START: int Main.$noinline$NotNot2(int) instruction_simplifier (after)
// / CHECK-DAG:     <<Arg:i\d+>>      ParameterValue
// / CHECK-DAG:     <<Not:i\d+>>      Not [<<Arg>>]
// / CHECK-DAG:     <<Add:i\d+>>      Add [<<Arg>>,<<Not>>]
// / CHECK-DAG:                       Return [<<Add>>]
// / CHECK-START: int Main.$noinline$NotNot2(int) instruction_simplifier (after)
// / CHECK:                           Not
// / CHECK-NOT:                       Not
public static int $noinline$NotNot2(int arg) {
    if (doThrow) {
        throw new Error();
    }
    int temp = ~arg;
    return temp + ~temp;
}
#method_after
// / CHECK-START: int Main.$noinline$NotNot2(int) instruction_simplifier (before)
// / CHECK-DAG:     <<Arg:i\d+>>       ParameterValue
// / CHECK-DAG:     <<ConstNeg1:i\d+>> IntConstant -1
// / CHECK-DAG:     <<Not1:i\d+>>      Xor [<<Arg>>,<<ConstNeg1>>]
// / CHECK-DAG:     <<Not2:i\d+>>      Xor [<<Not1>>,<<ConstNeg1>>]
// / CHECK-DAG:     <<Add:i\d+>>       Add [<<Not2>>,<<Not1>>]
// / CHECK-DAG:                        Return [<<Add>>]
// / CHECK-START: int Main.$noinline$NotNot2(int) instruction_simplifier (after)
// / CHECK-DAG:     <<Arg:i\d+>>      ParameterValue
// / CHECK-DAG:     <<Not:i\d+>>      Not [<<Arg>>]
// / CHECK-DAG:     <<Add:i\d+>>      Add [<<Arg>>,<<Not>>]
// / CHECK-DAG:                       Return [<<Add>>]
// / CHECK-START: int Main.$noinline$NotNot2(int) instruction_simplifier (after)
// / CHECK:                           Not
// / CHECK-NOT:                       Not
// / CHECK-START: int Main.$noinline$NotNot2(int) instruction_simplifier (after)
// / CHECK-NOT:                       Xor
public static int $noinline$NotNot2(int arg) {
    if (doThrow) {
        throw new Error();
    }
    int temp = ~arg;
    return temp + ~temp;
}
#end_block

#method_before
/*
   * Test simplification of double Boolean negation. Note that sometimes
   * both negations can be removed but we only expect the simplifier to
   * remove the second.
   */
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier (before)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:     <<Const1:i\d+>>    IntConstant 0
// / CHECK-DAG:     <<Result:z\d+>>    InvokeStaticOrDirect method_name:Main.NegateValue
// / CHECK-DAG:     <<NotResult:z\d+>> NotEqual [<<Result>>,<<Const1>>]
// / CHECK-DAG:                        If [<<NotResult>>]
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier (after)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:     <<Result:z\d+>>    InvokeStaticOrDirect method_name:Main.NegateValue
// / CHECK-NOT:                        NotEqual
// / CHECK-DAG:                        Return
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier$after_inlining (before)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-NOT:                        BooleanNot [<<Arg>>]
// / CHECK-DAG:                        Return
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier$after_inlining (after)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK:                            BooleanNot [<<Arg>>]
// / CHECK-NEXT:                       Goto
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) dead_code_elimination$final (after)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-NOT:                        BooleanNot [<<Arg>>]
// / CHECK-DAG:                        Return [<<Arg>>]
public static boolean NegateValue(boolean arg) {
    return !arg;
}
#method_after
/*
   * Test simplification of double Boolean negation. Note that sometimes
   * both negations can be removed but we only expect the simplifier to
   * remove the second.
   */
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier (before)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:     <<Const1:i\d+>>    IntConstant 0
// / CHECK-DAG:     <<Result:z\d+>>    InvokeStaticOrDirect method_name:Main.NegateValue
// / CHECK-DAG:     <<NotResult:z\d+>> NotEqual [<<Result>>,<<Const1>>]
// / CHECK-DAG:                        If [<<NotResult>>]
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier (after)
// / CHECK-NOT:                        NotEqual
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier (after)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:     <<Result:z\d+>>    InvokeStaticOrDirect method_name:Main.NegateValue
// / CHECK-DAG:     <<Const0:i\d+>>    IntConstant 0
// / CHECK-DAG:     <<Const1:i\d+>>    IntConstant 1
// / CHECK-DAG:     <<Phi:i\d+>>       Phi [<<Const1>>,<<Const0>>]
// / CHECK-DAG:                        Return [<<Phi>>]
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier$after_inlining (before)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-NOT:                        BooleanNot [<<Arg>>]
// / CHECK-NOT:                        Phi
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier$after_inlining (before)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-DAG:     <<Const0:i\d+>>    IntConstant 0
// / CHECK-DAG:     <<Const1:i\d+>>    IntConstant 1
// / CHECK-DAG:     <<Sel:i\d+>>       Select [<<Const1>>,<<Const0>>,<<Arg>>]
// / CHECK-DAG:     <<Sel2:i\d+>>      Select [<<Const1>>,<<Const0>>,<<Sel>>]
// / CHECK-DAG:                        Return [<<Sel2>>]
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier$after_inlining (after)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK:                            BooleanNot [<<Arg>>]
// / CHECK-NEXT:                       Goto
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) instruction_simplifier$after_inlining (after)
// / CHECK-NOT:                        Select
// / CHECK-START: boolean Main.$noinline$NotNotBool(boolean) dead_code_elimination$final (after)
// / CHECK-DAG:     <<Arg:z\d+>>       ParameterValue
// / CHECK-NOT:                        BooleanNot [<<Arg>>]
// / CHECK-DAG:                        Return [<<Arg>>]
public static boolean NegateValue(boolean arg) {
    return !arg;
}
#end_block

#method_before
public void test_DirectByteBuffer_PhantomReference() throws Exception {
    ByteBuffer bb = jniNewDirectByteBuffer();
    ReferenceQueue rq = new ReferenceQueue();
    PhantomReference pr = new PhantomReference(bb, rq);
    // Phantom reference is valid
    induceFinalization();
    assertTrue(!pr.isEnqueued());
    // Create a read only buffer from jni buffer, clear
    // original reference. We expect to phantom reference to be valid
    ByteBuffer otherBuffer = bb.asReadOnlyBuffer();
    bb = null;
    induceFinalization();
    assertTrue(!pr.isEnqueued());
    // Clear reference to derviced buffer, phantom reference should
    // be enqueued
    otherBuffer = null;
    induceFinalization();
    assertTrue(pr.isEnqueued());
}
#method_after
public void test_DirectByteBuffer_PhantomReference() throws Exception {
    ByteBuffer bb = jniNewDirectByteBuffer();
    ReferenceQueue rq = new ReferenceQueue();
    PhantomReference pr = new PhantomReference(bb, rq);
    // The phantom reference pr should still be valid while 'bb' still
    // has a strong reference to the ByteBuffer.
    FinalizationTester.induceFinalization();
    assertTrue(!pr.isEnqueued());
    // Create a read-only, derived buffer from the jni buffer and clear original
    // reference. The phantom reference should still be valid because the
    // 'otherBuffer' references the MemoryRef which contains reference to buffer
    // previously stored in 'bb'.
    ByteBuffer otherBuffer = bb.asReadOnlyBuffer();
    bb = null;
    FinalizationTester.induceFinalization();
    assertTrue(!pr.isEnqueued());
    // Clear reference to derived buffer. The phantom reference should be
    // eligible for collection because there are no strong references left.
    otherBuffer = null;
    FinalizationTester.induceFinalization();
    assertTrue(pr.isEnqueued());
}
#end_block

#method_before
public void init(RemoteDevices remoteDevices) {
    if (mProfileConnectionState == null) {
        mProfileConnectionState = new HashMap<Integer, Pair<Integer, Integer>>();
    } else {
        mProfileConnectionState.clear();
    }
    mRemoteDevices = remoteDevices;
    mReceiver = new BroadcastReceiver() {

        @Override
        public void onReceive(Context context, Intent intent) {
            Log.d(TAG, "Received intent " + intent);
            String action = intent.getAction();
            if (BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.HEADSET, intent);
            } else if (BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.A2DP, intent);
            } else if (BluetoothHeadsetClient.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.HEADSET_CLIENT, intent);
            } else if (BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.A2DP_SINK, intent);
            } else if (BluetoothInputHost.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.INPUT_HOST, intent);
            } else if (BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.INPUT_DEVICE, intent);
            } else if (BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.AVRCP_CONTROLLER, intent);
            } else if (BluetoothPan.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.PAN, intent);
            } else if (BluetoothMap.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.MAP, intent);
            } else if (BluetoothMapClient.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.MAP_CLIENT, intent);
            } else if (BluetoothSap.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.SAP, intent);
            } else if (BluetoothPbapClient.ACTION_CONNECTION_STATE_CHANGED.equals(action)) {
                sendConnectionStateChange(BluetoothProfile.PBAP_CLIENT, intent);
            }
        }
    };
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothHeadsetClient.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothInputHost.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothPan.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothMap.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothMapClient.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothSap.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothPbapClient.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothDevice.ACTION_UUID);
    mService.registerReceiver(mReceiver, filter);
}
#method_after
public void init(RemoteDevices remoteDevices) {
    if (mProfileConnectionState == null) {
        mProfileConnectionState = new HashMap<Integer, Pair<Integer, Integer>>();
    } else {
        mProfileConnectionState.clear();
    }
    mRemoteDevices = remoteDevices;
    IntentFilter filter = new IntentFilter();
    filter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothHeadsetClient.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothA2dpSink.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothInputHost.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothInputDevice.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothAvrcpController.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothPan.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothMap.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothMapClient.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothSap.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothPbapClient.ACTION_CONNECTION_STATE_CHANGED);
    filter.addAction(BluetoothDevice.ACTION_UUID);
    mService.registerReceiver(mReceiver, filter);
    mReceiverRegistered = true;
}
#end_block

#method_before
public void cleanup() {
    mRemoteDevices = null;
    if (mProfileConnectionState != null) {
        mProfileConnectionState.clear();
        mProfileConnectionState = null;
    }
    if (mReceiver != null) {
        mService.unregisterReceiver(mReceiver);
        mReceiver = null;
    }
    mService = null;
    mBondedDevices.clear();
}
#method_after
public void cleanup() {
    mRemoteDevices = null;
    if (mProfileConnectionState != null) {
        mProfileConnectionState.clear();
        mProfileConnectionState = null;
    }
    if (mReceiverRegistered) {
        mService.unregisterReceiver(mReceiver);
        mReceiverRegistered = false;
    }
    mService = null;
    mBondedDevices.clear();
}
#end_block

#method_before
private static Collection<Integer> getUpstreamIfaceTypes(Context ctx, int dunCheck) {
    final int[] ifaceTypes = ctx.getResources().getIntArray(com.android.internal.R.array.config_tether_upstream_types);
    final ArrayList<Integer> upstreamIfaceTypes = new ArrayList<>(ifaceTypes.length);
    for (int i : ifaceTypes) {
        switch(i) {
            case TYPE_MOBILE:
            case TYPE_MOBILE_HIPRI:
                if (dunCheck == DUN_REQUIRED)
                    continue;
                break;
            case TYPE_MOBILE_DUN:
                if (dunCheck == DUN_NOT_REQUIRED)
                    continue;
                break;
        }
        upstreamIfaceTypes.add(i);
    }
    // specified by configuration resources.
    if (dunCheck == DUN_REQUIRED) {
        if (!upstreamIfaceTypes.contains(TYPE_MOBILE_DUN)) {
            upstreamIfaceTypes.add(TYPE_MOBILE_DUN);
        }
    } else if (dunCheck == DUN_NOT_REQUIRED) {
        if (!upstreamIfaceTypes.contains(TYPE_MOBILE)) {
            upstreamIfaceTypes.add(TYPE_MOBILE);
        }
        if (!upstreamIfaceTypes.contains(TYPE_MOBILE_HIPRI)) {
            upstreamIfaceTypes.add(TYPE_MOBILE_HIPRI);
        }
    } else {
        // cellular interface types are found in the upstream interface types.
        if (!(upstreamIfaceTypes.contains(TYPE_MOBILE_DUN) || upstreamIfaceTypes.contains(TYPE_MOBILE) || upstreamIfaceTypes.contains(TYPE_MOBILE_HIPRI))) {
            upstreamIfaceTypes.add(TYPE_MOBILE);
            upstreamIfaceTypes.add(TYPE_MOBILE_HIPRI);
        }
    }
    // If any upstreams are defined, always make sure our good friend Ethernet is present.
    if (!upstreamIfaceTypes.isEmpty() && !upstreamIfaceTypes.contains(TYPE_ETHERNET)) {
        upstreamIfaceTypes.add(0, TYPE_ETHERNET);
    }
    return upstreamIfaceTypes;
}
#method_after
private static Collection<Integer> getUpstreamIfaceTypes(Context ctx, int dunCheck) {
    final int[] ifaceTypes = ctx.getResources().getIntArray(com.android.internal.R.array.config_tether_upstream_types);
    final ArrayList<Integer> upstreamIfaceTypes = new ArrayList<>(ifaceTypes.length);
    for (int i : ifaceTypes) {
        switch(i) {
            case TYPE_MOBILE:
            case TYPE_MOBILE_HIPRI:
                if (dunCheck == DUN_REQUIRED)
                    continue;
                break;
            case TYPE_MOBILE_DUN:
                if (dunCheck == DUN_NOT_REQUIRED)
                    continue;
                break;
        }
        upstreamIfaceTypes.add(i);
    }
    // specified by configuration resources.
    if (dunCheck == DUN_REQUIRED) {
        appendIfNotPresent(upstreamIfaceTypes, TYPE_MOBILE_DUN);
    } else if (dunCheck == DUN_NOT_REQUIRED) {
        appendIfNotPresent(upstreamIfaceTypes, TYPE_MOBILE);
        appendIfNotPresent(upstreamIfaceTypes, TYPE_MOBILE_HIPRI);
    } else {
        // cellular interface types are found in the upstream interface types.
        if (!(containsOneOf(upstreamIfaceTypes, TYPE_MOBILE_DUN, TYPE_MOBILE, TYPE_MOBILE_HIPRI))) {
            upstreamIfaceTypes.add(TYPE_MOBILE);
            upstreamIfaceTypes.add(TYPE_MOBILE_HIPRI);
        }
    }
    // Always make sure our good friend Ethernet is present.
    // TODO: consider unilaterally forcing this at the front.
    prependIfNotPresent(upstreamIfaceTypes, TYPE_ETHERNET);
    return upstreamIfaceTypes;
}
#end_block

#method_before
@Test
public void testNoDefinedUpstreamTypesAddsEthernet() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] {});
    mHasTelephonyManager = false;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_UNSPECIFIED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext, mLog);
    // This is because the code always adds some kind of mobile upstream,
    // be it DUN or, in this case where we use DUN_UNSPECIFIED, both vanilla
    // and hipri mobile types. Consequently, Ethernet always appears to be
    // safe to add, though all of this behaviour might be surprising.
    assertEquals(3, cfg.preferredUpstreamIfaceTypes.size());
    final Iterator<Integer> upstreamIterator = cfg.preferredUpstreamIfaceTypes.iterator();
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_ETHERNET, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_MOBILE, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_MOBILE_HIPRI, upstreamIterator.next().intValue());
    assertFalse(upstreamIterator.hasNext());
}
#method_after
@Test
public void testNoDefinedUpstreamTypesAddsEthernet() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] {});
    mHasTelephonyManager = false;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_UNSPECIFIED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext, mLog);
    final Iterator<Integer> upstreamIterator = cfg.preferredUpstreamIfaceTypes.iterator();
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_ETHERNET, upstreamIterator.next().intValue());
    // The following is because the code always adds some kind of mobile
    // upstream, be it DUN or, in this case where we use DUN_UNSPECIFIED,
    // both vanilla and hipri mobile types.
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_MOBILE, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_MOBILE_HIPRI, upstreamIterator.next().intValue());
    assertFalse(upstreamIterator.hasNext());
}
#end_block

#method_before
@Test
public void testDefinedUpstreamTypesSansEthernetAddsEthernet() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] { TYPE_WIFI, TYPE_MOBILE_HIPRI });
    mHasTelephonyManager = false;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_UNSPECIFIED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext, mLog);
    assertEquals(3, cfg.preferredUpstreamIfaceTypes.size());
    final Iterator<Integer> upstreamIterator = cfg.preferredUpstreamIfaceTypes.iterator();
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_ETHERNET, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_WIFI, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_MOBILE_HIPRI, upstreamIterator.next().intValue());
    assertFalse(upstreamIterator.hasNext());
}
#method_after
@Test
public void testDefinedUpstreamTypesSansEthernetAddsEthernet() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] { TYPE_WIFI, TYPE_MOBILE_HIPRI });
    mHasTelephonyManager = false;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_UNSPECIFIED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext, mLog);
    final Iterator<Integer> upstreamIterator = cfg.preferredUpstreamIfaceTypes.iterator();
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_ETHERNET, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_WIFI, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_MOBILE_HIPRI, upstreamIterator.next().intValue());
    assertFalse(upstreamIterator.hasNext());
}
#end_block

#method_before
@Test
public void testDefinedUpstreamTypesWithEthernetDoesNotAddEthernet() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] { TYPE_WIFI, TYPE_ETHERNET, TYPE_MOBILE_HIPRI });
    mHasTelephonyManager = false;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_UNSPECIFIED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext, mLog);
    assertEquals(3, cfg.preferredUpstreamIfaceTypes.size());
    final Iterator<Integer> upstreamIterator = cfg.preferredUpstreamIfaceTypes.iterator();
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_WIFI, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_ETHERNET, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_MOBILE_HIPRI, upstreamIterator.next().intValue());
    assertFalse(upstreamIterator.hasNext());
}
#method_after
@Test
public void testDefinedUpstreamTypesWithEthernetDoesNotAddEthernet() {
    when(mResources.getIntArray(com.android.internal.R.array.config_tether_upstream_types)).thenReturn(new int[] { TYPE_WIFI, TYPE_ETHERNET, TYPE_MOBILE_HIPRI });
    mHasTelephonyManager = false;
    when(mTelephonyManager.getTetherApnRequired()).thenReturn(DUN_UNSPECIFIED);
    final TetheringConfiguration cfg = new TetheringConfiguration(mMockContext, mLog);
    final Iterator<Integer> upstreamIterator = cfg.preferredUpstreamIfaceTypes.iterator();
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_WIFI, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_ETHERNET, upstreamIterator.next().intValue());
    assertTrue(upstreamIterator.hasNext());
    assertEquals(TYPE_MOBILE_HIPRI, upstreamIterator.next().intValue());
    assertFalse(upstreamIterator.hasNext());
}
#end_block

#method_before
private void handleTransferEvent(Intent intent, int deviceType) {
    String action = intent.getAction();
    int id = intent.getIntExtra(EXTRA_TRANSFER_ID, -1);
    String sourceAddress = intent.getStringExtra(EXTRA_ADDRESS);
    if (sourceAddress == null)
        return;
    if (mTransferManager == null) {
        // the transfer was cancelled. We need to tell BT OPP to stop transferring.
        if (id != -1) {
            if (deviceType == BeamTransferManager.DATA_LINK_TYPE_BLUETOOTH) {
                if (DBG)
                    Log.d(TAG, "Didn't find transfer, stopping");
                Intent cancelIntent = new Intent(ACTION_STOP_BLUETOOTH_TRANSFER);
                cancelIntent.putExtra(EXTRA_TRANSFER_ID, id);
                cancelIntent.setPackage(BLUETOOTH_PACKAGE);
                mContext.sendBroadcast(cancelIntent);
            }
        }
        return;
    }
    mTransferManager.setBluetoothTransferId(id);
    if (action.equals(ACTION_TRANSFER_DONE)) {
        int handoverStatus = intent.getIntExtra(EXTRA_TRANSFER_STATUS, HANDOVER_TRANSFER_STATUS_FAILURE);
        if (handoverStatus == HANDOVER_TRANSFER_STATUS_SUCCESS) {
            String uriString = intent.getStringExtra(EXTRA_TRANSFER_URI);
            String mimeType = intent.getStringExtra(EXTRA_TRANSFER_MIMETYPE);
            Uri uri = Uri.parse(uriString);
            if (uri != null && uri.getScheme() == null) {
                uri = Uri.fromFile(new File(uri.getPath()));
            }
            mTransferManager.finishTransfer(true, uri, mimeType);
        } else {
            mTransferManager.finishTransfer(false, null, null);
        }
    } else if (action.equals(ACTION_TRANSFER_PROGRESS)) {
        float progress = intent.getFloatExtra(EXTRA_TRANSFER_PROGRESS, 0.0f);
        mTransferManager.updateFileProgress(progress);
    } else if (action.equals(ACTION_HANDOVER_STARTED)) {
        int count = intent.getIntExtra(EXTRA_OBJECT_COUNT, 0);
        if (count > 0) {
            mTransferManager.setObjectCount(count);
        }
    }
}
#method_after
private void handleTransferEvent(Intent intent, int deviceType) {
    String action = intent.getAction();
    int id = intent.getIntExtra(EXTRA_TRANSFER_ID, -1);
    String sourceAddress = intent.getStringExtra(EXTRA_ADDRESS);
    if (sourceAddress == null)
        return;
    if (mTransferManager == null) {
        // the transfer was cancelled. We need to tell BT OPP to stop transferring.
        if (id != -1) {
            if (deviceType == BeamTransferManager.DATA_LINK_TYPE_BLUETOOTH) {
                if (DBG)
                    Log.d(TAG, "Didn't find transfer, stopping");
                Intent cancelIntent = new Intent(ACTION_STOP_BLUETOOTH_TRANSFER);
                cancelIntent.putExtra(EXTRA_TRANSFER_ID, id);
                cancelIntent.setPackage(mContext.getString(R.string.bluetooth_package));
                mContext.sendBroadcast(cancelIntent);
            }
        }
        return;
    }
    mTransferManager.setBluetoothTransferId(id);
    if (action.equals(ACTION_TRANSFER_DONE)) {
        int handoverStatus = intent.getIntExtra(EXTRA_TRANSFER_STATUS, HANDOVER_TRANSFER_STATUS_FAILURE);
        if (handoverStatus == HANDOVER_TRANSFER_STATUS_SUCCESS) {
            String uriString = intent.getStringExtra(EXTRA_TRANSFER_URI);
            String mimeType = intent.getStringExtra(EXTRA_TRANSFER_MIMETYPE);
            Uri uri = Uri.parse(uriString);
            if (uri != null && uri.getScheme() == null) {
                uri = Uri.fromFile(new File(uri.getPath()));
            }
            mTransferManager.finishTransfer(true, uri, mimeType);
        } else {
            mTransferManager.finishTransfer(false, null, null);
        }
    } else if (action.equals(ACTION_TRANSFER_PROGRESS)) {
        float progress = intent.getFloatExtra(EXTRA_TRANSFER_PROGRESS, 0.0f);
        mTransferManager.updateFileProgress(progress);
    } else if (action.equals(ACTION_HANDOVER_STARTED)) {
        int count = intent.getIntExtra(EXTRA_OBJECT_COUNT, 0);
        if (count > 0) {
            mTransferManager.setObjectCount(count);
        }
    }
}
#end_block

#method_before
public void stop() {
    final boolean hadBeenStarted = started();
    mUpstreamLinkProperties = null;
    mHwInterface.stopOffloadControl();
    mControlInitialized = false;
    mConfigInitialized = false;
    if (hadBeenStarted)
        mLog.log("tethering offload stopped");
}
#method_after
public void stop() {
    final boolean wasStarted = started();
    mUpstreamLinkProperties = null;
    mHwInterface.stopOffloadControl();
    mControlInitialized = false;
    mConfigInitialized = false;
    if (wasStarted)
        mLog.log("tethering offload stopped");
}
#end_block

#method_before
private boolean pushUpstreamParameters() {
    if (mUpstreamLinkProperties == null) {
        return mHwInterface.setUpstreamParameters(null, null, null, null);
    }
    // A stacked interface cannot be an upstream for hardware offload.
    // Consequently, we examine only the primary interface name, look at
    // getAddresses() rather than getAllAddresses(), and check getRoutes()
    // rather than getAllRoutes().
    final String iface = mUpstreamLinkProperties.getInterfaceName();
    final ArrayList<String> v6gateways = new ArrayList<>();
    String v4addr = null;
    String v4gateway = null;
    for (InetAddress ip : mUpstreamLinkProperties.getAddresses()) {
        if (ip instanceof Inet4Address) {
            v4addr = ip.getHostAddress();
            break;
        }
    }
    // Find the gateway addresses of all default routes of either address family.
    for (RouteInfo ri : mUpstreamLinkProperties.getRoutes()) {
        if (!ri.hasGateway())
            continue;
        final String gateway = ri.getGateway().getHostAddress();
        if (ri.isIPv4Default()) {
            v4gateway = gateway;
        } else if (ri.isIPv6Default()) {
            v6gateways.add(gateway);
        }
    }
    return mHwInterface.setUpstreamParameters(iface, v4addr, v4gateway, v6gateways);
}
#method_after
private boolean pushUpstreamParameters() {
    if (mUpstreamLinkProperties == null) {
        return mHwInterface.setUpstreamParameters(null, null, null, null);
    }
    // A stacked interface cannot be an upstream for hardware offload.
    // Consequently, we examine only the primary interface name, look at
    // getAddresses() rather than getAllAddresses(), and check getRoutes()
    // rather than getAllRoutes().
    final String iface = mUpstreamLinkProperties.getInterfaceName();
    final ArrayList<String> v6gateways = new ArrayList<>();
    String v4addr = null;
    String v4gateway = null;
    for (InetAddress ip : mUpstreamLinkProperties.getAddresses()) {
        if (ip instanceof Inet4Address) {
            v4addr = ip.getHostAddress();
            break;
        }
    }
    // Find the gateway addresses of all default routes of either address family.
    for (RouteInfo ri : mUpstreamLinkProperties.getRoutes()) {
        if (!ri.hasGateway())
            continue;
        final String gateway = ri.getGateway().getHostAddress();
        if (ri.isIPv4Default()) {
            v4gateway = gateway;
        } else if (ri.isIPv6Default()) {
            v6gateways.add(gateway);
        }
    }
    return mHwInterface.setUpstreamParameters(iface, v4addr, v4gateway, (v6gateways.isEmpty() ? null : v6gateways));
}
#end_block

#method_before
private boolean configureIPv4(boolean enabled) {
    if (VDBG)
        Log.d(TAG, "configureIPv4(" + enabled + ")");
    String ipAsString = null;
    int prefixLen = 0;
    if (mInterfaceType == ConnectivityManager.TETHERING_USB) {
        ipAsString = USB_NEAR_IFACE_ADDR;
        prefixLen = USB_PREFIX_LENGTH;
    } else if (mInterfaceType == ConnectivityManager.TETHERING_WIFI) {
        ipAsString = WIFI_HOST_IFACE_ADDR;
        prefixLen = WIFI_HOST_IFACE_PREFIX_LENGTH;
    } else {
        // Nothing to do, BT does this elsewhere.
        return true;
    }
    LinkAddress linkAddr = null;
    try {
        final InterfaceConfiguration ifcg = mNMService.getInterfaceConfig(mIfaceName);
        if (ifcg != null) {
            InetAddress addr = NetworkUtils.numericToInetAddress(ipAsString);
            linkAddr = new LinkAddress(addr, prefixLen);
            ifcg.setLinkAddress(linkAddr);
            if (mInterfaceType == ConnectivityManager.TETHERING_WIFI) {
                // The WiFi stack has ownership of the interface up/down state.
                // It is unclear whether the bluetooth or USB stacks will manage their own
                // state.
                ifcg.ignoreInterfaceUpDownStatus();
            } else {
                if (enabled) {
                    ifcg.setInterfaceUp();
                } else {
                    ifcg.setInterfaceDown();
                }
            }
            ifcg.clearFlag("running");
            mNMService.setInterfaceConfig(mIfaceName, ifcg);
        } else {
            mLog.e("Received null interface config");
            return false;
        }
    } catch (Exception e) {
        mLog.e("Error configuring interface " + e);
        return false;
    }
    if (enabled) {
        mLinkProperties.addLinkAddress(linkAddr);
        mLinkProperties.addRoute(new RouteInfo(linkAddr));
    } else {
        mLinkProperties.removeLinkAddress(linkAddr);
        mLinkProperties.removeRoute(new RouteInfo(linkAddr));
    }
    return true;
}
#method_after
private boolean configureIPv4(boolean enabled) {
    if (VDBG)
        Log.d(TAG, "configureIPv4(" + enabled + ")");
    // TODO: Replace this hard-coded information with dynamically selected
    // config passed down to us by a higher layer IP-coordinating element.
    String ipAsString = null;
    int prefixLen = 0;
    if (mInterfaceType == ConnectivityManager.TETHERING_USB) {
        ipAsString = USB_NEAR_IFACE_ADDR;
        prefixLen = USB_PREFIX_LENGTH;
    } else if (mInterfaceType == ConnectivityManager.TETHERING_WIFI) {
        ipAsString = WIFI_HOST_IFACE_ADDR;
        prefixLen = WIFI_HOST_IFACE_PREFIX_LENGTH;
    } else {
        // Nothing to do, BT does this elsewhere.
        return true;
    }
    final LinkAddress linkAddr;
    try {
        final InterfaceConfiguration ifcg = mNMService.getInterfaceConfig(mIfaceName);
        if (ifcg == null) {
            mLog.e("Received null interface config");
            return false;
        }
        InetAddress addr = NetworkUtils.numericToInetAddress(ipAsString);
        linkAddr = new LinkAddress(addr, prefixLen);
        ifcg.setLinkAddress(linkAddr);
        if (mInterfaceType == ConnectivityManager.TETHERING_WIFI) {
            // The WiFi stack has ownership of the interface up/down state.
            // It is unclear whether the Bluetooth or USB stacks will manage their own
            // state.
            ifcg.ignoreInterfaceUpDownStatus();
        } else {
            if (enabled) {
                ifcg.setInterfaceUp();
            } else {
                ifcg.setInterfaceDown();
            }
        }
        ifcg.clearFlag("running");
        mNMService.setInterfaceConfig(mIfaceName, ifcg);
    } catch (Exception e) {
        mLog.e("Error configuring interface " + e);
        return false;
    }
    // Directly-connected route.
    final RouteInfo route = new RouteInfo(linkAddr);
    if (enabled) {
        mLinkProperties.addLinkAddress(linkAddr);
        mLinkProperties.addRoute(route);
    } else {
        mLinkProperties.removeLinkAddress(linkAddr);
        mLinkProperties.removeRoute(route);
    }
    return true;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            switch(message.arg1) {
                case IControlsTethering.STATE_LOCAL_ONLY:
                    transitionTo(mLocalHotspotState);
                    break;
                case IControlsTethering.STATE_TETHERED:
                    transitionTo(mTetheredState);
                    break;
                default:
                    mLog.e("Invalid tethering interface serving state specified.");
            }
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            break;
        case CMD_IPV6_TETHER_UPDATE:
            mIPv6TetherSvc.updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            switch(message.arg1) {
                case IControlsTethering.STATE_LOCAL_ONLY:
                    transitionTo(mLocalHotspotState);
                    break;
                case IControlsTethering.STATE_TETHERED:
                    transitionTo(mTetheredState);
                    break;
                default:
                    mLog.e("Invalid tethering interface serving state specified.");
            }
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            break;
        case CMD_IPV6_TETHER_UPDATE:
            updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
@Override
public void enter() {
    if (!configureIPv4(true)) {
        mLastError = ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR;
        return;
    }
    try {
        mNMService.tetherInterface(mIfaceName);
    } catch (Exception e) {
        mLog.e("Error Tethering: " + e);
        mLastError = ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR;
        return;
    }
    if (!mIPv6TetherSvc.start()) {
        mLog.e("Failed to start IPv6TetheringInterfaceServices");
        // TODO: Make this a fatal error once Bluetooth IPv6 is sorted.
        return;
    }
}
#method_after
@Override
public void enter() {
    if (!startIPv4()) {
        mLastError = ConnectivityManager.TETHER_ERROR_IFACE_CFG_ERROR;
        return;
    }
    try {
        mNMService.tetherInterface(mIfaceName);
    } catch (Exception e) {
        mLog.e("Error Tethering: " + e);
        mLastError = ConnectivityManager.TETHER_ERROR_TETHER_IFACE_ERROR;
        return;
    }
    if (!startIPv6()) {
        mLog.e("Failed to startIPv6");
        // TODO: Make this a fatal error once Bluetooth IPv6 is sorted.
        return;
    }
}
#end_block

#method_before
@Override
public void exit() {
    // Note that at this point, we're leaving the tethered state.  We can fail any
    // of these operations, but it doesn't really change that we have to try them
    // all in sequence.
    mIPv6TetherSvc.stop();
    try {
        mNMService.untetherInterface(mIfaceName);
    } catch (Exception e) {
        mLastError = ConnectivityManager.TETHER_ERROR_UNTETHER_IFACE_ERROR;
        mLog.e("Failed to untether interface: " + e);
    }
    configureIPv4(false);
    resetLinkProperties();
}
#method_after
@Override
public void exit() {
    // Note that at this point, we're leaving the tethered state.  We can fail any
    // of these operations, but it doesn't really change that we have to try them
    // all in sequence.
    stopIPv6();
    try {
        mNMService.untetherInterface(mIfaceName);
    } catch (Exception e) {
        mLastError = ConnectivityManager.TETHER_ERROR_UNTETHER_IFACE_ERROR;
        mLog.e("Failed to untether interface: " + e);
    }
    stopIPv4();
    resetLinkProperties();
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case CMD_TETHER_UNREQUESTED:
            transitionTo(mInitialState);
            if (DBG)
                Log.d(TAG, "Untethered (unrequested)" + mIfaceName);
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            if (DBG)
                Log.d(TAG, "Untethered (ifdown)" + mIfaceName);
            break;
        case CMD_IPV6_TETHER_UPDATE:
            mIPv6TetherSvc.updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            sendLinkProperties();
            break;
        case CMD_IP_FORWARDING_ENABLE_ERROR:
        case CMD_IP_FORWARDING_DISABLE_ERROR:
        case CMD_START_TETHERING_ERROR:
        case CMD_STOP_TETHERING_ERROR:
        case CMD_SET_DNS_FORWARDERS_ERROR:
            mLastError = ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
            transitionTo(mInitialState);
            break;
        default:
            return false;
    }
    return true;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case CMD_TETHER_UNREQUESTED:
            transitionTo(mInitialState);
            if (DBG)
                Log.d(TAG, "Untethered (unrequested)" + mIfaceName);
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            if (DBG)
                Log.d(TAG, "Untethered (ifdown)" + mIfaceName);
            break;
        case CMD_IPV6_TETHER_UPDATE:
            updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            sendLinkProperties();
            break;
        case CMD_IP_FORWARDING_ENABLE_ERROR:
        case CMD_IP_FORWARDING_DISABLE_ERROR:
        case CMD_START_TETHERING_ERROR:
        case CMD_STOP_TETHERING_ERROR:
        case CMD_SET_DNS_FORWARDERS_ERROR:
            mLastError = ConnectivityManager.TETHER_ERROR_MASTER_ERROR;
            transitionTo(mInitialState);
            break;
        default:
            return false;
    }
    return true;
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    if (super.processMessage(message))
        return true;
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLog.e("CMD_TETHER_REQUESTED while already tethering.");
            break;
        case CMD_TETHER_CONNECTION_CHANGED:
            String newUpstreamIfaceName = (String) (message.obj);
            if ((mMyUpstreamIfaceName == null && newUpstreamIfaceName == null) || (mMyUpstreamIfaceName != null && mMyUpstreamIfaceName.equals(newUpstreamIfaceName))) {
                if (VDBG)
                    Log.d(TAG, "Connection changed noop - dropping");
                break;
            }
            cleanupUpstream();
            if (newUpstreamIfaceName != null) {
                try {
                    mNMService.enableNat(mIfaceName, newUpstreamIfaceName);
                    mNMService.startInterfaceForwarding(mIfaceName, newUpstreamIfaceName);
                } catch (Exception e) {
                    mLog.e("Exception enabling NAT: " + e);
                    cleanupUpstreamInterface(newUpstreamIfaceName);
                    mLastError = ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;
                    transitionTo(mInitialState);
                    return true;
                }
            }
            mMyUpstreamIfaceName = newUpstreamIfaceName;
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    if (super.processMessage(message))
        return true;
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLog.e("CMD_TETHER_REQUESTED while already tethering.");
            break;
        case CMD_TETHER_CONNECTION_CHANGED:
            String newUpstreamIfaceName = (String) (message.obj);
            if ((mMyUpstreamIfaceName == null && newUpstreamIfaceName == null) || (mMyUpstreamIfaceName != null && mMyUpstreamIfaceName.equals(newUpstreamIfaceName))) {
                if (VDBG)
                    Log.d(TAG, "Connection changed noop - dropping");
                break;
            }
            cleanupUpstream();
            if (newUpstreamIfaceName != null) {
                try {
                    mNMService.enableNat(mIfaceName, newUpstreamIfaceName);
                    mNMService.startInterfaceForwarding(mIfaceName, newUpstreamIfaceName);
                } catch (Exception e) {
                    mLog.e("Exception enabling NAT: " + e);
                    cleanupUpstreamInterface(newUpstreamIfaceName);
                    mLastError = ConnectivityManager.TETHER_ERROR_ENABLE_NAT_ERROR;
                    transitionTo(mInitialState);
                    return true;
                }
            }
            mMyUpstreamIfaceName = newUpstreamIfaceName;
            break;
        default:
            return false;
    }
    return true;
}
#end_block

#method_before
private void handleWifiApAction(Intent intent) {
    final int curState = intent.getIntExtra(EXTRA_WIFI_AP_STATE, WIFI_AP_STATE_DISABLED);
    final String ifname = intent.getStringExtra(EXTRA_WIFI_AP_INTERFACE_NAME);
    final int ipmode = intent.getIntExtra(EXTRA_WIFI_AP_MODE, IFACE_IP_MODE_UNSPECIFIED);
    synchronized (Tethering.this.mPublicSync) {
        switch(curState) {
            case WifiManager.WIFI_AP_STATE_ENABLING:
                // We can see this state on the way to both enabled and failure states.
                break;
            case WifiManager.WIFI_AP_STATE_ENABLED:
                enableWifiIpServingLocked(ifname, ipmode);
                break;
            case WifiManager.WIFI_AP_STATE_DISABLED:
            case WifiManager.WIFI_AP_STATE_DISABLING:
            case WifiManager.WIFI_AP_STATE_FAILED:
            default:
                disableWifiIpServingLocked(curState);
                break;
        }
    }
}
#method_after
private void handleWifiApAction(Intent intent) {
    final int curState = intent.getIntExtra(EXTRA_WIFI_AP_STATE, WIFI_AP_STATE_DISABLED);
    final String ifname = intent.getStringExtra(EXTRA_WIFI_AP_INTERFACE_NAME);
    final int ipmode = intent.getIntExtra(EXTRA_WIFI_AP_MODE, IFACE_IP_MODE_UNSPECIFIED);
    synchronized (Tethering.this.mPublicSync) {
        switch(curState) {
            case WifiManager.WIFI_AP_STATE_ENABLING:
                // We can see this state on the way to both enabled and failure states.
                break;
            case WifiManager.WIFI_AP_STATE_ENABLED:
                enableWifiIpServingLocked(ifname, ipmode);
                break;
            case WifiManager.WIFI_AP_STATE_DISABLED:
            case WifiManager.WIFI_AP_STATE_DISABLING:
            case WifiManager.WIFI_AP_STATE_FAILED:
            default:
                disableWifiIpServingLocked(ifname, curState);
                break;
        }
    }
}
#end_block

#method_before
// TODO: Pass in the interface name and, if non-empty, only turn down IP
private void disableWifiIpServingLocked(int apState) {
    if (DBG)
        Log.d(TAG, "Canceling WiFi tethering request - AP_STATE=" + apState);
    // themselves down.
    for (int i = 0; i < mTetherStates.size(); i++) {
        TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
        if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
            tism.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
            // There should be at most one of these.
            break;
        }
    }
    // Regardless of whether we requested this transition, the AP has gone
    // down.  Don't try to tether again unless we're requested to do so.
    mWifiTetherRequested = false;
}
#method_after
private void disableWifiIpServingLocked(String ifname, int apState) {
    mLog.log("Canceling WiFi tethering request - AP_STATE=" + apState);
    // Regardless of whether we requested this transition, the AP has gone
    // down.  Don't try to tether again unless we're requested to do so.
    // TODO: Remove this altogether, once Wi-Fi reliably gives us an
    // interface name with every broadcast.
    mWifiTetherRequested = false;
    if (!TextUtils.isEmpty(ifname)) {
        final TetherState ts = mTetherStates.get(ifname);
        if (ts != null) {
            ts.stateMachine.unwanted();
            return;
        }
    }
    for (int i = 0; i < mTetherStates.size(); i++) {
        TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
        if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
            tism.unwanted();
            return;
        }
    }
    mLog.log("Error disabling Wi-Fi IP serving; " + (TextUtils.isEmpty(ifname) ? "no interface name specified" : "specified interface: " + ifname));
}
#end_block

#method_before
protected void chooseUpstreamType(boolean tryCell) {
    // TODO - remove?
    updateConfiguration();
    final int upstreamType = mUpstreamNetworkMonitor.selectPreferredUpstreamType(mConfig.preferredUpstreamIfaceTypes);
    if (upstreamType == ConnectivityManager.TYPE_NONE) {
        if (tryCell) {
            mUpstreamNetworkMonitor.registerMobileNetworkRequest();
        // We think mobile should be coming up; don't set a retry.
        } else {
            sendMessageDelayed(CMD_RETRY_UPSTREAM, UPSTREAM_SETTLE_TIME_MS);
        }
    }
    setUpstreamByType(upstreamType);
}
#method_after
protected void chooseUpstreamType(boolean tryCell) {
    // TODO - remove?
    updateConfiguration();
    final NetworkState ns = mUpstreamNetworkMonitor.selectPreferredUpstreamType(mConfig.preferredUpstreamIfaceTypes);
    if (ns == null) {
        if (tryCell) {
            mUpstreamNetworkMonitor.registerMobileNetworkRequest();
        // We think mobile should be coming up; don't set a retry.
        } else {
            sendMessageDelayed(CMD_RETRY_UPSTREAM, UPSTREAM_SETTLE_TIME_MS);
        }
    }
    setUpstreamNetwork(ns);
}
#end_block

#method_before
private void notifyLinkPropertiesChanged(String iface, TetherInterfaceStateMachine who, LinkProperties newLp) {
    final int state;
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            state = tetherState.lastState;
        } else {
            mLog.log("got notification from stale iface " + iface);
            return;
        }
    }
    mLog.log(String.format("OBSERVED LinkProperties update iface=%s state=%s lp=%s", iface, state, newLp));
    final int which = TetherMasterSM.EVENT_IFACE_UPDATE_LINKPROPERTIES;
    mTetherMasterSM.sendMessage(which, state, 0, newLp);
}
#method_after
private void notifyLinkPropertiesChanged(String iface, TetherInterfaceStateMachine who, LinkProperties newLp) {
    final int state;
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            state = tetherState.lastState;
        } else {
            mLog.log("got notification from stale iface " + iface);
            return;
        }
    }
    mLog.log(String.format("OBSERVED LinkProperties update iface=%s state=%s lp=%s", iface, IControlsTethering.getStateString(state), newLp));
    final int which = TetherMasterSM.EVENT_IFACE_UPDATE_LINKPROPERTIES;
    mTetherMasterSM.sendMessage(which, state, 0, newLp);
}
#end_block

#method_before
private void initStateMachine(int interfaceType) throws Exception {
    mTestedSm = new TetherInterfaceStateMachine(IFACE_NAME, mLooper.getLooper(), interfaceType, mSharedLog, mNMService, mStatsService, mTetherHelper);
    mTestedSm.start();
    // Starting the state machine always puts us in a consistent state and notifies
    // the test of the world that we've changed from an unknown to available state.
    mLooper.dispatchAll();
    reset(mNMService, mStatsService, mTetherHelper);
    when(mNMService.getInterfaceConfig(IFACE_NAME)).thenReturn(mInterfaceConfiguration);
}
#method_after
private void initStateMachine(int interfaceType) throws Exception {
    mTestedSm = new TetherInterfaceStateMachine(IFACE_NAME, mLooper.getLooper(), interfaceType, mSharedLog, mNMService, mStatsService, mTetherHelper);
    mTestedSm.start();
    // Starting the state machine always puts us in a consistent state and notifies
    // the rest of the world that we've changed from an unknown to available state.
    mLooper.dispatchAll();
    reset(mNMService, mStatsService, mTetherHelper);
    when(mNMService.getInterfaceConfig(IFACE_NAME)).thenReturn(mInterfaceConfiguration);
}
#end_block

#method_before
@Test
public void canBeTetheredAsUsb() throws Exception {
    initStateMachine(TETHERING_USB);
    dispatchCommand(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, STATE_TETHERED);
    InOrder inOrder = inOrder(mTetherHelper, mNMService);
    inOrder.verify(mNMService).getInterfaceConfig(IFACE_NAME);
    inOrder.verify(mNMService).setInterfaceConfig(IFACE_NAME, mInterfaceConfiguration);
    inOrder.verify(mNMService).tetherInterface(IFACE_NAME);
    inOrder.verify(mTetherHelper).updateInterfaceState(mTestedSm, STATE_TETHERED, TETHER_ERROR_NO_ERROR);
    inOrder.verify(mTetherHelper).updateLinkProperties(eq(mTestedSm), any(LinkProperties.class));
    verifyNoMoreInteractions(mNMService, mStatsService, mTetherHelper);
}
#method_after
@Test
public void canBeTetheredAsUsb() throws Exception {
    initStateMachine(TETHERING_USB);
    dispatchCommand(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, STATE_TETHERED);
    InOrder inOrder = inOrder(mTetherHelper, mNMService);
    inOrder.verify(mNMService).getInterfaceConfig(IFACE_NAME);
    inOrder.verify(mNMService).setInterfaceConfig(IFACE_NAME, mInterfaceConfiguration);
    inOrder.verify(mNMService).tetherInterface(IFACE_NAME);
    inOrder.verify(mTetherHelper).updateInterfaceState(mTestedSm, STATE_TETHERED, TETHER_ERROR_NO_ERROR);
    inOrder.verify(mTetherHelper).updateLinkProperties(eq(mTestedSm), mLinkPropertiesCaptor.capture());
    assertIPv4AddressAndDirectlyConnectedRoute(mLinkPropertiesCaptor.getValue());
    verifyNoMoreInteractions(mNMService, mStatsService, mTetherHelper);
}
#end_block

#method_before
@Test
public void interfaceDownLeadsToUnavailable() throws Exception {
    for (boolean shouldThrow : new boolean[] { true, false }) {
        initTetheredStateMachine(TETHERING_USB, null);
        if (shouldThrow) {
            doThrow(RemoteException.class).when(mNMService).untetherInterface(IFACE_NAME);
        }
        dispatchCommand(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
        InOrder usbTeardownOrder = inOrder(mNMService, mInterfaceConfiguration, mTetherHelper);
        usbTeardownOrder.verify(mInterfaceConfiguration).setInterfaceDown();
        usbTeardownOrder.verify(mNMService).setInterfaceConfig(IFACE_NAME, mInterfaceConfiguration);
        usbTeardownOrder.verify(mTetherHelper).updateInterfaceState(mTestedSm, STATE_UNAVAILABLE, TETHER_ERROR_NO_ERROR);
        usbTeardownOrder.verify(mTetherHelper).updateLinkProperties(eq(mTestedSm), any(LinkProperties.class));
    }
}
#method_after
@Test
public void interfaceDownLeadsToUnavailable() throws Exception {
    for (boolean shouldThrow : new boolean[] { true, false }) {
        initTetheredStateMachine(TETHERING_USB, null);
        if (shouldThrow) {
            doThrow(RemoteException.class).when(mNMService).untetherInterface(IFACE_NAME);
        }
        dispatchCommand(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
        InOrder usbTeardownOrder = inOrder(mNMService, mInterfaceConfiguration, mTetherHelper);
        usbTeardownOrder.verify(mInterfaceConfiguration).setInterfaceDown();
        usbTeardownOrder.verify(mNMService).setInterfaceConfig(IFACE_NAME, mInterfaceConfiguration);
        usbTeardownOrder.verify(mTetherHelper).updateInterfaceState(mTestedSm, STATE_UNAVAILABLE, TETHER_ERROR_NO_ERROR);
        usbTeardownOrder.verify(mTetherHelper).updateLinkProperties(eq(mTestedSm), mLinkPropertiesCaptor.capture());
        assertNoAddressesNorRoutes(mLinkPropertiesCaptor.getValue());
    }
}
#end_block

#method_before
@Test
public void usbShouldBeTornDownOnTetherError() throws Exception {
    initStateMachine(TETHERING_USB);
    doThrow(RemoteException.class).when(mNMService).tetherInterface(IFACE_NAME);
    dispatchCommand(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, STATE_TETHERED);
    InOrder usbTeardownOrder = inOrder(mNMService, mInterfaceConfiguration, mTetherHelper);
    usbTeardownOrder.verify(mInterfaceConfiguration).setInterfaceDown();
    usbTeardownOrder.verify(mNMService).setInterfaceConfig(IFACE_NAME, mInterfaceConfiguration);
    usbTeardownOrder.verify(mTetherHelper).updateInterfaceState(mTestedSm, STATE_AVAILABLE, TETHER_ERROR_TETHER_IFACE_ERROR);
    usbTeardownOrder.verify(mTetherHelper).updateLinkProperties(eq(mTestedSm), any(LinkProperties.class));
}
#method_after
@Test
public void usbShouldBeTornDownOnTetherError() throws Exception {
    initStateMachine(TETHERING_USB);
    doThrow(RemoteException.class).when(mNMService).tetherInterface(IFACE_NAME);
    dispatchCommand(TetherInterfaceStateMachine.CMD_TETHER_REQUESTED, STATE_TETHERED);
    InOrder usbTeardownOrder = inOrder(mNMService, mInterfaceConfiguration, mTetherHelper);
    usbTeardownOrder.verify(mInterfaceConfiguration).setInterfaceDown();
    usbTeardownOrder.verify(mNMService).setInterfaceConfig(IFACE_NAME, mInterfaceConfiguration);
    usbTeardownOrder.verify(mTetherHelper).updateInterfaceState(mTestedSm, STATE_AVAILABLE, TETHER_ERROR_TETHER_IFACE_ERROR);
    usbTeardownOrder.verify(mTetherHelper).updateLinkProperties(eq(mTestedSm), mLinkPropertiesCaptor.capture());
    assertNoAddressesNorRoutes(mLinkPropertiesCaptor.getValue());
}
#end_block

#method_before
@Test
public void shouldTearDownUsbOnUpstreamError() throws Exception {
    initTetheredStateMachine(TETHERING_USB, null);
    doThrow(RemoteException.class).when(mNMService).enableNat(anyString(), anyString());
    dispatchTetherConnectionChanged(UPSTREAM_IFACE);
    InOrder usbTeardownOrder = inOrder(mNMService, mInterfaceConfiguration, mTetherHelper);
    usbTeardownOrder.verify(mInterfaceConfiguration).setInterfaceDown();
    usbTeardownOrder.verify(mNMService).setInterfaceConfig(IFACE_NAME, mInterfaceConfiguration);
    usbTeardownOrder.verify(mTetherHelper).updateInterfaceState(mTestedSm, STATE_AVAILABLE, TETHER_ERROR_ENABLE_NAT_ERROR);
    usbTeardownOrder.verify(mTetherHelper).updateLinkProperties(eq(mTestedSm), any(LinkProperties.class));
}
#method_after
@Test
public void shouldTearDownUsbOnUpstreamError() throws Exception {
    initTetheredStateMachine(TETHERING_USB, null);
    doThrow(RemoteException.class).when(mNMService).enableNat(anyString(), anyString());
    dispatchTetherConnectionChanged(UPSTREAM_IFACE);
    InOrder usbTeardownOrder = inOrder(mNMService, mInterfaceConfiguration, mTetherHelper);
    usbTeardownOrder.verify(mInterfaceConfiguration).setInterfaceDown();
    usbTeardownOrder.verify(mNMService).setInterfaceConfig(IFACE_NAME, mInterfaceConfiguration);
    usbTeardownOrder.verify(mTetherHelper).updateInterfaceState(mTestedSm, STATE_AVAILABLE, TETHER_ERROR_ENABLE_NAT_ERROR);
    usbTeardownOrder.verify(mTetherHelper).updateLinkProperties(eq(mTestedSm), mLinkPropertiesCaptor.capture());
    assertNoAddressesNorRoutes(mLinkPropertiesCaptor.getValue());
}
#end_block

#method_before
@Override
protected KeySpec engineGetKeySpec(SecretKey secretKey, Class<?> aClass) throws InvalidKeySpecException {
    if (secretKey == null) {
        throw new InvalidKeySpecException("Null SecretKey");
    }
    if (aClass == SecretKeySpec.class) {
        return (KeySpec) secretKey;
    } else if (aClass == DESedeKeySpec.class) {
        try {
            return new DESedeKeySpec(secretKey.getEncoded());
        } catch (InvalidKeyException e) {
            throw new InvalidKeySpecException(e);
        }
    } else {
        throw new InvalidKeySpecException("Unsupported KeySpec class: " + aClass.getName());
    }
}
#method_after
@Override
protected KeySpec engineGetKeySpec(SecretKey secretKey, Class<?> aClass) throws InvalidKeySpecException {
    if (secretKey == null) {
        throw new InvalidKeySpecException("Null SecretKey");
    }
    if (aClass == SecretKeySpec.class) {
        if (secretKey instanceof SecretKeySpec) {
            return (KeySpec) secretKey;
        } else {
            return new SecretKeySpec(secretKey.getEncoded(), "DESEDE");
        }
    } else if (aClass == DESedeKeySpec.class) {
        try {
            return new DESedeKeySpec(secretKey.getEncoded());
        } catch (InvalidKeyException e) {
            throw new InvalidKeySpecException(e);
        }
    } else {
        throw new InvalidKeySpecException("Unsupported KeySpec class: " + aClass);
    }
}
#end_block

#method_before
private void printUsage() {
    // have to reset fields so that "Default is: FOO" lines are accurate
    optionParser.reset();
    System.out.println("Usage: Vogar [options]... <actions>... [-- target args]...");
    System.out.println();
    System.out.println("  <actions>: .java files, directories, or class names.");
    System.out.println("      These should be JUnit tests, jtreg tests, Caliper benchmarks");
    System.out.println("      or executable Java classes.");
    System.out.println();
    System.out.println("      When passing in a JUnit test class, it may have \"#method_name\"");
    System.out.println("      appended to it, to specify a single test method.");
    System.out.println();
    System.out.println("  [args]: arguments passed to the target process. This is only useful when");
    System.out.println("      the target process is a Caliper benchmark or main method.");
    System.out.println();
    System.out.println("GENERAL OPTIONS");
    System.out.println();
    System.out.println("  --mode <activity|device|host|jvm>: specify which environment to run in.");
    System.out.println("      activity: runs in an Android application on a device or emulator");
    System.out.println("      device: runs in an ART runtime on a device or emulator");
    System.out.println("      host: runs in an ART runtime on the local desktop built with any lunch combo.");
    System.out.println("      jvm: runs in a Java VM on the local desktop");
    System.out.println("      Default is: " + modeId);
    System.out.println();
    System.out.println("  --variant <x32>: specify which architecture variant to execute with.");
    System.out.println("      x32: 32-bit");
    System.out.println("      Default is: " + variant);
    System.out.println();
    System.out.println("  --toolchain <jdk|jack>: Which toolchain to use.");
    System.out.println("      Default is: " + toolchain);
    System.out.println();
    System.out.println("  --language <J17|JN|JO|CUR>: Which language level to use.");
    System.out.println("      Default is: " + language);
    System.out.println();
    System.out.println("  --ssh <host:port>: target a remote machine via SSH.");
    System.out.println();
    System.out.println("  --clean: synonym for --clean-before and --clean-after (default).");
    System.out.println("      Disable with --no-clean if you want no files removed.");
    System.out.println();
    System.out.println("  --stream: stream output as it is emitted.");
    System.out.println();
    System.out.println("  --benchmark: for use with dalvikvm, this dexes all files together,");
    System.out.println("      and is mandatory for running Caliper benchmarks, and a good idea");
    System.out.println("      for other performance sensitive code.");
    System.out.println("      If you specify this without specifying --runner-type then it");
    System.out.println("      assumes --runner-type=" + RunnerType.CALIPER.name().toLowerCase());
    System.out.println();
    System.out.println("  --profile: run with a profiler to produce an hprof file.");
    System.out.println();
    System.out.println("  --profile-binary: produce a binary hprof file instead of the default ASCII.");
    System.out.println();
    System.out.println("  --profile-file <filename>: filename for hprof profile data.");
    System.out.println("      Default is java.hprof.txt in ASCII mode and java.hprof in binary mode.");
    System.out.println();
    System.out.println("  --profile-depth <count>: number of frames in profile stack traces.");
    System.out.println("      Default is: " + profileDepth);
    System.out.println();
    System.out.println("  --profile-interval <milliseconds>: interval between profile samples.");
    System.out.println("      Default is: " + profileInterval);
    System.out.println();
    System.out.println("  --profile-thread-group: profile thread group instead of single thread in dalvikvms");
    System.out.println("      Note --mode jvm only supports full VM profiling.");
    System.out.println("      Default is: " + profileThreadGroup);
    System.out.println();
    System.out.println("  --invoke-with: provide a command to invoke the VM with. Examples:");
    System.out.println("      --mode host --invoke-with \"valgrind --leak-check=full\"");
    System.out.println("      --mode device --invoke-with \"strace -f -o/sdcard/strace.txt\"");
    System.out.println();
    System.out.println("  --timeout <seconds>: maximum execution time of each action before the");
    System.out.println("      runner aborts it. Specifying zero seconds or using --debug will");
    System.out.println("      disable the execution timeout. Tests tagged with 'large' will time");
    System.out.println("      out in " + LARGE_TIMEOUT_MULTIPLIER + "x this timeout.");
    System.out.println("      Default is: " + timeoutSeconds);
    System.out.println();
    System.out.println("  --xml-reports-directory <path>: directory to emit JUnit-style");
    System.out.println("      XML test results.");
    System.out.println();
    System.out.println("  --classpath <jar file>: add the .jar to both build and execute classpaths.");
    System.out.println();
    System.out.println("  --use-bootclasspath: use the classpath as search path for bootstrap classes.");
    System.out.println();
    System.out.println("  --build-classpath <element>: add the directory or .jar to the build");
    System.out.println("      classpath. Such classes are available as build dependencies, but");
    System.out.println("      not at runtime.");
    System.out.println();
    System.out.println("  --sourcepath <directory>: add the directory to the build sourcepath.");
    System.out.println();
    System.out.println("  --vogar-dir <directory>: directory in which to find Vogar");
    System.out.println("      configuration information, caches, saved and results");
    System.out.println("      unless they've been put explicitly elsewhere.");
    System.out.println("      Default is: " + vogarDir);
    System.out.println();
    System.out.println("  --record-results: record test results for future comparison.");
    System.out.println();
    System.out.println("  --results-dir <directory>: read and write (if --record-results used)");
    System.out.println("      results from and to this directory.");
    System.out.println();
    System.out.println("  --runner-type <default|caliper|main|junit>: specify which runner to use.");
    System.out.println("      default: runs both JUnit tests and main() classes");
    System.out.println("      caliper: runs Caliper benchmarks only");
    System.out.println("      main: runs main() classes only");
    System.out.println("      junit: runs JUnit tests only");
    System.out.println("      Default is determined by --benchmark and --testonly, if they are");
    System.out.println("      not specified then defaults to: default");
    System.out.println();
    System.out.println("  --test-only: only run JUnit tests.");
    System.out.println("      Default is: " + testOnly);
    System.out.println("      DEPRECATED: Use --runner-type=" + RunnerType.JUNIT.name().toLowerCase());
    System.out.println();
    System.out.println("  --verbose: turn on persistent verbose output.");
    System.out.println();
    System.out.println("  --check-jni: enable CheckJNI mode.");
    System.out.println("      See http://developer.android.com/training/articles/perf-jni.html.");
    System.out.println("      Default is: " + checkJni + ", but disabled for --benchmark.");
    System.out.println("");
    System.out.println("TARGET OPTIONS");
    System.out.println();
    System.out.println("  --debug <port>: enable Java debugging on the specified port.");
    System.out.println("      This port must be free both on the device and on the local");
    System.out.println("      system. Disables the timeout specified by --timeout-seconds.");
    System.out.println();
    System.out.println("  --debug-app: enable debugging while running in an activity.");
    System.out.println("      This will require the use of DDMS to connect to the activity");
    System.out.println("      on the device, and expose the debugger on an appropriate port.");
    System.out.println();
    System.out.println("  --device-dir <directory>: use the specified directory for");
    System.out.println("      on-device temporary files and code.");
    System.out.println();
    System.out.println("  --vm-arg <argument>: include the specified argument when spawning a");
    System.out.println("      virtual machine. Examples: -Xint:fast, -ea, -Xmx16M");
    System.out.println();
    System.out.println("  --vm-command <argument>: override default vm executable name.");
    System.out.println("      Default is 'java' for the JVM and a version of dalvikvm for the host and target.");
    System.out.println();
    System.out.println("  --java-home <java_home>: execute the actions on the local workstation");
    System.out.println("      using the specified java home directory. This does not impact");
    System.out.println("      which javac gets used. When unset, java is used from the PATH.");
    System.out.println();
    System.out.println("EXOTIC OPTIONS");
    System.out.println();
    System.out.println("  --suggest-classpaths: build an index of jar files under the");
    System.out.println("      directories given by --jar-search-dir arguments. If Vogar then ");
    System.out.println("      fails due to missing classes or packages, it will use the index to");
    System.out.println("      diagnose the problem and suggest a fix.");
    System.out.println();
    System.out.println("      Currently only looks for jars called exactly \"classes.jar\".");
    System.out.println();
    System.out.println("  --jar-search-dir <directory>: a directory that should be searched for");
    System.out.println("      jar files to add to the class file index for use with");
    System.out.println("      --suggest-classpaths.");
    System.out.println();
    System.out.println("  --clean-before: remove working directories before building and");
    System.out.println("      running (default). Disable with --no-clean-before if you are");
    System.out.println("      using interactively with your own temporary input files.");
    System.out.println();
    System.out.println("  --clean-after: remove temporary files after running (default).");
    System.out.println("      Disable with --no-clean-after and use with --verbose if");
    System.out.println("      you'd like to manually re-run commands afterwards.");
    System.out.println();
    System.out.println("  --color: format output in technicolor.");
    System.out.println();
    System.out.println("  --pass-color: ANSI color code to use for passes.");
    System.out.println("      Default: 32 (green)");
    System.out.println();
    System.out.println("  --skip-color: ANSI color code to use for skips.");
    System.out.println("      Default: 33 (yellow)");
    System.out.println();
    System.out.println("  --warn-color: ANSI color code to use for warnings.");
    System.out.println("      Default: 35 (purple)");
    System.out.println();
    System.out.println("  --fail-color: ANSI color code to use for failures.");
    System.out.println("      Default: 31 (red)");
    System.out.println();
    System.out.println("  --ansi: use ANSI escape sequences to remove intermediate output.");
    System.out.println();
    System.out.println("  --expectations <file>: include the specified file when looking for");
    System.out.println("      action expectations. The file should include qualified action names");
    System.out.println("      and the corresponding expected output.");
    System.out.println("      Default is: " + expectationFiles);
    System.out.println();
    System.out.println("  --indent: amount to indent action result output. Can be set to ''");
    System.out.println("      (aka empty string) to simplify output parsing.");
    System.out.println("      Default is: '" + indent + "'");
    System.out.println();
    System.out.println("  --javac-arg <argument>: include the specified argument when invoking");
    System.out.println("      javac. Examples: --javac-arg -Xmaxerrs --javac-arg 1");
    System.out.println();
    System.out.println("  --jack-arg <argument>: include the specified argument when invoking");
    System.out.println("      jack. Examples: --jack-arg -D --jack-arg jack.assert.policy=always");
    System.out.println();
    System.out.println("  --dalvik-cache <argument>: override default dalvik-cache location.");
    System.out.println("      Default is: " + dalvikCache);
    System.out.println();
    System.out.println("  --first-monitor-port <port>: the port on the host (and possibly target)");
    System.out.println("      used to traffic control messages between vogar and forked processes.");
    System.out.println("      Use this to avoid port conflicts when running multiple vogar instances");
    System.out.println("      concurrently. Vogar will use up to N ports starting with this one,");
    System.out.println("      where N is the number of processors on the host (" + NUM_PROCESSORS + "). ");
    System.out.println();
    System.out.println("  --open-bugs-command <command>: a command that will take bug IDs as parameters");
    System.out.println("      and return those bugs that are still open. For example, if bugs 123 and");
    System.out.println("      789 are both open, the command should echo those values:");
    System.out.println("         $ ~/bin/bug-command 123 456 789");
    System.out.println("         123");
    System.out.println("         789");
    System.out.println();
    System.out.println("CONFIG FILE");
    System.out.println();
    System.out.println("  User-defined default arguments can be specified in ~/.vogarconfig. See");
    System.out.println("  .vogarconfig.example for an example.");
    System.out.println();
}
#method_after
private void printUsage() {
    // have to reset fields so that "Default is: FOO" lines are accurate
    optionParser.reset();
    System.out.println("Usage: Vogar [options]... <actions>... [-- target args]...");
    System.out.println();
    System.out.println("  <actions>: .java files, directories, or class names.");
    System.out.println("      These should be JUnit tests, jtreg tests, Caliper benchmarks");
    System.out.println("      or executable Java classes.");
    System.out.println();
    System.out.println("      When passing in a JUnit test class, it may have \"#method_name\"");
    System.out.println("      appended to it, to specify a single test method.");
    System.out.println();
    System.out.println("  [args]: arguments passed to the target process. This is only useful when");
    System.out.println("      the target process is a Caliper benchmark or main method.");
    System.out.println();
    System.out.println("GENERAL OPTIONS");
    System.out.println();
    System.out.println("  --mode <activity|device|host|jvm>: specify which environment to run in.");
    System.out.println("      activity: runs in an Android application on a device or emulator");
    System.out.println("      device: runs in an ART runtime on a device or emulator");
    System.out.println("      host: runs in an ART runtime on the local desktop built with any lunch combo.");
    System.out.println("      jvm: runs in a Java VM on the local desktop");
    System.out.println("      Default is: " + modeId);
    System.out.println();
    System.out.println("  --variant <x32>: specify which architecture variant to execute with.");
    System.out.println("      x32: 32-bit");
    System.out.println("      Default is: " + variant);
    System.out.println();
    System.out.println("  --toolchain <jdk|jack>: Which toolchain to use.");
    System.out.println("      Default is: " + toolchain);
    System.out.println();
    System.out.println("  --language <J17|JN|JO|CUR>: Which language level to use.");
    System.out.println("      Default is: " + language);
    System.out.println();
    System.out.println("  --ssh <host:port>: target a remote machine via SSH.");
    System.out.println();
    System.out.println("  --clean: synonym for --clean-before and --clean-after (default).");
    System.out.println("      Disable with --no-clean if you want no files removed.");
    System.out.println();
    System.out.println("  --stream: stream output as it is emitted.");
    System.out.println();
    System.out.println("  --benchmark: for use with dalvikvm, this dexes all files together,");
    System.out.println("      and is mandatory for running Caliper benchmarks, and a good idea");
    System.out.println("      for other performance sensitive code.");
    System.out.println("      If you specify this without specifying --runner-type then it");
    System.out.println("      assumes --runner-type=" + RunnerType.CALIPER.name().toLowerCase());
    System.out.println();
    System.out.println("  --invoke-with: provide a command to invoke the VM with. Examples:");
    System.out.println("      --mode host --invoke-with \"valgrind --leak-check=full\"");
    System.out.println("      --mode device --invoke-with \"strace -f -o/sdcard/strace.txt\"");
    System.out.println();
    System.out.println("  --timeout <seconds>: maximum execution time of each action before the");
    System.out.println("      runner aborts it. Specifying zero seconds or using --debug will");
    System.out.println("      disable the execution timeout. Tests tagged with 'large' will time");
    System.out.println("      out in " + LARGE_TIMEOUT_MULTIPLIER + "x this timeout.");
    System.out.println("      Default is: " + timeoutSeconds);
    System.out.println();
    System.out.println("  --xml-reports-directory <path>: directory to emit JUnit-style");
    System.out.println("      XML test results.");
    System.out.println();
    System.out.println("  --classpath <jar file>: add the .jar to both build and execute classpaths.");
    System.out.println();
    System.out.println("  --use-bootclasspath: use the classpath as search path for bootstrap classes.");
    System.out.println();
    System.out.println("  --build-classpath <element>: add the directory or .jar to the build");
    System.out.println("      classpath. Such classes are available as build dependencies, but");
    System.out.println("      not at runtime.");
    System.out.println();
    System.out.println("  --sourcepath <directory>: add the directory to the build sourcepath.");
    System.out.println();
    System.out.println("  --vogar-dir <directory>: directory in which to find Vogar");
    System.out.println("      configuration information, caches, saved and results");
    System.out.println("      unless they've been put explicitly elsewhere.");
    System.out.println("      Default is: " + vogarDir);
    System.out.println();
    System.out.println("  --record-results: record test results for future comparison.");
    System.out.println();
    System.out.println("  --results-dir <directory>: read and write (if --record-results used)");
    System.out.println("      results from and to this directory.");
    System.out.println();
    System.out.println("  --runner-type <default|caliper|main|junit>: specify which runner to use.");
    System.out.println("      default: runs both JUnit tests and main() classes");
    System.out.println("      caliper: runs Caliper benchmarks only");
    System.out.println("      main: runs main() classes only");
    System.out.println("      junit: runs JUnit tests only");
    System.out.println("      Default is determined by --benchmark and --testonly, if they are");
    System.out.println("      not specified then defaults to: default");
    System.out.println();
    System.out.println("  --test-only: only run JUnit tests.");
    System.out.println("      Default is: " + testOnly);
    System.out.println("      DEPRECATED: Use --runner-type=" + RunnerType.JUNIT.name().toLowerCase());
    System.out.println();
    System.out.println("  --verbose: turn on persistent verbose output.");
    System.out.println();
    System.out.println("  --check-jni: enable CheckJNI mode.");
    System.out.println("      See http://developer.android.com/training/articles/perf-jni.html.");
    System.out.println("      Default is: " + checkJni + ", but disabled for --benchmark.");
    System.out.println("");
    System.out.println("TARGET OPTIONS");
    System.out.println();
    System.out.println("  --debug <port>: enable Java debugging on the specified port.");
    System.out.println("      This port must be free both on the device and on the local");
    System.out.println("      system. Disables the timeout specified by --timeout-seconds.");
    System.out.println();
    System.out.println("  --debug-app: enable debugging while running in an activity.");
    System.out.println("      This will require the use of DDMS to connect to the activity");
    System.out.println("      on the device, and expose the debugger on an appropriate port.");
    System.out.println();
    System.out.println("  --device-dir <directory>: use the specified directory for");
    System.out.println("      on-device temporary files and code.");
    System.out.println();
    System.out.println("  --vm-arg <argument>: include the specified argument when spawning a");
    System.out.println("      virtual machine. Examples: -Xint:fast, -ea, -Xmx16M");
    System.out.println();
    System.out.println("  --vm-command <argument>: override default vm executable name.");
    System.out.println("      Default is 'java' for the JVM and a version of dalvikvm for the host and target.");
    System.out.println();
    System.out.println("  --java-home <java_home>: execute the actions on the local workstation");
    System.out.println("      using the specified java home directory. This does not impact");
    System.out.println("      which javac gets used. When unset, java is used from the PATH.");
    System.out.println();
    System.out.println("EXOTIC OPTIONS");
    System.out.println();
    System.out.println("  --suggest-classpaths: build an index of jar files under the");
    System.out.println("      directories given by --jar-search-dir arguments. If Vogar then ");
    System.out.println("      fails due to missing classes or packages, it will use the index to");
    System.out.println("      diagnose the problem and suggest a fix.");
    System.out.println();
    System.out.println("      Currently only looks for jars called exactly \"classes.jar\".");
    System.out.println();
    System.out.println("  --jar-search-dir <directory>: a directory that should be searched for");
    System.out.println("      jar files to add to the class file index for use with");
    System.out.println("      --suggest-classpaths.");
    System.out.println();
    System.out.println("  --clean-before: remove working directories before building and");
    System.out.println("      running (default). Disable with --no-clean-before if you are");
    System.out.println("      using interactively with your own temporary input files.");
    System.out.println();
    System.out.println("  --clean-after: remove temporary files after running (default).");
    System.out.println("      Disable with --no-clean-after and use with --verbose if");
    System.out.println("      you'd like to manually re-run commands afterwards.");
    System.out.println();
    System.out.println("  --color: format output in technicolor.");
    System.out.println();
    System.out.println("  --pass-color: ANSI color code to use for passes.");
    System.out.println("      Default: 32 (green)");
    System.out.println();
    System.out.println("  --skip-color: ANSI color code to use for skips.");
    System.out.println("      Default: 33 (yellow)");
    System.out.println();
    System.out.println("  --warn-color: ANSI color code to use for warnings.");
    System.out.println("      Default: 35 (purple)");
    System.out.println();
    System.out.println("  --fail-color: ANSI color code to use for failures.");
    System.out.println("      Default: 31 (red)");
    System.out.println();
    System.out.println("  --ansi: use ANSI escape sequences to remove intermediate output.");
    System.out.println();
    System.out.println("  --expectations <file>: include the specified file when looking for");
    System.out.println("      action expectations. The file should include qualified action names");
    System.out.println("      and the corresponding expected output.");
    System.out.println("      Default is: " + expectationFiles);
    System.out.println();
    System.out.println("  --indent: amount to indent action result output. Can be set to ''");
    System.out.println("      (aka empty string) to simplify output parsing.");
    System.out.println("      Default is: '" + indent + "'");
    System.out.println();
    System.out.println("  --javac-arg <argument>: include the specified argument when invoking");
    System.out.println("      javac. Examples: --javac-arg -Xmaxerrs --javac-arg 1");
    System.out.println();
    System.out.println("  --jack-arg <argument>: include the specified argument when invoking");
    System.out.println("      jack. Examples: --jack-arg -D --jack-arg jack.assert.policy=always");
    System.out.println();
    System.out.println("  --multidex: whether to use native multidex support");
    System.out.println("      Disable with --no-multidex.");
    System.out.println("      Default is: " + multidex);
    System.out.println();
    System.out.println("  --dalvik-cache <argument>: override default dalvik-cache location.");
    System.out.println("      Default is: " + dalvikCache);
    System.out.println();
    System.out.println("  --first-monitor-port <port>: the port on the host (and possibly target)");
    System.out.println("      used to traffic control messages between vogar and forked processes.");
    System.out.println("      Use this to avoid port conflicts when running multiple vogar instances");
    System.out.println("      concurrently. Vogar will use up to N ports starting with this one,");
    System.out.println("      where N is the number of processors on the host (" + NUM_PROCESSORS + "). ");
    System.out.println();
    System.out.println("  --open-bugs-command <command>: a command that will take bug IDs as parameters");
    System.out.println("      and return those bugs that are still open. For example, if bugs 123 and");
    System.out.println("      789 are both open, the command should echo those values:");
    System.out.println("         $ ~/bin/bug-command 123 456 789");
    System.out.println("         123");
    System.out.println("         789");
    System.out.println();
    System.out.println("CONFIG FILE");
    System.out.println();
    System.out.println("  User-defined default arguments can be specified in ~/.vogarconfig. See");
    System.out.println("  .vogarconfig.example for an example.");
    System.out.println();
}
#end_block

#method_before
@VisibleForTesting
public boolean parseArgs(String[] args) {
    // extract arguments from config file
    configArgs = OptionParser.readFile(configFile);
    // config file args are added first so that in a conflict, the currently supplied
    // arguments win.
    List<String> actionsAndTargetArgs = optionParser.parse(configArgs);
    if (!actionsAndTargetArgs.isEmpty()) {
        throw new RuntimeException("actions or targets given in .vogarconfig: " + actionsAndTargetArgs);
    }
    try {
        actionsAndTargetArgs.addAll(optionParser.parse(args));
    } catch (RuntimeException e) {
        System.out.println(e.getMessage());
        return false;
    }
    if (javaHome != null && !new File(javaHome, "/bin/java").exists()) {
        System.out.println("Invalid java home: " + javaHome);
        return false;
    }
    // check vm option consistency
    if (!modeId.acceptsVmArgs() && !vmArgs.isEmpty()) {
        System.out.println("VM args " + vmArgs + " should not be specified for mode " + modeId);
        return false;
    }
    // Check variant / mode compatibility.
    if (!modeId.supportsVariant(variant)) {
        System.out.println("Variant " + variant + " not supported for mode " + modeId);
        return false;
    }
    if (xmlReportsDirectory != null && !xmlReportsDirectory.isDirectory()) {
        System.out.println("Invalid XML reports directory: " + xmlReportsDirectory);
        return false;
    }
    if (!clean) {
        cleanBefore = false;
        cleanAfter = false;
    }
    if (vmCommand == null) {
        vmCommand = modeId.defaultVmCommand(variant);
    }
    // disable timeout when benchmarking or debugging
    if (benchmark || debugPort != null) {
        timeoutSeconds = 0;
    }
    if (firstMonitorPort == -1) {
        firstMonitorPort = modeId.isLocal() ? 8788 : 8787;
    }
    if (profileFile == null) {
        profileFile = new File(profileBinary ? "java.hprof" : "java.hprof.txt");
    }
    // separate the actions and the target args
    int index = 0;
    for (; index < actionsAndTargetArgs.size(); index++) {
        String arg = actionsAndTargetArgs.get(index);
        if (arg.equals("--")) {
            index++;
            break;
        }
        File file = new File(arg);
        if (file.exists()) {
            if (arg.endsWith(".java") || file.isDirectory()) {
                actionFiles.add(file.getAbsoluteFile());
            } else {
                System.out.println("Expected a .jar file, .java file, directory, " + "package name or classname, but was: " + arg);
                return false;
            }
        } else {
            actionClassesAndPackages.add(arg);
        }
    }
    targetArgs.addAll(actionsAndTargetArgs.subList(index, actionsAndTargetArgs.size()));
    if (actionFiles.isEmpty() && actionClassesAndPackages.isEmpty()) {
        System.out.println("No actions provided.");
        return false;
    }
    if (!modeId.acceptsVmArgs() && !targetArgs.isEmpty()) {
        System.out.println("Target args " + targetArgs + " should not be specified for mode " + modeId);
        return false;
    }
    // Check that jack is setup correctly & check compatibility
    if (toolchain.toLowerCase().equals("jack")) {
        useJack = true;
    } else if (!toolchain.toLowerCase().equals("jdk")) {
        System.out.println("The options for toolchain are either jack or jdk.");
        return false;
    }
    if (modeId == ModeId.ACTIVITY && debugPort != null) {
        System.out.println("Activity debugging requires the use of --debug-app and DDMS.");
        return false;
    }
    if (debugApp && modeId != ModeId.ACTIVITY) {
        System.out.println("--debug-app can only be used in combination with --mode activity.");
        return false;
    }
    // Pass --vm app_process to it so that it knows not to use dalvikvm.
    if ("app_process".equals(vmCommand) && benchmark) {
        targetArgs.add("--vm");
        targetArgs.add("app_process");
    }
    return true;
}
#method_after
@VisibleForTesting
public boolean parseArgs(String[] args) {
    // extract arguments from config file
    configArgs = OptionParser.readFile(configFile);
    // config file args are added first so that in a conflict, the currently supplied
    // arguments win.
    List<String> actionsAndTargetArgs = optionParser.parse(configArgs);
    if (!actionsAndTargetArgs.isEmpty()) {
        throw new RuntimeException("actions or targets given in .vogarconfig: " + actionsAndTargetArgs);
    }
    try {
        actionsAndTargetArgs.addAll(optionParser.parse(args));
    } catch (RuntimeException e) {
        System.out.println(e.getMessage());
        return false;
    }
    if (javaHome != null && !new File(javaHome, "/bin/java").exists()) {
        System.out.println("Invalid java home: " + javaHome);
        return false;
    }
    // check vm option consistency
    if (!modeId.acceptsVmArgs() && !vmArgs.isEmpty()) {
        System.out.println("VM args " + vmArgs + " should not be specified for mode " + modeId);
        return false;
    }
    // Check variant / mode compatibility.
    if (!modeId.supportsVariant(variant)) {
        System.out.println("Variant " + variant + " not supported for mode " + modeId);
        return false;
    }
    if (xmlReportsDirectory != null && !xmlReportsDirectory.isDirectory()) {
        System.out.println("Invalid XML reports directory: " + xmlReportsDirectory);
        return false;
    }
    if (!clean) {
        cleanBefore = false;
        cleanAfter = false;
    }
    if (vmCommand == null) {
        vmCommand = modeId.defaultVmCommand(variant);
    }
    // disable timeout when benchmarking or debugging
    if (benchmark || debugPort != null) {
        timeoutSeconds = 0;
    }
    if (firstMonitorPort == -1) {
        firstMonitorPort = modeId.isLocal() ? 8788 : 8787;
    }
    // separate the actions and the target args
    int index = 0;
    for (; index < actionsAndTargetArgs.size(); index++) {
        String arg = actionsAndTargetArgs.get(index);
        if (arg.equals("--")) {
            index++;
            break;
        }
        File file = new File(arg);
        if (file.exists()) {
            if (arg.endsWith(".java") || file.isDirectory()) {
                actionFiles.add(file.getAbsoluteFile());
            } else {
                System.out.println("Expected a .jar file, .java file, directory, " + "package name or classname, but was: " + arg);
                return false;
            }
        } else {
            actionClassesAndPackages.add(arg);
        }
    }
    targetArgs.addAll(actionsAndTargetArgs.subList(index, actionsAndTargetArgs.size()));
    if (actionFiles.isEmpty() && actionClassesAndPackages.isEmpty()) {
        System.out.println("No actions provided.");
        return false;
    }
    if (!modeId.acceptsVmArgs() && !targetArgs.isEmpty()) {
        System.out.println("Target args " + targetArgs + " should not be specified for mode " + modeId);
        return false;
    }
    // Check that jack is setup correctly & check compatibility
    if (toolchain.toLowerCase().equals("jack")) {
        useJack = true;
    } else if (!toolchain.toLowerCase().equals("jdk")) {
        System.out.println("The options for toolchain are either jack or jdk.");
        return false;
    }
    if (modeId == ModeId.ACTIVITY && debugPort != null) {
        System.out.println("Activity debugging requires the use of --debug-app and DDMS.");
        return false;
    }
    if (debugApp && modeId != ModeId.ACTIVITY) {
        System.out.println("--debug-app can only be used in combination with --mode activity.");
        return false;
    }
    // Pass --vm app_process to it so that it knows not to use dalvikvm.
    if ("app_process".equals(vmCommand) && benchmark) {
        targetArgs.add("--vm");
        targetArgs.add("app_process");
    }
    return true;
}
#end_block

#method_before
private void addCreateDexJarAndPushTasks(Set<Task> tasks, String name, File jar, Action action) {
    File localDex = run.localDexFile(name);
    File localDesugarTempDir = run.localDesugarTempDir(name);
    File deviceDex = run.targetDexFile(name);
    Task createDexJarTask = newCreateDexJarTask(run.classpath, jar, name, action, localDex, localDesugarTempDir);
    tasks.add(createDexJarTask);
    tasks.add(run.target.pushTask(localDex, deviceDex).afterSuccess(createDexJarTask));
}
#method_after
private void addCreateDexJarAndPushTasks(Set<Task> tasks, String name, File jar, Action action) {
    File localDex = run.localDexFile(name);
    File localTempDir = run.localDir(name);
    File deviceDex = run.targetDexFile(name);
    Task createDexJarTask = newCreateDexJarTask(run.classpath, jar, name, action, localDex, localTempDir);
    tasks.add(createDexJarTask);
    tasks.add(run.target.pushTask(localDex, deviceDex).afterSuccess(createDexJarTask));
}
#end_block

#method_before
private Task newCreateDexJarTask(Classpath classpath, File classpathElement, String name, Action action, File localDex, File localDesugarTempDir) {
    Task dex;
    if (run.useJack) {
        dex = new JackDexTask(run, classpath, run.benchmark, name, classpathElement, action, localDex);
    } else {
        dex = new DexTask(run.androidSdk, classpath, run.benchmark, name, classpathElement, action, localDex, localDesugarTempDir, run.multidex);
    }
    return dex;
}
#method_after
private Task newCreateDexJarTask(Classpath classpath, File classpathElement, String name, Action action, File localDex, File localTempDir) {
    Task dex;
    if (run.useJack) {
        dex = new JackDexTask(run, classpath, run.benchmark, name, classpathElement, action, localDex);
    } else {
        dex = new DexTask(run.androidSdk, classpath, run.benchmark, name, classpathElement, action, localDex, localTempDir, run.multidex);
    }
    return dex;
}
#end_block

#method_before
public static AndroidSdk createAndroidSdk(Log log, Mkdir mkdir, ModeId modeId, boolean useJack, Language language) {
    List<String> path = new Command.Builder(log).args("which", "dx").permitNonZeroExitStatus(true).execute();
    if (path.isEmpty()) {
        throw new RuntimeException("dx not found");
    }
    File dx = new File(path.get(0)).getAbsoluteFile();
    String parentFileName = getParentFileNOrLast(dx, 1).getName();
    List<String> adbPath = new Command.Builder(log).args("which", "adb").permitNonZeroExitStatus(true).execute();
    File adb;
    if (!adbPath.isEmpty()) {
        adb = new File(adbPath.get(0));
    } else {
        // Could not find adb.
        adb = null;
    }
    /*
         * Determine if we are running with a provided SDK or in the AOSP source tree.
         *
         * On Android SDK v23 (Marshmallow) the structure looks like:
         *  <sdk>/build-tools/23.0.1/aapt
         *  <sdk>/platform-tools/adb
         *  <sdk>/build-tools/23.0.1/dx
         *  <sdk>/platforms/android-23/android.jar
         *
         * Android build tree (target):
         *  ${ANDROID_BUILD_TOP}/out/host/linux-x86/bin/aapt
         *  ${ANDROID_BUILD_TOP}/out/host/linux-x86/bin/adb
         *  ${ANDROID_BUILD_TOP}/out/host/linux-x86/bin/dx
         *  ${ANDROID_BUILD_TOP}/out/target/common/obj/JAVA_LIBRARIES/core-libart_intermediates
         *      /classes.jar
         */
    File[] compilationClasspath;
    String androidJarPath;
    String desugarJarPath = null;
    // Accept that we are running in an SDK if the user has added the build-tools or
    // platform-tools to their path.
    boolean dxSdkPathValid = "build-tools".equals(getParentFileNOrLast(dx, 2).getName());
    boolean isAdbPathValid = (adb != null) && "platform-tools".equals(getParentFileNOrLast(adb, 1).getName());
    if (dxSdkPathValid || isAdbPathValid) {
        File sdkRoot = // if dx path invalid then
        dxSdkPathValid ? // if dx path invalid then
        getParentFileNOrLast(dx, 3) : // adb must be valid.
        getParentFileNOrLast(adb, 2);
        File newestPlatform = getNewestPlatform(sdkRoot);
        log.verbose("Using android platform: " + newestPlatform);
        compilationClasspath = new File[] { new File(newestPlatform, "android.jar") };
        androidJarPath = new File(newestPlatform.getAbsolutePath(), "android.jar").getAbsolutePath();
        log.verbose("using android sdk: " + sdkRoot);
        if (!useJack) {
            // There must be a desugar.jar in the same directory as dx.
            String dxParentFileName = getParentFileNOrLast(dx, 1).getName();
            desugarJarPath = dxParentFileName + "/desugar.jar";
            File desugarJarFile = new File(desugarJarPath);
            if (!desugarJarFile.exists()) {
                throw new RuntimeException("Could not find " + desugarJarPath);
            }
        }
    } else if ("bin".equals(parentFileName)) {
        log.verbose("Using android source build mode to find dependencies.");
        String tmpJarPath = "prebuilts/sdk/current/android.jar";
        String androidBuildTop = System.getenv("ANDROID_BUILD_TOP");
        if (!com.google.common.base.Strings.isNullOrEmpty(androidBuildTop)) {
            tmpJarPath = androidBuildTop + "/prebuilts/sdk/current/android.jar";
        } else {
            log.warn("Assuming current directory is android build tree root.");
        }
        androidJarPath = tmpJarPath;
        String outDir = System.getenv("OUT_DIR");
        if (Strings.isNullOrEmpty(outDir)) {
            if (Strings.isNullOrEmpty(androidBuildTop)) {
                outDir = ".";
                log.warn("Assuming we are in android build tree root to find libraries.");
            } else {
                log.verbose("Using ANDROID_BUILD_TOP to find built libraries.");
                outDir = androidBuildTop;
            }
            outDir += "/out/";
        } else {
            log.verbose("Using OUT_DIR environment variable for finding built libs.");
            outDir += "/";
        }
        if (!useJack) {
            File desugarJar = null;
            String desugarPattern = outDir + "host/linux-x86/framework/desugar.jar";
            desugarJar = new File(desugarPattern);
            if (!desugarJar.exists()) {
                throw new RuntimeException("Could not find " + desugarPattern);
            }
            desugarJarPath = desugarJar.getPath();
        }
        String pattern = outDir + "target/common/obj/JAVA_LIBRARIES/%s_intermediates/classes";
        if (modeId.isHost()) {
            pattern = outDir + "host/common/obj/JAVA_LIBRARIES/%s_intermediates/classes";
        }
        pattern += ((useJack) ? ".jack" : ".jar");
        String[] jarNames = modeId.getJarNames();
        compilationClasspath = new File[jarNames.length];
        for (int i = 0; i < jarNames.length; i++) {
            String jar = jarNames[i];
            compilationClasspath[i] = new File(String.format(pattern, jar));
        }
    } else {
        throw new RuntimeException("Couldn't derive Android home from " + dx);
    }
    return new AndroidSdk(log, mkdir, compilationClasspath, androidJarPath, desugarJarPath, new HostFileCache(log, mkdir), language);
}
#method_after
public static AndroidSdk createAndroidSdk(Log log, Mkdir mkdir, ModeId modeId, boolean useJack, Language language) {
    List<String> path = new Command.Builder(log).args("which", "dx").permitNonZeroExitStatus(true).execute();
    if (path.isEmpty()) {
        throw new RuntimeException("dx not found");
    }
    File dx = new File(path.get(0)).getAbsoluteFile();
    String parentFileName = getParentFileNOrLast(dx, 1).getName();
    List<String> adbPath = new Command.Builder(log).args("which", "adb").permitNonZeroExitStatus(true).execute();
    File adb;
    if (!adbPath.isEmpty()) {
        adb = new File(adbPath.get(0));
    } else {
        // Could not find adb.
        adb = null;
    }
    /*
         * Determine if we are running with a provided SDK or in the AOSP source tree.
         *
         * On Android SDK v23 (Marshmallow) the structure looks like:
         *  <sdk>/build-tools/23.0.1/aapt
         *  <sdk>/platform-tools/adb
         *  <sdk>/build-tools/23.0.1/dx
         *  <sdk>/platforms/android-23/android.jar
         *
         * Android build tree (target):
         *  ${ANDROID_BUILD_TOP}/out/host/linux-x86/bin/aapt
         *  ${ANDROID_BUILD_TOP}/out/host/linux-x86/bin/adb
         *  ${ANDROID_BUILD_TOP}/out/host/linux-x86/bin/dx
         *  ${ANDROID_BUILD_TOP}/out/host/linux-x86/bin/desugar.jar
         *  ${ANDROID_BUILD_TOP}/out/target/common/obj/JAVA_LIBRARIES/core-libart_intermediates
         *      /classes.jar
         */
    File[] compilationClasspath;
    String androidJarPath;
    String desugarJarPath = null;
    // Accept that we are running in an SDK if the user has added the build-tools or
    // platform-tools to their path.
    boolean dxSdkPathValid = "build-tools".equals(getParentFileNOrLast(dx, 2).getName());
    boolean isAdbPathValid = (adb != null) && "platform-tools".equals(getParentFileNOrLast(adb, 1).getName());
    if (dxSdkPathValid || isAdbPathValid) {
        File sdkRoot = // if dx path invalid then
        dxSdkPathValid ? // if dx path invalid then
        getParentFileNOrLast(dx, 3) : // adb must be valid.
        getParentFileNOrLast(adb, 2);
        File newestPlatform = getNewestPlatform(sdkRoot);
        log.verbose("Using android platform: " + newestPlatform);
        compilationClasspath = new File[] { new File(newestPlatform, "android.jar") };
        androidJarPath = new File(newestPlatform.getAbsolutePath(), "android.jar").getAbsolutePath();
        log.verbose("using android sdk: " + sdkRoot);
        if (!useJack) {
            // There must be a desugar.jar in the same directory as dx.
            String dxParentFileName = getParentFileNOrLast(dx, 1).getName();
            desugarJarPath = dxParentFileName + "/desugar.jar";
            File desugarJarFile = new File(desugarJarPath);
            if (!desugarJarFile.exists()) {
                throw new RuntimeException("Could not find " + desugarJarPath);
            }
        }
    } else if ("bin".equals(parentFileName)) {
        log.verbose("Using android source build mode to find dependencies.");
        String tmpJarPath = "prebuilts/sdk/current/android.jar";
        String androidBuildTop = System.getenv("ANDROID_BUILD_TOP");
        if (!com.google.common.base.Strings.isNullOrEmpty(androidBuildTop)) {
            tmpJarPath = androidBuildTop + "/prebuilts/sdk/current/android.jar";
        } else {
            log.warn("Assuming current directory is android build tree root.");
        }
        androidJarPath = tmpJarPath;
        String outDir = System.getenv("OUT_DIR");
        if (Strings.isNullOrEmpty(outDir)) {
            if (Strings.isNullOrEmpty(androidBuildTop)) {
                outDir = ".";
                log.warn("Assuming we are in android build tree root to find libraries.");
            } else {
                log.verbose("Using ANDROID_BUILD_TOP to find built libraries.");
                outDir = androidBuildTop;
            }
            outDir += "/out/";
        } else {
            log.verbose("Using OUT_DIR environment variable for finding built libs.");
            outDir += "/";
        }
        if (!useJack) {
            File desugarJar = null;
            String desugarPattern = outDir + "host/linux-x86/framework/desugar.jar";
            desugarJar = new File(desugarPattern);
            if (!desugarJar.exists()) {
                throw new RuntimeException("Could not find " + desugarPattern);
            }
            desugarJarPath = desugarJar.getPath();
        }
        String pattern = outDir + "target/common/obj/JAVA_LIBRARIES/%s_intermediates/classes";
        if (modeId.isHost()) {
            pattern = outDir + "host/common/obj/JAVA_LIBRARIES/%s_intermediates/classes";
        }
        pattern += ((useJack) ? ".jack" : ".jar");
        String[] jarNames = modeId.getJarNames();
        compilationClasspath = new File[jarNames.length];
        for (int i = 0; i < jarNames.length; i++) {
            String jar = jarNames[i];
            compilationClasspath[i] = new File(String.format(pattern, jar));
        }
    } else {
        throw new RuntimeException("Couldn't derive Android home from " + dx);
    }
    return new AndroidSdk(log, mkdir, compilationClasspath, androidJarPath, desugarJarPath, new HostFileCache(log, mkdir), language);
}
#end_block

#method_before
public void dex(boolean multidex, File output, File desugarOutputDir, Classpath classpath, Classpath dependentCp) {
    mkdir.mkdirs(output.getParentFile());
    String classpathSubKey = dexCache.makeKey(classpath);
    String cacheKey = null;
    if (classpathSubKey != null) {
        String multidexSubKey = "mdex=" + multidex;
        cacheKey = dexCache.makeKey(classpathSubKey, multidexSubKey);
        boolean cacheHit = dexCache.getFromCache(output, cacheKey);
        if (cacheHit) {
            log.verbose("dex cache hit for " + classpath);
            return;
        }
    }
    // Call desugar first to remove invoke-dynamic usage,
    // which dx doesn't support.
    Classpath desugarClasspath = classpath.makeTemp(desugarOutputDir, "desugar");
    {
        Command.Builder builder = new Command.Builder(log).args("java", "-jar", desugarJarPath);
        // otherwise it tries to use the java command's bootclasspath.
        for (File f : compilationClasspath) {
            builder.args("--bootclasspath_entry", f.getPath());
        }
        if (dependentCp != null) {
            // were compiled against. Dx does not; so it doesn't use dependentCp.
            for (File f : dependentCp.getElements()) {
                builder.args("--classpath_entry", f.getPath());
            }
        }
        builder.args("--core_library").args("--min_sdk_version", language.getJackMinApilevel());
        Iterator<File> inputIt = classpath.getElements().iterator();
        Iterator<File> outputIt = desugarClasspath.getElements().iterator();
        while (inputIt.hasNext() && outputIt.hasNext()) {
            File desugarInput = inputIt.next();
            File desugarOutput = outputIt.next();
            builder.args("-i", desugarInput.getPath()).args("-o", desugarOutput.getPath());
        }
        builder.execute();
    }
    /*
         * We pass --core-library so that we can write tests in the
         * same package they're testing, even when that's a core
         * library package. If you're actually just using this tool to
         * execute arbitrary code, this has the unfortunate
         * side-effect of preventing "dx" from protecting you from
         * yourself.
         *
         * Memory options pulled from build/core/definitions.mk to
         * handle large dx input when building dex for APK.
         */
    Command.Builder builder = new Command.Builder(log).args("dx").args("-JXms16M").args("-JXmx1536M").args("--min-sdk-version=" + language.getJackMinApilevel());
    if (multidex) {
        builder.args("--multi-dex");
    }
    builder.args("--dex").args("--output=" + output).args("--core-library").args((Object[]) Strings.objectsToStrings(desugarClasspath.getElements()));
    builder.execute();
    dexCache.insert(cacheKey, output);
}
#method_after
public void dex(boolean multidex, File output, File outputTempDir, Classpath classpath, Classpath dependentCp) {
    mkdir.mkdirs(output.getParentFile());
    String classpathSubKey = dexCache.makeKey(classpath);
    String cacheKey = null;
    if (classpathSubKey != null) {
        String multidexSubKey = "mdex=" + multidex;
        cacheKey = dexCache.makeKey(classpathSubKey, multidexSubKey);
        boolean cacheHit = dexCache.getFromCache(output, cacheKey);
        if (cacheHit) {
            log.verbose("dex cache hit for " + classpath);
            return;
        }
    }
    // Call desugar first to remove invoke-dynamic LambdaMetaFactory usage,
    // which ART doesn't support.
    List<String> desugarOutputFilePaths = desugar(outputTempDir, classpath, dependentCp);
    /*
         * We pass --core-library so that we can write tests in the
         * same package they're testing, even when that's a core
         * library package. If you're actually just using this tool to
         * execute arbitrary code, this has the unfortunate
         * side-effect of preventing "dx" from protecting you from
         * yourself.
         *
         * Memory options pulled from build/core/definitions.mk to
         * handle large dx input when building dex for APK.
         */
    Command.Builder builder = new Command.Builder(log).args("dx").args("-JXms16M").args("-JXmx1536M").args("--min-sdk-version=" + language.getMinApiLevel());
    if (multidex) {
        builder.args("--multi-dex");
    }
    builder.args("--dex").args("--output=" + output).args("--core-library").args(desugarOutputFilePaths);
    builder.execute();
    dexCache.insert(cacheKey, output);
}
#end_block

#method_before
@Override
protected Result execute() throws Exception {
    // make the local dex (inside a jar)
    Classpath cp = Classpath.of(jar);
    Classpath dependentCp = classpath;
    if (benchmark && action != null) {
        cp.addAll(classpath);
        dependentCp = null;
    }
    androidSdk.dex(multidex, localDex, localDesugarTempDir, cp, dependentCp);
    return Result.SUCCESS;
}
#method_after
@Override
protected Result execute() throws Exception {
    // make the local dex (inside a jar)
    Classpath cp = Classpath.of(jar);
    Classpath dependentCp = classpath;
    if (benchmark && action != null) {
        cp.addAll(classpath);
        // Everything is already in 'cp' so the dependent classpath becomes empty.
        dependentCp = new Classpath();
    }
    androidSdk.dex(multidex, localDex, localTempDir, cp, dependentCp);
    return Result.SUCCESS;
}
#end_block

#method_before
@Override
public Set<Task> installTasks() {
    Set<Task> result = new HashSet<Task>();
    for (File classpathElement : run.classpath.getElements()) {
        // Libraries need to be dex'ed and put in the temporary directory.
        String name = run.basenameOfJar(classpathElement);
        File localDex = run.localDexFile(name);
        File localDesugarTempDir = run.localDesugarTempDir(name);
        result.add(createCreateDexJarTask(run.classpath, classpathElement, name, null, /* action */
        localDex, localDesugarTempDir));
    }
    result.add(new MkdirTask(run.mkdir, dalvikCache()));
    return result;
}
#method_after
@Override
public Set<Task> installTasks() {
    Set<Task> result = new HashSet<Task>();
    for (File classpathElement : run.classpath.getElements()) {
        // Libraries need to be dex'ed and put in the temporary directory.
        String name = run.basenameOfJar(classpathElement);
        File localDex = run.localDexFile(name);
        File localTempDir = run.localDir(name);
        result.add(createCreateDexJarTask(run.classpath, classpathElement, name, null, /* action */
        localDex, localTempDir));
    }
    result.add(new MkdirTask(run.mkdir, dalvikCache()));
    return result;
}
#end_block

#method_before
@Override
public Set<Task> installActionTasks(Action action, File jar) {
    File localDexFile = run.localDexFile(action.getName());
    File localDesugarTempDir = run.localDesugarTempDir(action.getName());
    Task createDexJarTask = createCreateDexJarTask(Classpath.of(jar), jar, action.getName(), action, localDexFile, localDesugarTempDir);
    return Collections.singleton(createDexJarTask);
}
#method_after
@Override
public Set<Task> installActionTasks(Action action, File jar) {
    File localDexFile = run.localDexFile(action.getName());
    File localTempDir = run.localDir(action.getName());
    Task createDexJarTask = createCreateDexJarTask(Classpath.of(jar), jar, action.getName(), action, localDexFile, localTempDir);
    return Collections.singleton(createDexJarTask);
}
#end_block

#method_before
private Task createCreateDexJarTask(Classpath classpath, File classpathElement, String name, Action action, File localDex, File localDesugarTempDir) {
    Task dex;
    if (run.useJack) {
        dex = new JackDexTask(run, classpath, run.benchmark, name, classpathElement, action, localDex);
    } else {
        dex = new DexTask(run.androidSdk, classpath, run.benchmark, name, classpathElement, action, localDex, localDesugarTempDir, run.multidex);
    }
    return dex;
}
#method_after
private Task createCreateDexJarTask(Classpath classpath, File classpathElement, String name, Action action, File localDex, File localTempDir) {
    Task dex;
    if (run.useJack) {
        dex = new JackDexTask(run, classpath, run.benchmark, name, classpathElement, action, localDex);
    } else {
        dex = new DexTask(run.androidSdk, classpath, run.benchmark, name, classpathElement, action, localDex, localTempDir, run.multidex);
    }
    return dex;
}
#end_block

#method_before
private File createDex(Action action, File actionJar) {
    File dex = run.localFile(action, "classes.dex");
    Classpath classesToDex = Classpath.of(actionJar);
    classesToDex.addAll(run.classpath);
    if (run.useJack) {
        // TODO Implement Jack support for mode=activity.
        throw new UnsupportedOperationException("Jack support for --mode=activity not yet implemented");
    }
    File localDesugarTempDir = run.localDesugarTempDir(action.getName());
    // Do not specify additional compile-time-only dependencies,
    // because everything gets bundled into classes.dex.
    Classpath dependentCp = null;
    run.androidSdk.dex(run.multidex, dex, localDesugarTempDir, classesToDex, dependentCp);
    return dex;
}
#method_after
private File createDex(Action action, File actionJar) {
    File dex = run.localFile(action, "classes.dex");
    Classpath classesToDex = Classpath.of(actionJar);
    classesToDex.addAll(run.classpath);
    if (run.useJack) {
        // TODO Implement Jack support for mode=activity.
        throw new UnsupportedOperationException("Jack support for --mode=activity not yet implemented");
    }
    File localTempDir = run.localDir(action.getName());
    // Do not specify additional compile-time-only dependencies,
    // because everything gets bundled into classes.dex.
    Classpath dependentCp = new Classpath();
    run.androidSdk.dex(run.multidex, dex, localTempDir, classesToDex, dependentCp);
    return dex;
}
#end_block

#method_before
private void disableWifiIpServingLocked(String ifname, int apState) {
    if (DBG)
        Log.d(TAG, "Canceling WiFi tethering request - AP_STATE=" + apState);
    // Tell appropriate interface state machine that it should tear itself down.
    boolean found = false;
    if (!TextUtils.isEmpty(ifname)) {
        final TetherState ts = mTetherStates.get(ifname);
        if (ts != null) {
            ts.stateMachine.unwanted();
            found = true;
        }
    } else {
        for (int i = 0; i < mTetherStates.size(); i++) {
            TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
            if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
                tism.unwanted();
                found = true;
                // There should be at most one of these.
                break;
            }
        }
    }
    if (!found) {
        mLog.log("Error disabling Wi-Fi IP serving; referenced interface: " + ifname);
    }
    // Regardless of whether we requested this transition, the AP has gone
    // down.  Don't try to tether again unless we're requested to do so.
    mWifiTetherRequested = false;
}
#method_after
private void disableWifiIpServingLocked(String ifname, int apState) {
    mLog.log("Canceling WiFi tethering request - AP_STATE=" + apState);
    // Regardless of whether we requested this transition, the AP has gone
    // down.  Don't try to tether again unless we're requested to do so.
    // TODO: Remove this altogether, once Wi-Fi reliably gives us an
    // interface name with every broadcast.
    mWifiTetherRequested = false;
    if (!TextUtils.isEmpty(ifname)) {
        final TetherState ts = mTetherStates.get(ifname);
        if (ts != null) {
            ts.stateMachine.unwanted();
            return;
        }
    }
    for (int i = 0; i < mTetherStates.size(); i++) {
        TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
        if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
            tism.unwanted();
            return;
        }
    }
    mLog.log("Error disabling Wi-Fi IP serving; " + (TextUtils.isEmpty(ifname) ? "no interface name specified" : "specified interface: " + ifname));
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            handleInterfaceServingStateActive(message.arg1, who);
            transitionTo(mTetherModeAliveState);
            break;
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            handleInterfaceServingStateInactive(who);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode requested by " + who);
            handleInterfaceServingStateActive(message.arg1, who);
            transitionTo(mTetherModeAliveState);
            break;
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            who = (TetherInterfaceStateMachine) message.obj;
            if (VDBG)
                Log.d(TAG, "Tether Mode unrequested by " + who);
            handleInterfaceServingStateInactive(who);
            break;
        case EVENT_IFACE_UPDATE_LINKPROPERTIES:
            // Silently ignore these for now.
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
private void handleInterfaceServingStateActive(int mode, TetherInterfaceStateMachine who) {
    if (mNotifyList.indexOf(who) < 0) {
        mNotifyList.add(who);
        mIPv6TetheringCoordinator.addActiveDownstream(who, mode);
    }
    if (mode == IControlsTethering.STATE_TETHERED) {
        mForwardedDownstreams.add(who);
    } else {
        mForwardedDownstreams.remove(who);
    }
    // If this is a Wi-Fi interface, notify WifiManager of the active serving state.
    if (who.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
        final WifiManager mgr = getWifiManager();
        final String iface = who.interfaceName();
        switch(mode) {
            case IControlsTethering.STATE_TETHERED:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_TETHERED);
                break;
            case IControlsTethering.STATE_LOCAL_ONLY:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_LOCAL_ONLY);
                break;
            default:
                Log.wtf(TAG, "Unknown active serving mode: " + mode);
                break;
        }
    }
}
#method_after
private void handleInterfaceServingStateActive(int mode, TetherInterfaceStateMachine who) {
    if (mNotifyList.indexOf(who) < 0) {
        mNotifyList.add(who);
        mIPv6TetheringCoordinator.addActiveDownstream(who, mode);
    }
    if (mode == IControlsTethering.STATE_TETHERED) {
        mForwardedDownstreams.add(who);
    } else {
        mOffloadController.removeDownstreamInterface(who.interfaceName());
        mForwardedDownstreams.remove(who);
    }
    // If this is a Wi-Fi interface, notify WifiManager of the active serving state.
    if (who.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
        final WifiManager mgr = getWifiManager();
        final String iface = who.interfaceName();
        switch(mode) {
            case IControlsTethering.STATE_TETHERED:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_TETHERED);
                break;
            case IControlsTethering.STATE_LOCAL_ONLY:
                mgr.updateInterfaceIpState(iface, IFACE_IP_MODE_LOCAL_ONLY);
                break;
            default:
                Log.wtf(TAG, "Unknown active serving mode: " + mode);
                break;
        }
    }
}
#end_block

#method_before
private void handleInterfaceServingStateInactive(TetherInterfaceStateMachine who) {
    mNotifyList.remove(who);
    mIPv6TetheringCoordinator.removeActiveDownstream(who);
    mForwardedDownstreams.remove(who);
    // If this is a Wi-Fi interface, tell WifiManager of any errors.
    if (who.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
        if (who.lastError() != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
            getWifiManager().updateInterfaceIpState(who.interfaceName(), IFACE_IP_MODE_CONFIGURATION_ERROR);
        }
    }
}
#method_after
private void handleInterfaceServingStateInactive(TetherInterfaceStateMachine who) {
    mNotifyList.remove(who);
    mIPv6TetheringCoordinator.removeActiveDownstream(who);
    mOffloadController.removeDownstreamInterface(who.interfaceName());
    mForwardedDownstreams.remove(who);
    // If this is a Wi-Fi interface, tell WifiManager of any errors.
    if (who.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
        if (who.lastError() != ConnectivityManager.TETHER_ERROR_NO_ERROR) {
            getWifiManager().updateInterfaceIpState(who.interfaceName(), IFACE_IP_MODE_CONFIGURATION_ERROR);
        }
    }
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // This transitions us out of TetherModeAliveState,
                    // either to InitialState or an error state.
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (TetherInterfaceStateMachine o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (!mUpstreamWanted)
                    break;
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case EVENT_IFACE_SERVING_STATE_ACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode requested by " + who);
                handleInterfaceServingStateActive(message.arg1, who);
                who.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_CONNECTION_CHANGED, mCurrentUpstreamIface);
                // If there has been a change and an upstream is now
                // desired, kick off the selection process.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (!previousUpstreamWanted && mUpstreamWanted) {
                    chooseUpstreamType(true);
                }
                break;
            }
        case EVENT_IFACE_SERVING_STATE_INACTIVE:
            {
                TetherInterfaceStateMachine who = (TetherInterfaceStateMachine) message.obj;
                if (VDBG)
                    Log.d(TAG, "Tether Mode unrequested by " + who);
                handleInterfaceServingStateInactive(who);
                if (mNotifyList.isEmpty()) {
                    // This transitions us out of TetherModeAliveState,
                    // either to InitialState or an error state.
                    turnOffMasterTetherSettings();
                    break;
                }
                if (DBG) {
                    Log.d(TAG, "TetherModeAlive still has " + mNotifyList.size() + " live requests:");
                    for (TetherInterfaceStateMachine o : mNotifyList) {
                        Log.d(TAG, "  " + o);
                    }
                }
                // If there has been a change and an upstream is no
                // longer desired, release any mobile requests.
                final boolean previousUpstreamWanted = updateUpstreamWanted();
                if (previousUpstreamWanted && !mUpstreamWanted) {
                    mUpstreamNetworkMonitor.releaseMobileNetworkRequest();
                }
                break;
            }
        case EVENT_IFACE_UPDATE_LINKPROPERTIES:
            {
                final LinkProperties newLp = (LinkProperties) message.obj;
                if (message.arg1 == IControlsTethering.STATE_TETHERED) {
                    mOffloadController.notifyDownstreamLinkProperties(newLp);
                } else {
                    mOffloadController.removeDownstreamInterface(newLp.getInterfaceName());
                }
                break;
            }
        case CMD_UPSTREAM_CHANGED:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            // Need to try DUN immediately if Wi-Fi goes down.
            chooseUpstreamType(true);
            mTryCell = false;
            break;
        case CMD_RETRY_UPSTREAM:
            updateUpstreamWanted();
            if (!mUpstreamWanted)
                break;
            chooseUpstreamType(mTryCell);
            mTryCell = !mTryCell;
            break;
        case EVENT_UPSTREAM_CALLBACK:
            {
                updateUpstreamWanted();
                if (!mUpstreamWanted)
                    break;
                final NetworkState ns = (NetworkState) message.obj;
                if (ns == null || !pertainsToCurrentUpstream(ns)) {
                    // passing validation.
                    if (mCurrentUpstreamIface == null) {
                        // If we have no upstream interface, try to run through upstream
                        // selection again.  If, for example, IPv4 connectivity has shown up
                        // after IPv6 (e.g., 464xlat became available) we want the chance to
                        // notice and act accordingly.
                        chooseUpstreamType(false);
                    }
                    break;
                }
                switch(message.arg1) {
                    case UpstreamNetworkMonitor.EVENT_ON_AVAILABLE:
                        // arrive there's nothing to do.
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_CAPABILITIES:
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LINKPROPERTIES:
                        setDnsForwarders(ns.network, ns.linkProperties);
                        handleNewUpstreamNetworkState(ns);
                        break;
                    case UpstreamNetworkMonitor.EVENT_ON_LOST:
                        // TODO: Re-evaluate possible upstreams. Currently upstream
                        // reevaluation is triggered via received CONNECTIVITY_ACTION
                        // broadcasts that result in being passed a
                        // TetherMasterSM.CMD_UPSTREAM_CHANGED.
                        handleNewUpstreamNetworkState(null);
                        break;
                    default:
                        break;
                }
                break;
            }
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#end_block

#method_before
@Override
public void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    mLog.log(String.format("OBSERVED iface=%s state=%s error=%s", iface, state, error));
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    int which;
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + state);
            return;
    }
    mTetherMasterSM.sendMessage(which, state, 0, who);
    sendTetherStateChangedBroadcast();
}
#method_after
private void notifyInterfaceStateChange(String iface, TetherInterfaceStateMachine who, int state, int error) {
    synchronized (mPublicSync) {
        final TetherState tetherState = mTetherStates.get(iface);
        if (tetherState != null && tetherState.stateMachine.equals(who)) {
            tetherState.lastState = state;
            tetherState.lastError = error;
        } else {
            if (DBG)
                Log.d(TAG, "got notification from stale iface " + iface);
        }
    }
    mLog.log(String.format("OBSERVED iface=%s state=%s error=%s", iface, state, error));
    try {
        // Notify that we're tethering (or not) this interface.
        // This is how data saver for instance knows if the user explicitly
        // turned on tethering (thus keeping us from being in data saver mode).
        mPolicyManager.onTetheringChanged(iface, state == IControlsTethering.STATE_TETHERED);
    } catch (RemoteException e) {
    // Not really very much we can do here.
    }
    // by sending CMD_CLEAR_ERROR
    if (error == ConnectivityManager.TETHER_ERROR_MASTER_ERROR) {
        mTetherMasterSM.sendMessage(TetherMasterSM.CMD_CLEAR_ERROR, who);
    }
    int which;
    switch(state) {
        case IControlsTethering.STATE_UNAVAILABLE:
        case IControlsTethering.STATE_AVAILABLE:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_INACTIVE;
            break;
        case IControlsTethering.STATE_TETHERED:
        case IControlsTethering.STATE_LOCAL_ONLY:
            which = TetherMasterSM.EVENT_IFACE_SERVING_STATE_ACTIVE;
            break;
        default:
            Log.wtf(TAG, "Unknown interface state: " + state);
            return;
    }
    mTetherMasterSM.sendMessage(which, state, 0, who);
    sendTetherStateChangedBroadcast();
}
#end_block

#method_before
private void maybeTrackNewInterfaceLocked(final String iface) {
    // If we don't care about this type of interface, ignore.
    final int interfaceType = ifaceNameToType(iface);
    if (interfaceType == ConnectivityManager.TETHERING_INVALID) {
        mLog.log(iface + " is not a tetherable iface, ignoring");
        return;
    }
    // If we have already started a TISM for this interface, skip.
    if (mTetherStates.containsKey(iface)) {
        mLog.log("active iface (" + iface + ") reported as added, ignoring");
        return;
    }
    mLog.log("adding TetheringInterfaceStateMachine for: " + iface);
    final TetherState tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, this, new IPv6TetheringInterfaceServices(iface, mNMService, mLog)));
    mTetherStates.put(iface, tetherState);
    tetherState.stateMachine.start();
}
#method_after
private void maybeTrackNewInterfaceLocked(final String iface) {
    // If we don't care about this type of interface, ignore.
    final int interfaceType = ifaceNameToType(iface);
    if (interfaceType == ConnectivityManager.TETHERING_INVALID) {
        mLog.log(iface + " is not a tetherable iface, ignoring");
        return;
    }
    // If we have already started a TISM for this interface, skip.
    if (mTetherStates.containsKey(iface)) {
        mLog.log("active iface (" + iface + ") reported as added, ignoring");
        return;
    }
    mLog.log("adding TetheringInterfaceStateMachine for: " + iface);
    final TetherState tetherState = new TetherState(new TetherInterfaceStateMachine(iface, mLooper, interfaceType, mLog, mNMService, mStatsService, makeControlCallback(iface), new IPv6TetheringInterfaceServices(iface, mNMService, mLog)));
    mTetherStates.put(iface, tetherState);
    tetherState.stateMachine.start();
}
#end_block

#method_before
private void stopTrackingInterfaceLocked(final String iface) {
    final TetherState tetherState = mTetherStates.get(iface);
    if (tetherState == null) {
        mLog.log("attempting to remove unknown iface (" + iface + "), ignoring");
        return;
    }
    tetherState.stateMachine.sendMessage(TetherInterfaceStateMachine.CMD_INTERFACE_DOWN);
    mLog.log("removing TetheringInterfaceStateMachine for: " + iface);
    mTetherStates.remove(iface);
}
#method_after
private void stopTrackingInterfaceLocked(final String iface) {
    final TetherState tetherState = mTetherStates.get(iface);
    if (tetherState == null) {
        mLog.log("attempting to remove unknown iface (" + iface + "), ignoring");
        return;
    }
    tetherState.stateMachine.stop();
    mLog.log("removing TetheringInterfaceStateMachine for: " + iface);
    mTetherStates.remove(iface);
}
#end_block

#method_before
private void sendInterfaceState(int newInterfaceState) {
    mTetherController.notifyInterfaceStateChange(mIfaceName, TetherInterfaceStateMachine.this, newInterfaceState, mLastError);
}
#method_after
private void sendInterfaceState(int newInterfaceState) {
    mTetherController.updateInterfaceState(TetherInterfaceStateMachine.this, newInterfaceState, mLastError);
    // TODO: Populate mLinkProperties correctly, and send more sensible
    // updates more frequently (not just here).
    mTetherController.updateLinkProperties(TetherInterfaceStateMachine.this, new LinkProperties(mLinkProperties));
}
#end_block

#method_before
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    boolean retValue = true;
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            switch(message.arg1) {
                case IControlsTethering.STATE_LOCAL_ONLY:
                    transitionTo(mLocalHotspotState);
                    break;
                case IControlsTethering.STATE_TETHERED:
                    transitionTo(mTetheredState);
                    break;
                default:
                    mLog.e("Invalid tethering interface serving state specified.");
            }
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            break;
        case CMD_IPV6_TETHER_UPDATE:
            mIPv6TetherSvc.updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            break;
        default:
            retValue = false;
            break;
    }
    return retValue;
}
#method_after
@Override
public boolean processMessage(Message message) {
    maybeLogMessage(this, message.what);
    switch(message.what) {
        case CMD_TETHER_REQUESTED:
            mLastError = ConnectivityManager.TETHER_ERROR_NO_ERROR;
            switch(message.arg1) {
                case IControlsTethering.STATE_LOCAL_ONLY:
                    transitionTo(mLocalHotspotState);
                    break;
                case IControlsTethering.STATE_TETHERED:
                    transitionTo(mTetheredState);
                    break;
                default:
                    mLog.e("Invalid tethering interface serving state specified.");
            }
            break;
        case CMD_INTERFACE_DOWN:
            transitionTo(mUnavailableState);
            break;
        case CMD_IPV6_TETHER_UPDATE:
            mIPv6TetherSvc.updateUpstreamIPv6LinkProperties((LinkProperties) message.obj);
            break;
        default:
            return NOT_HANDLED;
    }
    return HANDLED;
}
#end_block

#method_before
// So many TODOs here, but chief among them is: make this functionality an
// integral part of this class such that whenever a higher priority network
// becomes available and useful we (a) file a request to keep it up as
// necessary and (b) change all upstream tracking state accordingly (by
// passing LinkProperties up to Tethering).
// 
public int selectPreferredUpstreamType(Collection<Integer> preferredTypes) {
    final TypeStatePair typeStatePair = findFirstAvailableUpstreamByType(mNetworkMap.values(), preferredTypes);
    mLog.log("preferred upstream type: " + getNetworkTypeName(typeStatePair.type));
    switch(typeStatePair.type) {
        case TYPE_MOBILE_DUN:
        case TYPE_MOBILE_HIPRI:
            // If we're on DUN, put our own grab on it.
            registerMobileNetworkRequest();
            break;
        case TYPE_NONE:
            break;
        default:
            /* If we've found an active upstream connection that's not DUN/HIPRI
                 * we should stop any outstanding DUN/HIPRI start requests.
                 *
                 * If we found NONE we don't want to do this as we want any previous
                 * requests to keep trying to bring up something we can use.
                 */
            releaseMobileNetworkRequest();
            break;
    }
    return typeStatePair.type;
}
#method_after
// So many TODOs here, but chief among them is: make this functionality an
// integral part of this class such that whenever a higher priority network
// becomes available and useful we (a) file a request to keep it up as
// necessary and (b) change all upstream tracking state accordingly (by
// passing LinkProperties up to Tethering).
// 
public int selectPreferredUpstreamType(Iterable<Integer> preferredTypes) {
    final TypeStatePair typeStatePair = findFirstAvailableUpstreamByType(mNetworkMap.values(), preferredTypes);
    mLog.log("preferred upstream type: " + getNetworkTypeName(typeStatePair.type));
    switch(typeStatePair.type) {
        case TYPE_MOBILE_DUN:
        case TYPE_MOBILE_HIPRI:
            // If we're on DUN, put our own grab on it.
            registerMobileNetworkRequest();
            break;
        case TYPE_NONE:
            break;
        default:
            /* If we've found an active upstream connection that's not DUN/HIPRI
                 * we should stop any outstanding DUN/HIPRI start requests.
                 *
                 * If we found NONE we don't want to do this as we want any previous
                 * requests to keep trying to bring up something we can use.
                 */
            releaseMobileNetworkRequest();
            break;
    }
    return typeStatePair.type;
}
#end_block

#method_before
static private TypeStatePair findFirstAvailableUpstreamByType(Collection<NetworkState> netStates, Collection<Integer> preferredTypes) {
    final TypeStatePair result = new TypeStatePair();
    for (Integer type : preferredTypes) {
        NetworkCapabilities nc;
        try {
            nc = ConnectivityManager.networkCapabilitiesForType(type.intValue());
        } catch (IllegalArgumentException iae) {
            Log.e(TAG, "No NetworkCapabilities mapping for legacy type: " + type);
            continue;
        }
        for (NetworkState value : netStates) {
            if (!nc.satisfiedByNetworkCapabilities(value.networkCapabilities)) {
                continue;
            }
            result.type = type.intValue();
            result.ns = value;
            return result;
        }
    }
    return result;
}
#method_after
static private TypeStatePair findFirstAvailableUpstreamByType(Iterable<NetworkState> netStates, Iterable<Integer> preferredTypes) {
    final TypeStatePair result = new TypeStatePair();
    for (int type : preferredTypes) {
        NetworkCapabilities nc;
        try {
            nc = ConnectivityManager.networkCapabilitiesForType(type);
        } catch (IllegalArgumentException iae) {
            Log.e(TAG, "No NetworkCapabilities mapping for legacy type: " + ConnectivityManager.getNetworkTypeName(type));
            continue;
        }
        for (NetworkState value : netStates) {
            if (!nc.satisfiedByNetworkCapabilities(value.networkCapabilities)) {
                continue;
            }
            result.type = type;
            result.ns = value;
            return result;
        }
    }
    return result;
}
#end_block

#method_before
@Override
protected void finalize() {
    count.value++;
}
#method_after
@Override
protected void finalize() {
    count.incrementAndGet();
}
#end_block

#method_before
public void timeFinalization(int reps) {
    // Allocate a bunch of finalizable objects.
    int n = reps;
    IntRef count = new IntRef();
    for (int i = 0; i < n; i++) {
        new FinalizableObject(count);
    }
    // Run GC so the objects will be collected for finalization.
    Runtime.getRuntime().gc();
    // Wait for finalization.
    Runtime.getRuntime().runFinalization();
    // Double check all the objects were finalized.
    if (n != count.value) {
        throw new IllegalStateException(String.format("Only %i of %i objects finalized?", count.value, n));
    }
}
#method_after
public void timeFinalization(int reps) {
    // Allocate a bunch of finalizable objects.
    int n = reps;
    AtomicInteger count = new AtomicInteger(0);
    for (int i = 0; i < n; i++) {
        new FinalizableObject(count);
    }
    // Run GC so the objects will be collected for finalization.
    Runtime.getRuntime().gc();
    // Wait for finalization.
    Runtime.getRuntime().runFinalization();
    // Double check all the objects were finalized.
    int got = count.get();
    if (n != got) {
        throw new IllegalStateException(String.format("Only %i of %i objects finalized?", got, n));
    }
}
#end_block

#method_before
@Override
public void run() {
    // This loop may be performance critical, since we need to keep up with mutator
    // generation of finalizable objects.
    // We minimize the amount of work we do per finalizable object. For example, we avoid
    // reading the current time here, since that involves a kernel call per object.  We
    // limit fast path communication with FinalizerWatchDogDaemon to what's unavoidable: A
    // non-volatile store to communicate the current finalizable object, e.g. for
    // reporting, and a release store (lazySet) to a counter.
    // We do stop the  FinalizerWatchDogDaemon if we have nothing to do for a
    // potentially extended period.  This prevents the device from waking up regularly
    // during idle times.
    // Local copy of progressCounter; saves a fence per increment on ARM and MIPS.
    int localProgressCounter = progressCounter.get();
    while (isRunning()) {
        try {
            // Use non-blocking poll to avoid FinalizerWatchdogDaemon communication
            // when busy.
            List<Reference<?>> objects = queue.pollAll();
            if (objects == null) {
                // Slow path; block.
                finalizingObject = null;
                FinalizerWatchdogDaemon.INSTANCE.goToSleep();
                finalizingObject = (FinalizerReference<?>) queue.remove();
                progressCounter.set(++localProgressCounter);
                FinalizerWatchdogDaemon.INSTANCE.wakeUp();
                doFinalize(finalizingObject);
            } else {
                for (Reference<?> object : objects) {
                    finalizingObject = (FinalizerReference<?>) object;
                    progressCounter.lazySet(++localProgressCounter);
                    doFinalize(finalizingObject);
                }
            }
        } catch (InterruptedException ignored) {
        } catch (OutOfMemoryError ignored) {
        }
    }
}
#method_after
@Override
public void run() {
    // This loop may be performance critical, since we need to keep up with mutator
    // generation of finalizable objects.
    // We minimize the amount of work we do per finalizable object. For example, we avoid
    // reading the current time here, since that involves a kernel call per object.  We
    // limit fast path communication with FinalizerWatchDogDaemon to what's unavoidable: A
    // non-volatile store to communicate the current finalizable object, e.g. for
    // reporting, and a release store (lazySet) to a counter.
    // We do stop the  FinalizerWatchDogDaemon if we have nothing to do for a
    // potentially extended period.  This prevents the device from waking up regularly
    // during idle times.
    // Local copy of progressCounter; saves a fence per increment on ARM and MIPS.
    int localProgressCounter = progressCounter.get();
    while (isRunning()) {
        try {
            // Use non-blocking poll to avoid FinalizerWatchdogDaemon communication
            // when busy.
            FinalizerReference<?> finalizingReference = (FinalizerReference<?>) queue.poll();
            if (finalizingReference != null) {
                finalizingObject = finalizingReference.get();
                progressCounter.lazySet(++localProgressCounter);
            } else {
                finalizingObject = null;
                progressCounter.lazySet(++localProgressCounter);
                // Slow path; block.
                FinalizerWatchdogDaemon.INSTANCE.goToSleep();
                finalizingReference = (FinalizerReference<?>) queue.remove();
                finalizingObject = finalizingReference.get();
                progressCounter.set(++localProgressCounter);
                FinalizerWatchdogDaemon.INSTANCE.wakeUp();
            }
            doFinalize(finalizingReference);
        } catch (InterruptedException ignored) {
        } catch (OutOfMemoryError ignored) {
        }
    }
}
#end_block

#method_before
@FindBugsSuppressWarnings("FI_EXPLICIT_INVOCATION")
private void doFinalize(FinalizerReference<?> reference) {
    FinalizerReference.remove(reference);
    Object object = reference.get();
    reference.clear();
    try {
        object.finalize();
    } catch (Throwable ex) {
        // The RI silently swallows these, but Android has always logged.
        System.logE("Uncaught exception thrown by finalizer", ex);
    }
}
#method_after
@FindBugsSuppressWarnings("FI_EXPLICIT_INVOCATION")
private void doFinalize(FinalizerReference<?> reference) {
    FinalizerReference.remove(reference);
    Object object = reference.get();
    reference.clear();
    try {
        object.finalize();
    } catch (Throwable ex) {
        // The RI silently swallows these, but Android has always logged.
        System.logE("Uncaught exception thrown by finalizer", ex);
    } finally {
        // Done finalizing, stop holding the object as live.
        finalizingObject = null;
    }
}
#end_block

#method_before
@Override
public void run() {
    while (isRunning()) {
        if (!sleepUntilNeeded()) {
            // We have been interrupted, need to see if this daemon has been stopped.
            continue;
        }
        final FinalizerReference<?> finalizing = waitForFinalization();
        if (finalizing != null && !VMRuntime.getRuntime().isDebuggerActive()) {
            finalizerTimedOut(finalizing);
            break;
        }
    }
}
#method_after
@Override
public void run() {
    while (isRunning()) {
        if (!sleepUntilNeeded()) {
            // We have been interrupted, need to see if this daemon has been stopped.
            continue;
        }
        final Object finalizing = waitForFinalization();
        if (finalizing != null && !VMRuntime.getRuntime().isDebuggerActive()) {
            finalizerTimedOut(finalizing);
            break;
        }
    }
}
#end_block

#method_before
private void sleepFor(long durationNanos) {
    long startNanos = System.nanoTime();
    while (true) {
        long elapsedNanos = System.nanoTime() - startNanos;
        long sleepNanos = durationNanos - elapsedNanos;
        long sleepMills = sleepNanos / NANOS_PER_MILLI;
        if (sleepMills <= 0) {
            return;
        }
        try {
            Thread.sleep(sleepMills);
        } catch (InterruptedException e) {
            if (!isRunning()) {
                return;
            }
        } catch (OutOfMemoryError ignored) {
            if (!isRunning()) {
                return;
            }
        }
    }
}
#method_after
private boolean sleepFor(long durationNanos) {
    long startNanos = System.nanoTime();
    while (true) {
        long elapsedNanos = System.nanoTime() - startNanos;
        long sleepNanos = durationNanos - elapsedNanos;
        long sleepMills = sleepNanos / NANOS_PER_MILLI;
        if (sleepMills <= 0) {
            return true;
        }
        try {
            Thread.sleep(sleepMills);
        } catch (InterruptedException e) {
            if (!isRunning()) {
                return false;
            }
        } catch (OutOfMemoryError ignored) {
            if (!isRunning()) {
                return false;
            }
        }
    }
}
#end_block

#method_before
private FinalizerReference<?> waitForFinalization() {
    long startCount = FinalizerDaemon.INSTANCE.progressCounter.get();
    // Avoid remembering object being finalized, so as not to keep it alive.
    sleepFor(MAX_FINALIZE_NANOS);
    if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) {
        // We assume that only remove() and doFinalize() may take time comparable to
        // MAX_FINALIZE_NANOS.
        // We observed neither the effect of the gotoSleep() nor the increment preceding a
        // later wakeUp. Any remove() call by the FinalizerDaemon during our sleep
        // interval must have been followed by a wakeUp call before we checked needToWork.
        // But then we would have seen the counter increment.  Thus there cannot have
        // been such a remove() call.
        // The FinalizerDaemon must not have progressed (from either the beginning or the
        // last progressCounter increment) to either the next increment or gotoSleep()
        // call.  Thus we must have taken essentially the whole MAX_FINALIZE_NANOS in a
        // single doFinalize() call.  Thus it's OK to time out.  finalizingObject was set
        // just before the counter increment, which preceded the doFinalize call.  Thus we
        // are guaranteed to get the correct finalizing value below, unless doFinalize()
        // just finished as we were timing out, in which case we may get null or a later
        // one.  In this last case, we are very likely to discard it below.
        FinalizerReference<?> finalizing = FinalizerDaemon.INSTANCE.finalizingObject;
        sleepFor(NANOS_PER_SECOND);
        // the case which a very slow finalization just finished as we were timing out.
        if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) {
            return finalizing;
        }
    }
    return null;
}
#method_after
private Object waitForFinalization() {
    long startCount = FinalizerDaemon.INSTANCE.progressCounter.get();
    // Avoid remembering object being finalized, so as not to keep it alive.
    if (!sleepFor(MAX_FINALIZE_NANOS)) {
        // Don't report possibly spurious timeout if we are interrupted.
        return null;
    }
    if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) {
        // We assume that only remove() and doFinalize() may take time comparable to
        // MAX_FINALIZE_NANOS.
        // We observed neither the effect of the gotoSleep() nor the increment preceding a
        // later wakeUp. Any remove() call by the FinalizerDaemon during our sleep
        // interval must have been followed by a wakeUp call before we checked needToWork.
        // But then we would have seen the counter increment.  Thus there cannot have
        // been such a remove() call.
        // The FinalizerDaemon must not have progressed (from either the beginning or the
        // last progressCounter increment) to either the next increment or gotoSleep()
        // call.  Thus we must have taken essentially the whole MAX_FINALIZE_NANOS in a
        // single doFinalize() call.  Thus it's OK to time out.  finalizingObject was set
        // just before the counter increment, which preceded the doFinalize call.  Thus we
        // are guaranteed to get the correct finalizing value below, unless doFinalize()
        // just finished as we were timing out, in which case we may get null or a later
        // one.  In this last case, we are very likely to discard it below.
        Object finalizing = FinalizerDaemon.INSTANCE.finalizingObject;
        sleepFor(NANOS_PER_SECOND / 2);
        // the case which a very slow finalization just finished as we were timing out.
        if (getNeedToWork() && FinalizerDaemon.INSTANCE.progressCounter.get() == startCount) {
            return finalizing;
        }
    }
    return null;
}
#end_block

#method_before
protected void setLocalPypiPath() throws RuntimeException {
    VtsVendorConfigFileUtil configReader = new VtsVendorConfigFileUtil();
    String configFilePath = configReader.GetVendorConfigFilePath();
    CLog.i("Loading vendor test config %s", configFilePath);
    InputStream config = getClass().getResourceAsStream(configFilePath);
    // First try to load local PyPI directory path from vendor config file
    if (config != null) {
        try {
            String content = StreamUtil.getStringFromStream(config);
            CLog.i("Loaded vendor test config %s", content);
            if (content != null) {
                JSONObject vendorConfigJson = new JSONObject(content);
                try {
                    String pypiPath = vendorConfigJson.getString(LOCAL_PYPI_PATH_KEY);
                    if (pypiPath.length() > 0 && dirExistsAndHaveReadAccess(pypiPath)) {
                        mLocalPypiPath = pypiPath;
                        CLog.i(String.format("Loaded %s: %s", LOCAL_PYPI_PATH_KEY, mLocalPypiPath));
                    }
                } catch (NoSuchElementException e) {
                    CLog.i("Vendor test config file does not define %s", LOCAL_PYPI_PATH_KEY);
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to read vendor config json file");
        } catch (JSONException e) {
            throw new RuntimeException("Failed to parse vendor config json data");
        }
    } else {
        CLog.i("Vendor test config file %s does not exist", configFilePath);
    }
    // check local pypi path defined by LOCAL_PYPI_PATH_ENV_VAR_NAME
    if (mLocalPypiPath == null) {
        CLog.i("Checking whether local pypi packages directory exists");
        String pypiPath = System.getenv(LOCAL_PYPI_PATH_ENV_VAR_NAME);
        if (pypiPath == null) {
            CLog.i("Local pypi packages directory not specified by env var %s", LOCAL_PYPI_PATH_ENV_VAR_NAME);
        } else if (dirExistsAndHaveReadAccess(pypiPath)) {
            mLocalPypiPath = pypiPath;
            CLog.i("Set local pypi packages directory to %s", pypiPath);
        }
    }
    if (mLocalPypiPath == null) {
        CLog.i("Failed to set local pypi packages path. Therefore internet connection to " + "https://pypi.python.org/simple/ must be available to run VTS tests.");
    }
}
#method_after
protected void setLocalPypiPath() throws RuntimeException {
    VtsVendorConfigFileUtil configReader = new VtsVendorConfigFileUtil();
    if (configReader.LoadVendorConfig(null)) {
        // First try to load local PyPI directory path from vendor config file
        try {
            String pypiPath = configReader.GetVendorConfigVariable(LOCAL_PYPI_PATH_KEY);
            if (pypiPath.length() > 0 && dirExistsAndHaveReadAccess(pypiPath)) {
                mLocalPypiPath = pypiPath;
                CLog.i(String.format("Loaded %s: %s", LOCAL_PYPI_PATH_KEY, mLocalPypiPath));
            }
        } catch (NoSuchElementException e) {
        /* continue */
        }
    }
    // check local pypi path defined by LOCAL_PYPI_PATH_ENV_VAR_NAME
    if (mLocalPypiPath == null) {
        CLog.i("Checking whether local pypi packages directory exists");
        String pypiPath = System.getenv(LOCAL_PYPI_PATH_ENV_VAR_NAME);
        if (pypiPath == null) {
            CLog.i("Local pypi packages directory not specified by env var %s", LOCAL_PYPI_PATH_ENV_VAR_NAME);
        } else if (dirExistsAndHaveReadAccess(pypiPath)) {
            mLocalPypiPath = pypiPath;
            CLog.i("Set local pypi packages directory to %s", pypiPath);
        }
    }
    if (mLocalPypiPath == null) {
        CLog.i("Failed to set local pypi packages path. Therefore internet connection to " + "https://pypi.python.org/simple/ must be available to run VTS tests.");
    }
}
#end_block

#method_before
private void readVtsTradeFedVendorConfig() throws RuntimeException {
    VtsVendorConfigFileUtil configReader = new VtsVendorConfigFileUtil();
    String configFilePath = configReader.GetVendorConfigFilePath();
    Log.d(LOG_TAG, String.format("Load vendor test config %s", configFilePath));
    InputStream config = getClass().getResourceAsStream(configFilePath);
    if (config == null) {
        Log.d(LOG_TAG, String.format("Vendor test config file %s does not exist.", configFilePath));
        return;
    }
    try {
        String content = StreamUtil.getStringFromStream(config);
        Log.d(LOG_TAG, String.format("Loaded vendor test config %s", content));
        if (content != null) {
            JSONObject vendorConfigJson = new JSONObject(content);
            try {
                String tracePath = vendorConfigJson.getString(HOST_PROFILING_TRACE_PATH_KEY);
                if (tracePath.length() > 0) {
                    mHostProfilingTracePath = tracePath;
                }
            } catch (NoSuchElementException e) {
                Log.d(LOG_TAG, String.format("Vendor config does not define %s", HOST_PROFILING_TRACE_PATH_KEY));
            }
        }
    } catch (IOException e) {
        throw new RuntimeException("Failed to read vendor config json file");
    } catch (JSONException e) {
        throw new RuntimeException("Failed to build updated vendor config json data");
    }
}
#method_after
private void readVtsTradeFedVendorConfig() throws RuntimeException {
    VtsVendorConfigFileUtil configReader = new VtsVendorConfigFileUtil();
    if (configReader.LoadVendorConfig(null)) {
        try {
            String tracePath = configReader.GetVendorConfigVariable(HOST_PROFILING_TRACE_PATH_KEY);
            if (tracePath.length() > 0) {
                mHostProfilingTracePath = tracePath;
            }
        } catch (NoSuchElementException e) {
        /* use the default */
        }
    }
}
#end_block

#method_before
private void updateVtsRunnerTestConfig(JSONObject jsonObject) throws IOException, JSONException, RuntimeException {
    VtsVendorConfigFileUtil configReader = new VtsVendorConfigFileUtil();
    String configFilePath = configReader.GetVendorConfigFilePath();
    CLog.i("Load vendor test config %s", configFilePath);
    InputStream config = getClass().getResourceAsStream(configFilePath);
    if (config != null) {
        try {
            String content = StreamUtil.getStringFromStream(config);
            CLog.i("Loaded vendor test config %s", content);
            if (content != null) {
                JSONObject vendorConfigJson = new JSONObject(content);
                JsonUtil.deepMergeJsonObjects(jsonObject, vendorConfigJson);
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to read vendor config json file");
        } catch (JSONException e) {
            throw new RuntimeException("Failed to build updated vendor config json data");
        }
    }
    CLog.i("Load original test config %s %s", mTestCaseDataDir, mTestConfigPath);
    String content = null;
    if (mTestConfigPath != null) {
        content = FileUtil.readStringFromFile(new File(Paths.get(mTestCaseDataDir, mTestConfigPath).toString()));
    }
    CLog.i("Loaded original test config %s", content);
    if (content != null) {
        JsonUtil.deepMergeJsonObjects(jsonObject, new JSONObject(content));
    }
    populateDefaultJsonFields(jsonObject, mTestCaseDataDir);
    CLog.i("Built a Json object using the loaded original test config");
    JSONArray deviceArray = new JSONArray();
    JSONObject deviceItemObject = new JSONObject();
    deviceItemObject.put(SERIAL, mDevice.getSerialNumber());
    boolean coverageBuild = false;
    try {
        deviceItemObject.put("product_type", mDevice.getProductType());
        deviceItemObject.put("product_variant", mDevice.getProductVariant());
        deviceItemObject.put("build_alias", mDevice.getBuildAlias());
        deviceItemObject.put("build_id", mDevice.getBuildId());
        deviceItemObject.put("build_flavor", mDevice.getBuildFlavor());
        String coverageProperty = mDevice.getProperty(COVERAGE_PROPERTY);
        coverageBuild = coverageProperty != null && coverageProperty.equals("1");
    } catch (DeviceNotAvailableException e) {
        CLog.e("A device not available - continuing");
        throw new RuntimeException("Failed to get device information");
    }
    deviceArray.put(deviceItemObject);
    JSONArray testBedArray = (JSONArray) jsonObject.get("test_bed");
    if (testBedArray.length() == 0) {
        JSONObject device = new JSONObject();
        String testName;
        if (mTestModuleName != null) {
            testName = mTestModuleName;
        } else {
            CLog.w("--test-module-name not set (not recommended); deriving automatically");
            if (mTestConfigPath != null) {
                testName = new File(mTestConfigPath).getName();
                testName = testName.replace(CONFIG_FILE_EXTENSION, "");
            } else if (mTestCasePath != null) {
                testName = new File(mTestCasePath).getName();
            } else {
                throw new RuntimeException("Failed to derive test module name; use --test-module-name option");
            }
        }
        if (testName.length() > MAX_TEST_NAME_LENGTH) {
            throw new RuntimeException("Test module name is too long: " + testName + ". (" + testName.length() + ">" + MAX_TEST_NAME_LENGTH + ")");
        }
        CLog.logAndDisplay(LogLevel.INFO, "Setting test name as %s", testName);
        device.put(NAME, testName);
        device.put(ANDROIDDEVICE, deviceArray);
        testBedArray.put(device);
    } else if (testBedArray.length() == 1) {
        JSONObject device = (JSONObject) testBedArray.get(0);
        device.put(ANDROIDDEVICE, deviceArray);
    } else {
        CLog.e("Multi-device not yet supported: %d devices requested", testBedArray.length());
        throw new RuntimeException("Failed to produce VTS runner test config");
    }
    jsonObject.put(DATA_FILE_PATH, mTestCaseDataDir);
    CLog.i("Added %s = %s to the Json object", DATA_FILE_PATH, mTestCaseDataDir);
    JSONObject build = new JSONObject();
    build.put(BUILD_ID, mBuildInfo.getBuildId());
    build.put(BUILD_TARGET, mBuildInfo.getBuildTargetName());
    jsonObject.put(BUILD, build);
    CLog.i("Added %s to the Json object", BUILD);
    JSONObject suite = new JSONObject();
    suite.put(NAME, mBuildInfo.getTestTag());
    suite.put(INCLUDE_FILTER, new JSONArray(mIncludeFilters));
    CLog.i("Added include filter to test suite: %s", mIncludeFilters);
    suite.put(EXCLUDE_FILTER, new JSONArray(mExcludeFilters));
    CLog.i("Added exclude filter to test suite: %s", mExcludeFilters);
    jsonObject.put(TEST_SUITE, suite);
    CLog.i("Added %s to the Json object", TEST_SUITE);
    if (mAbi != null) {
        jsonObject.put(ABI_NAME, mAbi.getName());
        CLog.i("Added %s to the Json object", ABI_NAME);
        jsonObject.put(ABI_BITNESS, mAbi.getBitness());
        CLog.i("Added %s to the Json object", ABI_BITNESS);
    }
    if (mSkipOn32BitAbi) {
        jsonObject.put(SKIP_ON_32BIT_ABI, mSkipOn32BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_32BIT_ABI);
    }
    if (mSkipOn64BitAbi) {
        jsonObject.put(SKIP_ON_64BIT_ABI, mSkipOn64BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_64BIT_ABI);
    } else if (mRun32bBitOn64BitAbi) {
        jsonObject.put(RUN_32BIT_ON_64BIT_ABI, mRun32bBitOn64BitAbi);
        CLog.i("Added %s to the Json object", RUN_32BIT_ON_64BIT_ABI);
    }
    if (mSkipIfThermalThrottling) {
        jsonObject.put(SKIP_IF_THERMAL_THROTTLING, mSkipIfThermalThrottling);
        CLog.i("Added %s to the Json object", SKIP_IF_THERMAL_THROTTLING);
    }
    if (!mBinaryTestSource.isEmpty()) {
        jsonObject.put(BINARY_TEST_SOURCE, new JSONArray(mBinaryTestSource));
        CLog.i("Added %s to the Json object", BINARY_TEST_SOURCE);
    }
    if (!mBinaryTestWorkingDirectory.isEmpty()) {
        jsonObject.put(BINARY_TEST_WORKING_DIRECTORY, new JSONArray(mBinaryTestWorkingDirectory));
        CLog.i("Added %s to the Json object", BINARY_TEST_WORKING_DIRECTORY);
    }
    if (!mBinaryTestEnvp.isEmpty()) {
        jsonObject.put(BINARY_TEST_ENVP, new JSONArray(mBinaryTestEnvp));
        CLog.i("Added %s to the Json object", BINARY_TEST_ENVP);
    }
    if (!mBinaryTestArgs.isEmpty()) {
        jsonObject.put(BINARY_TEST_ARGS, new JSONArray(mBinaryTestArgs));
        CLog.i("Added %s to the Json object", BINARY_TEST_ARGS);
    }
    if (!mBinaryTestLdLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_LD_LIBRARY_PATH, new JSONArray(mBinaryTestLdLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_LD_LIBRARY_PATH);
    }
    if (mEnableProfiling) {
        jsonObject.put(ENABLE_PROFILING, mEnableProfiling);
        CLog.i("Added %s to the Json object", ENABLE_PROFILING);
    }
    if (mSaveTraceFileRemote) {
        jsonObject.put(SAVE_TRACE_FIEL_REMOTE, mSaveTraceFileRemote);
        CLog.i("Added %s to the Json object", SAVE_TRACE_FIEL_REMOTE);
    }
    if (mEnableSystrace) {
        jsonObject.put(ENABLE_SYSTRACE, mEnableSystrace);
        CLog.i("Added %s to the Json object", ENABLE_SYSTRACE);
    }
    if (mEnableCoverage) {
        if (coverageBuild) {
            jsonObject.put(ENABLE_COVERAGE, mEnableCoverage);
            CLog.i("Added %s to the Json object", ENABLE_COVERAGE);
        } else {
            CLog.i("Device build has coverage disabled");
        }
    }
    if (mOutputCoverageReport) {
        jsonObject.put(OUTPUT_COVERAGE_REPORT, mOutputCoverageReport);
        CLog.i("Added %s to the Json object", OUTPUT_COVERAGE_REPORT);
    }
    if (mPreconditionHwBinderServiceName != null) {
        jsonObject.put(PRECONDITION_HWBINDER_SERVICE, mPreconditionHwBinderServiceName);
        CLog.i("Added %s to the Json object", PRECONDITION_HWBINDER_SERVICE);
    }
    if (mPreconditionFeature != null) {
        jsonObject.put(PRECONDITION_FEATURE, mPreconditionFeature);
        CLog.i("Added %s to the Json object", PRECONDITION_FEATURE);
    }
    if (mPreconditionFilePathPrefix != null) {
        jsonObject.put(PRECONDITION_FILE_PATH_PREFIX, mPreconditionFilePathPrefix);
        CLog.i("Added %s to the Json object", PRECONDITION_FILE_PATH_PREFIX);
    }
    if (mPreconditionLshal != null) {
        jsonObject.put(PRECONDITION_LSHAL, mPreconditionLshal);
        CLog.i("Added %s to the Json object", PRECONDITION_LSHAL);
    }
    if (!mBinaryTestProfilingLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_PROFILING_LIBRARY_PATH, new JSONArray(mBinaryTestProfilingLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_PROFILING_LIBRARY_PATH);
    }
    if (mBinaryTestDisableFramework) {
        jsonObject.put(BINARY_TEST_DISABLE_FRAMEWORK, mBinaryTestDisableFramework);
        CLog.i("Added %s to the Json object", BINARY_TEST_DISABLE_FRAMEWORK);
    }
    if (mBinaryTestStopNativeServers) {
        jsonObject.put(BINARY_TEST_STOP_NATIVE_SERVERS, mBinaryTestStopNativeServers);
        CLog.i("Added %s to the Json object", BINARY_TEST_STOP_NATIVE_SERVERS);
    }
    if (!mNativeServerProcessName.isEmpty()) {
        jsonObject.put(NATIVE_SERVER_PROCESS_NAME, new JSONArray(mNativeServerProcessName));
        CLog.i("Added %s to the Json object", NATIVE_SERVER_PROCESS_NAME);
    }
    if (!mHalHidlReplayTestTracePaths.isEmpty()) {
        jsonObject.put(HAL_HIDL_REPLAY_TEST_TRACE_PATHS, new JSONArray(mHalHidlReplayTestTracePaths));
        CLog.i("Added %s to the Json object", HAL_HIDL_REPLAY_TEST_TRACE_PATHS);
    }
    if (mHalHidlPackageName != null) {
        jsonObject.put(HAL_HIDL_PACKAGE_NAME, mHalHidlPackageName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mSystraceProcessName != null) {
        jsonObject.put(SYSTRACE_PROCESS_NAME, mSystraceProcessName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mPassthroughMode) {
        jsonObject.put(PASSTHROUGH_MODE, mPassthroughMode);
        CLog.i("Added %s to the Json object", PASSTHROUGH_MODE);
    }
    if (mGtestBatchMode) {
        jsonObject.put(GTEST_BATCH_MODE, mGtestBatchMode);
        CLog.i("Added %s to the Json object", GTEST_BATCH_MODE);
    }
}
#method_after
private void updateVtsRunnerTestConfig(JSONObject jsonObject) throws IOException, JSONException, RuntimeException {
    VtsVendorConfigFileUtil configReader = new VtsVendorConfigFileUtil();
    if (configReader.LoadVendorConfig(null)) {
        JSONObject vendorConfigJson = configReader.GetVendorConfigJson();
        if (vendorConfigJson != null) {
            JsonUtil.deepMergeJsonObjects(jsonObject, vendorConfigJson);
        }
    }
    CLog.i("Load original test config %s %s", mTestCaseDataDir, mTestConfigPath);
    String content = null;
    if (mTestConfigPath != null) {
        content = FileUtil.readStringFromFile(new File(Paths.get(mTestCaseDataDir, mTestConfigPath).toString()));
        CLog.i("Loaded original test config %s", content);
        if (content != null) {
            JsonUtil.deepMergeJsonObjects(jsonObject, new JSONObject(content));
        }
    }
    populateDefaultJsonFields(jsonObject, mTestCaseDataDir);
    CLog.i("Built a Json object using the loaded original test config");
    JSONArray deviceArray = new JSONArray();
    JSONObject deviceItemObject = new JSONObject();
    deviceItemObject.put(SERIAL, mDevice.getSerialNumber());
    boolean coverageBuild = false;
    try {
        deviceItemObject.put("product_type", mDevice.getProductType());
        deviceItemObject.put("product_variant", mDevice.getProductVariant());
        deviceItemObject.put("build_alias", mDevice.getBuildAlias());
        deviceItemObject.put("build_id", mDevice.getBuildId());
        deviceItemObject.put("build_flavor", mDevice.getBuildFlavor());
        String coverageProperty = mDevice.getProperty(COVERAGE_PROPERTY);
        coverageBuild = coverageProperty != null && coverageProperty.equals("1");
    } catch (DeviceNotAvailableException e) {
        CLog.e("A device not available - continuing");
        throw new RuntimeException("Failed to get device information");
    }
    deviceArray.put(deviceItemObject);
    JSONArray testBedArray = (JSONArray) jsonObject.get("test_bed");
    if (testBedArray.length() == 0) {
        JSONObject device = new JSONObject();
        String testName;
        if (mTestModuleName != null) {
            testName = mTestModuleName;
        } else {
            CLog.w("--test-module-name not set (not recommended); deriving automatically");
            if (mTestConfigPath != null) {
                testName = new File(mTestConfigPath).getName();
                testName = testName.replace(CONFIG_FILE_EXTENSION, "");
            } else if (mTestCasePath != null) {
                testName = new File(mTestCasePath).getName();
            } else {
                throw new RuntimeException("Failed to derive test module name; use --test-module-name option");
            }
        }
        if (testName.length() > MAX_TEST_NAME_LENGTH) {
            throw new RuntimeException("Test module name is too long: " + testName + ". (" + testName.length() + ">" + MAX_TEST_NAME_LENGTH + ")");
        }
        CLog.logAndDisplay(LogLevel.INFO, "Setting test name as %s", testName);
        device.put(NAME, testName);
        device.put(ANDROIDDEVICE, deviceArray);
        testBedArray.put(device);
    } else if (testBedArray.length() == 1) {
        JSONObject device = (JSONObject) testBedArray.get(0);
        device.put(ANDROIDDEVICE, deviceArray);
    } else {
        CLog.e("Multi-device not yet supported: %d devices requested", testBedArray.length());
        throw new RuntimeException("Failed to produce VTS runner test config");
    }
    jsonObject.put(DATA_FILE_PATH, mTestCaseDataDir);
    CLog.i("Added %s = %s to the Json object", DATA_FILE_PATH, mTestCaseDataDir);
    JSONObject build = new JSONObject();
    build.put(BUILD_ID, mBuildInfo.getBuildId());
    build.put(BUILD_TARGET, mBuildInfo.getBuildTargetName());
    jsonObject.put(BUILD, build);
    CLog.i("Added %s to the Json object", BUILD);
    JSONObject suite = new JSONObject();
    suite.put(NAME, mBuildInfo.getTestTag());
    suite.put(INCLUDE_FILTER, new JSONArray(mIncludeFilters));
    CLog.i("Added include filter to test suite: %s", mIncludeFilters);
    suite.put(EXCLUDE_FILTER, new JSONArray(mExcludeFilters));
    CLog.i("Added exclude filter to test suite: %s", mExcludeFilters);
    jsonObject.put(TEST_SUITE, suite);
    CLog.i("Added %s to the Json object", TEST_SUITE);
    if (mAbi != null) {
        jsonObject.put(ABI_NAME, mAbi.getName());
        CLog.i("Added %s to the Json object", ABI_NAME);
        jsonObject.put(ABI_BITNESS, mAbi.getBitness());
        CLog.i("Added %s to the Json object", ABI_BITNESS);
    }
    if (mSkipOn32BitAbi) {
        jsonObject.put(SKIP_ON_32BIT_ABI, mSkipOn32BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_32BIT_ABI);
    }
    if (mSkipOn64BitAbi) {
        jsonObject.put(SKIP_ON_64BIT_ABI, mSkipOn64BitAbi);
        CLog.i("Added %s to the Json object", SKIP_ON_64BIT_ABI);
    } else if (mRun32bBitOn64BitAbi) {
        jsonObject.put(RUN_32BIT_ON_64BIT_ABI, mRun32bBitOn64BitAbi);
        CLog.i("Added %s to the Json object", RUN_32BIT_ON_64BIT_ABI);
    }
    if (mSkipIfThermalThrottling) {
        jsonObject.put(SKIP_IF_THERMAL_THROTTLING, mSkipIfThermalThrottling);
        CLog.i("Added %s to the Json object", SKIP_IF_THERMAL_THROTTLING);
    }
    if (!mBinaryTestSource.isEmpty()) {
        jsonObject.put(BINARY_TEST_SOURCE, new JSONArray(mBinaryTestSource));
        CLog.i("Added %s to the Json object", BINARY_TEST_SOURCE);
    }
    if (!mBinaryTestWorkingDirectory.isEmpty()) {
        jsonObject.put(BINARY_TEST_WORKING_DIRECTORY, new JSONArray(mBinaryTestWorkingDirectory));
        CLog.i("Added %s to the Json object", BINARY_TEST_WORKING_DIRECTORY);
    }
    if (!mBinaryTestEnvp.isEmpty()) {
        jsonObject.put(BINARY_TEST_ENVP, new JSONArray(mBinaryTestEnvp));
        CLog.i("Added %s to the Json object", BINARY_TEST_ENVP);
    }
    if (!mBinaryTestArgs.isEmpty()) {
        jsonObject.put(BINARY_TEST_ARGS, new JSONArray(mBinaryTestArgs));
        CLog.i("Added %s to the Json object", BINARY_TEST_ARGS);
    }
    if (!mBinaryTestLdLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_LD_LIBRARY_PATH, new JSONArray(mBinaryTestLdLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_LD_LIBRARY_PATH);
    }
    if (mEnableProfiling) {
        jsonObject.put(ENABLE_PROFILING, mEnableProfiling);
        CLog.i("Added %s to the Json object", ENABLE_PROFILING);
    }
    if (mSaveTraceFileRemote) {
        jsonObject.put(SAVE_TRACE_FIEL_REMOTE, mSaveTraceFileRemote);
        CLog.i("Added %s to the Json object", SAVE_TRACE_FIEL_REMOTE);
    }
    if (mEnableSystrace) {
        jsonObject.put(ENABLE_SYSTRACE, mEnableSystrace);
        CLog.i("Added %s to the Json object", ENABLE_SYSTRACE);
    }
    if (mEnableCoverage) {
        if (coverageBuild) {
            jsonObject.put(ENABLE_COVERAGE, mEnableCoverage);
            CLog.i("Added %s to the Json object", ENABLE_COVERAGE);
        } else {
            CLog.i("Device build has coverage disabled");
        }
    }
    if (mOutputCoverageReport) {
        jsonObject.put(OUTPUT_COVERAGE_REPORT, mOutputCoverageReport);
        CLog.i("Added %s to the Json object", OUTPUT_COVERAGE_REPORT);
    }
    if (mPreconditionHwBinderServiceName != null) {
        jsonObject.put(PRECONDITION_HWBINDER_SERVICE, mPreconditionHwBinderServiceName);
        CLog.i("Added %s to the Json object", PRECONDITION_HWBINDER_SERVICE);
    }
    if (mPreconditionFeature != null) {
        jsonObject.put(PRECONDITION_FEATURE, mPreconditionFeature);
        CLog.i("Added %s to the Json object", PRECONDITION_FEATURE);
    }
    if (mPreconditionFilePathPrefix != null) {
        jsonObject.put(PRECONDITION_FILE_PATH_PREFIX, mPreconditionFilePathPrefix);
        CLog.i("Added %s to the Json object", PRECONDITION_FILE_PATH_PREFIX);
    }
    if (mPreconditionLshal != null) {
        jsonObject.put(PRECONDITION_LSHAL, mPreconditionLshal);
        CLog.i("Added %s to the Json object", PRECONDITION_LSHAL);
    }
    if (!mBinaryTestProfilingLibraryPath.isEmpty()) {
        jsonObject.put(BINARY_TEST_PROFILING_LIBRARY_PATH, new JSONArray(mBinaryTestProfilingLibraryPath));
        CLog.i("Added %s to the Json object", BINARY_TEST_PROFILING_LIBRARY_PATH);
    }
    if (mBinaryTestDisableFramework) {
        jsonObject.put(BINARY_TEST_DISABLE_FRAMEWORK, mBinaryTestDisableFramework);
        CLog.i("Added %s to the Json object", BINARY_TEST_DISABLE_FRAMEWORK);
    }
    if (mBinaryTestStopNativeServers) {
        jsonObject.put(BINARY_TEST_STOP_NATIVE_SERVERS, mBinaryTestStopNativeServers);
        CLog.i("Added %s to the Json object", BINARY_TEST_STOP_NATIVE_SERVERS);
    }
    if (!mNativeServerProcessName.isEmpty()) {
        jsonObject.put(NATIVE_SERVER_PROCESS_NAME, new JSONArray(mNativeServerProcessName));
        CLog.i("Added %s to the Json object", NATIVE_SERVER_PROCESS_NAME);
    }
    if (!mHalHidlReplayTestTracePaths.isEmpty()) {
        jsonObject.put(HAL_HIDL_REPLAY_TEST_TRACE_PATHS, new JSONArray(mHalHidlReplayTestTracePaths));
        CLog.i("Added %s to the Json object", HAL_HIDL_REPLAY_TEST_TRACE_PATHS);
    }
    if (mHalHidlPackageName != null) {
        jsonObject.put(HAL_HIDL_PACKAGE_NAME, mHalHidlPackageName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mSystraceProcessName != null) {
        jsonObject.put(SYSTRACE_PROCESS_NAME, mSystraceProcessName);
        CLog.i("Added %s to the Json object", SYSTRACE_PROCESS_NAME);
    }
    if (mPassthroughMode) {
        jsonObject.put(PASSTHROUGH_MODE, mPassthroughMode);
        CLog.i("Added %s to the Json object", PASSTHROUGH_MODE);
    }
    if (mGtestBatchMode) {
        jsonObject.put(GTEST_BATCH_MODE, mGtestBatchMode);
        CLog.i("Added %s to the Json object", GTEST_BATCH_MODE);
    }
}
#end_block

#method_before
public void setUpstreamLinkProperties(LinkProperties lp) {
    if (!started())
        return;
    mUpstreamLinkProperties = (lp != null) ? new LinkProperties(lp) : null;
    // TODO: examine return code and decide what to do if programming
    // upstream parameters fails (probably just wait for a subsequent
    // onOffloadEvent() callback to tell us offload is available again and
    // then reapply all state).
    setUpstreamParameters();
}
#method_after
public void setUpstreamLinkProperties(LinkProperties lp) {
    if (!started())
        return;
    mUpstreamLinkProperties = (lp != null) ? new LinkProperties(lp) : null;
    // TODO: examine return code and decide what to do if programming
    // upstream parameters fails (probably just wait for a subsequent
    // onOffloadEvent() callback to tell us offload is available again and
    // then reapply all state).
    pushUpstreamParameters();
}
#end_block

#method_before
public boolean setUpstreamParameters(String iface, String v4addr, String v4gw, ArrayList<String> v6gws) {
    final CbResults results = new CbResults();
    try {
        mOffloadControl.setUpstreamParameters(iface, v4addr, v4gw, v6gws, (boolean success, String errMsg) -> {
            results.success = success;
            results.errMsg = errMsg;
        });
    } catch (RemoteException e) {
        mLog.e("failed to setUpstreamParameters: " + e);
        return false;
    }
    if (!results.success)
        mLog.e("setUpstreamParameters failed: " + results.errMsg);
    return results.success;
}
#method_after
public boolean setUpstreamParameters(String iface, String v4addr, String v4gateway, ArrayList<String> v6gws) {
    final CbResults results = new CbResults();
    try {
        mOffloadControl.setUpstreamParameters(iface, v4addr, v4gateway, v6gws, (boolean success, String errMsg) -> {
            results.success = success;
            results.errMsg = errMsg;
        });
    } catch (RemoteException e) {
        mLog.e("failed to setUpstreamParameters: " + e);
        return false;
    }
    if (!results.success)
        mLog.e("setUpstreamParameters failed: " + results.errMsg);
    return results.success;
}
#end_block

#method_before
@Test
public void testSetUpstreamLinkPropertiesWorking() throws Exception {
    setupFunctioningHardwareInterface();
    final OffloadController offload = new OffloadController(null, mHardware, mContentResolver, new SharedLog("test"));
    offload.start();
    final InOrder inOrder = inOrder(mHardware);
    inOrder.verify(mHardware, times(1)).initOffloadConfig();
    inOrder.verify(mHardware, times(1)).initOffloadControl(any(OffloadHardwareInterface.ControlCallback.class));
    inOrder.verifyNoMoreInteractions();
    offload.setUpstreamLinkProperties(null);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(null), eq(null), eq(null), eq(null));
    inOrder.verifyNoMoreInteractions();
    reset(mHardware);
    final LinkProperties lp = new LinkProperties();
    final String testIfName = "rmnet_data17";
    lp.setInterfaceName(testIfName);
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(null), eq(null), mStringArrayCaptor.capture());
    assertTrue(mStringArrayCaptor.getValue().isEmpty());
    inOrder.verifyNoMoreInteractions();
    final String ipv4Addr = "192.0.2.5";
    final String linkAddr = ipv4Addr + "/24";
    lp.addLinkAddress(new LinkAddress(linkAddr));
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(ipv4Addr), eq(null), mStringArrayCaptor.capture());
    assertTrue(mStringArrayCaptor.getValue().isEmpty());
    inOrder.verifyNoMoreInteractions();
    final String ipv4Gateway = "192.0.2.1";
    lp.addRoute(new RouteInfo(InetAddress.getByName(ipv4Gateway)));
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(ipv4Addr), eq(ipv4Gateway), mStringArrayCaptor.capture());
    assertTrue(mStringArrayCaptor.getValue().isEmpty());
    inOrder.verifyNoMoreInteractions();
    final String ipv6Gw1 = "fe80::cafe";
    lp.addRoute(new RouteInfo(InetAddress.getByName(ipv6Gw1)));
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(ipv4Addr), eq(ipv4Gateway), mStringArrayCaptor.capture());
    ArrayList<String> v6gws = mStringArrayCaptor.getValue();
    assertEquals(1, v6gws.size());
    assertTrue(v6gws.contains(ipv6Gw1));
    inOrder.verifyNoMoreInteractions();
    final String ipv6Gw2 = "fe80::d00d";
    lp.addRoute(new RouteInfo(InetAddress.getByName(ipv6Gw2)));
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(ipv4Addr), eq(ipv4Gateway), mStringArrayCaptor.capture());
    v6gws = mStringArrayCaptor.getValue();
    assertEquals(2, v6gws.size());
    assertTrue(v6gws.contains(ipv6Gw1));
    assertTrue(v6gws.contains(ipv6Gw2));
    inOrder.verifyNoMoreInteractions();
}
#method_after
@Test
public void testSetUpstreamLinkPropertiesWorking() throws Exception {
    setupFunctioningHardwareInterface();
    final OffloadController offload = new OffloadController(null, mHardware, mContentResolver, new SharedLog("test"));
    offload.start();
    final InOrder inOrder = inOrder(mHardware);
    inOrder.verify(mHardware, times(1)).initOffloadConfig();
    inOrder.verify(mHardware, times(1)).initOffloadControl(any(OffloadHardwareInterface.ControlCallback.class));
    inOrder.verifyNoMoreInteractions();
    offload.setUpstreamLinkProperties(null);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(null), eq(null), eq(null), eq(null));
    inOrder.verifyNoMoreInteractions();
    reset(mHardware);
    final LinkProperties lp = new LinkProperties();
    final String testIfName = "rmnet_data17";
    lp.setInterfaceName(testIfName);
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(null), eq(null), mStringArrayCaptor.capture());
    assertTrue(mStringArrayCaptor.getValue().isEmpty());
    inOrder.verifyNoMoreInteractions();
    final String ipv4Addr = "192.0.2.5";
    final String linkAddr = ipv4Addr + "/24";
    lp.addLinkAddress(new LinkAddress(linkAddr));
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(ipv4Addr), eq(null), mStringArrayCaptor.capture());
    assertTrue(mStringArrayCaptor.getValue().isEmpty());
    inOrder.verifyNoMoreInteractions();
    final String ipv4Gateway = "192.0.2.1";
    lp.addRoute(new RouteInfo(InetAddress.getByName(ipv4Gateway)));
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(ipv4Addr), eq(ipv4Gateway), mStringArrayCaptor.capture());
    assertTrue(mStringArrayCaptor.getValue().isEmpty());
    inOrder.verifyNoMoreInteractions();
    final String ipv6Gw1 = "fe80::cafe";
    lp.addRoute(new RouteInfo(InetAddress.getByName(ipv6Gw1)));
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(ipv4Addr), eq(ipv4Gateway), mStringArrayCaptor.capture());
    ArrayList<String> v6gws = mStringArrayCaptor.getValue();
    assertEquals(1, v6gws.size());
    assertTrue(v6gws.contains(ipv6Gw1));
    inOrder.verifyNoMoreInteractions();
    final String ipv6Gw2 = "fe80::d00d";
    lp.addRoute(new RouteInfo(InetAddress.getByName(ipv6Gw2)));
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(ipv4Addr), eq(ipv4Gateway), mStringArrayCaptor.capture());
    v6gws = mStringArrayCaptor.getValue();
    assertEquals(2, v6gws.size());
    assertTrue(v6gws.contains(ipv6Gw1));
    assertTrue(v6gws.contains(ipv6Gw2));
    inOrder.verifyNoMoreInteractions();
    final LinkProperties stacked = new LinkProperties();
    stacked.setInterfaceName("stacked");
    stacked.addLinkAddress(new LinkAddress("192.0.2.129/25"));
    stacked.addRoute(new RouteInfo(InetAddress.getByName("192.0.2.254")));
    stacked.addRoute(new RouteInfo(InetAddress.getByName("fe80::bad:f00")));
    assertTrue(lp.addStackedLink(stacked));
    offload.setUpstreamLinkProperties(lp);
    inOrder.verify(mHardware, times(1)).setUpstreamParameters(eq(testIfName), eq(ipv4Addr), eq(ipv4Gateway), mStringArrayCaptor.capture());
    v6gws = mStringArrayCaptor.getValue();
    assertEquals(2, v6gws.size());
    assertTrue(v6gws.contains(ipv6Gw1));
    assertTrue(v6gws.contains(ipv6Gw2));
    inOrder.verifyNoMoreInteractions();
}
#end_block

#method_before
static void testNormalizer() {
    String composed = "Bl\u00c1ah";
    String decomposed = "Bl\u0041\u0301ah";
    String res;
    res = Normalizer.normalize(composed, Normalizer.Form.NFD);
    if (!decomposed.equals(res)) {
        System.err.println("Bad decompose: '" + composed + "' --> '" + res + "'");
    }
    res = Normalizer.normalize(decomposed, Normalizer.Form.NFC);
    if (!composed.equals(res)) {
        System.err.println("Bad compose: '" + decomposed + "' --> '" + res + "'");
    }
    System.out.println("Normalizer passed");
}
#method_after
static void testNormalizer() {
    String composed = "Bl\u00c1ah";
    String decomposed = "Bl\u0041\u0301ah";
    String res;
    res = Normalizer.normalize(composed, Normalizer.Form.NFD);
    if (!decomposed.equals(res)) {
        System.out.println("Bad decompose: '" + composed + "' --> '" + res + "'");
    }
    res = Normalizer.normalize(decomposed, Normalizer.Form.NFC);
    if (!composed.equals(res)) {
        System.out.println("Bad compose: '" + decomposed + "' --> '" + res + "'");
    }
    System.out.println("Normalizer passed");
}
#end_block

#method_before
static void testIso3() {
    Locale loc;
    loc = new Locale("en", "US");
    System.out.println("loc: " + loc);
    System.out.println(" iso3=" + loc.getISO3Language());
    loc = new Locale("eng", "USA");
    System.out.println("loc: " + loc);
    try {
        System.out.println(" iso3=" + loc.getISO3Language());
    } catch (MissingResourceException mre) {
        System.err.println("couldn't get iso3 language");
    }
}
#method_after
static void testIso3() {
    Locale loc;
    loc = new Locale("en", "US");
    System.out.println("loc: " + loc);
    System.out.println(" iso3=" + loc.getISO3Language());
    loc = new Locale("eng", "USA");
    System.out.println("loc: " + loc);
    try {
        System.out.println(" iso3=" + loc.getISO3Language());
    } catch (MissingResourceException mre) {
        System.out.println("couldn't get iso3 language");
    }
}
#end_block

#method_before
// / CHECK-START: void Main.doTopCall(boolean) inliner (before)
// / CHECK-NOT:   InvokeStaticOrDirect method_load_kind:recursive
// / CHECK-START: void Main.doTopCall(boolean) inliner (after)
public static void doTopCall(boolean first_call) {
    if (first_call) {
        inline1();
    } else {
        while (true) {
            inline3();
        }
    }
}
#method_after
// / CHECK-START: void Main.doTopCall(boolean) inliner (before)
// / CHECK-NOT:   InvokeStaticOrDirect method_load_kind:Recursive
// / CHECK-START: void Main.doTopCall(boolean) inliner (after)
public static void doTopCall(boolean first_call) {
    if (first_call) {
        inline1();
    } else {
        while (true) {
            inline3();
        }
    }
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    FancyLoader loader;
    loader = new FancyLoader(ClassLoader.getSystemClassLoader());
    // System.out.println("SYSTEM: " + ClassLoader.getSystemClassLoader());
    // System.out.println("ALTERN: " + loader);
    /*
         * This statement has no effect on this program, but it can
         * change the point where a LinkageException is thrown in
         * testImplement().  When this is present the "reference
         * implementation" throws an exception from Class.newInstance(),
         * when it's absent the exception is deferred until the first time
         * we call a method that isn't actually implemented.
         *
         * This isn't the class that fails -- it's a class with the same
         * name in the "fancy" class loader --  but the VM thinks it has a
         * reference to one of these; presumably the difference is that
         * without this the VM finds itself holding a reference to an
         * instance of an uninitialized class.
         */
    System.out.println("base: " + DoubledImplement.class);
    System.out.println("base2: " + DoubledImplement2.class);
    /*
         * Run tests.
         */
    testAccess1(loader);
    testAccess2(loader);
    testAccess3(loader);
    testExtend(loader);
    testExtendOkay(loader);
    testInterface(loader);
    testAbstract(loader);
    testImplement(loader);
    testIfaceImplement(loader);
    testSeparation();
    testClassForName();
}
#method_after
public static void main(String[] args) throws Exception {
    FancyLoader loader;
    loader = new FancyLoader(ClassLoader.getSystemClassLoader());
    // System.out.println("SYSTEM: " + ClassLoader.getSystemClassLoader());
    // System.out.println("ALTERN: " + loader);
    /*
         * This statement has no effect on this program, but it can
         * change the point where a LinkageException is thrown in
         * testImplement().  When this is present the "reference
         * implementation" throws an exception from Class.newInstance(),
         * when it's absent the exception is deferred until the first time
         * we call a method that isn't actually implemented.
         *
         * This isn't the class that fails -- it's a class with the same
         * name in the "fancy" class loader --  but the VM thinks it has a
         * reference to one of these; presumably the difference is that
         * without this the VM finds itself holding a reference to an
         * instance of an uninitialized class.
         */
    System.out.println("base: " + DoubledImplement.class);
    System.out.println("base2: " + DoubledImplement2.class);
    /*
         * Run tests.
         */
    testAccess1(loader);
    testAccess2(loader);
    testAccess3(loader);
    testExtend(loader);
    testExtendOkay(loader);
    testInterface(loader);
    testAbstract(loader);
    testImplement(loader);
    testIfaceImplement(loader);
    testSeparation();
    testClassForName();
    testNullClassLoader();
}
#end_block

#method_before
static void testSeparation() {
    FancyLoader loader1 = new FancyLoader(ClassLoader.getSystemClassLoader());
    FancyLoader loader2 = new FancyLoader(ClassLoader.getSystemClassLoader());
    try {
        Class target1 = loader1.loadClass("MutationTarget");
        Class target2 = loader2.loadClass("MutationTarget");
        if (target1 == target2) {
            throw new RuntimeException("target1 should not be equal to target2");
        }
        Class mutator1 = loader1.loadClass("Mutator");
        Class mutator2 = loader2.loadClass("Mutator");
        if (mutator1 == mutator2) {
            throw new RuntimeException("mutator1 should not be equal to mutator2");
        }
        runMutator(mutator1, 1);
        int value = getMutationTargetValue(target1);
        if (value != 1) {
            throw new RuntimeException("target 1 has unexpected value " + value);
        }
        value = getMutationTargetValue(target2);
        if (value != 0) {
            throw new RuntimeException("target 2 has unexpected value " + value);
        }
        runMutator(mutator2, 2);
        value = getMutationTargetValue(target1);
        if (value != 1) {
            throw new RuntimeException("target 1 has unexpected value " + value);
        }
        value = getMutationTargetValue(target2);
        if (value != 2) {
            throw new RuntimeException("target 2 has unexpected value " + value);
        }
    } catch (Exception ex) {
        ex.printStackTrace(System.out);
    }
}
#method_after
static void testSeparation() {
    FancyLoader loader1 = new FancyLoader(ClassLoader.getSystemClassLoader());
    FancyLoader loader2 = new FancyLoader(ClassLoader.getSystemClassLoader());
    try {
        Class<?> target1 = loader1.loadClass("MutationTarget");
        Class<?> target2 = loader2.loadClass("MutationTarget");
        if (target1 == target2) {
            throw new RuntimeException("target1 should not be equal to target2");
        }
        Class<?> mutator1 = loader1.loadClass("Mutator");
        Class<?> mutator2 = loader2.loadClass("Mutator");
        if (mutator1 == mutator2) {
            throw new RuntimeException("mutator1 should not be equal to mutator2");
        }
        runMutator(mutator1, 1);
        int value = getMutationTargetValue(target1);
        if (value != 1) {
            throw new RuntimeException("target 1 has unexpected value " + value);
        }
        value = getMutationTargetValue(target2);
        if (value != 0) {
            throw new RuntimeException("target 2 has unexpected value " + value);
        }
        runMutator(mutator2, 2);
        value = getMutationTargetValue(target1);
        if (value != 1) {
            throw new RuntimeException("target 1 has unexpected value " + value);
        }
        value = getMutationTargetValue(target2);
        if (value != 2) {
            throw new RuntimeException("target 2 has unexpected value " + value);
        }
    } catch (Exception ex) {
        ex.printStackTrace(System.out);
    }
}
#end_block

#method_before
private static void runMutator(Class c, int v) throws Exception {
    java.lang.reflect.Method m = c.getDeclaredMethod("mutate", int.class);
    m.invoke(null, v);
}
#method_after
private static void runMutator(Class<?> c, int v) throws Exception {
    java.lang.reflect.Method m = c.getDeclaredMethod("mutate", int.class);
    m.invoke(null, v);
}
#end_block

#method_before
private static int getMutationTargetValue(Class c) throws Exception {
    java.lang.reflect.Field f = c.getDeclaredField("value");
    return f.getInt(null);
}
#method_after
private static int getMutationTargetValue(Class<?> c) throws Exception {
    java.lang.reflect.Field f = c.getDeclaredField("value");
    return f.getInt(null);
}
#end_block

#method_before
static void testAccess1(ClassLoader loader) {
    Class altClass;
    try {
        altClass = loader.loadClass("Inaccessible1");
    } catch (ClassNotFoundException cnfe) {
        System.err.println("loadClass failed");
        cnfe.printStackTrace(System.out);
        return;
    }
    /* instantiate */
    Object obj;
    try {
        obj = altClass.newInstance();
        System.err.println("ERROR: Inaccessible1 was accessible");
    } catch (InstantiationException ie) {
        System.err.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.out.println("Got expected access exception #1");
        // System.out.println("+++ " + iae);
        return;
    }
}
#method_after
static void testAccess1(ClassLoader loader) {
    Class<?> altClass;
    try {
        altClass = loader.loadClass("Inaccessible1");
    } catch (ClassNotFoundException cnfe) {
        System.out.println("loadClass failed");
        cnfe.printStackTrace(System.out);
        return;
    }
    /* instantiate */
    Object obj;
    try {
        obj = altClass.newInstance();
        System.out.println("ERROR: Inaccessible1 was accessible");
    } catch (InstantiationException ie) {
        System.out.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.out.println("Got expected access exception #1");
        // System.out.println("+++ " + iae);
        return;
    }
}
#end_block

#method_before
static void testAccess2(ClassLoader loader) {
    Class altClass;
    try {
        altClass = loader.loadClass("Inaccessible2");
        System.err.println("ERROR: Inaccessible2 was accessible: " + altClass);
    } catch (ClassNotFoundException cnfe) {
        Throwable cause = cnfe.getCause();
        if (cause instanceof IllegalAccessError) {
            System.out.println("Got expected CNFE/IAE #2");
        } else {
            System.err.println("Got unexpected CNFE/IAE #2");
            cnfe.printStackTrace(System.out);
        }
    }
}
#method_after
static void testAccess2(ClassLoader loader) {
    Class<?> altClass;
    try {
        altClass = loader.loadClass("Inaccessible2");
        System.out.println("ERROR: Inaccessible2 was accessible: " + altClass);
    } catch (ClassNotFoundException cnfe) {
        Throwable cause = cnfe.getCause();
        if (cause instanceof IllegalAccessError) {
            System.out.println("Got expected CNFE/IAE #2");
        } else {
            System.out.println("Got unexpected CNFE/IAE #2");
            cnfe.printStackTrace(System.out);
        }
    }
}
#end_block

#method_before
static void testAccess3(ClassLoader loader) {
    Class altClass;
    try {
        altClass = loader.loadClass("Inaccessible3");
        System.err.println("ERROR: Inaccessible3 was accessible: " + altClass);
    } catch (ClassNotFoundException cnfe) {
        Throwable cause = cnfe.getCause();
        if (cause instanceof IllegalAccessError) {
            System.out.println("Got expected CNFE/IAE #3");
        } else {
            System.err.println("Got unexpected CNFE/IAE #3");
            cnfe.printStackTrace(System.out);
        }
    }
}
#method_after
static void testAccess3(ClassLoader loader) {
    Class<?> altClass;
    try {
        altClass = loader.loadClass("Inaccessible3");
        System.out.println("ERROR: Inaccessible3 was accessible: " + altClass);
    } catch (ClassNotFoundException cnfe) {
        Throwable cause = cnfe.getCause();
        if (cause instanceof IllegalAccessError) {
            System.out.println("Got expected CNFE/IAE #3");
        } else {
            System.out.println("Got unexpected CNFE/IAE #3");
            cnfe.printStackTrace(System.out);
        }
    }
}
#end_block

#method_before
static void testExtend(ClassLoader loader) {
    Class doubledExtendClass;
    Object obj;
    /* get the "alternate" version of DoubledExtend */
    try {
        doubledExtendClass = loader.loadClass("DoubledExtend");
    // System.out.println("+++ DoubledExtend is " + doubledExtendClass
    // + " in " + doubledExtendClass.getClassLoader());
    } catch (ClassNotFoundException cnfe) {
        System.err.println("loadClass failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = doubledExtendClass.newInstance();
    } catch (InstantiationException ie) {
        System.err.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.err.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        System.out.println("Got expected LinkageError on DE");
        return;
    }
    /* use the base class reference to get a CL-specific instance */
    Base baseRef = (Base) obj;
    DoubledExtend de = baseRef.getExtended();
    /* try to call through it */
    try {
        String result;
        result = Base.doStuff(de);
        System.err.println("ERROR: did not get LinkageError on DE");
        System.err.println("(result=" + result + ")");
    } catch (LinkageError le) {
        System.out.println("Got expected LinkageError on DE");
        return;
    }
}
#method_after
static void testExtend(ClassLoader loader) {
    Class<?> doubledExtendClass;
    Object obj;
    /* get the "alternate" version of DoubledExtend */
    try {
        doubledExtendClass = loader.loadClass("DoubledExtend");
    // System.out.println("+++ DoubledExtend is " + doubledExtendClass
    // + " in " + doubledExtendClass.getClassLoader());
    } catch (ClassNotFoundException cnfe) {
        System.out.println("loadClass failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = doubledExtendClass.newInstance();
    } catch (InstantiationException ie) {
        System.out.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.out.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        System.out.println("Got expected LinkageError on DE");
        return;
    }
    /* use the base class reference to get a CL-specific instance */
    Base baseRef = (Base) obj;
    DoubledExtend de = baseRef.getExtended();
    /* try to call through it */
    try {
        String result;
        result = Base.doStuff(de);
        System.out.println("ERROR: did not get LinkageError on DE");
        System.out.println("(result=" + result + ")");
    } catch (LinkageError le) {
        System.out.println("Got expected LinkageError on DE");
        return;
    }
}
#end_block

#method_before
static void testExtendOkay(ClassLoader loader) {
    Class doubledExtendOkayClass;
    Object obj;
    /* get the "alternate" version of DoubledExtendOkay */
    try {
        doubledExtendOkayClass = loader.loadClass("DoubledExtendOkay");
    } catch (ClassNotFoundException cnfe) {
        System.err.println("loadClass failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = doubledExtendOkayClass.newInstance();
    } catch (InstantiationException ie) {
        System.err.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.err.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        System.err.println("Got unexpected LinkageError on DEO");
        le.printStackTrace(System.out);
        return;
    }
    /* use the base class reference to get a CL-specific instance */
    BaseOkay baseRef = (BaseOkay) obj;
    DoubledExtendOkay de = baseRef.getExtended();
    /* try to call through it */
    try {
        String result;
        result = BaseOkay.doStuff(de);
        System.out.println("Got DEO result " + result);
    } catch (LinkageError le) {
        System.err.println("Got unexpected LinkageError on DEO");
        le.printStackTrace(System.out);
        return;
    }
}
#method_after
static void testExtendOkay(ClassLoader loader) {
    Class<?> doubledExtendOkayClass;
    Object obj;
    /* get the "alternate" version of DoubledExtendOkay */
    try {
        doubledExtendOkayClass = loader.loadClass("DoubledExtendOkay");
    } catch (ClassNotFoundException cnfe) {
        System.out.println("loadClass failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = doubledExtendOkayClass.newInstance();
    } catch (InstantiationException ie) {
        System.out.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.out.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        System.out.println("Got unexpected LinkageError on DEO");
        le.printStackTrace(System.out);
        return;
    }
    /* use the base class reference to get a CL-specific instance */
    BaseOkay baseRef = (BaseOkay) obj;
    DoubledExtendOkay de = baseRef.getExtended();
    /* try to call through it */
    try {
        String result;
        result = BaseOkay.doStuff(de);
        System.out.println("Got DEO result " + result);
    } catch (LinkageError le) {
        System.out.println("Got unexpected LinkageError on DEO");
        le.printStackTrace(System.out);
        return;
    }
}
#end_block

#method_before
static void testInterface(ClassLoader loader) {
    Class getDoubledClass;
    Object obj;
    /* get GetDoubled from the "alternate" class loader */
    try {
        getDoubledClass = loader.loadClass("GetDoubled");
    } catch (ClassNotFoundException cnfe) {
        System.err.println("loadClass failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = getDoubledClass.newInstance();
    } catch (InstantiationException ie) {
        System.err.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.err.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        // Dalvik bails here
        System.out.println("Got LinkageError on GD");
        return;
    }
    /*
         * Cast the object to the interface, and try to use it.
         */
    IGetDoubled iface = (IGetDoubled) obj;
    try {
        /* "de" will be the wrong variety of DoubledExtendOkay */
        DoubledExtendOkay de = iface.getDoubled();
        // reference impl bails here
        String str = de.getStr();
    } catch (LinkageError le) {
        System.out.println("Got LinkageError on GD");
        return;
    }
    System.err.println("Should have failed by now on GetDoubled");
}
#method_after
static void testInterface(ClassLoader loader) {
    Class<?> getDoubledClass;
    Object obj;
    /* get GetDoubled from the "alternate" class loader */
    try {
        getDoubledClass = loader.loadClass("GetDoubled");
    } catch (ClassNotFoundException cnfe) {
        System.out.println("loadClass failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = getDoubledClass.newInstance();
    } catch (InstantiationException ie) {
        System.out.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.out.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        // Dalvik bails here
        System.out.println("Got LinkageError on GD");
        return;
    }
    /*
         * Cast the object to the interface, and try to use it.
         */
    IGetDoubled iface = (IGetDoubled) obj;
    try {
        /* "de" will be the wrong variety of DoubledExtendOkay */
        DoubledExtendOkay de = iface.getDoubled();
        // reference impl bails here
        String str = de.getStr();
    } catch (LinkageError le) {
        System.out.println("Got LinkageError on GD");
        return;
    }
    System.out.println("Should have failed by now on GetDoubled");
}
#end_block

#method_before
static void testAbstract(ClassLoader loader) {
    Class abstractGetClass;
    Object obj;
    /* get AbstractGet from the "alternate" loader */
    try {
        abstractGetClass = loader.loadClass("AbstractGet");
    } catch (ClassNotFoundException cnfe) {
        System.err.println("loadClass ta failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = abstractGetClass.newInstance();
    } catch (InstantiationException ie) {
        System.err.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.err.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        System.out.println("Got LinkageError on TA");
        return;
    }
    /* use the base class reference to get a CL-specific instance */
    BaseOkay baseRef = (BaseOkay) obj;
    DoubledExtendOkay de = baseRef.getExtended();
    /* try to call through it */
    try {
        String result;
        result = BaseOkay.doStuff(de);
    } catch (LinkageError le) {
        System.out.println("Got LinkageError on TA");
        return;
    }
    System.err.println("Should have failed by now in testAbstract");
}
#method_after
static void testAbstract(ClassLoader loader) {
    Class<?> abstractGetClass;
    Object obj;
    /* get AbstractGet from the "alternate" loader */
    try {
        abstractGetClass = loader.loadClass("AbstractGet");
    } catch (ClassNotFoundException cnfe) {
        System.out.println("loadClass ta failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = abstractGetClass.newInstance();
    } catch (InstantiationException ie) {
        System.out.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.out.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        System.out.println("Got LinkageError on TA");
        return;
    }
    /* use the base class reference to get a CL-specific instance */
    BaseOkay baseRef = (BaseOkay) obj;
    DoubledExtendOkay de = baseRef.getExtended();
    /* try to call through it */
    try {
        String result;
        result = BaseOkay.doStuff(de);
    } catch (LinkageError le) {
        System.out.println("Got LinkageError on TA");
        return;
    }
    System.out.println("Should have failed by now in testAbstract");
}
#end_block

#method_before
static void testImplement(ClassLoader loader) {
    Class doubledImplementClass;
    Object obj;
    useImplement(new DoubledImplement(), true);
    /* get the "alternate" version of DoubledImplement */
    try {
        doubledImplementClass = loader.loadClass("DoubledImplement");
    } catch (ClassNotFoundException cnfe) {
        System.err.println("loadClass failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = doubledImplementClass.newInstance();
    } catch (InstantiationException ie) {
        System.err.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.err.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        System.out.println("Got LinkageError on DI (early)");
        return;
    }
    /* if we lived this long, try to do something with it */
    ICommon icommon = (ICommon) obj;
    useImplement(icommon.getDoubledInstance(), false);
}
#method_after
static void testImplement(ClassLoader loader) {
    Class<?> doubledImplementClass;
    Object obj;
    useImplement(new DoubledImplement(), true);
    /* get the "alternate" version of DoubledImplement */
    try {
        doubledImplementClass = loader.loadClass("DoubledImplement");
    } catch (ClassNotFoundException cnfe) {
        System.out.println("loadClass failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = doubledImplementClass.newInstance();
    } catch (InstantiationException ie) {
        System.out.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.out.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        System.out.println("Got LinkageError on DI (early)");
        return;
    }
    /* if we lived this long, try to do something with it */
    ICommon icommon = (ICommon) obj;
    useImplement(icommon.getDoubledInstance(), false);
}
#end_block

#method_before
static void useImplement(DoubledImplement di, boolean isOne) {
    // + di.getClass().getClassLoader());
    try {
        di.one();
        if (!isOne) {
            System.err.println("ERROR: did not get LinkageError on DI");
        }
    } catch (LinkageError le) {
        if (!isOne) {
            System.out.println("Got LinkageError on DI (late)");
        } else {
            throw le;
        }
    }
}
#method_after
static void useImplement(DoubledImplement di, boolean isOne) {
    // + di.getClass().getClassLoader());
    try {
        di.one();
        if (!isOne) {
            System.out.println("ERROR: did not get LinkageError on DI");
        }
    } catch (LinkageError le) {
        if (!isOne) {
            System.out.println("Got LinkageError on DI (late)");
        } else {
            throw le;
        }
    }
}
#end_block

#method_before
static void testIfaceImplement(ClassLoader loader) {
    Class ifaceImplClass;
    Object obj;
    /*
         * Create an instance of IfaceImpl.  We also pull in
         * DoubledImplement2 from the other class loader; without this
         * we don't fail in some implementations.
         */
    try {
        ifaceImplClass = loader.loadClass("IfaceImpl");
        ifaceImplClass = loader.loadClass("DoubledImplement2");
    } catch (ClassNotFoundException cnfe) {
        System.err.println("loadClass failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = ifaceImplClass.newInstance();
    } catch (InstantiationException ie) {
        System.err.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.err.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        System.out.println("Got LinkageError on IDI (early)");
        // System.out.println(le);
        return;
    }
    /*
         * Without the pre-load of FancyLoader->DoubledImplement2, some
         * implementations will happily execute through this part.  "obj"
         * comes from FancyLoader, but the di2 returned from ifaceSuper
         * comes from the application class loader.
         */
    IfaceSuper ifaceSuper = (IfaceSuper) obj;
    DoubledImplement2 di2 = ifaceSuper.getDoubledInstance2();
    di2.one();
}
#method_after
static void testIfaceImplement(ClassLoader loader) {
    Class<?> ifaceImplClass;
    Object obj;
    /*
         * Create an instance of IfaceImpl.  We also pull in
         * DoubledImplement2 from the other class loader; without this
         * we don't fail in some implementations.
         */
    try {
        ifaceImplClass = loader.loadClass("IfaceImpl");
        ifaceImplClass = loader.loadClass("DoubledImplement2");
    } catch (ClassNotFoundException cnfe) {
        System.out.println("loadClass failed: " + cnfe);
        return;
    }
    /* instantiate */
    try {
        obj = ifaceImplClass.newInstance();
    } catch (InstantiationException ie) {
        System.out.println("newInstance failed: " + ie);
        return;
    } catch (IllegalAccessException iae) {
        System.out.println("newInstance failed: " + iae);
        return;
    } catch (LinkageError le) {
        System.out.println("Got LinkageError on IDI (early)");
        // System.out.println(le);
        return;
    }
    /*
         * Without the pre-load of FancyLoader->DoubledImplement2, some
         * implementations will happily execute through this part.  "obj"
         * comes from FancyLoader, but the di2 returned from ifaceSuper
         * comes from the application class loader.
         */
    IfaceSuper ifaceSuper = (IfaceSuper) obj;
    DoubledImplement2 di2 = ifaceSuper.getDoubledInstance2();
    di2.one();
}
#end_block

#method_before
private void run() {
    System.out.println(new A().i);
    // Now run the class from the -ex file.
    FancyLoader loader = new FancyLoader(getClass().getClassLoader());
    try {
        Class testEx = loader.loadClass("TestEx");
        Method test = testEx.getDeclaredMethod("test");
        test.invoke(null);
    } catch (Exception exc) {
        exc.printStackTrace(System.out);
    }
}
#method_after
private void run() {
    System.out.println(new A().i);
    // Now run the class from the -ex file.
    FancyLoader loader = new FancyLoader(getClass().getClassLoader());
    try {
        Class<?> testEx = loader.loadClass("TestEx");
        Method test = testEx.getDeclaredMethod("test");
        test.invoke(null);
    } catch (Exception exc) {
        exc.printStackTrace(System.out);
    }
}
#end_block

#method_before
protected Class<?> loadClass(String className, boolean resolve) throws ClassNotFoundException {
    if (this != level1ClassLoader) {
        if (className.equals("Level1")) {
            return level1ClassLoader.loadClass(className);
        } else if (className.equals("Level2")) {
            throw new ClassNotFoundException("None of my methods require Level2!");
        } else if (!className.equals("LoadedByMyClassLoader")) {
            // We're only going to handle LoadedByMyClassLoader.
            return getParent().loadClass(className);
        }
    } else {
        if (className != "Level1" && className != "Level2") {
            return getParent().loadClass(className);
        }
    }
    // Mimic what DexPathList.findClass is doing.
    try {
        for (Object element : dexElements) {
            Object dex = dexFileField.get(element);
            Method method = dex.getClass().getDeclaredMethod("loadClassBinaryName", String.class, ClassLoader.class, List.class);
            if (dex != null) {
                Class clazz = (Class) method.invoke(dex, className, this, null);
                if (clazz != null) {
                    return clazz;
                }
            }
        }
    } catch (Exception e) {
    /* Ignore */
    }
    return null;
}
#method_after
protected Class<?> loadClass(String className, boolean resolve) throws ClassNotFoundException {
    if (this != level1ClassLoader) {
        if (className.equals("Level1")) {
            return level1ClassLoader.loadClass(className);
        } else if (className.equals("Level2")) {
            throw new ClassNotFoundException("None of my methods require Level2!");
        } else if (!className.equals("LoadedByMyClassLoader")) {
            // We're only going to handle LoadedByMyClassLoader.
            return getParent().loadClass(className);
        }
    } else {
        if (className != "Level1" && className != "Level2") {
            return getParent().loadClass(className);
        }
    }
    // Mimic what DexPathList.findClass is doing.
    try {
        for (Object element : dexElements) {
            Object dex = dexFileField.get(element);
            Method method = dex.getClass().getDeclaredMethod("loadClassBinaryName", String.class, ClassLoader.class, List.class);
            if (dex != null) {
                Class<?> clazz = (Class<?>) method.invoke(dex, className, this, null);
                if (clazz != null) {
                    return clazz;
                }
            }
        }
    } catch (Exception e) {
    /* Ignore */
    }
    return null;
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    System.loadLibrary(args[0]);
    // Clone resolved methods, to restore the original version just
    // before we walk the stack in $noinline$bar.
    savedResolvedMethods = cloneResolvedMethods(Main.class);
    MyClassLoader o = new MyClassLoader();
    MyClassLoader.level1ClassLoader = new MyClassLoader();
    Class foo = o.loadClass("LoadedByMyClassLoader");
    Method m = foo.getDeclaredMethod("bar");
    try {
        m.invoke(null);
    } catch (Error e) {
    /* Ignore */
    }
}
#method_after
public static void main(String[] args) throws Exception {
    System.loadLibrary(args[0]);
    // Clone resolved methods, to restore the original version just
    // before we walk the stack in $noinline$bar.
    savedResolvedMethods = cloneResolvedMethods(Main.class);
    MyClassLoader o = new MyClassLoader();
    MyClassLoader.level1ClassLoader = new MyClassLoader();
    Class<?> foo = o.loadClass("LoadedByMyClassLoader");
    Method m = foo.getDeclaredMethod("bar");
    try {
        m.invoke(null);
    } catch (Error e) {
    /* Ignore */
    }
}
#end_block

#method_before
public static void main(String[] args) {
    SubClass.main(null);
    try {
        GetNonexistent.main(null);
        System.err.println("Not expected to succeed");
    } catch (VerifyError fe) {
        // dalvik
        System.out.println("Got expected failure");
    } catch (NoSuchFieldError nsfe) {
        // reference
        System.out.println("Got expected failure");
    }
}
#method_after
public static void main(String[] args) {
    SubClass.main(null);
    try {
        GetNonexistent.main(null);
        System.out.println("Not expected to succeed");
    } catch (VerifyError fe) {
        // dalvik
        System.out.println("Got expected failure");
    } catch (NoSuchFieldError nsfe) {
        // reference
        System.out.println("Got expected failure");
    }
    try {
        Class<?> c = Class.forName("SubClassUsingInaccessibleField");
        Object o = c.newInstance();
        c.getMethod("test").invoke(o, null);
    } catch (InvocationTargetException ite) {
        if (ite.getCause() instanceof IllegalAccessError) {
            System.out.println("Got expected failure");
        } else {
            System.out.println("Got unexpected failure " + ite.getCause());
        }
    } catch (Exception e) {
        System.out.println("Got unexpected failure " + e);
    }
}
#end_block

#method_before
public Object getValue(Field field, Object obj, char type, Class expectedException) {
    Object result = null;
    try {
        switch(type) {
            case 'Z':
                result = field.getBoolean(obj);
                break;
            case 'B':
                result = field.getByte(obj);
                break;
            case 'S':
                result = field.getShort(obj);
                break;
            case 'C':
                result = field.getChar(obj);
                break;
            case 'I':
                result = field.getInt(obj);
                break;
            case 'J':
                result = field.getLong(obj);
                break;
            case 'F':
                result = field.getFloat(obj);
                break;
            case 'D':
                result = field.getDouble(obj);
                break;
            case 'L':
                result = field.get(obj);
                break;
            default:
                throw new RuntimeException("bad type '" + type + "'");
        }
        /* success; expected? */
        if (expectedException != null) {
            System.err.println("ERROR: call succeeded for field " + field + " with a read of type '" + type + "', was expecting " + expectedException);
            Thread.dumpStack();
        }
    } catch (Exception ex) {
        if (expectedException == null) {
            System.err.println("ERROR: call failed unexpectedly: " + ex.getClass());
            ex.printStackTrace(System.out);
        } else {
            if (!expectedException.equals(ex.getClass())) {
                System.err.println("ERROR: incorrect exception: wanted " + expectedException.getName() + ", got " + ex.getClass());
                ex.printStackTrace(System.out);
            }
        }
    }
    return result;
}
#method_after
public Object getValue(Field field, Object obj, char type, Class<?> expectedException) {
    Object result = null;
    try {
        switch(type) {
            case 'Z':
                result = field.getBoolean(obj);
                break;
            case 'B':
                result = field.getByte(obj);
                break;
            case 'S':
                result = field.getShort(obj);
                break;
            case 'C':
                result = field.getChar(obj);
                break;
            case 'I':
                result = field.getInt(obj);
                break;
            case 'J':
                result = field.getLong(obj);
                break;
            case 'F':
                result = field.getFloat(obj);
                break;
            case 'D':
                result = field.getDouble(obj);
                break;
            case 'L':
                result = field.get(obj);
                break;
            default:
                throw new RuntimeException("bad type '" + type + "'");
        }
        /* success; expected? */
        if (expectedException != null) {
            System.out.println("ERROR: call succeeded for field " + field + " with a read of type '" + type + "', was expecting " + expectedException);
            Thread.dumpStack();
        }
    } catch (Exception ex) {
        if (expectedException == null) {
            System.out.println("ERROR: call failed unexpectedly: " + ex.getClass());
            ex.printStackTrace(System.out);
        } else {
            if (!expectedException.equals(ex.getClass())) {
                System.out.println("ERROR: incorrect exception: wanted " + expectedException.getName() + ", got " + ex.getClass());
                ex.printStackTrace(System.out);
            }
        }
    }
    return result;
}
#end_block

#method_before
public Object getValue(Field field, Object obj, char type, Class expectedException) {
    Object result = null;
    try {
        switch(type) {
            case 'Z':
                result = field.getBoolean(obj);
                break;
            case 'B':
                result = field.getByte(obj);
                break;
            case 'S':
                result = field.getShort(obj);
                break;
            case 'C':
                result = field.getChar(obj);
                break;
            case 'I':
                result = field.getInt(obj);
                break;
            case 'J':
                result = field.getLong(obj);
                break;
            case 'F':
                result = field.getFloat(obj);
                break;
            case 'D':
                result = field.getDouble(obj);
                break;
            case 'L':
                result = field.get(obj);
                break;
            default:
                throw new RuntimeException("bad type '" + type + "'");
        }
        /* success; expected? */
        if (expectedException != null) {
            System.err.println("ERROR: call succeeded for field " + field + " with a read of type '" + type + "', was expecting " + expectedException);
            Thread.dumpStack();
        }
    } catch (Exception ex) {
        if (expectedException == null) {
            System.err.println("ERROR: call failed unexpectedly: " + ex.getClass());
            ex.printStackTrace(System.out);
        } else {
            if (!expectedException.equals(ex.getClass())) {
                System.err.println("ERROR: incorrect exception: wanted " + expectedException.getName() + ", got " + ex.getClass());
                ex.printStackTrace(System.out);
            }
        }
    }
    return result;
}
#method_after
public Object getValue(Field field, Object obj, char type, Class<?> expectedException) {
    Object result = null;
    try {
        switch(type) {
            case 'Z':
                result = field.getBoolean(obj);
                break;
            case 'B':
                result = field.getByte(obj);
                break;
            case 'S':
                result = field.getShort(obj);
                break;
            case 'C':
                result = field.getChar(obj);
                break;
            case 'I':
                result = field.getInt(obj);
                break;
            case 'J':
                result = field.getLong(obj);
                break;
            case 'F':
                result = field.getFloat(obj);
                break;
            case 'D':
                result = field.getDouble(obj);
                break;
            case 'L':
                result = field.get(obj);
                break;
            default:
                throw new RuntimeException("bad type '" + type + "'");
        }
        /* success; expected? */
        if (expectedException != null) {
            System.out.println("ERROR: call succeeded for field " + field + " with a read of type '" + type + "', was expecting " + expectedException);
            Thread.dumpStack();
        }
    } catch (Exception ex) {
        if (expectedException == null) {
            System.out.println("ERROR: call failed unexpectedly: " + ex.getClass());
            ex.printStackTrace(System.out);
        } else {
            if (!expectedException.equals(ex.getClass())) {
                System.out.println("ERROR: incorrect exception: wanted " + expectedException.getName() + ", got " + ex.getClass());
                ex.printStackTrace(System.out);
            }
        }
    }
    return result;
}
#end_block

#method_before
public Object invoke(Method method, Object obj, Class expectedException) {
    Object result = null;
    try {
        result = method.invoke(obj);
        /* success; expected? */
        if (expectedException != null) {
            System.err.println("ERROR: call succeeded for method " + method + "', was expecting " + expectedException);
            Thread.dumpStack();
        }
    } catch (Exception ex) {
        if (expectedException == null) {
            System.err.println("ERROR: call failed unexpectedly: " + ex.getClass());
            ex.printStackTrace(System.out);
        } else {
            if (!expectedException.equals(ex.getClass())) {
                System.err.println("ERROR: incorrect exception: wanted " + expectedException.getName() + ", got " + ex.getClass());
                ex.printStackTrace(System.out);
            }
        }
    }
    return result;
}
#method_after
public Object invoke(Method method, Object obj, Class<?> expectedException) {
    Object result = null;
    try {
        result = method.invoke(obj);
        /* success; expected? */
        if (expectedException != null) {
            System.out.println("ERROR: call succeeded for method " + method + "', was expecting " + expectedException);
            Thread.dumpStack();
        }
    } catch (Exception ex) {
        if (expectedException == null) {
            System.out.println("ERROR: call failed unexpectedly: " + ex.getClass());
            ex.printStackTrace(System.out);
        } else {
            if (!expectedException.equals(ex.getClass())) {
                System.out.println("ERROR: incorrect exception: wanted " + expectedException.getName() + ", got " + ex.getClass());
                ex.printStackTrace(System.out);
            }
        }
    }
    return result;
}
#end_block

#method_before
public static void main() {
    ConcreteSub sub = new ConcreteSub();
    try {
        callBase(sub);
    } catch (AbstractMethodError ame) {
        System.out.println("Got expected exception from abs.doStuff().");
    }
    /*
         * Check reflection stuff.
         */
    Class absClass = AbstractBase.class;
    Method meth;
    System.out.println("class modifiers=" + absClass.getModifiers());
    try {
        meth = absClass.getMethod("redefineMe", (Class[]) null);
    } catch (NoSuchMethodException nsme) {
        nsme.printStackTrace(System.out);
        return;
    }
    System.out.println("meth modifiers=" + meth.getModifiers());
}
#method_after
public static void main() {
    ConcreteSub sub = new ConcreteSub();
    try {
        callBase(sub);
    } catch (AbstractMethodError ame) {
        System.out.println("Got expected exception from abs.doStuff().");
    }
    /*
         * Check reflection stuff.
         */
    Class<?> absClass = AbstractBase.class;
    Method meth;
    System.out.println("class modifiers=" + absClass.getModifiers());
    try {
        meth = absClass.getMethod("redefineMe");
    } catch (NoSuchMethodException nsme) {
        nsme.printStackTrace(System.out);
        return;
    }
    System.out.println("meth modifiers=" + meth.getModifiers());
}
#end_block

#method_before
void printMethodInfo(Method meth) {
    Class[] params, exceptions;
    int i;
    System.out.println("Method name is " + meth.getName());
    System.out.println(" Declaring class is " + meth.getDeclaringClass().getName());
    params = meth.getParameterTypes();
    for (i = 0; i < params.length; i++) System.out.println(" Arg " + i + ": " + params[i].getName());
    exceptions = meth.getExceptionTypes();
    for (i = 0; i < exceptions.length; i++) System.out.println(" Exc " + i + ": " + exceptions[i].getName());
    System.out.println(" Return type is " + meth.getReturnType().getName());
    System.out.println(" Access flags are 0x" + Integer.toHexString(meth.getModifiers()));
// System.out.println(" GenericStr is " + meth.toGenericString());
}
#method_after
void printMethodInfo(Method meth) {
    Class<?>[] params, exceptions;
    int i;
    System.out.println("Method name is " + meth.getName());
    System.out.println(" Declaring class is " + meth.getDeclaringClass().getName());
    params = meth.getParameterTypes();
    for (i = 0; i < params.length; i++) System.out.println(" Arg " + i + ": " + params[i].getName());
    exceptions = meth.getExceptionTypes();
    for (i = 0; i < exceptions.length; i++) System.out.println(" Exc " + i + ": " + exceptions[i].getName());
    System.out.println(" Return type is " + meth.getReturnType().getName());
    System.out.println(" Access flags are 0x" + Integer.toHexString(meth.getModifiers()));
// System.out.println(" GenericStr is " + meth.toGenericString());
}
#end_block

#method_before
private void showStrings(Target instance) throws NoSuchFieldException, IllegalAccessException {
    Class target = Target.class;
    String one, two, three, four;
    Field field = null;
    field = target.getField("string1");
    one = (String) field.get(instance);
    field = target.getField("string2");
    two = (String) field.get(instance);
    field = target.getField("string3");
    three = (String) field.get(instance);
    System.out.println("  ::: " + one + ":" + two + ":" + three);
}
#method_after
private void showStrings(Target instance) throws NoSuchFieldException, IllegalAccessException {
    Class<?> target = Target.class;
    String one, two, three, four;
    Field field = null;
    field = target.getField("string1");
    one = (String) field.get(instance);
    field = target.getField("string2");
    two = (String) field.get(instance);
    field = target.getField("string3");
    three = (String) field.get(instance);
    System.out.println("  ::: " + one + ":" + two + ":" + three);
}
#end_block

#method_before
public static void checkAccess() {
    try {
        Class target = otherpackage.Other.class;
        Object instance = new otherpackage.Other();
        Method meth;
        meth = target.getMethod("publicMethod", (Class[]) null);
        meth.invoke(instance);
        try {
            meth = target.getMethod("packageMethod", (Class[]) null);
            System.err.println("succeeded on package-scope method");
        } catch (NoSuchMethodException nsme) {
        // good
        }
        instance = otherpackage.Other.getInnerClassInstance();
        target = instance.getClass();
        meth = target.getMethod("innerMethod", (Class[]) null);
        try {
            if (!FULL_ACCESS_CHECKS) {
                throw new IllegalAccessException();
            }
            meth.invoke(instance);
            System.err.println("inner-method invoke unexpectedly worked");
        } catch (IllegalAccessException iae) {
        // good
        }
        Field field = target.getField("innerField");
        try {
            int x = field.getInt(instance);
            if (!FULL_ACCESS_CHECKS) {
                throw new IllegalAccessException();
            }
            System.err.println("field get unexpectedly worked: " + x);
        } catch (IllegalAccessException iae) {
        // good
        }
    } catch (Exception ex) {
        System.out.println("----- unexpected exception -----");
        ex.printStackTrace(System.out);
    }
}
#method_after
public static void checkAccess() {
    try {
        Class<?> target = otherpackage.Other.class;
        Object instance = new otherpackage.Other();
        Method meth;
        meth = target.getMethod("publicMethod");
        meth.invoke(instance);
        try {
            meth = target.getMethod("packageMethod");
            System.out.println("succeeded on package-scope method");
        } catch (NoSuchMethodException nsme) {
        // good
        }
        instance = otherpackage.Other.getInnerClassInstance();
        target = instance.getClass();
        meth = target.getMethod("innerMethod");
        try {
            if (!FULL_ACCESS_CHECKS) {
                throw new IllegalAccessException();
            }
            meth.invoke(instance);
            System.out.println("inner-method invoke unexpectedly worked");
        } catch (IllegalAccessException iae) {
        // good
        }
        Field field = target.getField("innerField");
        try {
            int x = field.getInt(instance);
            if (!FULL_ACCESS_CHECKS) {
                throw new IllegalAccessException();
            }
            System.out.println("field get unexpectedly worked: " + x);
        } catch (IllegalAccessException iae) {
        // good
        }
    } catch (Exception ex) {
        System.out.println("----- unexpected exception -----");
        ex.printStackTrace(System.out);
    }
}
#end_block

#method_before
public void run() {
    Class target = Target.class;
    Method meth = null;
    Field field = null;
    boolean excep;
    try {
        meth = target.getMethod("myMethod", new Class[] { int.class });
        if (meth.getDeclaringClass() != target)
            throw new RuntimeException();
        printMethodInfo(meth);
        meth = target.getMethod("myMethod", new Class[] { float.class });
        printMethodInfo(meth);
        meth = target.getMethod("myNoargMethod", (Class[]) null);
        printMethodInfo(meth);
        meth = target.getMethod("myMethod", new Class[] { String[].class, float.class, char.class });
        printMethodInfo(meth);
        Target instance = new Target();
        Object[] argList = new Object[] { new String[] { "hi there" }, new Float(3.1415926f), new Character('\u2714') };
        System.out.println("Before, float is " + ((Float) argList[1]).floatValue());
        Integer boxval;
        boxval = (Integer) meth.invoke(instance, argList);
        System.out.println("Result of invoke: " + boxval.intValue());
        System.out.println("Calling no-arg void-return method");
        meth = target.getMethod("myNoargMethod", (Class[]) null);
        meth.invoke(instance, (Object[]) null);
        /* try invoking a method that throws an exception */
        meth = target.getMethod("throwingMethod", (Class[]) null);
        try {
            meth.invoke(instance, (Object[]) null);
            System.out.println("GLITCH: didn't throw");
        } catch (InvocationTargetException ite) {
            System.out.println("Invoke got expected exception:");
            System.out.println(ite.getClass().getName());
            System.out.println(ite.getCause());
        } catch (Exception ex) {
            System.out.println("GLITCH: invoke got wrong exception:");
            ex.printStackTrace(System.out);
        }
        System.out.println("");
        field = target.getField("string1");
        if (field.getDeclaringClass() != target)
            throw new RuntimeException();
        printFieldInfo(field);
        String strVal = (String) field.get(instance);
        System.out.println("  string1 value is '" + strVal + "'");
        showStrings(instance);
        field.set(instance, new String("a new string"));
        strVal = (String) field.get(instance);
        System.out.println("  string1 value is now '" + strVal + "'");
        showStrings(instance);
        try {
            field.set(instance, new Object());
            System.out.println("WARNING: able to store Object into String");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected illegal obj store exc");
        }
        try {
            String four;
            field = target.getField("string4");
            four = (String) field.get(instance);
            System.out.println("WARNING: able to access string4: " + four);
        } catch (IllegalAccessException iae) {
            System.out.println("  got expected access exc");
        } catch (NoSuchFieldException nsfe) {
            System.out.println("  got the other expected access exc");
        }
        try {
            String three;
            field = target.getField("string3");
            three = (String) field.get(this);
            System.out.println("WARNING: able to get string3 in wrong obj: " + three);
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected arg exc");
        }
        /*
             * Try setting a field to null.
             */
        String four;
        field = target.getDeclaredField("string3");
        field.set(instance, null);
        /*
             * Try getDeclaredField on a non-existant field.
             */
        try {
            field = target.getDeclaredField("nonExistant");
            System.out.println("ERROR: Expected NoSuchFieldException");
        } catch (NoSuchFieldException nsfe) {
            String msg = nsfe.getMessage();
            if (!msg.contains("Target;")) {
                System.out.println("  NoSuchFieldException '" + msg + "' didn't contain class");
            }
        }
        /*
             * Do some stuff with long.
             */
        long longVal;
        field = target.getField("pubLong");
        longVal = field.getLong(instance);
        System.out.println("pubLong initial value is " + Long.toHexString(longVal));
        field.setLong(instance, 0x9988776655443322L);
        longVal = field.getLong(instance);
        System.out.println("pubLong new value is " + Long.toHexString(longVal));
        field = target.getField("superInt");
        if (field.getDeclaringClass() == target)
            throw new RuntimeException();
        printFieldInfo(field);
        int intVal = field.getInt(instance);
        System.out.println("  superInt value is " + intVal);
        Integer boxedIntVal = (Integer) field.get(instance);
        System.out.println("  superInt boxed is " + boxedIntVal);
        field.set(instance, new Integer(20202));
        intVal = field.getInt(instance);
        System.out.println("  superInt value is now " + intVal);
        field.setShort(instance, (short) 30303);
        intVal = field.getInt(instance);
        System.out.println("  superInt value (from short) is now " + intVal);
        field.setInt(instance, 40404);
        intVal = field.getInt(instance);
        System.out.println("  superInt value is now " + intVal);
        try {
            field.set(instance, new Long(123));
            System.out.println("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected long->int failure");
        }
        try {
            field.setLong(instance, 123);
            System.out.println("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected long->int failure");
        }
        try {
            field.set(instance, new String("abc"));
            System.out.println("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected string->int failure");
        }
        try {
            field.getShort(instance);
            System.out.println("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected int->short failure");
        }
        field = target.getField("superClassInt");
        printFieldInfo(field);
        int superClassIntVal = field.getInt(instance);
        System.out.println("  superClassInt value is " + superClassIntVal);
        field = target.getField("staticDouble");
        printFieldInfo(field);
        double staticDoubleVal = field.getDouble(null);
        System.out.println("  staticDoubleVal value is " + staticDoubleVal);
        try {
            field.getLong(instance);
            System.out.println("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected double->long failure");
        }
        excep = false;
        try {
            field = target.getField("aPrivateInt");
            printFieldInfo(field);
        } catch (NoSuchFieldException nsfe) {
            System.out.println("as expected: aPrivateInt not found");
            excep = true;
        }
        if (!excep)
            System.out.println("BUG: got aPrivateInt");
        field = target.getField("constantString");
        printFieldInfo(field);
        String val = (String) field.get(instance);
        System.out.println("  Constant test value is " + val);
        field = target.getField("cantTouchThis");
        printFieldInfo(field);
        intVal = field.getInt(instance);
        System.out.println("  cantTouchThis is " + intVal);
        try {
            field.setInt(instance, 99);
            System.out.println("ERROR: set-final did not throw exception");
        } catch (IllegalAccessException iae) {
            System.out.println("  as expected: set-final throws exception");
        }
        intVal = field.getInt(instance);
        System.out.println("  cantTouchThis is still " + intVal);
        System.out.println("  " + field + " accessible=" + field.isAccessible());
        field.setAccessible(true);
        System.out.println("  " + field + " accessible=" + field.isAccessible());
        // exercise int version
        field.setInt(instance, 87);
        intVal = field.getInt(instance);
        System.out.println("  cantTouchThis is now " + intVal);
        // exercise Object version
        field.set(instance, 88);
        intVal = field.getInt(instance);
        System.out.println("  cantTouchThis is now " + intVal);
        Constructor<Target> cons;
        Target targ;
        Object[] args;
        cons = target.getConstructor(new Class[] { int.class, float.class });
        args = new Object[] { new Integer(7), new Float(3.3333) };
        System.out.println("cons modifiers=" + cons.getModifiers());
        targ = cons.newInstance(args);
        targ.myMethod(17);
        try {
            Thrower thrower = Thrower.class.newInstance();
            System.out.println("ERROR: Class.newInstance did not throw exception");
        } catch (UnsupportedOperationException uoe) {
            System.out.println("got expected exception for Class.newInstance");
        } catch (Exception e) {
            System.out.println("ERROR: Class.newInstance got unexpected exception: " + e.getClass().getName());
        }
        try {
            Constructor<Thrower> constructor = Thrower.class.getDeclaredConstructor();
            Thrower thrower = constructor.newInstance();
            System.out.println("ERROR: Constructor.newInstance did not throw exception");
        } catch (InvocationTargetException ite) {
            System.out.println("got expected exception for Constructor.newInstance");
        } catch (Exception e) {
            System.out.println("ERROR: Constructor.newInstance got unexpected exception: " + e.getClass().getName());
        }
    } catch (Exception ex) {
        System.out.println("----- unexpected exception -----");
        ex.printStackTrace(System.out);
    }
    System.out.println("ReflectTest done!");
}
#method_after
public void run() {
    Class<Target> target = Target.class;
    Method meth = null;
    Field field = null;
    boolean excep;
    try {
        meth = target.getMethod("myMethod", int.class);
        if (meth.getDeclaringClass() != target)
            throw new RuntimeException();
        printMethodInfo(meth);
        meth = target.getMethod("myMethod", float.class);
        printMethodInfo(meth);
        meth = target.getMethod("myNoargMethod");
        printMethodInfo(meth);
        meth = target.getMethod("myMethod", String[].class, float.class, char.class);
        printMethodInfo(meth);
        Target instance = new Target();
        Object[] argList = new Object[] { new String[] { "hi there" }, new Float(3.1415926f), new Character('\u2714') };
        System.out.println("Before, float is " + ((Float) argList[1]).floatValue());
        Integer boxval;
        boxval = (Integer) meth.invoke(instance, argList);
        System.out.println("Result of invoke: " + boxval.intValue());
        System.out.println("Calling no-arg void-return method");
        meth = target.getMethod("myNoargMethod");
        meth.invoke(instance, (Object[]) null);
        /* try invoking a method that throws an exception */
        meth = target.getMethod("throwingMethod");
        try {
            meth.invoke(instance, (Object[]) null);
            System.out.println("GLITCH: didn't throw");
        } catch (InvocationTargetException ite) {
            System.out.println("Invoke got expected exception:");
            System.out.println(ite.getClass().getName());
            System.out.println(ite.getCause());
        } catch (Exception ex) {
            System.out.println("GLITCH: invoke got wrong exception:");
            ex.printStackTrace(System.out);
        }
        System.out.println("");
        field = target.getField("string1");
        if (field.getDeclaringClass() != target)
            throw new RuntimeException();
        printFieldInfo(field);
        String strVal = (String) field.get(instance);
        System.out.println("  string1 value is '" + strVal + "'");
        showStrings(instance);
        field.set(instance, new String("a new string"));
        strVal = (String) field.get(instance);
        System.out.println("  string1 value is now '" + strVal + "'");
        showStrings(instance);
        try {
            field.set(instance, new Object());
            System.out.println("WARNING: able to store Object into String");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected illegal obj store exc");
        }
        try {
            String four;
            field = target.getField("string4");
            four = (String) field.get(instance);
            System.out.println("WARNING: able to access string4: " + four);
        } catch (IllegalAccessException iae) {
            System.out.println("  got expected access exc");
        } catch (NoSuchFieldException nsfe) {
            System.out.println("  got the other expected access exc");
        }
        try {
            String three;
            field = target.getField("string3");
            three = (String) field.get(this);
            System.out.println("WARNING: able to get string3 in wrong obj: " + three);
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected arg exc");
        }
        /*
             * Try setting a field to null.
             */
        String four;
        field = target.getDeclaredField("string3");
        field.set(instance, null);
        /*
             * Try getDeclaredField on a non-existant field.
             */
        try {
            field = target.getDeclaredField("nonExistant");
            System.out.println("ERROR: Expected NoSuchFieldException");
        } catch (NoSuchFieldException nsfe) {
            String msg = nsfe.getMessage();
            if (!msg.contains("Target;")) {
                System.out.println("  NoSuchFieldException '" + msg + "' didn't contain class");
            }
        }
        /*
             * Do some stuff with long.
             */
        long longVal;
        field = target.getField("pubLong");
        longVal = field.getLong(instance);
        System.out.println("pubLong initial value is " + Long.toHexString(longVal));
        field.setLong(instance, 0x9988776655443322L);
        longVal = field.getLong(instance);
        System.out.println("pubLong new value is " + Long.toHexString(longVal));
        field = target.getField("superInt");
        if (field.getDeclaringClass() == target)
            throw new RuntimeException();
        printFieldInfo(field);
        int intVal = field.getInt(instance);
        System.out.println("  superInt value is " + intVal);
        Integer boxedIntVal = (Integer) field.get(instance);
        System.out.println("  superInt boxed is " + boxedIntVal);
        field.set(instance, new Integer(20202));
        intVal = field.getInt(instance);
        System.out.println("  superInt value is now " + intVal);
        field.setShort(instance, (short) 30303);
        intVal = field.getInt(instance);
        System.out.println("  superInt value (from short) is now " + intVal);
        field.setInt(instance, 40404);
        intVal = field.getInt(instance);
        System.out.println("  superInt value is now " + intVal);
        try {
            field.set(instance, new Long(123));
            System.out.println("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected long->int failure");
        }
        try {
            field.setLong(instance, 123);
            System.out.println("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected long->int failure");
        }
        try {
            field.set(instance, new String("abc"));
            System.out.println("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected string->int failure");
        }
        try {
            field.getShort(instance);
            System.out.println("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected int->short failure");
        }
        field = target.getField("superClassInt");
        printFieldInfo(field);
        int superClassIntVal = field.getInt(instance);
        System.out.println("  superClassInt value is " + superClassIntVal);
        field = target.getField("staticDouble");
        printFieldInfo(field);
        double staticDoubleVal = field.getDouble(null);
        System.out.println("  staticDoubleVal value is " + staticDoubleVal);
        try {
            field.getLong(instance);
            System.out.println("FAIL: expected exception not thrown");
        } catch (IllegalArgumentException iae) {
            System.out.println("  got expected double->long failure");
        }
        excep = false;
        try {
            field = target.getField("aPrivateInt");
            printFieldInfo(field);
        } catch (NoSuchFieldException nsfe) {
            System.out.println("as expected: aPrivateInt not found");
            excep = true;
        }
        if (!excep)
            System.out.println("BUG: got aPrivateInt");
        field = target.getField("constantString");
        printFieldInfo(field);
        String val = (String) field.get(instance);
        System.out.println("  Constant test value is " + val);
        field = target.getField("cantTouchThis");
        printFieldInfo(field);
        intVal = field.getInt(instance);
        System.out.println("  cantTouchThis is " + intVal);
        try {
            field.setInt(instance, 99);
            System.out.println("ERROR: set-final did not throw exception");
        } catch (IllegalAccessException iae) {
            System.out.println("  as expected: set-final throws exception");
        }
        intVal = field.getInt(instance);
        System.out.println("  cantTouchThis is still " + intVal);
        System.out.println("  " + field + " accessible=" + field.isAccessible());
        field.setAccessible(true);
        System.out.println("  " + field + " accessible=" + field.isAccessible());
        // exercise int version
        field.setInt(instance, 87);
        intVal = field.getInt(instance);
        System.out.println("  cantTouchThis is now " + intVal);
        // exercise Object version
        field.set(instance, 88);
        intVal = field.getInt(instance);
        System.out.println("  cantTouchThis is now " + intVal);
        Constructor<Target> cons;
        Target targ;
        Object[] args;
        cons = target.getConstructor(int.class, float.class);
        args = new Object[] { new Integer(7), new Float(3.3333) };
        System.out.println("cons modifiers=" + cons.getModifiers());
        targ = cons.newInstance(args);
        targ.myMethod(17);
        try {
            Thrower thrower = Thrower.class.newInstance();
            System.out.println("ERROR: Class.newInstance did not throw exception");
        } catch (UnsupportedOperationException uoe) {
            System.out.println("got expected exception for Class.newInstance");
        } catch (Exception e) {
            System.out.println("ERROR: Class.newInstance got unexpected exception: " + e.getClass().getName());
        }
        try {
            Constructor<Thrower> constructor = Thrower.class.getDeclaredConstructor();
            Thrower thrower = constructor.newInstance();
            System.out.println("ERROR: Constructor.newInstance did not throw exception");
        } catch (InvocationTargetException ite) {
            System.out.println("got expected exception for Constructor.newInstance");
        } catch (Exception e) {
            System.out.println("ERROR: Constructor.newInstance got unexpected exception: " + e.getClass().getName());
        }
    } catch (Exception ex) {
        System.out.println("----- unexpected exception -----");
        ex.printStackTrace(System.out);
    }
    System.out.println("ReflectTest done!");
}
#end_block

#method_before
public static void checkClinitForFields() throws Exception {
    // Loading a class constant shouldn't run <clinit>.
    System.out.println("calling const-class FieldNoisyInitUser.class");
    Class niuClass = FieldNoisyInitUser.class;
    System.out.println("called const-class FieldNoisyInitUser.class");
    // Getting the declared fields doesn't run <clinit>.
    Field[] fields = niuClass.getDeclaredFields();
    System.out.println("got fields");
    Field field = niuClass.getField("staticField");
    System.out.println("got field");
    field.get(null);
    System.out.println("read field value");
    // FieldNoisyInitUser should now be initialized, but FieldNoisyInit shouldn't be initialized yet.
    FieldNoisyInitUser niu = new FieldNoisyInitUser();
    FieldNoisyInit ni = new FieldNoisyInit();
    System.out.println("");
}
#method_after
public static void checkClinitForFields() throws Exception {
    // Loading a class constant shouldn't run <clinit>.
    System.out.println("calling const-class FieldNoisyInitUser.class");
    Class<?> niuClass = FieldNoisyInitUser.class;
    System.out.println("called const-class FieldNoisyInitUser.class");
    // Getting the declared fields doesn't run <clinit>.
    Field[] fields = niuClass.getDeclaredFields();
    System.out.println("got fields");
    Field field = niuClass.getField("staticField");
    System.out.println("got field");
    field.get(null);
    System.out.println("read field value");
    // FieldNoisyInitUser should now be initialized, but FieldNoisyInit shouldn't be initialized yet.
    FieldNoisyInitUser niu = new FieldNoisyInitUser();
    FieldNoisyInit ni = new FieldNoisyInit();
    System.out.println("");
}
#end_block

#method_before
public static void checkClinitForMethods() throws Exception {
    // Loading a class constant shouldn't run <clinit>.
    System.out.println("calling const-class MethodNoisyInitUser.class");
    Class niuClass = MethodNoisyInitUser.class;
    System.out.println("called const-class MethodNoisyInitUser.class");
    // Getting the declared methods doesn't run <clinit>.
    Method[] methods = niuClass.getDeclaredMethods();
    System.out.println("got methods");
    Method method = niuClass.getMethod("staticMethod", (Class[]) null);
    System.out.println("got method");
    method.invoke(null);
    System.out.println("invoked method");
    // MethodNoisyInitUser should now be initialized, but MethodNoisyInit shouldn't be initialized yet.
    MethodNoisyInitUser niu = new MethodNoisyInitUser();
    MethodNoisyInit ni = new MethodNoisyInit();
    System.out.println("");
}
#method_after
public static void checkClinitForMethods() throws Exception {
    // Loading a class constant shouldn't run <clinit>.
    System.out.println("calling const-class MethodNoisyInitUser.class");
    Class<?> niuClass = MethodNoisyInitUser.class;
    System.out.println("called const-class MethodNoisyInitUser.class");
    // Getting the declared methods doesn't run <clinit>.
    Method[] methods = niuClass.getDeclaredMethods();
    System.out.println("got methods");
    Method method = niuClass.getMethod("staticMethod");
    System.out.println("got method");
    method.invoke(null);
    System.out.println("invoked method");
    // MethodNoisyInitUser should now be initialized, but MethodNoisyInit shouldn't be initialized yet.
    MethodNoisyInitUser niu = new MethodNoisyInitUser();
    MethodNoisyInit ni = new MethodNoisyInit();
    System.out.println("");
}
#end_block

#method_before
public static void checkGeneric() {
    Field field;
    try {
        field = Main.class.getField("dummy");
    } catch (NoSuchFieldException nsfe) {
        throw new RuntimeException(nsfe);
    }
    Type listType = field.getGenericType();
    System.out.println("generic field: " + listType);
    Method method;
    try {
        method = Main.class.getMethod("fancyMethod", new Class[] { ArrayList.class });
    } catch (NoSuchMethodException nsme) {
        throw new RuntimeException(nsme);
    }
    Type[] parmTypes = method.getGenericParameterTypes();
    Type ret = method.getGenericReturnType();
    System.out.println("generic method " + method.getName() + " params='" + stringifyTypeArray(parmTypes) + "' ret='" + ret + "'");
    Constructor ctor;
    try {
        ctor = Main.class.getConstructor(new Class[] { ArrayList.class });
    } catch (NoSuchMethodException nsme) {
        throw new RuntimeException(nsme);
    }
    parmTypes = ctor.getGenericParameterTypes();
    System.out.println("generic ctor " + ctor.getName() + " params='" + stringifyTypeArray(parmTypes) + "'");
}
#method_after
public static void checkGeneric() {
    Field field;
    try {
        field = Main.class.getField("dummy");
    } catch (NoSuchFieldException nsfe) {
        throw new RuntimeException(nsfe);
    }
    Type listType = field.getGenericType();
    System.out.println("generic field: " + listType);
    Method method;
    try {
        method = Main.class.getMethod("fancyMethod", ArrayList.class);
    } catch (NoSuchMethodException nsme) {
        throw new RuntimeException(nsme);
    }
    Type[] parmTypes = method.getGenericParameterTypes();
    Type ret = method.getGenericReturnType();
    System.out.println("generic method " + method.getName() + " params='" + stringifyTypeArray(parmTypes) + "' ret='" + ret + "'");
    Constructor<?> ctor;
    try {
        ctor = Main.class.getConstructor(ArrayList.class);
    } catch (NoSuchMethodException nsme) {
        throw new RuntimeException(nsme);
    }
    parmTypes = ctor.getGenericParameterTypes();
    System.out.println("generic ctor " + ctor.getName() + " params='" + stringifyTypeArray(parmTypes) + "'");
}
#end_block

#method_before
public static void checkUnique() {
    Field field1, field2;
    try {
        field1 = Main.class.getField("dummy");
        field2 = Main.class.getField("dummy");
    } catch (NoSuchFieldException nsfe) {
        throw new RuntimeException(nsfe);
    }
    if (field1 == field2) {
        System.out.println("ERROR: fields shouldn't have reference equality");
    } else {
        System.out.println("fields are unique");
    }
    if (field1.hashCode() == field2.hashCode() && field1.equals(field2)) {
        System.out.println("fields are .equals");
    } else {
        System.out.println("ERROR: fields fail equality");
    }
    Method method1, method2;
    try {
        method1 = Main.class.getMethod("fancyMethod", new Class[] { ArrayList.class });
        method2 = Main.class.getMethod("fancyMethod", new Class[] { ArrayList.class });
    } catch (NoSuchMethodException nsme) {
        throw new RuntimeException(nsme);
    }
    if (method1 == method2) {
        System.out.println("ERROR: methods shouldn't have reference equality");
    } else {
        System.out.println("methods are unique");
    }
    if (method1.hashCode() == method2.hashCode() && method1.equals(method2)) {
        System.out.println("methods are .equals");
    } else {
        System.out.println("ERROR: methods fail equality");
    }
}
#method_after
public static void checkUnique() {
    Field field1, field2;
    try {
        field1 = Main.class.getField("dummy");
        field2 = Main.class.getField("dummy");
    } catch (NoSuchFieldException nsfe) {
        throw new RuntimeException(nsfe);
    }
    if (field1 == field2) {
        System.out.println("ERROR: fields shouldn't have reference equality");
    } else {
        System.out.println("fields are unique");
    }
    if (field1.hashCode() == field2.hashCode() && field1.equals(field2)) {
        System.out.println("fields are .equals");
    } else {
        System.out.println("ERROR: fields fail equality");
    }
    Method method1, method2;
    try {
        method1 = Main.class.getMethod("fancyMethod", ArrayList.class);
        method2 = Main.class.getMethod("fancyMethod", ArrayList.class);
    } catch (NoSuchMethodException nsme) {
        throw new RuntimeException(nsme);
    }
    if (method1 == method2) {
        System.out.println("ERROR: methods shouldn't have reference equality");
    } else {
        System.out.println("methods are unique");
    }
    if (method1.hashCode() == method2.hashCode() && method1.equals(method2)) {
        System.out.println("methods are .equals");
    } else {
        System.out.println("ERROR: methods fail equality");
    }
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    System.loadLibrary(args[0]);
    System.out.println("thread test starting");
    testThreadCapacity();
    testThreadDaemons();
    testSleepZero();
    testSetName();
    testThreadPriorities();
    System.out.println("thread test done");
}
#method_after
public static void main(String[] args) throws Exception {
    System.loadLibrary(args[0]);
    System.out.println("thread test starting");
    testThreadCapacity();
    testThreadDaemons();
    testSleepZero();
    testSetName();
    testThreadPriorities();
    testMainThreadGroup();
    testMainThreadAllStackTraces();
    System.out.println("thread test done");
}
#end_block

#method_before
private static void testThreadCapacity() throws Exception {
    TestCapacityThread[] threads = new TestCapacityThread[512];
    for (int i = 0; i < 512; i++) {
        threads[i] = new TestCapacityThread();
    }
    for (TestCapacityThread thread : threads) {
        thread.start();
    }
    for (TestCapacityThread thread : threads) {
        thread.join();
    }
    System.out.println("testThreadCapacity thread count: " + TestCapacityThread.mCount);
}
#method_after
private static void testThreadCapacity() throws Exception {
    TestCapacityThread[] threads = new TestCapacityThread[128];
    for (int i = 0; i < threads.length; i++) {
        threads[i] = new TestCapacityThread();
    }
    for (TestCapacityThread thread : threads) {
        thread.start();
    }
    for (TestCapacityThread thread : threads) {
        thread.join();
    }
    System.out.println("testThreadCapacity thread count: " + TestCapacityThread.mCount);
}
#end_block

#method_before
// / CHECK-START: void Main.main(java.lang.String[]) ssa_builder (after)
// / CHECK:           InvokeStaticOrDirect {{.*Main.<init>.*}}
// / CHECK:           InvokeInterface
// / CHECK-START: void Main.main(java.lang.String[]) inliner (before)
// / CHECK-NOT:       ClinitCheck
// / CHECK-START: void Main.main(java.lang.String[]) inliner (after)
// / CHECK-NOT:       InvokeStaticOrDirect {{.*Main.<init>.*}}
// / CHECK-NOT:       InvokeVirtual
// / CHECK-NOT:       InvokeInterface
// / CHECK-START: void Main.main(java.lang.String[]) inliner (after)
public static void main(String[] args) {
    Itf itf = new Main();
    itf.$inline$foo();
}
#method_after
// / CHECK-START: void Main.main(java.lang.String[]) builder (after)
// / CHECK:           InvokeStaticOrDirect {{.*Main.<init>.*}}
// / CHECK:           InvokeInterface
// / CHECK-START: void Main.main(java.lang.String[]) inliner (before)
// / CHECK-NOT:       ClinitCheck
// / CHECK-START: void Main.main(java.lang.String[]) inliner (after)
// / CHECK-NOT:       InvokeStaticOrDirect {{.*Main.<init>.*}}
// / CHECK-NOT:       InvokeVirtual
// / CHECK-NOT:       InvokeInterface
// / CHECK-START: void Main.main(java.lang.String[]) inliner (after)
public static void main(String[] args) {
    Itf itf = new Main();
    itf.$inline$foo();
}
#end_block

#method_before
public static void testConstructorReflection() throws Exception {
    Constructor<?> ctor;
    ctor = String.class.getConstructor(new Class[0]);
    show(ctor.newInstance((Object[]) null));
    ctor = String.class.getConstructor(char[].class, int.class, int.class);
    show(ctor.newInstance(new char[] { '\u2714', 'y', 'z', '!' }, 1, 2));
}
#method_after
public static void testConstructorReflection() throws Exception {
    Constructor<String> ctor = String.class.getConstructor();
    show(ctor.newInstance());
    ctor = String.class.getConstructor(char[].class, int.class, int.class);
    show(ctor.newInstance(new char[] { '\u2714', 'y', 'z', '!' }, 1, 2));
}
#end_block

#method_before
private static void testPackagePrivateConstructor() {
    try {
        Class<?> c = Class.forName("sub.PPClass");
        Constructor cons = c.getConstructor();
        cons.newInstance();
        throw new RuntimeException("Expected IllegalAccessException.");
    } catch (IllegalAccessException e) {
    // Expected.
    } catch (Exception e) {
        // Error.
        e.printStackTrace(System.out);
    }
}
#method_after
private static void testPackagePrivateConstructor() {
    try {
        Class<?> c = Class.forName("sub.PPClass");
        Constructor<?> cons = c.getConstructor();
        cons.newInstance();
        throw new RuntimeException("Expected IllegalAccessException.");
    } catch (IllegalAccessException e) {
    // Expected.
    } catch (Exception e) {
        // Error.
        e.printStackTrace(System.out);
    }
}
#end_block

#method_before
private static void testPackagePrivateAccessibleConstructor() {
    try {
        Class<?> c = Class.forName("sub.PPClass");
        Constructor cons = c.getConstructor();
        // ensure we prevent IllegalAccessException
        cons.setAccessible(true);
        cons.newInstance();
    } catch (Exception e) {
        // Error.
        e.printStackTrace(System.out);
    }
}
#method_after
private static void testPackagePrivateAccessibleConstructor() {
    try {
        Class<?> c = Class.forName("sub.PPClass");
        Constructor<?> cons = c.getConstructor();
        // ensure we prevent IllegalAccessException
        cons.setAccessible(true);
        cons.newInstance();
    } catch (Exception e) {
        // Error.
        e.printStackTrace(System.out);
    }
}
#end_block

#method_before
public static void main() {
    test56267();
    printClassAttrs(ClassAttrs.class);
    printClassAttrs(OtherClass.class);
    printClassAttrs(OtherPackageClass.class);
    /* local, not anonymous, not member */
    class InnerNamed {

        public void showMe() {
            printClassAttrs(this.getClass());
        }
    }
    InnerNamed inner = new InnerNamed();
    inner.showMe();
    ClassAttrs attrs = new ClassAttrs();
    /* anonymous, not local, not member */
    printClassAttrs((new OtherClass() {

        int i = 5;
    }).getClass());
    /* member, not anonymous, not local */
    printClassAttrs(MemberClass.class);
    /* fancy */
    printClassAttrs(FancyClass.class);
    try {
        Constructor cons;
        cons = MemberClass.class.getConstructor(new Class[] { MemberClass.class });
        System.out.println("constructor signature: " + getSignatureAttribute(cons));
        Method meth;
        meth = MemberClass.class.getMethod("foo", (Class[]) null);
        System.out.println("method signature: " + getSignatureAttribute(meth));
        Field field;
        field = MemberClass.class.getField("mWha");
        System.out.println("field signature: " + getSignatureAttribute(field));
    } catch (NoSuchMethodException nsme) {
        System.err.println("FAILED: " + nsme);
    } catch (NoSuchFieldException nsfe) {
        System.err.println("FAILED: " + nsfe);
    } catch (RuntimeException re) {
        System.err.println("FAILED: " + re);
        re.printStackTrace(System.out);
    }
    test_isAssignableFrom();
    test_isInstance();
}
#method_after
public static void main() {
    test56267();
    printClassAttrs(ClassAttrs.class);
    printClassAttrs(OtherClass.class);
    printClassAttrs(OtherPackageClass.class);
    /* local, not anonymous, not member */
    class InnerNamed {

        public void showMe() {
            printClassAttrs(this.getClass());
        }
    }
    InnerNamed inner = new InnerNamed();
    inner.showMe();
    ClassAttrs attrs = new ClassAttrs();
    /* anonymous, not local, not member */
    printClassAttrs((new OtherClass() {

        int i = 5;
    }).getClass());
    /* member, not anonymous, not local */
    printClassAttrs(MemberClass.class);
    /* fancy */
    printClassAttrs(FancyClass.class);
    try {
        Constructor<?> cons;
        cons = MemberClass.class.getConstructor(MemberClass.class);
        System.out.println("constructor signature: " + getSignatureAttribute(cons));
        Method meth;
        meth = MemberClass.class.getMethod("foo");
        System.out.println("method signature: " + getSignatureAttribute(meth));
        Field field;
        field = MemberClass.class.getField("mWha");
        System.out.println("field signature: " + getSignatureAttribute(field));
    } catch (NoSuchMethodException nsme) {
        System.out.println("FAILED: " + nsme);
    } catch (NoSuchFieldException nsfe) {
        System.out.println("FAILED: " + nsfe);
    } catch (RuntimeException re) {
        System.out.println("FAILED: " + re);
        re.printStackTrace(System.out);
    }
    test_isAssignableFrom();
    test_isInstance();
}
#end_block

#method_before
public static String getSignatureAttribute(Object obj) {
    Method method;
    try {
        Class c = Class.forName("libcore.reflect.AnnotationAccess");
        method = c.getDeclaredMethod("getSignature", java.lang.reflect.AnnotatedElement.class);
        method.setAccessible(true);
    } catch (Exception ex) {
        ex.printStackTrace(System.out);
        return "<unknown>";
    }
    try {
        return (String) method.invoke(null, obj);
    } catch (IllegalAccessException ex) {
        throw new RuntimeException(ex);
    } catch (InvocationTargetException ex) {
        throw new RuntimeException(ex);
    }
}
#method_after
public static String getSignatureAttribute(Object obj) {
    Method method;
    try {
        Class<?> c = obj.getClass();
        if (c == Method.class || c == Constructor.class) {
            c = Executable.class;
        }
        method = c.getDeclaredMethod("getSignatureAttribute");
        method.setAccessible(true);
    } catch (Exception ex) {
        ex.printStackTrace(System.out);
        return "<unknown>";
    }
    try {
        return (String) method.invoke(obj);
    } catch (IllegalAccessException ex) {
        throw new RuntimeException(ex);
    } catch (InvocationTargetException ex) {
        throw new RuntimeException(ex);
    }
}
#end_block

#method_before
public static void printClassAttrs(Class clazz) {
    Class clazz2;
    System.out.println("***** " + clazz + ":");
    System.out.println("  name: " + clazz.getName());
    System.out.println("  canonical: " + clazz.getCanonicalName());
    System.out.println("  simple: " + clazz.getSimpleName());
    System.out.println("  genericSignature: " + getSignatureAttribute(clazz));
    System.out.println("  super: " + clazz.getSuperclass());
    System.out.println("  genericSuperclass: " + clazz.getGenericSuperclass());
    System.out.println("  declaring: " + clazz.getDeclaringClass());
    System.out.println("  enclosing: " + clazz.getEnclosingClass());
    System.out.println("  enclosingCon: " + clazz.getEnclosingConstructor());
    System.out.println("  enclosingMeth: " + clazz.getEnclosingMethod());
    System.out.println("  modifiers: " + clazz.getModifiers());
    System.out.println("  package: " + clazz.getPackage());
    System.out.println("  declaredClasses: " + stringifyTypeArray(clazz.getDeclaredClasses()));
    System.out.println("  member classes: " + stringifyTypeArray(clazz.getClasses()));
    System.out.println("  isAnnotation: " + clazz.isAnnotation());
    System.out.println("  isAnonymous: " + clazz.isAnonymousClass());
    System.out.println("  isArray: " + clazz.isArray());
    System.out.println("  isEnum: " + clazz.isEnum());
    System.out.println("  isInterface: " + clazz.isInterface());
    System.out.println("  isLocalClass: " + clazz.isLocalClass());
    System.out.println("  isMemberClass: " + clazz.isMemberClass());
    System.out.println("  isPrimitive: " + clazz.isPrimitive());
    System.out.println("  isSynthetic: " + clazz.isSynthetic());
    System.out.println("  genericInterfaces: " + stringifyTypeArray(clazz.getGenericInterfaces()));
    TypeVariable<Class<?>>[] typeParameters = clazz.getTypeParameters();
    System.out.println("  typeParameters: " + stringifyTypeArray(typeParameters));
}
#method_after
public static <T> void printClassAttrs(Class<T> clazz) {
    System.out.println("***** " + clazz + ":");
    System.out.println("  name: " + clazz.getName());
    System.out.println("  canonical: " + clazz.getCanonicalName());
    System.out.println("  simple: " + clazz.getSimpleName());
    System.out.println("  genericSignature: " + getSignatureAttribute(clazz));
    System.out.println("  super: " + clazz.getSuperclass());
    System.out.println("  genericSuperclass: " + clazz.getGenericSuperclass());
    System.out.println("  declaring: " + clazz.getDeclaringClass());
    System.out.println("  enclosing: " + clazz.getEnclosingClass());
    System.out.println("  enclosingCon: " + clazz.getEnclosingConstructor());
    System.out.println("  enclosingMeth: " + clazz.getEnclosingMethod());
    System.out.println("  modifiers: " + clazz.getModifiers());
    System.out.println("  package: " + clazz.getPackage());
    System.out.println("  declaredClasses: " + stringifyTypeArray(clazz.getDeclaredClasses()));
    System.out.println("  member classes: " + stringifyTypeArray(clazz.getClasses()));
    System.out.println("  isAnnotation: " + clazz.isAnnotation());
    System.out.println("  isAnonymous: " + clazz.isAnonymousClass());
    System.out.println("  isArray: " + clazz.isArray());
    System.out.println("  isEnum: " + clazz.isEnum());
    System.out.println("  isInterface: " + clazz.isInterface());
    System.out.println("  isLocalClass: " + clazz.isLocalClass());
    System.out.println("  isMemberClass: " + clazz.isMemberClass());
    System.out.println("  isPrimitive: " + clazz.isPrimitive());
    System.out.println("  isSynthetic: " + clazz.isSynthetic());
    System.out.println("  genericInterfaces: " + stringifyTypeArray(clazz.getGenericInterfaces()));
    TypeVariable<Class<T>>[] typeParameters = clazz.getTypeParameters();
    System.out.println("  typeParameters: " + stringifyTypeArray(typeParameters));
}
#end_block

#method_before
public void uncaughtException(Thread t, Throwable e) {
    System.err.println("Uncaught exception " + mMyMessage + "!");
    e.printStackTrace(System.out);
}
#method_after
public void uncaughtException(Thread t, Throwable e) {
    System.out.println("Uncaught exception " + mMyMessage + "!");
    e.printStackTrace(System.out);
}
#end_block

#method_before
public static void main(String[] args) {
    Derived derived = new Derived();
    derived.declaredInBase();
    derived.notDeclaredInBase();
    derived.wasOverridden();
    derived.callOverrideWithPublic();
    derived.callOverrideProtectedWithPublic();
    derived.callOverridePublicWithProtected();
    derived.callOverridePublicWithPrivate();
    derived.callOverridePrivateWithPublic();
    derived.overridePrivateWithPublic();
    derived.callOverrideVirtualWithStatic();
    derived.overrideVirtualWithStatic();
    derived.callOverrideStaticWithVirtual();
    derived.overrideStaticWithVirtual();
    try {
        ((Base) derived).overrideVirtualWithStatic();
    } catch (NoSuchMethodError nsme) {
        /* NSME is subclass of ICCE, so check it explicitly */
        System.err.println("Got NSME - ovws");
        nsme.printStackTrace(System.out);
    } catch (IncompatibleClassChangeError icce) {
        System.out.println("Got expected exception - ovws");
    }
    try {
        ((Base) derived).overrideStaticWithVirtual();
    } catch (NoSuchMethodError nsme) {
        System.err.println("Got NSME - oswv");
        nsme.printStackTrace(System.out);
    } catch (IncompatibleClassChangeError icce) {
        System.out.println("Got expected exception - oswv");
    }
}
#method_after
public static void main(String[] args) {
    Derived derived = new Derived();
    derived.declaredInBase();
    derived.notDeclaredInBase();
    derived.wasOverridden();
    derived.callOverrideWithPublic();
    derived.callOverrideProtectedWithPublic();
    derived.callOverridePublicWithProtected();
    derived.callOverridePublicWithPrivate();
    derived.callOverridePrivateWithPublic();
    derived.overridePrivateWithPublic();
    derived.callOverrideVirtualWithStatic();
    derived.overrideVirtualWithStatic();
    derived.callOverrideStaticWithVirtual();
    derived.overrideStaticWithVirtual();
    try {
        ((Base) derived).overrideVirtualWithStatic();
    } catch (NoSuchMethodError nsme) {
        /* NSME is subclass of ICCE, so check it explicitly */
        System.out.println("Got NSME - ovws");
        nsme.printStackTrace(System.out);
    } catch (IncompatibleClassChangeError icce) {
        System.out.println("Got expected exception - ovws");
    }
    try {
        ((Base) derived).overrideStaticWithVirtual();
    } catch (NoSuchMethodError nsme) {
        System.out.println("Got NSME - oswv");
        nsme.printStackTrace(System.out);
    } catch (IncompatibleClassChangeError icce) {
        System.out.println("Got expected exception - oswv");
    }
}
#end_block

#method_before
static void testClassNewInstance() {
    // should succeed
    try {
        Class c = Class.forName("LocalClass");
        Object obj = c.newInstance();
        System.out.println("LocalClass succeeded");
    } catch (Exception ex) {
        System.err.println("LocalClass failed");
        ex.printStackTrace(System.out);
    }
    // should fail
    try {
        Class c = Class.forName("otherpackage.PackageAccess");
        Object obj = c.newInstance();
        System.err.println("ERROR: PackageAccess succeeded unexpectedly");
    } catch (IllegalAccessException iae) {
        System.out.println("Got expected PackageAccess complaint");
    } catch (Exception ex) {
        System.err.println("Got unexpected PackageAccess failure");
        ex.printStackTrace(System.out);
    }
    LocalClass3.main();
    try {
        MaybeAbstract ma = new MaybeAbstract();
        System.err.println("ERROR: MaybeAbstract succeeded unexpectedly");
    } catch (InstantiationError ie) {
        System.out.println("Got expected InstantationError");
    } catch (Exception ex) {
        System.err.println("Got unexpected MaybeAbstract failure");
    }
}
#method_after
static void testClassNewInstance() {
    // should succeed
    try {
        Class<?> c = Class.forName("LocalClass");
        Object obj = c.newInstance();
        System.out.println("LocalClass succeeded");
    } catch (Exception ex) {
        System.out.println("LocalClass failed");
        ex.printStackTrace(System.out);
    }
    // should fail
    try {
        Class<?> c = Class.forName("otherpackage.PackageAccess");
        Object obj = c.newInstance();
        System.out.println("ERROR: PackageAccess succeeded unexpectedly");
    } catch (IllegalAccessException iae) {
        System.out.println("Got expected PackageAccess complaint");
    } catch (Exception ex) {
        System.out.println("Got unexpected PackageAccess failure");
        ex.printStackTrace(System.out);
    }
    LocalClass3.main();
    try {
        MaybeAbstract ma = new MaybeAbstract();
        System.out.println("ERROR: MaybeAbstract succeeded unexpectedly");
    } catch (InstantiationError ie) {
        System.out.println("Got expected InstantationError");
    } catch (Exception ex) {
        System.out.println("Got unexpected MaybeAbstract failure");
    }
}
#end_block

#method_before
static void testConstructorNewInstance() {
    // should fail -- getConstructor only returns public constructors
    try {
        Class c = Class.forName("LocalClass");
        Constructor cons = c.getConstructor(new Class[0]);
        System.err.println("Cons LocalClass succeeded unexpectedly");
    } catch (NoSuchMethodException nsme) {
        System.out.println("Cons LocalClass failed as expected");
    } catch (Exception ex) {
        System.err.println("Cons LocalClass failed strangely");
        ex.printStackTrace(System.out);
    }
    // should succeed
    try {
        Class c = Class.forName("LocalClass2");
        Constructor cons = c.getConstructor((Class[]) null);
        Object obj = cons.newInstance();
        System.out.println("Cons LocalClass2 succeeded");
    } catch (Exception ex) {
        System.err.println("Cons LocalClass2 failed");
        ex.printStackTrace(System.out);
    }
    // should succeed
    try {
        Class c = Class.forName("Main$InnerClass");
        Constructor cons = c.getDeclaredConstructor(new Class<?>[] { Main.class });
        Object obj = cons.newInstance(new Main());
        System.out.println("Cons InnerClass succeeded");
    } catch (Exception ex) {
        System.err.println("Cons InnerClass failed");
        ex.printStackTrace(System.out);
    }
    // should succeed
    try {
        Class c = Class.forName("Main$StaticInnerClass");
        Constructor cons = c.getDeclaredConstructor((Class[]) null);
        Object obj = cons.newInstance();
        System.out.println("Cons StaticInnerClass succeeded");
    } catch (Exception ex) {
        System.err.println("Cons StaticInnerClass failed");
        ex.printStackTrace(System.out);
    }
    // should fail
    try {
        Class c = Class.forName("otherpackage.PackageAccess");
        Constructor cons = c.getConstructor(new Class[0]);
        System.err.println("ERROR: Cons PackageAccess succeeded unexpectedly");
    } catch (NoSuchMethodException nsme) {
        // constructor isn't public
        System.out.println("Cons got expected PackageAccess complaint");
    } catch (Exception ex) {
        System.err.println("Cons got unexpected PackageAccess failure");
        ex.printStackTrace(System.out);
    }
    // should fail
    try {
        Class c = Class.forName("MaybeAbstract");
        Constructor cons = c.getConstructor(new Class[0]);
        Object obj = cons.newInstance();
        System.err.println("ERROR: Cons MaybeAbstract succeeded unexpectedly");
    } catch (InstantiationException ie) {
        // note InstantiationException vs. InstantiationError
        System.out.println("Cons got expected InstantationException");
    } catch (Exception ex) {
        System.err.println("Cons got unexpected MaybeAbstract failure");
        ex.printStackTrace(System.out);
    }
    // should fail
    try {
        Class c = Class.forName("otherpackage.PackageAccess2");
        Constructor cons = c.getConstructor((Class[]) null);
        if (!FULL_ACCESS_CHECKS) {
            throw new IllegalAccessException();
        }
        Object obj = cons.newInstance();
        System.err.println("ERROR: Cons PackageAccess2 succeeded unexpectedly");
    } catch (IllegalAccessException iae) {
        // constructor is public, but class has package scope
        System.out.println("Cons got expected PackageAccess2 complaint");
    } catch (Exception ex) {
        System.err.println("Cons got unexpected PackageAccess2 failure");
        ex.printStackTrace(System.out);
    }
    // should succeed
    try {
        otherpackage.ConstructorAccess.newConstructorInstance();
        System.out.println("Cons ConstructorAccess succeeded");
    } catch (Exception ex) {
        System.err.println("Cons ConstructorAccess failed");
        ex.printStackTrace();
    }
}
#method_after
static void testConstructorNewInstance() {
    // should fail -- getConstructor only returns public constructors
    try {
        Class<?> c = Class.forName("LocalClass");
        Constructor<?> cons = c.getConstructor();
        System.out.println("Cons LocalClass succeeded unexpectedly");
    } catch (NoSuchMethodException nsme) {
        System.out.println("Cons LocalClass failed as expected");
    } catch (Exception ex) {
        System.out.println("Cons LocalClass failed strangely");
        ex.printStackTrace(System.out);
    }
    // should succeed
    try {
        Class<?> c = Class.forName("LocalClass2");
        Constructor<?> cons = c.getConstructor();
        Object obj = cons.newInstance();
        System.out.println("Cons LocalClass2 succeeded");
    } catch (Exception ex) {
        System.out.println("Cons LocalClass2 failed");
        ex.printStackTrace(System.out);
    }
    // should succeed
    try {
        Class<?> c = Class.forName("Main$InnerClass");
        Constructor<?> cons = c.getDeclaredConstructor(Main.class);
        Object obj = cons.newInstance(new Main());
        System.out.println("Cons InnerClass succeeded");
    } catch (Exception ex) {
        System.out.println("Cons InnerClass failed");
        ex.printStackTrace(System.out);
    }
    // should succeed
    try {
        Class<?> c = Class.forName("Main$StaticInnerClass");
        Constructor<?> cons = c.getDeclaredConstructor();
        Object obj = cons.newInstance();
        System.out.println("Cons StaticInnerClass succeeded");
    } catch (Exception ex) {
        System.out.println("Cons StaticInnerClass failed");
        ex.printStackTrace(System.out);
    }
    // should fail
    try {
        Class<?> c = Class.forName("otherpackage.PackageAccess");
        Constructor<?> cons = c.getConstructor();
        System.out.println("ERROR: Cons PackageAccess succeeded unexpectedly");
    } catch (NoSuchMethodException nsme) {
        // constructor isn't public
        System.out.println("Cons got expected PackageAccess complaint");
    } catch (Exception ex) {
        System.out.println("Cons got unexpected PackageAccess failure");
        ex.printStackTrace(System.out);
    }
    // should fail
    try {
        Class<?> c = Class.forName("MaybeAbstract");
        Constructor<?> cons = c.getConstructor();
        Object obj = cons.newInstance();
        System.out.println("ERROR: Cons MaybeAbstract succeeded unexpectedly");
    } catch (InstantiationException ie) {
        // note InstantiationException vs. InstantiationError
        System.out.println("Cons got expected InstantationException");
    } catch (Exception ex) {
        System.out.println("Cons got unexpected MaybeAbstract failure");
        ex.printStackTrace(System.out);
    }
    // should fail
    try {
        Class<?> c = Class.forName("otherpackage.PackageAccess2");
        Constructor<?> cons = c.getConstructor();
        if (!FULL_ACCESS_CHECKS) {
            throw new IllegalAccessException();
        }
        Object obj = cons.newInstance();
        System.out.println("ERROR: Cons PackageAccess2 succeeded unexpectedly");
    } catch (IllegalAccessException iae) {
        // constructor is public, but class has package scope
        System.out.println("Cons got expected PackageAccess2 complaint");
    } catch (Exception ex) {
        System.out.println("Cons got unexpected PackageAccess2 failure");
        ex.printStackTrace(System.out);
    }
    // should succeed
    try {
        otherpackage.ConstructorAccess.newConstructorInstance();
        System.out.println("Cons ConstructorAccess succeeded");
    } catch (Exception ex) {
        System.out.println("Cons ConstructorAccess failed");
        ex.printStackTrace(System.out);
    }
}
#end_block

#method_before
public static void main() {
    try {
        CC.newInstance();
        System.out.println("LocalClass3 succeeded");
    } catch (Exception ex) {
        System.err.println("Got unexpected LocalClass3 failure");
        ex.printStackTrace(System.out);
    }
}
#method_after
public static void main() {
    try {
        CC.newInstance();
        System.out.println("LocalClass3 succeeded");
    } catch (Exception ex) {
        System.out.println("Got unexpected LocalClass3 failure");
        ex.printStackTrace(System.out);
    }
}
#end_block

#method_before
static Object newInstance() {
    try {
        Class c = CC.class;
        return c.newInstance();
    } catch (Exception ex) {
        ex.printStackTrace(System.out);
        return null;
    }
}
#method_after
static Object newInstance() {
    try {
        Class<?> c = CC.class;
        return c.newInstance();
    } catch (Exception ex) {
        ex.printStackTrace(System.out);
        return null;
    }
}
#end_block

#method_before
private void run() {
    System.out.println(new A().i);
    // Now run the class from the -ex file.
    FancyLoader loader = new FancyLoader(getClass().getClassLoader());
    try {
        Class testEx = loader.loadClass("TestEx");
        Method test = testEx.getDeclaredMethod("test");
        test.invoke(null);
    } catch (Exception exc) {
        exc.printStackTrace(System.out);
    }
}
#method_after
private void run() {
    System.out.println(new A().i);
    // Now run the class from the -ex file.
    String dexPath = System.getenv("DEX_LOCATION") + "/138-duplicate-classes-check-ex.jar";
    String optimizedDirectory = System.getenv("DEX_LOCATION");
    String librarySearchPath = null;
    DexClassLoader loader = new DexClassLoader(dexPath, optimizedDirectory, librarySearchPath, getClass().getClassLoader());
    try {
        Class<?> testEx = loader.loadClass("TestEx");
        Method test = testEx.getDeclaredMethod("test");
        test.invoke(null);
    } catch (Exception exc) {
        exc.printStackTrace(System.out);
    }
}
#end_block

#method_before
private Class<?> findDexClass(String name) throws TestFailed, InvocationTargetException {
    try {
        /*
                 * Find the DexFile class, and construct a DexFile object
                 * through reflection, then call loadCLass on it.
                 */
        Class mDexClass = ClassLoader.getSystemClassLoader().loadClass("dalvik.system.DexFile");
        Constructor ctor = mDexClass.getConstructor(new Class[] { String.class });
        Object mDexFile = ctor.newInstance(DEX_FILE);
        Method meth = mDexClass.getMethod("loadClass", new Class[] { String.class, ClassLoader.class });
        /*
                 * Invoking loadClass on CLASS_NAME is expected to
                 * throw an InvocationTargetException. Anything else
                 * is an error we can't recover from.
                 */
        meth.invoke(mDexFile, name, this);
    } catch (NoSuchMethodException nsme) {
        throw new TestFailed(nsme);
    } catch (InstantiationException ie) {
        throw new TestFailed(ie);
    } catch (IllegalAccessException iae) {
        throw new TestFailed(iae);
    } catch (ClassNotFoundException cnfe) {
        throw new TestFailed(cnfe);
    }
    return null;
}
#method_after
private Class<?> findDexClass(String name) throws TestFailed, InvocationTargetException {
    try {
        /*
                 * Find the DexFile class, and construct a DexFile object
                 * through reflection, then call loadCLass on it.
                 */
        Class<?> mDexClass = ClassLoader.getSystemClassLoader().loadClass("dalvik.system.DexFile");
        Constructor<?> ctor = mDexClass.getConstructor(String.class);
        Object mDexFile = ctor.newInstance(DEX_FILE);
        Method meth = mDexClass.getMethod("loadClass", String.class, ClassLoader.class);
        /*
                 * Invoking loadClass on CLASS_NAME is expected to
                 * throw an InvocationTargetException. Anything else
                 * is an error we can't recover from.
                 */
        meth.invoke(mDexFile, name, this);
    } catch (NoSuchMethodException nsme) {
        throw new TestFailed(nsme);
    } catch (InstantiationException ie) {
        throw new TestFailed(ie);
    } catch (IllegalAccessException iae) {
        throw new TestFailed(iae);
    } catch (ClassNotFoundException cnfe) {
        throw new TestFailed(cnfe);
    }
    return null;
}
#end_block

#method_before
static void testFailLoadAndGc() throws TestFailed {
    try {
        BrokenDexLoader loader;
        loader = new BrokenDexLoader(ClassLoader.getSystemClassLoader());
        loader.findBrokenClass();
        System.err.println("ERROR: Inaccessible was accessible");
    } catch (InvocationTargetException ite) {
        Throwable cause = ite.getCause();
        if (cause instanceof NullPointerException) {
            System.err.println("Got expected ITE/NPE");
        } else {
            System.err.println("Got unexpected ITE");
            ite.printStackTrace(System.out);
        }
    }
}
#method_after
static void testFailLoadAndGc() throws TestFailed {
    try {
        BrokenDexLoader loader;
        loader = new BrokenDexLoader(ClassLoader.getSystemClassLoader());
        loader.findBrokenClass();
        System.out.println("ERROR: Inaccessible was accessible");
    } catch (InvocationTargetException ite) {
        Throwable cause = ite.getCause();
        if (cause instanceof NullPointerException) {
            System.out.println("Got expected ITE/NPE");
        } else {
            System.out.println("Got unexpected ITE");
            ite.printStackTrace(System.out);
        }
    }
}
#end_block

#method_before
public Integer call() {
    Integer result;
    try {
        Class<?> c = Class.forName("Test");
        Method m = c.getMethod("synchronizedHashCode", new Class[] { Object.class });
        result = (Integer) m.invoke(null, m_obj);
    } catch (Exception e) {
        System.err.println("Hash code query exception");
        e.printStackTrace(System.out);
        result = -1;
    }
    return result;
}
#method_after
public Integer call() {
    Integer result;
    try {
        Class<?> c = Class.forName("Test");
        Method m = c.getMethod("synchronizedHashCode", Object.class);
        result = (Integer) m.invoke(null, m_obj);
    } catch (Exception e) {
        System.out.println("Hash code query exception");
        e.printStackTrace(System.out);
        result = -1;
    }
    return result;
}
#end_block

#method_before
public static void main(String[] args) throws Exception {
    Object obj = new Object();
    int numThreads = 10;
    ExecutorService pool = Executors.newFixedThreadPool(numThreads);
    List<HashCodeQuery> queries = new ArrayList<HashCodeQuery>(numThreads);
    for (int i = 0; i < numThreads; ++i) {
        queries.add(new HashCodeQuery(obj));
    }
    try {
        List<Future<Integer>> results = pool.invokeAll(queries, 5, TimeUnit.SECONDS);
        int hash = obj.hashCode();
        for (int i = 0; i < numThreads; ++i) {
            int result = results.get(i).get();
            if (hash != result) {
                throw new Error("Query #" + i + " wrong. Expected " + hash + ", got " + result);
            }
        }
        pool.shutdown();
    } catch (CancellationException ex) {
        System.err.println("Job timeout");
        System.exit(1);
    }
}
#method_after
public static void main(String[] args) throws Exception {
    Object obj = new Object();
    int numThreads = 10;
    ExecutorService pool = Executors.newFixedThreadPool(numThreads);
    List<HashCodeQuery> queries = new ArrayList<HashCodeQuery>(numThreads);
    for (int i = 0; i < numThreads; ++i) {
        queries.add(new HashCodeQuery(obj));
    }
    try {
        List<Future<Integer>> results = pool.invokeAll(queries);
        int hash = obj.hashCode();
        for (int i = 0; i < numThreads; ++i) {
            int result = results.get(i).get();
            if (hash != result) {
                throw new Error("Query #" + i + " wrong. Expected " + hash + ", got " + result);
            }
        }
        pool.shutdown();
    } catch (CancellationException ex) {
        System.out.println("Job timeout");
        System.exit(1);
    }
}
#end_block

#method_before
protected void onPause() {
    if (!mClicked) {
        // RESULT_CANCELED
        finish();
    }
    super.onPause();
}
#method_after
@Override
protected void onPause() {
    if (!mClicked) {
        // RESULT_CANCELED
        finish();
    }
    super.onPause();
}
#end_block

#method_before
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // By default, set the result to cancelled
    setResult(RESULT_CANCELED);
    Intent intent = getIntent();
    CharSequence label = "";
    if (intent != null) {
        try {
            mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1);
            mProfile = intent.getParcelableExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER_PROFILE);
            if (mProfile == null) {
                mProfile = android.os.Process.myUserHandle();
            }
            mComponentName = intent.getParcelableExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER);
            mCallingPackage = getCallingPackage();
            PackageManager pm = getPackageManager();
            ApplicationInfo ai = pm.getApplicationInfo(mCallingPackage, 0);
            label = pm.getApplicationLabel(ai);
        } catch (Exception e) {
            mAppWidgetId = -1;
            mComponentName = null;
            mCallingPackage = null;
            Log.v("BIND_APPWIDGET", "Error getting parameters");
            finish();
            return;
        }
    }
    AlertController.AlertParams ap = mAlertParams;
    ap.mTitle = getString(R.string.allow_bind_app_widget_activity_allow_bind_title);
    ap.mMessage = getString(R.string.allow_bind_app_widget_activity_allow_bind, label);
    ap.mPositiveButtonText = getString(R.string.create);
    ap.mNegativeButtonText = getString(android.R.string.cancel);
    ap.mPositiveButtonListener = this;
    ap.mNegativeButtonListener = this;
    LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    ap.mView = inflater.inflate(com.android.internal.R.layout.always_use_checkbox, null);
    mAlwaysUse = (CheckBox) ap.mView.findViewById(com.android.internal.R.id.alwaysUse);
    mAlwaysUse.setText(getString(R.string.allow_bind_app_widget_activity_always_allow_bind, label));
    mAlwaysUse.setPadding(mAlwaysUse.getPaddingLeft(), mAlwaysUse.getPaddingTop(), mAlwaysUse.getPaddingRight(), (int) (mAlwaysUse.getPaddingBottom() + getResources().getDimension(R.dimen.bind_app_widget_dialog_checkbox_bottom_padding)));
    mAppWidgetManager = AppWidgetManager.getInstance(this);
    mAlwaysUse.setChecked(mAppWidgetManager.hasBindAppWidgetPermission(mCallingPackage, mProfile.getIdentifier()));
    setupAlert();
}
#method_after
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // By default, set the result to cancelled
    setResult(RESULT_CANCELED);
    Intent intent = getIntent();
    CharSequence label = "";
    if (intent != null) {
        try {
            mAppWidgetId = intent.getIntExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, -1);
            mProfile = intent.getParcelableExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER_PROFILE);
            if (mProfile == null) {
                mProfile = android.os.Process.myUserHandle();
            }
            mComponentName = intent.getParcelableExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER);
            mCallingPackage = getCallingPackage();
            PackageManager pm = getPackageManager();
            ApplicationInfo ai = pm.getApplicationInfo(mCallingPackage, 0);
            label = pm.getApplicationLabel(ai);
        } catch (Exception e) {
            mAppWidgetId = -1;
            mComponentName = null;
            mCallingPackage = null;
            Log.v("BIND_APPWIDGET", "Error getting parameters");
            finish();
            return;
        }
    }
    AlertController.AlertParams ap = mAlertParams;
    ap.mTitle = getString(R.string.allow_bind_app_widget_activity_allow_bind_title);
    ap.mMessage = getString(R.string.allow_bind_app_widget_activity_allow_bind, label);
    ap.mPositiveButtonText = getString(R.string.create);
    ap.mNegativeButtonText = getString(android.R.string.cancel);
    ap.mPositiveButtonListener = this;
    ap.mNegativeButtonListener = this;
    LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    ap.mView = inflater.inflate(com.android.internal.R.layout.always_use_checkbox, null);
    mAlwaysUse = (CheckBox) ap.mView.findViewById(com.android.internal.R.id.alwaysUse);
    mAlwaysUse.setText(getString(R.string.allow_bind_app_widget_activity_always_allow_bind, label));
    mAlwaysUse.setPadding(mAlwaysUse.getPaddingLeft(), mAlwaysUse.getPaddingTop(), mAlwaysUse.getPaddingRight(), (int) (mAlwaysUse.getPaddingBottom() + getResources().getDimension(R.dimen.bind_app_widget_dialog_checkbox_bottom_padding)));
    mAppWidgetManager = AppWidgetManager.getInstance(this);
    mAlwaysUse.setChecked(mAppWidgetManager.hasBindAppWidgetPermission(mCallingPackage, mProfile.getIdentifier()));
    setupAlert();
}
#end_block

#method_before
// BEGIN Android-changed: No lookup chache support
// private static native URL[] getLookupCacheURLs(ClassLoader loader);
// private static native int[] getLookupCacheForClassLoader(ClassLoader loader,
// String name);
// private static native boolean knownToNotExist0(ClassLoader loader,
// String className);
private URL[] getLookupCacheURLs(ClassLoader loader) {
    return null;
}
#method_after
// BEGIN Android-changed: No lookup chache support
/*
    private static native URL[] getLookupCacheURLs(ClassLoader loader);
    private static native int[] getLookupCacheForClassLoader(ClassLoader loader,
                                                             String name);
    private static native boolean knownToNotExist0(ClassLoader loader,
                                                   String className);
    */
private URL[] getLookupCacheURLs(ClassLoader loader) {
    return null;
}
#end_block

#method_before
private void parseExtensionsDependencies() throws IOException {
// Android-changed: Not used
// ExtensionDependency.checkExtensionsDependencies(jar);
}
#method_after
private void parseExtensionsDependencies() throws IOException {
// Android-changed: checkExtensionsDependencies(jar) is not supported on Android.
// ExtensionDependency.checkExtensionsDependencies(jar);
}
#end_block

#method_before
// Initialize any miscellenous operating system settings that need to be
// set for the class libraries.
public static void initializeOSEnvironment() {
// Android-changed: not used
// if (!booted) {
// OSEnvironment.initialize();
// }
}
#method_after
// Initialize any miscellenous operating system settings that need to be
// set for the class libraries.
public static void initializeOSEnvironment() {
// Android-removed: OSEnvironment.initialize() not supported
// if (!booted) {
// OSEnvironment.initialize();
// }
}
#end_block

#method_before
public static synchronized SocketFactory getDefault() {
    // Android-changed: Check Security.getVersion() on each update.
    if (theFactory != null && lastVersion == Security.getVersion()) {
        return theFactory;
    }
    lastVersion = Security.getVersion();
    SSLSocketFactory previousDefaultSocketFactory = theFactory;
    theFactory = null;
    String clsName = getSecurityProperty("ssl.SocketFactory.provider");
    if (clsName != null) {
        // errors. Avoid creating a new object if the class name is the same as before.
        if (previousDefaultSocketFactory != null && clsName.equals(previousDefaultSocketFactory.getClass().getName())) {
            theFactory = previousDefaultSocketFactory;
            return theFactory;
        }
        log("setting up default SSLSocketFactory");
        try {
            Class<?> cls = null;
            try {
                cls = Class.forName(clsName);
            } catch (ClassNotFoundException e) {
                // Android-changed: Try the contextClassLoader first.
                ClassLoader cl = Thread.currentThread().getContextClassLoader();
                if (cl == null) {
                    cl = ClassLoader.getSystemClassLoader();
                }
                if (cl != null) {
                    // Android-changed: Use Class.forName() so the class gets initialized.
                    cls = Class.forName(clsName, true, cl);
                }
            }
            log("class " + clsName + " is loaded");
            SSLSocketFactory fac = (SSLSocketFactory) cls.newInstance();
            log("instantiated an instance of class " + clsName);
            theFactory = fac;
            return fac;
        } catch (Exception e) {
            log("SSLSocketFactory instantiation failed: " + e.toString());
        // Android-changed: Fallback to the default SSLContext on exception.
        }
    }
    try {
        // Android-changed: Allow for {@code null} SSLContext.getDefault.
        SSLContext context = SSLContext.getDefault();
        if (context != null) {
            theFactory = context.getSocketFactory();
        } else {
            theFactory = new DefaultSSLSocketFactory(new IllegalStateException("No factory found."));
        }
        return theFactory;
    } catch (NoSuchAlgorithmException e) {
        return new DefaultSSLSocketFactory(e);
    }
}
#method_after
public static synchronized SocketFactory getDefault() {
    // Android-changed: Check Security.getVersion() on each update.
    if (defaultSocketFactory != null && lastVersion == Security.getVersion()) {
        return defaultSocketFactory;
    }
    lastVersion = Security.getVersion();
    SSLSocketFactory previousDefaultSocketFactory = defaultSocketFactory;
    defaultSocketFactory = null;
    String clsName = getSecurityProperty("ssl.SocketFactory.provider");
    if (clsName != null) {
        // errors. Avoid creating a new object if the class name is the same as before.
        if (previousDefaultSocketFactory != null && clsName.equals(previousDefaultSocketFactory.getClass().getName())) {
            defaultSocketFactory = previousDefaultSocketFactory;
            return defaultSocketFactory;
        }
        log("setting up default SSLSocketFactory");
        try {
            Class<?> cls = null;
            try {
                cls = Class.forName(clsName);
            } catch (ClassNotFoundException e) {
                // Android-changed: Try the contextClassLoader first.
                ClassLoader cl = Thread.currentThread().getContextClassLoader();
                if (cl == null) {
                    cl = ClassLoader.getSystemClassLoader();
                }
                if (cl != null) {
                    // Android-changed: Use Class.forName() so the class gets initialized.
                    cls = Class.forName(clsName, true, cl);
                }
            }
            log("class " + clsName + " is loaded");
            SSLSocketFactory fac = (SSLSocketFactory) cls.newInstance();
            log("instantiated an instance of class " + clsName);
            defaultSocketFactory = fac;
            return fac;
        } catch (Exception e) {
            log("SSLSocketFactory instantiation failed: " + e.toString());
        // Android-changed: Fallback to the default SSLContext on exception.
        }
    }
    try {
        // Android-changed: Allow for {@code null} SSLContext.getDefault.
        SSLContext context = SSLContext.getDefault();
        if (context != null) {
            defaultSocketFactory = context.getSocketFactory();
        } else {
            defaultSocketFactory = new DefaultSSLSocketFactory(new IllegalStateException("No factory found."));
        }
        return defaultSocketFactory;
    } catch (NoSuchAlgorithmException e) {
        return new DefaultSSLSocketFactory(e);
    }
}
#end_block

#method_before
public static synchronized ServerSocketFactory getDefault() {
    // Android-changed: Check Security.getVersion() on each update.
    if (theFactory != null && lastVersion == Security.getVersion()) {
        return theFactory;
    }
    lastVersion = Security.getVersion();
    SSLServerSocketFactory previousDefaultServerSocketFactory = theFactory;
    theFactory = null;
    String clsName = SSLSocketFactory.getSecurityProperty("ssl.ServerSocketFactory.provider");
    if (clsName != null) {
        // errors. Avoid creating a new object if the class name is the same as before.
        if (previousDefaultServerSocketFactory != null && clsName.equals(previousDefaultServerSocketFactory.getClass().getName())) {
            theFactory = previousDefaultServerSocketFactory;
            return theFactory;
        }
        log("setting up default SSLServerSocketFactory");
        try {
            Class<?> cls = null;
            try {
                cls = Class.forName(clsName);
            } catch (ClassNotFoundException e) {
                // Android-changed; Try the contextClassLoader first.
                ClassLoader cl = Thread.currentThread().getContextClassLoader();
                if (cl == null) {
                    cl = ClassLoader.getSystemClassLoader();
                }
                if (cl != null) {
                    // Android-changed: Use Class.forName() so the class gets initialized.
                    cls = Class.forName(clsName, true, cl);
                }
            }
            log("class " + clsName + " is loaded");
            SSLServerSocketFactory fac = (SSLServerSocketFactory) cls.newInstance();
            log("instantiated an instance of class " + clsName);
            theFactory = fac;
            return fac;
        } catch (Exception e) {
            log("SSLServerSocketFactory instantiation failed: " + e);
        // Android-changed: Fallback to the default SSLContext on exception.
        }
    }
    try {
        // Android-changed: Allow for {@code null} SSLContext.getDefault.
        SSLContext context = SSLContext.getDefault();
        if (context != null) {
            theFactory = context.getServerSocketFactory();
        } else {
            theFactory = new DefaultSSLServerSocketFactory(new IllegalStateException("No factory found."));
        }
        return theFactory;
    } catch (NoSuchAlgorithmException e) {
        return new DefaultSSLServerSocketFactory(e);
    }
}
#method_after
public static synchronized ServerSocketFactory getDefault() {
    // Android-changed: Check Security.getVersion() on each update.
    if (defaultServerSocketFactory != null && lastVersion == Security.getVersion()) {
        return defaultServerSocketFactory;
    }
    lastVersion = Security.getVersion();
    SSLServerSocketFactory previousDefaultServerSocketFactory = defaultServerSocketFactory;
    defaultServerSocketFactory = null;
    String clsName = SSLSocketFactory.getSecurityProperty("ssl.ServerSocketFactory.provider");
    if (clsName != null) {
        // errors. Avoid creating a new object if the class name is the same as before.
        if (previousDefaultServerSocketFactory != null && clsName.equals(previousDefaultServerSocketFactory.getClass().getName())) {
            defaultServerSocketFactory = previousDefaultServerSocketFactory;
            return defaultServerSocketFactory;
        }
        log("setting up default SSLServerSocketFactory");
        try {
            Class<?> cls = null;
            try {
                cls = Class.forName(clsName);
            } catch (ClassNotFoundException e) {
                // Android-changed; Try the contextClassLoader first.
                ClassLoader cl = Thread.currentThread().getContextClassLoader();
                if (cl == null) {
                    cl = ClassLoader.getSystemClassLoader();
                }
                if (cl != null) {
                    // Android-changed: Use Class.forName() so the class gets initialized.
                    cls = Class.forName(clsName, true, cl);
                }
            }
            log("class " + clsName + " is loaded");
            SSLServerSocketFactory fac = (SSLServerSocketFactory) cls.newInstance();
            log("instantiated an instance of class " + clsName);
            defaultServerSocketFactory = fac;
            return fac;
        } catch (Exception e) {
            log("SSLServerSocketFactory instantiation failed: " + e);
        // Android-changed: Fallback to the default SSLContext on exception.
        }
    }
    try {
        // Android-changed: Allow for {@code null} SSLContext.getDefault.
        SSLContext context = SSLContext.getDefault();
        if (context != null) {
            defaultServerSocketFactory = context.getServerSocketFactory();
        } else {
            defaultServerSocketFactory = new DefaultSSLServerSocketFactory(new IllegalStateException("No factory found."));
        }
        return defaultServerSocketFactory;
    } catch (NoSuchAlgorithmException e) {
        return new DefaultSSLServerSocketFactory(e);
    }
}
#end_block

#method_before
private void handleWifiApAction(Intent intent) {
    final int curState = intent.getIntExtra(EXTRA_WIFI_AP_STATE, WIFI_AP_STATE_DISABLED);
    final String ifname = intent.getStringExtra(EXTRA_WIFI_AP_STATE);
    final int ipmode = intent.getIntExtra(EXTRA_WIFI_AP_MODE, Integer.MIN_VALUE);
    synchronized (Tethering.this.mPublicSync) {
        switch(curState) {
            case WifiManager.WIFI_AP_STATE_ENABLING:
                // We can see this state on the way to both enabled and failure states.
                break;
            case WifiManager.WIFI_AP_STATE_ENABLED:
                if (!TextUtils.isEmpty(ifname)) {
                    if (ipmode == IFACE_IP_MODE_TETHERED) {
                        changeInterfaceState(ifname, IControlsTethering.STATE_TETHERED);
                        break;
                    } else if (ipmode == IFACE_IP_MODE_LOCAL_ONLY) {
                        changeInterfaceState(ifname, IControlsTethering.STATE_LOCAL_ONLY);
                        break;
                    } else {
                        mLog.e("Unknown IP mode from WiFi: " + ipmode);
                    // Fall-through to legacy "guessing" behaviour.
                    }
                }
                // When the AP comes up and we've been requested to tether it, do so.
                // Otherwise, assume it's a local-only hotspot request.
                final int state = mWifiTetherRequested ? IControlsTethering.STATE_TETHERED : IControlsTethering.STATE_LOCAL_ONLY;
                tetherMatchingInterfaces(state, ConnectivityManager.TETHERING_WIFI);
                break;
            case WifiManager.WIFI_AP_STATE_DISABLED:
            case WifiManager.WIFI_AP_STATE_DISABLING:
            case WifiManager.WIFI_AP_STATE_FAILED:
            default:
                if (DBG) {
                    Log.d(TAG, "Canceling WiFi tethering request - AP_STATE=" + curState);
                }
                // themselves down.
                for (int i = 0; i < mTetherStates.size(); i++) {
                    TetherInterfaceStateMachine tism = mTetherStates.valueAt(i).stateMachine;
                    if (tism.interfaceType() == ConnectivityManager.TETHERING_WIFI) {
                        tism.sendMessage(TetherInterfaceStateMachine.CMD_TETHER_UNREQUESTED);
                        // There should be at most one of these.
                        break;
                    }
                }
                // Regardless of whether we requested this transition, the AP has gone
                // down.  Don't try to tether again unless we're requested to do so.
                mWifiTetherRequested = false;
                break;
        }
    }
}
#method_after
private void handleWifiApAction(Intent intent) {
    final int curState = intent.getIntExtra(EXTRA_WIFI_AP_STATE, WIFI_AP_STATE_DISABLED);
    final String ifname = intent.getStringExtra(EXTRA_WIFI_AP_INTERFACE_NAME);
    final int ipmode = intent.getIntExtra(EXTRA_WIFI_AP_MODE, IFACE_IP_MODE_UNSPECIFIED);
    synchronized (Tethering.this.mPublicSync) {
        switch(curState) {
            case WifiManager.WIFI_AP_STATE_ENABLING:
                // We can see this state on the way to both enabled and failure states.
                break;
            case WifiManager.WIFI_AP_STATE_ENABLED:
                enableWifiIpServingLocked(ifname, ipmode);
                break;
            case WifiManager.WIFI_AP_STATE_DISABLED:
            case WifiManager.WIFI_AP_STATE_DISABLING:
            case WifiManager.WIFI_AP_STATE_FAILED:
            default:
                disableWifiIpServingLocked(curState);
                break;
        }
    }
}
#end_block

#method_before
public DownloadRequest download(FileServiceInfo serviceInfo, Uri source, Uri dest, Intent resultIntent, IDownloadCallback listener) {
    DownloadRequest request = new DownloadRequest.Builder().setServiceInfo(serviceInfo).setSource(source).setDest(dest).setSub(mSubId).setAppIntent(resultIntent).setAppName(mDownloadAppName).build();
    return request;
}
#method_after
public DownloadRequest download(DownloadRequest request, IDownloadCallback listener) {
    request.setAppName(mDownloadAppName);
    return request;
}
#end_block

#method_before
public void start() {
    if (!isOffloadEnabled() || started())
        return;
    if (!mConfigInitialized) {
        mConfigInitialized = mHwInterface.initOffloadConfig();
        if (!mConfigInitialized) {
            mLog.i("tethering offload config not supported");
            stop();
            return;
        }
    }
    mControlInitialized = mHwInterface.initOffloadControl(new OffloadHardwareInterface.ControlCallback() {

        @Override
        public void onOffloadEvent(int event) {
            mLog.log("got offload event: " + event);
        }

        @Override
        public void onNatTimeoutUpdate(int proto, String srcAddr, int srcPort, String dstAddr, int dstPort) {
            mLog.log(String.format("NAT timeout update: %s (%s,%s) -> (%s,%s)", proto, srcAddr, srcPort, dstAddr, dstPort));
        }
    });
    if (!mControlInitialized) {
        mLog.i("tethering offload control not supported");
        stop();
    }
}
#method_after
public void start() {
    if (isOffloadDisabled() || started())
        return;
    if (!mConfigInitialized) {
        mConfigInitialized = mHwInterface.initOffloadConfig();
        if (!mConfigInitialized) {
            mLog.i("tethering offload config not supported");
            stop();
            return;
        }
    }
    mControlInitialized = mHwInterface.initOffloadControl(new OffloadHardwareInterface.ControlCallback() {

        @Override
        public void onOffloadEvent(int event) {
            mLog.log("got offload event: " + event);
        }

        @Override
        public void onNatTimeoutUpdate(int proto, String srcAddr, int srcPort, String dstAddr, int dstPort) {
            mLog.log(String.format("NAT timeout update: %s (%s,%s) -> (%s,%s)", proto, srcAddr, srcPort, dstAddr, dstPort));
        }
    });
    if (!mControlInitialized) {
        mLog.i("tethering offload control not supported");
        stop();
    }
}
#end_block

#method_before
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
}
#method_after
@Before
public void setUp() throws Exception {
    MockitoAnnotations.initMocks(this);
    mContentResolver = new MockContentResolver(mContext);
    mContentResolver.addProvider(Settings.AUTHORITY, new FakeSettingsProvider());
    when(mContext.getPackageName()).thenReturn("OffloadControllerTest");
    when(mContext.getContentResolver()).thenReturn(mContentResolver);
}
#end_block

#method_before
public void setForceScoAudio(boolean forced) {
    if (VDBG)
        log("setForceScoAudio");
    if (mService != null && isEnabled()) {
        try {
            mService.setForceScoAudio(forced);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
#method_after
public void setForceScoAudio(boolean forced) {
    if (VDBG)
        log("setForceScoAudio " + String.valueOf(forced));
    if (mService != null && isEnabled()) {
        try {
            mService.setForceScoAudio(forced);
        } catch (RemoteException e) {
            Log.e(TAG, e.toString());
        }
    } else {
        Log.w(TAG, "Proxy not attached to service");
        if (DBG)
            Log.d(TAG, Log.getStackTraceString(new Throwable()));
    }
}
#end_block

#method_before
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    if (argsContain(args, "--diag")) {
        dumpNetworkDiagnostics(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Metered Interfaces:");
    pw.increaseIndent();
    for (String value : mMeteredIfaces) {
        pw.println(value);
    }
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        final int uid = mUidRules.keyAt(i);
        pw.print("UID=");
        pw.print(uid);
        final int uidRules = mUidRules.get(uid, RULE_NONE);
        pw.print(" rules=");
        pw.print(uidRulesToString(uidRules));
        pw.println();
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    if (argsContain(args, "--short") == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mNetworkExtraInfo);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#method_after
@Override
protected void dump(FileDescriptor fd, PrintWriter writer, String[] args) {
    final IndentingPrintWriter pw = new IndentingPrintWriter(writer, "  ");
    if (mContext.checkCallingOrSelfPermission(android.Manifest.permission.DUMP) != PackageManager.PERMISSION_GRANTED) {
        pw.println("Permission Denial: can't dump ConnectivityService " + "from from pid=" + Binder.getCallingPid() + ", uid=" + Binder.getCallingUid());
        return;
    }
    if (argsContain(args, DIAG_ARG)) {
        dumpNetworkDiagnostics(pw);
        return;
    }
    pw.print("NetworkFactories for:");
    for (NetworkFactoryInfo nfi : mNetworkFactoryInfos.values()) {
        pw.print(" " + nfi.name);
    }
    pw.println();
    pw.println();
    final NetworkAgentInfo defaultNai = getDefaultNetwork();
    pw.print("Active default network: ");
    if (defaultNai == null) {
        pw.println("none");
    } else {
        pw.println(defaultNai.network.netId);
    }
    pw.println();
    pw.println("Current Networks:");
    pw.increaseIndent();
    for (NetworkAgentInfo nai : mNetworkAgentInfos.values()) {
        pw.println(nai.toString());
        pw.increaseIndent();
        pw.println(String.format("Requests: REQUEST:%d LISTEN:%d BACKGROUND_REQUEST:%d total:%d", nai.numForegroundNetworkRequests(), nai.numNetworkRequests() - nai.numRequestNetworkRequests(), nai.numBackgroundNetworkRequests(), nai.numNetworkRequests()));
        pw.increaseIndent();
        for (int i = 0; i < nai.numNetworkRequests(); i++) {
            pw.println(nai.requestAt(i).toString());
        }
        pw.decreaseIndent();
        pw.println("Lingered:");
        pw.increaseIndent();
        nai.dumpLingerTimers(pw);
        pw.decreaseIndent();
        pw.decreaseIndent();
    }
    pw.decreaseIndent();
    pw.println();
    pw.println("Metered Interfaces:");
    pw.increaseIndent();
    for (String value : mMeteredIfaces) {
        pw.println(value);
    }
    pw.decreaseIndent();
    pw.println();
    pw.print("Restrict background: ");
    pw.println(mRestrictBackground);
    pw.println();
    pw.println("Status for known UIDs:");
    pw.increaseIndent();
    final int size = mUidRules.size();
    for (int i = 0; i < size; i++) {
        final int uid = mUidRules.keyAt(i);
        pw.print("UID=");
        pw.print(uid);
        final int uidRules = mUidRules.get(uid, RULE_NONE);
        pw.print(" rules=");
        pw.print(uidRulesToString(uidRules));
        pw.println();
    }
    pw.println();
    pw.decreaseIndent();
    pw.println("Network Requests:");
    pw.increaseIndent();
    for (NetworkRequestInfo nri : mNetworkRequests.values()) {
        pw.println(nri.toString());
    }
    pw.println();
    pw.decreaseIndent();
    mLegacyTypeTracker.dump(pw);
    pw.println();
    mTethering.dump(fd, pw, args);
    pw.println();
    mKeepaliveTracker.dump(pw);
    pw.println();
    dumpAvoidBadWifiSettings(pw);
    if (argsContain(args, SHORT_ARG) == false) {
        pw.println();
        synchronized (mValidationLogs) {
            pw.println("mValidationLogs (most recent first):");
            for (ValidationLog p : mValidationLogs) {
                pw.println(p.mNetwork + " - " + p.mNetworkExtraInfo);
                pw.increaseIndent();
                p.mLog.dump(fd, pw, args);
                pw.decreaseIndent();
            }
        }
        pw.println();
        pw.println("mNetworkRequestInfoLogs (most recent first):");
        pw.increaseIndent();
        mNetworkRequestInfoLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("mNetworkInfoBlockingLogs (most recent first):");
        pw.increaseIndent();
        mNetworkInfoBlockingLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
        pw.println();
        pw.println("NetTransition WakeLock activity (most recent first):");
        pw.increaseIndent();
        mWakelockLogs.reverseDump(fd, pw, args);
        pw.decreaseIndent();
    }
}
#end_block

#method_before
private void wakeupAddInterface(String iface, NetworkCapabilities caps) throws RemoteException {
    if (!caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return;
    }
    mNetd.getNetdService().wakeupAddInterface(iface, "iface:" + iface, 0x80000000, 0x80000000);
}
#method_after
private void wakeupAddInterface(String iface, NetworkCapabilities caps) throws RemoteException {
    // marks on unsupported interfaces is harmless.
    if (!caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return;
    }
    mNetd.getNetdService().wakeupAddInterface(iface, "iface:" + iface, mWakeupPacketMark, mWakeupPacketMask);
}
#end_block

#method_before
private void wakeupDelInterface(String iface, NetworkCapabilities caps) throws RemoteException {
    if (!caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return;
    }
    mNetd.getNetdService().wakeupDelInterface(iface, "iface:" + iface, 0x80000000, 0x80000000);
}
#method_after
private void wakeupDelInterface(String iface, NetworkCapabilities caps) throws RemoteException {
    if (!caps.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)) {
        return;
    }
    mNetd.getNetdService().wakeupDelInterface(iface, "iface:" + iface, mWakeupPacketMark, mWakeupPacketMask);
}
#end_block

#method_before
@Override
public synchronized void onWakeupEvent(String prefix, int uid, int gid, long timestampNs) {
    Log.d(TAG, String.format("onWakeupEvent() prefix: %s, uid: %d, gid: %d, ts: %d", prefix, uid, gid, timestampNs));
}
#method_after
@Override
public synchronized void onWakeupEvent(String prefix, int uid, int gid, long timestampNs) {
}
#end_block

#method_before
@Override
public void tearDown(ITestDevice device, IBuildInfo buildInfo, Throwable e) {
    File reportFile = buildInfo.getFile(TEST_PLAN_REPORT_FILE);
    String repotFilePath = reportFile.getAbsolutePath();
    try (BufferedReader br = new BufferedReader(new FileReader(repotFilePath))) {
        DashboardPostMessage postMessage = new DashboardPostMessage();
        String currentLine;
        while ((currentLine = br.readLine()) != null) {
            String[] splited = currentLine.split("\\s+");
            if (splited.length != 2) {
                CLog.e(String.format("Invalid keys %s", currentLine));
                continue;
            }
            TestPlanReportMessage testPlanMessage = new TestPlanReportMessage();
            testPlanMessage.addTestModuleName(splited[0]);
            testPlanMessage.addTestModuleStartTimestamp(Long.parseLong(splited[1]));
            postMessage.addTestPlanReport(testPlanMessage);
        }
        Upload(postMessage);
    } catch (IOException ex) {
        CLog.d(String.format("Can't read the test plan result file %s", repotFilePath));
        return;
    }
}
#method_after
@Override
public void tearDown(ITestDevice device, IBuildInfo buildInfo, Throwable e) {
    File reportFile = buildInfo.getFile(TEST_PLAN_REPORT_FILE);
    String repotFilePath = reportFile.getAbsolutePath();
    try (BufferedReader br = new BufferedReader(new FileReader(repotFilePath))) {
        DashboardPostMessage postMessage = new DashboardPostMessage();
        String currentLine;
        while ((currentLine = br.readLine()) != null) {
            String[] lineWords = currentLine.split("\\s+");
            if (lineWords.length != 2) {
                CLog.e(String.format("Invalid keys %s", currentLine));
                continue;
            }
            TestPlanReportMessage testPlanMessage = new TestPlanReportMessage();
            testPlanMessage.addTestModuleName(lineWords[0]);
            testPlanMessage.addTestModuleStartTimestamp(Long.parseLong(lineWords[1]));
            postMessage.addTestPlanReport(testPlanMessage);
        }
        Upload(postMessage);
    } catch (IOException ex) {
        CLog.d(String.format("Can't read the test plan result file %s", repotFilePath));
        return;
    }
}
#end_block

