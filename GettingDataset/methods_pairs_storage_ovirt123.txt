1014
#method_before
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetStyleName(style.label());
    optimizationNoneEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationForServerEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationForDesktopEditor.setContentWidgetStyleName(style.fullWidth());
    optimizationCustomEditor.setContentWidgetStyleName(style.fullWidth());
    countThreadsAsCoresEditor.setContentWidgetStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetStyleName(style.fullWidth());
}
#method_after
private void addStyles() {
    importGlusterConfigurationEditor.addContentWidgetStyleName(style.editorContentWidget());
    migrateOnErrorOption_NOEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_YESEditor.addContentWidgetStyleName(style.label());
    migrateOnErrorOption_HA_ONLYEditor.addContentWidgetStyleName(style.label());
    countThreadsAsCoresEditor.setContentWidgetStyleName(style.fullWidth());
    enableTrustedServiceEditor.setContentWidgetStyleName(style.fullWidth());
}
#end_block

#method_before
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        for (VDS host : hosts) {
            if (host.getId().equals(vm.getDedicatedVmForVds())) {
                return Arrays.asList(host);
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST.toString());
    }
    return hosts;
}
#method_after
@Override
public List<VDS> filter(List<VDS> hosts, VM vm, Map<String, String> parameters, List<String> messages) {
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        for (VDS host : hosts) {
            if (host.getId().equals(vm.getDedicatedVmForVds())) {
                return Arrays.asList(host);
            }
        }
        // if flow reaches here, the VM is pinned but there is no dedicated host.
        return new ArrayList<>();
    }
    return hosts;
}
#end_block

#method_before
protected void initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    VDS destVds = getDestinationVds();
    SchedulingManager.SchedulingResult schedulingResult = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), destVds == null ? null : destVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    Guid vdsToRunOn = schedulingResult.getVdsSelected();
    setVdsDestinationId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // make _destinationVds null in order to refresh it from db in case it
    // changed.
    _destinationVds = null;
    if (vdsDestinationId != null && vdsDestinationId.equals(Guid.Empty)) {
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_CANT_ALLOC_VDS_MIGRATION);
    }
    if (getDestinationVds() == null || getVds() == null) {
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
    }
}
#method_after
protected void initVdss() {
    setVdsIdRef(getVm().getRunOnVds());
    VDS destVds = getDestinationVds();
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getVdsBlackList(), getVdsWhiteList(), destVds == null ? null : destVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsDestinationId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    // make _destinationVds null in order to refresh it from db in case it
    // changed.
    _destinationVds = null;
    if (vdsDestinationId != null && vdsDestinationId.equals(Guid.Empty)) {
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_CANT_ALLOC_VDS_MIGRATION);
    }
    if (getDestinationVds() == null || getVds() == null) {
        throw new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
    }
}
#end_block

#method_before
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, vdsDestinationId, dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp());
}
#method_after
private MigrateVDSCommandParameters createMigrateVDSCommandParameters() {
    String srcVdsHost = getVds().getHostName();
    String dstVdsHost = String.format("%1$s:%2$s", getDestinationVds().getHostName(), getDestinationVds().getPort());
    return new MigrateVDSCommandParameters(getVdsId(), getVmId(), srcVdsHost, vdsDestinationId, dstVdsHost, MigrationMethod.ONLINE, isTunnelMigrationUsed(), getMigrationNetworkIp(), getVds().getVdsGroupCompatibilityVersion());
}
#end_block

#method_before
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName) {
    final List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (nic.getStatistics().getStatus() == InterfaceStatus.UP && migrationNetworkName.equals(nic.getNetworkName())) {
            return nic.getAddress();
        }
    }
    return null;
}
#method_after
private String getMigrationNetworkAddress(Guid hostId, String migrationNetworkName) {
    final List<VdsNetworkInterface> nics = getDbFacade().getInterfaceDao().getAllInterfacesForVds(hostId);
    for (VdsNetworkInterface nic : nics) {
        if (migrationNetworkName.equals(nic.getNetworkName()) && migrationInterfaceUp(nic, nics)) {
            return nic.getAddress();
        }
    }
    return null;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? getActionReturnValue() == VMStatus.Up ? AuditLogType.VM_MIGRATION_DONE : isInternalExecution() ? AuditLogType.VM_MIGRATION_START_SYSTEM_INITIATED : AuditLogType.VM_MIGRATION_START : _isRerun ? AuditLogType.VM_MIGRATION_TRYING_RERUN : getVds().getStatus() == VDSStatus.PreparingForMaintenance ? AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE : AuditLogType.VM_MIGRATION_FAILED;
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    return getSucceeded() ? getActionReturnValue() == VMStatus.Up ? AuditLogType.VM_MIGRATION_DONE : isInternalExecution() ? AuditLogType.VM_MIGRATION_START_SYSTEM_INITIATED : AuditLogType.VM_MIGRATION_START : _isRerun ? AuditLogType.VM_MIGRATION_TRYING_RERUN : getVds().getStatus() == VDSStatus.PreparingForMaintenance ? AuditLogType.VM_MIGRATION_FAILED_DURING_MOVE_TO_MAINTENANCE : getDestinationVds() == null ? AuditLogType.VM_MIGRATION_FAILED_NO_VDS_TO_RUN_ON : AuditLogType.VM_MIGRATION_FAILED;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !forcedMigrationForNonMigratableVM) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    if (vm.getStatus() == VMStatus.MigratingFrom) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
    }
    if (vm.getStatus() == VMStatus.NotResponding) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
    }
    if (vm.getStatus() == VMStatus.Paused) {
        return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_VM_IS_UNSUPPORTED);
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    if (getDestinationVds() != null && getDestinationVds().getStatus() != VDSStatus.Up) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP);
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getVdsDestinationId(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    final VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // If VM is pinned to host, no migration can occur
    if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_PINNED_TO_HOST);
    }
    if (vm.getMigrationSupport() == MigrationSupport.IMPLICITLY_NON_MIGRATABLE && !forcedMigrationForNonMigratableVM) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NON_MIGRTABLE_AND_IS_NOT_FORCED_BY_USER_TO_MIGRATE);
    }
    if (vm.getStatus() == VMStatus.MigratingFrom) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MIGRATION_IN_PROGRESS);
    }
    if (vm.getStatus() == VMStatus.NotResponding) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
    }
    if (vm.getStatus() == VMStatus.Paused) {
        return failCanDoAction(VdcBllMessages.MIGRATE_PAUSED_VM_IS_UNSUPPORTED);
    }
    if (!vm.isQualifyToMigrate()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_RUNNING);
    }
    VmValidator vmValidator = new VmValidator(vm);
    if (!validate(vmValidator.vmNotHavingPluggedDiskSnapshots(VdcBllMessages.ACTION_TYPE_FAILED_VM_HAS_PLUGGED_DISK_SNAPSHOT))) {
        return false;
    }
    if (getDestinationVds() != null && getDestinationVds().getStatus() != VDSStatus.Up) {
        addCanDoActionMessage(VdcBllMessages.VAR__HOST_STATUS__UP);
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VDS_STATUS_ILLEGAL);
    }
    return validate(new SnapshotsValidator().vmNotDuringSnapshot(vm.getId())) && // TODO: replace it with a better solution
    validate(new DiskImagesValidator(ImagesHandler.getPluggedActiveImagesForVm(vm.getId())).diskImagesNotLocked()) && SchedulingManager.getInstance().canSchedule(getVdsGroup(), getVm(), getVdsBlackList(), getParameters().getInitialHosts(), getVdsDestinationId(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
        discoveryThread.start();
    } else {
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#method_after
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        discoveryThread.start();
    } else {
        discoveryThread.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#end_block

#method_before
public void addReason(Guid id, String reason) {
    filteredOutReasons.put(id, reason);
}
#method_after
public void addReason(Guid id, String hostName, VdcBllMessages filterType, String filterName) {
    filteredOutReasons.put(id, new Pair<VdcBllMessages, String>(filterType, filterName));
    hostNames.put(id, hostName);
}
#end_block

#method_before
public Set<Entry<Guid, String>> getReasons() {
    return filteredOutReasons.entrySet();
}
#method_after
public Set<Entry<Guid, Pair<VdcBllMessages, String>>> getReasons() {
    return filteredOutReasons.entrySet();
}
#end_block

#method_before
public Collection<String> getReasonMessages() {
    return filteredOutReasons.values();
}
#method_after
public Collection<String> getReasonMessages() {
    List<String> lines = new ArrayList<>();
    for (Entry<Guid, Pair<VdcBllMessages, String>> line : filteredOutReasons.entrySet()) {
        lines.add(line.getValue().getFirst().name());
        lines.add(String.format("$%1$s %2$s", "hostName", hostNames.get(line.getKey())));
        lines.add(String.format("$%1$s %2$s", "filterName", line.getValue().getSecond()));
        lines.add(VdcBllMessages.SCHEDULING_HOST_FILTERED_REASON.name());
    }
    return lines;
}
#end_block

#method_before
public SchedulingResult schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        if (destHostId != null) {
            if (checkDestinationHost(vm, vdsList, destHostId, messages, policy, parameters, memoryChecker)) {
                result.setVdsSelected(destHostId);
                return result;
            } else if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
                result.setMessage("VM " + vm.getId().toString() + " cannot be migrated because it is pinned to host");
                log.info(result.getMessage());
                return result;
            }
        }
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, correlationId, result);
        if (vdsList == null || vdsList.size() == 0) {
            return result;
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            result.setVdsSelected(vdsList.get(0).getId());
            return result;
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), vm.getVmMemSizeMb(), vm.getNumOfCpus());
        }
        result.setVdsSelected(bestHost);
        return result;
    }
}
#method_after
public Guid schedule(VDSGroup cluster, VM vm, List<Guid> hostBlackList, List<Guid> hostWhiteList, Guid destHostId, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId) {
    clusterLockMap.putIfAbsent(cluster.getId(), new Object());
    synchronized (clusterLockMap.get(cluster.getId())) {
        List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
        updateInitialHostList(vdsList, hostBlackList, true);
        updateInitialHostList(vdsList, hostWhiteList, false);
        ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
        Map<String, String> parameters = createClusterPolicyParameters(cluster);
        vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, memoryChecker, true, correlationId);
        if (vdsList == null || vdsList.size() == 0) {
            return null;
        }
        // it passed filters return it
        if (destHostId != null) {
            for (VDS vds : vdsList) {
                if (destHostId.equals(vds.getId())) {
                    return destHostId;
                }
            }
        }
        if (policy.getFunctions() == null || policy.getFunctions().isEmpty()) {
            return vdsList.get(0).getId();
        }
        Guid bestHost = runFunctions(policy.getFunctions(), vdsList, vm, parameters);
        if (bestHost == null && vdsList.size() > 0) {
            bestHost = vdsList.get(0).getId();
        }
        if (bestHost != null) {
            getVdsDynamicDao().updatePartialVdsDynamicCalc(bestHost, 1, vm.getNumOfCpus(), vm.getMinAllocatedMem(), vm.getVmMemSizeMb(), vm.getNumOfCpus());
        }
        return bestHost;
    }
}
#end_block

#method_before
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    SchedulingResult result = new SchedulingResult();
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    if (destVdsId != null) {
        if (checkDestinationHost(vm, vdsList, destVdsId, messages, policy, parameters, noWaitingMemoryChecker)) {
            return true;
        } else if (vm.getMigrationSupport() == MigrationSupport.PINNED_TO_HOST) {
            return false;
        }
    }
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, null, result);
    if (vdsList == null || vdsList.size() == 0) {
        messages.addAll(result.getReasonMessages());
        return false;
    }
    return true;
}
#method_after
public boolean canSchedule(VDSGroup cluster, VM vm, List<Guid> vdsBlackList, List<Guid> vdsWhiteList, Guid destVdsId, List<String> messages) {
    List<VDS> vdsList = getVdsDAO().getAllForVdsGroupWithStatus(cluster.getId(), VDSStatus.Up);
    updateInitialHostList(vdsList, vdsBlackList, true);
    updateInitialHostList(vdsList, vdsWhiteList, false);
    ClusterPolicy policy = policyMap.get(cluster.getClusterPolicyId());
    Map<String, String> parameters = createClusterPolicyParameters(cluster);
    vdsList = runFilters(policy.getFilters(), vdsList, vm, parameters, policy.getFilterPositionMap(), messages, noWaitingMemoryChecker, false, null);
    if (vdsList == null || vdsList.size() == 0) {
        return false;
    }
    return true;
}
#end_block

#method_before
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker, correlationId, result);
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled) && externalFilters.size() > 0 && hostList != null && hostList.size() > 0) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    return hostList;
}
#method_after
private List<VDS> runFilters(ArrayList<Guid> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, boolean shouldRunExternalFilters, String correlationId) {
    SchedulingResult result = new SchedulingResult();
    ArrayList<PolicyUnitImpl> internalFilters = new ArrayList<PolicyUnitImpl>();
    ArrayList<PolicyUnitImpl> externalFilters = new ArrayList<PolicyUnitImpl>();
    sortFilters(filters, filterPositionMap);
    if (filters != null) {
        for (Guid filter : filters) {
            PolicyUnitImpl filterPolicyUnit = policyUnits.get(filter);
            if (filterPolicyUnit.isInternal()) {
                internalFilters.add(filterPolicyUnit);
            } else {
                if (filterPolicyUnit.isEnabled()) {
                    externalFilters.add(filterPolicyUnit);
                }
            }
        }
    }
    hostList = runInternalFilters(internalFilters, hostList, vm, parameters, filterPositionMap, messages, memoryChecker, correlationId, result);
    if (shouldRunExternalFilters && Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled) && externalFilters.size() > 0 && hostList != null && hostList.size() > 0) {
        hostList = runExternalFilters(externalFilters, hostList, vm, parameters, messages, correlationId, result);
    }
    if (hostList == null || hostList.size() == 0) {
        messages.add(VdcBllMessages.SCHEDULING_ALL_HOSTS_FILTERED_OUT.name());
        messages.addAll(result.getReasonMessages());
    }
    return hostList;
}
#end_block

#method_before
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    if (filters != null) {
        for (PolicyUnitImpl filterPolicyUnit : filters) {
            if (hostList == null || hostList.isEmpty()) {
                break;
            }
            filterPolicyUnit.setMemoryChecker(memoryChecker);
            List<VDS> newHostList = filterPolicyUnit.filter(hostList, vm, parameters, messages);
            logFilterActions(hostList, newHostList, "internal filter " + filterPolicyUnit.getName(), result);
            hostList = newHostList;
        }
    }
    return hostList;
}
#method_after
private List<VDS> runInternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, Map<Guid, Integer> filterPositionMap, List<String> messages, VdsFreeMemoryChecker memoryChecker, String correlationId, SchedulingResult result) {
    if (filters != null) {
        for (PolicyUnitImpl filterPolicyUnit : filters) {
            if (hostList == null || hostList.isEmpty()) {
                break;
            }
            filterPolicyUnit.setMemoryChecker(memoryChecker);
            List<VDS> currentHostList = new ArrayList<VDS>(hostList);
            hostList = filterPolicyUnit.filter(hostList, vm, parameters, messages);
            logFilterActions(currentHostList, toIdSet(hostList), VdcBllMessages.VAR__FILTERTYPE__INTERNAL, filterPolicyUnit.getName(), result, correlationId);
        }
    }
    return hostList;
}
#end_block

#method_before
private void logFilterActions(List<VDS> oldList, List<VDS> newList, String actionName, SchedulingResult result) {
    // to get O(1) membership check
    Set<VDS> newSet = new HashSet<VDS>(newList);
    for (VDS host : oldList) {
        if (!newSet.contains(host)) {
            StringBuilder reason = new StringBuilder();
            reason.append("Candidate host ");
            reason.append(host.getName());
            reason.append(" (");
            reason.append(host.getId().toString());
            reason.append(") was filtered out by ");
            reason.append(actionName);
            result.addReason(host.getId(), reason.toString());
            log.info(reason);
        }
    }
}
#method_after
private void logFilterActions(List<VDS> oldList, Set<Guid> newSet, VdcBllMessages actionName, String filterName, SchedulingResult result, String correlationId) {
    for (VDS host : oldList) {
        if (!newSet.contains(host.getId())) {
            String reason = String.format("Candidate host %s (%s) was filtered out by %s filter %s", host.getName(), host.getId().toString(), actionName.name(), filterName);
            if (!StringUtils.isEmpty(correlationId)) {
                reason = String.format("%s (correlation id: %s)", reason, correlationId);
            }
            log.info(reason);
            result.addReason(host.getId(), host.getName(), actionName, filterName);
        }
    }
}
#end_block

#method_before
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<String> filterNames = new ArrayList<String>();
        for (PolicyUnitImpl filter : filters) {
            filterNames.add(filter.getName());
        }
        List<Guid> hostIDs = new ArrayList<Guid>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        filteredIDs = ExternalSchedulerFactory.getInstance().runFilters(filterNames, hostIDs, vm.getId(), parameters);
        logFilterActionsWithGuid(hostList, filteredIDs, "external filter(s)", result);
    }
    return intersectHosts(hostList, filteredIDs);
}
#method_after
private List<VDS> runExternalFilters(ArrayList<PolicyUnitImpl> filters, List<VDS> hostList, VM vm, Map<String, String> parameters, List<String> messages, String correlationId, SchedulingResult result) {
    List<Guid> filteredIDs = null;
    if (filters != null) {
        List<String> filterNames = new ArrayList<String>();
        for (PolicyUnitImpl filter : filters) {
            filterNames.add(filter.getName());
        }
        List<Guid> hostIDs = new ArrayList<Guid>();
        for (VDS host : hostList) {
            hostIDs.add(host.getId());
        }
        filteredIDs = ExternalSchedulerFactory.getInstance().runFilters(filterNames, hostIDs, vm.getId(), parameters);
        if (filteredIDs != null) {
            logFilterActions(hostList, new HashSet<Guid>(filteredIDs), VdcBllMessages.VAR__FILTERTYPE__EXTERNAL, Arrays.toString(filterNames.toArray()), result, correlationId);
        }
    }
    return intersectHosts(hostList, filteredIDs);
}
#end_block

#method_before
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found stateless snapshots for this vm  - skipped creating snapshots.", getVm().getName());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the EndAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getName());
        }
    }
}
#method_after
private void statelessVmTreatment() {
    warnIfNotAllDisksPermitSnapshots();
    if (isStatelessSnapshotExistsForVm()) {
        log.errorFormat("RunVmAsStateless - {0} - found stateless snapshots for this vm  - skipped creating snapshots.", getVm().getName());
        removeVmStatlessImages();
    } else {
        log.infoFormat("VdcBll.RunVmCommand.RunVmAsStateless - Creating snapshot for stateless vm {0} - {1}", getVm().getName(), getVm().getId());
        CreateAllSnapshotsFromVmParameters createAllSnapshotsFromVmParameters = buildCreateSnapshotParameters();
        Map<String, String> values = getVmValuesForMsgResolving();
        // Creating snapshots as sub step of run stateless
        Step createSnapshotsStep = addSubStep(StepEnum.EXECUTING, StepEnum.CREATING_SNAPSHOTS, values);
        // Add the step as the first step of the new context
        ExecutionContext createSnapshotsCtx = new ExecutionContext();
        createSnapshotsCtx.setMonitored(true);
        createSnapshotsCtx.setStep(createSnapshotsStep);
        VdcReturnValueBase vdcReturnValue = getBackend().runInternalAction(VdcActionType.CreateAllSnapshotsFromVm, createAllSnapshotsFromVmParameters, new CommandContext(createSnapshotsCtx, getCompensationContext(), getLock()));
        // setting lock to null in order not to release lock twice
        setLock(null);
        setSucceeded(vdcReturnValue.getSucceeded());
        if (vdcReturnValue.getSucceeded()) {
            getReturnValue().getVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            // save RunVmParams so we'll know how to run
            // the stateless VM in the endAction part.
            VmHandler.updateDisksFromDb(getVm());
        } else {
            if (areDisksLocked(vdcReturnValue)) {
                throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
            }
            getReturnValue().setFault(vdcReturnValue.getFault());
            log.errorFormat("RunVmAsStateless - {0} - failed to create snapshots", getVm().getName());
        }
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    VDS destinationVds = getDestinationVds();
    SchedulingManager.SchedulingResult schedulingResult = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), null, destinationVds == null ? null : destinationVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    Guid vdsToRunOn = schedulingResult.getVdsSelected();
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    /* Prepare user readable error message */
    VdcFault fault = new VdcFault();
    fault.setError(VdcBllErrors.SCHEDULING_ALL_HOSTS_FILTERED_OUT);
    getReturnValue().setFault(fault);
    StringBuilder errorMessage = new StringBuilder();
    errorMessage.append("All hosts were filtered out, the reasons follow:\n");
    for (Map.Entry<Guid, String> vds : schedulingResult.getReasons()) {
        errorMessage.append(String.format("%s: %s\n", vds.getKey().toString(), vds.getValue()));
    }
    getReturnValue().setDescription(errorMessage.toString());
    VmHandler.updateVmGuestAgentVersion(getVm());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    VDS destinationVds = getDestinationVds();
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), getVdsWhiteList(), destinationVds == null ? null : destinationVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this), getCorrelationId());
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validate(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validateNetworkInterfaces()) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    // we don't run the VM
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validate(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getVdsWhiteList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validateNetworkInterfaces()) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    // we don't run the VM
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    if (isVmRunningStateless()) {
        CreateAllSnapshotsFromVmParameters createSnapshotParameters = buildCreateSnapshotParameters();
        createSnapshotParameters.setImagesParameters(getParameters().getImagesParameters());
        getBackend().EndAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        setInternalExecution(true);
        // The internal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getName());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#method_after
@Override
protected void endSuccessfully() {
    if (isVmRunningStateless()) {
        CreateAllSnapshotsFromVmParameters createSnapshotParameters = buildCreateSnapshotParameters();
        createSnapshotParameters.setImagesParameters(getParameters().getImagesParameters());
        getBackend().endAction(VdcActionType.CreateAllSnapshotsFromVm, createSnapshotParameters);
        getParameters().setShouldBeLogged(false);
        getParameters().setRunAsStateless(false);
        ExecutionContext runStatelessVmCtx = new ExecutionContext();
        Step step = getExecutionContext().getStep();
        // Retrieve the job object and its steps as this the endSuccessfully stage of command execution -
        // at this is a new instance of the command is used
        // (comparing with the execution state) so all information on the job and steps should be retrieved.
        Job job = JobRepositoryFactory.getJobRepository().getJobWithSteps(step.getJobId());
        Step executingStep = job.getDirectStep(StepEnum.EXECUTING);
        // We would like to to set the run stateless step as substep of executing step
        setInternalExecution(true);
        // The internal command should be monitored for tasks
        runStatelessVmCtx.setMonitored(true);
        Step runStatelessStep = ExecutionHandler.addSubStep(getExecutionContext(), executingStep, StepEnum.RUN_STATELESS_VM, ExecutionMessageDirector.resolveStepMessage(StepEnum.RUN_STATELESS_VM, getVmValuesForMsgResolving()));
        // This is needed in order to end the job upon exextuion of the steps of the child command
        runStatelessVmCtx.setShouldEndJob(true);
        // Since run stateless step involves invocation of command, we should set the run stateless vm step as
        // the "beginning step" of the child command.
        runStatelessVmCtx.setStep(runStatelessStep);
        setSucceeded(getBackend().runInternalAction(getActionType(), getParameters(), new CommandContext(runStatelessVmCtx)).getSucceeded());
        if (!getSucceeded()) {
            // could not run the vm don't try to run the end action again
            log.warnFormat("Could not run the vm {0} on RunVm.EndSuccessfully", getVm().getName());
            getReturnValue().setEndActionTryAgain(false);
        }
    } else // Hibernation (VMStatus.Suspended) treatment:
    {
        super.endSuccessfully();
    }
}
#end_block

#method_before
void reloadData(File[] descriptorFiles, Map<String, PluginData> currentDataMapCopy) {
    Map<String, PluginData> entriesToUpdate = new HashMap<String, PluginData>();
    Set<String> keysToRemove = new HashSet<String>();
    // Optimization: make sure we don't check data that we already processed
    Set<String> keysToCheckForRemoval = new HashSet<String>(currentDataMapCopy.keySet());
    // Compare (possibly added or modified) files against cached data
    for (final File df : descriptorFiles) {
        final File cf = new File(pluginConfigDir, getConfigurationFileName(df));
        String descriptorFilePath = df.getAbsolutePath();
        PluginData currentData = currentDataMapCopy.get(descriptorFilePath);
        long descriptorLastModified = df.lastModified();
        long configurationLastModified = isJsonFile(cf) ? cf.lastModified() : MISSING_FILE_LAST_MODIFIED;
        // Check if data needs to be reloaded
        boolean reloadDescriptor, reloadConfiguration;
        if (currentDataMapCopy.containsKey(descriptorFilePath)) {
            reloadDescriptor = descriptorLastModified > currentData.getDescriptorLastModified();
            reloadConfiguration = configurationLastModified > currentData.getConfigurationLastModified();
            // Change in descriptor causes reload of configuration
            reloadConfiguration = reloadConfiguration || reloadDescriptor;
            // Refresh configuration if the corresponding file has gone missing
            reloadConfiguration = reloadConfiguration || (configurationLastModified == MISSING_FILE_LAST_MODIFIED && currentData.getConfigurationLastModified() != MISSING_FILE_LAST_MODIFIED);
        } else {
            reloadDescriptor = true;
            reloadConfiguration = true;
        }
        // Read descriptor data
        JsonNode descriptorNode = currentData != null ? currentData.getDescriptorNode() : null;
        if (reloadDescriptor) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.info("Reading UI plugin descriptor [" + df.getAbsolutePath() + "]");
            descriptorNode = readJsonNode(df);
            if (descriptorNode == null) {
                // Failed to read descriptor data, nothing we can do about it
                continue;
            }
        } else if (descriptorNode == null) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.warn("UI plugin descriptor node is null for [" + df.getAbsolutePath() + "]");
            continue;
        }
        // Read configuration data
        JsonNode configurationNode = currentData != null ? currentData.getConfigurationNode() : null;
        if (reloadConfiguration) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.info("Reading UI plugin configuration [" + cf.getAbsolutePath() + "]");
            configurationNode = readConfigurationNode(cf);
            if (configurationNode == null) {
                // Failed to read configuration data, use empty object
                configurationNode = createEmptyObjectNode();
            }
        } else if (configurationNode == null) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.warn("UI plugin configuration node is null for [" + cf.getAbsolutePath() + "]");
            continue;
        }
        // Update data
        if (reloadDescriptor || reloadConfiguration) {
            PluginData newData = new PluginData(descriptorNode, descriptorLastModified, configurationNode, configurationLastModified, mapper.getNodeFactory());
            // Validate data
            boolean dataValid = newData.validate(new PluginData.ValidationCallback() {

                @Override
                public void descriptorError(String message) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    logger.warn("Validation error in [" + df.getAbsolutePath() + "]: " + message);
                }

                @Override
                public void configurationError(String message) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    logger.warn("Validation error in [" + cf.getAbsolutePath() + "]: " + message);
                }
            });
            if (!dataValid) {
                // Data validation failed, nothing we can do about it
                continue;
            }
            entriesToUpdate.put(descriptorFilePath, newData);
        }
        keysToCheckForRemoval.remove(descriptorFilePath);
    }
    // Compare cached data against (possibly missing) files
    for (String descriptorFilePath : keysToCheckForRemoval) {
        File df = new File(descriptorFilePath);
        if (!df.exists()) {
            // Descriptor data file has gone missing
            keysToRemove.add(descriptorFilePath);
        }
    }
    // Perform data updates
    currentDataMapCopy.putAll(entriesToUpdate);
    currentDataMapCopy.keySet().removeAll(keysToRemove);
}
#method_after
void reloadData(File[] descriptorFiles, Map<String, PluginData> currentDataMapCopy) {
    Map<String, PluginData> entriesToUpdate = new HashMap<String, PluginData>();
    Set<String> keysToRemove = new HashSet<String>();
    // Optimization: make sure we don't check data that we already processed
    Set<String> keysToCheckForRemoval = new HashSet<String>(currentDataMapCopy.keySet());
    // Compare (possibly added or modified) files against cached data
    for (final File df : descriptorFiles) {
        final File cf = new File(pluginConfigDir, getConfigurationFileName(df));
        String descriptorFilePath = df.getAbsolutePath();
        PluginData currentData = currentDataMapCopy.get(descriptorFilePath);
        long descriptorLastModified = df.lastModified();
        long configurationLastModified = isJsonFile(cf) ? cf.lastModified() : MISSING_FILE_LAST_MODIFIED;
        // Check if data needs to be reloaded
        boolean reloadDescriptor, reloadConfiguration;
        if (currentDataMapCopy.containsKey(descriptorFilePath)) {
            reloadDescriptor = descriptorLastModified > currentData.getDescriptorLastModified();
            reloadConfiguration = configurationLastModified > currentData.getConfigurationLastModified();
            // Change in descriptor causes reload of configuration
            reloadConfiguration |= reloadDescriptor;
            // Refresh configuration if the corresponding file has gone missing
            reloadConfiguration |= (configurationLastModified == MISSING_FILE_LAST_MODIFIED && currentData.getConfigurationLastModified() != MISSING_FILE_LAST_MODIFIED);
        } else {
            reloadDescriptor = true;
            reloadConfiguration = true;
        }
        // Read descriptor data
        JsonNode descriptorNode = currentData != null ? currentData.getDescriptorNode() : null;
        if (reloadDescriptor) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.info("Reading UI plugin descriptor [" + df.getAbsolutePath() + "]");
            descriptorNode = readJsonNode(df);
            if (descriptorNode == null) {
                // Failed to read descriptor data, nothing we can do about it
                continue;
            }
        } else if (descriptorNode == null) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.warn("UI plugin descriptor node is null for [" + df.getAbsolutePath() + "]");
            continue;
        }
        // Read configuration data
        JsonNode configurationNode = currentData != null ? currentData.getConfigurationNode() : null;
        if (reloadConfiguration) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.info("Reading UI plugin configuration [" + cf.getAbsolutePath() + "]");
            configurationNode = readConfigurationNode(cf);
            if (configurationNode == null) {
                // Failed to read configuration data, use empty object
                configurationNode = createEmptyObjectNode();
            }
        } else if (configurationNode == null) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.warn("UI plugin configuration node is null for [" + cf.getAbsolutePath() + "]");
            continue;
        }
        // Update data
        if (reloadDescriptor || reloadConfiguration) {
            PluginData newData = new PluginData(descriptorNode, descriptorLastModified, configurationNode, configurationLastModified, mapper.getNodeFactory());
            // Validate data
            boolean dataValid = newData.validate(new PluginData.ValidationCallback() {

                @Override
                public void descriptorError(String message) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    logger.warn("Validation error in [" + df.getAbsolutePath() + "]: " + message);
                }

                @Override
                public void configurationError(String message) {
                    // $NON-NLS-1$ //$NON-NLS-2$
                    logger.warn("Validation error in [" + cf.getAbsolutePath() + "]: " + message);
                }
            });
            if (!dataValid) {
                // Data validation failed, nothing we can do about it
                continue;
            }
            entriesToUpdate.put(descriptorFilePath, newData);
        }
        keysToCheckForRemoval.remove(descriptorFilePath);
    }
    // Compare cached data against (possibly missing) files
    for (String descriptorFilePath : keysToCheckForRemoval) {
        File df = new File(descriptorFilePath);
        if (!df.exists()) {
            // Descriptor data file has gone missing
            keysToRemove.add(descriptorFilePath);
        }
    }
    // Perform data updates
    currentDataMapCopy.putAll(entriesToUpdate);
    currentDataMapCopy.keySet().removeAll(keysToRemove);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isVmExist() && isVmInUpPausedDownStatus() && canRunActionOnNonManagedVm() && isDiskExist(getDisk()) && checkCanPerformPlugUnPlugDisk() && isVmNotInPreviewSnapshot() && imageStorageValidation() && virtIoScsiDiskValidation();
}
#method_after
@Override
protected boolean canDoAction() {
    performDbLoads();
    return isVmExist() && isVmInUpPausedDownStatus() && canRunActionOnNonManagedVm() && isDiskExist(getDisk()) && checkCanPerformPlugUnPlugDisk() && isVmNotInPreviewSnapshot() && imageStorageValidation() && virtIoScsiDiskValidation();
}
#end_block

#method_before
private boolean checkCanPerformPlugUnPlugDisk() {
    if (getVm().getStatus().isUpOrPaused()) {
        setVdsId(getVm().getRunOnVds());
        if (!isInterfaceSupportedForPlugUnPlug(disk)) {
            return false;
        }
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getDisk().getId(), getVmId()));
    if (getPlugAction() == VDSCommandType.HotPlugDisk && oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
    }
    if (getPlugAction() == VDSCommandType.HotUnPlugDisk && !oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
    }
    return true;
}
#method_after
private boolean checkCanPerformPlugUnPlugDisk() {
    if (getVm().getStatus().isUpOrPaused()) {
        setVdsId(getVm().getRunOnVds());
        if (!isInterfaceSupportedForPlugUnPlug(disk)) {
            return false;
        }
    }
    if (getPlugAction() == VDSCommandType.HotPlugDisk && oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
    }
    if (getPlugAction() == VDSCommandType.HotUnPlugDisk && !oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
    }
    return true;
}
#end_block

#method_before
@Test
public void canDoActionFailedGuestOsIsNotSupported() {
    VM vm = mockVmStatusUp();
    // rhel3x64
    vm.setVmOs(15);
    cretaeVirtIODisk();
    when(osRepository.getOsName(15)).thenReturn("RHEL3x64");
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new ArrayList<String>());
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED.toString()));
}
#method_after
@Test
public void canDoActionFailedGuestOsIsNotSupported() {
    VM vm = mockVmStatusUp();
    // rhel3x64
    vm.setVmOs(15);
    cretaeVirtIODisk();
    when(osRepository.getOsName(15)).thenReturn("RHEL3x64");
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(Collections.<String>emptySet());
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED.toString()));
}
#end_block

#method_before
@Before
public void initializeCommand() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    command = spy(createCommand());
    mockVds();
    when(command.getActionType()).thenReturn(getCommandActionType());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    StorageDomainValidator storageDomainValidator = mock(StorageDomainValidator.class);
    doReturn(storageDomainValidator).when(command).getStorageDomainValidator(any(StorageDomain.class));
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainExistAndActive();
}
#method_after
@Before
public void initializeCommand() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    command = spy(createCommand());
    mockVds();
    mockVmDevice(false);
    when(command.getActionType()).thenReturn(getCommandActionType());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    StorageDomainValidator storageDomainValidator = mock(StorageDomainValidator.class);
    doReturn(storageDomainValidator).when(command).getStorageDomainValidator(any(StorageDomain.class));
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainExistAndActive();
    doReturn(vmNetworkInterfaceDao).when(command).getVmNetworkInterfaceDao();
}
#end_block

#method_before
private void mockVMDAO(VM vm) {
    when(vmDAO.get(command.getParameters().getVmId())).thenReturn(vm);
    List<VM> vmList = new ArrayList<VM>();
    VM vm1 = new VM();
    vm1.setId(command.getParameters().getVmId());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    vmList.add(vm1);
    vmList.add(vm2);
    when(vmDAO.getVmsListForDisk(any(Guid.class))).thenReturn(vmList);
}
#method_after
private void mockVMDAO(VM vm) {
    when(vmDAO.get(command.getParameters().getVmId())).thenReturn(vm);
    List<VM> vmList = new ArrayList<VM>();
    VM vm1 = new VM();
    vm1.setId(command.getParameters().getVmId());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    vmList.add(vm1);
    vmList.add(vm2);
    when(vmDAO.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(vmList);
}
#end_block

#method_before
private DiskImage createNotVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setActive(true);
    disk.setDiskInterface(DiskInterface.IDE);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(DISK_HOTPLUGGABLE_INTERFACES);
    return disk;
}
#method_after
private DiskImage createNotVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setActive(true);
    disk.setDiskInterface(DiskInterface.IDE);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    return disk;
}
#end_block

#method_before
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(DISK_HOTPLUGGABLE_INTERFACES);
    mockVmDevice(false);
}
#method_after
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    mockVmDevice(false);
}
#end_block

#method_before
public void removeAll(Guid vmId) {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(vmId);
    if (interfaces != null) {
        for (VmNic iface : interfaces) {
            getMacPoolManager().freeMac(iface.getMacAddress());
            getVmNicDao().remove(iface.getId());
            getVmNetworkStatisticsDao().remove(iface.getId());
        }
    }
}
#method_after
public void removeAll(Guid vmId) {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(vmId);
    if (interfaces != null) {
        removeFromExternalNetworks(interfaces);
        for (VmNic iface : interfaces) {
            getMacPoolManager().freeMac(iface.getMacAddress());
            getVmNicDao().remove(iface.getId());
            getVmNetworkStatisticsDao().remove(iface.getId());
        }
    }
}
#end_block

#method_before
@Before
public void setupMocks() {
    MockitoAnnotations.initMocks(this);
    doReturn(macPoolManager).when(vmInterfaceManager).getMacPoolManager();
    doReturn(vmNetworkStatisticsDAO).when(vmInterfaceManager).getVmNetworkStatisticsDao();
    doReturn(vmNetworkInterfaceDAO).when(vmInterfaceManager).getVmNetworkInterfaceDao();
    doReturn(vmNicDao).when(vmInterfaceManager).getVmNicDao();
    doReturn(vmDAO).when(vmInterfaceManager).getVmDAO();
    doNothing().when(vmInterfaceManager).auditLogMacInUseUnplug(any(VmNic.class));
    doNothing().when(vmInterfaceManager).log(any(AuditLogableBase.class), any(AuditLogType.class));
}
#method_after
@Before
@SuppressWarnings("unchecked")
public void setupMocks() {
    MockitoAnnotations.initMocks(this);
    doReturn(macPoolManager).when(vmInterfaceManager).getMacPoolManager();
    doReturn(vmNetworkStatisticsDAO).when(vmInterfaceManager).getVmNetworkStatisticsDao();
    doReturn(vmNetworkInterfaceDAO).when(vmInterfaceManager).getVmNetworkInterfaceDao();
    doReturn(vmNicDao).when(vmInterfaceManager).getVmNicDao();
    doReturn(vmDAO).when(vmInterfaceManager).getVmDAO();
    doNothing().when(vmInterfaceManager).auditLogMacInUseUnplug(any(VmNic.class));
    doNothing().when(vmInterfaceManager).removeFromExternalNetworks(anyList());
    doNothing().when(vmInterfaceManager).log(any(AuditLogableBase.class), any(AuditLogType.class));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = isVmExist();
    if (retValue) {
        retValue = canRunActionOnNonManagedVm();
    }
    if (retValue && getVm().getStatus() != VMStatus.Up && getVm().getStatus() != VMStatus.Down) {
        retValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if (retValue) {
        disk = getDiskDao().get((Guid) getParameters().getEntityInfo().getId());
        retValue = isDiskExist(disk);
    }
    if (retValue) {
        vmDevice = getVmDeviceDao().get(new VmDeviceId(disk.getId(), getVmId()));
        if (vmDevice == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_DETACHED);
        }
    }
    if (retValue && Boolean.TRUE.equals(getParameters().isPlugUnPlug()) && getVm().getStatus() != VMStatus.Down) {
        retValue = isInterfaceSupportedForPlugUnPlug(disk);
    }
    if (retValue && Boolean.FALSE.equals(getParameters().isPlugUnPlug()) && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        retValue = false;
    }
    // Check if disk has no snapshots before detaching it.
    if (retValue && DiskStorageType.IMAGE == disk.getDiskStorageType() && getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId()).size() > 1) {
        addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_DISK_WITH_SNAPSHOT);
        retValue = false;
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = isVmExist();
    if (retValue) {
        retValue = canRunActionOnNonManagedVm();
    }
    if (retValue && getVm().getStatus() != VMStatus.Up && getVm().getStatus() != VMStatus.Down) {
        retValue = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(getVm().getStatus()));
    }
    if (retValue) {
        disk = loadDisk((Guid) getParameters().getEntityInfo().getId());
        retValue = isDiskExist(disk);
    }
    if (retValue) {
        vmDevice = getVmDeviceDao().get(new VmDeviceId(disk.getId(), getVmId()));
        if (vmDevice == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_DETACHED);
        }
        if (retValue && vmDevice.getSnapshotId() != null) {
            disk = loadDiskFromSnapshot(disk.getId(), vmDevice.getSnapshotId());
        }
    }
    if (retValue && Boolean.TRUE.equals(getParameters().isPlugUnPlug()) && getVm().getStatus() != VMStatus.Down) {
        retValue = isInterfaceSupportedForPlugUnPlug(disk);
    }
    if (retValue && Boolean.FALSE.equals(getParameters().isPlugUnPlug()) && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_NOT_DOWN);
        retValue = false;
    }
    // Check if disk has no snapshots before detaching it.
    if (retValue && DiskStorageType.IMAGE == disk.getDiskStorageType()) {
        // therefore for attached disk snapshot it shouldn't be checked whether it has snapshots or not.
        if (vmDevice.getSnapshotId() == null && getDiskImageDao().getAllSnapshotsForImageGroup(disk.getId()).size() > 1) {
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_DETACH_DISK_WITH_SNAPSHOT);
            retValue = false;
        }
    }
    return retValue;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (diskShouldBeUnPlugged()) {
        performPlugCommand(VDSCommandType.HotUnPlugDisk, disk, vmDevice);
    }
    getVmDeviceDao().remove(vmDevice.getId());
    // update cached image
    VmHandler.updateDisksFromDb(getVm());
    // update vm device boot order
    VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (diskShouldBeUnPlugged()) {
        performPlugCommand(VDSCommandType.HotUnPlugDisk, disk, vmDevice);
    }
    getVmDeviceDao().remove(vmDevice.getId());
    if (!disk.isDiskSnapshot()) {
        // clears snapshot ID
        getImageDao().updateImageVmSnapshotId(((DiskImage) disk).getImageId(), null);
    }
    // update cached image
    VmHandler.updateDisksFromDb(getVm());
    // update vm device boot order
    VmDeviceUtils.updateBootOrderInVmDeviceAndStoreToDB(getVm().getStaticData());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk && ((DiskImage) disk).getImageStatus() == ImageStatus.ILLEGAL) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
    }
    if (isImageDisk && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
        addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
        return false;
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isInterfaceSupportedForPlugUnPlug(disk);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (disk == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
    }
    if (isOperationPerformedOnDiskSnapshot() && (!validate(getSnapshotsValidator().snapshotExists(getSnapshot())) || !validate(getSnapshotsValidator().snapshotTypeSupported(getSnapshot(), Collections.singletonList(SnapshotType.REGULAR))))) {
        return false;
    }
    boolean isImageDisk = disk.getDiskStorageType() == DiskStorageType.IMAGE;
    if (isImageDisk) {
        // TODO : this load and check of the active disk will be removed
        // after inspecting upgrade
        Disk activeDisk = loadActiveDisk(disk.getId());
        if (((DiskImage) activeDisk).getImageStatus() == ImageStatus.ILLEGAL) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_ILLEGAL_DISK_OPERATION);
        }
        if (((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED);
            addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", disk.getDiskAlias()));
            return false;
        }
    }
    if (!isVmExist() || !isVmInUpPausedDownStatus()) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    updateDisksFromDb();
    if (!isDiskCanBeAddedToVm(disk, getVm()) || !isDiskPassPciAndIdeLimit(disk)) {
        return false;
    }
    if (getVmDeviceDao().exists(new VmDeviceId(disk.getId(), getVmId()))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_ALREADY_ATTACHED);
    }
    if (disk.isShareable() && !isVersionSupportedForShareable(disk, getStoragePoolDAO().get(getVm().getStoragePoolId()).getcompatibility_version().getValue())) {
        return failCanDoAction(VdcBllMessages.ACTION_NOT_SUPPORTED_FOR_CLUSTER_POOL_LEVEL);
    }
    if (!isOperationPerformedOnDiskSnapshot() && !disk.isShareable() && disk.getNumberOfVms() > 0) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NOT_SHAREABLE_DISK_ALREADY_ATTACHED);
    }
    if (isImageDisk && getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(((DiskImage) disk).getStorageIds().get(0), getVm().getStoragePoolId())) == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
    }
    if (isImageDisk) {
        StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(((DiskImage) disk).getStorageIds().get(0), ((DiskImage) disk).getStoragePoolId());
        StorageDomainValidator storageDomainValidator = new StorageDomainValidator(storageDomain);
        if (!validate(storageDomainValidator.isDomainExistAndActive())) {
            return false;
        }
    }
    DiskValidator diskValidator = getDiskValidator(disk);
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    if (!isVmNotInPreviewSnapshot()) {
        return false;
    }
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        return isInterfaceSupportedForPlugUnPlug(disk);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    final VmDevice vmDevice = createVmDevice();
    getVmDeviceDao().save(vmDevice);
    // update cached image
    List<Disk> imageList = new ArrayList<Disk>();
    imageList.add(disk);
    VmHandler.updateDisksForVm(getVm(), imageList);
    if (disk.isAllowSnapshot()) {
        updateDiskVmSnapshotId();
    }
    // update vm device boot order
    updateBootOrderInVmDevice();
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        performPlugCommand(VDSCommandType.HotPlugDisk, disk, vmDevice);
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!isOperationPerformedOnDiskSnapshot()) {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
    }
    final VmDevice vmDevice = createVmDevice();
    getVmDeviceDao().save(vmDevice);
    // update cached image
    List<Disk> imageList = new ArrayList<Disk>();
    imageList.add(disk);
    VmHandler.updateDisksForVm(getVm(), imageList);
    if (!isOperationPerformedOnDiskSnapshot()) {
        if (disk.isAllowSnapshot()) {
            updateDiskVmSnapshotId();
        }
    }
    // update vm device boot order
    updateBootOrderInVmDevice();
    if (getParameters().isPlugUnPlug() && getVm().getStatus() != VMStatus.Down) {
        performPlugCommand(VDSCommandType.HotPlugDisk, disk, vmDevice);
    }
    setSucceeded(true);
}
#end_block

#method_before
protected VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(disk.getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, getParameters().isPlugUnPlug(), false, "", null);
}
#method_after
protected VmDevice createVmDevice() {
    return new VmDevice(new VmDeviceId(disk.getId(), getVmId()), VmDeviceGeneralType.DISK, VmDeviceType.DISK.getName(), "", 0, null, true, getParameters().isPlugUnPlug(), false, "", null, getParameters().getSnapshotId());
}
#end_block

#method_before
protected void removeVmNetwork() {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    if (interfaces != null) {
        for (VmNic iface : interfaces) {
            MacPoolManager.getInstance().freeMac(iface.getMacAddress());
        }
    }
}
#method_after
protected void removeVmNetwork() {
    if (getInterfaces() != null) {
        for (VmNic iface : getInterfaces()) {
            MacPoolManager.getInstance().freeMac(iface.getMacAddress());
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDS vds = getVds();
    VDSGroup cluster = getVdsGroup();
    boolean vdsmVersionSupportedByEngine = false;
    // check that vdc support vds OR vds support vdc
    Version partialVdcVersion = new Version(new Version(Config.<String>GetValue(ConfigValues.VdcVersion)).toString(2));
    RpmVersion vdsVersion = vds.getVersion();
    Version vdsmVersion = new Version(vdsVersion.getMajor(), vdsVersion.getMinor());
    if (!StringUtils.isEmpty(vds.getSupportedEngines())) {
        vdsmVersionSupportedByEngine = vds.getSupportedENGINESVersionsSet().contains(partialVdcVersion);
    }
    // version is not supported
    if (!vdsmVersionSupportedByEngine && !Config.<HashSet<Version>>GetValue(ConfigValues.SupportedVDSMVersions).contains(vdsmVersion)) {
        reportNonOperationReason(NonOperationalReason.VERSION_INCOMPATIBLE_WITH_CLUSTER, Config.<HashSet<Version>>GetValue(ConfigValues.SupportedVDSMVersions).toString(), vdsmVersion.toString());
    } else if (!VersionSupport.checkClusterVersionSupported(cluster.getcompatibility_version(), vds)) {
        reportNonOperationReason(NonOperationalReason.CLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER, cluster.getcompatibility_version().toString(), vds.getSupportedClusterLevels().toString());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    VDS vds = getVds();
    VDSGroup cluster = getVdsGroup();
    boolean isEngineSupportedByVdsm = false;
    // partialVdcVersion will hold the engine's version (minor and major parts),
    // this will be compared to vdsm supported engines to see if vdsm can be added
    // to cluster
    Version partialVdcVersion = new Version(new Version(Config.<String>GetValue(ConfigValues.VdcVersion)).toString(2));
    RpmVersion vdsVersion = vds.getVersion();
    Version vdsmVersion = new Version(vdsVersion.getMajor(), vdsVersion.getMinor());
    if (!StringUtils.isEmpty(vds.getSupportedEngines())) {
        isEngineSupportedByVdsm = vds.getSupportedENGINESVersionsSet().contains(partialVdcVersion);
    }
    // and cluster supports the specific vdsm version. which is sufficient
    if (!isEngineSupportedByVdsm && !Config.<HashSet<Version>>GetValue(ConfigValues.SupportedVDSMVersions).contains(vdsmVersion)) {
        reportNonOperationReason(NonOperationalReason.VERSION_INCOMPATIBLE_WITH_CLUSTER, Config.<HashSet<Version>>GetValue(ConfigValues.SupportedVDSMVersions).toString(), vdsmVersion.toString());
    } else if (!VersionSupport.checkClusterVersionSupported(cluster.getcompatibility_version(), vds)) {
        reportNonOperationReason(NonOperationalReason.CLUSTER_VERSION_INCOMPATIBLE_WITH_CLUSTER, cluster.getcompatibility_version().toString(), vds.getSupportedClusterLevels().toString());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String resource = getMyParameter("resource", request);
    String format = getMyParameter("format", request);
    String alias = getMyParameter("alias", request);
    try {
        if (resource == null) {
            throw new IllegalArgumentException("Missing resource name");
        }
        Details details = pkiResources.get(resource);
        if (details == null) {
            throw new IllegalArgumentException(String.format("Resource %1$s is invalid", resource));
        }
        if (format == null) {
            format = details.format;
        }
        if (alias == null) {
            alias = details.alias;
        }
        try (InputStream in = new FileInputStream(details.file)) {
            final Certificate certificate = CertificateFactory.getInstance("X.509").generateCertificate(in);
            if (format.startsWith("X509-PEM")) {
                if (format.endsWith("-CA")) {
                    response.setContentType("application/x-x509-ca-cert");
                } else {
                    response.setContentType("application/x-x509-cert");
                }
                // do not let println to use platform specific new line
                response.getWriter().print(String.format(("-----BEGIN CERTIFICATE-----%1$c" + "%2$s" + "-----END CERTIFICATE-----%1$c"), '\n', new Base64(76, new byte[] { (byte) '\n' }).encodeToString(certificate.getEncoded())));
            } else if ("RFC4716".equals(format)) {
                response.setContentType("text/plain");
                // do not let println to use platform specific new line
                response.getWriter().print(OpenSSHUtils.getKeyString(certificate.getPublicKey(), alias));
            } else {
                throw new IllegalArgumentException(String.format("Unsupported output format %1$s", format));
            }
        }
    } catch (FileNotFoundException e) {
        log.error(String.format("Cannot send public key resource '%1$s' format '%2$s'", resource, format), e);
        response.sendError(HttpServletResponse.SC_NOT_FOUND, e.getMessage());
    } catch (Exception e) {
        log.error(String.format("Cannot send public key resource '%1$s' format '%2$s'", resource, format), e);
        response.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String resource = getMyParameter("resource", request);
    String format = getMyParameter("format", request);
    String alias = getMyParameter("alias", request);
    try {
        if (resource == null) {
            throw new IllegalArgumentException("Missing resource name");
        }
        Details details = pkiResources.get(resource);
        if (details == null) {
            throw new IllegalArgumentException(String.format("Resource '%1$s' is invalid", resource));
        }
        if (format == null) {
            format = details.format;
        }
        if (alias == null) {
            alias = details.alias;
        }
        try (InputStream in = new FileInputStream(details.file)) {
            final Certificate certificate = CertificateFactory.getInstance("X.509").generateCertificate(in);
            if (format.startsWith("X509-PEM")) {
                if (format.endsWith("-CA")) {
                    response.setContentType("application/x-x509-ca-cert");
                } else {
                    response.setContentType("application/x-x509-cert");
                }
                // do not let println to use platform specific new line
                response.getWriter().print(String.format(("-----BEGIN CERTIFICATE-----%1$c" + "%2$s" + "-----END CERTIFICATE-----%1$c"), '\n', new Base64(76, new byte[] { (byte) '\n' }).encodeToString(certificate.getEncoded())));
            } else if ("OPENSSH-PUBKEY".equals(format)) {
                response.setContentType("text/plain");
                // do not let println to use platform specific new line
                response.getWriter().print(OpenSSHUtils.getKeyString(certificate.getPublicKey(), alias));
            } else {
                throw new IllegalArgumentException(String.format("Unsupported output format '%1$s'", format));
            }
        }
    } catch (FileNotFoundException e) {
        log.error(String.format("Cannot send public key resource '%1$s' format '%2$s'", resource, format), e);
        response.sendError(HttpServletResponse.SC_NOT_FOUND, e.getMessage());
    } catch (Exception e) {
        log.error(String.format("Cannot send public key resource '%1$s' format '%2$s'", resource, format), e);
        response.sendError(HttpServletResponse.SC_BAD_REQUEST, e.getMessage());
    }
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    window.setMessage(ConstantsManager.getInstance().getConstants().virtualMachinesMsg());
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    window.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel window = new ConfirmationModel();
    setWindow(window);
    window.setTitle(ConstantsManager.getInstance().getConstants().removeVirtualMachinesTitle());
    // $NON-NLS-1$
    window.setHashName("remove_virtual_machine");
    vmsRemoveMap = new HashMap<Guid, EntityModel>();
    for (Object selectedItem : getSelectedItems()) {
        VM vm = (VM) selectedItem;
        EntityModel removeDisksCheckbox = new EntityModel(true);
        removeDisksCheckbox.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
        removeDisksCheckbox.setMessage(vm.getName());
        if (!Guid.Empty.equals(vm.getVmtGuid())) {
            updateRemoveDisksCheckBox(removeDisksCheckbox, true, false, ConstantsManager.getInstance().getConstants().removeVmDisksTemplateMsg());
        }
        vmsRemoveMap.put(vm.getId(), removeDisksCheckbox);
    }
    window.setItems(vmsRemoveMap.entrySet());
    initRemoveDisksCheckboxes(vmsRemoveMap);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    window.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    window.getCommands().add(tempVar2);
}
#end_block

#method_before
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType((VmType) model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    tempVar.setVmOs((Integer) model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    tempVar.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless((Boolean) model.getIsStateless().getEntity());
    tempVar.setRunAndPause(((Boolean) model.getIsRunAndPause().getEntity()));
    tempVar.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setVncKeyboardLayout(vm.getVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    newvm.setPriority((Integer) prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, (String) model.getName().getEntity(), (String) model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse((Boolean) model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions((Boolean) model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.RunAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#method_after
public void postNameUniqueCheck() {
    UnitVmModel model = (UnitVmModel) getWindow();
    VM vm = (VM) getSelectedItem();
    VM tempVar = new VM();
    tempVar.setId(vm.getId());
    tempVar.setVmType((VmType) model.getVmType().getSelectedItem());
    if (model.getQuota().getSelectedItem() != null) {
        tempVar.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    tempVar.setVmOs((Integer) model.getOSType().getSelectedItem());
    tempVar.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    tempVar.setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
    tempVar.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    // $NON-NLS-1$
    tempVar.setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    tempVar.setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    tempVar.setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    tempVar.setVdsGroupId(model.getSelectedCluster().getId());
    tempVar.setTimeZone(model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    tempVar.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    tempVar.setStateless((Boolean) model.getIsStateless().getEntity());
    tempVar.setRunAndPause(((Boolean) model.getIsRunAndPause().getEntity()));
    tempVar.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    tempVar.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    tempVar.setDefaultBootSequence(model.getBootSequence());
    tempVar.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    // $NON-NLS-1$
    tempVar.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    tempVar.setUsbPolicy(vm.getUsbPolicy());
    tempVar.setInitrdUrl(vm.getInitrdUrl());
    tempVar.setKernelUrl(vm.getKernelUrl());
    tempVar.setKernelParams(vm.getKernelParams());
    tempVar.setDedicatedVmForVds(vm.getDedicatedVmForVds());
    tempVar.setMigrationSupport(vm.getMigrationSupport());
    tempVar.setVncKeyboardLayout(vm.getVncKeyboardLayout());
    VM newvm = tempVar;
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    newvm.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    newvm.setPriority((Integer) prioritySelectedItem.getEntity());
    AddVmTemplateParameters addVmTemplateParameters = new AddVmTemplateParameters(newvm, (String) model.getName().getEntity(), (String) model.getDescription().getEntity());
    addVmTemplateParameters.setPublicUse((Boolean) model.getIsTemplatePublic().getEntity());
    addVmTemplateParameters.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
    addVmTemplateParameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    addVmTemplateParameters.setCopyVmPermissions((Boolean) model.getCopyPermissions().getEntity());
    model.startProgress(null);
    addVmTemplateParameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    Frontend.RunAction(VdcActionType.AddVmTemplate, addVmTemplateParameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VmListModel vmListModel = (VmListModel) result.getState();
            vmListModel.getWindow().stopProgress();
            VdcReturnValueBase returnValueBase = result.getReturnValue();
            if (returnValueBase != null && returnValueBase.getSucceeded()) {
                vmListModel.cancel();
            }
        }
    }, this);
}
#end_block

#method_before
private void run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        // use sysprep iff the vm is not initialized and vm has Win OS
        RunVmParams tempVar = new RunVmParams(a.getId());
        if (!a.isInitialized() && AsyncDataProvider.isWindowsOsType(a.getVmOsId())) {
            tempVar.setInitializationType(InitializationType.Sysprep);
        } else if (!a.isInitialized() && AsyncDataProvider.isLinuxOsType(a.getVmOsId())) {
            tempVar.setInitializationType(InitializationType.CloudInit);
        } else {
            tempVar.setInitializationType(InitializationType.None);
        }
        list.add(tempVar);
    }
    Frontend.RunMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
private void run() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VM a = (VM) item;
        list.add(new RunVmParams(a.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.RunVm, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void onSave() {
    final VmNetworkCreatingManager defaultNetworkCreatingManager = new VmNetworkCreatingManager(new VmNetworkCreatingManager.PostNetworkCreatedCallback() {

        @Override
        public void networkCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType((VmType) model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    getcurrentVm().setVmOs((Integer) model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription((String) model.getDescription().getEntity());
    getcurrentVm().setComment((String) model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless((Boolean) model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl((String) model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl((String) model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams((String) model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    getcurrentVm().setPriority((Integer) prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    getcurrentVm().setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmNetworkCreatingManager addVmFromScratchNetworkManager = new VmNetworkCreatingManager(new VmNetworkCreatingManager.PostNetworkCreatedCallback() {

                @Override
                public void networkCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, parameters, new NetworkCreateFrontendAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if ((Boolean) model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                        param.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        Frontend.RunAction(VdcActionType.AddVmFromTemplate, param, new NetworkCreateOrUpdateFrontendActionAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                        param.setCopyTemplatePermissions((Boolean) model.getCopyPermissions().getEntity());
                        ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                        parameters.add(param);
                        Frontend.RunMultipleAction(VdcActionType.AddVmFromTemplate, parameters, new IFrontendMultipleActionAsyncCallback() {

                            @Override
                            public void executed(FrontendMultipleActionAsyncResult result) {
                                VmListModel vmListModel1 = (VmListModel) result.getState();
                                vmListModel1.getWindow().stopProgress();
                                vmListModel1.cancel();
                            }
                        }, vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.RunAction(VdcActionType.AddVm, params, new NetworkCreateOrUpdateFrontendActionAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.RunAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        Frontend.RunAction(VdcActionType.UpdateVm, updateVmParams, new NetworkUpdateFrontendAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            Frontend.RunAction(VdcActionType.UpdateVm, updateVmParams, new NetworkUpdateFrontendAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#method_after
private void onSave() {
    final VmInterfaceCreatingManager defaultNetworkCreatingManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

        @Override
        public void vnicCreated(Guid vmId) {
            getWindow().stopProgress();
            cancel();
            updateActionAvailability();
        }

        @Override
        public void queryFailed() {
            getWindow().stopProgress();
            cancel();
        }
    });
    final UnitVmModel model = (UnitVmModel) getWindow();
    VM selectedItem = (VM) getSelectedItem();
    String name = (String) model.getName().getEntity();
    // Save changes.
    VmTemplate template = (VmTemplate) model.getTemplate().getSelectedItem();
    getcurrentVm().setVmType((VmType) model.getVmType().getSelectedItem());
    getcurrentVm().setVmtGuid(template.getId());
    getcurrentVm().setName(name);
    if (model.getQuota().getSelectedItem() != null) {
        getcurrentVm().setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    getcurrentVm().setVmOs((Integer) model.getOSType().getSelectedItem());
    getcurrentVm().setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    getcurrentVm().setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
    getcurrentVm().setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    getcurrentVm().setVmDescription((String) model.getDescription().getEntity());
    getcurrentVm().setComment((String) model.getComment().getEntity());
    getcurrentVm().setVmDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setVmMemSizeMb((Integer) model.getMemSize().getEntity());
    getcurrentVm().setMinAllocatedMem((Integer) model.getMinAllocatedMemory().getEntity());
    Guid newClusterID = model.getSelectedCluster().getId();
    getcurrentVm().setVdsGroupId(newClusterID);
    getcurrentVm().setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    getcurrentVm().setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    getcurrentVm().setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    getcurrentVm().setStateless((Boolean) model.getIsStateless().getEntity());
    getcurrentVm().setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    getcurrentVm().setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    getcurrentVm().setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    getcurrentVm().setDefaultBootSequence(model.getBootSequence());
    getcurrentVm().setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : // $NON-NLS-1$
    "");
    getcurrentVm().setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    getcurrentVm().setInitrdUrl((String) model.getInitrd_path().getEntity());
    getcurrentVm().setKernelUrl((String) model.getKernel_path().getEntity());
    getcurrentVm().setKernelParams((String) model.getKernel_parameters().getEntity());
    getcurrentVm().setCustomProperties(model.getCustomPropertySheet().getEntity());
    getcurrentVm().setBalloonEnabled(balloonEnabled(model));
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    getcurrentVm().setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    getcurrentVm().setPriority((Integer) prioritySelectedItem.getEntity());
    getcurrentVm().setCpuPinning((String) model.getCpuPinning().getEntity());
    getcurrentVm().setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    if (model.getCpuSharesAmount().getIsAvailable() && !model.getCpuSharesAmount().getEntity().toString().equals("")) {
        // $NON-NLS-1$
        try {
            getcurrentVm().setCpuShares(Integer.parseInt(model.getCpuSharesAmount().getEntity().toString()));
        } catch (NumberFormatException ignored) {
        }
    }
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        getcurrentVm().setDedicatedVmForVds(null);
    } else {
        VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
        getcurrentVm().setDedicatedVmForVds(defaultHost.getId());
    }
    getcurrentVm().setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    getcurrentVm().setUseHostCpuFlags((Boolean) model.getHostCpu().getEntity());
    if (model.getIsNew()) {
        if (getcurrentVm().getVmtGuid().equals(Guid.Empty)) {
            if (model.getProgress() != null) {
                return;
            }
            VmInterfaceCreatingManager addVmFromScratchNetworkManager = new VmInterfaceCreatingManager(new VmInterfaceCreatingManager.PostVnicCreatedCallback() {

                @Override
                public void vnicCreated(Guid vmId) {
                    getWindow().stopProgress();
                    cancel();
                    setGuideContext(vmId);
                    updateActionAvailability();
                    getGuideCommand().execute();
                }

                @Override
                public void queryFailed() {
                    getWindow().stopProgress();
                    cancel();
                }
            });
            model.startProgress(null);
            AddVmFromScratchParameters parameters = new AddVmFromScratchParameters(getcurrentVm(), new ArrayList<DiskImage>(), Guid.Empty);
            parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            parameters.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
            parameters.setBalloonEnabled(balloonEnabled(model));
            setVmWatchdogToParams(model, parameters);
            Frontend.RunAction(VdcActionType.AddVmFromScratch, parameters, new UnitVmModelNetworkAsyncCallback(model, addVmFromScratchNetworkManager), this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            if ((Boolean) model.getProvisioning().getEntity()) {
                model.startProgress(null);
                AsyncQuery _asyncQuery = new AsyncQuery();
                _asyncQuery.setModel(this);
                _asyncQuery.asyncCallback = new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model1, Object result1) {
                        VmListModel vmListModel = (VmListModel) model1;
                        UnitVmModel unitVmModel = (UnitVmModel) vmListModel.getWindow();
                        AddVmFromTemplateParameters param = new AddVmFromTemplateParameters(vmListModel.getcurrentVm(), unitVmModel.getDisksAllocationModel().getImageToDestinationDomainMap(), Guid.Empty);
                        param.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                        param.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
                        param.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
                        param.setBalloonEnabled(balloonEnabled(model));
                        param.setCopyTemplatePermissions((Boolean) model.getCopyPermissions().getEntity());
                        Frontend.RunAction(VdcActionType.AddVmFromTemplate, param, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), vmListModel);
                    }
                };
                AsyncDataProvider.getTemplateDiskList(_asyncQuery, template.getId());
            } else {
                if (model.getProgress() != null) {
                    return;
                }
                model.startProgress(null);
                VmManagementParametersBase params = new VmManagementParametersBase(getcurrentVm());
                params.setDiskInfoDestinationMap(model.getDisksAllocationModel().getImageToDestinationDomainMap());
                params.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
                params.setBalloonEnabled(balloonEnabled(model));
                params.setCopyTemplatePermissions((Boolean) model.getCopyPermissions().getEntity());
                ArrayList<VdcActionParametersBase> parameters = new ArrayList<VdcActionParametersBase>();
                parameters.add(params);
                params.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                params.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
                setVmWatchdogToParams(model, params);
                Frontend.RunAction(VdcActionType.AddVm, params, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager), this);
            }
        }
    } else // Update existing VM -> consists of editing VM cluster, and if succeeds - editing VM:
    {
        if (model.getProgress() != null) {
            return;
        }
        // explicitly pass non-editable field from the original VM
        getcurrentVm().setCreatedByUserId(selectedItem.getCreatedByUserId());
        // runEditVM: should be true if Cluster hasn't changed or if
        // Cluster has changed and Editing it in the Backend has succeeded:
        Guid oldClusterID = selectedItem.getVdsGroupId();
        if (oldClusterID.equals(newClusterID) == false) {
            ChangeVMClusterParameters parameters = new ChangeVMClusterParameters(newClusterID, getcurrentVm().getId());
            model.startProgress(null);
            Frontend.RunAction(VdcActionType.ChangeVMCluster, parameters, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    final VmListModel vmListModel = (VmListModel) result.getState();
                    VdcReturnValueBase returnValueBase = result.getReturnValue();
                    if (returnValueBase != null && returnValueBase.getSucceeded()) {
                        VmManagementParametersBase updateVmParams = new VmManagementParametersBase(vmListModel.getcurrentVm());
                        setVmWatchdogToParams(model, updateVmParams);
                        updateVmParams.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
                        updateVmParams.setBalloonEnabled(balloonEnabled(model));
                        updateVmParams.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
                        Frontend.RunAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, vmListModel.getcurrentVm().getId()), vmListModel);
                    } else {
                        vmListModel.getWindow().stopProgress();
                    }
                }
            }, this);
        } else {
            if (model.getProgress() != null) {
                return;
            }
            model.startProgress(null);
            VmManagementParametersBase updateVmParams = new VmManagementParametersBase(getcurrentVm());
            setVmWatchdogToParams(model, updateVmParams);
            updateVmParams.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
            updateVmParams.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
            updateVmParams.setBalloonEnabled(balloonEnabled(model));
            updateVmParams.setVirtioScsiEnabled((Boolean) model.getIsVirtioScsiEnabled().getEntity());
            Frontend.RunAction(VdcActionType.UpdateVm, updateVmParams, new UnitVmModelNetworkAsyncCallback(model, defaultNetworkCreatingManager, getcurrentVm().getId()), this);
        }
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.RunVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.StopVm));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#method_after
private void updateActionAvailability() {
    List items = getSelectedItems() != null && getSelectedItem() != null ? getSelectedItems() : new ArrayList();
    getEditCommand().setIsExecutionAllowed(isEditCommandExecutionAllowed(items));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RemoveVm));
    getRunCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVm));
    getPauseCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.HibernateVm));
    getShutdownCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ShutdownVm));
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.StopVm));
    getMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.MigrateVm));
    getCancelMigrateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CancelMigrateVm));
    getNewTemplateCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.AddVmTemplate));
    getRunOnceCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.RunVmOnce));
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ExportVm));
    getCreateSnapshotCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.CreateAllSnapshotsFromVm));
    getRetrieveIsoImagesCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getChangeCdCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VM.class, VdcActionType.ChangeDisk));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    getGuideCommand().setIsExecutionAllowed(getGuideContext() != null || (getSelectedItem() != null && getSelectedItems() != null && getSelectedItems().size() == 1));
    getConsoleConnectCommand().setIsExecutionAllowed(isConsoleCommandsExecutionAllowed());
    getEditConsoleCommand().setIsExecutionAllowed(isConsoleEditEnabled());
}
#end_block

#method_before
private void transmitMultipleQueries(final List<VdcOperation<?, ?>> queriesList) {
    if (queriesList.size() > 1 || (queriesList.size() == 1 && queriesList.get(0).getCallback() instanceof VdcOperationCallbackList)) {
        List<VdcQueryType> queryTypes = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> parameters = new ArrayList<VdcQueryParametersBase>();
        for (VdcOperation<?, ?> operation : queriesList) {
            queryTypes.add((VdcQueryType) operation.getOperation());
            parameters.add((VdcQueryParametersBase) operation.getParameter());
        }
        getService().RunMultipleQueries((ArrayList<VdcQueryType>) queryTypes, (ArrayList<VdcQueryParametersBase>) parameters, new AsyncCallback<ArrayList<VdcQueryReturnValue>>() {

            @Override
            public void onFailure(final Throwable exception) {
                Map<VdcOperationCallback<?, ?>, List<VdcOperation<?, ?>>> callbackMap = getCallbackMap(queriesList);
                for (VdcOperationCallback<?, ?> callback : callbackMap.keySet()) {
                    if (callback instanceof VdcOperationCallbackList) {
                        ((VdcOperationCallbackList) callback).onFailure(callbackMap.get(callback), exception);
                    } else {
                        ((VdcOperationCallback) callback).onFailure(callbackMap.get(callback).get(0), exception);
                    }
                }
            }

            @Override
            public void onSuccess(final ArrayList<VdcQueryReturnValue> result) {
                Map<VdcOperationCallback<?, ?>, List<VdcOperation<?, ?>>> callbackMap = getCallbackMap(queriesList);
                for (VdcOperationCallback<?, ?> callback : callbackMap.keySet()) {
                    List<VdcQueryReturnValue> queryResult = (List<VdcQueryReturnValue>) getOperationResult(callbackMap.get(callback), queriesList, result);
                    if (callback instanceof VdcOperationCallbackList) {
                        ((VdcOperationCallbackList) callback).onSuccess(callbackMap.get(callback), queryResult);
                    } else {
                        ((VdcOperationCallback) callback).onSuccess(callbackMap.get(callback).get(0), queryResult.get(0));
                    }
                }
            }
        });
    } else {
        transmitOperation(queriesList.get(0));
    }
}
#method_after
private void transmitMultipleQueries(final List<VdcOperation<?, ?>> queriesList) {
    if (queriesList.size() > 1 || (queriesList.size() == 1 && queriesList.get(0).getCallback() instanceof VdcOperationCallbackList)) {
        List<VdcQueryType> queryTypes = new ArrayList<VdcQueryType>();
        List<VdcQueryParametersBase> parameters = new ArrayList<VdcQueryParametersBase>();
        for (VdcOperation<?, ?> operation : new ArrayList<VdcOperation<?, ?>>(queriesList)) {
            if (operation.isPublic()) {
                queriesList.remove(operation);
                runPublicQuery(operation);
            } else {
                queryTypes.add((VdcQueryType) operation.getOperation());
                parameters.add((VdcQueryParametersBase) operation.getParameter());
            }
        }
        getService().RunMultipleQueries((ArrayList<VdcQueryType>) queryTypes, (ArrayList<VdcQueryParametersBase>) parameters, new AsyncCallback<ArrayList<VdcQueryReturnValue>>() {

            @Override
            public void onFailure(final Throwable exception) {
                Map<VdcOperationCallback<?, ?>, List<VdcOperation<?, ?>>> callbackMap = getCallbackMap(queriesList);
                for (VdcOperationCallback<?, ?> callback : callbackMap.keySet()) {
                    if (callback instanceof VdcOperationCallbackList) {
                        ((VdcOperationCallbackList) callback).onFailure(callbackMap.get(callback), exception);
                    } else {
                        ((VdcOperationCallback) callback).onFailure(callbackMap.get(callback).get(0), exception);
                    }
                }
            }

            @Override
            public void onSuccess(final ArrayList<VdcQueryReturnValue> result) {
                Map<VdcOperationCallback<?, ?>, List<VdcOperation<?, ?>>> callbackMap = getCallbackMap(queriesList);
                for (VdcOperationCallback<?, ?> callback : callbackMap.keySet()) {
                    List<VdcQueryReturnValue> queryResult = (List<VdcQueryReturnValue>) getOperationResult(callbackMap.get(callback), queriesList, result);
                    if (callback instanceof VdcOperationCallbackList) {
                        ((VdcOperationCallbackList) callback).onSuccess(callbackMap.get(callback), queryResult);
                    } else {
                        ((VdcOperationCallback) callback).onSuccess(callbackMap.get(callback).get(0), queryResult.get(0));
                    }
                }
            }
        });
    } else {
        transmitOperation(queriesList.get(0));
    }
}
#end_block

#method_before
List<?> getOperationResult(final List<VdcOperation<?, ?>> operationList, final List<VdcOperation<?, ?>> allOperations, final List<?> allResults) {
    List result = new ArrayList();
    for (VdcOperation<?, ?> operation : operationList) {
        int index = allOperations.indexOf(operation);
        if (index > -1) {
            result.add(allResults.get(index));
        }
    }
    return result;
}
#method_after
List<?> getOperationResult(final List<VdcOperation<?, ?>> operationList, final List<VdcOperation<?, ?>> allOperations, final List<?> allResults) {
    List result = new ArrayList();
    for (VdcOperation<?, ?> operation : operationList) {
        int index = allOperations.indexOf(operation);
        if (index > -1 && index < allResults.size()) {
            result.add(allResults.get(index));
        }
    }
    return result;
}
#end_block

#method_before
@Override
public void logout(final Object userObject, final VdcUserCallback callback) {
    getService().logOff((VdcUser) userObject, new AsyncCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            callback.onSuccess(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            callback.onFailure(caught);
        }
    });
}
#method_after
@Override
public void logout(final Object userObject, final UserCallback callback) {
    getService().logOff((DbUser) userObject, new AsyncCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            callback.onSuccess(result);
        }

        @Override
        public void onFailure(final Throwable caught) {
            callback.onFailure(caught);
        }
    });
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeTemplatesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_template");
    model.setMessage(ConstantsManager.getInstance().getConstants().templatesMsg());
    ArrayList<String> items = new ArrayList<String>();
    ArrayList<VmTemplate> templates = Linq.<VmTemplate>cast(getSelectedItems());
    for (VmTemplate template : templates) {
        if (!template.getId().equals(Guid.Empty)) {
            items.add(template.getName());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeTemplatesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_template");
    ArrayList<String> items = new ArrayList<String>();
    ArrayList<VmTemplate> templates = Linq.<VmTemplate>cast(getSelectedItems());
    for (VmTemplate template : templates) {
        if (!template.getId().equals(Guid.Empty)) {
            items.add(template.getName());
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void postNameUniqueCheck(boolean isNameUnique) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem = (VmTemplate) getSelectedItem();
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    String name = (String) model.getName().getEntity();
    // Check name unicitate.
    if (!isNameUnique && name.compareToIgnoreCase(template.getName()) != 0) {
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.getName().setIsValid(false);
        model.setIsGeneralTabValid(false);
        return;
    }
    // Save changes.
    template.setVmType((VmType) model.getVmType().getSelectedItem());
    template.setName(name);
    template.setOsId((Integer) model.getOSType().getSelectedItem());
    template.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    template.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    template.setDescription((String) model.getDescription().getEntity());
    template.setComment((String) model.getComment().getEntity());
    // $NON-NLS-1$
    template.setDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    template.setMemSizeMb((Integer) model.getMemSize().getEntity());
    template.setMinAllocatedMem(((Integer) model.getMinAllocatedMemory().getEntity()));
    template.setVdsGroupId((model.getSelectedCluster()).getId());
    template.setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    template.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    template.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    template.setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    template.setStateless((Boolean) model.getIsStateless().getEntity());
    template.setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    template.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    template.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    template.setDefaultBootSequence(model.getBootSequence());
    // $NON-NLS-1$
    template.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    template.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    template.setKernelUrl((String) model.getKernel_path().getEntity());
    template.setKernelParams((String) model.getKernel_parameters().getEntity());
    template.setInitrdUrl((String) model.getInitrd_path().getEntity());
    template.setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        template.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    template.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    template.setPriority((Integer) prioritySelectedItem.getEntity());
    // host migration configuration
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        template.setDedicatedVmForVds(null);
    } else {
        template.setDedicatedVmForVds(defaultHost.getId());
    }
    template.setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    model.startProgress(null);
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    Frontend.RunAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#method_after
public void postNameUniqueCheck(boolean isNameUnique) {
    final UnitVmModel model = (UnitVmModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VmTemplate selectedItem = (VmTemplate) getSelectedItem();
    final VmTemplate template = (VmTemplate) Cloner.clone(selectedItem);
    String name = (String) model.getName().getEntity();
    // Check name unicitate.
    if (!isNameUnique && name.compareToIgnoreCase(template.getName()) != 0) {
        model.getName().getInvalidityReasons().add(ConstantsManager.getInstance().getConstants().nameMustBeUniqueInvalidReason());
        model.getName().setIsValid(false);
        model.setIsGeneralTabValid(false);
        return;
    }
    // Save changes.
    template.setVmType((VmType) model.getVmType().getSelectedItem());
    template.setName(name);
    template.setOsId((Integer) model.getOSType().getSelectedItem());
    template.setNumOfMonitors((Integer) model.getNumOfMonitors().getSelectedItem());
    template.setAllowConsoleReconnect((Boolean) model.getAllowConsoleReconnect().getEntity());
    template.setDescription((String) model.getDescription().getEntity());
    template.setComment((String) model.getComment().getEntity());
    // $NON-NLS-1$
    template.setDomain(model.getDomain().getIsAvailable() ? (String) model.getDomain().getSelectedItem() : "");
    template.setMemSizeMb((Integer) model.getMemSize().getEntity());
    template.setMinAllocatedMem(((Integer) model.getMinAllocatedMemory().getEntity()));
    template.setVdsGroupId((model.getSelectedCluster()).getId());
    template.setTimeZone((model.getTimeZone().getIsAvailable() && model.getTimeZone().getSelectedItem() != null) ? ((TimeZoneModel) model.getTimeZone().getSelectedItem()).getTimeZoneKey() : // $NON-NLS-1$
    "");
    template.setNumOfSockets((Integer) model.getNumOfSockets().getSelectedItem());
    template.setCpuPerSocket(Integer.parseInt(model.getTotalCPUCores().getEntity().toString()) / (Integer) model.getNumOfSockets().getSelectedItem());
    template.setUsbPolicy((UsbPolicy) model.getUsbPolicy().getSelectedItem());
    template.setStateless((Boolean) model.getIsStateless().getEntity());
    template.setRunAndPause((Boolean) model.getIsRunAndPause().getEntity());
    template.setDeleteProtected((Boolean) model.getIsDeleteProtected().getEntity());
    template.setSmartcardEnabled((Boolean) model.getIsSmartcardEnabled().getEntity());
    template.setDefaultBootSequence(model.getBootSequence());
    // $NON-NLS-1$
    template.setIsoPath(model.getCdImage().getIsChangable() ? (String) model.getCdImage().getSelectedItem() : "");
    template.setAutoStartup((Boolean) model.getIsHighlyAvailable().getEntity());
    template.setKernelUrl((String) model.getKernel_path().getEntity());
    template.setKernelParams((String) model.getKernel_parameters().getEntity());
    template.setInitrdUrl((String) model.getInitrd_path().getEntity());
    template.setVncKeyboardLayout((String) model.getVncKeyboardLayout().getSelectedItem());
    template.setCreatedByUserId(selectedItem.getCreatedByUserId());
    template.setSingleQxlPci((Boolean) model.getIsSingleQxlEnabled().getEntity());
    if (model.getQuota().getIsAvailable() && model.getQuota().getSelectedItem() != null) {
        template.setQuotaId(((Quota) model.getQuota().getSelectedItem()).getId());
    }
    EntityModel displayProtocolSelectedItem = (EntityModel) model.getDisplayProtocol().getSelectedItem();
    template.setDefaultDisplayType((DisplayType) displayProtocolSelectedItem.getEntity());
    EntityModel prioritySelectedItem = (EntityModel) model.getPriority().getSelectedItem();
    template.setPriority((Integer) prioritySelectedItem.getEntity());
    // host migration configuration
    VDS defaultHost = (VDS) model.getDefaultHost().getSelectedItem();
    if ((Boolean) model.getIsAutoAssign().getEntity()) {
        template.setDedicatedVmForVds(null);
    } else {
        template.setDedicatedVmForVds(defaultHost.getId());
    }
    template.setMigrationSupport((MigrationSupport) model.getMigrationMode().getSelectedItem());
    model.startProgress(null);
    UpdateVmTemplateParameters parameters = new UpdateVmTemplateParameters(template);
    parameters.setConsoleEnabled((Boolean) model.getIsConsoleDeviceEnabled().getEntity());
    setVmWatchdogToParams(model, parameters);
    parameters.setSoundDeviceEnabled((Boolean) model.getIsSoundcardEnabled().getEntity());
    Frontend.RunAction(VdcActionType.UpdateVmTemplate, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            TemplateListModel localModel = (TemplateListModel) result.getState();
            localModel.postUpdateVmTemplate(result.getReturnValue());
        }
    }, this);
}
#end_block

#method_before
protected void updateActionAvailability() {
    VmTemplate item = (VmTemplate) getSelectedItem();
    ArrayList items = (((ArrayList) getSelectedItems()) != null) ? (ArrayList) getSelectedItems() : new ArrayList();
    boolean blankSelected = isBlankTemplateSelected();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && item != null && item.getStatus() != VmTemplateStatus.Locked);
    if (getEditCommand().getIsExecutionAllowed() && blankSelected) {
        getEditCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeEdited());
        getEditCommand().setIsExecutionAllowed(false);
    }
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VmTemplate.class, VdcActionType.RemoveVmTemplate));
    if (getRemoveCommand().getIsExecutionAllowed() && blankSelected) {
        getRemoveCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeRemoved());
        getRemoveCommand().setIsExecutionAllowed(false);
    }
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VmTemplate.class, VdcActionType.ExportVmTemplate));
    if (getExportCommand().getIsExecutionAllowed() && blankSelected) {
        getExportCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeExported());
        getExportCommand().setIsExecutionAllowed(false);
    }
}
#method_after
protected void updateActionAvailability() {
    VmTemplate item = (VmTemplate) getSelectedItem();
    ArrayList items = (((ArrayList) getSelectedItems()) != null) ? (ArrayList) getSelectedItems() : new ArrayList();
    boolean blankSelected = isBlankTemplateSelected();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && item != null && item.getStatus() != VmTemplateStatus.Locked);
    if (getEditCommand().getIsExecutionAllowed() && blankSelected) {
        getEditCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeEdited());
        getEditCommand().setIsExecutionAllowed(false);
    }
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VmTemplate.class, VdcActionType.RemoveVmTemplate));
    if (getRemoveCommand().getIsExecutionAllowed() && blankSelected) {
        getRemoveCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeRemoved());
        getRemoveCommand().setIsExecutionAllowed(false);
    }
    getExportCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VmTemplate.class, VdcActionType.ExportVmTemplate));
    if (getExportCommand().getIsExecutionAllowed() && blankSelected) {
        getExportCommand().getExecuteProhibitionReasons().add(ConstantsManager.getInstance().getConstants().blankTemplateCannotBeExported());
        getExportCommand().setIsExecutionAllowed(false);
    }
}
#end_block

#method_before
public void runQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback, final boolean isPublic) {
    initQueryParamsFilter(parameters);
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryType, parameters, isPublic, new VdcOperationCallback<VdcOperation<VdcQueryType, VdcQueryParametersBase>, VdcQueryReturnValue>() {

        @Override
        public void onSuccess(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final VdcQueryReturnValue result) {
            try {
                if (!result.getSucceeded()) {
                    logger.log(Level.WARNING, // $NON-NLS-1$
                    "Failure while invoking ReturnQuery [" + result.getExceptionString() + // $NON-NLS-1$
                    "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        // getEventsHandler().runQueryFailed(failedResult);
                        String errorMessage = result.getExceptionString();
                        handleNotLoggedInEvent(errorMessage);
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().onSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                }
            } finally {
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.getDel().onSuccess(callback.getModel(), null);
                }
            } finally {
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }
    });
    // raise the query started event.
    raiseQueryStartedEvent(queryType, callback.getContext());
    if (isPublic) {
        getInstance().getOperationManager().addPublicOperation(operation);
    } else {
        getInstance().getOperationManager().addOperation(operation);
    }
}
#method_after
public void runQuery(final VdcQueryType queryType, final VdcQueryParametersBase parameters, final AsyncQuery callback, final boolean isPublic) {
    initQueryParamsFilter(parameters);
    final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation = new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryType, parameters, isPublic, new VdcOperationCallback<VdcOperation<VdcQueryType, VdcQueryParametersBase>, VdcQueryReturnValue>() {

        @Override
        public void onSuccess(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final VdcQueryReturnValue result) {
            try {
                if (!result.getSucceeded()) {
                    logger.log(Level.WARNING, // $NON-NLS-1$
                    "Failure while invoking runQuery [" + result.getExceptionString() + // $NON-NLS-1$
                    "]");
                    if (getEventsHandler() != null) {
                        ArrayList<VdcQueryReturnValue> failedResult = new ArrayList<VdcQueryReturnValue>();
                        failedResult.add(result);
                        // getEventsHandler().runQueryFailed(failedResult);
                        String errorMessage = result.getExceptionString();
                        handleNotLoggedInEvent(errorMessage);
                    }
                    if (callback.isHandleFailure()) {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                } else {
                    callback.setOriginalReturnValue(result);
                    if (callback.getConverter() != null) {
                        callback.getDel().onSuccess(callback.getModel(), callback.getConverter().Convert(result.getReturnValue(), callback));
                    } else {
                        callback.getDel().onSuccess(callback.getModel(), result);
                    }
                }
            } finally {
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcQueryType, VdcQueryParametersBase> operation, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runQuery: " + caught, caught);
                getEventsHandler().runQueryFailed(null);
                failureEventHandler(caught);
                if (callback.isHandleFailure()) {
                    callback.getDel().onSuccess(callback.getModel(), null);
                }
            } finally {
                raiseQueryCompleteEvent(queryType, callback.getContext());
            }
        }
    });
    // raise the query started event.
    raiseQueryStartedEvent(queryType, callback.getContext());
    if (isPublic) {
        getInstance().getOperationManager().addPublicOperation(operation);
    } else {
        getInstance().getOperationManager().addOperation(operation);
    }
}
#end_block

#method_before
public void runMultipleQueries(final List<VdcQueryType> queryTypeList, final List<VdcQueryParametersBase> queryParamsList, final IFrontendMultipleQueryAsyncCallback callback, final String context) {
    VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final List<VdcQueryReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from RunMultipleQueries!");
            FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, resultObject);
            callback.executed(f);
            raiseQueryCompleteEvent(queryTypeList, context);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute RunPublicQuery: " + caught, caught);
                FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, null);
                failureEventHandler(caught);
                callback.executed(f);
            } finally {
                raiseQueryCompleteEvent(queryTypeList, context);
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (int i = 0; i < queryTypeList.size(); i++) {
        VdcQueryParametersBase parameters = queryParamsList.get(i);
        // Why do we do this?
        parameters.setRefresh(false);
        initQueryParamsFilter(parameters);
        operationList.add(new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryTypeList.get(i), parameters, multiCallback));
    }
    raiseQueryStartedEvent(queryTypeList, context);
    getInstance().getOperationManager().addOperationList(operationList);
}
#method_after
public void runMultipleQueries(final List<VdcQueryType> queryTypeList, final List<VdcQueryParametersBase> queryParamsList, final IFrontendMultipleQueryAsyncCallback callback, final String context) {
    VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcQueryType, VdcQueryParametersBase>, List<VdcQueryReturnValue>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final List<VdcQueryReturnValue> resultObject) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from runMultipleQueries!");
            FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, resultObject);
            callback.executed(f);
            raiseQueryCompleteEvent(queryTypeList, context);
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcQueryType, VdcQueryParametersBase>> operationList, final Throwable caught) {
            try {
                if (ignoreFailure(caught)) {
                    return;
                }
                // $NON-NLS-1$
                logger.log(Level.SEVERE, "Failed to execute runMultipleQueries: " + caught, caught);
                FrontendMultipleQueryAsyncResult f = new FrontendMultipleQueryAsyncResult(queryTypeList, queryParamsList, null);
                failureEventHandler(caught);
                callback.executed(f);
            } finally {
                raiseQueryCompleteEvent(queryTypeList, context);
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (int i = 0; i < queryTypeList.size(); i++) {
        VdcQueryParametersBase parameters = queryParamsList.get(i);
        // Why do we do this?
        parameters.setRefresh(false);
        initQueryParamsFilter(parameters);
        operationList.add(new VdcOperation<VdcQueryType, VdcQueryParametersBase>(queryTypeList.get(i), parameters, multiCallback));
    }
    raiseQueryStartedEvent(queryTypeList, context);
    getInstance().getOperationManager().addOperationList(operationList);
}
#end_block

#method_before
public void runAction(final VdcActionType actionType, final VdcActionParametersBase parameters, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameters, new VdcOperationCallback<VdcOperation<VdcActionType, VdcActionParametersBase>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Frontend: sucessfully executed RunAction, determining result!");
            handleActionResult(actionType, parameters, result, callback != null ? callback : NULLABLE_ASYNC_CALLBACK, state, showErrorDialog);
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunAction: " + caught, caught);
            failureEventHandler(caught);
            FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, null, state);
            if (callback != null) {
                callback.executed(f);
            }
        }
    });
    getInstance().getOperationManager().addOperation(operation);
}
#method_after
public void runAction(final VdcActionType actionType, final VdcActionParametersBase parameters, final IFrontendActionAsyncCallback callback, final Object state, final boolean showErrorDialog) {
    VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameters, new VdcOperationCallback<VdcOperation<VdcActionType, VdcActionParametersBase>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Frontend: sucessfully executed runAction, determining result!");
            handleActionResult(actionType, parameters, result, callback != null ? callback : NULLABLE_ASYNC_CALLBACK, state, showErrorDialog);
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, VdcActionParametersBase> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runAction: " + caught, caught);
            failureEventHandler(caught);
            FrontendActionAsyncResult f = new FrontendActionAsyncResult(actionType, parameters, null, state);
            if (callback != null) {
                callback.executed(f);
            }
        }
    });
    getInstance().getOperationManager().addOperation(operation);
}
#end_block

#method_before
public void runMultipleAction(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final boolean isRunOnlyIfAllCanDoPass, final IFrontendMultipleActionAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operationList, final List<VdcReturnValueBase> resultObject) {
            // $NON-NLS-1$
            logger.finer("Frontend: successfully executed RunAction, determining result!");
            ArrayList<VdcReturnValueBase> failed = new ArrayList<VdcReturnValueBase>();
            for (VdcReturnValueBase v : resultObject) {
                if (!v.getCanDoAction()) {
                    failed.add(v);
                }
            }
            if (!failed.isEmpty()) {
                translateErrors(failed);
                getEventsHandler().runMultipleActionFailed(actionType, failed);
            }
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, resultObject, state));
            }
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunAction: " + caught, caught);
            failureEventHandler(caught);
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, null, state));
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (VdcActionParametersBase parameter : parameters) {
        VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameter, multiCallback);
        operationList.add(operation);
    }
    getInstance().getOperationManager().addOperationList(operationList);
}
#method_after
public void runMultipleAction(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final boolean isRunOnlyIfAllCanDoPass, final IFrontendMultipleActionAsyncCallback callback, final Object state) {
    VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>> multiCallback = new VdcOperationCallbackList<VdcOperation<VdcActionType, VdcActionParametersBase>, List<VdcReturnValueBase>>() {

        @Override
        public void onSuccess(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operationList, final List<VdcReturnValueBase> resultObject) {
            // $NON-NLS-1$
            logger.finer("Frontend: successfully executed runMultipleAction, determining result!");
            ArrayList<VdcReturnValueBase> failed = new ArrayList<VdcReturnValueBase>();
            for (VdcReturnValueBase v : resultObject) {
                if (!v.getCanDoAction()) {
                    failed.add(v);
                }
            }
            if (!failed.isEmpty()) {
                translateErrors(failed);
                getEventsHandler().runMultipleActionFailed(actionType, failed);
            }
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, resultObject, state));
            }
        }

        @Override
        public void onFailure(final List<VdcOperation<VdcActionType, VdcActionParametersBase>> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute runMultipleAction: " + caught, caught);
            failureEventHandler(caught);
            if (callback != null) {
                callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, null, state));
            }
        }
    };
    List<VdcOperation<?, ?>> operationList = new ArrayList<VdcOperation<?, ?>>();
    for (VdcActionParametersBase parameter : parameters) {
        VdcOperation<VdcActionType, VdcActionParametersBase> operation = new VdcOperation<VdcActionType, VdcActionParametersBase>(actionType, parameter, multiCallback);
        operationList.add(operation);
    }
    if (operationList.isEmpty()) {
        // it ourselves.
        if (scheduler == null) {
            scheduler = Scheduler.get();
        }
        scheduler.scheduleDeferred(new ScheduledCommand() {

            @Override
            public void execute() {
                if (callback != null) {
                    List<VdcReturnValueBase> emptyResult = new ArrayList<VdcReturnValueBase>();
                    callback.executed(new FrontendMultipleActionAsyncResult(actionType, parameters, emptyResult, state));
                }
            }
        });
    } else {
        getOperationManager().addOperationList(operationList);
    }
}
#end_block

#method_before
@Deprecated
public static void RunMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state) {
    getInstance().runMultipleActions(actionTypes, parameters, callbacks, failureCallback, state);
}
#method_after
public static void RunMultipleActions(VdcActionType actionType, List<VdcActionParametersBase> parameters, List<IFrontendActionAsyncCallback> callbacks) {
    RunMultipleActions(actionType, parameters, callbacks, null);
}
#end_block

#method_before
@Deprecated
public static void RunMultipleActions(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final IFrontendActionAsyncCallback successCallback, final Object state) {
    if (parameters == null || parameters.isEmpty()) {
        return;
    }
    int n = parameters.size();
    VdcActionType[] actionTypes = new VdcActionType[n];
    IFrontendActionAsyncCallback[] callbacks = new IFrontendActionAsyncCallback[n];
    Arrays.fill(actionTypes, actionType);
    callbacks[n - 1] = successCallback;
    RunMultipleActions(new LinkedList<VdcActionType>(Arrays.asList(actionTypes)), parameters, new LinkedList<IFrontendActionAsyncCallback>(Arrays.asList(callbacks)), null, state);
}
#method_after
@Deprecated
public static void RunMultipleActions(final VdcActionType actionType, final List<VdcActionParametersBase> parameters, final IFrontendActionAsyncCallback successCallback, final Object state) {
    if (parameters == null || parameters.isEmpty()) {
        return;
    }
    int n = parameters.size();
    IFrontendActionAsyncCallback[] callbacks = new IFrontendActionAsyncCallback[n];
    callbacks[n - 1] = successCallback;
    RunMultipleActions(actionType, parameters, new LinkedList<IFrontendActionAsyncCallback>(Arrays.asList(callbacks)), state);
}
#end_block

#method_before
public void loginAsync(final String userName, final String password, final String domain, final boolean isAdmin, final AsyncQuery callback) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async Login.");
    LoginUserParameters params = new LoginUserParameters(userName, password, domain, null, null, null);
    VdcActionType action = isAdmin ? VdcActionType.LoginAdminUser : VdcActionType.LoginUser;
    VdcOperation<VdcActionType, LoginUserParameters> loginOperation = new // Public action.
    VdcOperation<VdcActionType, LoginUserParameters>(// Public action.
    action, // Public action.
    params, // Public action.
    true, new VdcOperationCallback<VdcOperation<VdcActionType, LoginUserParameters>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, LoginUserParameters> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from Login.");
            getInstance().setLoggedInUser((VdcUser) result.getActionReturnValue());
            callback.getDel().onSuccess(callback.getModel(), result);
            if (getInstance().getLoginHandler() != null && result.getSucceeded()) {
                getInstance().getLoginHandler().onLoginSuccess(userName, password, domain);
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, LoginUserParameters> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            if (callback.isHandleFailure()) {
                getInstance().setLoggedInUser(null);
                callback.getDel().onSuccess(callback.getModel(), null);
            }
        }
    });
    getInstance().getOperationManager().loginUser(loginOperation);
}
#method_after
public void loginAsync(final String userName, final String password, final String domain, final boolean isAdmin, final AsyncQuery callback) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async Login.");
    LoginUserParameters params = new LoginUserParameters(userName, password, domain, null, null, null);
    VdcActionType action = isAdmin ? VdcActionType.LoginAdminUser : VdcActionType.LoginUser;
    VdcOperation<VdcActionType, LoginUserParameters> loginOperation = new // Public action.
    VdcOperation<VdcActionType, LoginUserParameters>(// Public action.
    action, // Public action.
    params, // Public action.
    true, new VdcOperationCallback<VdcOperation<VdcActionType, LoginUserParameters>, VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcOperation<VdcActionType, LoginUserParameters> operation, final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from Login.");
            getInstance().setLoggedInUser((DbUser) result.getActionReturnValue());
            result.setCanDoActionMessages((ArrayList<String>) translateError(result));
            callback.getDel().onSuccess(callback.getModel(), result);
            if (getInstance().getLoginHandler() != null && result.getSucceeded()) {
                getInstance().getLoginHandler().onLoginSuccess(userName, password, domain);
            }
        }

        @Override
        public void onFailure(final VdcOperation<VdcActionType, LoginUserParameters> operation, final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to login: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            clearLoggedInUser();
            if (callback.isHandleFailure()) {
                getInstance().setLoggedInUser(null);
                callback.getDel().onSuccess(callback.getModel(), null);
            }
        }
    });
    getInstance().getOperationManager().loginUser(loginOperation);
}
#end_block

#method_before
@Deprecated
public static void LogoffAsync(final VdcUser vdcUser, final AsyncQuery callback) {
    getInstance().logoffAsync(vdcUser, callback);
}
#method_after
@Deprecated
public static void LogoffAsync(final DbUser dbUser, final AsyncQuery callback) {
    getInstance().logoffAsync(dbUser, callback);
}
#end_block

#method_before
public void logoffAsync(final VdcUser vdcUser, final AsyncQuery callback) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async Logoff.");
    getInstance().getOperationManager().logoutUser(vdcUser, new VdcUserCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from Logoff.");
            callback.getDel().onSuccess(callback.getModel(), result);
            if (getInstance().getLoginHandler() != null) {
                getInstance().getLoginHandler().onLogout();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute Logoff: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            callback.getDel().onSuccess(callback.getModel(), null);
        }
    });
}
#method_after
public void logoffAsync(final DbUser dbUser, final AsyncQuery callback) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async logoff.");
    getInstance().getOperationManager().logoutUser(dbUser, new UserCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from logoff.");
            callback.getDel().onSuccess(callback.getModel(), result);
            if (getInstance().getLoginHandler() != null) {
                getInstance().getLoginHandler().onLogout();
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute logoff: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            callback.getDel().onSuccess(callback.getModel(), null);
        }
    });
}
#end_block

#method_before
public VdcUser getLoggedInUser() {
    return currentUser;
}
#method_after
public DbUser getLoggedInUser() {
    return currentUser;
}
#end_block

#method_before
public void setLoggedInUser(final VdcUser loggedInUser) {
    this.currentUser = loggedInUser;
    if (currentUser != null) {
        getOperationManager().setLoggedIn(true);
    } else {
        getOperationManager().setLoggedIn(false);
    }
}
#method_after
public void setLoggedInUser(final DbUser loggedInUser) {
    this.currentUser = loggedInUser;
    if (currentUser != null) {
        getOperationManager().setLoggedIn(true);
    } else {
        getOperationManager().setLoggedIn(false);
    }
}
#end_block

#method_before
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    bindEventBus();
    bind(GenericApiGWTServiceAsync.class).asEagerSingleton();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(OperationProcessor.class).asEagerSingleton();
    bind(VdcOperationManager.class).asEagerSingleton();
    bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
    bind(Frontend.class).asEagerSingleton();
    bind(RootPresenter.class).asEagerSingleton();
    bind(PlaceManager.class).to(placeManager).in(Singleton.class);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
    bind(AppErrors.class).in(Singleton.class);
    bind(VdsmErrors.class).in(Singleton.class);
}
#method_after
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    bindEventBus();
    bind(GenericApiGWTServiceAsync.class).asEagerSingleton();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(OperationProcessor.class).asEagerSingleton();
    bind(VdcOperationManager.class).asEagerSingleton();
    bind(CommunicationProvider.class).to(GWTRPCCommunicationProvider.class).in(Singleton.class);
    bind(Frontend.class).asEagerSingleton();
    bind(RootPresenter.class).asEagerSingleton();
    bind(PlaceManager.class).to(placeManager);
    bind(placeManager).in(Singleton.class);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
    bind(AppErrors.class).in(Singleton.class);
    bind(VdsmErrors.class).in(Singleton.class);
}
#end_block

#method_before
public ListModel getPluginType() {
    return pluginType;
}
#method_after
public ListModel getPluginType() {
    return getNeutronAgentModel().getPluginType();
}
#end_block

#method_before
private String getDefaultUrl(ProviderType type) {
    if (type == null) {
        return new String();
    }
    switch(type) {
        case OPENSTACK_NETWORK:
            // $NON-NLS-1$
            return "http://localhost:9696";
        case OPENSTACK_IMAGE:
            // $NON-NLS-1$
            return "http://localhost:9292";
        case FOREMAN:
        default:
            // $NON-NLS-1$
            return "http://localhost";
    }
}
#method_after
private String getDefaultUrl(ProviderType type) {
    if (type == null) {
        // $NON-NLS-1$
        return "";
    }
    switch(type) {
        case OPENSTACK_NETWORK:
            // $NON-NLS-1$
            return "http://localhost:9696";
        case OPENSTACK_IMAGE:
            // $NON-NLS-1$
            return "http://localhost:9292";
        case FOREMAN:
        default:
            // $NON-NLS-1$
            return "http://localhost";
    }
}
#end_block

#method_before
private boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getPluginType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getTenantName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getUrl().validateEntity(new IValidation[] { new NotEmptyValidation(), new UrlValidation(Uri.SCHEME_HTTP, Uri.SCHEME_HTTPS) });
    getNeutronAgentModel().validate();
    return getName().getIsValid() && getType().getIsValid() && getPluginType().getIsValid() && getUrl().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid() && getTenantName().getIsValid() && getNeutronAgentModel().getIsValid();
}
#method_after
private boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new AsciiNameValidation() });
    getType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getUsername().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getPassword().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getTenantName().validateEntity(new IValidation[] { new NotEmptyValidation() });
    getUrl().validateEntity(new IValidation[] { new NotEmptyValidation(), new UrlValidation(Uri.SCHEME_HTTP, Uri.SCHEME_HTTPS) });
    getNeutronAgentModel().validate();
    return getName().getIsValid() && getType().getIsValid() && getUrl().getIsValid() && getUsername().getIsValid() && getPassword().getIsValid() && getTenantName().getIsValid() && getNeutronAgentModel().getIsValid();
}
#end_block

#method_before
private void flush() {
    provider.setName((String) name.getEntity());
    provider.setType((ProviderType) type.getSelectedItem());
    provider.setDescription((String) description.getEntity());
    provider.setUrl((String) url.getEntity());
    if (isTypeOpenStackNetwork()) {
        OpenstackNetworkProviderProperties properties = new OpenstackNetworkProviderProperties();
        properties.setPluginType(NeutronPluginTranslator.getPluginNameForDisplayString((String) getPluginType().getSelectedItem()));
        properties.setAgentConfiguration(getNeutronAgentModel().flush());
        provider.setAdditionalProperties(properties);
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenstackImageProviderProperties());
    }
    boolean authenticationRequired = (Boolean) requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername((String) getUsername().getEntity());
        provider.setPassword((String) getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName((String) getTenantName().getEntity());
        }
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
    }
}
#method_after
private void flush() {
    provider.setName((String) name.getEntity());
    provider.setType((ProviderType) type.getSelectedItem());
    provider.setDescription((String) description.getEntity());
    provider.setUrl((String) url.getEntity());
    if (isTypeOpenStackNetwork()) {
        getNeutronAgentModel().flush(provider);
    } else if (isTypeOpenStackImage()) {
        provider.setAdditionalProperties(new OpenStackImageProviderProperties());
    }
    boolean authenticationRequired = (Boolean) requiresAuthentication.getEntity();
    provider.setRequiringAuthentication(authenticationRequired);
    if (authenticationRequired) {
        provider.setUsername((String) getUsername().getEntity());
        provider.setPassword((String) getPassword().getEntity());
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties == null) {
                properties = new TenantProviderProperties();
                provider.setAdditionalProperties(properties);
            }
            properties.setTenantName((String) getTenantName().getEntity());
        }
    } else {
        provider.setUsername(null);
        provider.setPassword(null);
        if (getTenantName().getIsAvailable()) {
            TenantProviderProperties properties = (TenantProviderProperties) provider.getAdditionalProperties();
            if (properties != null) {
                properties.setTenantName(null);
            }
        }
    }
}
#end_block

#method_before
protected void actualSave() {
    flush();
    Frontend.RunAction(action, new ProviderParameters(provider), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            sourceListModel.getSearchCommand().execute();
        }
    });
    cancel();
}
#method_after
protected void actualSave() {
    flush();
    Frontend.RunAction(action, new ProviderParameters(provider), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (result.getReturnValue() == null || !result.getReturnValue().getSucceeded()) {
                return;
            }
            sourceListModel.getSearchCommand().execute();
            cancel();
        }
    });
}
#end_block

#method_before
private void takeVm() {
    VmPool entity = (VmPool) getItem().getEntity();
    VmPoolUserParameters params = new VmPoolUserParameters(entity.getVmPoolId(), Frontend.getInstance().getLoggedInUser(), false);
    params.setReinitialize(!getItem().isInitialized() && AsyncDataProvider.isWindowsOsType(getItem().getOsId()));
    Frontend.RunAction(VdcActionType.AttachUserToVmFromPoolAndRun, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (!result.getReturnValue().getSucceeded()) {
                return;
            }
        }
    }, this);
}
#method_after
private void takeVm() {
    VmPool entity = (VmPool) getItem().getEntity();
    VmPoolUserParameters params = new VmPoolUserParameters(entity.getVmPoolId(), Frontend.getInstance().getLoggedInUser(), false);
    Frontend.RunAction(VdcActionType.AttachUserToVmFromPoolAndRun, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (!result.getReturnValue().getSucceeded()) {
                return;
            }
        }
    }, this);
}
#end_block

#method_before
private void updateProperties() {
    VmPool entity = (VmPool) getItem().getEntity();
    getItem().setName(entity.getName());
    getItem().setDescription(entity.getVmPoolDescription());
    getItem().setIsPool(true);
    getItem().setIsServer(false);
    getItem().setStatus(VMStatus.Down);
    getItem().setIsFromPool(false);
    getItem().setPoolType(entity.getVmPoolType());
    if (poolToOsType.containsKey(entity.getVmPoolId())) {
        getItem().setOsId(poolToOsType.get(entity.getVmPoolId()));
    }
    Frontend.RunQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(entity.getVmPoolId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            PoolItemBehavior behavior = (PoolItemBehavior) target;
            if (returnValue != null) {
                VM vm = (VM) ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (vm == null) {
                    return;
                }
                UserPortalItemModel model = behavior.getItem();
                model.setOsId(vm.getVmOsId());
                model.setSpiceDriverVersion(vm.getSpiceDriverVersion());
                model.setInitialized(vm.isInitialized());
                poolToOsType.put(((VmPool) model.getEntity()).getVmPoolId(), vm.getVmOsId());
            }
        }
    }));
}
#method_after
private void updateProperties() {
    VmPool entity = (VmPool) getItem().getEntity();
    getItem().setName(entity.getName());
    getItem().setDescription(entity.getVmPoolDescription());
    getItem().setIsPool(true);
    getItem().setIsServer(false);
    getItem().setStatus(VMStatus.Down);
    getItem().setIsFromPool(false);
    getItem().setPoolType(entity.getVmPoolType());
    if (poolToOsType.containsKey(entity.getVmPoolId())) {
        getItem().setOsId(poolToOsType.get(entity.getVmPoolId()));
    }
    Frontend.RunQuery(VdcQueryType.GetVmDataByPoolId, new IdQueryParameters(entity.getVmPoolId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            PoolItemBehavior behavior = (PoolItemBehavior) target;
            if (returnValue != null) {
                VM vm = (VM) ((VdcQueryReturnValue) returnValue).getReturnValue();
                if (vm == null) {
                    return;
                }
                UserPortalItemModel model = behavior.getItem();
                model.setOsId(vm.getVmOsId());
                model.setSpiceDriverVersion(vm.getSpiceDriverVersion());
                poolToOsType.put(((VmPool) model.getEntity()).getVmPoolId(), vm.getVmOsId());
            }
        }
    }));
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initOSType();
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initOSType();
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        }
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition)) {
        if (sender == getVmType()) {
            vmTypeChanged();
        } else if (sender == getDataCenterWithClustersList()) {
            dataCenterWithClusterSelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getTemplate()) {
            template_SelectedItemChanged(sender, args);
        } else if (sender == getTimeZone()) {
            timeZone_SelectedItemChanged(sender, args);
        } else if (sender == getDefaultHost()) {
            defaultHost_SelectedItemChanged(sender, args);
        } else if (sender == getOSType()) {
            oSType_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getFirstBootDevice()) {
            firstBootDevice_SelectedItemChanged(sender, args);
        } else if (sender == getDisplayProtocol()) {
            displayProtocol_SelectedItemChanged(sender, args);
            initUsbPolicy();
        } else if (sender == getNumOfSockets()) {
            numOfSockets_EntityChanged(sender, args);
        } else if (sender == getCoresPerSocket()) {
            coresPerSocket_EntityChanged(sender, args);
        } else if (sender == getMigrationMode()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getCpuSharesAmountSelection()) {
            behavior.updateCpuSharesAmountChangeability();
        }
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition)) {
        if (sender == getMemSize()) {
            memSize_EntityChanged(sender, args);
        } else if (sender == getTotalCPUCores()) {
            totalCPUCores_EntityChanged(sender, args);
        } else if (sender == getIsAutoAssign()) {
            behavior.updateUseHostCpuAvailability();
            behavior.updateCpuPinningVisibility();
            behavior.updateHaAvailability();
        } else if (sender == getProvisioning()) {
            provisioning_SelectedItemChanged(sender, args);
        } else if (sender == getProvisioningThin_IsSelected()) {
            if ((Boolean) getProvisioningThin_IsSelected().getEntity()) {
                getProvisioning().setEntity(false);
            }
        } else if (sender == getProvisioningClone_IsSelected()) {
            if ((Boolean) getProvisioningClone_IsSelected().getEntity()) {
                getProvisioning().setEntity(true);
            }
        } else if (sender == getWatchdogModel()) {
            WatchdogModel_EntityChanged(sender, args);
        } else if (sender == getIsHighlyAvailable()) {
            behavior.updateMigrationAvailability();
        }
    }
}
#end_block

#method_before
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(true);
}
#method_after
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(getVmType().getSelectedItem() == VmType.Server);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = (Integer) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = (Integer) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
}
#end_block

#method_before
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel entityModel = (EntityModel) getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return;
    }
    DisplayType type = (DisplayType) entityModel.getEntity();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#method_after
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    if (getDisplayType() == null) {
        return;
    }
    DisplayType type = getDisplayType();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#end_block

#method_before
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClustersFromSystemTree(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    StoragePool dataCenter = getDataCenterAccordingSystemTree(model, dataCenters);
    // the dataCenters are the entities just downloaded from server while the dataCenter can be a cached one from the system tree
    dataCenter = dataCenter == null ? null : findDataCenterById(dataCenters, dataCenter.getId());
    List<VDSGroup> possibleClusters = getClusterAccordingSystemTree(model, clusters);
    if (dataCenter == null || possibleClusters == null) {
        getDataCenterWithClustersList().setIsChangable(false);
        return;
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (VDSGroup cluster : possibleClusters) {
        if (cluster.getStoragePoolId() != null && cluster.getStoragePoolId().equals(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#method_after
protected void setupDataCenterWithClusters(UnitVmModel model, List<StoragePool> dataCenters, List<VDSGroup> clusters, Guid selectedCluster) {
    Map<Guid, List<VDSGroup>> dataCenterToCluster = new HashMap<Guid, List<VDSGroup>>();
    for (VDSGroup cluster : clusters) {
        if (cluster.getStoragePoolId() == null) {
            continue;
        }
        if (!dataCenterToCluster.containsKey(cluster.getStoragePoolId())) {
            dataCenterToCluster.put(cluster.getStoragePoolId(), new ArrayList<VDSGroup>());
        }
        dataCenterToCluster.get(cluster.getStoragePoolId()).add(cluster);
    }
    List<DataCenterWithCluster> dataCentersWithClusters = new ArrayList<DataCenterWithCluster>();
    for (StoragePool dataCenter : dataCenters) {
        for (VDSGroup cluster : dataCenterToCluster.get(dataCenter.getId())) {
            dataCentersWithClusters.add(new DataCenterWithCluster(dataCenter, cluster));
        }
    }
    getDataCenterWithClustersList().setItems(dataCentersWithClusters);
    selectDataCenterWithCluster(model, selectedCluster, dataCentersWithClusters);
}
#end_block

#method_before
private StoragePool findDataCenterById(List<StoragePool> list, Guid id) {
    for (StoragePool dc : list) {
        if (dc.getId().equals(id)) {
            return dc;
        }
    }
    return null;
}
#method_after
private StoragePool findDataCenterById(List<StoragePool> list, Guid id) {
    if (id == null) {
        return null;
    }
    for (StoragePool dc : list) {
        if (dc.getId().equals(id)) {
            return dc;
        }
    }
    return null;
}
#end_block

#method_before
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = (Integer) getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? WINDOWS_VM_NAME_MAX_LIMIT : NON_WINDOWS_VM_NAME_MAX_LIMIT), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && ((Boolean) getIsAutoAssign().getEntity()) == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty((String) getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty((String) getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty((String) getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && behavior.validate() && customPropertySheetValid && getQuota().getIsValid();
}
#method_after
public boolean validate() {
    getDataCenterWithClustersList().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMemSize().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getMinAllocatedMemory().validateEntity(new IValidation[] { new ByteSizeValidation() });
    getOSType().validateSelectedItem(new NotEmptyValidation[] { new NotEmptyValidation() });
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    StoragePool dataCenter = dataCenterWithCluster == null ? null : dataCenterWithCluster.getDataCenter();
    if (dataCenter != null && dataCenter.getQuotaEnforcementType() == QuotaEnforcementTypeEnum.HARD_ENFORCEMENT) {
        getQuota().validateSelectedItem(new IValidation[] { new NotEmptyQuotaValidation() });
    }
    getTotalCPUCores().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(1, behavior.maxCpus), new TotalCpuCoresComposableValidation() });
    if (getOSType().getIsValid()) {
        Integer osType = (Integer) getOSType().getSelectedItem();
        getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new LengthValidation((getBehavior() instanceof TemplateVmModelBehavior || getBehavior() instanceof NewTemplateVmModelBehavior) ? VM_TEMPLATE_NAME_MAX_LIMIT : AsyncDataProvider.isWindowsOsType(osType) ? AsyncDataProvider.getMaxVmNameLengthWin() : AsyncDataProvider.getMaxVmNameLengthNonWin()), isPoolTabValid ? new PoolNameValidation() : new I18NNameValidation() });
        getDescription().validateEntity(new IValidation[] { new LengthValidation(DESCRIPTION_MAX_LIMIT), new SpecialAsciiI18NOrNoneValidation() });
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.setModel(this);
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                validateMemorySize(getMemSize(), (Integer) ((VdcQueryReturnValue) returnValue).getReturnValue(), _minMemSize);
                if (!(((UnitVmModel) model).getBehavior() instanceof TemplateVmModelBehavior)) {
                    // Minimum 'Physical Memory Guaranteed' is 1MB
                    validateMemorySize(getMinAllocatedMemory(), (Integer) getMemSize().getEntity(), 1);
                }
            }
        };
        if (getSelectedCluster() != null) {
            AsyncDataProvider.getOsMaxRam(osType, getSelectedCluster().getcompatibility_version(), asyncQuery);
        }
        getComment().validateEntity(new IValidation[] { new SpecialAsciiI18NOrNoneValidation() });
    }
    if (getIsAutoAssign().getEntity() != null && ((Boolean) getIsAutoAssign().getEntity()) == false) {
        getDefaultHost().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    } else {
        getDefaultHost().setIsValid(true);
    }
    getTemplate().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getDisksAllocationModel().validateEntity(new IValidation[] {});
    getCdImage().setIsValid(true);
    if (getCdImage().getIsChangable()) {
        getCdImage().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    }
    if (getIsLinuxOS()) {
        getKernel_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getInitrd_path().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        getKernel_parameters().validateEntity(new IValidation[] { new NoTrimmingWhitespacesValidation() });
        // initrd path and kernel params require kernel path to be filled
        if (StringHelper.isNullOrEmpty((String) getKernel_path().getEntity())) {
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (!StringHelper.isNullOrEmpty((String) getInitrd_path().getEntity())) {
                getInitrd_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getInitrd_path().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.initrdPathInvalid());
                getKernel_path().setIsValid(false);
            }
            if (!StringHelper.isNullOrEmpty((String) getKernel_parameters().getEntity())) {
                getKernel_parameters().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_parameters().setIsValid(false);
                getKernel_path().getInvalidityReasons().add(constants.kernelParamsInvalid());
                getKernel_path().setIsValid(false);
            }
        }
    }
    if (getCpuSharesAmount().getIsAvailable()) {
        getCpuSharesAmount().validateEntity(new IValidation[] { new NotEmptyValidation(), new IntegerValidation(0, 262144) });
    }
    boolean customPropertySheetValid = getCustomPropertySheet().validate();
    setIsBootSequenceTabValid(true);
    setIsAllocationTabValid(getIsBootSequenceTabValid());
    setIsDisplayTabValid(getIsAllocationTabValid());
    setIsFirstRunTabValid(getIsDisplayTabValid());
    setIsGeneralTabValid(getIsFirstRunTabValid());
    setIsGeneralTabValid(getName().getIsValid() && getDescription().getIsValid() && getComment().getIsValid() && getDataCenterWithClustersList().getIsValid() && getTemplate().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid());
    setIsFirstRunTabValid(getDomain().getIsValid() && getTimeZone().getIsValid());
    setIsDisplayTabValid(getUsbPolicy().getIsValid() && getNumOfMonitors().getIsValid());
    setIsHostTabValid(getDefaultHost().getIsValid());
    setIsAllocationTabValid(getDisksAllocationModel().getIsValid() && getMinAllocatedMemory().getIsValid() && getCpuSharesAmount().getIsValid());
    setIsBootSequenceTabValid(getCdImage().getIsValid() && getKernel_path().getIsValid());
    setIsCustomPropertiesTabValid(customPropertySheetValid);
    return getName().getIsValid() && getDescription().getIsValid() && getDataCenterWithClustersList().getIsValid() && getDisksAllocationModel().getIsValid() && getTemplate().getIsValid() && getComment().getIsValid() && getDefaultHost().getIsValid() && getMemSize().getIsValid() && getMinAllocatedMemory().getIsValid() && getNumOfMonitors().getIsValid() && getDomain().getIsValid() && getUsbPolicy().getIsValid() && getTimeZone().getIsValid() && getOSType().getIsValid() && getCdImage().getIsValid() && getKernel_path().getIsValid() && getInitrd_path().getIsValid() && getKernel_parameters().getIsValid() && getCpuSharesAmount().getIsValid() && behavior.validate() && customPropertySheetValid && getQuota().getIsValid();
}
#end_block

#method_before
protected void executeCommandWithConsoleSafenessWarning(final UICommand command) {
    VM vm = getEntity();
    if (vm.getAllowConsoleReconnect() || vm.getConsoleCurentUserName() == null || Frontend.getInstance().getLoggedInUser().getUserId().equals(vm.getConsoleUserId())) {
        command.execute();
        return;
    }
    // now we ask if the currently connected user has permission to reconnect (async)
    HasAdElementReconnectPermissionParameters params = new HasAdElementReconnectPermissionParameters(vm.getConsoleUserId(), vm.getId());
    AsyncQuery query = new AsyncQuery();
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            boolean returnValue = ((Boolean) ((VdcQueryReturnValue) result).getReturnValue());
            if (returnValue) {
                command.execute();
            } else {
                displayConsoleConnectConfirmPopup(command);
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, params, query);
}
#method_after
protected void executeCommandWithConsoleSafenessWarning(final UICommand command) {
    VM vm = getEntity();
    if (vm.getAllowConsoleReconnect() || vm.getConsoleCurentUserName() == null || Frontend.getInstance().getLoggedInUser().getId().equals(vm.getConsoleUserId())) {
        command.execute();
        return;
    }
    // now we ask if the currently connected user has permission to reconnect (async)
    final HasAdElementReconnectPermissionParameters consoleUserReconnectPermParams = new HasAdElementReconnectPermissionParameters(vm.getConsoleUserId(), vm.getId());
    final HasAdElementReconnectPermissionParameters portalUserReconnectPermParams = new HasAdElementReconnectPermissionParameters(Frontend.getInstance().getLoggedInUser().getId(), vm.getId());
    final AsyncQuery portalUserReconnectPermissionQuery = new AsyncQuery();
    portalUserReconnectPermissionQuery.setModel(this);
    portalUserReconnectPermissionQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            boolean returnValue = ((VdcQueryReturnValue) result).getReturnValue();
            if (returnValue) {
                displayConsoleConnectConfirmPopup(command);
            } else {
                // user will be stopped by backend validation
                command.execute();
            }
        }
    };
    final AsyncQuery consoleUserReconnectPermissionQuery = new AsyncQuery();
    consoleUserReconnectPermissionQuery.setModel(this);
    consoleUserReconnectPermissionQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            boolean returnValue = ((VdcQueryReturnValue) result).getReturnValue();
            if (returnValue) {
                command.execute();
            } else {
                Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, portalUserReconnectPermParams, portalUserReconnectPermissionQuery);
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, consoleUserReconnectPermParams, consoleUserReconnectPermissionQuery);
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getName().setInfo("Cannot edit Host's Name in this tree context");
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getCluster().setInfo("Cannot choose Host's Cluster in tree context");
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getHostPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(new ValueObjectMap(model.getPmOptionsMap(), false));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(new ValueObjectMap(model.getPmSecondaryOptionsMap(), false));
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider externalProvider = (Provider) model.getExternalProviders().getSelectedItem();
        if (externalProvider != null) {
            parameters.setProvider(externalProvider.getId());
            parameters.setNetworkMappings((String) model.getNeutronAgentModel().getInterfaceMappings().getEntity());
        }
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
        }
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_host");
    model.setMessage(ConstantsManager.getInstance().getConstants().hostsMsg());
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    final ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeHostsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_host");
    Set<Guid> clusters = new HashSet<Guid>();
    ArrayList<String> list = new ArrayList<String>();
    for (VDS item : Linq.<VDS>cast(getSelectedItems())) {
        list.add(item.getName());
        clusters.add(item.getVdsGroupId());
    }
    model.setItems(list);
    // - the cluster should be a gluster only cluster
    if (clusters.size() == 1) {
        model.startProgress(null);
        AsyncDataProvider.getClusterById(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                VDSGroup cluster = (VDSGroup) returnValue;
                if (cluster != null && cluster.supportsGlusterService() && !cluster.supportsVirtService()) {
                    model.getForce().setIsAvailable(true);
                }
                model.stopProgress();
            }
        }), clusters.iterator().next());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
public void activate() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new VdsActionParameters(vds.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.ActivateVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
public void activate() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    Collections.sort((List<VDS>) getSelectedItems(), new Linq.VdsSPMPriorityComparer());
    for (VDS vds : (List<VDS>) getSelectedItems()) {
        list.add(new VdsActionParameters(vds.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.ActivateVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    setHostBricksListModel(new HostBricksListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
    getHostBricksListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService());
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#method_after
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#end_block

#method_before
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        VdcUser vdcUser = Frontend.getInstance().getLoggedInUser();
        if (vdcUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.RunQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(vdcUser.getUserId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<permissions> permissions = (ArrayList<permissions>) response.getReturnValue();
                    for (permissions permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#method_after
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        DbUser dbUser = Frontend.getInstance().getLoggedInUser();
        if (dbUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.RunQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(dbUser.getId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<permissions> permissions = (ArrayList<permissions>) response.getReturnValue();
                    for (permissions permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#end_block

#method_before
@Override
public void onLogout() {
    AsyncQuery query = new AsyncQuery();
    query.setHandleFailure(true);
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            // IE optimization: reload entire application on user logout
            if (clientAgentType.isIE8OrBelow()) {
                Window.Location.reload();
            }
            frontend.setLoggedInUser(null);
            getLoginModel().resetAfterLogout();
            AsyncDataProvider.clearCache();
            connectAutomaticallyManager.resetAlreadyOpened();
            ApplicationInit.super.onLogout();
        }
    };
    Frontend.LogoffAsync(frontend.getLoggedInUser(), query);
}
#method_after
@Override
public void onLogout() {
    AsyncQuery query = new AsyncQuery();
    query.setHandleFailure(true);
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            // IE optimization: reload entire application on user logout
            if (clientAgentType.isIE8OrBelow()) {
                Window.Location.reload();
            }
            frontend.clearLoggedInUser();
            getLoginModel().resetAfterLogout();
            AsyncDataProvider.clearCache();
            connectAutomaticallyManager.resetAlreadyOpened();
            ApplicationInit.super.onLogout();
        }
    };
    frontend.logoffAsync(frontend.getLoggedInUser(), query);
}
#end_block

#method_before
@SuppressWarnings({ "rawtypes", "unchecked" })
void processAvailableOperations(final VdcOperationManager manager) {
    List<VdcOperation<?, ?>> operations = new ArrayList<VdcOperation<?, ?>>();
    Map<VdcOperationCallback<VdcOperation<?, ?>, ?>, VdcOperationCallback<VdcOperation<?, ?>, ?>> usedCallbacks = new HashMap<VdcOperationCallback<VdcOperation<?, ?>, ?>, VdcOperationCallback<VdcOperation<?, ?>, ?>>();
    VdcOperation<?, ?> operation;
    while ((operation = manager.pollOperation()) != null) {
        if (!operation.allowDuplicates() && (pending.contains(operation) || operations.contains(operation))) {
            // Skip this one as the result is pending.
            continue;
        }
        VdcOperationCallback<?, ?> newCallback = usedCallbacks.get(operation.getCallback());
        if (newCallback == null) {
            // into an unknown callback sequence, otherwise use an existing one.
            if (!(operation.getCallback() instanceof VdcOperationCallbackList)) {
                newCallback = new VdcOperationCallback<VdcOperation<?, ?>, Object>() {

                    @Override
                    public void onSuccess(final VdcOperation<?, ?> operation, final Object result) {
                        // Do nothing more than call original callback.
                        VdcOperation<?, ?> originalOperation = getOriginalOperation(operation);
                        originalOperation.getCallback().onSuccess(originalOperation, result);
                        removePending(operation);
                        // Finished, check for more operations.
                        processOperation(manager);
                    }

                    @Override
                    public void onFailure(final VdcOperation<?, ?> operation, final Throwable exception) {
                        // Remove pending, so it won't accidentally stop the re-add if possible.
                        removePending(operation);
                        // If the failure is recoverable, then add the request back into the queue.
                        if (!operation.allowDuplicates() && operation.getCopyCount() < THRESHOLD) {
                            manager.addOperation(operation);
                        } else {
                            VdcOperation<?, ?> originalOperation = getOriginalOperation(operation);
                            originalOperation.getCallback().onFailure(originalOperation, exception);
                        }
                        // Finished, check for more operations.
                        processOperation(manager);
                    }
                };
            } else {
                newCallback = new VdcOperationCallbackList<VdcOperation<?, ?>, Object>() {

                    @Override
                    public void onSuccess(final List<VdcOperation<?, ?>> operationList, final Object result) {
                        if (!operationList.isEmpty()) {
                            // All the call-backs in the list are the same, just have to call one.
                            VdcOperation<?, ?> originalOperation = getOriginalOperation(operationList.get(0));
                            VdcOperationCallback<List<VdcOperation<?, ?>>, Object> originalCallback = originalOperation.getCallback();
                            originalCallback.onSuccess(operationList, result);
                            removePending(operationList);
                            // Finished, check for more operations.
                            processOperation(manager);
                        }
                    }

                    @Override
                    public void onFailure(final List<VdcOperation<?, ?>> operationList, final Throwable exception) {
                        // If the failure is recoverable, then add the request back into the queue.
                        removePending(operationList);
                        VdcOperation<?, ?> originalOperation = getOriginalOperation(operationList.get(0));
                        // If the operation allows duplicates, it means we shouldn't retry the operation.
                        if (!operationList.get(0).allowDuplicates() && operationList.get(0).getCopyCount() < THRESHOLD) {
                            manager.addOperationList(operationList);
                        } else {
                            VdcOperationCallbackList<VdcOperation<?, ?>, Object> originalCallback = (VdcOperationCallbackList<VdcOperation<?, ?>, Object>) originalOperation.getCallback();
                            originalCallback.onFailure(operationList, exception);
                        }
                        // Finished, check for more operations.
                        processOperation(manager);
                    }
                };
            }
            usedCallbacks.put(operation.getCallback(), (VdcOperationCallback<VdcOperation<?, ?>, ?>) newCallback);
        }
        operations.add(new VdcOperation(operation, newCallback));
    }
    // Mark the operations pending.
    addPending(operations);
    communicationProvider.transmitOperationList(operations);
}
#method_after
@SuppressWarnings({ "rawtypes", "unchecked" })
void processAvailableOperations(final VdcOperationManager manager) {
    List<VdcOperation<?, ?>> operations = new ArrayList<VdcOperation<?, ?>>();
    Map<VdcOperationCallback<VdcOperation<?, ?>, ?>, VdcOperationCallback<VdcOperation<?, ?>, ?>> usedCallbacks = new HashMap<VdcOperationCallback<VdcOperation<?, ?>, ?>, VdcOperationCallback<VdcOperation<?, ?>, ?>>();
    VdcOperation<?, ?> operation;
    while ((operation = manager.pollOperation()) != null) {
        if (!operation.allowDuplicates() && (pending.contains(operation) || operations.contains(operation))) {
            // Skip this one as the result is pending.
            continue;
        }
        // Check if the original callback from the operation has been replaced already. This happens only in
        // the case where the original operation is part of an operation list.
        VdcOperationCallback<?, ?> replacementCallback = usedCallbacks.get(operation.getCallback());
        if (replacementCallback == null) {
            // operation before. Re-use existing wrapper callback from the usedCallback map.
            if (!(operation.getCallback() instanceof VdcOperationCallbackList)) {
                replacementCallback = createCallback(manager);
            } else {
                replacementCallback = createListCallback(manager);
            }
            usedCallbacks.put(operation.getCallback(), (VdcOperationCallback<VdcOperation<?, ?>, ?>) replacementCallback);
        }
        operations.add(new VdcOperation(operation, replacementCallback));
    }
    // Mark the operations pending.
    addPending(operations);
    communicationProvider.transmitOperationList(operations);
}
#end_block

#method_before
public void loginUser(VdcOperation<VdcActionType, LoginUserParameters> loginOperation) {
    communicationProvider.login(loginOperation);
}
#method_after
public void loginUser(final VdcOperation<VdcActionType, LoginUserParameters> loginOperation) {
    communicationProvider.login(loginOperation);
}
#end_block

#method_before
public void logoutUser(final Object userObject, final VdcUserCallback<?> callback) {
    communicationProvider.logout(userObject, callback);
}
#method_after
public void logoutUser(final Object userObject, final UserCallback<?> callback) {
    communicationProvider.logout(userObject, callback);
}
#end_block

#method_before
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (getExcludeItems() != null) {
                for (Object item : getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getId());
                }
            }
            setusers(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapUser a = (LdapUser) item;
                if (!excludeUsers.contains(a.getUserId())) {
                    DbUser tempVar = new DbUser();
                    tempVar.setId(a.getUserId());
                    tempVar.setFirstName(a.getName());
                    tempVar.setLastName(a.getSurName());
                    tempVar.setLoginName(a.getUserName());
                    tempVar.setDomain(a.getDomainControler());
                    DbUser user = tempVar;
                    EntityModel tempVar2 = new EntityModel();
                    tempVar2.setEntity(user);
                    getusers().add(tempVar2);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapGroup a = (LdapGroup) item;
                if (!excludeUsers.contains(a.getid())) {
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setId(a.getid());
                    tempVar3.setFirstName(a.getname());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getdomain());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#method_after
@Override
protected void syncSearch() {
    // allow only a single user lookup at a time
    if ((Boolean) getSearchInProgress().getEntity()) {
        return;
    }
    getSearchInProgress().setEntity(true);
    super.syncSearch();
    // var exclude = ExcludeItems != null ? ExcludeItems.Cast<DbUser>() : new List<DbUser>();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            setusers(new ArrayList<EntityModel>());
            addUsersToModel(queryReturnValue, getExcludeUsers());
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findUsers(// $NON-NLS-1$
    "allnames=" + // $NON-NLS-1$
    (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
    _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.setHandleFailure(true);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            AdElementListModel adElementListModel = (AdElementListModel) model;
            VdcQueryReturnValue queryReturnValue = (VdcQueryReturnValue) ReturnValue;
            if (handleQueryError(queryReturnValue, adElementListModel)) {
                return;
            }
            HashSet<Guid> excludeUsers = new HashSet<Guid>();
            if (adElementListModel.getExcludeItems() != null) {
                for (Object item : adElementListModel.getExcludeItems()) {
                    DbUser a = (DbUser) item;
                    excludeUsers.add(a.getId());
                }
            }
            adElementListModel.setgroups(new ArrayList<EntityModel>());
            for (IVdcQueryable item : (ArrayList<IVdcQueryable>) ((VdcQueryReturnValue) ReturnValue).getReturnValue()) {
                LdapGroup a = (LdapGroup) item;
                if (!excludeUsers.contains(a.getid())) {
                    DbUser tempVar3 = new DbUser();
                    tempVar3.setId(a.getid());
                    tempVar3.setFirstName(a.getname());
                    // $NON-NLS-1$
                    tempVar3.setLastName("");
                    // $NON-NLS-1$
                    tempVar3.setLoginName("");
                    tempVar3.setDomain(a.getdomain());
                    DbUser user = tempVar3;
                    EntityModel tempVar4 = new EntityModel();
                    tempVar4.setEntity(user);
                    adElementListModel.getgroups().add(tempVar4);
                }
            }
            onUserAndAdGroupsLoaded(adElementListModel);
        }
    };
    findGroups(// $NON-NLS-1$ //$NON-NLS-2$
    "name=" + (StringHelper.isNullOrEmpty(getSearchString()) ? "*" : getSearchString()), _asyncQuery);
}
#end_block

#method_before
private void onUserAndAdGroupsLoaded(AdElementListModel adElementListModel) {
    if (adElementListModel.getusers() != null && adElementListModel.getgroups() != null) {
        getSearchInProgress().setEntity(false);
        ArrayList<EntityModel> items = new ArrayList<EntityModel>();
        items.addAll(getusers());
        items.addAll(getgroups());
        adElementListModel.getSelectAll().setEntity(false);
        adElementListModel.setItems(items);
        setusers(null);
        setgroups(getusers());
        setIsEmpty(items.isEmpty());
    }
}
#method_after
protected void onUserAndAdGroupsLoaded(AdElementListModel adElementListModel) {
    if (adElementListModel.getusers() != null && adElementListModel.getgroups() != null) {
        getSearchInProgress().setEntity(false);
        ArrayList<EntityModel> items = new ArrayList<EntityModel>();
        items.addAll(getusers());
        items.addAll(getgroups());
        adElementListModel.getSelectAll().setEntity(false);
        adElementListModel.setItems(items);
        setusers(null);
        setgroups(getusers());
        setIsEmpty(items.isEmpty());
    }
}
#end_block

#method_before
private void updateOptionsPostData() {
    if (nics == null || disks == null) {
        return;
    }
    // Add NIC action.
    // $NON-NLS-1$
    UICommand addNicAction = new UICommand("AddNetwork", this);
    if (nics.isEmpty()) {
        addNicAction.setTitle(VmConfigureNetworkInterfacesAction);
        getCompulsoryActions().add(addNicAction);
    } else {
        addNicAction.setTitle(VmAddAnotherNetworkInterfaceAction);
        getOptionalActions().add(addNicAction);
    }
    // Add disk action.
    // $NON-NLS-1$
    UICommand addDiskAction = new UICommand("AddDisk", this);
    if (disks.isEmpty()) {
        addDiskAction.setTitle(VmConfigureVirtualDisksAction);
        getCompulsoryActions().add(addDiskAction);
    } else {
        addDiskAction.setTitle(VmAddAnotherVirtualDiskAction);
        getOptionalActions().add(addDiskAction);
    }
    stopProgress();
}
#method_after
private void updateOptionsPostData(Collection<Disk> disks) {
    // Add disk action.
    // $NON-NLS-1$
    UICommand addDiskAction = new UICommand("AddDisk", this);
    if (disks.isEmpty()) {
        addDiskAction.setTitle(VmConfigureVirtualDisksAction);
        getCompulsoryActions().add(addDiskAction);
    } else {
        addDiskAction.setTitle(VmAddAnotherVirtualDiskAction);
        getOptionalActions().add(addDiskAction);
    }
    stopProgress();
}
#end_block

#method_before
private void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() != null) {
        startProgress(null);
        updateOptionsData();
    }
}
#method_after
public void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() != null) {
        startProgress(null);
        AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                updateOptionsPostData((Collection<Disk>) returnValue);
            }
        }), getEntity().getId());
    }
}
#end_block

#method_before
public void addDisk() {
    if (getEntity() == null) {
        return;
    }
    NewDiskModel model = new NewDiskModel();
    model.setTitle(ConstantsManager.getInstance().getConstants().addVirtualDiskTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_disk");
    model.setVm(getEntity());
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#method_after
public void addDisk() {
    if (getEntity() == null) {
        return;
    }
    NewDiskModel model = new NewGuideDiskModel(this);
    model.setTitle(ConstantsManager.getInstance().getConstants().addVirtualDiskTitle());
    // $NON-NLS-1$
    model.setHashName("new_virtual_disk");
    model.setVm(getEntity());
    setWindow(model);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.setCancelCommand(cancelCommand);
    model.initialize();
}
#end_block

#method_before
public void cancel() {
    resetData();
    setWindow(null);
    Frontend.getInstance().unsubscribe();
}
#method_after
public void cancel() {
    setWindow(null);
    Frontend.getInstance().unsubscribe();
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "AddNetwork")) {
        addNetwork();
    }
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "AddDisk")) {
        addDisk();
    }
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "AddDisk")) {
        addDisk();
    }
    if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    }
}
#end_block

#method_before
public VdcUser getParametersCurrentUser() {
    return parametersCurrentUser;
}
#method_after
public DbUser getParametersCurrentUser() {
    return parametersCurrentUser;
}
#end_block

#method_before
public void setParametersCurrentUser(VdcUser value) {
    parametersCurrentUser = value;
}
#method_after
public void setParametersCurrentUser(DbUser value) {
    parametersCurrentUser = value;
}
#end_block

#method_before
@Override
public String toString() {
    StringBuilder builder = new StringBuilder(50);
    // $NON-NLS-1$
    builder.append("commandId: ");
    builder.append(getCommandId());
    // $NON-NLS-1$
    builder.append(", user: ");
    if (getParametersCurrentUser() != null) {
        builder.append(getParametersCurrentUser().getUserName());
    }
    // $NON-NLS-1$
    builder.append(", commandType: ");
    builder.append(getCommandType());
    return builder.toString();
}
#method_after
@Override
public String toString() {
    StringBuilder builder = new StringBuilder(50);
    // $NON-NLS-1$
    builder.append("commandId: ");
    builder.append(getCommandId());
    // $NON-NLS-1$
    builder.append(", user: ");
    if (getParametersCurrentUser() != null) {
        builder.append(getParametersCurrentUser().getLoginName());
    }
    // $NON-NLS-1$
    builder.append(", commandType: ");
    builder.append(getCommandType());
    return builder.toString();
}
#end_block

#method_before
protected void performLogin(T loginModel) {
    VdcUser loggedUser = loginModel.getLoggedUser();
    // UiCommon login preparation
    frontend.setLoggedInUser(loggedUser);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#method_after
protected void performLogin(T loginModel) {
    DbUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = (String) loginModel.getPassword().getEntity();
    // UiCommon login preparation
    frontend.initLoggedInUser(loggedUser, loginPassword);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#end_block

#method_before
protected void initFrontend() {
    // Set up Frontend event handlers
    frontend.setEventsHandler(frontendEventsHandler);
    frontend.getFrontendFailureEvent().addListener(frontendFailureEventListener);
    frontend.getFrontendNotLoggedInEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            user.logout();
        }
    });
    frontend.setFilterQueries(filterFrontendQueries());
    // Initialize specific UI dependencies for search
    SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(AsyncDataProvider.getOsUniqueOsNames()));
}
#method_after
protected void initFrontend() {
    // Set up Frontend event handlers
    frontend.setEventsHandler(frontendEventsHandler);
    frontend.getFrontendFailureEvent().addListener(frontendFailureEventListener);
    frontend.getFrontendNotLoggedInEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            user.logout();
        }
    });
    frontend.setFilterQueries(filterFrontendQueries());
}
#end_block

#method_before
protected void handleAutoLogin(AutoLoginData autoLoginData) {
    final VdcUser vdcUser = autoLoginData.getVdcUser();
    frontend.setLoggedInUser(vdcUser);
    // Use deferred command because CommonModel change needs to happen
    // after all model providers have been properly initialized
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            lockInteractionManager.showLoadingIndicator();
            getLoginModel().autoLogin(vdcUser);
        }
    });
    // Indicate that the user should be logged in automatically
    user.setAutoLogin(true);
}
#method_after
protected void handleAutoLogin(AutoLoginData autoLoginData) {
    final DbUser vdcUser = autoLoginData.getVdcUser();
    // Use deferred command because CommonModel change needs to happen
    // after all model providers have been properly initialized
    Scheduler.get().scheduleDeferred(new ScheduledCommand() {

        @Override
        public void execute() {
            lockInteractionManager.showLoadingIndicator();
            getLoginModel().autoLogin(vdcUser);
        }
    });
    // Indicate that the user should be logged in automatically
    user.setAutoLogin(true);
}
#end_block

#method_before
@Test
public void testLoginAsync_404_failure() {
    frontend.setLoggedInUser(new VdcUser());
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockEventsHandler).runQueryFailed(null);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (EventArgs) any());
    // $NON-NLS-1$
    assertNull("Logged in user should be null", frontend.getLoggedInUser());
    verify(mockAsyncCallback).onSuccess(any(), any());
}
#method_after
@Test
public void testLoginAsync_404_failure() {
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    Frontend.getInstance().initLoggedInUser(new DbUser(), testPassword);
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockEventsHandler).runQueryFailed(null);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (EventArgs) any());
    // $NON-NLS-1$
    assertNull("Logged in user should be null", frontend.getLoggedInUser());
    verify(mockAsyncCallback).onSuccess(any(), any());
}
#end_block

#method_before
@Test
public void testLoginAsync_success() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    frontend.setLoggedInUser(new VdcUser());
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#method_after
@Test
public void testLoginAsync_success() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    Frontend.getInstance().initLoggedInUser(new DbUser(), testPassword);
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#end_block

#method_before
@Test
public void testLoginAsync_login_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    frontend.setLoggedInUser(new VdcUser());
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    // Yes I know this is the default, just to be sure.
    returnValue.setSucceeded(false);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler, never()).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#method_after
@Test
public void testLoginAsync_login_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    Frontend.getInstance().initLoggedInUser(new DbUser(), testPassword);
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    frontend.loginAsync(testUser, testPassword, testDomain, false, mockAsyncQuery);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), eq(VdcActionType.LoginUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    // Yes I know this is the default, just to be sure.
    returnValue.setSucceeded(false);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler, never()).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#end_block

#method_before
@Test
public void testLogoffAsync_ignored_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    VdcUser testUser = new VdcUser();
    // $NON-NLS-1$
    testUser.setUserName("testUser");
    // $NON-NLS-1$
    testUser.setPassword("testpassword");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    // $NON-NLS-1$
    StatusCodeException exception = new StatusCodeException(0, "0 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
    verify(mockEventsHandler, never()).runQueryFailed(null);
    verify(mockAsyncCallback, never()).onSuccess(model, null);
}
#method_after
@Test
public void testLogoffAsync_ignored_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    DbUser testUser = new DbUser();
    // $NON-NLS-1$
    testUser.setLoginName("testUser");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    // $NON-NLS-1$
    StatusCodeException exception = new StatusCodeException(0, "0 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
    verify(mockEventsHandler, never()).runQueryFailed(null);
    verify(mockAsyncCallback, never()).onSuccess(model, null);
}
#end_block

#method_before
@Test
public void testLogoffAsync_404_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    VdcUser testUser = new VdcUser();
    // $NON-NLS-1$
    testUser.setUserName("testUser");
    // $NON-NLS-1$
    testUser.setPassword("testpassword");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (EventArgs) any());
    verify(mockEventsHandler).runQueryFailed(null);
    verify(mockAsyncCallback).onSuccess(model, null);
}
#method_after
@Test
public void testLogoffAsync_404_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    DbUser testUser = new DbUser();
    // $NON-NLS-1$
    testUser.setLoginName("testUser");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, // $NON-NLS-1$
    "404 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (EventArgs) any());
    verify(mockEventsHandler).runQueryFailed(null);
    verify(mockAsyncCallback).onSuccess(model, null);
}
#end_block

#method_before
@Test
public void testLogoffAsync_success() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    VdcUser testUser = new VdcUser();
    // $NON-NLS-1$
    testUser.setUserName("testUser");
    // $NON-NLS-1$
    testUser.setPassword("testpassword");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler).onLogout();
}
#method_after
@Test
public void testLogoffAsync_success() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    DbUser testUser = new DbUser();
    // $NON-NLS-1$
    testUser.setLoginName("testUser");
    frontend.logoffAsync(testUser, mockAsyncQuery);
    verify(mockService).logOff(eq(testUser), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler).onLogout();
}
#end_block

#method_before
public VdcUser getLoggedUser() {
    return privateLoggedUser;
}
#method_after
public DbUser getLoggedUser() {
    return privateLoggedUser;
}
#end_block

#method_before
protected void setLoggedUser(VdcUser value) {
    privateLoggedUser = value;
}
#method_after
protected void setLoggedUser(DbUser value) {
    privateLoggedUser = value;
}
#end_block

#method_before
public void login() {
    if (!validate()) {
        return;
    }
    startProgress(null);
    disableLoginScreen();
    String fullUserName = (String) getUserName().getEntity();
    String[] parts = getUserNameParts(fullUserName);
    String domain = parts[1];
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            LoginModel loginModel = (LoginModel) model;
            VdcUser user = null;
            if (result != null) {
                VdcReturnValueBase returnValue = (VdcReturnValueBase) result;
                if (returnValue.getSucceeded()) {
                    user = (VdcUser) returnValue.getActionReturnValue();
                    loginModel.setLoggedUser(user);
                }
                if (user == null) {
                    // $NON-NLS-1$
                    loginModel.getPassword().setEntity("");
                    loginModel.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                    loginModel.getUserName().setIsChangable(true);
                    loginModel.getPassword().setIsChangable(true);
                    loginModel.getDomain().setIsChangable(true);
                    loginModel.getLoginCommand().setIsExecutionAllowed(true);
                    loginModel.getLoginFailedEvent().raise(this, EventArgs.Empty);
                } else {
                    raiseLoggedInEvent();
                }
                stopProgress();
            }
        }
    };
    Frontend.LoginAsync(fullUserName, (String) getPassword().getEntity(), StringHelper.isNullOrEmpty(domain) ? (String) getDomain().getSelectedItem() : domain, true, _asyncQuery);
}
#method_after
public void login() {
    if (!validate()) {
        getLoginFailedEvent().raise(this, EventArgs.Empty);
        return;
    }
    startProgress(null);
    disableLoginScreen();
    String fullUserName = (String) getUserName().getEntity();
    String[] parts = getUserNameParts(fullUserName);
    String domain = parts[1];
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            LoginModel loginModel = (LoginModel) model;
            DbUser user = null;
            if (result != null) {
                VdcReturnValueBase returnValue = (VdcReturnValueBase) result;
                if (returnValue.getSucceeded()) {
                    user = (DbUser) returnValue.getActionReturnValue();
                    loginModel.setLoggedUser(user);
                }
                if (user == null) {
                    // $NON-NLS-1$
                    loginModel.getPassword().setEntity("");
                    loginModel.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                    loginModel.getUserName().setIsChangable(true);
                    loginModel.getPassword().setIsChangable(true);
                    loginModel.getDomain().setIsChangable(true);
                    loginModel.getLoginCommand().setIsExecutionAllowed(true);
                    loginModel.getLoginFailedEvent().raise(this, EventArgs.Empty);
                } else {
                    raiseLoggedInEvent();
                }
                stopProgress();
            }
        }
    };
    Frontend.LoginAsync(fullUserName, (String) getPassword().getEntity(), StringHelper.isNullOrEmpty(domain) ? (String) getDomain().getSelectedItem() : domain, true, _asyncQuery);
}
#end_block

#method_before
public void autoLogin(VdcUser user) {
    loggingInAutomatically = true;
    getUserName().setEntity(user.getUserName());
    getDomain().setSelectedItem(user.getDomainControler());
    disableLoginScreen();
    setLoggedUser(user);
    raiseLoggedInEvent();
}
#method_after
public void autoLogin(DbUser user) {
    loggingInAutomatically = true;
    getUserName().setEntity(user.getLoginName());
    getDomain().setSelectedItem(user.getDomain());
    disableLoginScreen();
    setLoggedUser(user);
    Frontend.getInstance().setLoggedInUser(user);
    raiseLoggedInEvent();
}
#end_block

#method_before
@Override
public VdcUser getLoggedInUser() {
    VdcQueryParametersBase queryParams = new VdcQueryParametersBase();
    queryParams.setSessionId(getSessionId());
    queryParams.setHttpSessionId(getSessionId());
    VdcQueryReturnValue vqrv = RunQuery(VdcQueryType.GetUserBySessionId, queryParams);
    if (!vqrv.getSucceeded()) {
        return null;
    } else if (vqrv.getSucceeded()) {
        if (vqrv.getReturnValue() == null) {
            return null;
        }
        return (VdcUser) vqrv.getReturnValue();
    } else {
        // For unknown reason the result was failed be returned.
        return null;
    }
}
#method_after
@Override
public DbUser getLoggedInUser() {
    VdcQueryParametersBase queryParams = new VdcQueryParametersBase();
    queryParams.setSessionId(getSessionId());
    queryParams.setHttpSessionId(getSessionId());
    VdcQueryReturnValue vqrv = RunQuery(VdcQueryType.GetUserBySessionId, queryParams);
    if (!vqrv.getSucceeded()) {
        return null;
    } else if (vqrv.getSucceeded()) {
        if (vqrv.getReturnValue() == null) {
            return null;
        }
        return (DbUser) vqrv.getReturnValue();
    } else {
        // For unknown reason the result was failed be returned.
        return null;
    }
}
#end_block

#method_before
@Override
public VdcReturnValueBase logOff(VdcUser userToLogoff) {
    LogoutUserParameters params = new LogoutUserParameters(userToLogoff.getUserId());
    params.setSessionId(getSessionId());
    VdcReturnValueBase returnValue = getBackend().Logoff(params);
    return returnValue;
}
#method_after
@Override
public VdcReturnValueBase logOff(DbUser userToLogoff) {
    LogoutUserParameters params = new LogoutUserParameters(userToLogoff.getId());
    params.setSessionId(getSessionId());
    VdcReturnValueBase returnValue = getBackend().Logoff(params);
    return returnValue;
}
#end_block

#method_before
private void updateDataCenterAlert() {
    if (getDataCenter().getSelectedItem() != null && !UnassignedDataCenterId.equals(((StoragePool) getDataCenter().getSelectedItem()).getId()) && ((StoragePool) getDataCenter().getSelectedItem()).getstatus() == StoragePoolStatus.Uninitialized) {
        getDataCenterAlert().setIsAvailable(true);
        getDataCenterAlert().setEntity(ConstantsManager.getInstance().getConstants().dataCenterUninitializedAlert());
    } else {
        getDataCenterAlert().setIsAvailable(false);
        getDataCenterAlert().setEntity("");
    }
}
#method_after
private void updateDataCenterAlert() {
    if (getDataCenter().getSelectedItem() != null && !UnassignedDataCenterId.equals(((StoragePool) getDataCenter().getSelectedItem()).getId()) && ((StoragePool) getDataCenter().getSelectedItem()).getStatus() == StoragePoolStatus.Uninitialized) {
        getDataCenterAlert().setIsAvailable(true);
        getDataCenterAlert().setEntity(ConstantsManager.getInstance().getConstants().dataCenterUninitializedAlert());
    } else {
        getDataCenterAlert().setIsAvailable(false);
        getDataCenterAlert().setEntity("");
    }
}
#end_block

#method_before
private void initDataCenter() {
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                {
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    // $NON-NLS-1$
                    getDataCenter().setInfo("Cannot choose Storage's Data Center in tree context");
                }
                break;
            case Host:
                {
                    VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                    getHost().setIsChangable(false);
                    // $NON-NLS-1$
                    getHost().setInfo("Cannot choose Storage's Host in tree context");
                    getHost().setSelectedItem(host);
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    // $NON-NLS-1$
                    getDataCenter().setInfo("Cannot choose Storage's Data Center in tree context");
                }
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) // We are either adding a new storage or editing an unattached storage
        // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
        // [TODO: In case of an Unattached SD, choose only DCs of the same type]
        {
            AsyncDataProvider.getDataCenterList(new AsyncQuery(new Object[] { this, behavior }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    StorageModel storageModel = (StorageModel) array[0];
                    StorageModelBehavior storageModelBehavior = (StorageModelBehavior) array[1];
                    List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                    dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                    StoragePool oldSelectedItem = (StoragePool) storageModel.getDataCenter().getSelectedItem();
                    storageModel.getDataCenter().setItems(dataCenters);
                    if (oldSelectedItem != null) {
                        storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(oldSelectedItem.getId())));
                    } else {
                        storageModel.getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrDefault(dataCenters) : Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(UnassignedDataCenterId)));
                    }
                }
            }, getHash()));
        } else // "Edit Storage" mode:
        {
            AsyncDataProvider.getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    List<StoragePool> dataCenters = new ArrayList<StoragePool>();
                    List<StoragePool> dataCentersWithStorage = (ArrayList<StoragePool>) returnValue;
                    if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                        StorageModel.addEmptyDataCenterToList(dataCenters);
                    } else {
                        dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                    }
                    storageModel.getDataCenter().setItems(dataCenters);
                    storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                }
            }, getHash()), getStorage().getId());
        }
    }
}
#method_after
private void initDataCenter() {
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case DataCenter:
            case Cluster:
            case Storages:
            case Storage:
                {
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
            case Host:
                {
                    VDS host = (VDS) getSystemTreeSelectedItem().getEntity();
                    getHost().setIsChangable(false);
                    getHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                    getHost().setSelectedItem(host);
                    SystemTreeItemModel dataCenterItem = SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, getSystemTreeSelectedItem());
                    StoragePool dc = (StoragePool) dataCenterItem.getEntity();
                    getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                    getDataCenter().setSelectedItem(dc);
                    getDataCenter().setIsChangable(false);
                    getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                }
                break;
        }
    } else {
        if (getStorage() == null || getStorage().getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached) // We are either adding a new storage or editing an unattached storage
        // -> fill DataCenters drop-down with all possible Data-Centers, choose the empty one:
        // [TODO: In case of an Unattached SD, choose only DCs of the same type]
        {
            AsyncDataProvider.getDataCenterList(new AsyncQuery(new Object[] { this, behavior }, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    Object[] array = (Object[]) target;
                    StorageModel storageModel = (StorageModel) array[0];
                    StorageModelBehavior storageModelBehavior = (StorageModelBehavior) array[1];
                    List<StoragePool> dataCenters = (ArrayList<StoragePool>) returnValue;
                    dataCenters = storageModelBehavior.filterDataCenter(dataCenters);
                    StorageModel.addEmptyDataCenterToList(dataCenters);
                    StoragePool oldSelectedItem = (StoragePool) storageModel.getDataCenter().getSelectedItem();
                    storageModel.getDataCenter().setItems(dataCenters);
                    if (oldSelectedItem != null) {
                        storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(oldSelectedItem.getId())));
                    } else {
                        storageModel.getDataCenter().setSelectedItem(getStorage() == null ? Linq.firstOrDefault(dataCenters) : Linq.firstOrDefault(dataCenters, new Linq.DataCenterPredicate(UnassignedDataCenterId)));
                    }
                }
            }, getHash()));
        } else // "Edit Storage" mode:
        {
            AsyncDataProvider.getDataCentersByStorageDomain(new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object target, Object returnValue) {
                    StorageModel storageModel = (StorageModel) target;
                    List<StoragePool> dataCenters = new ArrayList<StoragePool>();
                    List<StoragePool> dataCentersWithStorage = (ArrayList<StoragePool>) returnValue;
                    if (dataCentersWithStorage.size() < 1 || dataCentersWithStorage.get(0) == null) {
                        StorageModel.addEmptyDataCenterToList(dataCenters);
                    } else {
                        dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCentersWithStorage.get(0) }));
                    }
                    storageModel.getDataCenter().setItems(dataCenters);
                    storageModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                }
            }, getHash()), getStorage().getId());
        }
    }
}
#end_block

#method_before
public void postUpdateHost(Iterable<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getSelectedItem() != null && getSelectedItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = (VDS) getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        hosts = Collections.singletonList(getSPM(hosts));
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts);
    getHost().setSelectedItem(selectedItem);
}
#method_after
public void postUpdateHost(Iterable<VDS> hosts) {
    // Filter hosts
    hosts = Linq.where(hosts, new Linq.HostStatusPredicate(VDSStatus.Up));
    // Allow only hosts with version above 2.2 for export storage.
    ArrayList<VDS> list = new ArrayList<VDS>();
    if (getSelectedItem() != null && getSelectedItem().getRole() == StorageDomainType.ImportExport) {
        for (VDS host : hosts) {
            if (// $NON-NLS-1$
            host.getVdsGroupCompatibilityVersion().compareTo(new Version("2.2")) >= 0) {
                list.add(host);
            }
        }
        hosts = list;
    }
    VDS oldSelectedItem = (VDS) getHost().getSelectedItem();
    VDS selectedItem = null;
    // any host can perform the operation, thus no need to filter to use just the SPM
    if (getStorage() != null && getStorage().getStatus() != StorageDomainStatus.Maintenance) {
        VDS spm = getSPM(hosts);
        hosts = spm != null ? Collections.singletonList(spm) : Collections.<VDS>emptyList();
    }
    // Try to select previously selected host.
    if (oldSelectedItem != null) {
        selectedItem = Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldSelectedItem.getId()));
    }
    // Select a default - if there's a SPM choose it, otherwise choose the first host in the list.
    if (selectedItem == null) {
        VDS spm = getSPM(hosts);
        selectedItem = spm == null ? Linq.firstOrDefault(hosts) : spm;
    }
    getHost().setItems(hosts);
    getHost().setSelectedItem(selectedItem);
}
#end_block

#method_before
void updateFormat() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getSelectedItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.NFS || getSelectedItem().getType() == StorageType.LOCALFS) && (dataCenter.getcompatibility_version().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getcompatibility_version().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangable(true);
            formats.add(StorageFormatType.V1);
            if ((getSelectedItem().getType() == StorageType.FCP || getSelectedItem().getType() == StorageType.ISCSI) && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#method_after
void updateFormat() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getSelectedItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getSelectedItem().getRole().isDataDomain()) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.NFS || getSelectedItem().getType() == StorageType.LOCALFS) && (dataCenter.getcompatibility_version().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getcompatibility_version().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangable(true);
            formats.add(StorageFormatType.V1);
            if ((getSelectedItem().getType() == StorageType.FCP || getSelectedItem().getType() == StorageType.ISCSI) && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#end_block

#method_before
public boolean isExtendImageSizeEnabled() {
    return (getEntity() != null) ? VdcActionUtils.CanExecute(Arrays.asList(getEntity()), VM.class, VdcActionType.ExtendImageSize) : false;
}
#method_after
public boolean isExtendImageSizeEnabled() {
    return (getEntity() != null) ? VdcActionUtils.canExecute(Arrays.asList(getEntity()), VM.class, VdcActionType.ExtendImageSize) : false;
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.setMessage(ConstantsManager.getInstance().getConstants().disksMsg());
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private boolean isPlugAvailableByDisks(boolean plug) {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        boolean isLocked = disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED;
        if (disk.getPlugged() == plug || isLocked || (disk.getDiskInterface() == DiskInterface.IDE && !isVmDown())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isPlugAvailableByDisks(boolean plug) {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        boolean isLocked = disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED;
        boolean isDiskHotpluggableInterface = false;
        if (getEntity() != null) {
            isDiskHotpluggableInterface = AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), getEntity().getVdsGroupCompatibilityVersion()).contains(disk.getDiskInterface());
        }
        if (disk.getPlugged() == plug || isLocked || (!isDiskHotpluggableInterface && !isVmDown())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged()) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void updateIsDiskHotPlugAvailable() {
    VM vm = getEntity();
    Version clusterCompatibilityVersion = vm.getVdsGroupCompatibilityVersion();
    if (clusterCompatibilityVersion == null) {
        setIsDiskHotPlugSupported(false);
    } else {
        setIsDiskHotPlugSupported((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.HotPlugEnabled, clusterCompatibilityVersion.toString()));
    }
}
#method_after
protected void updateIsDiskHotPlugAvailable() {
    VM vm = getEntity();
    Version clusterCompatibilityVersion = vm.getVdsGroupCompatibilityVersion();
    if (clusterCompatibilityVersion == null) {
        setIsDiskHotPlugSupported(false);
    } else {
        setIsDiskHotPlugSupported((Boolean) !AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), clusterCompatibilityVersion).isEmpty());
    }
}
#end_block

#method_before
private boolean isLocalDataCenterEmpty(StoragePool dataCenter) {
    if (dataCenter != null && dataCenter.getStorageType() == StorageType.LOCALFS && dataCenter.getstatus() == StoragePoolStatus.Uninitialized) {
        return true;
    }
    return false;
}
#method_after
private boolean isLocalDataCenterEmpty(StoragePool dataCenter) {
    if (dataCenter != null && dataCenter.getStorageType() == StorageType.LOCALFS && dataCenter.getStatus() == StoragePoolStatus.Uninitialized) {
        return true;
    }
    return false;
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setInfo(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        clusterModel.getName().setIsChangable(false);
        // $NON-NLS-1$
        clusterModel.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeClusterTitle());
    // $NON-NLS-1$
    model.setHashName("remove_cluster");
    model.setMessage(ConstantsManager.getInstance().getConstants().clustersMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (VDSGroup a : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
public void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeClusterTitle());
    // $NON-NLS-1$
    model.setHashName("remove_cluster");
    ArrayList<String> list = new ArrayList<String>();
    for (VDSGroup a : Linq.<VDSGroup>cast(getSelectedItems())) {
        list.add(a.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private void onSaveConfirmCV(ClusterModel model) {
    if (!((Version) model.getVersion().getSelectedItem()).equals(((VDSGroup) getSelectedItem()).getcompatibility_version())) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeClusterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_cluster_compatibility_version");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuThreads", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        onSaveConfirmCpuThreads();
    }
}
#method_after
private void onSaveConfirmCV(ClusterModel model) {
    if (!((Version) model.getVersion().getSelectedItem()).equals(((VDSGroup) getSelectedItem()).getcompatibility_version())) {
        final ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().changeClusterCompatibilityVersionTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("change_cluster_compatibility_version");
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuThreads", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
        checkForNonResponsiveHosts(confirmModel);
    } else {
        onSaveConfirmCpuThreads();
    }
}
#end_block

#method_before
private void onSaveConfirmCpuThreads() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    // CPU thread support is being turned off either explicitly or via version change
    if (!((Boolean) model.getVersionSupportsCpuThreads().getEntity() && (Boolean) model.getCountThreadsAsCores().getEntity()) && ((VDSGroup) getSelectedItem()).getCountThreadsAsCores()) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().disableClusterCpuThreadSupportTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("disable_cpu_thread_support");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCpuThreadSupportMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveInternal", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        onSaveInternal();
    }
}
#method_after
private void onSaveConfirmCpuThreads() {
    ClusterModel model = (ClusterModel) getWindow();
    // cancel confirm window if there is one
    cancelConfirmation();
    // CPU thread support is being turned off either explicitly or via version change
    if (!((Boolean) model.getVersionSupportsCpuThreads().getEntity() && (Boolean) model.getCountThreadsAsCores().getEntity()) && ((VDSGroup) getSelectedItem()).getCountThreadsAsCores()) {
        ConfirmationModel confirmModel = new ConfirmationModel();
        setConfirmWindow(confirmModel);
        confirmModel.setTitle(ConstantsManager.getInstance().getConstants().disableClusterCpuThreadSupportTitle());
        // $NON-NLS-1$
        confirmModel.setHashName("disable_cpu_thread_support");
        confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCpuThreadSupportMsg());
        // $NON-NLS-1$
        UICommand tempVar = new UICommand("OnSaveConfirmCpuLevel", this);
        tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
        tempVar.setIsDefault(true);
        getConfirmWindow().getCommands().add(tempVar);
        // $NON-NLS-1$
        UICommand tempVar2 = new UICommand("CancelConfirmation", this);
        tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
        tempVar2.setIsCancel(true);
        getConfirmWindow().getCommands().add(tempVar2);
    } else {
        onSaveConfirmCpuLevel();
    }
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuThreads")) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command == getNewCommand()) {
        newEntity();
    } else if (command == getEditCommand()) {
        edit();
    } else if (command == getRemoveCommand()) {
        remove();
    } else if (command == getGuideCommand()) {
        guide();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSave")) {
        onSave();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "Cancel")) {
        cancel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnRemove")) {
        onRemove();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuThreads")) {
        onSaveConfirmCpuThreads();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveConfirmCpuLevel")) {
        onSaveConfirmCpuLevel();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveInternal")) {
        onSaveInternal();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "CancelConfirmation")) {
        cancelConfirmation();
    } else if (// $NON-NLS-1$
    StringHelper.stringsEqual(command.getName(), "OnSaveHosts")) {
        onSaveHosts();
    }
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getInstance().getQueryStartedEvent().addListener(this);
    Frontend.getInstance().getQueryCompleteEvent().addListener(this);
    Frontend.getInstance().subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#method_after
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getInstance().getQueryStartedEvent().addListener(this);
    Frontend.getInstance().getQueryCompleteEvent().addListener(this);
    Frontend.getInstance().subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage, VdcQueryType.OsRepository });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#end_block

#method_before
private void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (a.getStorageDomainType() != StorageDomainType.ISO && a.getStorageDomainType() != StorageDomainType.ImportExport && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            if (storage != null) {
                updateWipeAfterDelete(storage.getStorageType());
                // $NON-NLS-1$
                diskModel.setMessage("");
            } else {
                diskModel.setMessage(CONSTANTS.noActiveStorageDomainsInDC());
            }
            updateQuota(datacenter);
        }
    }, getHash()), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#method_after
private void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (a.getStorageDomainType() != StorageDomainType.ISO && a.getStorageDomainType() != StorageDomainType.ImportExport && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            if (storage != null) {
                updateWipeAfterDelete(storage.getStorageType());
                // $NON-NLS-1$
                diskModel.setMessage("");
            } else {
                diskModel.setMessage(CONSTANTS.noActiveStorageDomainsInDC());
            }
        }
    }, getHash()), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#end_block

#method_before
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            for (Disk disk : disks) {
                if (disk.isBoot() && !disk.equals(getDisk())) {
                    diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                    diskModel.getIsBootable().setEntity(false);
                    diskModel.getIsBootable().setIsChangable(false);
                    break;
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#method_after
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#end_block

#method_before
private void updateShareable(VolumeType volumeType, StorageType storageType) {
    if (storageType.isBlockDomain() && volumeType == VolumeType.Sparse) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupportedByConfiguration());
        getIsShareable().setIsChangable(false);
        getIsShareable().setEntity(false);
    } else {
        getIsShareable().setIsChangable(getVm() != null && getVm().isDown());
    }
}
#method_after
private void updateShareable(VolumeType volumeType, StorageType storageType) {
    if (storageType.isBlockDomain() && volumeType == VolumeType.Sparse) {
        getIsShareable().setChangeProhibitionReason(CONSTANTS.shareableDiskNotSupportedByConfiguration());
        getIsShareable().setIsChangable(false);
        getIsShareable().setEntity(false);
    } else {
        getIsShareable().setIsChangable(isEditEnabled());
    }
}
#end_block

#method_before
public void updateInterface(Version clusterVersion) {
    getDiskInterface().setItems(AsyncDataProvider.getDiskInterfaceList(clusterVersion));
}
#method_after
public void updateInterface(final Version clusterVersion) {
    if (getVm() != null) {
        AsyncDataProvider.isVirtioScsiEnabledForVm(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue1) {
                final boolean isVirtioScsiDisabled = Boolean.FALSE.equals(returnValue1);
                AsyncQuery asyncQuery = new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue2) {
                        ArrayList<DiskInterface> diskInterfaces = (ArrayList<DiskInterface>) returnValue2;
                        if (isVirtioScsiDisabled) {
                            diskInterfaces.remove(DiskInterface.VirtIO_SCSI);
                        }
                        setInterfaces(diskInterfaces);
                    }
                });
                AsyncDataProvider.getDiskInterfaceList(getVm().getOs(), clusterVersion, asyncQuery);
            }
        }), getVm().getId());
    } else {
        setInterfaces(AsyncDataProvider.getDiskInterfaceList());
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.EntityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.EntityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryStartedEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.getInstance().getQueryCompleteEventDefinition()) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#end_block

#method_before
@Override
public void setEntity(Object value) {
    if (value == null || !value.equals(getEntity())) {
        super.setEntity(value);
    }
}
#method_after
@Override
public void setEntity(Object value) {
    if (value == null || !value.equals(getEntity())) {
        super.setEntity(value);
        updateActionAvailability();
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    StorageDomain storageDomain = (StorageDomain) getEntity();
    @SuppressWarnings("unchecked")
    ArrayList<RepoImage> selectedImages = getSelectedItems() != null ? (ArrayList<RepoImage>) getSelectedItems() : new ArrayList<RepoImage>();
    getImportImagesCommand().setIsExecutionAllowed(storageDomain != null && storageDomain.getStorageType() == StorageType.GLANCE && selectedImages.size() > 0);
}
#method_after
private void updateActionAvailability() {
    StorageDomain storageDomain = (StorageDomain) getEntity();
    @SuppressWarnings("unchecked")
    ArrayList<RepoImage> selectedImages = getSelectedItems() != null ? (ArrayList<RepoImage>) getSelectedItems() : new ArrayList<RepoImage>();
    if (storageDomain != null && storageDomain.getStorageType() == StorageType.GLANCE) {
        getImportImagesCommand().setIsAvailable(true);
        getImportImagesCommand().setIsExecutionAllowed(selectedImages.size() > 0);
    } else {
        getImportImagesCommand().setIsAvailable(false);
    }
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.setMessage(ConstantsManager.getInstance().getConstants().disksMsg());
    model.getLatch().setIsAvailable(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setIsAvailable(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((operationType == null) ? 0 : operationType.hashCode());
    result = prime * result + ((operationCallback == null) ? 0 : operationCallback.hashCode());
    result = prime * result + ((parameter == null) ? 0 : parameter.hashCode());
    result = prime * result + ((source == null) ? 0 : source.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((operationType == null) ? 0 : operationType.hashCode());
    result = prime * result + ((parameter == null) ? 0 : parameter.hashCode());
    result = prime * result + ((source == null) ? 0 : source.hashCode());
    return result;
}
#end_block

#method_before
public void setThreshold(final int threshouldCount) {
    threshold = threshouldCount;
}
#method_after
public void setThreshold(final int thresholdCount) {
    threshold = thresholdCount;
}
#end_block

#method_before
@Override
public void scheduleDeferred(ScheduledCommand cmd) {
    callCount++;
    if (callCount >= threshold) {
        cmd.execute();
    }
}
#method_after
@Override
public void scheduleDeferred(ScheduledCommand cmd) {
    callCount++;
    if (callCount >= threshold) {
        // threshold matched, execute the command.
        cmd.execute();
    }
}
#end_block

#method_before
@Override
public void scheduleEntry(RepeatingCommand cmd) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleEntry(RepeatingCommand cmd) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleEntry(ScheduledCommand cmd) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleEntry(ScheduledCommand cmd) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleFinally(RepeatingCommand cmd) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleFinally(RepeatingCommand cmd) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleFinally(ScheduledCommand cmd) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleFinally(ScheduledCommand cmd) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleFixedDelay(RepeatingCommand cmd, int delayMs) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleFixedDelay(RepeatingCommand cmd, int delayMs) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleFixedPeriod(RepeatingCommand cmd, int delayMs) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleFixedPeriod(RepeatingCommand cmd, int delayMs) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
@Override
public void scheduleIncremental(RepeatingCommand cmd) {
// TODO Auto-generated method stub
}
#method_after
@Override
public void scheduleIncremental(RepeatingCommand cmd) {
    // $NON-NLS-1$
    throw new RuntimeException("Not implemented");
}
#end_block

#method_before
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#method_after
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    profileList = new VnicProfileListModel();
    list.add(profileList);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#end_block

#method_before
private void tagListModel_SelectedItemsChanged(Object sender, EventArgs e) {
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    boolean hadSelectedTags = getHasSelectedTags();
    updateHasSelectedTags();
    dataCenterList.setIsAvailable(!getHasSelectedTags());
    clusterList.setIsAvailable(!getHasSelectedTags());
    hostList.setIsAvailable(true);
    storageList.setIsAvailable(!getHasSelectedTags());
    vmList.setIsAvailable(true);
    volumeList.setIsAvailable(true);
    poolList.setIsAvailable(!getHasSelectedTags());
    templateList.setIsAvailable(!getHasSelectedTags());
    userList.setIsAvailable(true);
    eventList.setIsAvailable(!getHasSelectedTags());
    reportsList.setIsAvailable(ReportInit.getInstance().isReportsEnabled() && !getHasSelectedTags());
    networkList.setIsAvailable(!getHasSelectedTags());
    providerList.setIsAvailable(!getHasSelectedTags());
    // Switch the selected item as neccessary.
    ListModel oldSelectedItem = getSelectedItem();
    if (getHasSelectedTags() && oldSelectedItem != hostList && oldSelectedItem != volumeList && oldSelectedItem != vmList && oldSelectedItem != userList) {
        setSelectedItem(vmList);
    } else // Update search string only when selecting or de-selecting tags
    if (getHasSelectedTags() || hadSelectedTags) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        searchStringChanged();
    }
}
#method_after
private void tagListModel_SelectedItemsChanged(Object sender, EventArgs e) {
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    boolean hadSelectedTags = getHasSelectedTags();
    updateHasSelectedTags();
    if (getHasSelectedTags()) {
        setAllListModelsUnavailable();
        hostList.setIsAvailable(true);
        vmList.setIsAvailable(true);
        userList.setIsAvailable(true);
    } else {
        updateAvailability(SystemTreeItemType.System, null);
    }
    // Switch the selected item as neccessary.
    ListModel oldSelectedItem = getSelectedItem();
    if (getHasSelectedTags() && oldSelectedItem != hostList && oldSelectedItem != volumeList && oldSelectedItem != vmList && oldSelectedItem != userList) {
        setSelectedItem(vmList);
    } else // Update search string only when selecting or de-selecting tags
    if (getHasSelectedTags() || hadSelectedTags) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        searchStringChanged();
    }
}
#end_block

#method_before
private void bookmarkListModel_Navigated(Object sender, BookmarkEventArgs e) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    for (SearchableListModel item : getItems()) {
        item.setIsAvailable(true);
    }
    // $NON-NLS-1$
    setSearchStringPrefix("");
    setSearchString(e.getBookmark().getbookmark_value());
    getSearchCommand().execute();
}
#method_after
private void bookmarkListModel_Navigated(Object sender, BookmarkEventArgs e) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    // the main tabs that should appear when a bookmark is selected should
    // be the exact same main tabs that are displayed when the "System" node
    // in the system tree is selected.
    updateAvailability(SystemTreeItemType.System, null);
    // $NON-NLS-1$
    setSearchStringPrefix("");
    setSearchString(e.getBookmark().getbookmark_value());
    getSearchCommand().execute();
}
#end_block

#method_before
private void systemTree_ItemChanged(Object sender, EventArgs args) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    updateHasSelectedTags();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    if (model == null) {
        return;
    }
    // Update items availability depending on system tree selection.
    dataCenterList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.DataCenters);
    clusterList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Clusters || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.Network || model.getType() == SystemTreeItemType.System);
    hostList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Hosts || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.Network || model.getType() == SystemTreeItemType.System);
    volumeList.setIsAvailable(model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Volume || model.getType() == SystemTreeItemType.Volumes || model.getType() == SystemTreeItemType.System);
    if (model.getType() == SystemTreeItemType.Cluster) {
        volumeList.setIsAvailable(false);
    }
    storageList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Storages || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.System);
    quotaList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter);
    boolean isDataStorage = false;
    if (model.getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) model.getEntity();
        isDataStorage = storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master;
    }
    diskList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || isDataStorage || model.getType() == SystemTreeItemType.System);
    vmList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Network || isDataStorage || model.getType() == SystemTreeItemType.VMs || model.getType() == SystemTreeItemType.System);
    poolList.setIsAvailable(model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster);
    templateList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Network || isDataStorage || model.getType() == SystemTreeItemType.Templates || model.getType() == SystemTreeItemType.System);
    if (model.getType() == SystemTreeItemType.Cluster_Gluster) {
        VDSGroup cluster = (VDSGroup) model.getEntity();
        if (!cluster.supportsVirtService()) {
            vmList.setIsAvailable(false);
            templateList.setIsAvailable(false);
            storageList.setIsAvailable(false);
            poolList.setIsAvailable(false);
        }
    }
    userList.setIsAvailable(model.getType() == SystemTreeItemType.System);
    eventList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.Volume);
    reportsList.setIsAvailable(ReportInit.getInstance().isReportsEnabled() && ReportInit.getInstance().getDashboard(model.getType().toString()) != null);
    networkList.setIsAvailable(model.getType() == SystemTreeItemType.Network || model.getType() == SystemTreeItemType.Networks || model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Host);
    providerList.setIsAvailable(model.getType() == SystemTreeItemType.Providers || model.getType() == SystemTreeItemType.Provider);
    // Select a default item depending on system tree selection.
    ListModel oldSelectedItem = getSelectedItem();
    // Do not Change Tab if the Selection is the Reports
    if (!reportsList.getIsAvailable() || getSelectedItem() != reportsList) {
        changeSelectedTabIfNeeded(model);
    } else {
        reportsList.refreshReportModel();
    }
    // search string will be updated in OnSelectedItemChanged method.
    if (getSelectedItem() == oldSelectedItem) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        if (getSelectedItem() instanceof ISupportSystemTreeContext) {
            ISupportSystemTreeContext treeContext = (ISupportSystemTreeContext) getSelectedItem();
            treeContext.setSystemTreeSelectedItem((SystemTreeItemModel) getSystemTree().getSelectedItem());
        }
    }
}
#method_after
private void systemTree_ItemChanged(Object sender, EventArgs args) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    updateHasSelectedTags();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    if (model == null) {
        return;
    }
    updateAvailability(model.getType(), model.getEntity());
    // Select a default item depending on system tree selection.
    ListModel oldSelectedItem = getSelectedItem();
    // Do not Change Tab if the Selection is the Reports
    if (!reportsList.getIsAvailable() || getSelectedItem() != reportsList) {
        changeSelectedTabIfNeeded(model);
    } else {
        reportsList.refreshReportModel();
    }
    // search string will be updated in OnSelectedItemChanged method.
    if (getSelectedItem() == oldSelectedItem) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        if (getSelectedItem() instanceof ISupportSystemTreeContext) {
            ISupportSystemTreeContext treeContext = (ISupportSystemTreeContext) getSelectedItem();
            treeContext.setSystemTreeSelectedItem((SystemTreeItemModel) getSystemTree().getSelectedItem());
        }
    }
}
#end_block

#method_before
private void splitSearchString(String source, RefObject<String> prefix, RefObject<String> search) {
    ArrayList<TagModel> tags = (ArrayList<TagModel>) getTagList().getSelectedItems();
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    // $NON-NLS-1$
    prefix.argvalue = "";
    // Split for tags.
    if (tags != null && tags.size() > 0) {
        // $NON-NLS-1$
        Regex regex = new Regex("tag\\s*=\\s*(?:[\\w-]+)(?:\\sor\\s)?", RegexOptions.IgnoreCase);
        // $NON-NLS-1$
        String[] array = source.split("[:]", -1);
        String entityClause = array[0];
        String searchClause = array[1];
        StringBuilder tagsClause = new StringBuilder();
        for (TagModel tag : tags) {
            // $NON-NLS-1$
            tagsClause.append("tag=").append(tag.getName().getEntity());
            if (tag != tags.get(tags.size() - 1)) {
                // $NON-NLS-1$
                tagsClause.append(" or ");
            }
        }
        // $NON-NLS-1$
        prefix.argvalue = entityClause + ": " + tagsClause.toString();
        // $NON-NLS-1$
        search.argvalue = regex.replace(searchClause, "").trim();
    } else // Split for system tree.
    if (model != null && model.getType() != SystemTreeItemType.System) {
        // $NON-NLS-1$ //$NON-NLS-2$
        getAutoCompleteModel().setFilter(new String[] { "or", "and" });
        switch(model.getType()) {
            case DataCenters:
                if (dataCenterList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "DataCenter:";
                }
                break;
            case DataCenter:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: datacenter = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: datacenter = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_datacenter = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Disk: datacenter.name = " + model.getTitle() + " and disk_type = image";
                    } else if (quotaList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Quota: storagepoolname = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: datacenter = " + model.getTitle();
                    }
                }
                break;
            case Clusters:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Cluster:
            case Cluster_Gluster:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + model.getTitle();
                    } else if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: cluster.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: cluster = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: cluster = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Cluster_network.cluster_name = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: cluster = " + model.getTitle();
                    }
                }
                break;
            case Hosts:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Host:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: host.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: Hosts.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: Hosts.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: host.name = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Host_network.host_name = " + model.getTitle();
                    }
                }
                break;
            case Volumes:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Volume:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Volume: name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: volume.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Events: volume.name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    }
                }
                break;
            case Storages:
                {
                    if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Storage:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: storage.name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: storage.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: storage.name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: storage.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Templates: storage.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_storage = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Disk: storages.name = " + model.getTitle();
                    }
                }
                break;
            case Templates:
                {
                    if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case VMs:
                {
                    if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model).getTitle();
                    }
                }
                break;
            case Networks:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Network:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Network: name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Cluster: Cluster_network.network_name = " + model.getTitle() + " Datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Host : Nic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Vm : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Template : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Providers:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider:";
                }
                break;
            case Provider:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider: name = " + model.getTitle();
                }
                break;
        }
        // $NON-NLS-1$
        prefix.argvalue = prefix.argvalue + " ";
        // $NON-NLS-1$
        search.argvalue = "";
    } else {
        search.argvalue = source;
        getAutoCompleteModel().setFilter(null);
    }
}
#method_after
private void splitSearchString(String source, RefObject<String> prefix, RefObject<String> search) {
    ArrayList<TagModel> tags = (ArrayList<TagModel>) getTagList().getSelectedItems();
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    // $NON-NLS-1$
    prefix.argvalue = "";
    // Split for tags.
    if (tags != null && tags.size() > 0) {
        // $NON-NLS-1$
        Regex regex = new Regex("tag\\s*=\\s*(?:[\\w-]+)(?:\\sor\\s)?", RegexOptions.IgnoreCase);
        // $NON-NLS-1$
        String[] array = source.split("[:]", -1);
        String entityClause = array[0];
        String searchClause = array[1];
        StringBuilder tagsClause = new StringBuilder();
        for (TagModel tag : tags) {
            // $NON-NLS-1$
            tagsClause.append("tag=").append(tag.getName().getEntity());
            if (tag != tags.get(tags.size() - 1)) {
                // $NON-NLS-1$
                tagsClause.append(" or ");
            }
        }
        // $NON-NLS-1$
        prefix.argvalue = entityClause + ": " + tagsClause.toString();
        // $NON-NLS-1$
        search.argvalue = regex.replace(searchClause, "").trim();
    } else // Split for system tree.
    if (model != null && model.getType() != SystemTreeItemType.System) {
        // $NON-NLS-1$ //$NON-NLS-2$
        getAutoCompleteModel().setFilter(new String[] { "or", "and" });
        switch(model.getType()) {
            case DataCenters:
                if (dataCenterList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "DataCenter:";
                }
                break;
            case DataCenter:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: datacenter = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: datacenter = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_datacenter = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Disk: datacenter.name = " + model.getTitle() + " and disk_type = image";
                    } else if (quotaList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Quota: storagepoolname = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: datacenter = " + model.getTitle();
                    } else if (profileList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "VnicProfile: datacenter = " + model.getTitle();
                    }
                }
                break;
            case Clusters:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Cluster:
            case Cluster_Gluster:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + model.getTitle();
                    } else if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: cluster.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: cluster = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: cluster = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Cluster_network.cluster_name = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: cluster = " + model.getTitle();
                    }
                }
                break;
            case Hosts:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Host:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: host.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: Hosts.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: Hosts.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: host.name = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Host_network.host_name = " + model.getTitle();
                    }
                }
                break;
            case Volumes:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Volume:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Volume: name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: volume.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Events: volume.name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    }
                }
                break;
            case Storages:
                {
                    if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Storage:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: storage.name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: storage.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: storage.name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: storage.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Templates: storage.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_storage = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Disk: storages.name = " + model.getTitle();
                    }
                }
                break;
            case Templates:
                {
                    if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case VMs:
                {
                    if (vmList.isSearchStringMatch(source)) {
                        SystemTreeItemModel ancestor = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (ancestor == null) {
                            ancestor = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + ancestor.getTitle();
                    }
                }
                break;
            case Networks:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Network:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Network: name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Cluster: Cluster_network.network_name = " + model.getTitle() + " Datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Host : Nic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Vm : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Template : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (profileList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "VnicProfile : network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Providers:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider:";
                }
                break;
            case Provider:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider: name = " + model.getTitle();
                }
                break;
        }
        // $NON-NLS-1$
        prefix.argvalue = prefix.argvalue + " ";
        // $NON-NLS-1$
        search.argvalue = "";
    } else {
        search.argvalue = source;
        getAutoCompleteModel().setFilter(null);
    }
}
#end_block

#method_before
public VdcUser getLoggedInUser() {
    return loggedInUser;
}
#method_after
public DbUser getLoggedInUser() {
    return loggedInUser;
}
#end_block

#method_before
public void setLoggedInUser(VdcUser value) {
    if (loggedInUser != value) {
        loggedInUser = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("LoggedInUser"));
    }
}
#method_after
public void setLoggedInUser(DbUser value) {
    if (loggedInUser != value) {
        loggedInUser = value;
        // $NON-NLS-1$
        onPropertyChanged(new PropertyChangedEventArgs("LoggedInUser"));
    }
}
#end_block

#method_before
private void edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageEditable = model.isStorageActive() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getComment().setIsChangable(isStorageEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageEditable);
    boolean isPathEditable = isPathEditable(storage);
    isStorageEditable = isStorageEditable || isPathEditable;
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            model.getHost().setIsChangable(isPathEditable);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() != SystemTreeItemType.System) {
        switch(getSystemTreeSelectedItem().getType()) {
            case Storage:
                {
                    model.getName().setIsChangable(false);
                    // $NON-NLS-1$
                    model.getName().setInfo("Cannot edit Storage Domains's Name in this tree context");
                }
                break;
        }
    }
    UICommand command;
    if (isStorageEditable) {
        // $NON-NLS-1$
        command = createOKCommand("OnSave");
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#method_after
private void edit() {
    StorageDomain storage = (StorageDomain) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    StorageModel model = new StorageModel(new NewEditStorageModelBehavior());
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().editDomainTitle());
    // $NON-NLS-1$
    model.setHashName("edit_domain");
    model.setSystemTreeSelectedItem(getSystemTreeSelectedItem());
    model.setStorage(storage);
    model.getName().setEntity(storage.getStorageName());
    model.getDescription().setEntity(storage.getDescription());
    model.getComment().setEntity(storage.getComment());
    model.setOriginalName(storage.getStorageName());
    model.getDataCenter().setIsChangable(false);
    model.getFormat().setIsChangable(false);
    boolean isStorageEditable = model.isStorageActive() || model.isNewStorage();
    model.getHost().setIsChangable(false);
    model.getName().setIsChangable(isStorageEditable);
    model.getDescription().setIsChangable(isStorageEditable);
    model.getComment().setIsChangable(isStorageEditable);
    // set the field domain type to non editable
    model.getAvailableStorageItems().setIsChangable(false);
    model.setIsChangable(isStorageEditable);
    boolean isPathEditable = isPathEditable(storage);
    isStorageEditable = isStorageEditable || isPathEditable;
    IStorageModel item = null;
    switch(storage.getStorageType()) {
        case NFS:
            item = prepareNfsStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case FCP:
            item = prepareFcpStorageForEdit(storage);
            break;
        case ISCSI:
            item = prepareIscsiStorageForEdit(storage);
            break;
        case LOCALFS:
            item = prepareLocalStorageForEdit(storage);
            model.getHost().setIsChangable(isPathEditable);
            break;
        case POSIXFS:
            item = preparePosixStorageForEdit(storage);
            // when storage is active, only SPM can perform actions on it, thus it is set above that host is not changeable.
            // If storage is editable but not active (maintenance) - any host can perform the edit so the changeable here is set based on that
            model.getHost().setIsChangable(isPathEditable);
            break;
        case GLUSTERFS:
            item = prepareGlusterStorageForEdit(storage);
            break;
    }
    model.setItems(new ArrayList<IStorageModel>(Arrays.asList(new IStorageModel[] { item })));
    model.setSelectedItem(item);
    model.initialize();
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage) {
        model.getName().setIsChangable(false);
        model.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    UICommand command;
    if (isStorageEditable) {
        // $NON-NLS-1$
        command = createOKCommand("OnSave");
        model.getCommands().add(command);
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        model.getCommands().add(command);
    } else {
        // close is created the same as cancel, but with a different title
        // thus most of creation code can be reused.
        // $NON-NLS-1$
        command = createCancelCommand("Cancel");
        command.setTitle(ConstantsManager.getInstance().getConstants().close());
        model.getCommands().add(command);
    }
}
#end_block

#method_before
private boolean isPathEditable(StorageDomain storage) {
    if (storage.getStorageType().isFileDomain() && !storage.getStorageType().equals(StorageType.GLUSTERFS)) {
        return ((storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master) && storage.getStatus() == StorageDomainStatus.Maintenance);
    }
    return false;
}
#method_after
private boolean isPathEditable(StorageDomain storage) {
    if (storage.getStorageType().isFileDomain() && !storage.getStorageType().equals(StorageType.GLUSTERFS)) {
        return ((storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master) && (storage.getStatus() == StorageDomainStatus.Maintenance || storage.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached));
    }
    return false;
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    model.setMessage(ConstantsManager.getInstance().getConstants().areYouSureYouWantToRemoveTheStorageDomainMsg());
    model.getFormat().setIsAvailable(false);
    AsyncDataProvider.getHostListByStatus(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setIsAvailable(storage.getStorageDomainType() == StorageDomainType.ISO || storage.getStorageDomainType() == StorageDomainType.ImportExport);
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), VDSStatus.Up);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    RemoveStorageModel model = new RemoveStorageModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeStoragesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_storage");
    model.getFormat().setIsAvailable(false);
    StorageDomain storage = (StorageDomain) getSelectedItem();
    boolean localFsOnly = storage.getStorageType() == StorageType.LOCALFS;
    AsyncDataProvider.getHostsForStorageOperation(new AsyncQuery(new Object[] { this, model }, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            Object[] array = (Object[]) target;
            StorageListModel storageListModel = (StorageListModel) array[0];
            RemoveStorageModel removeStorageModel = (RemoveStorageModel) array[1];
            StorageDomain storage = (StorageDomain) storageListModel.getSelectedItem();
            ArrayList<VDS> hosts = (ArrayList<VDS>) returnValue;
            removeStorageModel.getHostList().setItems(hosts);
            removeStorageModel.getHostList().setSelectedItem(Linq.firstOrDefault(hosts));
            removeStorageModel.getFormat().setIsAvailable(storage.getStorageDomainType() == StorageDomainType.ISO || storage.getStorageDomainType() == StorageDomainType.ImportExport);
            if (hosts.isEmpty()) {
                // $NON-NLS-1$
                UICommand tempVar = createCancelCommand("Cancel");
                tempVar.setIsDefault(true);
                removeStorageModel.getCommands().add(tempVar);
            } else {
                UICommand command;
                // $NON-NLS-1$
                command = createOKCommand("OnRemove");
                removeStorageModel.getCommands().add(command);
                // $NON-NLS-1$
                command = createCancelCommand("Cancel");
                removeStorageModel.getCommands().add(command);
            }
        }
    }), null, localFsOnly);
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    StorageDomain item = (StorageDomain) getSelectedItem();
    getNewDomainCommand().setIsAvailable(true);
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && isEditAvailable(item));
    getRemoveCommand().setIsExecutionAllowed(items.size() == 1 && items.get(0).getStorageType() != StorageType.GLANCE && Linq.findAllStorageDomainsBySharedStatus(items, StorageDomainSharedStatus.Unattached).size() == items.size());
    getDestroyCommand().setIsExecutionAllowed(item != null && items.size() == 1 && item.getStatus() != StorageDomainStatus.Active);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage);
    getNewDomainCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    ArrayList<StorageDomain> items = getSelectedItems() != null ? Linq.<StorageDomain>cast(getSelectedItems()) : new ArrayList<StorageDomain>();
    StorageDomain item = (StorageDomain) getSelectedItem();
    getNewDomainCommand().setIsAvailable(true);
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && isEditAvailable(item));
    getRemoveCommand().setIsExecutionAllowed(items.size() == 1 && items.get(0).getStorageType() != StorageType.GLANCE && Linq.findAllStorageDomainsBySharedStatus(items, StorageDomainSharedStatus.Unattached).size() == items.size());
    getDestroyCommand().setIsExecutionAllowed(item != null && items.size() == 1 && items.get(0).getStorageType() != StorageType.GLANCE && item.getStatus() != StorageDomainStatus.Active);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Storage);
    getNewDomainCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getDestroyCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
private boolean isEditAvailable(StorageDomain storageDomain) {
    if (storageDomain == null) {
        return false;
    }
    boolean isEditAvailable;
    boolean isActive = storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Active || storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Mixed;
    boolean isInMaintenance = (storageDomain.getStatus() == StorageDomainStatus.Maintenance);
    boolean isDataDomain = (storageDomain.getStorageDomainType() == StorageDomainType.Data) || (storageDomain.getStorageDomainType() == StorageDomainType.Master);
    boolean isBlockStorage = storageDomain.getStorageType().isBlockDomain();
    isEditAvailable = isActive || isBlockStorage || (isInMaintenance && isDataDomain);
    return isEditAvailable;
}
#method_after
private boolean isEditAvailable(StorageDomain storageDomain) {
    if (storageDomain == null) {
        return false;
    }
    boolean isEditAvailable;
    boolean isActive = storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Active || storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Mixed;
    boolean isInMaintenance = (storageDomain.getStatus() == StorageDomainStatus.Maintenance);
    boolean isUnattached = (storageDomain.getStorageDomainSharedStatus() == StorageDomainSharedStatus.Unattached);
    boolean isDataDomain = (storageDomain.getStorageDomainType() == StorageDomainType.Data) || (storageDomain.getStorageDomainType() == StorageDomainType.Master);
    boolean isBlockStorage = storageDomain.getStorageType().isBlockDomain();
    isEditAvailable = isActive || isBlockStorage || ((isInMaintenance || isUnattached) && isDataDomain);
    return isEditAvailable;
}
#end_block

#method_before
private void updatePath() {
    StorageModel model = (StorageModel) getWindow();
    VDS host = (VDS) model.getHost().getSelectedItem();
    Guid hostId = Guid.Empty;
    Guid storagePoolId = Guid.Empty;
    if (host != null) {
        hostId = host.getId();
        storagePoolId = host.getStoragePoolId();
    }
    IStorageModel storageModel = model.getSelectedItem();
    connection = new StorageServerConnections();
    connection.setid(storageDomain.getStorage());
    connection.setconnection(path);
    connection.setstorage_type(storageModel.getType());
    if (storageModel.getType().equals(StorageType.NFS)) {
        updateNFSProperties(storageModel);
    } else if (storageModel.getType().equals(StorageType.POSIXFS)) {
        updatePosixProperties(storageModel);
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId);
    parameters.setStoragePoolId(storagePoolId);
    Frontend.RunAction(VdcActionType.UpdateStorageServerConnection, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    }, this);
}
#method_after
private void updatePath() {
    StorageModel model = (StorageModel) getWindow();
    VDS host = (VDS) model.getHost().getSelectedItem();
    Guid hostId = Guid.Empty;
    if (host != null) {
        hostId = host.getId();
    }
    IStorageModel storageModel = model.getSelectedItem();
    connection = new StorageServerConnections();
    connection.setid(storageDomain.getStorage());
    connection.setconnection(path);
    connection.setstorage_type(storageModel.getType());
    if (storageModel.getType().equals(StorageType.NFS)) {
        updateNFSProperties(storageModel);
    } else if (storageModel.getType().equals(StorageType.POSIXFS)) {
        updatePosixProperties(storageModel);
    }
    StorageServerConnectionParametersBase parameters = new StorageServerConnectionParametersBase(connection, hostId);
    Frontend.RunAction(VdcActionType.UpdateStorageServerConnection, parameters, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            StorageListModel storageListModel = (StorageListModel) result.getState();
            storageListModel.onFinish(storageListModel.context, true, storageListModel.storageModel);
        }
    }, this);
}
#end_block

#method_before
public void importFileStorageAddDomain(ArrayList<StorageDomain> domains) {
    StorageDomain sdToAdd = Linq.firstOrDefault(domains);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.RunAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = (StoragePool) model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId());
                }
                postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
            }
        }
    }, new Object[] { this, sdToAdd });
}
#method_after
public void importFileStorageAddDomain(ArrayList<StorageDomain> domains) {
    StorageDomain sdToAdd = Linq.firstOrDefault(domains);
    StorageDomainStatic sdsToAdd = sdToAdd.getStorageStaticData();
    StorageDomainManagementParameter params = new StorageDomainManagementParameter(sdsToAdd);
    params.setVdsId(hostId);
    Frontend.RunAction(VdcActionType.AddExistingFileStorageDomain, params, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            Object[] array = (Object[]) result.getState();
            StorageListModel storageListModel = (StorageListModel) array[0];
            StorageDomain sdToAdd1 = (StorageDomain) array[1];
            VdcReturnValueBase returnVal = result.getReturnValue();
            boolean success = returnVal != null && returnVal.getSucceeded();
            if (success) {
                StorageModel model = (StorageModel) storageListModel.getWindow();
                StoragePool dataCenter = (StoragePool) model.getDataCenter().getSelectedItem();
                if (!dataCenter.getId().equals(StorageModel.UnassignedDataCenterId)) {
                    storageListModel.attachStorageToDataCenter(sdToAdd1.getId(), dataCenter.getId());
                    onFinish(storageListModel.context, true, storageListModel.storageModel, null);
                } else {
                    postImportFileStorage(storageListModel.context, true, storageListModel.storageModel, null);
                }
            } else {
                // $NON-NLS-1$
                postImportFileStorage(storageListModel.context, false, storageListModel.storageModel, "");
            }
        }
    }, new Object[] { this, sdToAdd });
}
#end_block

#method_before
private UICommand createCancelCommand(String commandName) {
    UICommand command;
    // $NON-NLS-1$
    command = new UICommand(commandName, this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    return command;
}
#method_after
private UICommand createCancelCommand(String commandName) {
    UICommand command;
    command = new UICommand(commandName, this);
    command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    command.setIsCancel(true);
    return command;
}
#end_block

#method_before
public void addOperation(final VdcOperation<?, ?> operation) {
    addOperation(operation, false);
}
#method_after
public boolean addOperation(final VdcOperation<?, ?> operation) {
    return addOperation(operation, false);
}
#end_block

#method_before
private void addOperation(final VdcOperation<?, ?> operation, final boolean isPublic) {
    // an action (allows duplicates). Then add this operation to the queue, and process the queue immediately.
    if ((loggedIn || isPublic) && (!operationQueue.contains(operation) || operation.allowDuplicates()) && operationQueue.add(operation)) {
        processor.processOperation(this);
    }
}
#method_after
private boolean addOperation(final VdcOperation<?, ?> operation, final boolean isPublic) {
    // If the user is logged in, or the user is not logged in and the operation does not allow duplicates (aka
    // it is a query, and not an action). And the operation is not already in the queue || the operation is
    // an action (allows duplicates). Then add this operation to the queue, and process the queue immediately.
    final boolean isAllowedToExecute = loggedIn || isPublic;
    final boolean operationCanBeAdded = !operationQueue.contains(operation) || operation.allowDuplicates();
    if (isAllowedToExecute) {
        if (operationCanBeAdded && operationQueue.add(operation)) {
            processor.processOperation(this);
        }
    }
    return isAllowedToExecute;
}
#end_block

#method_before
public void addOperationList(final List<VdcOperation<?, ?>> operationList) {
    for (VdcOperation<?, ?> operation : operationList) {
        addOperation(operation, false);
    }
    // Call the processor.
    processor.processOperation(this);
}
#method_after
public boolean addOperationList(final List<VdcOperation<?, ?>> operationList) {
    boolean allowed = true;
    for (VdcOperation<?, ?> operation : operationList) {
        if (!addOperation(operation, false)) {
            allowed = false;
        }
    }
    // Call the processor.
    processor.processOperation(this);
    return allowed;
}
#end_block

#method_before
public void logoutUser(final Object userObject, final VdcUserCallback<?> callback) {
    loggedIn = false;
    processor.logoutUser(userObject, callback);
}
#method_after
public void logoutUser(final Object userObject, final UserCallback<?> callback) {
    loggedIn = false;
    processor.logoutUser(userObject, callback);
}
#end_block

#method_before
@Override
public VdcUser getLoggedUser() {
    privateLoggedUser.setPassword((String) getPassword().getEntity());
    return privateLoggedUser;
}
#method_after
@Override
public DbUser getLoggedUser() {
    return privateLoggedUser;
}
#end_block

#method_before
@Override
protected void setLoggedUser(VdcUser value) {
    privateLoggedUser = value;
}
#method_after
@Override
protected void setLoggedUser(DbUser value) {
    privateLoggedUser = value;
}
#end_block

#method_before
@Override
public void login() {
    // Completely override the base class functionality.
    if (!validate()) {
        return;
    }
    startProgress(null);
    getUserName().setIsChangable(false);
    getPassword().setIsChangable(false);
    getDomain().setIsChangable(false);
    getLoginCommand().setIsExecutionAllowed(false);
    getIsAutoConnect().setIsChangable(false);
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(final Object model, final Object result) {
            UserPortalLoginModel loginModel = (UserPortalLoginModel) model;
            VdcReturnValueBase returnValue = (VdcReturnValueBase) result;
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success) {
                loginModel.setLoggedUser((VdcUser) returnValue.getActionReturnValue());
                loginModel.raiseLoggedInEvent();
            } else {
                // $NON-NLS-1$
                loginModel.getPassword().setEntity("");
                if (returnValue != null) {
                    loginModel.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                }
                loginModel.getUserName().setIsChangable(true);
                loginModel.getPassword().setIsChangable(true);
                loginModel.getDomain().setIsChangable(true);
                loginModel.getLoginCommand().setIsExecutionAllowed(true);
                getIsAutoConnect().setIsChangable(true);
                loginModel.getLoginFailedEvent().raise(this, EventArgs.Empty);
            }
            stopProgress();
        }
    };
    Frontend.LoginAsync((String) getUserName().getEntity(), (String) getPassword().getEntity(), (String) getDomain().getSelectedItem(), false, asyncQuery);
}
#method_after
@Override
public void login() {
    // Completely override the base class functionality.
    if (!validate()) {
        getLoginFailedEvent().raise(this, EventArgs.Empty);
        return;
    }
    startProgress(null);
    getUserName().setIsChangable(false);
    getPassword().setIsChangable(false);
    getDomain().setIsChangable(false);
    getLoginCommand().setIsExecutionAllowed(false);
    getIsAutoConnect().setIsChangable(false);
    AsyncQuery asyncQuery = new AsyncQuery();
    asyncQuery.setModel(this);
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(final Object model, final Object result) {
            UserPortalLoginModel loginModel = (UserPortalLoginModel) model;
            VdcReturnValueBase returnValue = (VdcReturnValueBase) result;
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success) {
                loginModel.setLoggedUser((DbUser) returnValue.getActionReturnValue());
                loginModel.raiseLoggedInEvent();
            } else {
                // $NON-NLS-1$
                loginModel.getPassword().setEntity("");
                if (returnValue != null) {
                    loginModel.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                }
                loginModel.getUserName().setIsChangable(true);
                loginModel.getPassword().setIsChangable(true);
                loginModel.getDomain().setIsChangable(true);
                loginModel.getLoginCommand().setIsExecutionAllowed(true);
                getIsAutoConnect().setIsChangable(true);
                loginModel.getLoginFailedEvent().raise(this, EventArgs.Empty);
            }
            stopProgress();
        }
    };
    Frontend.LoginAsync((String) getUserName().getEntity(), (String) getPassword().getEntity(), (String) getDomain().getSelectedItem(), false, asyncQuery);
}
#end_block

#method_before
// Update IsENGINEUser flag.
public void updateIsENGINEUser(VdcUser LoggedUser) {
    setENGINEUserActionGroupList(new ArrayList<ActionGroup>());
    this.setLoggedUser(LoggedUser);
    AsyncDataProvider.getRoleActionGroupsByRoleId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalLoginModel loginModel = (UserPortalLoginModel) target;
            loginModel.setENGINEUserActionGroupList((ArrayList<ActionGroup>) returnValue);
            // a user 'stays' a user if he has consume quota action group.
            // so we need to apply the same logic to this ActionGroup as for
            // engine user role's action group.
            loginModel.getENGINEUserActionGroupList().add(ConsumeQuotaActionGroup);
            loginModel.getUserRoles(loginModel);
        }
    }), ApplicationGuids.engineUser.asGuid());
}
#method_after
// Update IsENGINEUser flag.
public void updateIsENGINEUser(DbUser LoggedUser) {
    setENGINEUserActionGroupList(new ArrayList<ActionGroup>());
    this.setLoggedUser(LoggedUser);
    AsyncDataProvider.getRoleActionGroupsByRoleId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UserPortalLoginModel loginModel = (UserPortalLoginModel) target;
            loginModel.setENGINEUserActionGroupList((ArrayList<ActionGroup>) returnValue);
            // a user 'stays' a user if he has consume quota action group.
            // so we need to apply the same logic to this ActionGroup as for
            // engine user role's action group.
            loginModel.getENGINEUserActionGroupList().add(ConsumeQuotaActionGroup);
            loginModel.getUserRoles(loginModel);
        }
    }), ApplicationGuids.engineUser.asGuid());
}
#end_block

#method_before
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(Object targetObject) {
    UserPortalLoginModel loginModel = (UserPortalLoginModel) targetObject;
    AsyncDataProvider.getPermissionsByAdElementId(new AsyncQuery(targetObject, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<permissions> permissions = (ArrayList<permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (permissions permission : permissions) {
                // ALL Everyone/NetworkUser persmissions
                if (isEveyoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission) || isEveyoneNetworUserPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveyoneNetworUserPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.networkUser.asGuid());
        }

        private boolean isEveyoneUserPortalBasedVmPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getUserId());
}
#method_after
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(Object targetObject) {
    UserPortalLoginModel loginModel = (UserPortalLoginModel) targetObject;
    AsyncDataProvider.getPermissionsByAdElementId(new AsyncQuery(targetObject, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<permissions> permissions = (ArrayList<permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (permissions permission : permissions) {
                // ALL Everyone/NetworkUser persmissions
                if (isEveryoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission) || isEveryoneVnicProfileUserPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveryoneVnicProfileUserPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.vnicProfileUser.asGuid());
        }

        private boolean isEveryoneUserPortalBasedVmPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getId());
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.setMessage(ConstantsManager.getInstance().getConstants().disksMsg());
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private boolean isPlugAvailableByDisks(boolean plug) {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        boolean isLocked = disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED;
        if (disk.getPlugged() == plug || isLocked || (!AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), getEntity().getVdsGroupCompatibilityVersion()).contains(disk.getDiskInterface()) && !isVmDown())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isPlugAvailableByDisks(boolean plug) {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        boolean isLocked = disk.getDiskStorageType() == DiskStorageType.IMAGE && ((DiskImage) disk).getImageStatus() == ImageStatus.LOCKED;
        boolean isDiskHotpluggableInterface = false;
        if (getEntity() != null) {
            isDiskHotpluggableInterface = AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), getEntity().getVdsGroupCompatibilityVersion()).contains(disk.getDiskInterface());
        }
        if (disk.getPlugged() == plug || isLocked || (!isDiskHotpluggableInterface && !isVmDown())) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged()) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected void updateIsDiskHotPlugAvailable() {
    VM vm = getEntity();
    Version clusterCompatibilityVersion = vm.getVdsGroupCompatibilityVersion();
    if (clusterCompatibilityVersion == null) {
        setIsDiskHotPlugSupported(false);
    } else {
        setIsDiskHotPlugSupported((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.HotPlugEnabled, clusterCompatibilityVersion.toString()));
    }
}
#method_after
protected void updateIsDiskHotPlugAvailable() {
    VM vm = getEntity();
    Version clusterCompatibilityVersion = vm.getVdsGroupCompatibilityVersion();
    if (clusterCompatibilityVersion == null) {
        setIsDiskHotPlugSupported(false);
    } else {
        setIsDiskHotPlugSupported((Boolean) !AsyncDataProvider.getDiskHotpluggableInterfaces(getEntity().getOs(), clusterCompatibilityVersion).isEmpty());
    }
}
#end_block

#method_before
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = (Map<Pair<Integer, Version>, ArrayList<String>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#method_after
public static void initDiskHotpluggableInterfacesMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            diskHotpluggableInterfacesMap = (Map<Pair<Integer, Version>, Set<String>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskHotpluggableInterfacesMap), callback);
}
#end_block

#method_before
public static Map<Pair<Integer, Version>, ArrayList<String>> getDiskHotpluggableInterfacesMap() {
    return diskHotpluggableInterfacesMap;
}
#method_after
public static Map<Pair<Integer, Version>, Set<String>> getDiskHotpluggableInterfacesMap() {
    return diskHotpluggableInterfacesMap;
}
#end_block

#method_before
public static Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) {
    Pair<Integer, Version> pair = new Pair<Integer, Version>(osId, version);
    if (getDiskHotpluggableInterfacesMap().containsKey(pair)) {
        List<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(pair);
        if (diskHotpluggableInterfaces != null && !diskHotpluggableInterfaces.isEmpty()) {
            Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
            for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
                diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
            }
            return diskInterfaces;
        }
    }
    return Collections.emptyList();
}
#method_after
public static Collection<DiskInterface> getDiskHotpluggableInterfaces(Integer osId, Version version) {
    Set<String> diskHotpluggableInterfaces = getDiskHotpluggableInterfacesMap().get(new Pair<Integer, Version>(osId, version));
    if (diskHotpluggableInterfaces == null) {
        return Collections.emptySet();
    }
    Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
    for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
        diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
    }
    return diskInterfaces;
}
#end_block

#method_before
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.converterCallback = new IAsyncConverter<GlusterVolumeTaskStatusEntity>() {

        @Override
        public GlusterVolumeTaskStatusEntity Convert(Object source, AsyncQuery _asyncQuery) {
            return (GlusterVolumeTaskStatusEntity) source;
        }
    };
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList(Version clusterVersion) {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO }));
    boolean isVirtIOScsiEnabled = clusterVersion != null ? (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, clusterVersion.getValue()) : true;
    if (isVirtIOScsiEnabled) {
        diskInterfaces.add(DiskInterface.VirtIO_SCSI);
    }
    return diskInterfaces;
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static String getNewNicName(ArrayList<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#method_after
public static void initUniqueOsNames() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            uniqueOsNames = (HashMap<Integer, String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            // Initialize specific UI dependencies for search
            SimpleDependecyInjector.getInstance().bind(new OsValueAutoCompleter(uniqueOsNames));
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetUniqueOsNames), callback);
}
#end_block

#method_before
@Override
public void init(final ServletConfig config) throws ServletException {
    // Let the parent do its work:
    super.init(config);
    if (getServletConfig() != null) {
        // we use %{x} convention to avoid conflict with jboss properties
        targetContext = ServletUtils.getAsAbsoluteContext(getServletContext().getContextPath(), EngineLocalConfig.getInstance().expandString(config.getInitParameter(CONTEXT_PARAM).replaceAll("%\\{", "\\${")));
        uri = getInitParameter(URI_PARAM);
    }
    if (targetContext == null) {
        // $NON-NLS-1$
        throw new ServletException("Target context not defined in web.xml");
    }
}
#method_after
@Override
public void init(final ServletConfig config) throws ServletException {
    // Let the parent do its work:
    super.init(config);
    targetContext = config.getInitParameter(CONTEXT_PARAM);
    if (targetContext == null) {
        // $NON-NLS-1$
        throw new ServletException("Target context not defined in web.xml");
    }
    uri = config.getInitParameter(URI_PARAM);
    if (uri == null) {
        // $NON-NLS-1$
        throw new ServletException("Target URI not defined in web.xml");
    }
    // we use %{x} convention to avoid conflict with jboss properties
    EngineLocalConfig engineLocalConfig = EngineLocalConfig.getInstance();
    targetContext = ServletUtils.getAsAbsoluteContext(getServletContext().getContextPath(), engineLocalConfig.expandString(targetContext.replaceAll("%\\{", "\\${")));
    uri = engineLocalConfig.expandString(uri.replaceAll("%\\{", "\\${"));
}
#end_block

#method_before
public static String getSpiceBaseURL() {
    // $NON-NLS-1$
    return FrontendUrlUtils.getRootURL() + "ovirt-engine/services/files/spice/";
}
#method_after
public static String getSpiceBaseURL() {
    return FrontendUrlUtils.getRootURL() + HostPageConfiguration.getInstance().getBaseContextPath() + // $NON-NLS-1$
    "services/files/spice/";
}
#end_block

#method_before
public void updateUsbFilter() {
    // $NON-NLS-1$
    fetchFile("/ovirt-engine/services/files/usbfilter.txt", usbFilterFileFetchedEvent);
}
#method_after
public void updateUsbFilter() {
    fetchFile(HostPageConfiguration.getInstance().getBaseContextPath() + "services/files/usbfilter.txt", // $NON-NLS-1$
    usbFilterFileFetchedEvent);
}
#end_block

#method_before
private String replaceLocaleWithUSLocale(String originalString, Locale locale) {
    return replaceLocaleWithOtherLocale(originalString, locale, Locale.US);
}
#method_after
private String replaceLocaleWithUSLocale(String originalString, Locale locale) {
    return replaceLocaleWithOtherLocale(// $NON-NLS-1$
    originalString != null ? originalString : "", locale, Locale.US);
}
#end_block

#method_before
private void updateOptionsPostData() {
    if (disks == null) {
        return;
    }
    // Add disk action.
    // $NON-NLS-1$
    UICommand addDiskAction = new UICommand("AddDisk", this);
    if (disks.isEmpty()) {
        addDiskAction.setTitle(VmConfigureVirtualDisksAction);
        getCompulsoryActions().add(addDiskAction);
    } else {
        addDiskAction.setTitle(VmAddAnotherVirtualDiskAction);
        getOptionalActions().add(addDiskAction);
    }
    stopProgress();
}
#method_after
private void updateOptionsPostData(Collection<Disk> disks) {
    // Add disk action.
    // $NON-NLS-1$
    UICommand addDiskAction = new UICommand("AddDisk", this);
    if (disks.isEmpty()) {
        addDiskAction.setTitle(VmConfigureVirtualDisksAction);
        getCompulsoryActions().add(addDiskAction);
    } else {
        addDiskAction.setTitle(VmAddAnotherVirtualDiskAction);
        getOptionalActions().add(addDiskAction);
    }
    stopProgress();
}
#end_block

#method_before
private void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() != null) {
        startProgress(null);
        updateOptionsData();
    }
}
#method_after
public void updateOptions() {
    getCompulsoryActions().clear();
    getOptionalActions().clear();
    if (getEntity() != null) {
        startProgress(null);
        AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                updateOptionsPostData((Collection<Disk>) returnValue);
            }
        }), getEntity().getId());
    }
}
#end_block

#method_before
public void cancel() {
    resetData();
    setWindow(null);
    Frontend.Unsubscribe();
}
#method_after
public void cancel() {
    setWindow(null);
    Frontend.Unsubscribe();
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.converterCallback = new IAsyncConverter<GlusterVolumeTaskStatusEntity>() {

        @Override
        public GlusterVolumeTaskStatusEntity Convert(Object source, AsyncQuery _asyncQuery) {
            return (GlusterVolumeTaskStatusEntity) source;
        }
    };
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList(Version clusterVersion) {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO }));
    boolean isVirtIOScsiEnabled = clusterVersion != null ? (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, clusterVersion.getValue()) : true;
    if (isVirtIOScsiEnabled) {
        diskInterfaces.add(DiskInterface.VirtIO_SCSI);
    }
    return diskInterfaces;
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
private boolean isRemovableStatus(VDSStatus status) {
    switch(status) {
        case Up:
        case Down:
        case Maintenance:
            return true;
        default:
            return false;
    }
}
#method_after
private boolean isRemovableStatus(VDSStatus status) {
    switch(status) {
        case Up:
        case Down:
            return true;
        default:
            return false;
    }
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_INCOMPLETE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Test
public void testCDANonExistingVds() {
    doReturn(null).when(vdsDAOMock).get(vdsId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.VDS_NOT_EXIST);
}
#method_after
@Test
public void testCDANonExistingVds() {
    doReturn(null).when(vdsDAOMock).get(vdsId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail for non existing VDS", command, VdcBllMessages.VDS_NOT_EXIST);
}
#end_block

#method_before
@Test
public void testCDAVdsNotUp() {
    vds.setStatus(VDSStatus.Down);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_UP);
}
#method_after
@Test
public void testCDAVdsNotUp() {
    vds.setStatus(VDSStatus.Down);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail for a VDS with a status different from UP", command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_UP);
}
#end_block

#method_before
@Test
public void testCDAStoragePoolValid() {
    vds.setId(Guid.newGuid());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_IN_POOL);
}
#method_after
@Test
public void testCDAStoragePoolValid() {
    vds.setId(Guid.newGuid());
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail on mismatch Storage Pool", command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_IN_POOL);
}
#end_block

#method_before
@Test
public void testCDAVdsIsSPM() {
    vds.setSpmStatus(VdsSpmStatus.SPM);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_ALREADY_SPM);
}
#method_after
@Test
public void testCDAVdsIsSPM() {
    vds.setSpmStatus(VdsSpmStatus.SPM);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail on a VDS that is already set as SPM", command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_ALREADY_SPM);
}
#end_block

#method_before
@Test
public void testCDAVdsSPMPrioritySetToNever() {
    vds.setVdsSpmPriority(BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_MARKED_AS_NEVER_SPM);
}
#method_after
@Test
public void testCDAVdsSPMPrioritySetToNever() {
    vds.setVdsSpmPriority(BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail on a VDS that is set to never be elected as SPM", command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_MARKED_AS_NEVER_SPM);
}
#end_block

#method_before
@Test
public void testCDAStoragePoolNotUp() {
    storagePool.setStatus(StoragePoolStatus.Uninitialized);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
}
#method_after
@Test
public void testCDAStoragePoolNotUp() {
    storagePool.setStatus(StoragePoolStatus.Uninitialized);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail on a Storage Pool which is not up", command, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
}
#end_block

#method_before
@Test
public void testCDAStoragePoolHasTasks() {
    List<Guid> tasks = Arrays.asList(Guid.newGuid());
    doReturn(tasks).when(asyncTaskDAOMock).getAsyncTaskIdsByStoragePoolId(storagePoolId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_STORAGE_POOL_HAS_RUNNING_TASKS);
}
#method_after
@Test
public void testCDAStoragePoolHasTasks() {
    List<Guid> tasks = Arrays.asList(Guid.newGuid());
    doReturn(tasks).when(asyncTaskDAOMock).getAsyncTaskIdsByStoragePoolId(storagePoolId);
    CanDoActionTestUtils.runAndAssertCanDoActionFailure("canDoAction did not fail on a Storage Pool with running tasks", command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_STORAGE_POOL_HAS_RUNNING_TASKS);
}
#end_block

#method_before
@Override
public String render(T size) {
    if (size.longValue() > SizeConverter.BYTES_IN_GB) {
        return messages.rebalanceFileSizeGb(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.GB).longValue());
    } else if (size.longValue() > SizeConverter.BYTES_IN_MB) {
        return messages.rebalanceFileSizeMb(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.MB).longValue());
    } else if (size.longValue() > SizeConverter.BYTES_IN_KB) {
        return messages.rebalanceFileSizeKb(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.KB).longValue());
    } else {
        return messages.rebalanceFileSizeBytes(size.longValue());
    }
}
#method_after
@Override
public String render(T size) {
    if (size.longValue() > SizeConverter.BYTES_IN_GB) {
        return messages.rebalanceFileSizeGb(formatSize(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.GB).doubleValue()));
    } else if (size.longValue() > SizeConverter.BYTES_IN_MB) {
        return messages.rebalanceFileSizeMb(formatSize(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.MB).doubleValue()));
    } else if (size.longValue() > SizeConverter.BYTES_IN_KB) {
        return messages.rebalanceFileSizeKb(formatSize(SizeConverter.convert(size.longValue(), SizeUnit.BYTES, SizeUnit.KB).doubleValue()));
    } else {
        return messages.rebalanceFileSizeBytes(formatSize(size.doubleValue()));
    }
}
#end_block

#method_before
void initEditors(ApplicationConstants constants) {
    rebalanceHostsTable = new EntityModelCellTable<ListModel>(false, true);
    statusTimeEditor = getInstanceOfDateEditor();
    startedTimeEditor = getInstanceOfDateEditor();
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getHostName();
        }
    }, constants.rebalanceSessionHost());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getFilesMoved() + "";
        }
    }, constants.rebalanceFileCount());
    rebalanceHostsTable.addEntityModelColumn(new RebalanceFileSizeColumn<EntityModel>(messages) {

        @Override
        protected Long getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getTotalSizeMoved();
        }
    }, constants.rebalanceSize());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesFailed());
        }
    }, constants.rebalanceFailedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesSkipped());
        }
    }, constants.rebalanceSkippedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesScanned());
        }
    }, constants.rebalanceScannedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new UptimeColumn<EntityModel>() {

        @Override
        protected Double getRawValue(EntityModel object) {
            // TODO Auto-generated method stub
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getRunTime();
        }
    }, constants.rebalanceRunTime());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getStatus().toString();
        }
    }, constants.rebalanceStatus());
}
#method_after
void initEditors(ApplicationConstants constants) {
    rebalanceHostsTable = new EntityModelCellTable<ListModel>(false, true);
    statusTimeEditor = getInstanceOfDateEditor();
    startedTimeEditor = getInstanceOfDateEditor();
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getHostName();
        }
    }, constants.rebalanceSessionHost());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getFilesMoved() + "";
        }
    }, constants.rebalanceFileCount());
    rebalanceHostsTable.addEntityModelColumn(new RebalanceFileSizeColumn<EntityModel>(messages) {

        @Override
        protected Long getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getTotalSizeMoved();
        }
    }, constants.rebalanceSize());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesFailed());
        }
    }, constants.rebalanceFailedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesSkipped());
        }
    }, constants.rebalanceSkippedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesScanned());
        }
    }, constants.rebalanceScannedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new HumanReadableTimeColumn<EntityModel>() {

        @Override
        protected Double getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getRunTime();
        }
    }, constants.rebalanceRunTime());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getStatus().toString();
        }
    }, constants.rebalanceStatus());
}
#end_block

#method_before
private EntityModelLabelEditor getInstanceOfDateEditor() {
    return new EntityModelLabelEditor(new EntityModelRenderer() {

        @Override
        public String render(Object entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return FullDateTimeRenderer.getLocalizedDateTimeFormat().format((Date) entity);
        }
    }, new EntityModelParser());
}
#method_after
private EntityModelLabelEditor getInstanceOfDateEditor() {
    return new EntityModelLabelEditor(new EntityModelRenderer() {

        @Override
        public String render(Object entity) {
            if (entity == null) {
                return constants.unAvailablePropertyLabel();
            }
            return GlusterRebalanceDateTimeRenderer.getLocalizedDateTimeFormat().format((Date) entity);
        }
    }, new EntityModelParser());
}
#end_block

#method_before
public void refreshDetails(GlusterVolumeEntity volumeEntity) {
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            showStatus(rebalanceStatusEntity);
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#method_after
public void refreshDetails(GlusterVolumeEntity volumeEntity) {
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if (rebalanceStatusEntity != null) {
                showStatus(rebalanceStatusEntity);
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid vdsId = null;
            Guid storagePoolId = null;
            String vdsName = null;
            ArrayList<VDSDomainsData> domainsList = null;
            synchronized (getLockObj()) {
                _vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (_vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (_refreshIteration == _numberRefreshesBeforeSave) {
                        _refreshIteration = 1;
                    } else {
                        _refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds, monitoringStrategy);
                        _vdsUpdater.Refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && _vds.getStatus() != VDSStatus.NonResponsive && _vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", _vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (_vdsUpdater != null) {
                        _vdsUpdater.AfterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (_vds != null && _vds.getStatus() != VDSStatus.Maintenance) {
                            vdsId = _vds.getId();
                            vdsName = _vds.getName();
                            storagePoolId = _vds.getStoragePoolId();
                            domainsList = _vds.getDomains();
                        }
                    }
                    _vds = null;
                    _vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.UpdateVdsDomainsData(_vds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer() {
    if (LockManagerFactory.getLockManager().acquireLock(monitoringLock).getFirst()) {
        try {
            setIsSetNonOperationalExecuted(false);
            Guid storagePoolId = null;
            ArrayList<VDSDomainsData> domainsList = null;
            VDS tmpVds;
            synchronized (getLockObj()) {
                tmpVds = _vds = DbFacade.getInstance().getVdsDao().get(getVdsId());
                if (_vds == null) {
                    log.errorFormat("VdsManager::refreshVdsRunTimeInfo - OnTimer is NULL for {0}", getVdsId());
                    return;
                }
                try {
                    if (_refreshIteration == _numberRefreshesBeforeSave) {
                        _refreshIteration = 1;
                    } else {
                        _refreshIteration++;
                    }
                    if (isMonitoringNeeded()) {
                        setStartTime();
                        _vdsUpdater = new VdsUpdateRunTimeInfo(VdsManager.this, _vds, monitoringStrategy);
                        _vdsUpdater.Refresh();
                        mUnrespondedAttempts.set(0);
                        sshSoftFencingExecuted.set(false);
                        setLastUpdate();
                    }
                    if (!getInitialized() && _vds.getStatus() != VDSStatus.NonResponsive && _vds.getStatus() != VDSStatus.PendingApproval) {
                        log.infoFormat("Initializing Host: {0}", _vds.getName());
                        ResourceManager.getInstance().HandleVdsFinishedInit(_vds.getId());
                        setInitialized(true);
                    }
                } catch (VDSNetworkException e) {
                    logNetworkException(e);
                } catch (VDSRecoveringException ex) {
                    HandleVdsRecoveringException(ex);
                } catch (RuntimeException ex) {
                    logFailureMessage(ex);
                }
                try {
                    if (_vdsUpdater != null) {
                        _vdsUpdater.AfterRefreshTreatment();
                        // the storage anymore (so there is no sense in updating the domains list in that case).
                        if (_vds != null && _vds.getStatus() != VDSStatus.Maintenance) {
                            storagePoolId = _vds.getStoragePoolId();
                            domainsList = _vds.getDomains();
                        }
                    }
                    _vds = null;
                    _vdsUpdater = null;
                } catch (IRSErrorException ex) {
                    logAfterRefreshFailureMessage(ex);
                    if (log.isDebugEnabled()) {
                        logException(ex);
                    }
                } catch (RuntimeException ex) {
                    logAfterRefreshFailureMessage(ex);
                    logException(ex);
                }
            }
            // synchronized part of code
            if (domainsList != null) {
                IrsBrokerCommand.UpdateVdsDomainsData(tmpVds, storagePoolId, domainsList);
            }
        } catch (Exception e) {
            log.error("Timer update runtimeinfo failed. Exception:", e);
        } finally {
            LockManagerFactory.getLockManager().releaseLock(monitoringLock);
        }
    }
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStop(String volumeName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeRebalanceStatus(volumeName);
        GlusterVolumeTaskReturnForXmlRpc wrapper = new GlusterVolumeTaskReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStop(String volumeName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeRebalanceStop(volumeName);
        GlusterVolumeTaskReturnForXmlRpc wrapper = new GlusterVolumeTaskReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    String volumeName = getParameters().getVolumeName();
    result = getBroker().glusterVolumeRebalanceStatus(volumeName);
    proceedProxyReturnValue();
    // Set the current engine time as status time
    GlusterVolumeTaskStatusEntity entity = result.getStatusDetails();
    entity.setStatusTime(new Date());
    setReturnValue(entity);
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    String volumeName = getParameters().getVolumeName();
    result = getBroker().glusterVolumeRebalanceStop(volumeName);
    proceedProxyReturnValue();
    // Set the current engine time as status time
    GlusterVolumeTaskStatusEntity entity = result.getStatusDetails();
    entity.setStatusTime(new Date());
    setReturnValue(entity);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    if (!vdsReturnaValue.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        setSucceeded(false);
        return;
    }
    GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) vdsReturnaValue.getReturnValue();
    JobExecutionStatus stepStatus = rebalanceStatusEntity.getStatusSummary().getStatus();
    if (JobExecutionStatus.FINISHED.equals(stepStatus)) {
        endStepJob(stepStatus, getStepMessageMap(stepStatus), true);
    } else {
        endStepJob(stepStatus, getStepMessageMap(stepStatus), false);
    }
    releaseVolumeLock();
    setSucceeded(vdsReturnaValue.getSucceeded());
    getReturnValue().setActionReturnValue(rebalanceStatusEntity);
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    if (!vdsReturnaValue.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        setSucceeded(false);
        return;
    }
    GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) vdsReturnaValue.getReturnValue();
    JobExecutionStatus stepStatus = rebalanceStatusEntity.getStatusSummary().getStatus();
    if (stepStatus != null && JobExecutionStatus.FINISHED.equals(stepStatus)) {
        endStepJob(stepStatus, getStepMessageMap(stepStatus), true);
    } else {
        endStepJob(JobExecutionStatus.ABORTED, getStepMessageMap(JobExecutionStatus.ABORTED), false);
    }
    releaseVolumeLock();
    setSucceeded(vdsReturnaValue.getSucceeded());
    getReturnValue().setActionReturnValue(rebalanceStatusEntity);
}
#end_block

#method_before
private void loadVmDiskAttachedToInfo() {
    if (getOldDisk() != null) {
        vmsDiskSnapshotPluggedTo = new LinkedList<>();
        vmsDiskPluggedTo = new LinkedList<>();
        vmsDiskOrSnapshotPluggedTo = new LinkedList<>();
        vmsDiskOrSnapshotAttachedTo = new LinkedList<>();
        List<Pair<VM, VmDevice>> attachedVmsInfo = getVmDAO().getVmsWithPlugInfo(getOldDisk().getId());
        for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
            VM vm = pair.getFirst();
            vmsDiskOrSnapshotAttachedTo.add(vm);
            if (Boolean.TRUE.equals(pair.getSecond().getIsPlugged())) {
                if (pair.getSecond().getSnapshotId() != null) {
                    vmsDiskSnapshotPluggedTo.add(vm);
                } else {
                    vmsDiskPluggedTo.add(vm);
                }
                vmsDiskOrSnapshotPluggedTo.add(vm);
            }
            if (vm.getId().equals(getParameters().getVmId())) {
                vmDeviceForVm = pair.getSecond();
            }
        }
    }
}
#method_after
private void loadVmDiskAttachedToInfo() {
    if (getOldDisk() != null) {
        List<Pair<VM, VmDevice>> attachedVmsInfo = getVmDAO().getVmsWithPlugInfo(getOldDisk().getId());
        for (Pair<VM, VmDevice> pair : attachedVmsInfo) {
            VM vm = pair.getFirst();
            vmsDiskOrSnapshotAttachedTo.add(vm);
            if (Boolean.TRUE.equals(pair.getSecond().getIsPlugged())) {
                if (pair.getSecond().getSnapshotId() != null) {
                    vmsDiskSnapshotPluggedTo.add(vm);
                } else {
                    vmsDiskPluggedTo.add(vm);
                }
                vmsDiskOrSnapshotPluggedTo.add(vm);
            }
            if (vm.getId().equals(getParameters().getVmId())) {
                vmDeviceForVm = pair.getSecond();
            }
        }
    }
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VolumeGeneralModel());
    list.add(new VolumeParameterListModel());
    list.add(new VolumeBrickListModel());
    list.add(new PermissionListModel());
    list.add(new VolumeEventListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    setBrickListModel(new VolumeBrickListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(new VolumeGeneralModel());
    list.add(new VolumeParameterListModel());
    list.add(getBrickListModel());
    list.add(new PermissionListModel());
    list.add(new VolumeEventListModel());
    setDetailModels(list);
}
#end_block

#method_before
private void removeVolume() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVolumesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_volume");
    model.setMessage(ConstantsManager.getInstance().getConstants().removeVolumesMessage());
    model.setNote(ConstantsManager.getInstance().getConstants().removeVolumesWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void removeVolume() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeVolumesTitle());
    // $NON-NLS-1$
    model.setHashName("remove_volume");
    model.setNote(ConstantsManager.getInstance().getConstants().removeVolumesWarning());
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<String> list = new ArrayList<String>();
    for (GlusterVolumeEntity item : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
        list.add(item.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
}
#method_after
@Override
protected void onSelectedItemChanged() {
    super.onSelectedItemChanged();
    updateActionAvailability();
    getBrickListModel().setEntity(provideDetailModelEntity(getSelectedItem()));
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    }
}
#end_block

#method_before
private void stopRebalance() {
    if (getWindow() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(volume.getName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#method_after
private void stopRebalance() {
    if (getSelectedItems() == null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setConfirmWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceTitle());
    // $NON-NLS-1$
    model.setHashName("volume_rebalance_stop");
    model.setMessage(ConstantsManager.getInstance().getConstants().confirmStopVolumeRebalanceMsg());
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("onStopRebalance", this);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    model.getCommands().add(okCommand);
    // $NON-NLS-1$
    UICommand cancelCommand = new UICommand("Cancel", this);
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    model.getCommands().add(cancelCommand);
}
#end_block

#method_before
private void onStopRebalance() {
    if (getWindow() == null) {
        return;
    }
    ConfirmationModel model = (ConfirmationModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        GlusterVolumeEntity volume = (GlusterVolumeEntity) item;
        list.add(new GlusterVolumeRebalanceParameters(volume.getId(), false, false));
    }
    model.startProgress(null);
    Frontend.RunMultipleAction(VdcActionType.StopRebalanceGlusterVolume, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) result.getState();
            localModel.stopProgress();
            cancel();
        }
    }, model);
}
#method_after
private void onStopRebalance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    model.startProgress(null);
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    GlusterVolumeRebalanceParameters param = new GlusterVolumeRebalanceParameters(volumeEntity.getId(), false, false);
    Frontend.RunAction(VdcActionType.StopRebalanceGlusterVolume, param, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow();
            localModel.stopProgress();
            setConfirmWindow(null);
            if (result.getReturnValue().getSucceeded()) {
                showRebalanceStatus();
            }
        }
    });
}
#end_block

#method_before
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            boolean status = ((VdcQueryReturnValue) returnValue).getSucceeded();
            cModel.stopProgress();
            if (status) {
                GlusterVolumeTaskStatusEntity rebalanceStatusEntity = ((VdcQueryReturnValue) returnValue).getReturnValue();
                if ((rebalanceStatusEntity == null) || (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.UNKNOWN)) {
                    cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusConfirmationMessage(volumeEntity.getName()));
                    cModel.getCommands().add(rebalanceStatusOk);
                } else {
                    setConfirmWindow(null);
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#method_after
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    cModel.getCommands().add(rebalanceStatusOk);
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            cModel.stopProgress();
            VdcQueryReturnValue vdcValue = (VdcQueryReturnValue) returnValue;
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = vdcValue.getReturnValue();
            if ((rebalanceStatusEntity == null) || !(vdcValue.getSucceeded())) {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusFailed(volumeEntity.getName()));
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    // $NON-NLS-1$
                    UICommand stopRebalanceFromStatus = new UICommand("stop_rebalance_from_status", VolumeListModel.this);
                    stopRebalanceFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRebalance());
                    rebalanceStatusModel.getCommands().add(stopRebalanceFromStatus);
                    rebalanceStatusModel.setStopReblanceFromStatus(stopRebalanceFromStatus);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                } else {
                    VolumeRebalanceStatusModel statusModel = (VolumeRebalanceStatusModel) getWindow();
                    statusModel.getCommands().get(0).setIsExecutionAllowed(false);
                    statusModel.showStatus(rebalanceStatusEntity);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#method_after
public static void getGlusterRebalanceStatus(AsyncQuery aQuery, Guid clusterId, Guid volumeId) {
    aQuery.setHandleFailure(true);
    GlusterVolumeQueriesParameters parameters = new GlusterVolumeQueriesParameters(clusterId, volumeId);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeRebalanceStatus, parameters, aQuery);
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList(Version clusterVersion) {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO }));
    boolean isVirtIOScsiEnabled = clusterVersion != null ? (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, clusterVersion.getValue()) : true;
    if (isVirtIOScsiEnabled) {
        diskInterfaces.add(DiskInterface.VirtIO_SCSI);
    }
    return diskInterfaces;
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
public static String getNewNicName(ArrayList<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#method_after
@Override
protected void initDetailModels() {
    super.initDetailModels();
    HostGeneralModel generalModel = new HostGeneralModel();
    generalModel.getRequestEditEvent().addListener(this);
    generalModel.getRequestGOToEventsTabEvent().addListener(this);
    setGlusterSwiftModel(new HostGlusterSwiftListModel());
    setHostBricksListModel(new HostBricksListModel());
    ObservableCollection<EntityModel> list = new ObservableCollection<EntityModel>();
    list.add(generalModel);
    list.add(new HostHardwareGeneralModel());
    list.add(new HostVmListModel());
    list.add(new HostInterfaceListModel());
    setHostEventListModel(new HostEventListModel());
    list.add(getHostEventListModel());
    list.add(new HostHooksListModel());
    list.add(getGlusterSwiftModel());
    list.add(getHostBricksListModel());
    list.add(new PermissionListModel());
    setDetailModels(list);
}
#end_block

#method_before
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
}
#method_after
@Override
protected void updateDetailsAvailability() {
    super.updateDetailsAvailability();
    VDS vds = (VDS) getSelectedItem();
    getGlusterSwiftModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService() && GlusterFeaturesUtil.isGlusterSwiftSupported(vds.getVdsGroupCompatibilityVersion()));
    getHostBricksListModel().setIsAvailable(vds != null && vds.getVdsGroupSupportsGlusterService());
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    boolean hasSystemDiskWarning = false;
    RemoveDiskModel model = new RemoveDiskModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeDisksTitle());
    // $NON-NLS-1$
    model.setHashName("remove_disk");
    model.getLatch().setEntity(false);
    ArrayList<DiskModel> items = new ArrayList<DiskModel>();
    for (Object item : getSelectedItems()) {
        Disk disk = (Disk) item;
        DiskModel diskModel = new DiskModel();
        diskModel.setDisk(disk);
        diskModel.setVm(getEntity());
        items.add(diskModel);
        // A shared disk or a disk snapshot can only be detached
        if (disk.getNumberOfVms() > 1) {
            model.getLatch().setIsChangable(false);
        }
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged())) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isMoveCommandAvailable() {
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || (!isVmDown() && disk.getPlugged()) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk)) {
            return false;
        }
    }
    return true;
}
#method_after
private boolean isLiveMoveCommandAvailable() {
    if (!getIsLiveStorageMigrationEnabled()) {
        return false;
    }
    VM vm = getEntity();
    if (vm == null || !vm.getStatus().isUpOrPaused() || vm.isStateless()) {
        return false;
    }
    ArrayList<Disk> disks = getSelectedItems() != null ? Linq.<Disk>cast(getSelectedItems()) : new ArrayList<Disk>();
    for (Disk disk : disks) {
        if (!isImageDiskOK(disk) || disk.isDiskSnapshot()) {
            return false;
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void setMessage(String message) {
    if (message == null) {
        setMessageToDefault();
    } else {
        super.setMessage(message);
    }
}
#method_after
@Override
public void setMessage(String message) {
    super.setMessage(message == null ? constants.removeConfirmationPopupMessage() : message);
}
#end_block

#method_before
@Override
protected void restore() {
    super.restore();
    if (getWindow() != null) {
        return;
    }
    ImportVmModel model = getImportModel();
    setWindow(model);
    model.startProgress(null);
    UICommand restoreCommand;
    // $NON-NLS-1$
    restoreCommand = new UICommand("OnRestore", this);
    restoreCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    restoreCommand.setIsDefault(true);
    model.getCommands().add(restoreCommand);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("Cancel", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    model.getCommands().add(tempVar3);
    model.setItems(getSelectedItems());
    model.init(getEntity().getId());
    // Add 'Close' command
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsDefault(true);
    closeCommand.setIsCancel(true);
    model.setCloseCommand(closeCommand);
}
#method_after
@Override
protected void restore() {
    super.restore();
    if (getWindow() != null) {
        return;
    }
    ImportVmModel model = getImportModel();
    setWindow(model);
    model.startProgress(null);
    UICommand restoreCommand;
    // $NON-NLS-1$
    restoreCommand = new UICommand("OnRestore", this);
    restoreCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    restoreCommand.setIsDefault(true);
    model.getCommands().add(restoreCommand);
    // $NON-NLS-1$
    UICommand tempVar3 = new UICommand("Cancel", this);
    tempVar3.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar3.setIsCancel(true);
    model.getCommands().add(tempVar3);
    model.init(getSelectedItems(), getEntity().getId());
    // Add 'Close' command
    // $NON-NLS-1$
    UICommand closeCommand = new UICommand("Cancel", this);
    closeCommand.setTitle(ConstantsManager.getInstance().getConstants().close());
    closeCommand.setIsDefault(true);
    closeCommand.setIsCancel(true);
    model.setCloseCommand(closeCommand);
}
#end_block

#method_before
protected void endStepJob(JobExecutionStatus status, Map<String, String> stepMessageMap) {
    GlusterAsyncTask asyncTask = getGlusterVolume().getAsyncTask();
    // Gluster Task will be associated with only one step ( REBALANCING_VOLUME or REMOVING_BRICK)
    Step step = getStepDao().getStepsByExternalId(asyncTask.getTaskId()).get(0);
    step.markStepEnded(status);
    step.setDescription(ExecutionMessageDirector.resolveStepMessage(getStepType(), stepMessageMap));
    JobRepositoryFactory.getJobRepository().updateStep(step);
    ExecutionContext finalContext = ExecutionHandler.createFinalizingContext(step.getId());
    ExecutionHandler.endTaskJob(finalContext, false);
}
#method_after
protected void endStepJob(JobExecutionStatus status, Map<String, String> stepMessageMap, boolean exitStatus) {
    GlusterAsyncTask asyncTask = getGlusterVolume().getAsyncTask();
    // Gluster Task will be associated with only one step ( REBALANCING_VOLUME or REMOVING_BRICK)
    Step step = getStepDao().getStepsByExternalId(asyncTask.getTaskId()).get(0);
    step.markStepEnded(status);
    step.setDescription(ExecutionMessageDirector.resolveStepMessage(getStepType(), stepMessageMap));
    JobRepositoryFactory.getJobRepository().updateStep(step);
    ExecutionContext finalContext = ExecutionHandler.createFinalizingContext(step.getId());
    ExecutionHandler.endTaskJob(finalContext, exitStatus);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CommitRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), volume.getName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    endStepJob(JobExecutionStatus.FINISHED, getStepMessageMap(JobExecutionStatus.FINISHED));
    releaseVolumeLock();
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#method_after
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.CommitRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), volume.getName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    endStepJobCommitted();
    releaseVolumeLock();
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#end_block

#method_before
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case RemoveGlusterServerFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case RemoveGlusterServerFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBricksStartFailed:
        case GlusterVolumeRemoveBricksStopFailed:
        case GlusterVolumeRemoveBrickStatusFailed:
        case GlusterVolumeRemoveBricksCommitFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps == null || steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            step.setStatus(task.getStatus());
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#method_after
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            step.setStatus(task.getStatus());
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#end_block

#method_before
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
}
#method_after
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        case REMOVING_BRICKS:
            actionType = VdcActionType.StartRemoveGlusterVolumeBricks;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
    updateVolumeBricksAndLock(cluster, task);
}
#end_block

#method_before
private static boolean hasTaskCompleted(GlusterAsyncTask task) {
    if (JobExecutionStatus.ABORTED == task.getStatus() || JobExecutionStatus.FINISHED == task.getStatus() || JobExecutionStatus.FAILED == task.getStatus()) {
        return true;
    }
    return false;
}
#method_after
private static boolean hasTaskCompleted(GlusterAsyncTask task) {
    // Remove brick task is marked completed only if committed or aborted.
    if (JobExecutionStatus.ABORTED == task.getStatus() || (JobExecutionStatus.FINISHED == task.getStatus() && task.getType() != GlusterTaskType.REMOVE_BRICK) || JobExecutionStatus.FAILED == task.getStatus()) {
        return true;
    }
    return false;
}
#end_block

#method_before
private static Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    values.put(GlusterConstants.JOB_STATUS, task.getStatus().toString());
    values.put(GlusterConstants.JOB_INFO, task.getMessage());
    return values;
}
#method_after
private static Map<String, String> getMessageMap(VDSGroup cluster, GlusterAsyncTask task) {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    String jobStatus = getJobStatusInfo(task);
    values.put(GlusterConstants.JOB_STATUS, jobStatus);
    values.put(GlusterConstants.JOB_INFO, task.getMessage());
    return values;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void mockBackend(boolean succeeded, VdcBllErrors errorCode) {
    when(cmd.getBackend()).thenReturn(backend);
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    doReturn(new HashMap<String, String>()).when(cmd).getStepMessageMap(any(JobExecutionStatus.class));
    doNothing().when(cmd).endStepJob(any(JobExecutionStatus.class), any(Map.class));
    doNothing().when(cmd).releaseVolumeLock();
    VDSReturnValue vdsReturnValue = new VDSReturnValue();
    vdsReturnValue.setSucceeded(succeeded);
    if (!succeeded) {
        vdsReturnValue.setVdsError(new VDSError(errorCode, ""));
    }
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.CommitRemoveGlusterVolumeBricks), argThat(anyGlusterVolumeVDS()))).thenReturn(vdsReturnValue);
}
#method_after
@SuppressWarnings("unchecked")
private void mockBackend(boolean succeeded, VdcBllErrors errorCode) {
    when(cmd.getBackend()).thenReturn(backend);
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    doNothing().when(cmd).endStepJobCommitted();
    doNothing().when(cmd).releaseVolumeLock();
    VDSReturnValue vdsReturnValue = new VDSReturnValue();
    vdsReturnValue.setSucceeded(succeeded);
    if (!succeeded) {
        vdsReturnValue.setVdsError(new VDSError(errorCode, ""));
    }
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.CommitRemoveGlusterVolumeBricks), argThat(anyGlusterVolumeVDS()))).thenReturn(vdsReturnValue);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Test
public void testExecuteCommand() {
    cmd = spy(new CommitRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTask, getBricks(volumeWithRemoveBricksTask, 2))));
    prepareMocks(cmd);
    mockBackend(true, null);
    assertTrue(cmd.canDoAction());
    cmd.executeCommand();
    verify(cmd, times(1)).endStepJob(any(JobExecutionStatus.class), any(Map.class));
    verify(cmd, times(1)).releaseVolumeLock();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT);
}
#method_after
@SuppressWarnings("unchecked")
@Test
public void testExecuteCommand() {
    cmd = spy(new CommitRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTask, getBricks(volumeWithRemoveBricksTask, 2))));
    prepareMocks(cmd);
    mockBackend(true, null);
    assertTrue(cmd.canDoAction());
    cmd.executeCommand();
    verify(cmd, times(1)).endStepJobCommitted();
    verify(cmd, times(1)).releaseVolumeLock();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT);
}
#end_block

#method_before
@Test
public void executeCommandWhenFailed() {
    cmd = spy(new CommitRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTask, getBricks(volumeWithRemoveBricksTask, 2))));
    prepareMocks(cmd);
    mockBackend(false, VdcBllErrors.GlusterVolumeRemoveBricksCommitFailed);
    assertTrue(cmd.canDoAction());
    cmd.executeCommand();
    verify(cmd, never()).endStepJob();
    verify(cmd, never()).releaseVolumeLock();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED);
}
#method_after
@Test
public void executeCommandWhenFailed() {
    cmd = spy(new CommitRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTask, getBricks(volumeWithRemoveBricksTask, 2))));
    prepareMocks(cmd);
    mockBackend(false, VdcBllErrors.GlusterVolumeRemoveBricksCommitFailed);
    assertTrue(cmd.canDoAction());
    cmd.executeCommand();
    verify(cmd, never()).endStepJobAborted();
    verify(cmd, never()).releaseVolumeLock();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_COMMIT_FAILED);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static ArrayList<DiskInterface> getDiskInterfaceList(Version clusterVersion) {
    ArrayList<DiskInterface> diskInterfaces = new ArrayList<DiskInterface>(Arrays.asList(new DiskInterface[] { DiskInterface.IDE, DiskInterface.VirtIO }));
    boolean isVirtIOScsiEnabled = clusterVersion != null ? (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.VirtIoScsiEnabled, clusterVersion.getValue()) : true;
    if (isVirtIOScsiEnabled) {
        diskInterfaces.add(DiskInterface.VirtIO_SCSI);
    }
    return diskInterfaces;
}
#method_after
public static void getDiskInterfaceList(int osId, Version clusterVersion, AsyncQuery asyncQuery) {
    final INewAsyncCallback chainedCallback = asyncQuery.asyncCallback;
    asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            ArrayList<String> interfaces = (ArrayList<String>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            List<DiskInterface> interfaceTypes = new ArrayList<DiskInterface>();
            for (String diskIfs : interfaces) {
                try {
                    interfaceTypes.add(DiskInterface.valueOf(diskIfs));
                } catch (IllegalArgumentException e) {
                // ignore if we can't find the enum value.
                }
            }
            chainedCallback.onSuccess(model, interfaceTypes);
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetDiskInterfaces, osId, clusterVersion), asyncQuery);
}
#end_block

#method_before
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    if (// $NON-NLS-1$
    e.PropertyName.equals("status")) {
        getSearchCommand().execute();
    }
}
#method_after
@Override
protected void entityPropertyChanged(Object sender, PropertyChangedEventArgs e) {
    super.entityPropertyChanged(sender, e);
    getSearchCommand().execute();
}
#end_block

#method_before
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        VdcUser vdcUser = Frontend.getLoggedInUser();
        if (vdcUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.RunQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(vdcUser.getUserId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<permissions> permissions = (ArrayList<permissions>) response.getReturnValue();
                    for (permissions permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#method_after
public void updateConfigureLocalStorageCommandAvailability() {
    if (hasAdminSystemPermission == null) {
        DbUser dbUser = Frontend.getLoggedInUser();
        if (dbUser == null) {
            hasAdminSystemPermission = false;
            updateConfigureLocalStorageCommandAvailability1();
            return;
        }
        Frontend.RunQuery(VdcQueryType.GetPermissionsByAdElementId, new IdQueryParameters(dbUser.getId()), new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                VdcQueryReturnValue response = (VdcQueryReturnValue) returnValue;
                if (response == null || !response.getSucceeded()) {
                    hasAdminSystemPermission = false;
                    updateConfigureLocalStorageCommandAvailability1();
                } else {
                    ArrayList<permissions> permissions = (ArrayList<permissions>) response.getReturnValue();
                    for (permissions permission : permissions) {
                        if (permission.getObjectType() == VdcObjectType.System && permission.getRoleType() == RoleType.ADMIN) {
                            hasAdminSystemPermission = true;
                            break;
                        }
                    }
                    updateConfigureLocalStorageCommandAvailability1();
                }
            }
        }, true));
    } else {
        updateConfigureLocalStorageCommandAvailability1();
    }
}
#end_block

#method_before
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getQueryStartedEvent().addListener(this);
    Frontend.getQueryCompleteEvent().addListener(this);
    Frontend.subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#method_after
@Override
public void initialize() {
    super.initialize();
    setHash(getHashName() + new Date());
    // Add progress listeners
    Frontend.getQueryStartedEvent().addListener(this);
    Frontend.getQueryCompleteEvent().addListener(this);
    Frontend.subscribeAdditionalQueries(new VdcQueryType[] { VdcQueryType.Search, VdcQueryType.GetStoragePoolById, VdcQueryType.GetNextAvailableDiskAliasNameByVMId, VdcQueryType.GetPermittedStorageDomainsByStoragePoolId, VdcQueryType.GetAllVdsByStoragePool, VdcQueryType.GetAllAttachableDisks, VdcQueryType.GetAllDisksByVmId, VdcQueryType.GetAllRelevantQuotasForStorage, VdcQueryType.OsRepository });
    // Create and set commands
    // $NON-NLS-1$
    UICommand onSaveCommand = new UICommand("OnSave", this);
    onSaveCommand.setTitle(CONSTANTS.ok());
    onSaveCommand.setIsDefault(true);
    getCommands().add(onSaveCommand);
    getCommands().add(getCancelCommand());
    // Update data
    if (getVm() != null) {
        updateBootableDiskAvailable();
    }
    updateDatacenters();
}
#end_block

#method_before
private void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (a.getStorageDomainType() != StorageDomainType.ISO && a.getStorageDomainType() != StorageDomainType.ImportExport && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            if (storage != null) {
                updateWipeAfterDelete(storage.getStorageType());
                // $NON-NLS-1$
                diskModel.setMessage("");
            } else {
                diskModel.setMessage(CONSTANTS.noActiveStorageDomainsInDC());
            }
            updateQuota(datacenter);
        }
    }, getHash()), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#method_after
private void updateStorageDomains(final StoragePool datacenter) {
    AsyncDataProvider.getPermittedStorageDomainsByStoragePoolId(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            DiskModel diskModel = (DiskModel) target;
            ArrayList<StorageDomain> storageDomains = (ArrayList<StorageDomain>) returnValue;
            ArrayList<StorageDomain> filteredStorageDomains = new ArrayList<StorageDomain>();
            for (StorageDomain a : storageDomains) {
                if (a.getStorageDomainType() != StorageDomainType.ISO && a.getStorageDomainType() != StorageDomainType.ImportExport && a.getStatus() == StorageDomainStatus.Active) {
                    filteredStorageDomains.add(a);
                }
            }
            Collections.sort(filteredStorageDomains, new NameableComparator());
            StorageDomain storage = Linq.firstOrDefault(filteredStorageDomains);
            diskModel.getStorageDomain().setItems(filteredStorageDomains);
            diskModel.getStorageDomain().setSelectedItem(storage);
            if (storage != null) {
                updateWipeAfterDelete(storage.getStorageType());
                // $NON-NLS-1$
                diskModel.setMessage("");
            } else {
                diskModel.setMessage(CONSTANTS.noActiveStorageDomainsInDC());
            }
        }
    }, getHash()), datacenter.getId(), ActionGroup.CREATE_DISK);
}
#end_block

#method_before
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            for (Disk disk : disks) {
                if (disk.isBoot() && !disk.equals(getDisk())) {
                    diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                    diskModel.getIsBootable().setEntity(false);
                    diskModel.getIsBootable().setIsChangable(false);
                    break;
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#method_after
private void updateBootableDiskAvailable() {
    AsyncDataProvider.getVmDiskList(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            AbstractDiskModel diskModel = (AbstractDiskModel) target;
            ArrayList<Disk> disks = (ArrayList<Disk>) returnValue;
            diskModel.getIsBootable().setEntity(true);
            if (getDisk() == null || !getDisk().isDiskSnapshot()) {
                for (Disk disk : disks) {
                    if (disk.isBoot() && !disk.equals(getDisk())) {
                        diskModel.getIsBootable().setEntity(false);
                        if (!disk.isDiskSnapshot()) {
                            diskModel.getIsBootable().setChangeProhibitionReason(CONSTANTS.onlyOneBootableDisk());
                            diskModel.getIsBootable().setIsChangable(false);
                            break;
                        }
                    }
                }
            }
            if (!getIsNew()) {
                getIsBootable().setEntity(getDisk().isBoot());
            }
        }
    }, getHash()), getVm().getId());
}
#end_block

#method_before
public void updateInterface(int osId, Version clusterVersion, AsyncQuery chainedAsyncQuery) {
    final INewAsyncCallback chainedCallback = chainedAsyncQuery.asyncCallback;
    if (clusterVersion == null) {
        ArrayList<DiskInterface> diskInterfaces = AsyncDataProvider.getDiskInterfaceList();
        getDiskInterface().setItems(diskInterfaces);
        chainedCallback.onSuccess(this, null);
    } else {
        AsyncQuery asyncQuery = new AsyncQuery();
        asyncQuery.asyncCallback = new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue) {
                getDiskInterface().setItems((List<DiskInterface>) returnValue);
                chainedCallback.onSuccess(model, returnValue);
            }
        };
        AsyncDataProvider.getDiskInterfaceList(osId, clusterVersion, asyncQuery);
    }
}
#method_after
public void updateInterface(final Version clusterVersion) {
    if (getVm() != null) {
        AsyncDataProvider.isVirtioScsiEnabledForVm(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object model, Object returnValue1) {
                final boolean isVirtioScsiDisabled = Boolean.FALSE.equals(returnValue1);
                AsyncQuery asyncQuery = new AsyncQuery(this, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue2) {
                        ArrayList<DiskInterface> diskInterfaces = (ArrayList<DiskInterface>) returnValue2;
                        if (isVirtioScsiDisabled) {
                            diskInterfaces.remove(DiskInterface.VirtIO_SCSI);
                        }
                        setInterfaces(diskInterfaces);
                    }
                });
                AsyncDataProvider.getDiskInterfaceList(getVm().getOs(), clusterVersion, asyncQuery);
            }
        }), getVm().getId());
    } else {
        setInterfaces(AsyncDataProvider.getDiskInterfaceList());
    }
}
#end_block

#method_before
private void datacenter_SelectedItemChanged() {
    StoragePool datacenter = (StoragePool) getDataCenter().getSelectedItem();
    boolean isInternal = getIsInternal().getEntity() != null ? (Boolean) getIsInternal().getEntity() : false;
    boolean isInVm = getVm() != null;
    if (datacenter == null) {
        return;
    }
    updateVolumeType(datacenter.getStorageType());
    updateShareableDiskEnabled(datacenter);
    updateDirectLunDiskEnabled(datacenter);
    if (isInVm) {
        updateInterface(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion());
    } else {
        updateInterface(0, null);
    }
    if (isInternal) {
        updateStorageDomains(datacenter);
    } else {
        updateHosts(datacenter);
    }
}
#method_after
private void datacenter_SelectedItemChanged() {
    StoragePool datacenter = (StoragePool) getDataCenter().getSelectedItem();
    boolean isInternal = getIsInternal().getEntity() != null ? (Boolean) getIsInternal().getEntity() : false;
    boolean isInVm = getVm() != null;
    if (datacenter == null) {
        return;
    }
    updateVolumeType(datacenter.getStorageType());
    updateShareableDiskEnabled(datacenter);
    updateDirectLunDiskEnabled(datacenter);
    updateInterface(isInVm ? getVm().getVdsGroupCompatibilityVersion() : null);
    if (isInternal) {
        updateStorageDomains(datacenter);
    } else {
        updateHosts(datacenter);
    }
}
#end_block

#method_before
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.EntityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#method_after
@Override
public void eventRaised(Event ev, Object sender, EventArgs args) {
    super.eventRaised(ev, sender, args);
    if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsWipeAfterDelete()) {
        wipeAfterDelete_EntityChanged(args);
    } else if (ev.matchesDefinition(EntityModel.EntityChangedEventDefinition) && sender == getIsAttachDisk()) {
        attachDisk_EntityChanged(args);
    } else if (ev.matchesDefinition(ListModel.EntityChangedEventDefinition) && sender == getIsInternal()) {
        isInternal_EntityChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getVolumeType()) {
        volumeType_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDiskInterface()) {
        DiskInterface_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getDataCenter()) {
        datacenter_SelectedItemChanged();
    } else if (ev.matchesDefinition(ListModel.selectedItemChangedEventDefinition) && sender == getStorageDomain()) {
        storageDomain_SelectedItemChanged();
    } else if (ev.matchesDefinition(Frontend.QueryStartedEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryStarted();
    } else if (ev.matchesDefinition(Frontend.QueryCompleteEventDefinition) && StringHelper.stringsEqual(Frontend.getCurrentContext(), getHash())) {
        frontend_QueryComplete();
    }
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
public static void getPmOptions(AsyncQuery aQuery, String pmType) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new VdcQueryParametersBase(), aQuery);
}
#method_after
public static void getPmOptions(AsyncQuery aQuery, String pmType, String version) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            String pmtype = (String) _asyncQuery.Data[0];
            HashMap<String, ArrayList<String>> cachedPmMap = new HashMap<String, ArrayList<String>>();
            HashMap<String, HashMap<String, Object>> dict = (HashMap<String, HashMap<String, Object>>) source;
            for (Map.Entry<String, HashMap<String, Object>> pair : dict.entrySet()) {
                ArrayList<String> list = new ArrayList<String>();
                for (Map.Entry<String, Object> p : pair.getValue().entrySet()) {
                    list.add(p.getKey());
                }
                cachedPmMap.put(pair.getKey(), list);
            }
            return cachedPmMap.get(pmtype);
        }
    };
    aQuery.setData(new Object[] { pmType });
    Frontend.RunQuery(VdcQueryType.GetAgentFenceOptions, new GetAgentFenceOptionsQueryParameters(version), aQuery);
}
#end_block

#method_before
public static String getNewNicName(ArrayList<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
public static void hasSpiceSupport(int osId, Version version, AsyncQuery callback) {
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.HasSpiceSupport, osId, version), callback);
}
#method_after
public static Boolean hasSpiceSupport(int osId, Version version) {
    return spiceSupportMatrix.get(osId).get(version);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#method_after
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#end_block

#method_before
public ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#method_after
@JsonIgnore
public ArrayList<DiskImage> getDiskList() {
    return diskList;
}
#end_block

#method_before
@Before
public void initializeCommand() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    command = spy(createCommand());
    mockVds();
    when(command.getActionType()).thenReturn(getCommandActionType());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    StorageDomainValidator storageDomainValidator = mock(StorageDomainValidator.class);
    doReturn(storageDomainValidator).when(command).getStorageDomainValidator(any(StorageDomain.class));
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainExistAndActive();
}
#method_after
@Before
public void initializeCommand() {
    SimpleDependecyInjector.getInstance().bind(OsRepository.class, osRepository);
    command = spy(createCommand());
    mockVds();
    mockVmDevice(false);
    when(command.getActionType()).thenReturn(getCommandActionType());
    SnapshotsValidator snapshotsValidator = mock(SnapshotsValidator.class);
    doReturn(snapshotsValidator).when(command).getSnapshotsValidator();
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotDuringSnapshot(any(Guid.class));
    doReturn(ValidationResult.VALID).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    StorageDomainValidator storageDomainValidator = mock(StorageDomainValidator.class);
    doReturn(storageDomainValidator).when(command).getStorageDomainValidator(any(StorageDomain.class));
    doReturn(ValidationResult.VALID).when(storageDomainValidator).isDomainExistAndActive();
}
#end_block

#method_before
private void mockVMDAO(VM vm) {
    when(vmDAO.get(command.getParameters().getVmId())).thenReturn(vm);
    List<VM> vmList = new ArrayList<VM>();
    VM vm1 = new VM();
    vm1.setId(command.getParameters().getVmId());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    vmList.add(vm1);
    vmList.add(vm2);
    when(vmDAO.getVmsListForDisk(any(Guid.class))).thenReturn(vmList);
}
#method_after
private void mockVMDAO(VM vm) {
    when(vmDAO.get(command.getParameters().getVmId())).thenReturn(vm);
    List<VM> vmList = new ArrayList<VM>();
    VM vm1 = new VM();
    vm1.setId(command.getParameters().getVmId());
    VM vm2 = new VM();
    vm2.setId(Guid.newGuid());
    vmList.add(vm1);
    vmList.add(vm2);
    when(vmDAO.getVmsListForDisk(any(Guid.class), anyBoolean())).thenReturn(vmList);
}
#end_block

#method_before
private DiskImage createNotVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setActive(true);
    disk.setDiskInterface(DiskInterface.IDE);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(DISK_HOTPLUGGABLE_INTERFACES);
    return disk;
}
#method_after
private DiskImage createNotVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setActive(true);
    disk.setDiskInterface(DiskInterface.IDE);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    return disk;
}
#end_block

#method_before
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(DISK_HOTPLUGGABLE_INTERFACES);
    mockVmDevice(false);
}
#method_after
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    mockVmDevice(false);
}
#end_block

#method_before
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new VdcBLLException(VdcBllErrors.StorageServerConnectionError);
                }
            }
        }
    }
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm().getId(), disk, vmDevice));
}
#method_after
protected void performPlugCommand(VDSCommandType commandType, Disk disk, VmDevice vmDevice) {
    if (disk.getDiskStorageType() == DiskStorageType.LUN) {
        LunDisk lunDisk = (LunDisk) disk;
        if (commandType == VDSCommandType.HotPlugDisk) {
            LUNs lun = lunDisk.getLun();
            updateLUNConnectionsInfo(lun);
            Map<StorageType, List<StorageServerConnections>> lunsByStorageType = StorageHelperBase.filterConnectionsByStorageType(lun);
            for (StorageType storageType : lunsByStorageType.keySet()) {
                if (!getStorageHelper(storageType).connectStorageToLunByVdsId(null, getVm().getRunOnVds(), lun, getVm().getStoragePoolId())) {
                    throw new VdcBLLException(VdcBllErrors.StorageServerConnectionError);
                }
            }
        }
    }
    runVdsCommand(commandType, new HotPlugDiskVDSParameters(getVm().getRunOnVds(), getVm(), disk, vmDevice));
}
#end_block

#method_before
protected boolean isDiskCanBeAddedToVm(Disk diskInfo, VM vm) {
    if (diskInfo.isBoot()) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.isBoot()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", vm.getName()));
                return false;
            }
        }
    }
    return true;
}
#method_after
protected boolean isDiskCanBeAddedToVm(Disk diskInfo, VM vm) {
    if (!diskInfo.isDiskSnapshot() && diskInfo.isBoot()) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.isBoot() && !disk.isDiskSnapshot()) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISK_BOOT_IN_USE);
                getReturnValue().getCanDoActionMessages().add(String.format("$DiskName %1$s", disk.getDiskAlias()));
                getReturnValue().getCanDoActionMessages().add(String.format("$VmName %1$s", vm.getName()));
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
protected boolean isInterfaceSupportedForPlugUnPlug(Disk disk) {
    boolean retVal = true;
    List<String> diskHotpluggableInterfaces = osRepository.getDiskHotpluggableInterfaces(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion());
    if (diskHotpluggableInterfaces == null || diskHotpluggableInterfaces.isEmpty()) {
        retVal = false;
    }
    if (retVal) {
        Collection<DiskInterface> diskInterfaces = new HashSet<DiskInterface>();
        for (String diskHotpluggableInterface : diskHotpluggableInterfaces) {
            diskInterfaces.add(DiskInterface.valueOf(diskHotpluggableInterface));
        }
        if (!diskInterfaces.contains(disk.getDiskInterface())) {
            retVal = false;
        }
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return retVal;
}
#method_after
protected boolean isInterfaceSupportedForPlugUnPlug(Disk disk) {
    Set<String> diskHotpluggableInterfaces = osRepository.getDiskHotpluggableInterfaces(getVm().getOs(), getVm().getVdsGroupCompatibilityVersion());
    if (CollectionUtils.isEmpty(diskHotpluggableInterfaces) || !diskHotpluggableInterfaces.contains(disk.getDiskInterface().toString())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GUEST_OS_VERSION_IS_NOT_SUPPORTED);
    }
    return true;
}
#end_block

#method_before
private boolean isDiskExistInVm(Disk disk) {
    List<VM> listVms = getVmDAO().getVmsListForDisk(disk.getId());
    for (VM vm : listVms) {
        if (vm.getId().equals(getVmId())) {
            return true;
        }
    }
    return false;
}
#method_after
private boolean isDiskExistInVm(Disk disk) {
    List<VM> listVms = getVmDAO().getVmsListForDisk(disk.getId(), true);
    for (VM vm : listVms) {
        if (vm.getId().equals(getVmId())) {
            return true;
        }
    }
    return false;
}
#end_block

#method_before
@Override
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(DISK_HOTPLUGGABLE_INTERFACES);
    mockVmDevice(true);
}
#method_after
@Override
protected void cretaeVirtIODisk() {
    DiskImage disk = getDiskImage();
    disk.setDiskInterface(DiskInterface.VirtIO);
    disk.setActive(true);
    doReturn(diskDao).when(command).getDiskDao();
    when(diskDao.get(diskImageGuid)).thenReturn(disk);
    when(osRepository.getDiskHotpluggableInterfaces(any(Integer.class), any(Version.class))).thenReturn(new HashSet<String>(DISK_HOTPLUGGABLE_INTERFACES));
    mockVmDevice(true);
}
#end_block

#method_before
protected static void updateAllDiskImageSnapshotsStatusWithCompensation(final Guid diskId, final ImageStatus status, ImageStatus statusForCompensation, final CompensationContext compensationContext) {
    if (compensationContext != null) {
        List<DiskImage> diskSnapshots = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(diskId);
        for (DiskImage diskSnapshot : diskSnapshots) {
            diskSnapshot.setImageStatus(statusForCompensation);
            compensationContext.snapshotEntityStatus(diskSnapshot.getImage());
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status);
                compensationContext.stateChanged();
                return null;
            }
        });
    } else {
        DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status);
    }
}
#method_after
protected static void updateAllDiskImageSnapshotsStatusWithCompensation(final Guid diskId, final ImageStatus status, ImageStatus statusForCompensation, final CompensationContext compensationContext) {
    if (compensationContext != null) {
        List<DiskImage> diskSnapshots = DbFacade.getInstance().getDiskImageDao().getAllSnapshotsForImageGroup(diskId);
        for (DiskImage diskSnapshot : diskSnapshots) {
            diskSnapshot.setImageStatus(statusForCompensation);
            compensationContext.snapshotEntityStatus(diskSnapshot.getImage());
        }
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                DbFacade.getInstance().getImageDao().updateStatusOfImagesByImageGroupId(diskId, status);
                compensationContext.stateChanged();
                return null;
            }
        });
    } else {
        updateAllDiskImageSnapshotsStatus(diskId, status);
    }
}
#end_block

#method_before
protected Guid findImageForSameDrive(SnapshotType snapshotType) {
    return findImageForSameDrive(getSnapshotDao().getId(getVmDAO().getVmsListForDisk(getImage().getId()).get(0).getId(), snapshotType));
}
#method_after
protected Guid findImageForSameDrive(SnapshotType snapshotType) {
    return findImageForSameDrive(getSnapshotDao().getId(getVmDAO().getVmsListForDisk(getImage().getId(), false).get(0).getId(), snapshotType));
}
#end_block

#method_before
private VM getVmForNonShareableDiskImage(DiskImage disk) {
    if (!disk.isShareable()) {
        List<VM> vms = getVmDAO().getVmsListForDisk(disk.getId());
        if (!vms.isEmpty()) {
            return vms.get(0);
        }
    }
    return null;
}
#method_after
private VM getVmForNonShareableDiskImage(DiskImage disk) {
    if (!disk.isShareable()) {
        List<VM> vms = getVmDAO().getVmsListForDisk(disk.getId(), false);
        if (!vms.isEmpty()) {
            return vms.get(0);
        }
    }
    return null;
}
#end_block

#method_before
private void removeImageMapping() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getImageStorageDomainMapDao().remove(new ImageStorageDomainMapId(getParameters().getImageId(), getParameters().getStorageDomainId()));
            ImagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.OK, null, null);
            return null;
        }
    });
}
#method_after
private void removeImageMapping() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getImageStorageDomainMapDao().remove(new ImageStorageDomainMapId(getParameters().getImageId(), getParameters().getStorageDomainId()));
            ImagesHandler.updateAllDiskImageSnapshotsStatus(getRelevantDiskImage().getId(), getRelevantDiskImage().getImageStatus());
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void lockImage() {
    ImagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.LOCKED, ImageStatus.OK, getCompensationContext());
}
#method_after
@Override
protected void lockImage() {
    ImagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.LOCKED, getRelevantDiskImage().getImageStatus(), getCompensationContext());
}
#end_block

#method_before
@Override
protected void unLockImage() {
    ImagesHandler.updateAllDiskImageSnapshotsStatusWithCompensation(getRelevantDiskImage().getId(), ImageStatus.OK, null, null);
}
#method_after
@Override
protected void unLockImage() {
    ImagesHandler.updateAllDiskImageSnapshotsStatus(getRelevantDiskImage().getId(), ImageStatus.OK);
}
#end_block

#method_before
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    final int nextTabIndex = setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            Object selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
    if (object.getCommands() instanceof ObservableCollection) {
        ObservableCollection<UICommand> commands = (ObservableCollection<UICommand>) object.getCommands();
        commands.getCollectionChangedEvent().addListener(new IEventListener() {

            @Override
            public void eventRaised(Event ev, Object sender, EventArgs args) {
                setButtonsTabIndex(nextTabIndex);
            }
        });
    }
}
#method_after
@Override
public void edit(final HostModel object) {
    driver.edit(object);
    setTabIndexes(0);
    // TODO should be handled in a more generic way
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            String propName = ((PropertyChangedEventArgs) args).PropertyName;
            if ("IsGeneralTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsGeneralTabValid()) {
                    generalTab.markAsValid();
                } else {
                    generalTab.markAsInvalid(null);
                }
            } else if ("IsPowerManagementTabValid".equals(propName)) {
                // $NON-NLS-1$
                if (object.getIsPowerManagementTabValid()) {
                    powerManagementTab.markAsValid();
                } else {
                    powerManagementTab.markAsInvalid(null);
                }
            }
        }
    });
    object.getFetchResult().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            fetchResult.setText((String) object.getFetchResult().getEntity());
        }
    });
    object.getPkSection().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsAvailable") {
                // $NON-NLS-1$
                setPkPasswordSectionVisiblity(false);
            }
        }
    });
    rbPassword.setValue(true);
    displayPassPkWindow(true);
    fetchSshFingerprint.hideLabel();
    object.setAuthenticationMethod(AuthenticationMethod.Password);
    rbPassword.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.Password);
            displayPassPkWindow(true);
        }
    });
    rbPublicKey.addValueChangeHandler(new ValueChangeHandler<Boolean>() {

        @Override
        public void onValueChange(ValueChangeEvent<Boolean> event) {
            object.setAuthenticationMethod(AuthenticationMethod.PublicKey);
            displayPassPkWindow(false);
        }
    });
    testButton.setCommand(object.getTestCommand());
    // Bind proxy commands.
    upButton.setCommand(object.getProxyUpCommand());
    upButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyUpCommand().execute();
        }
    });
    downButton.setCommand(object.getProxyDownCommand());
    downButton.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            object.getProxyDownCommand().execute();
        }
    });
    updateHostsButton.setResource(resources.searchButtonImage());
    // Bind proxy list.
    object.getPmProxyPreferencesList().getItemsChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            proxyListBox.clear();
            for (Object item : object.getPmProxyPreferencesList().getItems()) {
                proxyListBox.addItem((String) item);
            }
        }
    });
    object.getPmProxyPreferencesList().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            int selectedItemIndex = items.indexOf(object.getPmProxyPreferencesList().getSelectedItem());
            proxyListBox.setSelectedIndex(selectedItemIndex);
        }
    });
    object.getPmProxyPreferencesList().getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName == "IsChangable") {
                // $NON-NLS-1$
                proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
            }
        }
    });
    proxyListBox.setEnabled(object.getPmProxyPreferencesList().getIsChangable());
    proxyListBox.addChangeHandler(new ChangeHandler() {

        @Override
        public void onChange(ChangeEvent event) {
            List items = (List) object.getPmProxyPreferencesList().getItems();
            Object selectedItem = proxyListBox.getSelectedIndex() >= 0 ? items.get(proxyListBox.getSelectedIndex()) : null;
            object.getPmProxyPreferencesList().setSelectedItem(selectedItem);
        }
    });
    // Create SPM related controls.
    IEventListener spmListener = new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            createSpmControls(object);
        }
    };
    object.getSpmPriority().getItemsChangedEvent().addListener(spmListener);
    object.getSpmPriority().getSelectedItemChangedEvent().addListener(spmListener);
    createSpmControls(object);
    // Wire events on power management related controls.
    object.getPmVariants().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            ListModel model = (ListModel) sender;
            List items = (List) model.getItems();
            Object selectedItem = model.getSelectedItem();
            updatePmPanelsVisibility(items.indexOf(selectedItem) == 0);
        }
    });
    updatePmPanelsVisibility(true);
    initExternalHostProviderWidgets(object.showExternalProviderPanel());
    // TODO: remove setIsChangable when configured ssh username is enabled
    userNameEditor.setEnabled(false);
    networkProviderTab.setVisible(object.showNetworkProviderTab());
    networkProviderWidget.edit(object.getNetworkProviderModel());
    addTextAndLinkAlert(fetchPanel, appConstants.fetchingHostFingerprint(), object.getSSHFingerPrint());
    nameEditor.setFocus(true);
}
#end_block

#method_before
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#method_after
@Override
public int setTabIndexes(int nextTabIndex) {
    // ==General Tab==
    dataCenterEditor.setTabIndex(nextTabIndex++);
    clusterEditor.setTabIndex(nextTabIndex++);
    externalHostProviderEnabledEditor.setTabIndex(nextTabIndex++);
    providersEditor.setTabIndex(nextTabIndex++);
    providerSearchFilterLabel.setTabIndex(nextTabIndex++);
    nameEditor.setTabIndex(nextTabIndex++);
    hostAddressEditor.setTabIndex(nextTabIndex++);
    authSshPortEditor.setTabIndex(nextTabIndex++);
    userNameEditor.setTabIndex(nextTabIndex++);
    rbPassword.setTabIndex(nextTabIndex++);
    passwordEditor.setTabIndex(nextTabIndex++);
    return nextTabIndex;
}
#end_block

#method_before
@Override
public HasUiCommandClickHandlers addFooterButton(String label, String uniqueId) {
    AbstractUiCommandButton button = createCommandButton(label, uniqueId);
    asWidget().addFooterButton(button);
    buttonsMap.put(label, (UiCommandButton) button);
    // Set button element ID for better accessibility
    button.asWidget().getElement().setId(ElementIdUtils.createElementId(elementId, uniqueId));
    return button;
}
#method_after
@Override
public HasUiCommandClickHandlers addFooterButton(String label, String uniqueId) {
    AbstractUiCommandButton button = createCommandButton(label, uniqueId);
    asWidget().addFooterButton(button);
    focusableButtons.add(0, button);
    // Set button element ID for better accessibility
    button.asWidget().getElement().setId(ElementIdUtils.createElementId(elementId, uniqueId));
    return button;
}
#end_block

#method_before
@Override
public void removeButtons() {
    asWidget().removeFooterButtons();
}
#method_after
@Override
public void removeButtons() {
    asWidget().removeFooterButtons();
    focusableButtons.clear();
}
#end_block

#method_before
@Override
public void stopProgress() {
    // Set dialog content to the actual popup content widget
    asWidget().setContent(popupContent);
    // Show dialog buttons when stopping progress
    asWidget().setFooterPanelVisible(true);
    // Now that the panel is visible we can try to focus
    focusInput();
}
#method_after
@Override
public void stopProgress() {
    // Set dialog content to the actual popup content widget
    asWidget().setContent(popupContent);
    // Show dialog buttons when stopping progress
    asWidget().setFooterPanelVisible(true);
    // Update tab index values
    updateTabIndexes();
    // Now that the panel is visible we can try to focus
    focusInput();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(vm, allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network))) {
            return false;
        }
        if (!validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
        return false;
    }
    if (!updateVnicForBackwardCompatibility()) {
        return false;
    }
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (!validate(vmStatusLegal(getVm().getStatus()))) {
        return false;
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getInterface().getId(), getVmId()));
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    oldIface = LinqUtils.firstOrNull(interfaces, new Predicate<VmNic>() {

        @Override
        public boolean eval(VmNic i) {
            return i.getId().equals(getInterface().getId());
        }
    });
    if (oldIface == null || oldVmDevice == null) {
        addCanDoActionMessage(VdcBllMessages.VM_INTERFACE_NOT_EXIST);
        return false;
    }
    if (!StringUtils.equals(oldIface.getName(), getInterfaceName()) && !uniqueInterfaceName(interfaces)) {
        return false;
    }
    // check that not exceeded PCI and IDE limit
    List<VmNic> allInterfaces = new ArrayList<>(interfaces);
    allInterfaces.remove(oldIface);
    allInterfaces.add(getInterface());
    VmStatic vm = getVmStaticDAO().get(getVmId());
    if (!pciAndIdeWithinLimit(vm, allInterfaces)) {
        return false;
    }
    if (!validate(vmTemplateEmpty())) {
        return false;
    }
    UpdateVmNicValidator nicValidator = new UpdateVmNicValidator(getInterface(), getVm().getVdsGroupCompatibilityVersion(), getVm().getOs());
    if (!validate(nicValidator.unplugPlugNotRequired()) || !validate(nicValidator.linkedCorrectly()) || !validate(nicValidator.isCompatibleWithOs()) || !validate(nicValidator.emptyNetworkValid()) || !validate(nicValidator.hotUpdatePossible()) || !validate(nicValidator.profileValid(vm.getVdsGroupId()))) {
        return false;
    }
    Network network = NetworkHelper.getNetworkByVnicProfileId(getInterface().getVnicProfileId());
    if (getRequiredAction() == RequiredAction.UPDATE_VM_DEVICE) {
        Network oldNetwork = NetworkHelper.getNetworkByVnicProfileId(oldIface.getVnicProfileId());
        if (!validate(nicValidator.hotUpdateDoneWithInternalNetwork(oldNetwork, network)) || !validate(nicValidator.networkExistsOnHost(network))) {
            return false;
        }
    }
    macShouldBeChanged = !StringUtils.equals(oldIface.getMacAddress(), getMacAddress());
    if (macShouldBeChanged && !validate(macAvailable())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    // Find the image corresponding to the status of the volume:
    GlusterStatus status = volume.getStatus();
    ImageResource statusImage = null;
    String tooltip;
    Boolean brickWarn = false;
    for (GlusterBrickEntity brick : volume.getBricks()) {
        if (brick.getStatus() == GlusterStatus.DOWN) {
            brickWarn = true;
        }
    }
    if (!brickWarn) {
        switch(status) {
            case DOWN:
                statusImage = resources.downImage();
                tooltip = constants.down();
                break;
            case UP:
                statusImage = resources.upImage();
                tooltip = constants.up();
                break;
            default:
                statusImage = resources.downImage();
                tooltip = constants.down();
        }
    } else {
        statusImage = resources.volumeBrickWarning();
        tooltip = constants.brickWarning();
    }
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    sb.append(applicationTemplates.statusTemplate(statusImageHtml, tooltip));
}
#method_after
@Override
public void render(Context context, GlusterVolumeEntity volume, SafeHtmlBuilder sb) {
    // Nothing to render if no volume is provided:
    if (volume == null) {
        return;
    }
    int brickCount = volume.getBricks().size();
    int count = 0;
    // Find the image corresponding to the status of the volume:
    GlusterStatus status = volume.getStatus();
    ImageResource statusImage = null;
    String tooltip;
    switch(status) {
        case DOWN:
            statusImage = resources.downImage();
            tooltip = constants.down();
            break;
        case UP:
            count = countDownBricks(volume);
            if (count == 0) {
                statusImage = resources.upImage();
                tooltip = constants.up();
            } else if (count < brickCount) {
                statusImage = resources.volumeBricksDownWarning();
                tooltip = constants.volumeBricksDown();
            } else {
                statusImage = resources.volumeAllBricksDownWarning();
                tooltip = constants.volumeAllBricksDown();
            }
            break;
        default:
            statusImage = resources.downImage();
            tooltip = constants.down();
    }
    // Generate the HTML for the image:
    SafeHtml statusImageHtml = SafeHtmlUtils.fromTrustedString(AbstractImagePrototype.create(statusImage).getHTML());
    sb.append(applicationTemplates.statusTemplate(statusImageHtml, tooltip));
}
#end_block

#method_before
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsAvailable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#method_after
public void setVmAttachedToPool(boolean value) {
    if (value) {
        // ==General Tab==
        getDataCenterWithClustersList().setIsChangable(!value);
        getQuota().setIsChangable(false);
        getDescription().setIsChangable(false);
        getComment().setIsChangable(false);
        getNumOfDesktops().setIsChangable(false);
        getPrestartedVms().setIsChangable(false);
        getMaxAssignedVmsPerUser().setIsChangable(false);
        getTemplate().setIsChangable(false);
        getMemSize().setIsChangable(false);
        getTotalCPUCores().setIsChangable(false);
        getCoresPerSocket().setIsChangable(false);
        getNumOfSockets().setIsChangable(false);
        getOSType().setIsChangable(false);
        getIsStateless().setIsChangable(false);
        getIsRunAndPause().setIsChangable(false);
        getIsDeleteProtected().setIsChangable(false);
        // ==Initial run Tab==
        getTimeZone().setIsChangable(false);
        getDomain().setIsChangable(false);
        // ==Console Tab==
        getDisplayProtocol().setIsChangable(false);
        getUsbPolicy().setIsChangable(false);
        getNumOfMonitors().setIsChangable(false);
        getIsSingleQxlEnabled().setIsChangable(false);
        getIsSmartcardEnabled().setIsChangable(false);
        getAllowConsoleReconnect().setIsChangable(false);
        getVncKeyboardLayout().setIsChangable(false);
        // ==Host Tab==
        getIsAutoAssign().setIsChangable(false);
        getDefaultHost().setIsChangable(false);
        getHostCpu().setIsChangable(false);
        getMigrationMode().setIsChangable(false);
        getCpuPinning().setIsChangable(false);
        // ==Resource Allocation Tab==
        getMinAllocatedMemory().setIsChangable(false);
        getProvisioning().setIsChangable(false);
        getProvisioningThin_IsSelected().setIsChangable(false);
        getProvisioningClone_IsSelected().setIsChangable(false);
        getDisksAllocationModel().setIsChangable(false);
        // ==Boot Options Tab==
        getFirstBootDevice().setIsChangable(false);
        getSecondBootDevice().setIsChangable(false);
        getCdAttached().setIsChangable(false);
        getCdImage().setIsChangable(false);
        getKernel_path().setIsChangable(false);
        getInitrd_path().setIsChangable(false);
        getKernel_parameters().setIsChangable(false);
        // ==Custom Properties Tab==
        getCustomProperties().setIsChangable(false);
        vmAttachedToPool = true;
    }
}
#end_block

#method_before
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getIsSingleQxlEnabled().setEntity(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initOSType();
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#method_after
public void initialize(SystemTreeItemModel SystemTreeSelectedItem) {
    super.initialize();
    setHash(getHashName() + new Date());
    getMemSize().setEntity(256);
    getMinAllocatedMemory().setEntity(256);
    getIsStateless().setEntity(false);
    getIsRunAndPause().setEntity(false);
    getIsSmartcardEnabled().setEntity(false);
    isConsoleDeviceEnabled.setEntity(false);
    getIsHighlyAvailable().setEntity(false);
    getIsAutoAssign().setEntity(true);
    getIsTemplatePublic().setEntity(true);
    getBehavior().enableSinglePCI(false);
    getHostCpu().setEntity(false);
    getMigrationMode().setIsChangable(true);
    getCdImage().setIsChangable(false);
    initOSType();
    initDisplayProtocol();
    initFirstBootDevice();
    initNumOfMonitors();
    initAllowConsoleReconnect();
    initMinimalVmMemSize();
    initMaximalVmMemSize32OS();
    initMigrationMode();
    initVncKeyboardLayout();
    behavior.initialize(SystemTreeSelectedItem);
}
#end_block

#method_before
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(true);
}
#method_after
protected void initAllowConsoleReconnect() {
    getAllowConsoleReconnect().setEntity(getVmType().getSelectedItem() == VmType.Server);
}
#end_block

#method_before
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
}
#method_after
private void dataCenterWithClusterSelectedItemChanged(Object sender, EventArgs args) {
    behavior.dataCenterWithClusterSelectedItemChanged();
    DataCenterWithCluster dataCenterWithCluster = (DataCenterWithCluster) getDataCenterWithClustersList().getSelectedItem();
    if (dataCenterWithCluster != null && dataCenterWithCluster.getDataCenter() != null) {
        getDisksAllocationModel().setQuotaEnforcementType(dataCenterWithCluster.getDataCenter().getQuotaEnforcementType());
    }
    updateMaximalVmMemSize();
    handleQxlClusterLevel();
}
#end_block

#method_before
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = (Integer) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    if (getSelectedCluster() != null) {
        getIsSingleQxlEnabled().setEntity(getIsLinuxOS() && Version.v3_3.compareTo(getSelectedCluster().getcompatibility_version()) <= 0);
    } else {
        getIsSingleQxlEnabled().setEntity(false);
    }
}
#method_after
private void oSType_SelectedItemChanged(Object sender, EventArgs args) {
    Integer osType = (Integer) getOSType().getSelectedItem();
    setIsWindowsOS(AsyncDataProvider.isWindowsOsType(osType));
    setIsLinuxOS(AsyncDataProvider.isLinuxOsType(osType));
    getInitrd_path().setIsChangable(getIsLinuxOS());
    getInitrd_path().setIsAvailable(getIsLinuxOS());
    getKernel_path().setIsChangable(getIsLinuxOS());
    getKernel_path().setIsAvailable(getIsLinuxOS());
    getKernel_parameters().setIsChangable(getIsLinuxOS());
    getKernel_parameters().setIsAvailable(getIsLinuxOS());
    getDomain().setIsChangable(getIsWindowsOS());
    getBehavior().updateDefaultTimeZone();
    handleQxlClusterLevel();
}
#end_block

#method_before
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    EntityModel entityModel = (EntityModel) getDisplayProtocol().getSelectedItem();
    if (entityModel == null) {
        return;
    }
    DisplayType type = (DisplayType) entityModel.getEntity();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    getBehavior().updateSingleQxl(type == DisplayType.qxl);
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#method_after
private void displayProtocol_SelectedItemChanged(Object sender, EventArgs args) {
    if (getDisplayType() == null) {
        return;
    }
    DisplayType type = getDisplayType();
    if (type == DisplayType.vnc) {
        getUsbPolicy().setSelectedItem(org.ovirt.engine.core.common.businessentities.UsbPolicy.DISABLED);
        getIsSmartcardEnabled().setEntity(false);
    }
    handleQxlClusterLevel();
    getUsbPolicy().setIsChangable(type == DisplayType.qxl);
    getIsSmartcardEnabled().setIsChangable(type == DisplayType.qxl);
    getVncKeyboardLayout().setIsAvailable(type == DisplayType.vnc);
    updateNumOfMonitors();
}
#end_block

#method_before
final protected boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The object to check is null for action {0}.", getActionType());
        }
        messages.add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("No action group is defined for action {0}.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getUserId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#method_after
final protected boolean checkSinglePermission(PermissionSubject permSubject, Collection<String> messages) {
    final Guid objectId = permSubject.getObjectId();
    final VdcObjectType objectType = permSubject.getObjectType();
    final ActionGroup objectActionGroup = permSubject.getActionGroup();
    // if objectId is null we can't check permission
    if (objectId == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("The object to check is null for action {0}.", getActionType());
        }
        messages.add(VdcBllMessages.USER_NOT_AUTHORIZED_TO_PERFORM_ACTION.name());
        return false;
    }
    // Check that an action group is defined for this action;
    if (objectActionGroup == null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("No action group is defined for action {0}.", getActionType());
        }
        return false;
    }
    // Check the authorization:
    if (!checkUserAuthorization(getCurrentUser().getId(), objectActionGroup, objectId, objectType)) {
        messages.add(permSubject.getMessage().name());
        return false;
    }
    return true;
}
#end_block

#method_before
private void onSave() {
    VmNetworkInterface nic = createBaseNic();
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    nic.setName((String) getName().getEntity());
    VnicProfileView profile = (VnicProfileView) getProfile().getSelectedItem();
    nic.setVnicProfileId(profile != null ? profile.getId() : null);
    nic.setLinked((Boolean) getLinked().getEntity());
    if (getNicType().getSelectedItem() == null) {
        nic.setType(null);
    } else {
        nic.setType(((VmInterfaceType) getNicType().getSelectedItem()).getValue());
    }
    onSaveMAC(nic);
    nic.setPlugged((Boolean) getPlugged().getEntity());
    startProgress(null);
    Frontend.RunAction(getVdcActionType(), createVdcActionParameters(nic), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
                postOnSave();
            }
        }
    }, this);
}
#method_after
private void onSave() {
    VmNetworkInterface nic = createBaseNic();
    if (getProgress() != null) {
        return;
    }
    if (!validate()) {
        return;
    }
    // Save changes.
    nic.setName((String) getName().getEntity());
    VnicProfileView profile = (VnicProfileView) getProfile().getSelectedItem();
    nic.setVnicProfileId(profile.getId());
    nic.setNetworkName(profile.getNetworkName());
    nic.setLinked((Boolean) getLinked().getEntity());
    if (getNicType().getSelectedItem() == null) {
        nic.setType(null);
    } else {
        nic.setType(((VmInterfaceType) getNicType().getSelectedItem()).getValue());
    }
    onSaveMAC(nic);
    nic.setPlugged((Boolean) getPlugged().getEntity());
    startProgress(null);
    Frontend.RunAction(getVdcActionType(), createVdcActionParameters(nic), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            stopProgress();
            if (returnValue != null && returnValue.getSucceeded()) {
                cancel();
                postOnSave();
            }
        }
    }, this);
}
#end_block

#method_before
private void postNicInit() {
    initSelectedType();
    getName().setEntity(getNic().getName());
    initMAC();
    initLinked();
    initProfiles();
    // Plug should be the last one updated, cause it controls the changeability of the other editor
    getPlugged().setEntity(getNic().isPlugged());
    if (!hotPlugSupported) {
        getPlugged().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().hotPlugNotSupported(getClusterCompatibilityVersion().toString()));
    }
    getPlugged().setIsChangable(hotPlugSupported || vmStatus.equals(VMStatus.Down));
    initCommands();
}
#method_after
private void postNicInit() {
    initSelectedType();
    getName().setEntity(getNic().getName());
    initMAC();
    initLinked();
    initProfiles();
    // Plug should be the last one updated, cause it controls the changeability of the other editor
    getPlugged().setEntity(getNic().isPlugged());
    if (!allowPlug()) {
        getPlugged().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().nicHotPlugNotSupported(getClusterCompatibilityVersion().toString()));
    }
    getPlugged().setIsChangable(allowPlug());
    initCommands();
}
#end_block

#method_before
private void postNicInit() {
    initSelectedType();
    getName().setEntity(AsyncDataProvider.getNewNicName(getVmNicList()));
    initMAC();
    if (!hotPlugSupported) {
        getPlugged().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().hotPlugNotSupported(getClusterCompatibilityVersion().toString()));
    }
    getPlugged().setIsChangable(hotPlugSupported || vmStatus.equals(VMStatus.Down));
    getPlugged().setEntity(hotPlugSupported || vmStatus.equals(VMStatus.Down));
    initLinked();
    initProfiles();
    initCommands();
}
#method_after
private void postNicInit() {
    initSelectedType();
    getName().setEntity(AsyncDataProvider.getNewNicName(getVmNicList()));
    initMAC();
    if (!allowPlug()) {
        getPlugged().setChangeProhibitionReason(ConstantsManager.getInstance().getMessages().nicHotPlugNotSupported(getClusterCompatibilityVersion().toString()));
    }
    getPlugged().setIsChangable(allowPlug());
    getPlugged().setEntity(allowPlug());
    initLinked();
    initProfiles();
    initCommands();
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    switch(getParameters().getOsRepositoryVerb()) {
        case GetOsNames:
            setReturnValue(osRepository.getOsNames());
            break;
        case GetUniqueOsNames:
            setReturnValue(osRepository.getUniqueOsNames());
            break;
        case GetOsIds:
            setReturnValue(osRepository.getOsIds());
            break;
        case GetLinuxOss:
            setReturnValue(osRepository.getLinuxOss());
            break;
        case GetWindowsOss:
            setReturnValue(osRepository.getWindowsOss());
            break;
        case GetNicHotplugSupportMap:
            setReturnValue(osRepository.getNicHotplugSupportMap());
            break;
        case GetMaxOsRam:
            setReturnValue(osRepository.getMaximumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetMinimumOsRam:
            setReturnValue(osRepository.getMinimumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case HasSpiceSupport:
            setReturnValue(osRepository.hasSpiceSupport(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case HasNicHotplugSupport:
            setReturnValue(osRepository.hasNicHotplugSupport(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetNetworkDevices:
            setReturnValue(osRepository.getNetworkDevices(getParameters().getOsId(), getParameters().getVersion()));
            break;
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    switch(getParameters().getOsRepositoryVerb()) {
        case GetOsNames:
            setReturnValue(osRepository.getOsNames());
            break;
        case GetUniqueOsNames:
            setReturnValue(osRepository.getUniqueOsNames());
            break;
        case GetOsIds:
            setReturnValue(osRepository.getOsIds());
            break;
        case GetLinuxOss:
            setReturnValue(osRepository.getLinuxOss());
            break;
        case GetWindowsOss:
            setReturnValue(osRepository.getWindowsOss());
            break;
        case GetNicHotplugSupportMap:
            setReturnValue(osRepository.getNicHotplugSupportMap());
            break;
        case GetMaxOsRam:
            setReturnValue(osRepository.getMaximumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetMinimumOsRam:
            setReturnValue(osRepository.getMinimumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetSpiceSupportMatrix:
            setReturnValue(osRepository.getSpiceSupportMatrix());
            break;
        case HasNicHotplugSupport:
            setReturnValue(osRepository.hasNicHotplugSupport(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetNetworkDevices:
            setReturnValue(osRepository.getNetworkDevices(getParameters().getOsId(), getParameters().getVersion()));
            break;
    }
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initNicHotplugSupportMap();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
    initNicHotplugSupportMap();
}
#end_block

#method_before
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = (HashMap<Pair<Integer, Version>, Boolean>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#method_after
public static void initNicHotplugSupportMap() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            nicHotplugSupportMap = (Map<Pair<Integer, Version>, Boolean>) ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetNicHotplugSupportMap), callback);
}
#end_block

#method_before
public static HashMap<Pair<Integer, Version>, Boolean> getNicHotplugSupportMap() {
    return nicHotplugSupportMap;
}
#method_after
public static Map<Pair<Integer, Version>, Boolean> getNicHotplugSupportMap() {
    return nicHotplugSupportMap;
}
#end_block

#method_before
public static String getNewNicName(ArrayList<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#method_after
public static String getNewNicName(List<VmNetworkInterface> existingInterfaces) {
    int maxIfaceNumber = 0;
    if (existingInterfaces != null) {
        for (VmNetworkInterface iface : existingInterfaces) {
            // name of Interface is "eth<n>" (<n>: integer).
            if (iface.getName().length() > 3) {
                final Integer ifaceNumber = IntegerCompat.tryParse(iface.getName().substring(3));
                if (ifaceNumber != null && ifaceNumber > maxIfaceNumber) {
                    maxIfaceNumber = ifaceNumber;
                }
            }
        }
    }
    // $NON-NLS-1$
    return "nic" + (maxIfaceNumber + 1);
}
#end_block

#method_before
public static void hasSpiceSupport(int osId, Version version, AsyncQuery callback) {
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.HasSpiceSupport, osId, version), callback);
}
#method_after
public static Boolean hasSpiceSupport(int osId, Version version) {
    return spiceSupportMatrix.get(osId).get(version);
}
#end_block

#method_before
public static <T extends Disk> boolean checkPciAndIdeLimit(int monitorsNumber, List<VmNic> interfaces, List<T> disks, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO;
        }
    }).size();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO_SCSI;
        }
    }).isEmpty() ? 0 : 1;
    if (pciInUse > MAX_PCI_SLOTS) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.IDE;
        }
    }).size()) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    }
    return result;
}
#method_after
public static <T extends Disk> boolean checkPciAndIdeLimit(int monitorsNumber, List<VmNic> interfaces, List<T> disks, boolean virtioScsiEnabled, ArrayList<String> messages) {
    boolean result = true;
    // this adds: monitors + 2 * (interfaces with type rtl_pv) + (all other
    // interfaces) + (all disks that are not IDE)
    int pciInUse = monitorsNumber;
    for (VmNic a : interfaces) {
        if (a.getType() != null && VmInterfaceType.forValue(a.getType()) == VmInterfaceType.rtl8139_pv) {
            pciInUse += 2;
        } else {
            pciInUse += 1;
        }
    }
    pciInUse += LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.VirtIO;
        }
    }).size();
    // VirtIO SCSI controller requires one PCI slot
    pciInUse += virtioScsiEnabled ? 1 : 0;
    if (pciInUse > MAX_PCI_SLOTS) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_PCI_SLOTS.name());
    } else if (MAX_IDE_SLOTS < LinqUtils.filter(disks, new Predicate<T>() {

        @Override
        public boolean eval(T a) {
            return a.getDiskInterface() == DiskInterface.IDE;
        }
    }).size()) {
        result = false;
        messages.add(VdcBllMessages.ACTION_TYPE_FAILED_EXCEEDED_MAX_IDE_SLOTS.name());
    }
    return result;
}
#end_block

#method_before
protected void removeVmNetwork() {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getVmId());
    if (interfaces != null) {
        for (VmNic iface : interfaces) {
            MacPoolManager.getInstance().freeMac(iface.getMacAddress());
        }
    }
}
#method_after
protected void removeVmNetwork() {
    if (getInterfaces() != null) {
        for (VmNic iface : getInterfaces()) {
            MacPoolManager.getInstance().freeMac(iface.getMacAddress());
        }
    }
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    clusterId = getParameters().getClusterId();
    Guid volumeId = getParameters().getVolumeId();
    if (volumeId != null) {
        volume = getGlusterVolumeDao().getById(volumeId);
        if (volume == null) {
            throw new RuntimeException(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_INVALID.toString());
        }
        if (clusterId == null) {
            clusterId = volume.getClusterId();
        }
        asyncTask = volume.getAsyncTask();
        getQueryReturnValue().setReturnValue(fetchTaskStatusDetails());
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    clusterId = getParameters().getClusterId();
    Guid volumeId = getParameters().getVolumeId();
    if (volumeId != null) {
        volume = getGlusterVolumeDao().getById(volumeId);
        if (volume == null) {
            throw new RuntimeException(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_INVALID.toString());
        }
        if (clusterId == null) {
            clusterId = volume.getClusterId();
        }
        getQueryReturnValue().setReturnValue(fetchTaskStatusDetails());
    }
}
#end_block

#method_before
private GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRebalanceStatus, new GlusterVolumeVDSParameters(getUpServerId(clusterId), volume.getName()));
    // Set the volume re-balance start time
    GlusterVolumeTaskStatusEntity entity = (GlusterVolumeTaskStatusEntity) returnValue.getReturnValue();
    List<Step> stepsList = getStepDao().getStepsByExternalId(asyncTask.getTaskId());
    if (stepsList != null && !stepsList.isEmpty()) {
        entity.setStartTime(stepsList.get(0).getStartTime());
    }
    return entity;
}
#method_after
private GlusterVolumeTaskStatusEntity fetchTaskStatusDetails() {
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.GetGlusterVolumeRebalanceStatus, new GlusterVolumeVDSParameters(getUpServerId(clusterId), volume.getName()));
    // Set the volume re-balance start time
    GlusterVolumeTaskStatusEntity entity = (GlusterVolumeTaskStatusEntity) returnValue.getReturnValue();
    GlusterAsyncTask asyncTask = volume.getAsyncTask();
    if (asyncTask != null) {
        Guid taskId = asyncTask.getTaskId();
        if (taskId != null) {
            List<Step> stepsList = getStepDao().getStepsByExternalId(taskId);
            if (stepsList != null && !stepsList.isEmpty()) {
                entity.setStartTime(stepsList.get(0).getStartTime());
            }
        }
    }
    // Set the host ip in status details
    updateHostIP(entity);
    return entity;
}
#end_block

#method_before
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // Locate the requested file:
    File originalFile = ServletUtils.makeFileFromSanePath(request.getPathInfo(), base);
    Locale locale = getLocaleFromRequest(request);
    File file = determineActualFile(request, locale);
    file = checkForIndex(request, response, file, request.getPathInfo());
    if (file == null) {
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else if (!response.isCommitted()) {
        // If the response is committed, we have already redirected.
        boolean languagePageShown = isLangPageShown(request);
        if (!file.equals(originalFile) && !file.getAbsolutePath().equals(replaceLocaleWithOtherLocale(originalFile.getAbsolutePath(), locale, locale))) {
            // We determined that we are going to redirect the user to the English version URI.
            String redirect = request.getServletPath() + replaceLocaleWithUSLocale(request.getPathInfo(), locale);
            if (!languagePageShown) {
                setLangPageShown(response, true);
                request.setAttribute(LocaleFilter.LOCALE, locale);
                request.setAttribute(ENGLISH_HREF, redirect);
                RequestDispatcher dispatcher = request.getRequestDispatcher(LANG_JSP);
                if (dispatcher != null) {
                    dispatcher.include(request, response);
                }
            } else {
                // Redirect to English version of the document
                response.sendRedirect(redirect);
            }
        } else {
            // Send the content of the file:
            // type is the default MIME type of the Servlet(passed in through WebInit parameter).
            ServletUtils.sendFile(request, response, file, type);
        }
    }
}
#method_after
@Override
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    // Locate the requested file:
    File originalFile = ServletUtils.makeFileFromSanePath(request.getPathInfo(), base);
    Locale locale = getLocaleFromRequest(request);
    File file = determineActualFile(request, locale);
    file = checkForIndex(request, response, file, request.getPathInfo());
    if (file == null) {
        response.sendError(HttpServletResponse.SC_NOT_FOUND);
    } else if (!response.isCommitted()) {
        // If the response is committed, we have already redirected.
        boolean languagePageShown = isLangPageShown(request);
        if (!file.equals(originalFile) && !file.getAbsolutePath().equals(replaceLocaleWithOtherLocale(originalFile.getAbsolutePath(), locale, locale))) {
            // We determined that we are going to redirect the user to the English version URI.
            String redirect = request.getServletPath() + replaceLocaleWithUSLocale(request.getPathInfo(), locale);
            if (!languagePageShown) {
                setLangPageShown(response, true);
                request.setAttribute(LocaleFilter.LOCALE, locale);
                request.setAttribute(ENGLISH_HREF, redirect);
                final ServletContext forwardContext = getServletContext().getContext(localeDocsMissing);
                if (forwardContext != null) {
                    final RequestDispatcher dispatcher = forwardContext.getRequestDispatcher(localeDocsMissing);
                    if (dispatcher != null) {
                        dispatcher.forward(request, response);
                    } else {
                        log.error("Unable to determine dispatcher");
                        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "unable to determine dispatcher");
                    }
                } else {
                    log.error("Unable to determine forwarding context");
                    response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "unable to determine forward context");
                }
            } else {
                // Redirect to English version of the document
                response.sendRedirect(redirect);
            }
        } else {
            // Send the content of the file:
            // type is the default MIME type of the Servlet(passed in through WebInit parameter).
            ServletUtils.sendFile(request, response, file, type);
        }
    }
}
#end_block

#method_before
@Override
public GlusterBrickEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(getGuidDefaultEmpty(rs, "id"));
    brick.setVolumeId(getGuidDefaultEmpty(rs, "volume_id"));
    Guid serverId = getGuidDefaultEmpty(rs, "server_id");
    brick.setServerId(serverId);
    // Update the brick with server name. This is useful as the brick is typically represented in the form
    // serverName:brickDirectory though the database table (gluster_volume_bricks) stores just the server id
    brick.setServerName(getHostNameOfServer(serverId));
    brick.setBrickDirectory(rs.getString("brick_dir"));
    brick.setBrickOrder(rs.getInt("brick_order"));
    brick.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    brick.getAsyncTask().setTaskId(getGuidDefaultEmpty(rs, "task_id"));
    return brick;
}
#method_after
@Override
public GlusterBrickEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(getGuidDefaultEmpty(rs, "id"));
    brick.setVolumeId(getGuidDefaultEmpty(rs, "volume_id"));
    Guid serverId = getGuidDefaultEmpty(rs, "server_id");
    brick.setServerId(serverId);
    // Update the brick with server name. This is useful as the brick is typically represented in the form
    // serverName:brickDirectory though the database table (gluster_volume_bricks) stores just the server id
    brick.setServerName(getHostNameOfServer(serverId));
    brick.setBrickDirectory(rs.getString("brick_dir"));
    brick.setBrickOrder(rs.getInt("brick_order"));
    brick.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    brick.getAsyncTask().setTaskId(getGuid(rs, "task_id"));
    return brick;
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<GlusterBrickEntity> getBatchMapper() {
    return new MapSqlParameterMapper<GlusterBrickEntity>() {

        @Override
        public MapSqlParameterSource map(GlusterBrickEntity entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("volume_id", entity.getVolumeId()).addValue("server_id", entity.getServerId()).addValue("brick_dir", entity.getBrickDirectory()).addValue("status", entity.getStatus().name()).addValue("id", entity.getId().toString()).addValue("brick_order", entity.getBrickOrder()).addValue("task_id", entity.getAsyncTask() != null ? entity.getAsyncTask().getTaskId().toString() : "");
            return paramValue;
        }
    };
}
#method_after
@Override
public MapSqlParameterMapper<GlusterBrickEntity> getBatchMapper() {
    return new MapSqlParameterMapper<GlusterBrickEntity>() {

        @Override
        public MapSqlParameterSource map(GlusterBrickEntity entity) {
            MapSqlParameterSource paramValue = new MapSqlParameterSource().addValue("volume_id", entity.getVolumeId()).addValue("server_id", entity.getServerId()).addValue("brick_dir", entity.getBrickDirectory()).addValue("status", entity.getStatus().name()).addValue("id", entity.getId().toString()).addValue("brick_order", entity.getBrickOrder()).addValue("task_id", entity.getAsyncTask().getTaskId() != null ? entity.getAsyncTask().getTaskId().toString() : "");
            return paramValue;
        }
    };
}
#end_block

#method_before
@Test
public void testUpdateAllBrickTasksByHostIdBrickDir() {
    GlusterBrickEntity existingBrick = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    GlusterBrickEntity existingBrick2 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID2);
    GlusterAsyncTask asyncTask = new GlusterAsyncTask();
    asyncTask.setTaskId(FixturesTool.GLUSTER_ASYNC_TASK_ID1);
    // assertNull(existingBrick.getAsyncTask());
    GlusterBrickEntity updateBrick = new GlusterBrickEntity();
    updateBrick.setBrickDirectory(existingBrick.getBrickDirectory());
    updateBrick.setServerId(existingBrick.getServerId());
    updateBrick.setAsyncTask(asyncTask);
    GlusterBrickEntity updateBrick2 = new GlusterBrickEntity();
    updateBrick2.setBrickDirectory(existingBrick2.getBrickDirectory());
    updateBrick2.setServerId(existingBrick2.getServerId());
    updateBrick2.setAsyncTask(asyncTask);
    List<GlusterBrickEntity> bricks = new ArrayList<>();
    bricks.add(updateBrick);
    bricks.add(updateBrick2);
    dao.updateAllBrickTasksByHostIdBrickDir(bricks);
    GlusterBrickEntity newEntity1 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    GlusterBrickEntity newEntity2 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    assertEquals(FixturesTool.GLUSTER_ASYNC_TASK_ID1, newEntity1.getAsyncTask().getTaskId());
    assertEquals(FixturesTool.GLUSTER_ASYNC_TASK_ID1, newEntity2.getAsyncTask().getTaskId());
}
#method_after
@Test
public void testUpdateAllBrickTasksByHostIdBrickDir() {
    GlusterBrickEntity existingBrick = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    GlusterBrickEntity existingBrick2 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID2);
    GlusterAsyncTask asyncTask = new GlusterAsyncTask();
    asyncTask.setTaskId(FixturesTool.GLUSTER_ASYNC_TASK_ID1);
    GlusterBrickEntity updateBrick = new GlusterBrickEntity();
    updateBrick.setBrickDirectory(existingBrick.getBrickDirectory());
    updateBrick.setServerId(existingBrick.getServerId());
    updateBrick.setAsyncTask(asyncTask);
    GlusterBrickEntity updateBrick2 = new GlusterBrickEntity();
    updateBrick2.setBrickDirectory(existingBrick2.getBrickDirectory());
    updateBrick2.setServerId(existingBrick2.getServerId());
    updateBrick2.setAsyncTask(asyncTask);
    List<GlusterBrickEntity> bricks = new ArrayList<>();
    bricks.add(updateBrick);
    bricks.add(updateBrick2);
    dao.updateAllBrickTasksByHostIdBrickDirInBatch(bricks);
    GlusterBrickEntity newEntity1 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    GlusterBrickEntity newEntity2 = dao.getById(FixturesTool.GLUSTER_BRICK_UUID1);
    assertEquals(FixturesTool.GLUSTER_ASYNC_TASK_ID1, newEntity1.getAsyncTask().getTaskId());
    assertEquals(FixturesTool.GLUSTER_ASYNC_TASK_ID1, newEntity2.getAsyncTask().getTaskId());
}
#end_block

#method_before
protected void validateContainerFormat(Image glanceImage) {
    if (!glanceImage.getContainerFormat().equals(GlanceImageContainer.BARE.getValue())) {
        throw new RuntimeException("Unsupported container format");
    }
}
#method_after
protected void validateContainerFormat(Image glanceImage) {
    if (!glanceImage.getContainerFormat().equals(GlanceImageContainer.BARE.getValue())) {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_CONTAINER_FORMAT, "Unsupported container format: " + glanceImage.getContainerFormat());
    }
}
#end_block

#method_before
public List<RepoImage> getAllImagesAsRepoImages() {
    ArrayList<RepoImage> repoImages = new ArrayList<>();
    long currentTime = System.currentTimeMillis();
    Integer listSize = Config.<Integer>GetValue(ConfigValues.GlanceImageListSize);
    Integer totalListSize = Config.<Integer>GetValue(ConfigValues.GlanceImageTotalListSize);
    Images images = null;
    do {
        OpenStackRequest<Images> listRequest = getClient().images().list(true).queryParam("limit", Integer.valueOf(listSize)).queryParam("sort_key", "name").queryParam("sort_dir", "asc");
        if (images != null) {
            listRequest.queryParam("marker", images.getList().get(images.getList().size() - 1).getId());
        }
        images = listRequest.execute();
        for (Image glanceImage : images) {
            RepoImage repoImage = imageToRepoImage(glanceImage);
            repoImage.setLastRefreshed(currentTime);
            repoImages.add(repoImage);
        }
    } while ((images.getList().size() >= listSize) && repoImages.size() < totalListSize);
    return repoImages;
}
#method_after
public List<RepoImage> getAllImagesAsRepoImages(Integer listSize, Integer totalListSize) {
    ArrayList<RepoImage> repoImages = new ArrayList<>();
    long currentTime = System.currentTimeMillis();
    Images images = null;
    do {
        OpenStackRequest<Images> listRequest = getClient().images().list(true).queryParam("limit", listSize).queryParam("sort_key", "name").queryParam("sort_dir", "asc");
        if (images != null) {
            listRequest.queryParam("marker", images.getList().get(images.getList().size() - 1).getId());
        }
        images = listRequest.execute();
        for (Image glanceImage : images) {
            RepoImage repoImage = imageToRepoImage(glanceImage);
            repoImage.setLastRefreshed(currentTime);
            repoImages.add(repoImage);
        }
    } while ((images.getList().size() >= listSize) && (totalListSize != null && repoImages.size() < totalListSize));
    return repoImages;
}
#end_block

#method_before
public DiskImage getImageAsDiskImage(String id) {
    DiskImage diskImage = new DiskImage();
    Image glanceImage = getClient().images().show(id).execute();
    validateContainerFormat(glanceImage);
    String shortHash = glanceImage.getId().substring(0, 7);
    diskImage.setDiskAlias("GlanceDisk-" + shortHash);
    if (glanceImage.getName() != null) {
        diskImage.setDiskDescription(glanceImage.getName() + " (" + shortHash + ")");
    } else {
        diskImage.setDiskDescription("Glance disk: " + shortHash);
    }
    diskImage.setSize(getImageVirtualSize(glanceImage));
    diskImage.setActualSizeInBytes(glanceImage.getSize());
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.RAW);
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.COW);
    } else {
        throw new RuntimeException("Unknown disk format: " + glanceImage.getDiskFormat());
    }
    return diskImage;
}
#method_after
public DiskImage getImageAsDiskImage(String id) {
    DiskImage diskImage = new DiskImage();
    Image glanceImage = getClient().images().show(id).execute();
    validateContainerFormat(glanceImage);
    String shortHash = glanceImage.getId().substring(0, 7);
    diskImage.setDiskAlias("GlanceDisk-" + shortHash);
    if (glanceImage.getName() != null) {
        diskImage.setDiskDescription(glanceImage.getName() + " (" + shortHash + ")");
    } else {
        diskImage.setDiskDescription("Glance disk: " + shortHash);
    }
    diskImage.setSize(getImageVirtualSize(glanceImage));
    diskImage.setActualSizeInBytes(glanceImage.getSize());
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.RAW);
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        diskImage.setvolumeFormat(VolumeFormat.COW);
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + glanceImage.getDiskFormat());
    }
    return diskImage;
}
#end_block

#method_before
public String createImageFromDiskImage(DiskImage diskImage) {
    Image glanceImage = new Image();
    glanceImage.setName(diskImage.getDiskAlias());
    if (diskImage.getVolumeFormat() == VolumeFormat.RAW) {
        glanceImage.setDiskFormat(GlanceImageFormat.RAW.getValue());
    } else if (diskImage.getVolumeFormat() == VolumeFormat.COW) {
        glanceImage.setDiskFormat(GlanceImageFormat.COW.getValue());
    } else {
        throw new RuntimeException("Unknown disk format: " + diskImage.getVolumeFormat());
    }
    glanceImage.setContainerFormat(GlanceImageContainer.BARE.getValue());
    Image retGlanceImage = getClient().images().create(glanceImage).execute();
    return retGlanceImage.getId();
}
#method_after
public String createImageFromDiskImage(DiskImage diskImage) {
    Image glanceImage = new Image();
    glanceImage.setName(diskImage.getDiskAlias());
    if (diskImage.getVolumeFormat() == VolumeFormat.RAW) {
        glanceImage.setDiskFormat(GlanceImageFormat.RAW.getValue());
    } else if (diskImage.getVolumeFormat() == VolumeFormat.COW) {
        glanceImage.setDiskFormat(GlanceImageFormat.COW.getValue());
    } else {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + diskImage.getVolumeFormat());
    }
    glanceImage.setContainerFormat(GlanceImageContainer.BARE.getValue());
    Image retGlanceImage = getClient().images().create(glanceImage).execute();
    return retGlanceImage.getId();
}
#end_block

#method_before
private long getCowVirtualSize(String id) throws IOException {
    // For the qcow2 format we need to download the image header and read the virtual size from there
    byte[] imgContent = new byte[72];
    ImageDownload downloadImage = getClient().images().download(id).execute();
    try {
        int bytesRead = downloadImage.getInputStream().read(imgContent, 0, imgContent.length);
        if (bytesRead != imgContent.length) {
            throw new RuntimeException("Unable to read image header: " + bytesRead);
        }
    } finally {
        downloadImage.getInputStream().close();
    }
    ByteBuffer b = ByteBuffer.wrap(imgContent);
    if (b.getInt() == QCOW2_SIGNATURE && b.getInt() == QCOW2_VERSION) {
        b.position(QCOW2_SIZE_OFFSET);
        return b.getLong();
    }
    throw new RuntimeException("Unable to recognize QCOW2 format");
}
#method_after
private long getCowVirtualSize(String id) {
    // For the qcow2 format we need to download the image header and read the virtual size from there
    byte[] imgContent = new byte[72];
    ImageDownload downloadImage = getClient().images().download(id).execute();
    try {
        int bytesRead = downloadImage.getInputStream().read(imgContent, 0, imgContent.length);
        if (bytesRead != imgContent.length) {
            throw new OpenStackImageException(OpenStackImageException.ErrorType.UNABLE_TO_DOWNLOAD_IMAGE, "Unable to read image header: " + bytesRead);
        }
    } catch (IOException e) {
        throw new OpenStackImageException(OpenStackImageException.ErrorType.UNABLE_TO_DOWNLOAD_IMAGE, "Unable to download image");
    } finally {
        try {
            downloadImage.getInputStream().close();
        } catch (IOException e) {
        // Silently skip errors on close
        }
    }
    ByteBuffer b = ByteBuffer.wrap(imgContent);
    if (b.getInt() == QCOW2_SIGNATURE && b.getInt() == QCOW2_VERSION) {
        b.position(QCOW2_SIZE_OFFSET);
        return b.getLong();
    }
    throw new OpenStackImageException(OpenStackImageException.ErrorType.UNRECOGNIZED_IMAGE_FORMAT, "Unable to recognize QCOW2 format");
}
#end_block

#method_before
protected long getImageVirtualSize(Image glanceImage) {
    validateContainerFormat(glanceImage);
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue()) || glanceImage.getDiskFormat().equals(GlanceImageFormat.ISO.getValue())) {
        return glanceImage.getSize();
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        try {
            return getCowVirtualSize(glanceImage.getId());
        } catch (IOException e) {
            throw new RuntimeException("Unsupported image format");
        }
    }
    throw new RuntimeException("Unsupported image format");
}
#method_after
protected long getImageVirtualSize(Image glanceImage) {
    validateContainerFormat(glanceImage);
    if (glanceImage.getDiskFormat().equals(GlanceImageFormat.RAW.getValue()) || glanceImage.getDiskFormat().equals(GlanceImageFormat.ISO.getValue())) {
        return glanceImage.getSize();
    } else if (glanceImage.getDiskFormat().equals(GlanceImageFormat.COW.getValue())) {
        return getCowVirtualSize(glanceImage.getId());
    }
    throw new OpenStackImageException(OpenStackImageException.ErrorType.UNSUPPORTED_DISK_FORMAT, "Unknown disk format: " + glanceImage.getDiskFormat());
}
#end_block

#method_before
public int getHighlyAvailableScore() {
    return this.mVdsDynamic.getHighlyAvailableScore();
}
#method_after
public Integer getHighlyAvailableScore() {
    return this.mVdsStatistics.getHighlyAvailableScore();
}
#end_block

#method_before
public void setHighlyAvailableScore(int value) {
    this.mVdsDynamic.setHighlyAvailableScore(value);
}
#method_after
public void setHighlyAvailableScore(Integer value) {
    this.mVdsStatistics.setHighlyAvailableScore(value);
}
#end_block

#method_before
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit) {
    switch(policyUnit.getName()) {
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit);
        case "CPU":
            return new CPUPolicyUnit(policyUnit);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit);
        case "Network":
            return new NetworkPolicyUnit(policyUnit);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new HAClusterWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.Filter) {
                return new HAClusterFilterPolicyUnit(policyUnit);
            }
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new NoneWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new NoneBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new PowerSavingWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new PowerSavingBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#method_after
public static PolicyUnitImpl getPolicyUnitImpl(PolicyUnit policyUnit) {
    switch(policyUnit.getName()) {
        case "PinToHost":
            return new PinToHostPolicyUnit(policyUnit);
        case "CPU":
            return new CPUPolicyUnit(policyUnit);
        case "Memory":
            return new MemoryPolicyUnit(policyUnit);
        case "Network":
            return new NetworkPolicyUnit(policyUnit);
        case "HA":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new HostedEngineHAClusterWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.Filter) {
                return new HostedEngineHAClusterFilterPolicyUnit(policyUnit);
            }
        case "CPU-Level":
            return new CpuLevelFilterPolicyUnit(policyUnit);
        case "None":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new NoneWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new NoneBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForPowerSaving":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new PowerSavingWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new PowerSavingBalancePolicyUnit(policyUnit);
            }
            break;
        case "OptimalForEvenDistribution":
            if (policyUnit.getPolicyUnitType() == PolicyUnitType.Weight) {
                return new EvenDistributionWeightPolicyUnit(policyUnit);
            } else if (policyUnit.getPolicyUnitType() == PolicyUnitType.LoadBalancing) {
                return new EvenDistributionBalancePolicyUnit(policyUnit);
            }
            break;
        default:
            break;
    }
    throw new NotImplementedException("policyUnit: " + policyUnit.getName());
}
#end_block

#method_before
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
}
#method_after
public static void updateVDSDynamicData(VDS vds, Map<String, Object> xmlRpcStruct) {
    updateNetworkData(vds, xmlRpcStruct);
    vds.setCpuThreads(AssignIntValue(xmlRpcStruct, VdsProperties.cpuThreads));
    vds.setCpuCores(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_cores));
    vds.setCpuSockets(AssignIntValue(xmlRpcStruct, VdsProperties.cpu_sockets));
    vds.setCpuModel(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_model));
    vds.setCpuSpeedMh(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_speed_mh));
    vds.setPhysicalMemMb(AssignIntValue(xmlRpcStruct, VdsProperties.physical_mem_mb));
    vds.setKvmEnabled(AssignBoolValue(xmlRpcStruct, VdsProperties.kvm_enabled));
    vds.setReservedMem(AssignIntValue(xmlRpcStruct, VdsProperties.reservedMem));
    Integer guestOverhead = AssignIntValue(xmlRpcStruct, VdsProperties.guestOverhead);
    vds.setGuestOverhead(guestOverhead != null ? guestOverhead : 0);
    vds.setCpuFlags(AssignStringValue(xmlRpcStruct, VdsProperties.cpu_flags));
    UpdatePackagesVersions(vds, xmlRpcStruct);
    vds.setSupportedClusterLevels(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_cluster_levels));
    vds.setSupportedEngines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.supported_engines));
    vds.setIScsiInitiatorName(AssignStringValue(xmlRpcStruct, VdsProperties.iSCSIInitiatorName));
    vds.setSupportedEmulatedMachines(AssignStringValueFromArray(xmlRpcStruct, VdsProperties.emulatedMachines));
    // default value if hooks is not in the xml rpc struct
    String hooksStr = "";
    if (xmlRpcStruct.containsKey(VdsProperties.hooks)) {
        hooksStr = xmlRpcStruct.get(VdsProperties.hooks).toString();
    }
    vds.setHooksStr(hooksStr);
    // parse out the HBAs available in this host
    Map<String, List<Map<String, String>>> hbas = new HashMap<>();
    for (Map.Entry<String, Object[]> el : ((Map<String, Object[]>) xmlRpcStruct.get(VdsProperties.HBAInventory)).entrySet()) {
        List<Map<String, String>> devicesList = new ArrayList<Map<String, String>>();
        for (Object device : el.getValue()) {
            devicesList.add((Map<String, String>) device);
        }
        hbas.put(el.getKey(), devicesList);
    }
    vds.setHBAs(hbas);
}
#end_block

#method_before
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
        if (vds.getUsageCpuPercent() >= vds.getHighUtilization() || vds.getUsageCpuPercent() <= vds.getLowUtilization()) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
}
#method_after
public static void updateVDSStatisticsData(VDS vds, Map<String, Object> xmlRpcStruct) {
    // ------------- vds memory usage ---------------------------
    vds.setUsageMemPercent(AssignIntValue(xmlRpcStruct, VdsProperties.mem_usage));
    // ------------- vds network statistics ---------------------
    Map<String, Object> interfaces = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.NETWORK);
    if (interfaces != null) {
        int networkUsage = 0;
        for (Entry<String, Object> entry : interfaces.entrySet()) {
            VdsNetworkInterface iface = null;
            for (VdsNetworkInterface tempInterface : vds.getInterfaces()) {
                if (tempInterface.getName().equals(entry.getKey())) {
                    iface = tempInterface;
                    break;
                }
            }
            if (iface != null) {
                iface.setVdsId(vds.getId());
                Map<String, Object> dict = (Map<String, Object>) entry.getValue();
                Double rx_rate = AssignDoubleValue(dict, VdsProperties.rx_rate);
                Double rx_dropped = AssignDoubleValue(dict, VdsProperties.rx_dropped);
                Double tx_rate = AssignDoubleValue(dict, VdsProperties.tx_rate);
                Double tx_dropped = AssignDoubleValue(dict, VdsProperties.tx_dropped);
                iface.getStatistics().setReceiveRate(rx_rate != null ? rx_rate : 0);
                iface.getStatistics().setReceiveDropRate(rx_dropped != null ? rx_dropped : 0);
                iface.getStatistics().setTransmitRate(tx_rate != null ? tx_rate : 0);
                iface.getStatistics().setTransmitDropRate(tx_dropped != null ? tx_dropped : 0);
                iface.setSpeed(AssignIntValue(dict, VdsProperties.INTERFACE_SPEED));
                iface.getStatistics().setStatus(AssignInterfaceStatusValue(dict, VdsProperties.iface_status));
                int hold = (iface.getStatistics().getTransmitRate().compareTo(iface.getStatistics().getReceiveRate()) > 0 ? iface.getStatistics().getTransmitRate() : iface.getStatistics().getReceiveRate()).intValue();
                if (hold > networkUsage) {
                    networkUsage = hold;
                }
            }
        }
        vds.setUsageNetworkPercent((networkUsage > 100) ? 100 : networkUsage);
    }
    // ----------- vds cpu statistics info ---------------------
    vds.setCpuSys(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_sys));
    vds.setCpuUser(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_user));
    if (vds.getCpuSys() != null && vds.getCpuUser() != null) {
        vds.setUsageCpuPercent((int) (vds.getCpuSys() + vds.getCpuUser()));
        if (vds.getUsageCpuPercent() >= vds.getHighUtilization() || vds.getUsageCpuPercent() <= vds.getLowUtilization()) {
            if (vds.getCpuOverCommitTimestamp() == null) {
                vds.setCpuOverCommitTimestamp(new Date());
            }
        } else {
            vds.setCpuOverCommitTimestamp(null);
        }
    }
    // CPU load reported by VDSM is in uptime-style format, i.e. normalized
    // to unity, so that say an 8% load is reported as 0.08
    Double d = AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_load);
    d = (d != null) ? d : 0;
    vds.setCpuLoad(d.doubleValue() * 100.0);
    vds.setCpuIdle(AssignDoubleValue(xmlRpcStruct, VdsProperties.cpu_idle));
    vds.setMemAvailable(AssignLongValue(xmlRpcStruct, VdsProperties.mem_available));
    vds.setMemFree(AssignLongValue(xmlRpcStruct, VdsProperties.memFree));
    vds.setMemShared(AssignLongValue(xmlRpcStruct, VdsProperties.mem_shared));
    vds.setSwapFree(AssignLongValue(xmlRpcStruct, VdsProperties.swap_free));
    vds.setSwapTotal(AssignLongValue(xmlRpcStruct, VdsProperties.swap_total));
    vds.setKsmCpuPercent(AssignIntValue(xmlRpcStruct, VdsProperties.ksm_cpu_percent));
    vds.setKsmPages(AssignLongValue(xmlRpcStruct, VdsProperties.ksm_pages));
    vds.setKsmState(AssignBoolValue(xmlRpcStruct, VdsProperties.ksm_state));
    // dynamic data got from GetVdsStats
    if (xmlRpcStruct.containsKey(VdsProperties.transparent_huge_pages_state)) {
        vds.setTransparentHugePagesState(EnumUtils.valueOf(VdsTransparentHugePagesState.class, xmlRpcStruct.get(VdsProperties.transparent_huge_pages_state).toString(), true));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.anonymous_transparent_huge_pages)) {
        vds.setAnonymousHugePages(AssignIntValue(xmlRpcStruct, VdsProperties.anonymous_transparent_huge_pages));
    }
    vds.setNetConfigDirty(AssignBoolValue(xmlRpcStruct, VdsProperties.netConfigDirty));
    vds.setImagesLastCheck(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_check));
    vds.setImagesLastDelay(AssignDoubleValue(xmlRpcStruct, VdsProperties.images_last_delay));
    Integer vm_count = AssignIntValue(xmlRpcStruct, VdsProperties.vm_count);
    vds.setVmCount(vm_count == null ? 0 : vm_count);
    vds.setVmActive(AssignIntValue(xmlRpcStruct, VdsProperties.vm_active));
    vds.setVmMigrating(AssignIntValue(xmlRpcStruct, VdsProperties.vm_migrating));
    updateVDSDomainData(vds, xmlRpcStruct);
    updateLocalDisksUsage(vds, xmlRpcStruct);
    Integer haScore = AssignIntValue(xmlRpcStruct, VdsProperties.ha_score);
    vds.setHighlyAvailableScore(haScore != null ? haScore : 0);
}
#end_block

#method_before
protected boolean formatStorage(StorageDomain dom, VDS vds) {
    try {
        return getVdsBroker().RunVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vds.getId(), dom.getId())).getSucceeded();
    } catch (VdcBLLException e) {
        if (e.getVdsError().getCode() != VdcBllErrors.StorageDomainDoesNotExist) {
            throw e;
        }
        log.warnFormat("Storage Domain {0} which was about to be formatted was not exists in VDS id {1}", vds.getId(), dom.getId());
        return true;
    }
}
#method_after
protected boolean formatStorage(StorageDomain dom, VDS vds) {
    try {
        return getVdsBroker().RunVdsCommand(VDSCommandType.FormatStorageDomain, new FormatStorageDomainVDSCommandParameters(vds.getId(), dom.getId())).getSucceeded();
    } catch (VdcBLLException e) {
        if (e.getErrorCode() != VdcBllErrors.StorageDomainDoesNotExist) {
            throw e;
        }
        log.warnFormat("Storage Domain {0} which was about to be formatted does not exist in VDS {1}", dom.getName(), vds.getName());
        return true;
    }
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps == null || steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        } else {
            // update status in step table
            for (Step step : steps) {
                if (step.getEndTime() != null) {
                    // we have already processed the task
                    continue;
                }
                step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
                if (hasTaskCompleted(task)) {
                    step.markStepEnded(task.getStatus());
                    endStepJob(step);
                    releaseVolumeLock(task.getTaskId());
                } else {
                    getJobRepository().updateStep(step);
                }
            }
        }
    }
    return runningTasks;
}
#method_after
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getTemplateDisks() != null && !getTemplateDisks().isEmpty()) {
        ensureDomainMap(getTemplateDisks(), getParameters().getStorageDomainId());
        ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), imageFromSourceDomainMap, null, true);
        if (getVmTemplate().getDiskMap().values().size() != imageFromSourceDomainMap.size()) {
            log.errorFormat("Can't find any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
        }
        if (!VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), null, getReturnValue().getCanDoActionMessages(), true, true, true, false, getTemplateDisks())) {
            return false;
        }
        setStoragePoolId(getVmTemplate().getStoragePoolId());
        if (!checkStorageDomain() || !checkStorageDomainStatus(StorageDomainStatus.Active)) {
            return false;
        }
        long actualDiskSize = Double.valueOf(getVmTemplate().getActualDiskSize()).longValue();
        if (!checkFreeSpaceOnDestinationDomain(getStorageDomain(), actualDiskSize)) {
            return false;
        }
        try {
            if (atLeastOneImageFoundInStorageDomain(getTemplateDisks(), getStorageDomain().getId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_ALREADY_CONTAINS_DISK);
            }
        } catch (RuntimeException e) {
            // There is nothing to do in case of VDSM failure to retrieve images from the given storage domain
            // except of writing the log file. The command itself will probably fail during the execution
            // and then user will get meaningful error message
            log.error("Failed to validate if target storage domain already contains one of the template disks! " + e.getMessage());
        }
        StoragePoolIsoMapId storagePoolIsoMapId = new StoragePoolIsoMapId(getStorageDomain().getId(), getVmTemplate().getStoragePoolId().getValue());
        if (DbFacade.getInstance().getStoragePoolIsoMapDao().get(storagePoolIsoMapId) == null) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = true;
    if (getVmTemplate() == null) {
        retValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    } else if (getTemplateDisks() != null && !getTemplateDisks().isEmpty()) {
        ensureDomainMap(getTemplateDisks(), getParameters().getStorageDomainId());
        // check that images are ok
        ImagesHandler.fillImagesMapBasedOnTemplate(getVmTemplate(), imageFromSourceDomainMap, null, true);
        if (getVmTemplate().getDiskTemplateMap().values().size() != imageFromSourceDomainMap.size()) {
            log.errorFormat("Can not found any default active domain for one of the disks of template with id : {0}", getVmTemplate().getId());
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MISSED_STORAGES_FOR_SOME_DISKS);
            retValue = false;
        }
        retValue = retValue && VmTemplateCommand.isVmTemplateImagesReady(getVmTemplate(), null, getReturnValue().getCanDoActionMessages(), true, true, true, false, getTemplateDisks());
        if (retValue) {
            setStoragePoolId(getVmTemplate().getStoragePoolId());
            retValue = checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active) && checkIfDisksExist(getTemplateDisks()) && checkFreeSpaceOnDestinationDomain(getStorageDomain(), (int) getVmTemplate().getActualDiskSize());
        }
        if (retValue && DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(getStorageDomain().getId(), getVmTemplate().getStoragePoolId())) == null) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH);
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean checkFreeSpaceOnDestinationDomain(StorageDomain domain, long requestedSizeGB) {
    return validate(new StorageDomainValidator(domain).isDomainHasSpaceForRequest(requestedSizeGB));
}
#method_after
private boolean checkFreeSpaceOnDestinationDomain(StorageDomain domain, int requestedSizeGB) {
    return validate(new StorageDomainValidator(domain).isDomainHasSpaceForRequest(requestedSizeGB));
}
#end_block

#method_before
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
                p.setParentCommand(getActionType());
                p.setEntityId(getParameters().getEntityId());
                p.setAddImageDomainMapping(getMoveOrCopyImageOperation() == ImageOperation.Copy);
                p.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
                p.setParentParameters(getParameters());
                VdcReturnValueBase vdcRetValue = getBackend().runInternalAction(getImagesActionType(), p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
            }
            return null;
        }
    });
}
#method_after
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                VdcReturnValueBase vdcRetValue = getBackend().runInternalAction(getImagesActionType(), buildModeOrCopyImageGroupParameters(containerID, disk), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }

        private MoveOrCopyImageGroupParameters buildModeOrCopyImageGroupParameters(final Guid containerID, DiskImage disk) {
            MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
            params.setParentCommand(getActionType());
            params.setEntityInfo(getParameters().getEntityInfo());
            params.setAddImageDomainMapping(getMoveOrCopyImageOperation() == ImageOperation.Copy);
            params.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
            params.setParentParameters(getParameters());
            return params;
        }
    });
}
#end_block

#method_before
protected void fillMacAddressIfMissing(VmNetworkInterface iface) {
    if (StringUtils.isEmpty(iface.getMacAddress()) && (MacPoolManager.getInstance().getAvailableMacsCount() >= 1)) {
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
}
#method_after
protected void fillMacAddressIfMissing(VmNic iface) {
    if (StringUtils.isEmpty(iface.getMacAddress()) && (MacPoolManager.getInstance().getAvailableMacsCount() >= 1)) {
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
    }
}
#end_block

#method_before
protected boolean validateMacAddress(List<VmNetworkInterface> ifaces) {
    int freeMacs = 0;
    for (VmNetworkInterface iface : ifaces) {
        if (!StringUtils.isEmpty(iface.getMacAddress())) {
            if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                addCanDoActionMessage("$IfaceName " + iface.getName());
                addCanDoActionMessage("$MacAddress " + iface.getMacAddress());
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID);
                return false;
            }
        } else {
            freeMacs++;
        }
    }
    if (freeMacs > 0 && !(MacPoolManager.getInstance().getAvailableMacsCount() >= freeMacs)) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#method_after
protected boolean validateMacAddress(List<VmNic> ifaces) {
    int freeMacs = 0;
    for (VmNic iface : ifaces) {
        if (!StringUtils.isEmpty(iface.getMacAddress())) {
            if (!VALIDATE_MAC_ADDRESS.matcher(iface.getMacAddress()).matches()) {
                addCanDoActionMessage("$IfaceName " + iface.getName());
                addCanDoActionMessage("$MacAddress " + iface.getMacAddress());
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NETWORK_INTERFACE_MAC_INVALID);
                return false;
            }
        } else {
            freeMacs++;
        }
    }
    if (freeMacs > 0 && !(MacPoolManager.getInstance().getAvailableMacsCount() >= freeMacs)) {
        addCanDoActionMessage(VdcBllMessages.MAC_POOL_NOT_ENOUGH_MAC_ADDRESSES);
        return false;
    }
    return true;
}
#end_block

#method_before
private void mockGetStorageDomainList(int availableDiskSizeFirstDomain, int availableDiskSizeSecondDomain) {
    // Mock Dao
    storageDomainsList = getStorageDomainList(availableDiskSizeFirstDomain, availableDiskSizeSecondDomain);
    mockDiskImageDAO();
    mockStorageDomainDAO(storageDomainsList);
}
#method_after
protected void mockGetStorageDomainList(int availableDiskSizeFirstDomain, int availableDiskSizeSecondDomain) {
    // Mock Dao
    storageDomainsList = getStorageDomainList(availableDiskSizeFirstDomain, availableDiskSizeSecondDomain);
    mockDiskImageDAO();
    mockStorageDomainDAO(storageDomainsList);
}
#end_block

#method_before
private StoragePool mockStoragePool() {
    StoragePool storagePool = new StoragePool();
    storagePool.setstatus(StoragePoolStatus.Up);
    return storagePool;
}
#method_after
private StoragePool mockStoragePool() {
    StoragePool storagePool = new StoragePool();
    storagePool.setStatus(StoragePoolStatus.Up);
    return storagePool;
}
#end_block

#method_before
private static void setDiskList(VmTemplate vmTemplate) {
    for (DiskImage diskImage : getDiskImageList()) {
        vmTemplate.getDiskList().add(diskImage);
    }
    Map<Guid, DiskImage> diskImageTemplate = getDiskImageTempalteList();
    for (Guid key : diskImageTemplate.keySet()) {
        vmTemplate.getDiskMap().put(key, diskImageTemplate.get(key));
    }
}
#method_after
private static void setDiskList(VmTemplate vmTemplate) {
    for (DiskImage diskImage : getDiskImageList()) {
        vmTemplate.getDiskList().add(diskImage);
    }
    Map<Guid, DiskImage> diskImageTemplate = getDiskImageTempalteList();
    vmTemplate.getDiskTemplateMap().putAll(diskImageTemplate);
}
#end_block

#method_before
private static List<DiskImage> getDiskImageList() {
    List<DiskImage> diskList = new ArrayList<DiskImage>();
    DiskImage diskImage = new DiskImage();
    diskImage.setId(Guid.NewGuid());
    diskImage.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    diskImage = new DiskImage();
    diskImage.setId(Guid.NewGuid());
    diskImage.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    return diskList;
}
#method_after
private static List<DiskImage> getDiskImageList() {
    List<DiskImage> diskList = new ArrayList<DiskImage>();
    DiskImage diskImage = new DiskImage();
    diskImage.setId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    diskImage = new DiskImage();
    diskImage.setId(Guid.newGuid());
    diskImage.setStorageIds(new ArrayList<Guid>());
    diskList.add(diskImage);
    return diskList;
}
#end_block

#method_before
private static Map<Guid, DiskImage> getDiskImageTempalteList() {
    Map<Guid, DiskImage> diskTemplateList = new HashMap<Guid, DiskImage>();
    DiskImage diskImageTemplate = new DiskImage();
    diskImageTemplate.setId(Guid.NewGuid());
    diskImageTemplate.setImageId(Guid.NewGuid());
    diskImageTemplate.setStorageIds(new ArrayList<Guid>());
    diskTemplateList.put(diskImageTemplate.getId(), diskImageTemplate);
    diskImageTemplate = new DiskImage();
    diskImageTemplate.setId(Guid.NewGuid());
    diskImageTemplate.setImageId(Guid.NewGuid());
    diskImageTemplate.setStorageIds(new ArrayList<Guid>());
    diskTemplateList.put(diskImageTemplate.getId(), diskImageTemplate);
    return diskTemplateList;
}
#method_after
private static Map<Guid, DiskImage> getDiskImageTempalteList() {
    Map<Guid, DiskImage> diskTemplateList = new HashMap<Guid, DiskImage>();
    DiskImage diskImageTemplate = new DiskImage();
    diskImageTemplate.setId(Guid.newGuid());
    diskImageTemplate.setImageId(Guid.newGuid());
    diskImageTemplate.setStorageIds(new ArrayList<Guid>());
    diskTemplateList.put(diskImageTemplate.getId(), diskImageTemplate);
    diskImageTemplate = new DiskImage();
    diskImageTemplate.setId(Guid.newGuid());
    diskImageTemplate.setImageId(Guid.newGuid());
    diskImageTemplate.setStorageIds(new ArrayList<Guid>());
    diskTemplateList.put(diskImageTemplate.getId(), diskImageTemplate);
    return diskTemplateList;
}
#end_block

#method_before
private VmStatic getVmStatic() {
    VmStatic vmStatic = new VmStatic();
    vmStatic.setOs(VmOsType.Unassigned);
    vmStatic.setMemSizeMb(300);
    vmStatic.setStateless(false);
    vmStatic.setVmtGuid(vmTemplateId);
    return vmStatic;
}
#method_after
private VmStatic getVmStatic() {
    VmStatic vmStatic = new VmStatic();
    vmStatic.setOsId(OsRepository.DEFAULT_OS);
    vmStatic.setMemSizeMb(300);
    vmStatic.setStateless(false);
    vmStatic.setVmtGuid(vmTemplateId);
    return vmStatic;
}
#end_block

#method_before
@Test
public void canAddThinVmFromTemplateWithManyDisks() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 10;
    AddVmCommand<VmManagementParametersBase> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(Collections.emptyList()).when(cmd).validateCustomProperties(any(VmStatic.class));
    // Adding 10 disks, which each one should consume the default sparse size (which is 1GB).
    setNewDisksForTemplate(10, cmd.getVmTemplate().getDiskMap());
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    assertFalse("Thin vm could not be added due to storage sufficient", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
    assertTrue("canDoAction failed for insufficient disk size", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void canAddThinVmFromTemplateWithManyDisks() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 10;
    AddVmCommand<VmManagementParametersBase> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(Collections.emptyList()).when(cmd).validateCustomProperties(any(VmStatic.class));
    // Adding 10 disks, which each one should consume the default sparse size (which is 1GB).
    setNewDisksForTemplate(10, cmd.getVmTemplate().getDiskTemplateMap());
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    assertFalse("Thin vm could not be added due to storage sufficient", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
    assertTrue("canDoAction failed for insufficient disk size", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.NewGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    assertFalse("Clone vm should have failed due to non existing snapshot id", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to non existing snapshot id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    assertFalse("Clone vm should have failed due to non existing snapshot id", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to non existing snapshot id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST.toString()));
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.NewGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    assertFalse("Clone vm should have failed due to non existing vm configuration", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to no configuration id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    assertFalse("Clone vm should have failed due to non existing vm configuration", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to no configuration id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION.toString()));
}
#end_block

#method_before
private AddVmFromTemplateCommand<AddVmFromTemplateParameters> createVmFromTemplateCommand(VM vm) {
    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> concrete = new AddVmFromTemplateCommand<AddVmFromTemplateParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }
    };
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(Collections.emptyList()).when(result).validateCustomProperties(any(VmStatic.class));
    mockDAOs(result);
    mockBackend(result);
    return result;
}
#method_after
private AddVmFromTemplateCommand<AddVmFromTemplateParameters> createVmFromTemplateCommand(VM vm) {
    AddVmFromTemplateParameters param = new AddVmFromTemplateParameters();
    param.setVm(vm);
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> concrete = new AddVmFromTemplateCommand<AddVmFromTemplateParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    AddVmFromTemplateCommand<AddVmFromTemplateParameters> result = spy(concrete);
    doReturn(true).when(result).checkNumberOfMonitors();
    doReturn(createVmTemplate()).when(result).getVmTemplate();
    doReturn(Collections.emptyList()).when(result).validateCustomProperties(any(VmStatic.class));
    mockDAOs(result);
    mockBackend(result);
    return result;
}
#end_block

#method_before
private AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> createVmFromSnapshotCommand(VM vm, Guid sourceSnapshotId) {
    AddVmFromSnapshotParameters param = new AddVmFromSnapshotParameters();
    param.setVm(vm);
    param.setSourceSnapshotId(sourceSnapshotId);
    param.setStorageDomainId(Guid.NewGuid());
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = new AddVmFromSnapshotCommand<AddVmFromSnapshotParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }
    };
    cmd = spy(cmd);
    doReturn(vm).when(cmd).getVm();
    mockDAOs(cmd);
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockBackend(cmd);
    return cmd;
}
#method_after
private AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> createVmFromSnapshotCommand(VM vm, Guid sourceSnapshotId) {
    AddVmFromSnapshotParameters param = new AddVmFromSnapshotParameters();
    param.setVm(vm);
    param.setSourceSnapshotId(sourceSnapshotId);
    param.setStorageDomainId(Guid.newGuid());
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = new AddVmFromSnapshotCommand<AddVmFromSnapshotParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    doReturn(vm).when(cmd).getVm();
    mockDAOs(cmd);
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockBackend(cmd);
    return cmd;
}
#end_block

#method_before
private static <T extends VmManagementParametersBase> void initCommandMethods(AddVmCommand<T> cmd) {
    doReturn(Guid.NewGuid()).when(cmd).getStoragePoolId();
    doReturn(true).when(cmd).canAddVm(anyListOf(String.class), anyString(), any(Guid.class), anyInt());
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
}
#method_after
private static <T extends VmManagementParametersBase> void initCommandMethods(AddVmCommand<T> cmd) {
    doReturn(Guid.newGuid()).when(cmd).getStoragePoolId();
    doReturn(true).when(cmd).canAddVm(anyListOf(String.class), anyString(), any(Guid.class), anyInt());
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
}
#end_block

#method_before
private static void setNewDisksForTemplate(int numberOfNewDisks, Map<Guid, DiskImage> disksMap) {
    for (int newDiskInd = 0; newDiskInd < numberOfNewDisks; newDiskInd++) {
        DiskImage diskImageTempalte = new DiskImage();
        diskImageTempalte.setImageId(Guid.NewGuid());
        disksMap.put(Guid.NewGuid(), diskImageTempalte);
    }
}
#method_after
private static void setNewDisksForTemplate(int numberOfNewDisks, Map<Guid, DiskImage> disksMap) {
    for (int newDiskInd = 0; newDiskInd < numberOfNewDisks; newDiskInd++) {
        DiskImage diskImageTempalte = new DiskImage();
        diskImageTempalte.setImageId(Guid.newGuid());
        disksMap.put(Guid.newGuid(), diskImageTempalte);
    }
}
#end_block

#method_before
private static void setNewImageDiskMapForTemplate(AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd, long diskSize, Map<Guid, DiskImage> diskImageMap) {
    DiskImage diskImage = new DiskImage();
    diskImage.setActualSizeInBytes(diskSize);
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    diskImageMap.put(Guid.NewGuid(), diskImage);
    cmd.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    cmd.storageToDisksMap.put(STORAGE_DOMAIN_ID, new ArrayList<DiskImage>(diskImageMap.values()));
}
#method_after
private static void setNewImageDiskMapForTemplate(AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd, long diskSize, Map<Guid, DiskImage> diskImageMap) {
    DiskImage diskImage = new DiskImage();
    diskImage.setActualSizeInBytes(diskSize);
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    diskImageMap.put(Guid.newGuid(), diskImage);
    cmd.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    cmd.storageToDisksMap.put(STORAGE_DOMAIN_ID, new ArrayList<DiskImage>(diskImageMap.values()));
}
#end_block

#method_before
private void mockStorageDomainDAOGetForStoragePool(int domainSpaceGB) {
    when(sdDAO.getForStoragePool(Matchers.<Guid>any(Guid.class), Matchers.<NGuid>any(NGuid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#method_after
private void mockStorageDomainDAOGetForStoragePool(int domainSpaceGB) {
    when(sdDAO.getForStoragePool(Matchers.<Guid>any(Guid.class), Matchers.<Guid>any(Guid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#end_block

#method_before
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskMap().put(image.getImageId(), image);
        Map<Guid, DiskImage> diskImageMap = new HashMap<Guid, DiskImage>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#method_after
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskTemplateMap().put(image.getImageId(), image);
        HashMap<Guid, DiskImage> diskImageMap = new HashMap<Guid, DiskImage>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#end_block

#method_before
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.NewGuid());
    i.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return i;
}
#method_after
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.newGuid());
    i.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return i;
}
#end_block

#method_before
private static DiskImage createDiskImage(int size) {
    DiskImage img = new DiskImage();
    img.setSizeInGigabytes(size);
    img.setActualSize(size);
    img.setId(Guid.NewGuid());
    img.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return img;
}
#method_after
private static DiskImage createDiskImage(int size) {
    DiskImage img = new DiskImage();
    img.setSizeInGigabytes(size);
    img.setActualSize(size);
    img.setId(Guid.newGuid());
    img.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return img;
}
#end_block

#method_before
private void mockConfig() {
    mcr.mockConfigValue(ConfigValues.PredefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.UserDefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.InitStorageSparseSizeInGB, 1);
}
#method_after
private void mockConfig() {
    mcr.mockConfigValue(ConfigValues.PredefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.UserDefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.InitStorageSparseSizeInGB, 1);
    mcr.mockConfigValue(ConfigValues.VirtIoScsiEnabled, Version.v3_3, true);
}
#end_block

#method_before
private static VM createVm() {
    VM vm = new VM();
    VmDynamic dynamic = new VmDynamic();
    VmStatic stat = new VmStatic();
    stat.setVmtGuid(Guid.NewGuid());
    stat.setName("testVm");
    stat.setPriority(1);
    vm.setStaticData(stat);
    vm.setDynamicData(dynamic);
    return vm;
}
#method_after
private static VM createVm() {
    VM vm = new VM();
    VmDynamic dynamic = new VmDynamic();
    VmStatic stat = new VmStatic();
    stat.setVmtGuid(Guid.newGuid());
    stat.setName("testVm");
    stat.setPriority(1);
    vm.setStaticData(stat);
    vm.setDynamicData(dynamic);
    vm.setSingleQxlPci(false);
    return vm;
}
#end_block

#method_before
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = new AddVmCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        protected int getNeededDiskSize(Guid domainId) {
            return getBlockSparseInitSizeInGb() * getVmTemplate().getDiskMap().size();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    return cmd;
}
#method_after
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = new AddVmCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        protected int getNeededDiskSize(Guid domainId) {
            return getBlockSparseInitSizeInGb() * getVmTemplate().getDiskTemplateMap().size();
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    return cmd;
}
#end_block

#method_before
private <T extends VmManagementParametersBase> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString());
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    spy.setVmTemplateId(Guid.NewGuid());
}
#method_after
private <T extends VmManagementParametersBase> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString());
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(createVdsGroup()).when(spy).getVdsGroup();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    doReturn(false).when(spy).isVirtioScsiControllerAttached(any(Guid.class));
    spy.setVmTemplateId(Guid.newGuid());
}
#end_block

#method_before
@Test
public void canAddThinVmFromTemplateWithManyDisks() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 10;
    AddVmCommand<VmManagementParametersBase> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(Collections.emptyList()).when(cmd).validateCustomProperties(any(VmStatic.class));
    // Adding 10 disks, which each one should consume the default sparse size (which is 1GB).
    setNewDisksForTemplate(10, cmd.getVmTemplate().getDiskMap());
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    assertFalse("Thin vm could not be added due to storage sufficient", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
    assertTrue("canDoAction failed for insufficient disk size", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#method_after
@Test
public void canAddThinVmFromTemplateWithManyDisks() {
    ArrayList<String> reasons = new ArrayList<String>();
    final int domainSizeGB = 20;
    final int sizeRequired = 10;
    AddVmCommand<VmManagementParametersBase> cmd = setupCanAddVmTests(domainSizeGB, sizeRequired);
    doReturn(Collections.emptyList()).when(cmd).validateCustomProperties(any(VmStatic.class));
    // Adding 10 disks, which each one should consume the default sparse size (which is 1GB).
    setNewDisksForTemplate(10, cmd.getVmTemplate().getDiskTemplateMap());
    doReturn(createVmTemplate()).when(cmd).getVmTemplate();
    assertFalse("Thin vm could not be added due to storage sufficient", cmd.canAddVm(reasons, Arrays.asList(createStorageDomain(domainSizeGB))));
    assertTrue("canDoAction failed for insufficient disk size", cmd.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISK_SPACE_LOW_ON_TARGET_STORAGE_DOMAIN.toString()));
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.NewGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    assertFalse("Clone vm should have failed due to non existing snapshot id", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to non existing snapshot id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotSnapshotDoesNotExist() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    assertFalse("Clone vm should have failed due to non existing snapshot id", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to non existing snapshot id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_DOES_NOT_EXIST.toString()));
}
#end_block

#method_before
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.NewGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    assertFalse("Clone vm should have failed due to non existing vm configuration", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to no configuration id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION.toString()));
}
#method_after
@Test
public void canAddCloneVmFromSnapshotNoConfiguration() {
    final int domainSizeGB = 15;
    final int sizeRequired = 4;
    final Guid sourceSnapshotId = Guid.newGuid();
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = setupCanAddVmFromSnapshotTests(domainSizeGB, sizeRequired, sourceSnapshotId);
    cmd.getVm().setName("vm1");
    mockNonInterestingMethodsForCloneVmFromSnapshot(cmd);
    SnapshotsValidator sv = spy(new SnapshotsValidator());
    doReturn(ValidationResult.VALID).when(sv).vmNotDuringSnapshot(any(Guid.class));
    doReturn(sv).when(cmd).createSnapshotsValidator();
    when(snapshotDao.get(sourceSnapshotId)).thenReturn(new Snapshot());
    assertFalse("Clone vm should have failed due to non existing vm configuration", cmd.canDoAction());
    ArrayList<String> reasons = cmd.getReturnValue().getCanDoActionMessages();
    assertTrue("Clone vm should have failed due to no configuration id", reasons.contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_SNAPSHOT_HAS_NO_CONFIGURATION.toString()));
}
#end_block

#method_before
private AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> createVmFromSnapshotCommand(VM vm, Guid sourceSnapshotId) {
    AddVmFromSnapshotParameters param = new AddVmFromSnapshotParameters();
    param.setVm(vm);
    param.setSourceSnapshotId(sourceSnapshotId);
    param.setStorageDomainId(Guid.NewGuid());
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = new AddVmFromSnapshotCommand<AddVmFromSnapshotParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    doReturn(vm).when(cmd).getVm();
    mockDAOs(cmd);
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockBackend(cmd);
    return cmd;
}
#method_after
private AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> createVmFromSnapshotCommand(VM vm, Guid sourceSnapshotId) {
    AddVmFromSnapshotParameters param = new AddVmFromSnapshotParameters();
    param.setVm(vm);
    param.setSourceSnapshotId(sourceSnapshotId);
    param.setStorageDomainId(Guid.newGuid());
    AddVmFromSnapshotCommand<AddVmFromSnapshotParameters> cmd = new AddVmFromSnapshotCommand<AddVmFromSnapshotParameters>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // Stub for testing
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    doReturn(vm).when(cmd).getVm();
    mockDAOs(cmd);
    doReturn(snapshotDao).when(cmd).getSnapshotDao();
    mockBackend(cmd);
    return cmd;
}
#end_block

#method_before
private static <T extends VmManagementParametersBase> void initCommandMethods(AddVmCommand<T> cmd) {
    doReturn(Guid.NewGuid()).when(cmd).getStoragePoolId();
    doReturn(true).when(cmd).canAddVm(anyListOf(String.class), anyString(), any(Guid.class), anyInt());
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
}
#method_after
private static <T extends VmManagementParametersBase> void initCommandMethods(AddVmCommand<T> cmd) {
    doReturn(Guid.newGuid()).when(cmd).getStoragePoolId();
    doReturn(true).when(cmd).canAddVm(anyListOf(String.class), anyString(), any(Guid.class), anyInt());
    doReturn(STORAGE_POOL_ID).when(cmd).getStoragePoolId();
}
#end_block

#method_before
private static void setNewDisksForTemplate(int numberOfNewDisks, Map<Guid, DiskImage> disksMap) {
    for (int newDiskInd = 0; newDiskInd < numberOfNewDisks; newDiskInd++) {
        DiskImage diskImageTempalte = new DiskImage();
        diskImageTempalte.setImageId(Guid.NewGuid());
        disksMap.put(Guid.NewGuid(), diskImageTempalte);
    }
}
#method_after
private static void setNewDisksForTemplate(int numberOfNewDisks, Map<Guid, DiskImage> disksMap) {
    for (int newDiskInd = 0; newDiskInd < numberOfNewDisks; newDiskInd++) {
        DiskImage diskImageTempalte = new DiskImage();
        diskImageTempalte.setImageId(Guid.newGuid());
        disksMap.put(Guid.newGuid(), diskImageTempalte);
    }
}
#end_block

#method_before
private static void setNewImageDiskMapForTemplate(AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd, long diskSize, Map<Guid, DiskImage> diskImageMap) {
    DiskImage diskImage = new DiskImage();
    diskImage.setActualSizeInBytes(diskSize);
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    diskImageMap.put(Guid.NewGuid(), diskImage);
    cmd.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    cmd.storageToDisksMap.put(STORAGE_DOMAIN_ID, new ArrayList<DiskImage>(diskImageMap.values()));
}
#method_after
private static void setNewImageDiskMapForTemplate(AddVmFromTemplateCommand<AddVmFromTemplateParameters> cmd, long diskSize, Map<Guid, DiskImage> diskImageMap) {
    DiskImage diskImage = new DiskImage();
    diskImage.setActualSizeInBytes(diskSize);
    diskImage.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    diskImageMap.put(Guid.newGuid(), diskImage);
    cmd.storageToDisksMap = new HashMap<Guid, List<DiskImage>>();
    cmd.storageToDisksMap.put(STORAGE_DOMAIN_ID, new ArrayList<DiskImage>(diskImageMap.values()));
}
#end_block

#method_before
private void mockBackend(AddVmCommand<?> cmd) {
    VdcQueryReturnValue returnValue = new VdcQueryReturnValue();
    returnValue.setReturnValue(Boolean.FALSE);
    when(backend.runInternalQuery(Matchers.<VdcQueryType>any(VdcQueryType.class), Matchers.any(VdcQueryParametersBase.class))).thenReturn(returnValue);
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    doReturn(backend).when(cmd).getBackend();
}
#method_after
private void mockBackend(AddVmCommand<?> cmd) {
    when(backend.getResourceManager()).thenReturn(vdsBrokerFrontend);
    doReturn(backend).when(cmd).getBackend();
}
#end_block

#method_before
private void mockStorageDomainDAOGetForStoragePool(int domainSpaceGB) {
    when(sdDAO.getForStoragePool(Matchers.<Guid>any(Guid.class), Matchers.<NGuid>any(NGuid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#method_after
private void mockStorageDomainDAOGetForStoragePool(int domainSpaceGB) {
    when(sdDAO.getForStoragePool(Matchers.<Guid>any(Guid.class), Matchers.<Guid>any(Guid.class))).thenReturn(createStorageDomain(domainSpaceGB));
}
#end_block

#method_before
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskMap().put(image.getImageId(), image);
        Map<Guid, DiskImage> diskImageMap = new HashMap<Guid, DiskImage>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#method_after
private VmTemplate createVmTemplate() {
    if (vmTemplate == null) {
        vmTemplate = new VmTemplate();
        vmTemplate.setStoragePoolId(STORAGE_POOL_ID);
        DiskImage image = createDiskImageTemplate();
        vmTemplate.getDiskTemplateMap().put(image.getImageId(), image);
        HashMap<Guid, DiskImage> diskImageMap = new HashMap<Guid, DiskImage>();
        DiskImage diskImage = createDiskImage(REQUIRED_DISK_SIZE_GB);
        diskImageMap.put(diskImage.getId(), diskImage);
        vmTemplate.setDiskImageMap(diskImageMap);
    }
    return vmTemplate;
}
#end_block

#method_before
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.NewGuid());
    i.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return i;
}
#method_after
private static DiskImage createDiskImageTemplate() {
    DiskImage i = new DiskImage();
    i.setSizeInGigabytes(USED_SPACE_GB + AVAILABLE_SPACE_GB);
    i.setActualSizeInBytes(REQUIRED_DISK_SIZE_GB * 1024L * 1024L * 1024L);
    i.setImageId(Guid.newGuid());
    i.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return i;
}
#end_block

#method_before
private static DiskImage createDiskImage(int size) {
    DiskImage img = new DiskImage();
    img.setSizeInGigabytes(size);
    img.setActualSize(size);
    img.setId(Guid.NewGuid());
    img.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return img;
}
#method_after
private static DiskImage createDiskImage(int size) {
    DiskImage img = new DiskImage();
    img.setSizeInGigabytes(size);
    img.setActualSize(size);
    img.setId(Guid.newGuid());
    img.setStorageIds(new ArrayList<Guid>(Arrays.asList(STORAGE_DOMAIN_ID)));
    return img;
}
#end_block

#method_before
private void mockGetImageDomainsListVdsCommand() {
    ArrayList<Guid> guids = new ArrayList<Guid>(1);
    guids.add(Guid.NewGuid());
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(guids);
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.GetImageDomainsList), Matchers.<VDSParametersBase>any(VDSParametersBase.class))).thenReturn(returnValue);
}
#method_after
private void mockGetImageDomainsListVdsCommand() {
    ArrayList<Guid> guids = new ArrayList<Guid>(1);
    guids.add(Guid.newGuid());
    VDSReturnValue returnValue = new VDSReturnValue();
    returnValue.setReturnValue(guids);
    when(vdsBrokerFrontend.RunVdsCommand(eq(VDSCommandType.GetImageDomainsList), Matchers.<VDSParametersBase>any(VDSParametersBase.class))).thenReturn(returnValue);
}
#end_block

#method_before
private void mockConfig() {
    mcr.mockConfigValue(ConfigValues.PredefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.UserDefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.InitStorageSparseSizeInGB, 1);
}
#method_after
private void mockConfig() {
    mcr.mockConfigValue(ConfigValues.PredefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.UserDefinedVMProperties, Version.v3_0, "");
    mcr.mockConfigValue(ConfigValues.InitStorageSparseSizeInGB, 1);
    mcr.mockConfigValue(ConfigValues.VirtIoScsiEnabled, Version.v3_3, true);
}
#end_block

#method_before
private static VM createVm() {
    VM vm = new VM();
    VmDynamic dynamic = new VmDynamic();
    VmStatic stat = new VmStatic();
    stat.setVmtGuid(Guid.NewGuid());
    stat.setName("testVm");
    stat.setPriority(1);
    vm.setStaticData(stat);
    vm.setDynamicData(dynamic);
    return vm;
}
#method_after
private static VM createVm() {
    VM vm = new VM();
    VmDynamic dynamic = new VmDynamic();
    VmStatic stat = new VmStatic();
    stat.setVmtGuid(Guid.newGuid());
    stat.setName("testVm");
    stat.setPriority(1);
    vm.setStaticData(stat);
    vm.setDynamicData(dynamic);
    vm.setSingleQxlPci(false);
    return vm;
}
#end_block

#method_before
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = new AddVmCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        protected int getNeededDiskSize(Guid domainId) {
            return getBlockSparseInitSizeInGb() * getVmTemplate().getDiskMap().size();
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    return cmd;
}
#method_after
private AddVmCommand<VmManagementParametersBase> createCommand(VM vm) {
    VmManagementParametersBase param = new VmManagementParametersBase(vm);
    AddVmCommand<VmManagementParametersBase> cmd = new AddVmCommand<VmManagementParametersBase>(param) {

        @Override
        protected void initTemplateDisks() {
        // Stub for testing
        }

        @Override
        protected void initStoragePoolId() {
        // stub for testing
        }

        @Override
        protected int getNeededDiskSize(Guid domainId) {
            return getBlockSparseInitSizeInGb() * getVmTemplate().getDiskTemplateMap().size();
        }

        @Override
        public VmTemplate getVmTemplate() {
            return createVmTemplate();
        }
    };
    cmd = spy(cmd);
    mockDAOs(cmd);
    mockBackend(cmd);
    return cmd;
}
#end_block

#method_before
private <T extends VmManagementParametersBase> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    spy.setVmTemplateId(Guid.NewGuid());
}
#method_after
private <T extends VmManagementParametersBase> void mockUninterestingMethods(AddVmCommand<T> spy) {
    doReturn(true).when(spy).isVmNameValidLength(Matchers.<VM>any(VM.class));
    doReturn(false).when(spy).isVmWithSameNameExists(anyString());
    doReturn(STORAGE_POOL_ID).when(spy).getStoragePoolId();
    doReturn(createVmTemplate()).when(spy).getVmTemplate();
    doReturn(createVdsGroup()).when(spy).getVdsGroup();
    doReturn(true).when(spy).areParametersLegal(anyListOf(String.class));
    doReturn(Collections.<VmNetworkInterface>emptyList()).when(spy).getVmInterfaces();
    doReturn(Collections.<DiskImageBase>emptyList()).when(spy).getVmDisks();
    doReturn(false).when(spy).isVirtioScsiControllerAttached(any(Guid.class));
    spy.setVmTemplateId(Guid.newGuid());
}
#end_block

#method_before
protected InstanceType getInstanceType() {
    if (instanceType == null && instanceTypeId != null) {
        instanceType = getVmTemplateDAO().getInstanceType(instanceTypeId.getValue());
    }
    return instanceType;
}
#method_after
protected InstanceType getInstanceType() {
    if (instanceType == null && instanceTypeId != null) {
        instanceType = getVmTemplateDAO().getInstanceType(instanceTypeId);
    }
    return instanceType;
}
#end_block

#method_before
protected ImageType getImageType() {
    if (imageType == null && imageTypeId != null) {
        imageType = getVmTemplateDAO().getImageType(imageTypeId.getValue());
    }
    return imageType;
}
#method_after
protected ImageType getImageType() {
    if (imageType == null && imageTypeId != null) {
        imageType = getVmTemplateDAO().getImageType(imageTypeId);
    }
    return imageType;
}
#end_block

#method_before
protected void initStoragePoolId() {
    if (getVdsGroup() != null) {
        setStoragePoolId(getVdsGroup().getStoragePoolId() != null ? getVdsGroup().getStoragePoolId().getValue() : Guid.Empty);
    }
}
#method_after
protected void initStoragePoolId() {
    if (getVdsGroup() != null) {
        setStoragePoolId(getVdsGroup().getStoragePoolId() != null ? getVdsGroup().getStoragePoolId() : Guid.Empty);
    }
}
#end_block

#method_before
protected List<VmNetworkInterface> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNetworkInterface> vmNetworkInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(vmInterfacesSourceId);
        _vmInterfaces = (vmNetworkInterfaces != null) ? vmNetworkInterfaces : new ArrayList<VmNetworkInterface>();
    }
    return _vmInterfaces;
}
#method_after
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNic> vmNetworkInterfaces = getVmNicDao().getAllForTemplate(vmInterfacesSourceId);
        _vmInterfaces = vmNetworkInterfaces == null ? new ArrayList<VmNic>() : vmNetworkInterfaces;
    }
    return _vmInterfaces;
}
#end_block

#method_before
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId().getValue(), vmStaticFromParams.getPriority());
    if (returnValue) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (StorageDomain domain : destStorages) {
                StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
                if (!validate(storageDomainValidator.isDomainWithinThresholds()) || !validate(storageDomainValidator.isDomainHasSpaceForRequest(getNeededDiskSize(domain.getId())))) {
                    return false;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#method_after
protected boolean canAddVm(ArrayList<String> reasons, Collection<StorageDomain> destStorages) {
    VmStatic vmStaticFromParams = getParameters().getVmStaticData();
    boolean returnValue = canAddVm(reasons, vmStaticFromParams.getName(), getStoragePoolId(), vmStaticFromParams.getPriority());
    if (returnValue) {
        List<ValidationError> validationErrors = validateCustomProperties(vmStaticFromParams);
        if (!validationErrors.isEmpty()) {
            VmPropertiesUtils.getInstance().handleCustomPropertiesError(validationErrors, reasons);
            returnValue = false;
        }
    }
    // check that template image and vm are on the same storage pool
    if (returnValue && shouldCheckSpaceInStorageDomains()) {
        if (!getStoragePoolId().equals(getStoragePoolIdFromSourceImageContainer())) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_POOL_NOT_MATCH.toString());
            returnValue = false;
        } else {
            for (StorageDomain domain : destStorages) {
                StorageDomainValidator storageDomainValidator = new StorageDomainValidator(domain);
                if (!validate(storageDomainValidator.isDomainExistAndActive())) {
                    return false;
                }
                if (!validate(storageDomainValidator.isDomainWithinThresholds()) || !validate(storageDomainValidator.isDomainHasSpaceForRequest(getNeededDiskSize(domain.getId())))) {
                    return false;
                }
            }
        }
    }
    if (returnValue) {
        returnValue = isDedicatedVdsOnSameCluster(vmStaticFromParams);
    }
    return returnValue;
}
#end_block

#method_before
protected Guid getStoragePoolIdFromSourceImageContainer() {
    return vmDisksSource.getStoragePoolId().getValue();
}
#method_after
protected Guid getStoragePoolIdFromSourceImageContainer() {
    return vmDisksSource.getStoragePoolId();
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.CheckCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, String compatibility_version, List<String> CanDoActionMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket) > Config.<Integer>GetValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>GetValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>GetValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean returnValue = true;
    if (getVmTemplate() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    returnValue = buildAndCheckDestStorageDomains();
    if (returnValue) {
        storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
        returnValue = canDoAddVmCommand();
    }
    String vmName = getParameters().getVm().getName();
    if (vmName == null || vmName.isEmpty()) {
        returnValue = false;
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    } else {
        // check that VM name is not too long
        boolean vmNameValidLength = isVmNameValidLength(getParameters().getVm());
        if (!vmNameValidLength) {
            returnValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
        }
    }
    // check for Vm Payload
    if (returnValue && getParameters().getVmPayload() != null) {
        returnValue = checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath());
        if (returnValue) {
            // we save the content in base64 string
            getParameters().getVmPayload().setContent(Base64.encodeBase64String(getParameters().getVmPayload().getContent().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        returnValue = false;
    }
    // check cpuPinning if the check haven't failed yet
    if (returnValue) {
        VM vmFromParams = getParameters().getVm();
        returnValue = isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData());
    }
    if (getParameters().getVm().isUseHostCpuFlags() && getParameters().getVm().getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (returnValue && instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (returnValue && imageTypeId != null && getImageType() == null) {
        // invalid image type
        failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    return returnValue && checkCpuSockets();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (instanceTypeId != null && getInstanceType() == null) {
        // invalid instance type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_INSTANCE_TYPE_DOES_NOT_EXIST);
    }
    if (imageTypeId != null && getImageType() == null) {
        // invalid image type
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_TYPE_DOES_NOT_EXIST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.CheckCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkCpuSockets() {
    return AddVmCommand.checkCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected Collection<DiskImage> getImagesToCheckDestinationStorageDomains() {
    return vmDisksSource.getDiskMap().values();
}
#method_after
protected Collection<DiskImage> getImagesToCheckDestinationStorageDomains() {
    return vmDisksSource.getDiskTemplateMap().values();
}
#end_block

#method_before
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(vmDisksSource, getStorageDomainDAO().getAllForStoragePool(vmDisksSource.getStoragePoolId().getValue()), diskInfoDestinationMap, destStorages, false);
}
#method_after
protected void fillImagesMapBasedOnTemplate() {
    ImagesHandler.fillImagesMapBasedOnTemplate(vmDisksSource, getStorageDomainDAO().getAllForStoragePool(vmDisksSource.getStoragePoolId()), diskInfoDestinationMap, destStorages, false);
}
#end_block

#method_before
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    boolean returnValue;
    // Checking if a desktop with same name already exists
    boolean exists = (Boolean) getBackend().runInternalQuery(VdcQueryType.IsVmWithSameNameExist, new IsVmWithSameNameExistParameters(name)).getReturnValue();
    if (exists) {
        if (reasons != null) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED.toString());
        }
        return false;
    }
    boolean checkTemplateLock = getParameters().getParentCommand() == VdcActionType.AddVmPoolWithVms ? false : true;
    returnValue = verifyAddVM(reasons, vmPriority);
    if (returnValue && !getParameters().getDontCheckTemplateImages()) {
        for (StorageDomain storage : destStorages.values()) {
            if (!VmTemplateCommand.isVmTemplateImagesReady(vmDisksSource, storage.getId(), reasons, false, checkTemplateLock, true, true, storageToDisksMap.get(storage.getId()))) {
                return false;
            }
        }
    }
    return returnValue;
}
#method_after
protected boolean canAddVm(List<String> reasons, String name, Guid storagePoolId, int vmPriority) {
    // Checking if a desktop with same name already exists
    if (isVmWithSameNameExists(name)) {
        reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED.name());
        return false;
    }
    if (!verifyAddVM(reasons, vmPriority)) {
        return false;
    }
    if (!checkTemplateImages(reasons)) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.VerifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#method_after
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions(newDiskImages);
                    // these devices can't be changed if using instance type
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    if (getInstanceType() == null) {
                        addVmPayload();
                        updateSmartCardDevices();
                        addVmWatchdog();
                    }
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.NewGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getType(), payload.getSpecParams(), true, true, null);
    }
}
#method_after
protected void addVmPayload() {
    VmPayload payload = getParameters().getVmPayload();
    if (payload != null) {
        VmDeviceUtils.addManagedDevice(new VmDeviceId(Guid.newGuid(), getParameters().getVmId()), VmDeviceGeneralType.DISK, payload.getType(), payload.getSpecParams(), true, true, null);
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), newDiskImages, _vmInterfaces);
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(vmDevicesSourceId, getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled());
}
#end_block

#method_before
protected boolean areParametersLegal(List<String> reasons) {
    boolean returnValue = false;
    final VmStatic vmStaticData = getParameters().getVmStaticData();
    if (vmStaticData != null) {
        returnValue = vmStaticData.getMigrationSupport() != MigrationSupport.PINNED_TO_HOST || !vmStaticData.isAutoStartup();
        if (!returnValue) {
            reasons.add(VdcBllMessages.ACTION_TYPE_FAILED_VM_CANNOT_BE_HIGHLY_AVAILABLE_AND_PINNED_TO_HOST.toString());
        }
        if (!returnValue) {
            returnValue = returnValue && IsLegalClusterId(vmStaticData.getVdsGroupId(), reasons);
        }
        if (!validatePinningAndMigration(reasons, vmStaticData, getParameters().getVm().getCpuPinning())) {
            returnValue = false;
        }
        returnValue = returnValue && VmHandler.isMemorySizeLegal(vmStaticData.getOs(), vmStaticData.getMemSizeMb(), reasons, getVdsGroup().getcompatibility_version().toString());
    }
    return returnValue;
}
#method_after
protected boolean areParametersLegal(List<String> reasons) {
    boolean returnValue = false;
    final VmStatic vmStaticData = getParameters().getVmStaticData();
    if (vmStaticData != null) {
        returnValue = isLegalClusterId(vmStaticData.getVdsGroupId(), reasons);
        if (!validatePinningAndMigration(reasons, vmStaticData, getParameters().getVm().getCpuPinning())) {
            returnValue = false;
        }
        returnValue = returnValue && VmHandler.isMemorySizeLegal(vmStaticData.getOsId(), vmStaticData.getMemSizeMb(), reasons, getVdsGroup().getcompatibility_version());
    }
    return returnValue;
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNetworkInterface iface : getVmInterfaces()) {
        iface.setId(Guid.NewGuid());
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#method_after
protected void addVmStatic() {
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (vmStatic.getOrigin() == null) {
        vmStatic.setOrigin(OriginType.valueOf(Config.<String>GetValue(ConfigValues.OriginType)));
    }
    vmStatic.setId(getVmId());
    vmStatic.setQuotaId(getQuotaId());
    vmStatic.setCreationDate(new Date());
    vmStatic.setCreatedByUserId(getUserId());
    // predefined and user defined fields
    if (vmStatic.getCustomProperties() != null) {
        VMCustomProperties properties = VmPropertiesUtils.getInstance().parseProperties(getVdsGroupDAO().get(getParameters().getVm().getVdsGroupId()).getcompatibility_version(), vmStatic.getCustomProperties());
        String predefinedProperties = properties.getPredefinedProperties();
        String userDefinedProperties = properties.getUseDefinedProperties();
        vmStatic.setPredefinedProperties(predefinedProperties);
        vmStatic.setUserDefinedProperties(userDefinedProperties);
    }
    getVmStaticDao().save(vmStatic);
    getCompensationContext().snapshotNewEntity(vmStatic);
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (vmDisksSource.getDiskMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityId(getParameters().getEntityId());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalTaskIdList());
                newDiskImages.add((DiskImage) result.getActionReturnValue());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (vmDisksSource.getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? (getReturnValue().getTaskIdList().size() > 0 ? AuditLogType.USER_ADD_VM_STARTED : AuditLogType.USER_ADD_VM) : AuditLogType.USER_FAILED_ADD_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            return getSucceeded() ? (getReturnValue().getVdsmTaskIdList().size() > 0 ? AuditLogType.USER_ADD_VM_STARTED : AuditLogType.USER_ADD_VM) : AuditLogType.USER_FAILED_ADD_VM;
        case END_SUCCESS:
            return getSucceeded() ? AuditLogType.USER_ADD_VM_FINISHED_SUCCESS : AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
        default:
            return AuditLogType.USER_ADD_VM_FINISHED_FAILURE;
    }
}
#end_block

#method_before
protected void removeVmRelatedEntitiesFromDb() {
    removeVmUsers();
    removeVmNetwork();
    new SnapshotsManager().removeSnapshots(getVmId());
    removeVmStatic();
}
#method_after
protected void removeVmRelatedEntitiesFromDb() {
    removeVmUsers();
    removeVmNetwork();
    // Note that currently newly added vm never have memory state
    // In case it will be changed (clone vm from snapshot will clone the memory state),
    // we'll need to remove the memory state images here as well.
    removeVmSnapshots();
    removeVmStatic();
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        for (DiskImage disk : getParameters().getDiskInfoDestinationMap().values()) {
            if (disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                permissionList.add(new PermissionSubject(GuidUtils.getGuidValue(disk.getStorageIds().get(0)), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
            }
        }
    }
    // if using instance type, need create instance
    if (getInstanceType() != null) {
        permissionList.add(new PermissionSubject(instanceTypeId.getValue(), VdcObjectType.VmTemplate, ActionGroup.CREATE_INSTANCE));
    }
    // if using image type, need create instance
    if (getImageType() != null) {
        permissionList.add(new PermissionSubject(imageTypeId.getValue(), VdcObjectType.VmTemplate, ActionGroup.CREATE_INSTANCE));
    }
    addPermissionSubjectForAdminLevelProperties(permissionList);
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(getVdsGroupId(), VdcObjectType.VdsGroups, getActionType().getActionGroup()));
    permissionList.add(new PermissionSubject(getVmTemplateId(), VdcObjectType.VmTemplate, getActionType().getActionGroup()));
    if (getVmTemplate() != null && !getVmTemplate().getDiskList().isEmpty()) {
        for (DiskImage disk : getParameters().getDiskInfoDestinationMap().values()) {
            if (disk.getStorageIds() != null && !disk.getStorageIds().isEmpty()) {
                permissionList.add(new PermissionSubject(disk.getStorageIds().get(0), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
            }
        }
    }
    // if using instance type, need create instance
    if (getInstanceType() != null) {
        permissionList.add(new PermissionSubject(instanceTypeId, VdcObjectType.VmTemplate, ActionGroup.CREATE_INSTANCE));
    }
    // if using image type, need create instance
    if (getImageType() != null) {
        permissionList.add(new PermissionSubject(imageTypeId, VdcObjectType.VmTemplate, ActionGroup.CREATE_INSTANCE));
    }
    addPermissionSubjectForAdminLevelProperties(permissionList);
    return permissionList;
}
#end_block

#method_before
protected void addVmPermission() {
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissions perms = new permissions(getCurrentUser().getUserId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
        MultiLevelAdministrationHandler.addPermission(perms);
        getCompensationContext().snapshotNewEntity(perms);
    }
}
#method_after
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#end_block

#method_before
protected void addDiskPermissions(List<DiskImage> newDiskImages) {
    permissions[] permsArray = new permissions[newDiskImages.size()];
    for (int i = 0; i < newDiskImages.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getUserId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImages.get(i).getId(), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    permissions[] permsArray = new permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
protected void addActiveSnapshot() {
    _vmSnapshotId = Guid.NewGuid();
    new SnapshotsManager().addActiveSnapshot(_vmSnapshotId, getVm(), getCompensationContext());
}
#method_after
protected void addActiveSnapshot() {
    _vmSnapshotId = Guid.newGuid();
    new SnapshotsManager().addActiveSnapshot(_vmSnapshotId, getVm(), getCompensationContext());
}
#end_block

#method_before
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // TODO: this handle sound card, will be available soon
        // use sound card only if instance type has it
        // List<VmDevice> list =
        // getVmDeviceDao()
        // .getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceType.SOUND.getName());
        // getParameters().setSoundDeviceEnabled(!list.isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOs(imageType.getOs());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
}
#method_after
private void updateVmObject() {
    InstanceType instanceType = getInstanceType();
    VmStatic vmStatic = getParameters().getVmStaticData();
    if (instanceType != null) {
        vmStatic.setMemSizeMb(instanceType.getMemSizeMb());
        vmStatic.setNumOfSockets(instanceType.getNumOfSockets());
        vmStatic.setCpuPerSocket(instanceType.getCpuPerSocket());
        vmStatic.setDefaultBootSequence(instanceType.getDefaultBootSequence());
        vmStatic.setDefaultDisplayType(instanceType.getDefaultDisplayType());
        vmStatic.setPriority(instanceType.getPriority());
        vmStatic.setMinAllocatedMem(instanceType.getMinAllocatedMem());
        vmStatic.setTunnelMigration(instanceType.getTunnelMigration());
        // use sound card only if instance type has it
        getParameters().setSoundDeviceEnabled(!getVmDeviceDao().getVmDeviceByVmIdAndType(instanceType.getId(), VmDeviceGeneralType.SOUND).isEmpty());
        // set vm interface source id to be the instance type, vm interface are taken from it
        vmInterfacesSourceId = instanceType.getId();
    }
    ImageType imageType = getImageType();
    if (imageType != null) {
        vmStatic.setOsId(imageType.getOsId());
        vmStatic.setIsoPath(imageType.getIsoPath());
        vmStatic.setInitrdUrl(imageType.getInitrdUrl());
        vmStatic.setKernelUrl(imageType.getKernelUrl());
        vmStatic.setKernelParams(imageType.getKernelParams());
        // set vm disks source to be the image type, vm disks are taken from it
        vmDisksSource = (VmTemplate) imageType;
    }
}
#end_block

#method_before
public TemplateType getTemplateType() {
    return templateType;
}
#method_after
public VmEntityType getTemplateType() {
    return templateType;
}
#end_block

#method_before
public void setTemplateType(TemplateType templateType) {
    this.templateType = templateType;
}
#method_after
public void setTemplateType(VmEntityType templateType) {
    this.templateType = templateType;
}
#end_block

#method_before
@Mapping(from = ActionGroup.class, to = PermitType.class)
public static PermitType map(ActionGroup entity, PermitType template) {
    switch(entity) {
        case CREATE_VM:
            return PermitType.CREATE_VM;
        case DELETE_VM:
            return PermitType.DELETE_VM;
        case EDIT_VM_PROPERTIES:
            return PermitType.EDIT_VM_PROPERTIES;
        case VM_BASIC_OPERATIONS:
            return PermitType.VM_BASIC_OPERATIONS;
        case CHANGE_VM_CD:
            return PermitType.CHANGE_VM_CD;
        case MIGRATE_VM:
            return PermitType.MIGRATE_VM;
        case CONNECT_TO_VM:
            return PermitType.CONNECT_TO_VM;
        case IMPORT_EXPORT_VM:
            return PermitType.IMPORT_EXPORT_VM;
        case CONFIGURE_VM_NETWORK:
            return PermitType.CONFIGURE_VM_NETWORK;
        case CONFIGURE_VM_STORAGE:
            return PermitType.CONFIGURE_VM_STORAGE;
        case MOVE_VM:
            return PermitType.MOVE_VM;
        case MANIPULATE_VM_SNAPSHOTS:
            return PermitType.MANIPULATE_VM_SNAPSHOTS;
        case RECONNECT_TO_VM:
            return PermitType.RECONNECT_TO_VM;
        case CHANGE_VM_CUSTOM_PROPERTIES:
            return PermitType.CHANGE_VM_CUSTOM_PROPERTIES;
        case EDIT_ADMIN_VM_PROPERTIES:
            return PermitType.EDIT_ADMIN_VM_PROPERTIES;
        case CREATE_INSTANCE:
            return PermitType.CREATE_INSTANCE;
        case CREATE_HOST:
            return PermitType.CREATE_HOST;
        case EDIT_HOST_CONFIGURATION:
            return PermitType.EDIT_HOST_CONFIGURATION;
        case DELETE_HOST:
            return PermitType.DELETE_HOST;
        case MANIPUTLATE_HOST:
            return PermitType.MANIPUTLATE_HOST;
        case CONFIGURE_HOST_NETWORK:
            return PermitType.CONFIGURE_HOST_NETWORK;
        case CREATE_TEMPLATE:
            return PermitType.CREATE_TEMPLATE;
        case EDIT_TEMPLATE_PROPERTIES:
            return PermitType.EDIT_TEMPLATE_PROPERTIES;
        case EDIT_ADMIN_TEMPLATE_PROPERTIES:
            return PermitType.EDIT_ADMIN_TEMPLATE_PROPERTIES;
        case DELETE_TEMPLATE:
            return PermitType.DELETE_TEMPLATE;
        case COPY_TEMPLATE:
            return PermitType.COPY_TEMPLATE;
        case CONFIGURE_TEMPLATE_NETWORK:
            return PermitType.CONFIGURE_TEMPLATE_NETWORK;
        case CREATE_VM_POOL:
            return PermitType.CREATE_VM_POOL;
        case EDIT_VM_POOL_CONFIGURATION:
            return PermitType.EDIT_VM_POOL_CONFIGURATION;
        case DELETE_VM_POOL:
            return PermitType.DELETE_VM_POOL;
        case VM_POOL_BASIC_OPERATIONS:
            return PermitType.VM_POOL_BASIC_OPERATIONS;
        case CREATE_CLUSTER:
            return PermitType.CREATE_CLUSTER;
        case EDIT_CLUSTER_CONFIGURATION:
            return PermitType.EDIT_CLUSTER_CONFIGURATION;
        case DELETE_CLUSTER:
            return PermitType.DELETE_CLUSTER;
        case CONFIGURE_CLUSTER_NETWORK:
            return PermitType.CONFIGURE_CLUSTER_NETWORK;
        case MANIPULATE_USERS:
            return PermitType.MANIPULATE_USERS;
        case MANIPULATE_ROLES:
            return PermitType.MANIPULATE_ROLES;
        case MANIPULATE_PERMISSIONS:
            return PermitType.MANIPULATE_PERMISSIONS;
        case CREATE_STORAGE_DOMAIN:
            return PermitType.CREATE_STORAGE_DOMAIN;
        case EDIT_STORAGE_DOMAIN_CONFIGURATION:
            return PermitType.EDIT_STORAGE_DOMAIN_CONFIGURATION;
        case DELETE_STORAGE_DOMAIN:
            return PermitType.DELETE_STORAGE_DOMAIN;
        case MANIPULATE_STORAGE_DOMAIN:
            return PermitType.MANIPULATE_STORAGE_DOMAIN;
        case CREATE_STORAGE_POOL:
            return PermitType.CREATE_STORAGE_POOL;
        case DELETE_STORAGE_POOL:
            return PermitType.DELETE_STORAGE_POOL;
        case EDIT_STORAGE_POOL_CONFIGURATION:
            return PermitType.EDIT_STORAGE_POOL_CONFIGURATION;
        case CONFIGURE_STORAGE_POOL_NETWORK:
            return PermitType.CONFIGURE_STORAGE_POOL_NETWORK;
        case CREATE_STORAGE_POOL_NETWORK:
            return PermitType.CREATE_STORAGE_POOL_NETWORK;
        case DELETE_STORAGE_POOL_NETWORK:
            return PermitType.DELETE_STORAGE_POOL_NETWORK;
        case ASSIGN_CLUSTER_NETWORK:
            return PermitType.ASSIGN_CLUSTER_NETWORK;
        case CONFIGURE_ENGINE:
            return PermitType.CONFIGURE_RHEVM;
        case CONFIGURE_QUOTA:
            return PermitType.CONFIGURE_QUOTA;
        case CONSUME_QUOTA:
            return PermitType.CONSUME_QUOTA;
        case CREATE_GLUSTER_VOLUME:
            return PermitType.CREATE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_VOLUME:
            return PermitType.MANIPULATE_GLUSTER_VOLUME;
        case DELETE_GLUSTER_VOLUME:
            return PermitType.DELETE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_HOOK:
            return PermitType.MANIPULATE_GLUSTER_HOOK;
        case CREATE_DISK:
            return PermitType.CREATE_DISK;
        case ATTACH_DISK:
            return PermitType.ATTACH_DISK;
        case EDIT_DISK_PROPERTIES:
            return PermitType.EDIT_DISK_PROPERTIES;
        case CONFIGURE_DISK_STORAGE:
            return PermitType.CONFIGURE_DISK_STORAGE;
        case DELETE_DISK:
            return PermitType.DELETE_DISK;
        case PORT_MIRRORING:
            return PermitType.PORT_MIRRORING;
        case LOGIN:
            return PermitType.LOGIN;
        case INJECT_EXTERNAL_EVENTS:
            return PermitType.INJECT_EXTERNAL_EVENTS;
        case MANIPULATE_GLUSTER_SERVICE:
            return PermitType.MANIPULATE_GLUSTER_SERVICE;
        default:
            return null;
    }
}
#method_after
@Mapping(from = ActionGroup.class, to = PermitType.class)
public static PermitType map(ActionGroup entity, PermitType template) {
    switch(entity) {
        case CREATE_VM:
            return PermitType.CREATE_VM;
        case DELETE_VM:
            return PermitType.DELETE_VM;
        case EDIT_VM_PROPERTIES:
            return PermitType.EDIT_VM_PROPERTIES;
        case VM_BASIC_OPERATIONS:
            return PermitType.VM_BASIC_OPERATIONS;
        case CHANGE_VM_CD:
            return PermitType.CHANGE_VM_CD;
        case MIGRATE_VM:
            return PermitType.MIGRATE_VM;
        case CONNECT_TO_VM:
            return PermitType.CONNECT_TO_VM;
        case IMPORT_EXPORT_VM:
            return PermitType.IMPORT_EXPORT_VM;
        case CONFIGURE_VM_NETWORK:
            return PermitType.CONFIGURE_VM_NETWORK;
        case CONFIGURE_VM_STORAGE:
            return PermitType.CONFIGURE_VM_STORAGE;
        case MOVE_VM:
            return PermitType.MOVE_VM;
        case MANIPULATE_VM_SNAPSHOTS:
            return PermitType.MANIPULATE_VM_SNAPSHOTS;
        case RECONNECT_TO_VM:
            return PermitType.RECONNECT_TO_VM;
        case CHANGE_VM_CUSTOM_PROPERTIES:
            return PermitType.CHANGE_VM_CUSTOM_PROPERTIES;
        case EDIT_ADMIN_VM_PROPERTIES:
            return PermitType.EDIT_ADMIN_VM_PROPERTIES;
        case CREATE_INSTANCE:
            return PermitType.CREATE_INSTANCE;
        case CREATE_HOST:
            return PermitType.CREATE_HOST;
        case EDIT_HOST_CONFIGURATION:
            return PermitType.EDIT_HOST_CONFIGURATION;
        case DELETE_HOST:
            return PermitType.DELETE_HOST;
        case MANIPUTLATE_HOST:
            return PermitType.MANIPUTLATE_HOST;
        case CONFIGURE_HOST_NETWORK:
            return PermitType.CONFIGURE_HOST_NETWORK;
        case CREATE_TEMPLATE:
            return PermitType.CREATE_TEMPLATE;
        case EDIT_TEMPLATE_PROPERTIES:
            return PermitType.EDIT_TEMPLATE_PROPERTIES;
        case EDIT_ADMIN_TEMPLATE_PROPERTIES:
            return PermitType.EDIT_ADMIN_TEMPLATE_PROPERTIES;
        case DELETE_TEMPLATE:
            return PermitType.DELETE_TEMPLATE;
        case COPY_TEMPLATE:
            return PermitType.COPY_TEMPLATE;
        case CONFIGURE_TEMPLATE_NETWORK:
            return PermitType.CONFIGURE_TEMPLATE_NETWORK;
        case CREATE_VM_POOL:
            return PermitType.CREATE_VM_POOL;
        case EDIT_VM_POOL_CONFIGURATION:
            return PermitType.EDIT_VM_POOL_CONFIGURATION;
        case DELETE_VM_POOL:
            return PermitType.DELETE_VM_POOL;
        case VM_POOL_BASIC_OPERATIONS:
            return PermitType.VM_POOL_BASIC_OPERATIONS;
        case CREATE_CLUSTER:
            return PermitType.CREATE_CLUSTER;
        case EDIT_CLUSTER_CONFIGURATION:
            return PermitType.EDIT_CLUSTER_CONFIGURATION;
        case DELETE_CLUSTER:
            return PermitType.DELETE_CLUSTER;
        case CONFIGURE_CLUSTER_NETWORK:
            return PermitType.CONFIGURE_CLUSTER_NETWORK;
        case MANIPULATE_USERS:
            return PermitType.MANIPULATE_USERS;
        case MANIPULATE_ROLES:
            return PermitType.MANIPULATE_ROLES;
        case MANIPULATE_PERMISSIONS:
            return PermitType.MANIPULATE_PERMISSIONS;
        case CREATE_STORAGE_DOMAIN:
            return PermitType.CREATE_STORAGE_DOMAIN;
        case EDIT_STORAGE_DOMAIN_CONFIGURATION:
            return PermitType.EDIT_STORAGE_DOMAIN_CONFIGURATION;
        case DELETE_STORAGE_DOMAIN:
            return PermitType.DELETE_STORAGE_DOMAIN;
        case MANIPULATE_STORAGE_DOMAIN:
            return PermitType.MANIPULATE_STORAGE_DOMAIN;
        case CREATE_STORAGE_POOL:
            return PermitType.CREATE_STORAGE_POOL;
        case DELETE_STORAGE_POOL:
            return PermitType.DELETE_STORAGE_POOL;
        case EDIT_STORAGE_POOL_CONFIGURATION:
            return PermitType.EDIT_STORAGE_POOL_CONFIGURATION;
        case CONFIGURE_STORAGE_POOL_NETWORK:
            return PermitType.CONFIGURE_STORAGE_POOL_NETWORK;
        case CREATE_STORAGE_POOL_NETWORK:
            return PermitType.CREATE_STORAGE_POOL_NETWORK;
        case DELETE_STORAGE_POOL_NETWORK:
            return PermitType.DELETE_STORAGE_POOL_NETWORK;
        case ASSIGN_CLUSTER_NETWORK:
            return PermitType.ASSIGN_CLUSTER_NETWORK;
        case CONFIGURE_ENGINE:
            return PermitType.CONFIGURE_RHEVM;
        case CONFIGURE_QUOTA:
            return PermitType.CONFIGURE_QUOTA;
        case CONSUME_QUOTA:
            return PermitType.CONSUME_QUOTA;
        case CREATE_GLUSTER_VOLUME:
            return PermitType.CREATE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_VOLUME:
            return PermitType.MANIPULATE_GLUSTER_VOLUME;
        case DELETE_GLUSTER_VOLUME:
            return PermitType.DELETE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_HOOK:
            return PermitType.MANIPULATE_GLUSTER_HOOK;
        case CREATE_DISK:
            return PermitType.CREATE_DISK;
        case ATTACH_DISK:
            return PermitType.ATTACH_DISK;
        case EDIT_DISK_PROPERTIES:
            return PermitType.EDIT_DISK_PROPERTIES;
        case CONFIGURE_DISK_STORAGE:
            return PermitType.CONFIGURE_DISK_STORAGE;
        case DELETE_DISK:
            return PermitType.DELETE_DISK;
        case CONFIGURE_NETWORK_VNIC_PROFILE:
            return PermitType.CONFIGURE_NETWORK_VNIC_PROFILE;
        case CREATE_NETWORK_VNIC_PROFILE:
            return PermitType.CREATE_NETWORK_VNIC_PROFILE;
        case DELETE_NETWORK_VNIC_PROFILE:
            return PermitType.DELETE_NETWORK_VNIC_PROFILE;
        case LOGIN:
            return PermitType.LOGIN;
        case INJECT_EXTERNAL_EVENTS:
            return PermitType.INJECT_EXTERNAL_EVENTS;
        case MANIPULATE_GLUSTER_SERVICE:
            return PermitType.MANIPULATE_GLUSTER_SERVICE;
        case CONFIGURE_SCSI_GENERIC_IO:
            return PermitType.CONFIGURE_SCSI_GENERIC_IO;
        case INJECT_EXTERNAL_TASKS:
            return PermitType.INJECT_EXTERNAL_TASKS;
        case ACCESS_IMAGE_STORAGE:
            return PermitType.ACCESS_IMAGE_STORAGE;
        default:
            return null;
    }
}
#end_block

#method_before
@Mapping(from = PermitType.class, to = ActionGroup.class)
public static ActionGroup map(PermitType entity, ActionGroup template) {
    switch(entity) {
        case CREATE_VM:
            return ActionGroup.CREATE_VM;
        case DELETE_VM:
            return ActionGroup.DELETE_VM;
        case EDIT_VM_PROPERTIES:
            return ActionGroup.EDIT_VM_PROPERTIES;
        case VM_BASIC_OPERATIONS:
            return ActionGroup.VM_BASIC_OPERATIONS;
        case CHANGE_VM_CD:
            return ActionGroup.CHANGE_VM_CD;
        case MIGRATE_VM:
            return ActionGroup.MIGRATE_VM;
        case CONNECT_TO_VM:
            return ActionGroup.CONNECT_TO_VM;
        case IMPORT_EXPORT_VM:
            return ActionGroup.IMPORT_EXPORT_VM;
        case CONFIGURE_VM_NETWORK:
            return ActionGroup.CONFIGURE_VM_NETWORK;
        case CONFIGURE_VM_STORAGE:
            return ActionGroup.CONFIGURE_VM_STORAGE;
        case MOVE_VM:
            return ActionGroup.MOVE_VM;
        case MANIPULATE_VM_SNAPSHOTS:
            return ActionGroup.MANIPULATE_VM_SNAPSHOTS;
        case RECONNECT_TO_VM:
            return ActionGroup.RECONNECT_TO_VM;
        case CHANGE_VM_CUSTOM_PROPERTIES:
            return ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES;
        case EDIT_ADMIN_VM_PROPERTIES:
            return ActionGroup.EDIT_ADMIN_VM_PROPERTIES;
        case CREATE_INSTANCE:
            return ActionGroup.CREATE_INSTANCE;
        case CREATE_HOST:
            return ActionGroup.CREATE_HOST;
        case EDIT_HOST_CONFIGURATION:
            return ActionGroup.EDIT_HOST_CONFIGURATION;
        case DELETE_HOST:
            return ActionGroup.DELETE_HOST;
        case MANIPUTLATE_HOST:
            return ActionGroup.MANIPUTLATE_HOST;
        case CONFIGURE_HOST_NETWORK:
            return ActionGroup.CONFIGURE_HOST_NETWORK;
        case CREATE_TEMPLATE:
            return ActionGroup.CREATE_TEMPLATE;
        case EDIT_TEMPLATE_PROPERTIES:
            return ActionGroup.EDIT_TEMPLATE_PROPERTIES;
        case EDIT_ADMIN_TEMPLATE_PROPERTIES:
            return ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES;
        case DELETE_TEMPLATE:
            return ActionGroup.DELETE_TEMPLATE;
        case COPY_TEMPLATE:
            return ActionGroup.COPY_TEMPLATE;
        case CONFIGURE_TEMPLATE_NETWORK:
            return ActionGroup.CONFIGURE_TEMPLATE_NETWORK;
        case CREATE_VM_POOL:
            return ActionGroup.CREATE_VM_POOL;
        case EDIT_VM_POOL_CONFIGURATION:
            return ActionGroup.EDIT_VM_POOL_CONFIGURATION;
        case DELETE_VM_POOL:
            return ActionGroup.DELETE_VM_POOL;
        case VM_POOL_BASIC_OPERATIONS:
            return ActionGroup.VM_POOL_BASIC_OPERATIONS;
        case CREATE_CLUSTER:
            return ActionGroup.CREATE_CLUSTER;
        case EDIT_CLUSTER_CONFIGURATION:
            return ActionGroup.EDIT_CLUSTER_CONFIGURATION;
        case DELETE_CLUSTER:
            return ActionGroup.DELETE_CLUSTER;
        case CONFIGURE_CLUSTER_NETWORK:
            return ActionGroup.CONFIGURE_CLUSTER_NETWORK;
        case MANIPULATE_USERS:
            return ActionGroup.MANIPULATE_USERS;
        case MANIPULATE_ROLES:
            return ActionGroup.MANIPULATE_ROLES;
        case MANIPULATE_PERMISSIONS:
            return ActionGroup.MANIPULATE_PERMISSIONS;
        case CREATE_STORAGE_DOMAIN:
            return ActionGroup.CREATE_STORAGE_DOMAIN;
        case EDIT_STORAGE_DOMAIN_CONFIGURATION:
            return ActionGroup.EDIT_STORAGE_DOMAIN_CONFIGURATION;
        case DELETE_STORAGE_DOMAIN:
            return ActionGroup.DELETE_STORAGE_DOMAIN;
        case MANIPULATE_STORAGE_DOMAIN:
            return ActionGroup.MANIPULATE_STORAGE_DOMAIN;
        case CREATE_STORAGE_POOL:
            return ActionGroup.CREATE_STORAGE_POOL;
        case DELETE_STORAGE_POOL:
            return ActionGroup.DELETE_STORAGE_POOL;
        case EDIT_STORAGE_POOL_CONFIGURATION:
            return ActionGroup.EDIT_STORAGE_POOL_CONFIGURATION;
        case CONFIGURE_STORAGE_POOL_NETWORK:
            return ActionGroup.CONFIGURE_STORAGE_POOL_NETWORK;
        case CONFIGURE_RHEVM:
            return ActionGroup.CONFIGURE_ENGINE;
        case CONFIGURE_QUOTA:
            return ActionGroup.CONFIGURE_QUOTA;
        case CONSUME_QUOTA:
            return ActionGroup.CONSUME_QUOTA;
        case CREATE_GLUSTER_VOLUME:
            return ActionGroup.CREATE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_VOLUME:
            return ActionGroup.MANIPULATE_GLUSTER_VOLUME;
        case DELETE_GLUSTER_VOLUME:
            return ActionGroup.DELETE_GLUSTER_VOLUME;
        case CREATE_DISK:
            return ActionGroup.CREATE_DISK;
        case ATTACH_DISK:
            return ActionGroup.ATTACH_DISK;
        case EDIT_DISK_PROPERTIES:
            return ActionGroup.EDIT_DISK_PROPERTIES;
        case CONFIGURE_DISK_STORAGE:
            return ActionGroup.CONFIGURE_DISK_STORAGE;
        case DELETE_DISK:
            return ActionGroup.DELETE_DISK;
        case PORT_MIRRORING:
            return ActionGroup.PORT_MIRRORING;
        case LOGIN:
            return ActionGroup.LOGIN;
        case INJECT_EXTERNAL_EVENTS:
            return ActionGroup.INJECT_EXTERNAL_EVENTS;
        case CREATE_STORAGE_POOL_NETWORK:
            return ActionGroup.CREATE_STORAGE_POOL_NETWORK;
        case DELETE_STORAGE_POOL_NETWORK:
            return ActionGroup.DELETE_STORAGE_POOL_NETWORK;
        case ASSIGN_CLUSTER_NETWORK:
            return ActionGroup.ASSIGN_CLUSTER_NETWORK;
        default:
            return null;
    }
}
#method_after
@Mapping(from = PermitType.class, to = ActionGroup.class)
public static ActionGroup map(PermitType entity, ActionGroup template) {
    switch(entity) {
        case CREATE_VM:
            return ActionGroup.CREATE_VM;
        case DELETE_VM:
            return ActionGroup.DELETE_VM;
        case EDIT_VM_PROPERTIES:
            return ActionGroup.EDIT_VM_PROPERTIES;
        case VM_BASIC_OPERATIONS:
            return ActionGroup.VM_BASIC_OPERATIONS;
        case CHANGE_VM_CD:
            return ActionGroup.CHANGE_VM_CD;
        case MIGRATE_VM:
            return ActionGroup.MIGRATE_VM;
        case CONNECT_TO_VM:
            return ActionGroup.CONNECT_TO_VM;
        case IMPORT_EXPORT_VM:
            return ActionGroup.IMPORT_EXPORT_VM;
        case CONFIGURE_VM_NETWORK:
            return ActionGroup.CONFIGURE_VM_NETWORK;
        case CONFIGURE_VM_STORAGE:
            return ActionGroup.CONFIGURE_VM_STORAGE;
        case MOVE_VM:
            return ActionGroup.MOVE_VM;
        case MANIPULATE_VM_SNAPSHOTS:
            return ActionGroup.MANIPULATE_VM_SNAPSHOTS;
        case RECONNECT_TO_VM:
            return ActionGroup.RECONNECT_TO_VM;
        case CHANGE_VM_CUSTOM_PROPERTIES:
            return ActionGroup.CHANGE_VM_CUSTOM_PROPERTIES;
        case EDIT_ADMIN_VM_PROPERTIES:
            return ActionGroup.EDIT_ADMIN_VM_PROPERTIES;
        case CREATE_INSTANCE:
            return ActionGroup.CREATE_INSTANCE;
        case CREATE_HOST:
            return ActionGroup.CREATE_HOST;
        case EDIT_HOST_CONFIGURATION:
            return ActionGroup.EDIT_HOST_CONFIGURATION;
        case DELETE_HOST:
            return ActionGroup.DELETE_HOST;
        case MANIPUTLATE_HOST:
            return ActionGroup.MANIPUTLATE_HOST;
        case CONFIGURE_HOST_NETWORK:
            return ActionGroup.CONFIGURE_HOST_NETWORK;
        case CREATE_TEMPLATE:
            return ActionGroup.CREATE_TEMPLATE;
        case EDIT_TEMPLATE_PROPERTIES:
            return ActionGroup.EDIT_TEMPLATE_PROPERTIES;
        case EDIT_ADMIN_TEMPLATE_PROPERTIES:
            return ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES;
        case DELETE_TEMPLATE:
            return ActionGroup.DELETE_TEMPLATE;
        case COPY_TEMPLATE:
            return ActionGroup.COPY_TEMPLATE;
        case CONFIGURE_TEMPLATE_NETWORK:
            return ActionGroup.CONFIGURE_TEMPLATE_NETWORK;
        case CREATE_VM_POOL:
            return ActionGroup.CREATE_VM_POOL;
        case EDIT_VM_POOL_CONFIGURATION:
            return ActionGroup.EDIT_VM_POOL_CONFIGURATION;
        case DELETE_VM_POOL:
            return ActionGroup.DELETE_VM_POOL;
        case VM_POOL_BASIC_OPERATIONS:
            return ActionGroup.VM_POOL_BASIC_OPERATIONS;
        case CREATE_CLUSTER:
            return ActionGroup.CREATE_CLUSTER;
        case EDIT_CLUSTER_CONFIGURATION:
            return ActionGroup.EDIT_CLUSTER_CONFIGURATION;
        case DELETE_CLUSTER:
            return ActionGroup.DELETE_CLUSTER;
        case CONFIGURE_CLUSTER_NETWORK:
            return ActionGroup.CONFIGURE_CLUSTER_NETWORK;
        case MANIPULATE_USERS:
            return ActionGroup.MANIPULATE_USERS;
        case MANIPULATE_ROLES:
            return ActionGroup.MANIPULATE_ROLES;
        case MANIPULATE_PERMISSIONS:
            return ActionGroup.MANIPULATE_PERMISSIONS;
        case CREATE_STORAGE_DOMAIN:
            return ActionGroup.CREATE_STORAGE_DOMAIN;
        case EDIT_STORAGE_DOMAIN_CONFIGURATION:
            return ActionGroup.EDIT_STORAGE_DOMAIN_CONFIGURATION;
        case DELETE_STORAGE_DOMAIN:
            return ActionGroup.DELETE_STORAGE_DOMAIN;
        case MANIPULATE_STORAGE_DOMAIN:
            return ActionGroup.MANIPULATE_STORAGE_DOMAIN;
        case CREATE_STORAGE_POOL:
            return ActionGroup.CREATE_STORAGE_POOL;
        case DELETE_STORAGE_POOL:
            return ActionGroup.DELETE_STORAGE_POOL;
        case EDIT_STORAGE_POOL_CONFIGURATION:
            return ActionGroup.EDIT_STORAGE_POOL_CONFIGURATION;
        case CONFIGURE_STORAGE_POOL_NETWORK:
            return ActionGroup.CONFIGURE_STORAGE_POOL_NETWORK;
        case CONFIGURE_RHEVM:
            return ActionGroup.CONFIGURE_ENGINE;
        case CONFIGURE_QUOTA:
            return ActionGroup.CONFIGURE_QUOTA;
        case CONSUME_QUOTA:
            return ActionGroup.CONSUME_QUOTA;
        case CREATE_GLUSTER_VOLUME:
            return ActionGroup.CREATE_GLUSTER_VOLUME;
        case MANIPULATE_GLUSTER_VOLUME:
            return ActionGroup.MANIPULATE_GLUSTER_VOLUME;
        case DELETE_GLUSTER_VOLUME:
            return ActionGroup.DELETE_GLUSTER_VOLUME;
        case CREATE_DISK:
            return ActionGroup.CREATE_DISK;
        case ATTACH_DISK:
            return ActionGroup.ATTACH_DISK;
        case EDIT_DISK_PROPERTIES:
            return ActionGroup.EDIT_DISK_PROPERTIES;
        case CONFIGURE_DISK_STORAGE:
            return ActionGroup.CONFIGURE_DISK_STORAGE;
        case DELETE_DISK:
            return ActionGroup.DELETE_DISK;
        case CONFIGURE_NETWORK_VNIC_PROFILE:
            return ActionGroup.CONFIGURE_NETWORK_VNIC_PROFILE;
        case CREATE_NETWORK_VNIC_PROFILE:
            return ActionGroup.CREATE_NETWORK_VNIC_PROFILE;
        case DELETE_NETWORK_VNIC_PROFILE:
            return ActionGroup.DELETE_NETWORK_VNIC_PROFILE;
        case LOGIN:
            return ActionGroup.LOGIN;
        case INJECT_EXTERNAL_EVENTS:
            return ActionGroup.INJECT_EXTERNAL_EVENTS;
        case CREATE_STORAGE_POOL_NETWORK:
            return ActionGroup.CREATE_STORAGE_POOL_NETWORK;
        case DELETE_STORAGE_POOL_NETWORK:
            return ActionGroup.DELETE_STORAGE_POOL_NETWORK;
        case ASSIGN_CLUSTER_NETWORK:
            return ActionGroup.ASSIGN_CLUSTER_NETWORK;
        case CONFIGURE_SCSI_GENERIC_IO:
            return ActionGroup.CONFIGURE_SCSI_GENERIC_IO;
        case INJECT_EXTERNAL_TASKS:
            return ActionGroup.INJECT_EXTERNAL_TASKS;
        case ACCESS_IMAGE_STORAGE:
            return ActionGroup.ACCESS_IMAGE_STORAGE;
        default:
            return null;
    }
}
#end_block

#method_before
protected void updateVmDisks() {
    VmHandler.updateDisksFromDb(getVm());
}
#method_after
protected void updateVmDisks() {
    VmHandler.updateDisksFromDb(getVm());
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.NewGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityId(getVmTemplateId());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            AddVmTemplateImages();
            List<VmNetworkInterface> vmInterfaces = addVmInterfaces();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), newDiskImages, vmInterfaces);
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), newDiskImages, vmInterfaces);
            }
            setSucceeded(true);
            return null;
        }
    });
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled());
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled());
            }
            setSucceeded(true);
            return null;
        }
    });
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    for (DiskImage diskImage : getVm().getDiskList()) {
        mImages.add(diskImage);
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getOs(), getParameters().getMasterVm().getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version().toString())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!getVm().getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        Map<Guid, List<DiskImage>> sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
        for (DiskImage image : mImages) {
            MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
            if (!diskInfoDestinationMap.containsKey(image.getId())) {
                Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getStorageIds().get(0);
                ArrayList<Guid> storageIds = new ArrayList<Guid>();
                storageIds.add(destStorageId);
                image.setStorageIds(storageIds);
                diskInfoDestinationMap.put(image.getId(), image);
            }
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
            if (storage.getStorageDomainType() == StorageDomainType.ImportExport || storage.getStorageDomainType() == StorageDomainType.ISO) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#method_after
private boolean imagesRelatedChecks() {
    // images related checks
    if (!mImages.isEmpty()) {
        if (!getVm().getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) {
            addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
            return false;
        }
        if (!validateVmNotDuringSnapshot()) {
            return false;
        }
        if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
            return false;
        }
        List<DiskImage> diskImagesToCheck = ImagesHandler.filterImageDisks(mImages, true, false);
        DiskImagesValidator diskImagesValidator = new DiskImagesValidator(diskImagesToCheck);
        if (!validate(diskImagesValidator.diskImagesNotIllegal()) || !validate(diskImagesValidator.diskImagesNotLocked())) {
            return false;
        }
        MultipleStorageDomainsValidator storageDomainsValidator = new MultipleStorageDomainsValidator(getStoragePoolId(), sourceImageDomainsImageMap.keySet());
        if (!validate(storageDomainsValidator.allDomainsExistAndActive())) {
            return false;
        }
        Map<Guid, StorageDomain> storageDomains = new HashMap<Guid, StorageDomain>();
        Set<Guid> destImageDomains = getStorageGuidSet();
        destImageDomains.removeAll(sourceImageDomainsImageMap.keySet());
        for (Guid destImageDomain : destImageDomains) {
            StorageDomain storage = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(destImageDomain, getVm().getStoragePoolId());
            if (storage == null) {
                // domain is not in the same storage pool as the vm
                if (DbFacade.getInstance().getStorageDomainStaticDao().get(destImageDomain) == null) {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_EXIST.toString());
                } else {
                    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_NOT_IN_STORAGE_POOL);
                }
                return false;
            }
            if (storage.getStatus() == null || storage.getStatus() != StorageDomainStatus.Active) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_STATUS_ILLEGAL.toString());
                return false;
            }
            if (storage.getStorageDomainType() == StorageDomainType.ImportExport || storage.getStorageDomainType() == StorageDomainType.ISO) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
                return false;
            }
            storageDomains.put(destImageDomain, storage);
        }
        // update vm snapshots for storage free space check
        ImagesHandler.fillImagesBySnapshots(getVm());
        Map<StorageDomain, Integer> domainMap = StorageDomainValidator.getSpaceRequirementsForStorageDomains(ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), true, false), storageDomains, diskInfoDestinationMap);
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    return true;
}
#end_block

#method_before
protected List<VmNetworkInterface> addVmInterfaces() {
    List<VmNetworkInterface> templateInterfaces = new ArrayList<VmNetworkInterface>();
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        iDynamic.setId(Guid.NewGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        templateInterfaces.add(iDynamic);
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
    }
    return templateInterfaces;
}
#method_after
protected void addVmInterfaces(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNic iface : interfaces) {
        VmNic iDynamic = new VmNic();
        iDynamic.setId(Guid.newGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setVnicProfileId(iface.getVnicProfileId());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        getVmNicDao().save(iDynamic);
        srcDeviceIdToTargetDeviceIdMapping.put(iface.getId(), iDynamic.getId());
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void endUnlockOps() {
    if (isVmInDb) {
        VmHandler.UnLockVm(getVm());
    }
    VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
}
#method_after
private void endUnlockOps() {
    if (isVmInDb) {
        VmHandler.unLockVm(getVm());
    }
    VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null || getVdsGroup().getStoragePoolId() == null ? null : getVdsGroup().getStoragePoolId().getValue();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
        // host-specific parameters can be changed by administration role only
        if (getParameters().getMasterVm().getDedicatedVmForVds() != null || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionCheckSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permissionCheckSubject == null) {
        permissionCheckSubject = new ArrayList<PermissionSubject>();
        Guid storagePoolId = getVdsGroup() == null ? null : getVdsGroup().getStoragePoolId();
        permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, getActionType().getActionGroup()));
        // host-specific parameters can be changed by administration role only
        if (getParameters().getMasterVm().getDedicatedVmForVds() != null || !StringUtils.isEmpty(getParameters().getMasterVm().getCpuPinning())) {
            permissionCheckSubject.add(new PermissionSubject(storagePoolId, VdcObjectType.StoragePool, ActionGroup.EDIT_ADMIN_TEMPLATE_PROPERTIES));
        }
    }
    return permissionCheckSubject;
}
#end_block

#method_before
private void addPermission() {
    addPermissionForTemplate(getCurrentUser().getUserId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    }
}
#method_after
private void addPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(permissionsToAdd, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    } else {
        addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_USER);
    }
    copyVmPermissions(permissionsToAdd);
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
    }
}
#end_block

#method_before
private void addPermissionForTemplate(Guid userId, PredefinedRoles role) {
    permissions perms = new permissions();
    perms.setad_element_id(userId);
    perms.setObjectType(VdcObjectType.VmTemplate);
    perms.setObjectId(getParameters().getVmTemplateId());
    perms.setrole_id(role.getId());
    MultiLevelAdministrationHandler.addPermission(perms);
}
#method_after
private void addPermissionForTemplate(UniquePermissionsSet permissionsToAdd, Guid userId, PredefinedRoles role) {
    permissionsToAdd.addPermission(userId, role.getId(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
}
#end_block

#method_before
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getVmTemplateDao();
    existingTemplate = dao.get(new Guid("1b85420c-b84c-4f29-997e-0eb674b40b79"));
    newVmTemplate = new VmTemplate();
    newVmTemplate.setId(Guid.NewGuid());
    newVmTemplate.setName("NewVmTemplate");
    newVmTemplate.setVdsGroupId(VDS_GROUP_ID);
}
#method_after
@Override
public void setUp() throws Exception {
    super.setUp();
    dao = dbFacade.getVmTemplateDao();
    existingTemplate = dao.get(new Guid("1b85420c-b84c-4f29-997e-0eb674b40b79"));
    newVmTemplate = new VmTemplate();
    newVmTemplate.setId(Guid.newGuid());
    newVmTemplate.setName("NewVmTemplate");
    newVmTemplate.setVdsGroupId(VDS_GROUP_ID);
}
#end_block

#method_before
@Test
public void testGetWithInvalidId() {
    VmTemplate result = dao.get(Guid.NewGuid());
    assertNull(result);
}
#method_after
@Test
public void testGetWithInvalidId() {
    VmTemplate result = dao.get(Guid.newGuid());
    assertNull(result);
}
#end_block

#method_before
@Test
public void testGetImageType() {
    InstanceType result = dao.getInstanceType(EXISTING_IMAGE_TYPE_ID);
    assertNotNull(result);
    assertEquals(EXISTING_IMAGE_TYPE_ID, result.getId());
}
#method_after
@Test
public void testGetImageType() {
    ImageType result = dao.getImageType(EXISTING_IMAGE_TYPE_ID);
    assertNotNull(result);
    assertEquals(EXISTING_IMAGE_TYPE_ID, result.getId());
}
#end_block

#method_before
public InstanceType getInstanceType(Guid id) {
    VmTemplate result = get(id);
    if (result != null && result.getTemplateType() != TemplateType.INSTANCE_TYPE) {
        result = null;
    }
    return result;
}
#method_after
@Override
public InstanceType getInstanceType(Guid id) {
    VmTemplate result = get(id);
    if (result != null && result.getTemplateType() != VmEntityType.INSTANCE_TYPE) {
        result = null;
    }
    return result;
}
#end_block

#method_before
public ImageType getImageType(Guid id) {
    VmTemplate result = get(id);
    if (result != null && result.getTemplateType() != TemplateType.IMAGE_TYPE) {
        result = null;
    }
    return result;
}
#method_after
@Override
public ImageType getImageType(Guid id) {
    VmTemplate result = get(id);
    if (result != null && result.getTemplateType() != VmEntityType.IMAGE_TYPE) {
        result = null;
    }
    return result;
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOs()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("is_auto_suspend", template.isAutoSuspend()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("template_type", template.getTemplateType().name());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name());
}
#end_block

#method_before
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOs(VmOsType.forValue(rs.getInt("os")));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTemplateType(TemplateType.valueOf(rs.getString("entity_type")));
    return entity;
}
#method_after
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    return entity;
}
#end_block

#method_before
public VmTemplateStatus getStatus() {
    return status;
}
#method_after
@Override
public VmTemplateStatus getStatus() {
    return status;
}
#end_block

#method_before
public void setStatus(VmTemplateStatus value) {
    status = value;
}
#method_after
@Override
public void setStatus(VmTemplateStatus value) {
    status = value;
}
#end_block

#method_before
public NGuid getStoragePoolId() {
    return storagePoolId;
}
#method_after
public Guid getStoragePoolId() {
    return storagePoolId;
}
#end_block

#method_before
public void setStoragePoolId(NGuid value) {
    storagePoolId = value;
}
#method_after
public void setStoragePoolId(Guid value) {
    storagePoolId = value;
}
#end_block

#method_before
@JsonIgnore
public Map<Guid, DiskImage> getDiskImageMap() {
    return diskMap;
}
#method_after
@JsonIgnore
public HashMap<Guid, DiskImage> getDiskImageMap() {
    return diskImageMap;
}
#end_block

#method_before
public void setDiskImageMap(Map<Guid, DiskImage> value) {
    diskMap = value;
}
#method_after
public void setDiskImageMap(HashMap<Guid, DiskImage> value) {
    diskImageMap = value;
}
#end_block

#method_before
public TemplateType getTemplateType() {
    return templateType;
}
#method_after
public VmEntityType getTemplateType() {
    return templateType;
}
#end_block

#method_before
public void setTemplateType(TemplateType templateType) {
    this.templateType = templateType;
}
#method_after
public void setTemplateType(VmEntityType templateType) {
    this.templateType = templateType;
}
#end_block

#method_before
@Override
public List<VM> getAllForVmPool(NGuid vmPoolId) {
    return getCallsHandler().executeReadList("GetVmsByVmPoolId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vm_pool_id", vmPoolId));
}
#method_after
@Override
public List<VM> getAllForVmPool(Guid vmPoolId) {
    return getCallsHandler().executeReadList("GetVmsByVmPoolId", VMRowMapper.instance, getCustomMapSqlParameterSource().addValue("vm_pool_id", vmPoolId));
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setVmOs(VmOsType.forValue(rs.getInt("vm_os")));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOs(VmOsType.forValue(rs.getInt("vmt_os")));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
    entity.setMigratingToVds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(NGuid.createGuidFromString(rs.getString("vm_pool_id")));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setAutoSuspend(rs.getBoolean("is_auto_suspend"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(Guid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setSelectionAlgorithm(VdsSelectionAlgorithm.forValue(rs.getInt("selection_algorithm")));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setInstanceTypeId(NGuid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(NGuid.createGuidFromString(rs.getString("image_type_id")));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    entity.setCpuName(rs.getString("cpu_name"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    return entity;
}
#end_block

#method_before
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOs()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("is_auto_suspend", template.isAutoSuspend()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("template_type", template.getTemplateType().name());
}
#method_after
private MapSqlParameterSource getInsertOrUpdateParameters(VmTemplate template) {
    return getCustomMapSqlParameterSource().addValue("child_count", template.getChildCount()).addValue("creation_date", template.getCreationDate()).addValue("description", template.getDescription()).addValue("free_text_comment", template.getComment()).addValue("mem_size_mb", template.getMemSizeMb()).addValue("name", template.getName()).addValue("num_of_sockets", template.getNumOfSockets()).addValue("cpu_per_socket", template.getCpuPerSocket()).addValue("os", template.getOsId()).addValue("vmt_guid", template.getId()).addValue("vds_group_id", template.getVdsGroupId()).addValue("domain", template.getDomain()).addValue("num_of_monitors", template.getNumOfMonitors()).addValue("single_qxl_pci", template.getSingleQxlPci()).addValue("allow_console_reconnect", template.isAllowConsoleReconnect()).addValue("status", template.getStatus()).addValue("usb_policy", template.getUsbPolicy()).addValue("time_zone", template.getTimeZone()).addValue("fail_back", template.isFailBack()).addValue("vm_type", template.getVmType()).addValue("nice_level", template.getNiceLevel()).addValue("cpu_shares", template.getCpuShares()).addValue("default_boot_sequence", template.getDefaultBootSequence()).addValue("default_display_type", template.getDefaultDisplayType()).addValue("priority", template.getPriority()).addValue("auto_startup", template.isAutoStartup()).addValue("is_stateless", template.isStateless()).addValue("is_smartcard_enabled", template.isSmartcardEnabled()).addValue("is_delete_protected", template.isDeleteProtected()).addValue("iso_path", template.getIsoPath()).addValue("origin", template.getOrigin()).addValue("initrd_url", template.getInitrdUrl()).addValue("kernel_url", template.getKernelUrl()).addValue("kernel_params", template.getKernelParams()).addValue("is_disabled", template.isDisabled()).addValue("quota_id", template.getQuotaId()).addValue("migration_support", template.getMigrationSupport().getValue()).addValue("dedicated_vm_for_vds", template.getDedicatedVmForVds()).addValue("tunnel_migration", template.getTunnelMigration()).addValue("vnc_keyboard_layout", template.getVncKeyboardLayout()).addValue("min_allocated_mem", template.getMinAllocatedMem()).addValue("is_run_and_pause", template.isRunAndPause()).addValue("created_by_user_id", template.getCreatedByUserId()).addValue("template_type", template.getTemplateType().name());
}
#end_block

#method_before
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOs(VmOsType.forValue(rs.getInt("os")));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(NGuid.createGuidFromString(rs.getString("storage_pool_id")));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTemplateType(TemplateType.valueOf(rs.getString("entity_type")));
    return entity;
}
#method_after
@Override
public VmTemplate mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmTemplate entity = new VmTemplate();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setChildCount(rs.getInt("child_count"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setName(rs.getString("name"));
    entity.setOsId(rs.getInt("os"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setStatus(VmTemplateStatus.forValue(rs.getInt("status")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setStoragePoolId(getGuid(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDisabled(rs.getBoolean("is_disabled"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setTemplateType(VmEntityType.valueOf(rs.getString("entity_type")));
    return entity;
}
#end_block

#method_before
public VmOsType getOs() {
    return this.getVmOs();
}
#method_after
public int getOs() {
    return this.getVmOsId();
}
#end_block

#method_before
public void setVmOs(VmOsType value) {
    this.vmStatic.setOs(value);
}
#method_after
public void setVmOs(int value) {
    this.vmStatic.setOsId(value);
}
#end_block

#method_before
public NGuid getDedicatedVmForVds() {
    return vmStatic.getDedicatedVmForVds();
}
#method_after
public Guid getDedicatedVmForVds() {
    return vmStatic.getDedicatedVmForVds();
}
#end_block

#method_before
public void setDedicatedVmForVds(NGuid value) {
    vmStatic.setDedicatedVmForVds(value);
}
#method_after
public void setDedicatedVmForVds(Guid value) {
    vmStatic.setDedicatedVmForVds(value);
}
#end_block

#method_before
public VMStatus getStatus() {
    return this.vmDynamic.getStatus();
}
#method_after
@Override
public VMStatus getStatus() {
    return this.vmDynamic.getStatus();
}
#end_block

#method_before
public void setStatus(VMStatus value) {
    this.vmDynamic.setStatus(value);
}
#method_after
@Override
public void setStatus(VMStatus value) {
    this.vmDynamic.setStatus(value);
}
#end_block

#method_before
public NGuid getConsoleUserId() {
    return this.vmDynamic.getConsoleUserId();
}
#method_after
public Guid getConsoleUserId() {
    return this.vmDynamic.getConsoleUserId();
}
#end_block

#method_before
public void setConsoleUserId(NGuid value) {
    this.vmDynamic.setConsoleUserId(value);
}
#method_after
public void setConsoleUserId(Guid value) {
    this.vmDynamic.setConsoleUserId(value);
}
#end_block

#method_before
public NGuid getRunOnVds() {
    return this.vmDynamic.getRunOnVds();
}
#method_after
public Guid getRunOnVds() {
    return this.vmDynamic.getRunOnVds();
}
#end_block

#method_before
public void setRunOnVds(NGuid value) {
    this.vmDynamic.setRunOnVds(value);
}
#method_after
public void setRunOnVds(Guid value) {
    this.vmDynamic.setRunOnVds(value);
}
#end_block

#method_before
public NGuid getMigratingToVds() {
    return this.vmDynamic.getMigratingToVds();
}
#method_after
public Guid getMigratingToVds() {
    return this.vmDynamic.getMigratingToVds();
}
#end_block

#method_before
public void setMigratingToVds(NGuid value) {
    this.vmDynamic.setMigratingToVds(value);
}
#method_after
public void setMigratingToVds(Guid value) {
    this.vmDynamic.setMigratingToVds(value);
}
#end_block

#method_before
public NGuid getLastVdsRunOn() {
    return this.vmDynamic.getLastVdsRunOn();
}
#method_after
public Guid getLastVdsRunOn() {
    return this.vmDynamic.getLastVdsRunOn();
}
#end_block

#method_before
public void setLastVdsRunOn(NGuid value) {
    this.vmDynamic.setLastVdsRunOn(value);
}
#method_after
public void setLastVdsRunOn(Guid value) {
    this.vmDynamic.setLastVdsRunOn(value);
}
#end_block

#method_before
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    setUtcDiff(vm.getUtcDiff());
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#method_after
public void updateRunTimeDynamicData(VmDynamic vm, Guid vdsId, String vdsName) {
    setStatus(vm.getStatus());
    setRunOnVds(vdsId);
    setRunOnVdsName(vdsName);
    setDisplay(vm.getDisplay());
    setDisplaySecurePort(vm.getDisplaySecurePort());
    setVmHost(vm.getVmHost());
    setVmIp(vm.getVmIp());
    setVmFQDN(vm.getVmFQDN());
    // if (!string.IsNullOrEmpty(vm.app_list))
    // {
    setAppList(vm.getAppList());
    // }
    setGuestOs(vm.getGuestOs());
    setDisplayType(vm.getDisplayType());
    setDisplayIp(vm.getDisplayIp());
    setKvmEnable(vm.getKvmEnable());
    setAcpiEnable(vm.getAcpiEnable());
    setGuestCurrentUserName(vm.getGuestCurrentUserName());
    setWin2kHackEnable(vm.getWin2kHackEnable());
    if (SimpleDependecyInjector.getInstance().get(OsRepository.class).isLinux(getVmOsId())) {
        setUtcDiff(vm.getUtcDiff());
    }
    setExitStatus(vm.getExitStatus());
    setExitMessage(vm.getExitMessage());
    setClientIp(vm.getClientIp());
    setVmPauseStatus(vm.getPauseStatus());
    setLastWatchdogEvent(vm.getLastWatchdogEvent());
// TODO: check what to do with update disk data
// updateDisksData(vm);
// updateSession(vm);
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + migreatingFromPort;
    result = prime * result + migreatingToPort;
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + ((selectionAlgorithm == null) ? 0 : selectionAlgorithm.hashCode());
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + (useSysPrep ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuFlagsData == null) ? 0 : vdsGroupCpuFlagsData.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + ((vmtOs == null) ? 0 : vmtOs.hashCode());
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    long temp;
    temp = (long) _actualDiskWithSnapthotsSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + (balloonEnabled ? 1231 : 1237);
    result = prime * result + ((cdPath == null) ? 0 : cdPath.hashCode());
    result = prime * result + ((configured == null) ? 0 : configured.hashCode());
    result = prime * result + ((diskMap == null) ? 0 : diskMap.hashCode());
    temp = (long) diskSize;
    result = prime * result + (int) (temp ^ (temp >>> 32));
    result = prime * result + ((floppyPath == null) ? 0 : floppyPath.hashCode());
    result = prime * result + ((initializationType == null) ? 0 : initializationType.hashCode());
    result = prime * result + migreatingFromPort;
    result = prime * result + migreatingToPort;
    result = prime * result + ((privateGuestAgentVersion == null) ? 0 : privateGuestAgentVersion.hashCode());
    result = prime * result + ((runOnVdsName == null) ? 0 : runOnVdsName.hashCode());
    result = prime * result + (runOnce ? 1231 : 1237);
    result = prime * result + ((snapshots == null) ? 0 : snapshots.hashCode());
    result = prime * result + ((spiceDriverVersion == null) ? 0 : spiceDriverVersion.hashCode());
    result = prime * result + ((storagePoolId == null) ? 0 : storagePoolId.hashCode());
    result = prime * result + ((storagePoolName == null) ? 0 : storagePoolName.hashCode());
    result = prime * result + (transparentHugePages ? 1231 : 1237);
    result = prime * result + ((vdsGroupCompatibilityVersion == null) ? 0 : vdsGroupCompatibilityVersion.hashCode());
    result = prime * result + ((vdsGroupCpuFlagsData == null) ? 0 : vdsGroupCpuFlagsData.hashCode());
    result = prime * result + ((vdsGroupCpuName == null) ? 0 : vdsGroupCpuName.hashCode());
    result = prime * result + ((vdsGroupDescription == null) ? 0 : vdsGroupDescription.hashCode());
    result = prime * result + ((vdsGroupName == null) ? 0 : vdsGroupName.hashCode());
    result = prime * result + ((vmDynamic == null) ? 0 : vmDynamic.hashCode());
    result = prime * result + ((vmPayload == null) ? 0 : vmPayload.hashCode());
    result = prime * result + ((vmPoolId == null) ? 0 : vmPoolId.hashCode());
    result = prime * result + ((vmPoolName == null) ? 0 : vmPoolName.hashCode());
    result = prime * result + ((vmStatic == null) ? 0 : vmStatic.hashCode());
    result = prime * result + ((vmStatistics == null) ? 0 : vmStatistics.hashCode());
    result = prime * result + vmtCpuPerSocket;
    result = prime * result + ((vmtCreationDate == null) ? 0 : vmtCreationDate.hashCode());
    result = prime * result + ((vmtDescription == null) ? 0 : vmtDescription.hashCode());
    result = prime * result + vmtMemSizeMb;
    result = prime * result + ((vmtName == null) ? 0 : vmtName.hashCode());
    result = prime * result + vmtNumOfCpus;
    result = prime * result + vmtNumOfSockets;
    result = prime * result + vmtOsId;
    result = prime * result + ((vmtTimeZone == null) ? 0 : vmtTimeZone.hashCode());
    result = prime * result + vmtchildCount;
    return result;
}
#end_block

#method_before
public NGuid getVmPoolId() {
    return vmPoolId;
}
#method_after
public Guid getVmPoolId() {
    return vmPoolId;
}
#end_block

#method_before
public void setVmPoolId(NGuid value) {
    vmPoolId = value;
}
#method_after
public void setVmPoolId(Guid value) {
    vmPoolId = value;
}
#end_block

#method_before
public void setRunOnce(boolean value) {
    runOnce = value;
}
#method_after
public void setRunOnce(boolean value) {
    vmDynamic.setRunOnce(value);
}
#end_block

#method_before
public boolean isRunOnce() {
    return runOnce;
}
#method_after
public boolean isRunOnce() {
    return vmDynamic.isRunOnce();
}
#end_block

#method_before
public NGuid getInstanceTypeId() {
    return vmStatic.getInstanceTypeId();
}
#method_after
public Guid getInstanceTypeId() {
    return vmStatic.getInstanceTypeId();
}
#end_block

#method_before
public void setInstanceTypeId(NGuid instanceTypeId) {
    vmStatic.setInstanceTypeId(instanceTypeId);
}
#method_after
public void setInstanceTypeId(Guid instanceTypeId) {
    vmStatic.setInstanceTypeId(instanceTypeId);
}
#end_block

#method_before
public NGuid getImageTypeId() {
    return vmStatic.getImageTypeId();
}
#method_after
public Guid getImageTypeId() {
    return vmStatic.getImageTypeId();
}
#end_block

#method_before
public void setImageTypeId(NGuid ImageTypeId) {
    vmStatic.setImageTypeId(ImageTypeId);
}
#method_after
public void setImageTypeId(Guid ImageTypeId) {
    vmStatic.setImageTypeId(ImageTypeId);
}
#end_block

#method_before
public NGuid getInstanceTypeId() {
    return instanceTypeId;
}
#method_after
public Guid getInstanceTypeId() {
    return instanceTypeId;
}
#end_block

#method_before
public void setInstanceTypeId(NGuid instanceTypeId) {
    this.instanceTypeId = instanceTypeId;
}
#method_after
public void setInstanceTypeId(Guid instanceTypeId) {
    this.instanceTypeId = instanceTypeId;
}
#end_block

#method_before
public NGuid getImageTypeId() {
    return imageTypeId;
}
#method_after
public Guid getImageTypeId() {
    return imageTypeId;
}
#end_block

#method_before
public void setImageTypeId(NGuid imageTypeId) {
    this.imageTypeId = imageTypeId;
}
#method_after
public void setImageTypeId(Guid imageTypeId) {
    this.imageTypeId = imageTypeId;
}
#end_block

#method_before
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOs()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("is_initialized", vm.isInitialized()).addValue("is_auto_suspend", vm.isAutoSuspend()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId());
}
#method_after
private MapSqlParameterSource getFullParameterSource(VmStatic vm) {
    return getIdParamterSource(vm.getId()).addValue("description", vm.getDescription()).addValue("free_text_comment", vm.getComment()).addValue("mem_size_mb", vm.getMemSizeMb()).addValue("os", vm.getOsId()).addValue("vds_group_id", vm.getVdsGroupId()).addValue("vm_name", vm.getName()).addValue("vmt_guid", vm.getVmtGuid()).addValue("domain", vm.getDomain()).addValue("creation_date", vm.getCreationDate()).addValue("num_of_monitors", vm.getNumOfMonitors()).addValue("single_qxl_pci", vm.getSingleQxlPci()).addValue("is_initialized", vm.isInitialized()).addValue("num_of_sockets", vm.getNumOfSockets()).addValue("cpu_per_socket", vm.getCpuPerSocket()).addValue("usb_policy", vm.getUsbPolicy()).addValue("time_zone", vm.getTimeZone()).addValue("auto_startup", vm.isAutoStartup()).addValue("is_stateless", vm.isStateless()).addValue("is_smartcard_enabled", vm.isSmartcardEnabled()).addValue("is_delete_protected", vm.isDeleteProtected()).addValue("dedicated_vm_for_vds", vm.getDedicatedVmForVds()).addValue("fail_back", vm.isFailBack()).addValue("vm_type", vm.getVmType()).addValue("nice_level", vm.getNiceLevel()).addValue("cpu_shares", vm.getCpuShares()).addValue("default_boot_sequence", vm.getDefaultBootSequence()).addValue("default_display_type", vm.getDefaultDisplayType()).addValue("priority", vm.getPriority()).addValue("iso_path", vm.getIsoPath()).addValue("origin", vm.getOrigin()).addValue("initrd_url", vm.getInitrdUrl()).addValue("kernel_url", vm.getKernelUrl()).addValue("kernel_params", vm.getKernelParams()).addValue("migration_support", vm.getMigrationSupport().getValue()).addValue("predefined_properties", vm.getPredefinedProperties()).addValue("userdefined_properties", vm.getUserDefinedProperties()).addValue("min_allocated_mem", vm.getMinAllocatedMem()).addValue("quota_id", vm.getQuotaId()).addValue("allow_console_reconnect", vm.isAllowConsoleReconnect()).addValue("cpu_pinning", vm.getCpuPinning()).addValue("host_cpu_flags", vm.isUseHostCpuFlags()).addValue("tunnel_migration", vm.getTunnelMigration()).addValue("vnc_keyboard_layout", vm.getVncKeyboardLayout()).addValue("is_run_and_pause", vm.isRunAndPause()).addValue("created_by_user_id", vm.getCreatedByUserId()).addValue("instance_type_id", vm.getInstanceTypeId()).addValue("image_type_id", vm.getImageTypeId());
}
#end_block

#method_before
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(Guid.createGuidFromString(rs.getString("vds_group_id")));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(Guid.createGuidFromString(rs.getString("vmt_guid")));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(NGuid.createGuidFromString(rs.getString("dedicated_vm_for_vds")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(Guid.createGuidFromString(rs.getString("quota_id")));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(NGuid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(NGuid.createGuidFromString(rs.getString("image_type_id")));
    return entity;
}
#method_after
@Override
public VmStatic mapRow(ResultSet rs, int rowNum) throws SQLException {
    final VmStatic entity = new VmStatic();
    map(rs, entity);
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setMemSizeMb(rs.getInt("mem_size_mb"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setName(rs.getString("vm_name"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setDomain(rs.getString("domain"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setInstanceTypeId(Guid.createGuidFromString(rs.getString("instance_type_id")));
    entity.setImageTypeId(Guid.createGuidFromString(rs.getString("image_type_id")));
    return entity;
}
#end_block

#method_before
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
        discoveryThread.start();
    } else {
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#method_after
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        discoveryThread.start();
    } else {
        discoveryThread.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#end_block

#method_before
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = ImagesHandler.getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setImageTemplateId(VmTemplateHandler.BlankVmTemplateId);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = ImagesHandler.getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#method_after
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = ImagesHandler.getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setImageTemplateId(VmTemplateHandler.BlankVmTemplateId);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
                updateManagedDeviceMap(disk, getVm().getStaticData().getManagedDeviceMap());
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = ImagesHandler.getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getId());
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    // Everything is OK:
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // Everything is OK:
    return true;
}
#end_block

#method_before
@Test
public void testExecuteQuery() {
    Guid storagePoolID = Guid.newGuid();
    when(getQueryParameters().getId()).thenReturn(storagePoolID);
    StorageDomain domain = new StorageDomain();
    StorageDomainDAO storageDomainDAOMock = mock(StorageDomainDAO.class);
    when(storageDomainDAOMock.getAllForStoragePool(storagePoolID, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(Collections.singletonList(domain));
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    when(dbFacadeMock.getStorageDomainDao()).thenReturn(storageDomainDAOMock);
    getQuery().executeQueryCommand();
    @SuppressWarnings("unchecked")
    List<StorageDomain> result = (List<StorageDomain>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong number of domains returned", 1, result.size());
    assertEquals("Wrong domain returned", domain, result.get(0));
}
#method_after
@Test
public void testExecuteQuery() {
    Guid storagePoolID = Guid.newGuid();
    when(getQueryParameters().getId()).thenReturn(storagePoolID);
    StorageDomain domain = new StorageDomain();
    StorageDomainDAO storageDomainDAOMock = mock(StorageDomainDAO.class);
    when(storageDomainDAOMock.getAllForStoragePool(storagePoolID, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(Collections.singletonList(domain));
    DbFacade dbFacadeMock = getDbFacadeMockInstance();
    when(dbFacadeMock.getStorageDomainDao()).thenReturn(storageDomainDAOMock);
    getQuery().executeQueryCommand();
    List<StorageDomain> result = getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong number of domains returned", 1, result.size());
    assertEquals("Wrong domain returned", domain, result.get(0));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    getNetworkDAO().save(getNetwork());
    NetworkHelper.addPermissions(getCurrentUser().getId(), getNetwork().getId(), getParameters().isPublicUse());
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    getNetwork().setId(Guid.newGuid());
    getNetworkDAO().save(getNetwork());
    if (getNetwork().isVmNetwork() && getParameters().isVnicProfileRequired()) {
        getVnicProfileDao().save(NetworkHelper.createVnicProfile(getNetwork()));
    }
    NetworkHelper.addPermissionsOnNetwork(getCurrentUser().getId(), getNetwork().getId());
    getReturnValue().setActionReturnValue(getNetwork().getId());
    setSucceeded(true);
}
#end_block

#method_before
protected void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<Guid, DiskImage>();
    }
    sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            Guid destStorageId = getParameters().getDestinationStorageDomainId() != null ? getParameters().getDestinationStorageDomainId() : image.getStorageIds().get(0);
            ArrayList<Guid> storageIds = new ArrayList<Guid>();
            storageIds.add(destStorageId);
            image.setStorageIds(storageIds);
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#method_after
protected void updateDiskInfoDestinationMap() {
    diskInfoDestinationMap = getParameters().getDiskInfoDestinationMap();
    if (diskInfoDestinationMap == null) {
        diskInfoDestinationMap = new HashMap<Guid, DiskImage>();
    }
    sourceImageDomainsImageMap = new HashMap<Guid, List<DiskImage>>();
    for (DiskImage image : mImages) {
        MultiValueMapUtils.addToMap(image.getStorageIds().get(0), image, sourceImageDomainsImageMap);
        if (!diskInfoDestinationMap.containsKey(image.getId())) {
            diskInfoDestinationMap.put(image.getId(), image);
        }
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            AddVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            AddVmTemplateImages();
            List<VmNetworkInterface> vmInterfaces = addVmInterfaces();
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), newDiskImages, vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), newDiskImages, vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
            }
            setSucceeded(true);
            return null;
        }
    });
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#method_after
@Override
protected void executeCommand() {
    // relevant only if template created from vm
    if (isVmInDb) {
        VmDynamic vmDynamic = DbFacade.getInstance().getVmDynamicDao().get(getVmId());
        if (vmDynamic.getStatus() != VMStatus.Down) {
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(vmDynamic, getCompensationContext());
    }
    setActionReturnValue(Guid.Empty);
    setVmTemplateId(Guid.newGuid());
    getParameters().setVmTemplateId(getVmTemplateId());
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.VmTemplate, getVmTemplateId()));
    final Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping = new HashMap<>();
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmTemplateToDb();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addPermission();
            addVmTemplateImages(srcDeviceIdToTargetDeviceIdMapping);
            addVmInterfaces(srcDeviceIdToTargetDeviceIdMapping);
            if (isVmInDb) {
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled());
            } else {
                // sending true for isVm in order to create basic devices needed
                VmDeviceUtils.copyVmDevices(getVmId(), getVmTemplateId(), getVm(), getVmTemplate(), true, Collections.<VmDevice>emptyList(), srcDeviceIdToTargetDeviceIdMapping, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), getParameters().isVirtioScsiEnabled());
            }
            setSucceeded(true);
            return null;
        }
    });
    // means that there are no asynchronous tasks to execute and that we can
    // end the command synchronously
    boolean pendingAsyncTasks = !getReturnValue().getVdsmTaskIdList().isEmpty();
    if (!pendingAsyncTasks) {
        endSuccessfullySynchronous();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!IsVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return imagesRelatedChecks() && AddVmCommand.CheckCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null) {
        addCanDoActionMessage(VdcBllMessages.VDS_CLUSTER_IS_NOT_VALID);
        return false;
    }
    if (!VmHandler.isMemorySizeLegal(getParameters().getMasterVm().getOsId(), getParameters().getMasterVm().getMemSizeMb(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (!isVmPriorityValueLegal(getParameters().getMasterVm().getPriority(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (isVmInDb && getVm().getStatus() != VMStatus.Down) {
        addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_CREATE_TEMPLATE_FROM_DOWN_VM.toString());
        return false;
    }
    if (isVmTemlateWithSameNameExist(getVmTemplateName())) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        return false;
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(getParameters().getVm().getUsbPolicy(), getParameters().getVm().getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    if (getParameters().getVm().getSingleQxlPci() && !VmHandler.isSingleQxlDeviceLegal(getParameters().getVm().getDefaultDisplayType(), getParameters().getVm().getOs(), getReturnValue().getCanDoActionMessages(), getVdsGroup().getcompatibility_version())) {
        return false;
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return imagesRelatedChecks() && AddVmCommand.checkCpuSockets(getParameters().getMasterVm().getNumOfSockets(), getParameters().getMasterVm().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected List<VmNetworkInterface> addVmInterfaces() {
    List<VmNetworkInterface> templateInterfaces = new ArrayList<VmNetworkInterface>();
    List<VmNetworkInterface> interfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNetworkInterface iface : interfaces) {
        VmNetworkInterface iDynamic = new VmNetworkInterface();
        iDynamic.setId(Guid.newGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setNetworkName(iface.getNetworkName());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        templateInterfaces.add(iDynamic);
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iDynamic);
    }
    return templateInterfaces;
}
#method_after
protected void addVmInterfaces(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getMasterVm().getId());
    for (VmNic iface : interfaces) {
        VmNic iDynamic = new VmNic();
        iDynamic.setId(Guid.newGuid());
        iDynamic.setVmTemplateId(getVmTemplateId());
        iDynamic.setName(iface.getName());
        iDynamic.setVnicProfileId(iface.getVnicProfileId());
        iDynamic.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iDynamic.setType(iface.getType());
        iDynamic.setLinked(iface.isLinked());
        getVmNicDao().save(iDynamic);
        srcDeviceIdToTargetDeviceIdMapping.put(iface.getId(), iDynamic.getId());
    }
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#method_after
@Override
protected void endSuccessfully() {
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    isVmInDb = getVm() != null;
    getVmStaticDAO().incrementDbGeneration(getVmTemplateId());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    if (reloadVmTemplateFromDB() != null) {
        endDefaultOperations();
    }
    checkTrustedService();
    setSucceeded(true);
}
#end_block

#method_before
private void endUnlockOps() {
    if (isVmInDb) {
        VmHandler.UnLockVm(getVm());
    }
    VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
}
#method_after
private void endUnlockOps() {
    if (isVmInDb) {
        VmHandler.unLockVm(getVm());
    }
    VmTemplateHandler.UnLockVmTemplate(getVmTemplateId());
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        RemoveNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.UnLockVm(getVm());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void endWithFailure() {
    // We evaluate 'VmTemplate' so it won't be null in the last 'if'
    // statement.
    // (a template without images doesn't exist in the 'vm_template_view').
    setVmTemplateId(getParameters().getVmTemplateId());
    setVmId(getVmIdFromImageParameters());
    for (VdcActionParametersBase p : getParameters().getImagesParameters()) {
        p.setTaskGroupSuccess(false);
        Backend.getInstance().EndAction(VdcActionType.CreateImageTemplate, p);
    }
    // if template exist in db remove it
    if (getVmTemplate() != null) {
        DbFacade.getInstance().getVmTemplateDao().remove(getVmTemplateId());
        removeNetwork();
    }
    if (!getVmId().equals(Guid.Empty) && getVm() != null) {
        VmHandler.unLockVm(getVm());
    }
    setSucceeded(true);
}
#end_block

#method_before
private void addPermission() {
    addPermissionForTemplate(getCurrentUser().getId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    }
    copyVmPermissions();
}
#method_after
private void addPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_OWNER);
    // if the template is for public use, set EVERYONE as a TEMPLATE_USER.
    if (getParameters().isPublicUse()) {
        addPermissionForTemplate(permissionsToAdd, MultiLevelAdministrationHandler.EVERYONE_OBJECT_ID, PredefinedRoles.TEMPLATE_USER);
    } else {
        addPermissionForTemplate(permissionsToAdd, getCurrentUser().getId(), PredefinedRoles.TEMPLATE_USER);
    }
    copyVmPermissions(permissionsToAdd);
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
    }
}
#end_block

#method_before
private void copyVmPermissions() {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> vmPermissions = dao.getAllForEntity(getVmId(), getCurrentUser().getId(), false);
    List<permissions> templatePermissions = new ArrayList<permissions>();
    for (permissions vmPermission : vmPermissions) {
        templatePermissions.add(new permissions(getCurrentUser().getId(), vmPermission.getrole_id(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate));
    }
    if (templatePermissions.size() > 0) {
        MultiLevelAdministrationHandler.addPermission(templatePermissions.toArray(new permissions[templatePermissions.size()]));
    }
}
#method_after
private void copyVmPermissions(UniquePermissionsSet permissionsToAdd) {
    if (!isVmInDb || !getParameters().isCopyVmPermissions()) {
        return;
    }
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> vmPermissions = dao.getAllForEntity(getVmId(), getCurrentUser().getId(), false);
    for (permissions vmPermission : vmPermissions) {
        permissionsToAdd.addPermission(vmPermission.getad_element_id(), vmPermission.getrole_id(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
    }
}
#end_block

#method_before
private void addPermissionForTemplate(Guid userId, PredefinedRoles role) {
    permissions perms = new permissions();
    perms.setad_element_id(userId);
    perms.setObjectType(VdcObjectType.VmTemplate);
    perms.setObjectId(getParameters().getVmTemplateId());
    perms.setrole_id(role.getId());
    MultiLevelAdministrationHandler.addPermission(perms);
}
#method_after
private void addPermissionForTemplate(UniquePermissionsSet permissionsToAdd, Guid userId, PredefinedRoles role) {
    permissionsToAdd.addPermission(userId, role.getId(), getParameters().getVmTemplateId(), VdcObjectType.VmTemplate);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    permissions permission = getParameters().getPermission();
    return Collections.singletonList(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getUser() != null && _dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    Guid userId = null;
    String domain = null;
    if (getParameters().getUser() != null) {
        addCustomValue("NewUserName", getParameters().getUser().getLoginName());
        userId = getParameters().getUser().getId();
        domain = getParameters().getUser().getDomain();
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adUser == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        // set the AD user on the parameters to save another roundtrip to the AD when adding the user
        getParameters().setAdUser(adUser);
    } else if (getParameters().getAdGroup() != null) {
        addCustomValue("NewUserName", getParameters().getAdGroup().getname());
        userId = getParameters().getAdGroup().getid();
        domain = getParameters().getAdGroup().getdomain();
        LdapGroup adGroup = (LdapGroup) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adGroup == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
    }
    if (userId == null) {
        addCanDoActionMessage(VdcBllMessages.MISSING_DIRECTORY_ELEMENT_ID);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    Guid userId = null;
    String domain = null;
    if (getParameters().getUser() != null) {
        addCustomValue("NewUserName", getParameters().getUser().getLoginName());
        userId = getParameters().getUser().getId();
        domain = getParameters().getUser().getDomain();
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adUser == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
        // set the AD user on the parameters to save another roundtrip to the AD when adding the user
        getParameters().setAdUser(adUser);
    } else if (getParameters().getAdUser() != null) {
        addCustomValue("NewUserName", getParameters().getAdUser().getUserName());
        userId = getParameters().getAdUser().getUserId();
        domain = getParameters().getAdUser().getDomainControler();
        LdapUser adUser = (LdapUser) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdUserByUserId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adUser == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
    } else if (getParameters().getAdGroup() != null) {
        addCustomValue("NewUserName", getParameters().getAdGroup().getname());
        userId = getParameters().getAdGroup().getid();
        domain = getParameters().getAdGroup().getdomain();
        LdapGroup adGroup = (LdapGroup) LdapFactory.getInstance(domain).RunAdAction(AdActionType.GetAdGroupByGroupId, new LdapSearchByIdParameters(domain, userId)).getReturnValue();
        if (adGroup == null) {
            addCanDoActionMessage(VdcBllMessages.USER_MUST_EXIST_IN_DIRECTORY);
            return false;
        }
    }
    if (userId == null) {
        addCanDoActionMessage(VdcBllMessages.MISSING_DIRECTORY_ELEMENT_ID);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getParameters().getUser() != null) {
        UserCommandBase.persistAuthenticatedUser(getParameters().getAdUser());
    } else // try to add group to db if adGroup sent
    if (getParameters().getAdGroup() != null) {
        AdGroupsHandlingCommandBase.initAdGroup(getParameters().getAdGroup());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getParameters().getAdUser() != null) {
        UserCommandBase.persistAuthenticatedUser(getParameters().getAdUser());
    } else // try to add group to db if adGroup sent
    if (getParameters().getAdGroup() != null) {
        AdGroupsHandlingCommandBase.initAdGroup(getParameters().getAdGroup());
    }
    setSucceeded(true);
}
#end_block

#method_before
public void login() {
    if (!validate()) {
        return;
    }
    startProgress(null);
    disableLoginScreen();
    String fullUserName = (String) getUserName().getEntity();
    String[] parts = getUserNameParts(fullUserName);
    String domain = parts[1];
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            LoginModel loginModel = (LoginModel) model;
            DbUser user = null;
            if (result != null) {
                VdcReturnValueBase returnValue = (VdcReturnValueBase) result;
                if (returnValue.getSucceeded()) {
                    user = (DbUser) returnValue.getActionReturnValue();
                    loginModel.setLoggedUser(user);
                }
                if (user == null) {
                    // $NON-NLS-1$
                    loginModel.getPassword().setEntity("");
                    loginModel.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                    loginModel.getUserName().setIsChangable(true);
                    loginModel.getPassword().setIsChangable(true);
                    loginModel.getDomain().setIsChangable(true);
                    loginModel.getLoginCommand().setIsExecutionAllowed(true);
                    loginModel.getLoginFailedEvent().raise(this, EventArgs.Empty);
                } else {
                    raiseLoggedInEvent();
                }
                stopProgress();
            }
        }
    };
    Frontend.LoginAsync(fullUserName, (String) getPassword().getEntity(), StringHelper.isNullOrEmpty(domain) ? (String) getDomain().getSelectedItem() : domain, _asyncQuery);
}
#method_after
public void login() {
    if (!validate()) {
        getLoginFailedEvent().raise(this, EventArgs.Empty);
        return;
    }
    startProgress(null);
    disableLoginScreen();
    String fullUserName = (String) getUserName().getEntity();
    String[] parts = getUserNameParts(fullUserName);
    String domain = parts[1];
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            LoginModel loginModel = (LoginModel) model;
            DbUser user = null;
            if (result != null) {
                VdcReturnValueBase returnValue = (VdcReturnValueBase) result;
                if (returnValue.getSucceeded()) {
                    user = (DbUser) returnValue.getActionReturnValue();
                    loginModel.setLoggedUser(user);
                }
                if (user == null) {
                    // $NON-NLS-1$
                    loginModel.getPassword().setEntity("");
                    loginModel.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                    loginModel.getUserName().setIsChangable(true);
                    loginModel.getPassword().setIsChangable(true);
                    loginModel.getDomain().setIsChangable(true);
                    loginModel.getLoginCommand().setIsExecutionAllowed(true);
                    loginModel.getLoginFailedEvent().raise(this, EventArgs.Empty);
                } else {
                    raiseLoggedInEvent();
                }
                stopProgress();
            }
        }
    };
    Frontend.LoginAsync(fullUserName, (String) getPassword().getEntity(), StringHelper.isNullOrEmpty(domain) ? (String) getDomain().getSelectedItem() : domain, _asyncQuery);
}
#end_block

#method_before
@Override
public VdcActionParametersBase getParameters(VmPool incoming, org.ovirt.engine.core.common.businessentities.VmPool current) {
    final int currentVmCount = current.getAssignedVmsCount();
    int size = 0;
    if (incoming.isSetSize()) {
        // in case the value is negative, the backend command will fail on canDoAction
        size = incoming.getSize() - currentVmCount;
    }
    final org.ovirt.engine.core.common.businessentities.VmPool entity = map(incoming, current);
    final VM vm = mapToVM(map(entity));
    if (incoming.isSetTemplate()) {
        vm.setVmtGuid(new Guid(incoming.getTemplate().getId()));
    } else {
        final VM existing = currentVmCount > 0 ? getEntity(VM.class, SearchType.VM, "Vms: pool=" + incoming.getName()) : null;
        if (existing != null) {
            vm.setVmtGuid(existing.getVmtGuid());
        }
    }
    if (vm.getVmtGuid() != null) {
        final VmTemplate template = getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(vm.getId()), vm.getId().toString());
        vm.getStaticData().setMemSizeMb(template.getMemSizeMb());
    }
    final AddVmPoolWithVmsParameters parameters = new AddVmPoolWithVmsParameters(entity, vm, size, -1);
    parameters.setStorageDomainId(getStorageDomainId(vm.getVmtGuid()));
    return parameters;
}
#method_after
@Override
public VdcActionParametersBase getParameters(VmPool incoming, org.ovirt.engine.core.common.businessentities.VmPool current) {
    final int currentVmCount = current.getAssignedVmsCount();
    int size = 0;
    if (incoming.isSetSize()) {
        // in case the value is negative, the backend command will fail on canDoAction
        size = incoming.getSize() - currentVmCount;
    }
    final org.ovirt.engine.core.common.businessentities.VmPool entity = map(incoming, current);
    final VM vm = mapToVM(map(entity));
    if (incoming.isSetTemplate()) {
        vm.setVmtGuid(new Guid(incoming.getTemplate().getId()));
    } else {
        final VM existing = currentVmCount > 0 ? getEntity(VM.class, SearchType.VM, "Vms: pool=" + incoming.getName()) : null;
        if (existing != null) {
            vm.setVmtGuid(existing.getVmtGuid());
        }
    }
    if (vm.getVmtGuid() != null) {
        final VmTemplate template = getEntity(VmTemplate.class, VdcQueryType.GetVmTemplate, new GetVmTemplateParameters(vm.getId()), vm.getId().toString());
        vm.getStaticData().setMemSizeMb(template.getMemSizeMb());
        vm.getStaticData().setSingleQxlPci(template.getSingleQxlPci());
    }
    final AddVmPoolWithVmsParameters parameters = new AddVmPoolWithVmsParameters(entity, vm, size, -1);
    parameters.setStorageDomainId(getStorageDomainId(vm.getVmtGuid()));
    return parameters;
}
#end_block

#method_before
protected List<VmNetworkInterface> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNetworkInterface> vmNetworkInterfaces = DbFacade.getInstance().getVmNetworkInterfaceDao().getAllForTemplate(getVmTemplate().getId());
        _vmInterfaces = (vmNetworkInterfaces != null) ? vmNetworkInterfaces : new ArrayList<VmNetworkInterface>();
    }
    return _vmInterfaces;
}
#method_after
protected List<VmNic> getVmInterfaces() {
    if (_vmInterfaces == null) {
        List<VmNic> vmNetworkInterfaces = getVmNicDao().getAllForTemplate(getVmTemplate().getId());
        _vmInterfaces = vmNetworkInterfaces == null ? new ArrayList<VmNic>() : vmNetworkInterfaces;
    }
    return _vmInterfaces;
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.CheckCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, String compatibility_version, List<String> CanDoActionMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket) > Config.<Integer>GetValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>GetValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>GetValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.CheckCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkCpuSockets() {
    return AddVmCommand.checkCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected Collection<DiskImage> getImagesToCheckDestinationStorageDomains() {
    return getVmTemplate().getDiskMap().values();
}
#method_after
protected Collection<DiskImage> getImagesToCheckDestinationStorageDomains() {
    return getVmTemplate().getDiskTemplateMap().values();
}
#end_block

#method_before
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.VerifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#method_after
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions(newDiskImages);
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), newDiskImages, _vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled());
}
#end_block

#method_before
protected boolean areParametersLegal(List<String> reasons) {
    boolean returnValue = false;
    final VmStatic vmStaticData = getParameters().getVmStaticData();
    if (vmStaticData != null) {
        returnValue = IsLegalClusterId(vmStaticData.getVdsGroupId(), reasons);
        if (!validatePinningAndMigration(reasons, vmStaticData, getParameters().getVm().getCpuPinning())) {
            returnValue = false;
        }
        returnValue = returnValue && VmHandler.isMemorySizeLegal(vmStaticData.getOsId(), vmStaticData.getMemSizeMb(), reasons, getVdsGroup().getcompatibility_version());
    }
    return returnValue;
}
#method_after
protected boolean areParametersLegal(List<String> reasons) {
    boolean returnValue = false;
    final VmStatic vmStaticData = getParameters().getVmStaticData();
    if (vmStaticData != null) {
        returnValue = isLegalClusterId(vmStaticData.getVdsGroupId(), reasons);
        if (!validatePinningAndMigration(reasons, vmStaticData, getParameters().getVm().getCpuPinning())) {
            returnValue = false;
        }
        returnValue = returnValue && VmHandler.isMemorySizeLegal(vmStaticData.getOsId(), vmStaticData.getMemSizeMb(), reasons, getVdsGroup().getcompatibility_version());
    }
    return returnValue;
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNetworkInterface iface : getVmInterfaces()) {
        iface.setId(Guid.newGuid());
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        DbFacade.getInstance().getVmNetworkInterfaceDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#method_after
void addVmDynamic() {
    VmDynamic tempVar = new VmDynamic();
    tempVar.setId(getVmId());
    tempVar.setStatus(VMStatus.Down);
    tempVar.setVmHost("");
    tempVar.setVmIp("");
    tempVar.setVmFQDN("");
    tempVar.setDisplayType(getParameters().getVmStaticData().getDefaultDisplayType());
    VmDynamic vmDynamic = tempVar;
    DbFacade.getInstance().getVmDynamicDao().save(vmDynamic);
    getCompensationContext().snapshotNewEntity(vmDynamic);
}
#end_block

#method_before
protected boolean addVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                newDiskImages.add((DiskImage) result.getActionReturnValue());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (getVmTemplate().getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void addVmPermission() {
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissions perms = new permissions(getCurrentUser().getId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
        MultiLevelAdministrationHandler.addPermission(perms);
        getCompensationContext().snapshotNewEntity(perms);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        copyTemplatePermissions();
    }
}
#method_after
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#end_block

#method_before
private void copyTemplatePermissions() {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getCurrentUser().getId(), false);
    List<permissions> vmPermissions = new ArrayList<permissions>();
    for (permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        vmPermissions.add(new permissions(getCurrentUser().getId(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM));
    }
    if (vmPermissions.size() > 0) {
        MultiLevelAdministrationHandler.addPermission(vmPermissions.toArray(new permissions[vmPermissions.size()]));
        getCompensationContext().snapshotNewEntities(vmPermissions);
    }
}
#method_after
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getCurrentUser().getId(), false);
    for (permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#end_block

#method_before
protected void addDiskPermissions(List<DiskImage> newDiskImages) {
    permissions[] permsArray = new permissions[newDiskImages.size()];
    for (int i = 0; i < newDiskImages.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImages.get(i).getId(), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    permissions[] permsArray = new permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (validatePermissions()) {
        if (validateInputs()) {
            try {
                returnValue.setSucceeded(true);
                executeQueryCommand();
            } catch (RuntimeException ex) {
                returnValue.setSucceeded(false);
                Throwable th = ex instanceof VdcBLLException ? ex : ex.getCause();
                if (th != null && th instanceof VdcBLLException) {
                    VdcBLLException vdcExc = (VdcBLLException) th;
                    if (vdcExc.getErrorCode() != null) {
                        returnValue.setExceptionString(vdcExc.getErrorCode().toString());
                    } else {
                        returnValue.setExceptionString(vdcExc.getMessage());
                    }
                    log.errorFormat("Query {0} failed. Exception message is {1}", getClass().getSimpleName(), vdcExc.getMessage());
                    if (log.isDebugEnabled()) {
                        log.debugFormat("Detailed stacktrace:", vdcExc);
                    }
                } else {
                    returnValue.setExceptionString(ex.getMessage());
                    log.errorFormat("Query {0} failed. Exception message is {1}", getClass().getSimpleName(), ex.getMessage());
                    if (log.isDebugEnabled()) {
                        log.debugFormat("Detailed stacktrace:", ex);
                    }
                }
            }
        } else {
            log.error("Query execution failed due to invalid inputs. " + returnValue.getExceptionString());
        }
    } else {
        String errMessage = "Query execution failed due to insufficient permissions.";
        log.error(errMessage);
        returnValue.setExceptionString(errMessage);
    }
}
#method_after
@Override
protected void executeCommand() {
    if (validatePermissions()) {
        if (validateInputs()) {
            try {
                returnValue.setSucceeded(true);
                executeQueryCommand();
            } catch (RuntimeException ex) {
                returnValue.setSucceeded(false);
                Throwable th = ex instanceof VdcBLLException ? ex : ex.getCause();
                if (th instanceof VdcBLLException) {
                    VdcBLLException vdcExc = (VdcBLLException) th;
                    if (vdcExc.getErrorCode() != null) {
                        returnValue.setExceptionString(vdcExc.getErrorCode().toString());
                    } else {
                        returnValue.setExceptionString(vdcExc.getMessage());
                    }
                    log.errorFormat("Query {0} failed. Exception message is {1}", getClass().getSimpleName(), vdcExc.getMessage());
                    if (log.isDebugEnabled()) {
                        log.debugFormat("Detailed stacktrace:", vdcExc);
                    }
                } else {
                    returnValue.setExceptionString(ex.getMessage());
                    log.errorFormat("Query {0} failed. Exception message is {1}", getClass().getSimpleName(), ex.getMessage());
                    if (log.isDebugEnabled()) {
                        log.debugFormat("Detailed stacktrace:", ex);
                    }
                }
            }
        } else {
            log.error("Query execution failed due to invalid inputs. " + returnValue.getExceptionString());
        }
    } else {
        String errMessage = "Query execution failed due to insufficient permissions.";
        log.error(errMessage);
        returnValue.setExceptionString(errMessage);
    }
}
#end_block

#method_before
private String getConsoleUserName(DbUser user) {
    String domain = user.getDomain();
    String name = user.getLoginName();
    if (StringUtils.isEmpty(name) || name.contains("@") || StringUtils.isEmpty(domain)) {
        return name;
    } else {
        return name + "@" + domain;
    }
}
#method_after
String getConsoleUserName() {
    DbUser user = getCurrentUser();
    String domain = user.getDomain();
    String name = user.getLoginName();
    if (StringUtils.isEmpty(name)) {
        return null;
    }
    if (name.contains("@") || StringUtils.isEmpty(domain)) {
        return name;
    }
    return name + "@" + domain;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    // Check that the virtual machine is in state that allows connections
    // to the console:
    final VMStatus status = vm.getStatus();
    if (status != VMStatus.Up && status != VMStatus.Paused && status != VMStatus.PoweringUp && status != VMStatus.PoweringDown && status != VMStatus.RebootInProgress) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        return false;
    }
    // subjects:
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // Check that the virtual machine is in state that allows connections
    // to the console:
    final VMStatus status = vm.getStatus();
    if (status != VMStatus.Up && status != VMStatus.Paused && status != VMStatus.PoweringUp && status != VMStatus.PoweringDown && status != VMStatus.RebootInProgress) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
    }
    // subjects:
    return true;
}
#end_block

#method_before
private static void handleNotLoggedInEvent(String errorMessage) {
    if (errorMessage != null && errorMessage.equals("USER_IS_NOT_LOGGED_IN")) {
        // $NON-NLS-1$
        frontendNotLoggedInEvent.raise(Frontend.class, EventArgs.Empty);
    }
}
#method_after
private static void handleNotLoggedInEvent(String errorMessage) {
    if ("USER_IS_NOT_LOGGED_IN".equals(errorMessage)) {
        // $NON-NLS-1$
        frontendNotLoggedInEvent.raise(Frontend.class, EventArgs.Empty);
    }
}
#end_block

#method_before
static void RunMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, final GenericApiGWTServiceAsync service) {
    if (actionTypes.isEmpty() || parameters.isEmpty() || callbacks.isEmpty()) {
        return;
    }
    runActionImpl(actionTypes.get(0), parameters.get(0), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(final FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success || failureCallback == null) {
                IFrontendActionAsyncCallback callback = callbacks.get(0);
                if (callback != null) {
                    callback.executed(result);
                }
                actionTypes.remove(0);
                parameters.remove(0);
                callbacks.remove(0);
                RunMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, service);
            } else {
                failureCallback.executed(result);
            }
        }
    }, state, true, service);
}
#method_after
public static void RunMultipleActions(VdcActionType actionType, List<VdcActionParametersBase> parameters, List<IFrontendActionAsyncCallback> callbacks) {
    RunMultipleActions(actionType, parameters, callbacks, null);
}
#end_block

#method_before
public static void RunMultipleActions(VdcActionType actionType, List<VdcActionParametersBase> parameters, IFrontendActionAsyncCallback successCallback, Object state) {
    if (parameters == null || parameters.isEmpty()) {
        return;
    }
    int n = parameters.size();
    VdcActionType[] actionTypes = new VdcActionType[n];
    IFrontendActionAsyncCallback[] callbacks = new IFrontendActionAsyncCallback[n];
    Arrays.fill(actionTypes, actionType);
    callbacks[n - 1] = successCallback;
    RunMultipleActions(new LinkedList<VdcActionType>(Arrays.asList(actionTypes)), parameters, new LinkedList<IFrontendActionAsyncCallback>(Arrays.asList(callbacks)), null, state);
}
#method_after
public static void RunMultipleActions(VdcActionType actionType, List<VdcActionParametersBase> parameters, IFrontendActionAsyncCallback successCallback, Object state) {
    if (parameters == null || parameters.isEmpty()) {
        return;
    }
    int n = parameters.size();
    IFrontendActionAsyncCallback[] callbacks = new IFrontendActionAsyncCallback[n];
    callbacks[n - 1] = successCallback;
    RunMultipleActions(actionType, parameters, new LinkedList<IFrontendActionAsyncCallback>(Arrays.asList(callbacks)), state);
}
#end_block

#method_before
static void LoginAsync(final String userName, final String password, final String domain, final AsyncQuery callback, final GenericApiGWTServiceAsync service) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async Login.");
    service.Login(userName, password, domain, new AsyncCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from Login.");
            setLoggedInUser(null);
            callback.getDel().onSuccess(callback.getModel(), result);
            setLoginPassword(null);
            if (getLoginHandler() != null && result.getSucceeded()) {
                getLoginHandler().onLoginSuccess(userName, password, domain);
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            if (callback.isHandleFailure()) {
                setLoggedInUser(null);
                callback.getDel().onSuccess(callback.getModel(), null);
                setLoginPassword(null);
            }
        }
    });
}
#method_after
static void LoginAsync(final String userName, final String password, final String domain, final AsyncQuery callback, final GenericApiGWTServiceAsync service) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async Login.");
    service.Login(userName, password, domain, new AsyncCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from Login.");
            clearLoggedInUser();
            result.setCanDoActionMessages((ArrayList<String>) translateError(result));
            callback.getDel().onSuccess(callback.getModel(), result);
            if (getLoginHandler() != null && result.getSucceeded()) {
                getLoginHandler().onLoginSuccess(userName, password, domain);
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            if (callback.isHandleFailure()) {
                clearLoggedInUser();
                callback.getDel().onSuccess(callback.getModel(), null);
            }
        }
    });
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    VM vm = getVm();
    if (vm != null) {
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded();
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!isVmExist() || !acquireLockInternal()) {
        return false;
    }
    VM vm = getVm();
    if (vm != null) {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        updateDisksFromDb();
        // if user sent drive check that its not in use
        if (!isDiskCanBeAddedToVm(getParameters().getDiskInfo(), vm) || !isDiskPassPciAndIdeLimit(getParameters().getDiskInfo())) {
            return false;
        }
    }
    if (DiskStorageType.IMAGE == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfImageDiskCanBeAdded(vm);
    }
    if (DiskStorageType.LUN == getParameters().getDiskInfo().getDiskStorageType()) {
        return checkIfLunDiskCanBeAdded();
    }
    return true;
}
#end_block

#method_before
protected boolean checkIfLunDiskCanBeAdded() {
    LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    DiskValidator diskValidator = new DiskValidator(getParameters().getDiskInfo());
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean checkIfLunDiskCanBeAdded() {
    LUNs lun = ((LunDisk) getParameters().getDiskInfo()).getLun();
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    switch(lun.getLunType()) {
        case UNKNOWN:
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_HAS_NO_VALID_TYPE);
        case ISCSI:
            if (lun.getLunConnections() == null || lun.getLunConnections().isEmpty()) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
            }
            for (StorageServerConnections conn : lun.getLunConnections()) {
                if (StringUtils.isEmpty(conn.getiqn()) || StringUtils.isEmpty(conn.getconnection()) || StringUtils.isEmpty(conn.getport())) {
                    return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_ISCSI_MISSING_CONNECTION_PARAMS);
                }
            }
            break;
    }
    if (getDiskLunMapDao().getDiskIdByLunId(lun.getLUN_id()) != null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_LUN_IS_ALREADY_IN_USE);
    }
    if (getVm() != null && !(isVmNotLocked() && isVmNotInPreviewSnapshot())) {
        return false;
    }
    if (!validate(diskValidator.isVirtIoScsiValid(getVm()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean checkIfImageDiskCanBeAdded(VM vm) {
    boolean returnValue;
    DiskValidator diskValidator = new DiskValidator(getParameters().getDiskInfo());
    // vm agnostic checks
    returnValue = validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive()) && checkImageConfiguration() && hasFreeSpace(getStorageDomain()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#method_after
private boolean checkIfImageDiskCanBeAdded(VM vm) {
    boolean returnValue;
    DiskValidator diskValidator = getDiskValidator(getParameters().getDiskInfo());
    // vm agnostic checks
    returnValue = validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive()) && checkImageConfiguration() && hasFreeSpace(getStorageDomain()) && checkExceedingMaxBlockDiskSize() && canAddShareableDisk() && validate(diskValidator.isVirtIoScsiValid(vm));
    if (returnValue && vm != null) {
        // Note this is done according to the VM's spId.
        StoragePool sp = getStoragePool();
        returnValue = validate(new StoragePoolValidator(sp).isUp()) && isStoragePoolMatching(vm) && isVmNotLocked() && isVmNotInPreviewSnapshot();
    }
    return returnValue;
}
#end_block

#method_before
protected boolean checkImageConfiguration() {
    return ImagesHandler.CheckImageConfiguration(getStorageDomain().getStorageStaticData(), getDiskImageInfo(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkImageConfiguration() {
    return ImagesHandler.checkImageConfiguration(getStorageDomain().getStorageStaticData(), getDiskImageInfo(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#method_after
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    profileList = new VnicProfileListModel();
    list.add(profileList);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#end_block

#method_before
private void tagListModel_SelectedItemsChanged(Object sender, EventArgs e) {
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    boolean hadSelectedTags = getHasSelectedTags();
    updateHasSelectedTags();
    dataCenterList.setIsAvailable(!getHasSelectedTags());
    clusterList.setIsAvailable(!getHasSelectedTags());
    hostList.setIsAvailable(true);
    storageList.setIsAvailable(!getHasSelectedTags());
    vmList.setIsAvailable(true);
    volumeList.setIsAvailable(true);
    poolList.setIsAvailable(!getHasSelectedTags());
    templateList.setIsAvailable(!getHasSelectedTags());
    userList.setIsAvailable(true);
    eventList.setIsAvailable(!getHasSelectedTags());
    reportsList.setIsAvailable(ReportInit.getInstance().isReportsEnabled() && !getHasSelectedTags());
    networkList.setIsAvailable(!getHasSelectedTags());
    providerList.setIsAvailable(!getHasSelectedTags());
    // Switch the selected item as neccessary.
    ListModel oldSelectedItem = getSelectedItem();
    if (getHasSelectedTags() && oldSelectedItem != hostList && oldSelectedItem != volumeList && oldSelectedItem != vmList && oldSelectedItem != userList) {
        setSelectedItem(vmList);
    } else // Update search string only when selecting or de-selecting tags
    if (getHasSelectedTags() || hadSelectedTags) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        searchStringChanged();
    }
}
#method_after
private void tagListModel_SelectedItemsChanged(Object sender, EventArgs e) {
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    boolean hadSelectedTags = getHasSelectedTags();
    updateHasSelectedTags();
    if (getHasSelectedTags()) {
        setAllListModelsUnavailable();
        hostList.setIsAvailable(true);
        vmList.setIsAvailable(true);
        userList.setIsAvailable(true);
    } else {
        updateAvailability(SystemTreeItemType.System, null);
    }
    // Switch the selected item as neccessary.
    ListModel oldSelectedItem = getSelectedItem();
    if (getHasSelectedTags() && oldSelectedItem != hostList && oldSelectedItem != volumeList && oldSelectedItem != vmList && oldSelectedItem != userList) {
        setSelectedItem(vmList);
    } else // Update search string only when selecting or de-selecting tags
    if (getHasSelectedTags() || hadSelectedTags) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        searchStringChanged();
    }
}
#end_block

#method_before
private void bookmarkListModel_Navigated(Object sender, BookmarkEventArgs e) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    for (SearchableListModel item : getItems()) {
        item.setIsAvailable(true);
    }
    // $NON-NLS-1$
    setSearchStringPrefix("");
    setSearchString(e.getBookmark().getbookmark_value());
    getSearchCommand().execute();
}
#method_after
private void bookmarkListModel_Navigated(Object sender, BookmarkEventArgs e) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    // Reset system tree to the root item.
    getSystemTree().getSelectedItemChangedEvent().removeListener(this);
    getSystemTree().getResetCommand().execute();
    getSystemTree().getSelectedItemChangedEvent().addListener(this);
    // the main tabs that should appear when a bookmark is selected should
    // be the exact same main tabs that are displayed when the "System" node
    // in the system tree is selected.
    updateAvailability(SystemTreeItemType.System, null);
    // $NON-NLS-1$
    setSearchStringPrefix("");
    setSearchString(e.getBookmark().getbookmark_value());
    getSearchCommand().execute();
}
#end_block

#method_before
private void systemTree_ItemChanged(Object sender, EventArgs args) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    updateHasSelectedTags();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    if (model == null) {
        return;
    }
    // Update items availability depending on system tree selection.
    dataCenterList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.DataCenters);
    clusterList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Clusters || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.Network || model.getType() == SystemTreeItemType.System);
    hostList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Hosts || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.Network || model.getType() == SystemTreeItemType.System);
    volumeList.setIsAvailable(model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Volume || model.getType() == SystemTreeItemType.Volumes || model.getType() == SystemTreeItemType.System);
    if (model.getType() == SystemTreeItemType.Cluster) {
        volumeList.setIsAvailable(false);
    }
    storageList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Storages || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.System);
    quotaList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter);
    boolean isDataStorage = false;
    if (model.getType() == SystemTreeItemType.Storage) {
        StorageDomain storage = (StorageDomain) model.getEntity();
        isDataStorage = storage.getStorageDomainType() == StorageDomainType.Data || storage.getStorageDomainType() == StorageDomainType.Master;
    }
    diskList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || isDataStorage || model.getType() == SystemTreeItemType.System);
    vmList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Network || isDataStorage || model.getType() == SystemTreeItemType.VMs || model.getType() == SystemTreeItemType.System);
    poolList.setIsAvailable(model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster);
    templateList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Network || isDataStorage || model.getType() == SystemTreeItemType.Templates || model.getType() == SystemTreeItemType.System);
    if (model.getType() == SystemTreeItemType.Cluster_Gluster) {
        VDSGroup cluster = (VDSGroup) model.getEntity();
        if (!cluster.supportsVirtService()) {
            vmList.setIsAvailable(false);
            templateList.setIsAvailable(false);
            storageList.setIsAvailable(false);
            poolList.setIsAvailable(false);
        }
    }
    userList.setIsAvailable(model.getType() == SystemTreeItemType.System);
    eventList.setIsAvailable(model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Cluster_Gluster || model.getType() == SystemTreeItemType.Host || model.getType() == SystemTreeItemType.Storage || model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.Volume);
    reportsList.setIsAvailable(ReportInit.getInstance().isReportsEnabled() && ReportInit.getInstance().getDashboard(model.getType().toString()) != null);
    networkList.setIsAvailable(model.getType() == SystemTreeItemType.Network || model.getType() == SystemTreeItemType.Networks || model.getType() == SystemTreeItemType.System || model.getType() == SystemTreeItemType.DataCenter || model.getType() == SystemTreeItemType.Cluster || model.getType() == SystemTreeItemType.Host);
    providerList.setIsAvailable(model.getType() == SystemTreeItemType.Providers || model.getType() == SystemTreeItemType.Provider);
    // Select a default item depending on system tree selection.
    ListModel oldSelectedItem = getSelectedItem();
    // Do not Change Tab if the Selection is the Reports
    if (!reportsList.getIsAvailable() || getSelectedItem() != reportsList) {
        changeSelectedTabIfNeeded(model);
    } else {
        reportsList.refreshReportModel();
    }
    // search string will be updated in OnSelectedItemChanged method.
    if (getSelectedItem() == oldSelectedItem) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        if (getSelectedItem() instanceof ISupportSystemTreeContext) {
            ISupportSystemTreeContext treeContext = (ISupportSystemTreeContext) getSelectedItem();
            treeContext.setSystemTreeSelectedItem((SystemTreeItemModel) getSystemTree().getSelectedItem());
        }
    }
}
#method_after
private void systemTree_ItemChanged(Object sender, EventArgs args) {
    // Reset tags tree to the root item.
    getTagList().getSelectedItemsChangedEvent().removeListener(this);
    getTagList().getResetCommand().execute();
    updateHasSelectedTags();
    getTagList().getSelectedItemsChangedEvent().addListener(this);
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    if (model == null) {
        return;
    }
    updateAvailability(model.getType(), model.getEntity());
    // Select a default item depending on system tree selection.
    ListModel oldSelectedItem = getSelectedItem();
    // Do not Change Tab if the Selection is the Reports
    if (!reportsList.getIsAvailable() || getSelectedItem() != reportsList) {
        changeSelectedTabIfNeeded(model);
    } else {
        reportsList.refreshReportModel();
    }
    // search string will be updated in OnSelectedItemChanged method.
    if (getSelectedItem() == oldSelectedItem) {
        // $NON-NLS-1$
        String prefix = "";
        // $NON-NLS-1$
        String search = "";
        RefObject<String> tempRef_prefix = new RefObject<String>(prefix);
        RefObject<String> tempRef_search = new RefObject<String>(search);
        splitSearchString(getSelectedItem().getDefaultSearchString(), tempRef_prefix, tempRef_search);
        prefix = tempRef_prefix.argvalue;
        search = tempRef_search.argvalue;
        setSearchStringPrefix(prefix);
        setSearchString(search);
        getSearchCommand().execute();
        if (getSelectedItem() instanceof ISupportSystemTreeContext) {
            ISupportSystemTreeContext treeContext = (ISupportSystemTreeContext) getSelectedItem();
            treeContext.setSystemTreeSelectedItem((SystemTreeItemModel) getSystemTree().getSelectedItem());
        }
    }
}
#end_block

#method_before
private void splitSearchString(String source, RefObject<String> prefix, RefObject<String> search) {
    ArrayList<TagModel> tags = (ArrayList<TagModel>) getTagList().getSelectedItems();
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    // $NON-NLS-1$
    prefix.argvalue = "";
    // Split for tags.
    if (tags != null && tags.size() > 0) {
        // $NON-NLS-1$
        Regex regex = new Regex("tag\\s*=\\s*(?:[\\w-]+)(?:\\sor\\s)?", RegexOptions.IgnoreCase);
        // $NON-NLS-1$
        String[] array = source.split("[:]", -1);
        String entityClause = array[0];
        String searchClause = array[1];
        StringBuilder tagsClause = new StringBuilder();
        for (TagModel tag : tags) {
            // $NON-NLS-1$
            tagsClause.append("tag=").append(tag.getName().getEntity());
            if (tag != tags.get(tags.size() - 1)) {
                // $NON-NLS-1$
                tagsClause.append(" or ");
            }
        }
        // $NON-NLS-1$
        prefix.argvalue = entityClause + ": " + tagsClause.toString();
        // $NON-NLS-1$
        search.argvalue = regex.replace(searchClause, "").trim();
    } else // Split for system tree.
    if (model != null && model.getType() != SystemTreeItemType.System) {
        // $NON-NLS-1$ //$NON-NLS-2$
        getAutoCompleteModel().setFilter(new String[] { "or", "and" });
        switch(model.getType()) {
            case DataCenters:
                if (dataCenterList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "DataCenter:";
                }
                break;
            case DataCenter:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: datacenter = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: datacenter = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_datacenter = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Disk: datacenter.name = " + model.getTitle() + " and disk_type = image";
                    } else if (quotaList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Quota: storagepoolname = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: datacenter = " + model.getTitle();
                    }
                }
                break;
            case Clusters:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Cluster:
            case Cluster_Gluster:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + model.getTitle();
                    } else if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: cluster.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: cluster = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: cluster = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Cluster_network.cluster_name = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: cluster = " + model.getTitle();
                    }
                }
                break;
            case Hosts:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Host:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: host.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: Hosts.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: Hosts.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: host.name = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Host_network.host_name = " + model.getTitle();
                    }
                }
                break;
            case Volumes:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Volume:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Volume: name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: volume.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Events: volume.name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    }
                }
                break;
            case Storages:
                {
                    if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Storage:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: storage.name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: storage.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: storage.name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: storage.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Templates: storage.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_storage = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Disk: storages.name = " + model.getTitle();
                    }
                }
                break;
            case Templates:
                {
                    if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case VMs:
                {
                    if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model).getTitle();
                    }
                }
                break;
            case Networks:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Network:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Network: name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Cluster: Cluster_network.network_name = " + model.getTitle() + " Datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Host : Nic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Vm : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Template : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Providers:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider:";
                }
                break;
            case Provider:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider: name = " + model.getTitle();
                }
                break;
        }
        // $NON-NLS-1$
        prefix.argvalue = prefix.argvalue + " ";
        // $NON-NLS-1$
        search.argvalue = "";
    } else {
        search.argvalue = source;
        getAutoCompleteModel().setFilter(null);
    }
}
#method_after
private void splitSearchString(String source, RefObject<String> prefix, RefObject<String> search) {
    ArrayList<TagModel> tags = (ArrayList<TagModel>) getTagList().getSelectedItems();
    SystemTreeItemModel model = (SystemTreeItemModel) getSystemTree().getSelectedItem();
    // $NON-NLS-1$
    prefix.argvalue = "";
    // Split for tags.
    if (tags != null && tags.size() > 0) {
        // $NON-NLS-1$
        Regex regex = new Regex("tag\\s*=\\s*(?:[\\w-]+)(?:\\sor\\s)?", RegexOptions.IgnoreCase);
        // $NON-NLS-1$
        String[] array = source.split("[:]", -1);
        String entityClause = array[0];
        String searchClause = array[1];
        StringBuilder tagsClause = new StringBuilder();
        for (TagModel tag : tags) {
            // $NON-NLS-1$
            tagsClause.append("tag=").append(tag.getName().getEntity());
            if (tag != tags.get(tags.size() - 1)) {
                // $NON-NLS-1$
                tagsClause.append(" or ");
            }
        }
        // $NON-NLS-1$
        prefix.argvalue = entityClause + ": " + tagsClause.toString();
        // $NON-NLS-1$
        search.argvalue = regex.replace(searchClause, "").trim();
    } else // Split for system tree.
    if (model != null && model.getType() != SystemTreeItemType.System) {
        // $NON-NLS-1$ //$NON-NLS-2$
        getAutoCompleteModel().setFilter(new String[] { "or", "and" });
        switch(model.getType()) {
            case DataCenters:
                if (dataCenterList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "DataCenter:";
                }
                break;
            case DataCenter:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: datacenter = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: datacenter = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_datacenter = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Disk: datacenter.name = " + model.getTitle() + " and disk_type = image";
                    } else if (quotaList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Quota: storagepoolname = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: datacenter = " + model.getTitle();
                    } else if (profileList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "VnicProfile: datacenter = " + model.getTitle();
                    }
                }
                break;
            case Clusters:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Cluster:
            case Cluster_Gluster:
                {
                    if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + model.getTitle();
                    } else if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: cluster.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: cluster = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: cluster = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Cluster_network.cluster_name = " + model.getTitle();
                    } else if (poolList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Pools: cluster = " + model.getTitle();
                    }
                }
                break;
            case Hosts:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Host:
                {
                    if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: host.name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: Hosts.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: Hosts.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: host.name = " + model.getTitle();
                    } else if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: Host_network.host_name = " + model.getTitle();
                    }
                }
                break;
            case Volumes:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        SystemTreeItemModel cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (cluster == null) {
                            cluster = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Volume: cluster = " + cluster.getTitle();
                    }
                }
                break;
            case Volume:
                {
                    if (volumeList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Volume: name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: volume.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Events: volume.name = " + model.getTitle() + " cluster = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model).getTitle();
                    }
                }
                break;
            case Storages:
                {
                    if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Storage:
                {
                    if (dataCenterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "DataCenter: storage.name = " + model.getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Cluster: storage.name = " + model.getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Host: storage.name = " + model.getTitle();
                    } else if (storageList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Storage: name = " + model.getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: storage.name = " + model.getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Templates: storage.name = " + model.getTitle();
                    } else if (eventList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Events: event_storage = " + model.getTitle();
                    } else if (diskList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Disk: storages.name = " + model.getTitle();
                    }
                }
                break;
            case Templates:
                {
                    if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Template: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case VMs:
                {
                    if (vmList.isSearchStringMatch(source)) {
                        SystemTreeItemModel ancestor = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster, model);
                        if (ancestor == null) {
                            ancestor = SystemTreeItemModel.findAncestor(SystemTreeItemType.Cluster_Gluster, model);
                        }
                        // $NON-NLS-1$
                        prefix.argvalue = "Vms: cluster = " + ancestor.getTitle();
                    }
                }
                break;
            case Networks:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$
                        prefix.argvalue = "Network: datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Network:
                {
                    if (networkList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Network: name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (clusterList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Cluster: Cluster_network.network_name = " + model.getTitle() + " Datacenter.name = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (hostList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Host : Nic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (vmList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Vm : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (templateList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "Template : Vnic.network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    } else if (profileList.isSearchStringMatch(source)) {
                        // $NON-NLS-1$ //$NON-NLS-2$
                        prefix.argvalue = "VnicProfile : network_name = " + model.getTitle() + " datacenter = " + SystemTreeItemModel.findAncestor(SystemTreeItemType.DataCenter, model).getTitle();
                    }
                }
                break;
            case Providers:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider:";
                }
                break;
            case Provider:
                if (providerList.isSearchStringMatch(source)) {
                    // $NON-NLS-1$
                    prefix.argvalue = "Provider: name = " + model.getTitle();
                }
                break;
        }
        // $NON-NLS-1$
        prefix.argvalue = prefix.argvalue + " ";
        // $NON-NLS-1$
        search.argvalue = "";
    } else {
        search.argvalue = source;
        getAutoCompleteModel().setFilter(null);
    }
}
#end_block

#method_before
@Override
public DbUser mapRow(ResultSet rs, int rowNum) throws SQLException {
    DbUser entity = new DbUser();
    entity.setDepartment(rs.getString("department"));
    entity.setDomain(rs.getString("domain"));
    entity.setEmail(rs.getString("email"));
    entity.setGroupNames(rs.getString("groups"));
    entity.setFirstName(rs.getString("name"));
    entity.setNote(rs.getString("note"));
    entity.setNote(rs.getString("note"));
    entity.setRole(rs.getString("role"));
    entity.setStatus(rs.getInt("status"));
    entity.setLastName(rs.getString("surname"));
    entity.setId(getGuidDefaultEmpty(rs, "user_id"));
    entity.setLoginName(rs.getString("username"));
    entity.setAdmin(rs.getBoolean("last_admin_check_status"));
    entity.setGroupIds(rs.getString("group_ids"));
    entity.setExternalId(rs.getBytes("external_id"));
    return entity;
}
#method_after
@Override
public DbUser mapRow(ResultSet rs, int rowNum) throws SQLException {
    DbUser entity = new DbUser();
    entity.setDepartment(rs.getString("department"));
    entity.setDomain(rs.getString("domain"));
    entity.setEmail(rs.getString("email"));
    entity.setGroupNames(rs.getString("groups"));
    entity.setFirstName(rs.getString("name"));
    entity.setNote(rs.getString("note"));
    entity.setNote(rs.getString("note"));
    entity.setRole(rs.getString("role"));
    entity.setStatus(rs.getInt("status"));
    entity.setLastName(rs.getString("surname"));
    entity.setId(getGuidDefaultEmpty(rs, "user_id"));
    entity.setLoginName(rs.getString("username"));
    entity.setAdmin(rs.getBoolean("last_admin_check_status"));
    entity.setGroupIds(rs.getString("group_ids"));
    entity.setExternalId(new ExternalId(rs.getBytes("external_id")));
    return entity;
}
#end_block

#method_before
@Override
public DbUser getByExternalId(String domain, byte[] externalId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("domain", domain).addValue("external_id", externalId);
    return getCallsHandler().executeRead("GetUserByExternalId", DbUserRowMapper.instance, parameterSource);
}
#method_after
@Override
public DbUser getByExternalId(String domain, ExternalId externalId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("domain", domain).addValue("external_id", externalId.getBytes());
    return getCallsHandler().executeRead("GetUserByExternalId", DbUserRowMapper.instance, parameterSource);
}
#end_block

#method_before
@Override
public Principal validate(String sessionId) {
    Principal principal = null;
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setSessionId(sessionId);
    VdcQueryReturnValue queryReturnValue = backend.RunPublicQuery(VdcQueryType.ValidateSession, params);
    if (queryReturnValue != null) {
        DbUser user = (DbUser) queryReturnValue.getReturnValue();
        if (user != null) {
            principal = new Principal(user.getLoginName(), null, user.getDomain());
            sessionHelper.setSessionId(sessionId);
            current.set(user);
        }
    }
    if (principal != null) {
        validateSessionSucceeded(queryReturnValue);
    } else {
        validateSessionFailed(queryReturnValue);
    }
    return principal;
}
#method_after
@Override
public Principal validate(String sessionId) {
    Principal principal = null;
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setSessionId(sessionId);
    VdcQueryReturnValue queryReturnValue = backend.RunPublicQuery(VdcQueryType.ValidateSession, params);
    if (queryReturnValue != null) {
        DbUser user = queryReturnValue.getReturnValue();
        if (user != null) {
            principal = new Principal(user.getLoginName(), null, user.getDomain());
            sessionHelper.setSessionId(sessionId);
            current.set(user);
        }
    }
    if (principal != null) {
        validateSessionSucceeded(queryReturnValue);
    } else {
        validateSessionFailed(queryReturnValue);
    }
    return principal;
}
#end_block

#method_before
private boolean runQuery(HttpServletRequest request, HttpServletResponse response, String sessionID) {
    BackendInternal backend = null;
    VdcQueryParametersBase params = null;
    VdcQueryReturnValue queryReturnValue = null;
    boolean returnValue = false;
    backend = (BackendInternal) EjbUtils.findBean(BeanType.BACKEND, BeanProxyType.LOCAL);
    log.debug("Calling ValidateSession query");
    params = new VdcQueryParametersBase();
    params.setSessionId(sessionID);
    queryReturnValue = backend.runInternalQuery(VdcQueryType.ValidateSession, params);
    if (queryReturnValue != null) {
        returnValue = queryReturnValue.getSucceeded();
        if (returnValue) {
            DbUser user = (DbUser) queryReturnValue.getReturnValue();
            // We get the user name only in case the validation succeeded, and the user is an administrator
            if (user.isAdmin()) {
                log.debug("Getting user name");
                printUPNToResponse(response, getUPN(user));
            } else {
                log.error("User is not authorized to perform operation");
                returnValue = false;
            }
        }
    } else {
        log.error("Got NULL from backend.RunQuery");
    }
    return returnValue;
}
#method_after
private boolean runQuery(HttpServletRequest request, HttpServletResponse response, String sessionID) {
    BackendInternal backend = null;
    VdcQueryParametersBase params = null;
    VdcQueryReturnValue queryReturnValue = null;
    boolean returnValue = false;
    backend = (BackendInternal) EjbUtils.findBean(BeanType.BACKEND, BeanProxyType.LOCAL);
    log.debug("Calling ValidateSession query");
    params = new VdcQueryParametersBase();
    params.setSessionId(sessionID);
    queryReturnValue = backend.runInternalQuery(VdcQueryType.ValidateSession, params);
    if (queryReturnValue != null) {
        returnValue = queryReturnValue.getSucceeded();
        if (returnValue) {
            DbUser user = queryReturnValue.getReturnValue();
            // We get the user name only in case the validation succeeded, and the user is an administrator
            if (user.isAdmin()) {
                log.debug("Getting user name");
                printUPNToResponse(response, getUPN(user));
            } else {
                log.error("User is not authorized to perform operation");
                returnValue = false;
            }
        }
    } else {
        log.error("Got NULL from backend.RunQuery");
    }
    return returnValue;
}
#end_block

#method_before
protected void addStoragePoolToDb() {
    getStoragePool().setId(Guid.newGuid());
    getStoragePool().setstatus(StoragePoolStatus.Uninitialized);
    getStoragePoolDAO().save(getStoragePool());
}
#method_after
protected void addStoragePoolToDb() {
    getStoragePool().setId(Guid.newGuid());
    getStoragePool().setStatus(StoragePoolStatus.Uninitialized);
    getStoragePoolDAO().save(getStoragePool());
}
#end_block

#method_before
private void addDefaultNetworks() {
    Network net = new Network();
    net.setId(Guid.newGuid());
    net.setName(NetworkUtils.getEngineNetwork());
    net.setDescription(AddVdsGroupCommand.DefaultNetworkDescription);
    net.setDataCenterId(getStoragePool().getId());
    net.setVmNetwork(true);
    getNetworkDAO().save(net);
    NetworkHelper.addPermissions(getCurrentUser().getId(), net.getId(), true);
}
#method_after
private void addDefaultNetworks() {
    Network net = new Network();
    net.setId(Guid.newGuid());
    net.setName(NetworkUtils.getEngineNetwork());
    net.setDescription(AddVdsGroupCommand.DefaultNetworkDescription);
    net.setDataCenterId(getStoragePool().getId());
    net.setVmNetwork(true);
    getNetworkDAO().save(net);
    NetworkHelper.addPermissionsOnNetwork(getCurrentUser().getId(), net.getId());
    VnicProfile profile = NetworkHelper.createVnicProfile(net);
    getVnicProfileDao().save(profile);
    NetworkHelper.addPermissionsOnVnicProfile(getCurrentUser().getId(), profile.getId(), true);
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removePermissionTitle());
    // $NON-NLS-1$
    model.setHashName("remove_permission");
    model.setMessage(ConstantsManager.getInstance().getConstants().permissionMsg());
    ArrayList<String> items = new ArrayList<String>();
    for (Object a : getSelectedItems()) {
        // $NON-NLS-1$ //$NON-NLS-2$
        items.add("Role " + ((permissions) a).getRoleName() + " on User " + ((permissions) a).getOwnerName());
    }
    model.setItems(items);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removePermissionTitle());
    // $NON-NLS-1$
    model.setHashName("remove_permission");
    model.setMessage(ConstantsManager.getInstance().getConstants().permissionMsg());
    model.setItems(getSelectedItems());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
protected VdcObjectType getObjectType() {
    if (getEntity() instanceof VM) {
        return VdcObjectType.VM;
    }
    if (getEntity() instanceof StoragePool) {
        return VdcObjectType.StoragePool;
    }
    if (getEntity() instanceof VDSGroup) {
        return VdcObjectType.VdsGroups;
    }
    if (getEntity() instanceof VDS) {
        return VdcObjectType.VDS;
    }
    if (getEntity() instanceof StorageDomain) {
        return VdcObjectType.Storage;
    }
    if (getEntity() instanceof VmTemplate) {
        return VdcObjectType.VmTemplate;
    }
    if (getEntity() instanceof VmPool) {
        return VdcObjectType.VmPool;
    }
    if (getEntity() instanceof Quota) {
        return VdcObjectType.Quota;
    }
    if (getEntity() instanceof GlusterVolumeEntity) {
        return VdcObjectType.GlusterVolume;
    }
    if (getEntity() instanceof DiskImage) {
        return VdcObjectType.Disk;
    }
    if (getEntity() instanceof Network) {
        return VdcObjectType.Network;
    }
    return VdcObjectType.Unknown;
}
#method_after
protected VdcObjectType getObjectType() {
    if (getEntity() instanceof VM) {
        return VdcObjectType.VM;
    }
    if (getEntity() instanceof StoragePool) {
        return VdcObjectType.StoragePool;
    }
    if (getEntity() instanceof VDSGroup) {
        return VdcObjectType.VdsGroups;
    }
    if (getEntity() instanceof VDS) {
        return VdcObjectType.VDS;
    }
    if (getEntity() instanceof StorageDomain) {
        return VdcObjectType.Storage;
    }
    if (getEntity() instanceof VmTemplate) {
        return VdcObjectType.VmTemplate;
    }
    if (getEntity() instanceof VmPool) {
        return VdcObjectType.VmPool;
    }
    if (getEntity() instanceof Quota) {
        return VdcObjectType.Quota;
    }
    if (getEntity() instanceof GlusterVolumeEntity) {
        return VdcObjectType.GlusterVolume;
    }
    if (getEntity() instanceof DiskImage) {
        return VdcObjectType.Disk;
    }
    if (getEntity() instanceof Network) {
        return VdcObjectType.Network;
    }
    if (getEntity() instanceof VnicProfile) {
        return VdcObjectType.VnicProfile;
    }
    return VdcObjectType.Unknown;
}
#end_block

#method_before
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeSystemPermissionsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_system_permission");
    model.setMessage(ConstantsManager.getInstance().getConstants().systemPermissionsMsg());
    ArrayList<String> list = new ArrayList<String>();
    for (Object item : getSelectedItems()) {
        permissions permission = (permissions) item;
        // $NON-NLS-1$ //$NON-NLS-2$
        list.add("User: " + permission.getOwnerName() + " with Role: " + permission.getRoleName());
    }
    model.setItems(list);
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#method_after
private void remove() {
    if (getWindow() != null) {
        return;
    }
    ConfirmationModel model = new ConfirmationModel();
    setWindow(model);
    model.setTitle(ConstantsManager.getInstance().getConstants().removeSystemPermissionsTitle());
    // $NON-NLS-1$
    model.setHashName("remove_system_permission");
    model.setMessage(ConstantsManager.getInstance().getConstants().systemPermissionsMsg());
    model.setItems(getSelectedItems());
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnRemove", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    model.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    model.getCommands().add(tempVar2);
}
#end_block

#method_before
@Test
public void testLoginAsync_404_failure() {
    Frontend.setLoggedInUser(new DbUser());
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    Frontend.LoginAsync(testUser, testPassword, testDomain, mockAsyncQuery, mockService);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), callbackAction.capture());
    // $NON-NLS-1$
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, "404 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockEventsHandler).runQueryFailed(null);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (EventArgs) any());
    // $NON-NLS-1$
    assertNull("Logged in user should be null", Frontend.getLoggedInUser());
    verify(mockAsyncCallback).onSuccess(any(), any());
}
#method_after
@Test
public void testLoginAsync_404_failure() {
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    Frontend.initLoggedInUser(new DbUser(), testPassword);
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    Frontend.LoginAsync(testUser, testPassword, testDomain, mockAsyncQuery, mockService);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), callbackAction.capture());
    // $NON-NLS-1$
    StatusCodeException exception = new StatusCodeException(HttpServletResponse.SC_NOT_FOUND, "404 status code");
    callbackAction.getValue().onFailure(exception);
    verify(mockEventsHandler).runQueryFailed(null);
    verify(mockFrontendFailureEvent).raise(eq(Frontend.class), (EventArgs) any());
    // $NON-NLS-1$
    assertNull("Logged in user should be null", Frontend.getLoggedInUser());
    verify(mockAsyncCallback).onSuccess(any(), any());
}
#end_block

#method_before
@Test
public void testLoginAsync_success() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    Frontend.setLoggedInUser(new DbUser());
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    Frontend.LoginAsync(testUser, testPassword, testDomain, mockAsyncQuery, mockService);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#method_after
@Test
public void testLoginAsync_success() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    Frontend.initLoggedInUser(new DbUser(), testPassword);
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    Frontend.LoginAsync(testUser, testPassword, testDomain, mockAsyncQuery, mockService);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    returnValue.setSucceeded(true);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#end_block

#method_before
@Test
public void testLoginAsync_login_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    Frontend.setLoggedInUser(new DbUser());
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    Frontend.LoginAsync(testUser, testPassword, testDomain, mockAsyncQuery, mockService);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    // Yes I know this is the default, just to be sure.
    returnValue.setSucceeded(false);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler, never()).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#method_after
@Test
public void testLoginAsync_login_failure() {
    Object model = new Object();
    when(mockAsyncQuery.getModel()).thenReturn(model);
    // $NON-NLS-1$
    String testUser = "testUser";
    // $NON-NLS-1$
    String testPassword = "testpassword";
    // $NON-NLS-1$
    String testDomain = "testdomain";
    Frontend.initLoggedInUser(new DbUser(), testPassword);
    when(mockAsyncQuery.isHandleFailure()).thenReturn(Boolean.TRUE);
    Frontend.LoginAsync(testUser, testPassword, testDomain, mockAsyncQuery, mockService);
    verify(mockService).Login(eq(testUser), eq(testPassword), eq(testDomain), callbackAction.capture());
    VdcReturnValueBase returnValue = new VdcReturnValueBase();
    // Yes I know this is the default, just to be sure.
    returnValue.setSucceeded(false);
    callbackAction.getValue().onSuccess(returnValue);
    verify(mockAsyncCallback).onSuccess(model, returnValue);
    verify(mockLoginHandler, never()).onLoginSuccess(testUser, testPassword, testDomain);
    verify(mockFrontendFailureEvent, never()).raise(eq(Frontend.class), (EventArgs) any());
}
#end_block

#method_before
public VdcReturnValueBase endAction() {
    ExecutionHandler.startFinalizingStep(getExecutionContext());
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("EndAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        freeLock();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#method_after
public VdcReturnValueBase endAction() {
    if (!hasTaskHandlers() || getExecutionIndex() == getTaskHandlers().size() - 1) {
        ExecutionHandler.startFinalizingStep(getExecutionContext());
    }
    try {
        initiateLockEndAction();
        setActionState();
        handleTransactivity();
        TransactionSupport.executeInScope(endActionScope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("EndAction: Transaction was aborted in {0}", this.getClass().getName());
    } finally {
        freeLockEndAction();
        if (getCommandShouldBeLogged()) {
            logCommand();
        }
    }
    return getReturnValue();
}
#end_block

#method_before
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
        } else {
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLock();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#method_after
public void endActionInTransactionScope() {
    boolean exceptionOccurred = false;
    try {
        if (isEndSuccessfully()) {
            internalEndSuccessfully();
        } else {
            internalEndWithFailure();
        }
    } catch (RuntimeException e) {
        exceptionOccurred = true;
        throw e;
    } finally {
        freeLockEndAction();
        if (TransactionSupport.current() == null) {
            // cleanup fails (probably since the transaction is aborted) then try to compensate.
            try {
                cleanUpCompensationData();
            } catch (RuntimeException e) {
                logExceptionAndCompensate(e);
            }
        } else {
            try {
                if (!exceptionOccurred && TransactionSupport.current().getStatus() == Status.STATUS_ACTIVE) {
                    cleanUpCompensationData();
                } else {
                    compensate();
                }
            } catch (SystemException e) {
                logExceptionAndCompensate(e);
            }
        }
    }
}
#end_block

#method_before
protected boolean validateInputs() {
    List<String> messages = ValidationUtils.validateInputs(getValidationGroups(), getParameters());
    if (!messages.isEmpty()) {
        getReturnValue().getCanDoActionMessages().addAll(messages);
        return false;
    }
    return true;
}
#method_after
protected boolean validateInputs() {
    return validate(getParameters());
}
#end_block

#method_before
protected boolean validate(ValidationResult validationResult) {
    if (!validationResult.isValid()) {
        addCanDoActionMessage(validationResult.getMessage());
        if (validationResult.getVariableReplacements() != null) {
            for (String variableReplacement : validationResult.getVariableReplacements()) {
                addCanDoActionMessage(variableReplacement);
            }
        }
    }
    return validationResult.isValid();
}
#method_after
protected <T> boolean validate(T value) {
    List<String> messages = ValidationUtils.validateInputs(getValidationGroups(), value);
    if (!messages.isEmpty()) {
        getReturnValue().getCanDoActionMessages().addAll(messages);
        return false;
    }
    return true;
}
#end_block

#method_before
protected final void execute() {
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#method_after
protected final void execute() {
    getReturnValue().setCanDoAction(true);
    getReturnValue().setIsSyncronious(true);
    if (!hasTaskHandlers() || getExecutionIndex() == 0) {
        ExecutionHandler.addStep(getExecutionContext(), StepEnum.EXECUTING, null);
    }
    try {
        handleTransactivity();
        TransactionSupport.executeInScope(scope, this);
    } catch (TransactionRolledbackLocalException e) {
        log.infoFormat("Transaction was aborted in {0}", this.getClass().getName());
        // Transaction was aborted - we must sure we compensation for all previous applicative stages of the command
        compensate();
    } finally {
        try {
            if (getCommandShouldBeLogged()) {
                logRenamedEntity();
                logCommand();
            }
            if (getSucceeded()) {
                // only after creating all tasks, we can start polling them (we
                // don't want
                // to start polling before all tasks were created, otherwise we
                // might change
                // the VM/VmTemplate status to 'Down'/'OK' too soon.
                startPollingAsyncTasks();
            }
        } finally {
            if (!hasTasks() && !ExecutionHandler.checkIfJobHasTasks(getExecutionContext())) {
                ExecutionHandler.endJob(getExecutionContext(), getSucceeded());
            }
        }
    }
}
#end_block

#method_before
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, String taskKey) {
    if (taskKeyToTaskIdMap.containsKey(taskKey)) {
        return taskKeyToTaskIdMap.get(taskKey);
    }
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        creationInfo.setTaskType(getTaskType());
        AsyncTasks task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        getAsyncTaskDao().save(task);
        taskKeyToTaskIdMap.put(taskKey, taskId);
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during persistAsyncTaskPlaceHolder for command: {0}. Exception {1}", getClass().getName(), ex);
    }
    return taskId;
}
#method_after
public Guid persistAsyncTaskPlaceHolder(VdcActionType parentCommand, final String taskKey) {
    if (taskKeyToTaskIdMap.containsKey(taskKey)) {
        return taskKeyToTaskIdMap.get(taskKey);
    }
    Guid taskId = Guid.Empty;
    try {
        AsyncTaskCreationInfo creationInfo = new AsyncTaskCreationInfo();
        if (!hasTaskHandlers()) {
            creationInfo.setTaskType(getTaskType());
        } else {
            creationInfo.setTaskType(getCurrentTaskHandler().getTaskType());
        }
        final AsyncTasks task = createAsyncTask(creationInfo, parentCommand);
        taskId = task.getTaskId();
        TransactionScopeOption scopeOption = getTransactive() ? TransactionScopeOption.RequiresNew : TransactionScopeOption.Required;
        TransactionSupport.executeInScope(scopeOption, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                saveTaskAndPutInMap(taskKey, task);
                return null;
            }
        });
        addToReturnValueTaskPlaceHolderIdList(taskId);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during persistAsyncTaskPlaceHolder for command: {0}. Exception {1}", getClass().getName(), ex);
    }
    return taskId;
}
#end_block

#method_before
private void freeLockExecute() {
    if (releaseLocksAtEndOfExecute || !getSucceeded() || !hasTasks()) {
        freeLock();
    }
}
#method_after
private void freeLockExecute() {
    if (releaseLocksAtEndOfExecute || !getSucceeded() || (!hasTasks() && !(this instanceof IVdsAsyncCommand))) {
        freeLock();
    }
}
#end_block

#method_before
protected final boolean failCanDoAction(VdcBllMessages message) {
    addCanDoActionMessage(message);
    return false;
}
#method_after
protected final boolean failCanDoAction(VdcBllMessages message, String... variableReplacements) {
    addCanDoActionMessage(message);
    for (String variableReplacement : variableReplacements) {
        addCanDoActionMessage(variableReplacement);
    }
    return false;
}
#end_block

#method_before
@Test
public void testExecuteQuery() {
    // Create a storage domain for the test
    Guid storageDomainId = Guid.newGuid();
    StorageDomain expected = new StorageDomain();
    expected.setId(storageDomainId);
    when(getQueryParameters().getId()).thenReturn(storageDomainId);
    // Mock the DAOs
    StorageDomainDAO storageDoaminDAOMock = mock(StorageDomainDAO.class);
    when(storageDoaminDAOMock.get(storageDomainId, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(expected);
    when(getDbFacadeMockInstance().getStorageDomainDao()).thenReturn(storageDoaminDAOMock);
    getQuery().executeQueryCommand();
    // Assert we got the correct storage domain back
    StorageDomain actual = (StorageDomain) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong storage domain returned", expected, actual);
}
#method_after
@Test
public void testExecuteQuery() {
    // Create a storage domain for the test
    Guid storageDomainId = Guid.newGuid();
    StorageDomain expected = new StorageDomain();
    expected.setId(storageDomainId);
    when(getQueryParameters().getId()).thenReturn(storageDomainId);
    // Mock the DAOs
    StorageDomainDAO storageDoaminDAOMock = mock(StorageDomainDAO.class);
    when(storageDoaminDAOMock.get(storageDomainId, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(expected);
    when(getDbFacadeMockInstance().getStorageDomainDao()).thenReturn(storageDoaminDAOMock);
    getQuery().executeQueryCommand();
    // Assert we got the correct storage domain back
    StorageDomain actual = getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong storage domain returned", expected, actual);
}
#end_block

#method_before
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getName().setInfo("Cannot edit Host's Name in this tree context");
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getCluster().setInfo("Cannot choose Host's Cluster in tree context");
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        // $NON-NLS-1$
                        innerHostModel.getDataCenter().setInfo("Cannot choose Host's Data Center in tree context");
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void newEntity() {
    if (getWindow() != null) {
        return;
    }
    final NewHostModel hostModel = new NewHostModel();
    setWindow(hostModel);
    hostModel.setTitle(ConstantsManager.getInstance().getConstants().newHostTitle());
    // $NON-NLS-1$
    hostModel.setHashName("new_host");
    hostModel.getPort().setEntity(54321);
    hostModel.getOverrideIpTables().setIsAvailable(false);
    hostModel.setSpmPriorityValue(null);
    hostModel.getConsoleAddressEnabled().setEntity(false);
    hostModel.getConsoleAddress().setIsChangable(false);
    AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            hostModel.setPmProxyPreferences((String) returnValue);
        }
    }));
    // Make sure not to set override IP tables flag back true when it was set false once.
    hostModel.getOverrideIpTables().getEntityChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            if (!clusterChanging) {
                updateOverrideIpTables = (Boolean) hostModel.getOverrideIpTables().getEntity();
            }
        }
    });
    // Set override IP tables flag true for v3.0 clusters.
    hostModel.getCluster().getSelectedItemChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            clusterChanging = true;
            ListModel clusterModel = hostModel.getCluster();
            if (clusterModel.getSelectedItem() != null) {
                Version v3 = new Version(3, 0);
                VDSGroup cluster = (VDSGroup) clusterModel.getSelectedItem();
                boolean isLessThan3 = cluster.getcompatibility_version().compareTo(v3) < 0;
                hostModel.getOverrideIpTables().setIsAvailable(!isLessThan3);
                hostModel.getOverrideIpTables().setEntity(!isLessThan3 && updateOverrideIpTables);
            }
            clusterChanging = false;
        }
    });
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            HostModel innerHostModel = (HostModel) hostListModel.getWindow();
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            final UIConstants constants = ConstantsManager.getInstance().getConstants();
            if (hostListModel.getSystemTreeSelectedItem() != null) {
                switch(hostListModel.getSystemTreeSelectedItem().getType()) {
                    case Host:
                        innerHostModel.getName().setIsChangable(false);
                        innerHostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
                        break;
                    case Hosts:
                    case Cluster:
                    case Cluster_Gluster:
                        VDSGroup cluster = (VDSGroup) hostListModel.getSystemTreeSelectedItem().getEntity();
                        for (StoragePool dc : dataCenters) {
                            if (dc.getId().equals(cluster.getStoragePoolId())) {
                                innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dc })));
                                innerHostModel.getDataCenter().setSelectedItem(dc);
                                break;
                            }
                        }
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        innerHostModel.getCluster().setItems(Arrays.asList(cluster));
                        innerHostModel.getCluster().setSelectedItem(cluster);
                        innerHostModel.getCluster().setIsChangable(false);
                        innerHostModel.getCluster().setChangeProhibitionReason(constants.cannotChangeClusterInTreeContext());
                        break;
                    case DataCenter:
                        StoragePool selectDataCenter = (StoragePool) hostListModel.getSystemTreeSelectedItem().getEntity();
                        innerHostModel.getDataCenter().setItems(new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { selectDataCenter })));
                        innerHostModel.getDataCenter().setSelectedItem(selectDataCenter);
                        innerHostModel.getDataCenter().setIsChangable(false);
                        innerHostModel.getDataCenter().setChangeProhibitionReason(constants.cannotChangeDCInTreeContext());
                        break;
                    default:
                        innerHostModel.getDataCenter().setItems(dataCenters);
                        innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
                        break;
                }
            } else {
                innerHostModel.getDataCenter().setItems(dataCenters);
                innerHostModel.getDataCenter().setSelectedItem(Linq.firstOrDefault(dataCenters));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            innerHostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            innerHostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#method_after
public void edit(final boolean isEditWithPMemphasis) {
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    AsyncQuery _asyncQuery = new AsyncQuery();
    _asyncQuery.setModel(this);
    _asyncQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            HostListModel hostListModel = (HostListModel) model;
            ArrayList<StoragePool> dataCenters = (ArrayList<StoragePool>) result;
            VDS host = (VDS) hostListModel.getSelectedItem();
            final HostModel hostModel = new EditHostModel();
            hostListModel.setWindow(hostModel);
            hostModel.updateModelFromVds(host, dataCenters, isEditWithPMemphasis, getSystemTreeSelectedItem());
            hostModel.setTitle(ConstantsManager.getInstance().getConstants().editHostTitle());
            // $NON-NLS-1$
            hostModel.setHashName("edit_host");
            if (host.getPmProxyPreferences() != null) {
                hostModel.setPmProxyPreferences(host.getPmProxyPreferences());
            } else {
                AsyncDataProvider.getDefaultPmProxyPreferences(new AsyncQuery(null, new INewAsyncCallback() {

                    @Override
                    public void onSuccess(Object model, Object returnValue) {
                        hostModel.setPmProxyPreferences((String) returnValue);
                    }
                }));
            }
            UICommand command;
            // $NON-NLS-1$
            command = new UICommand("OnSaveFalse", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().ok());
            command.setIsDefault(true);
            hostModel.getCommands().add(command);
            // $NON-NLS-1$
            command = new UICommand("Cancel", hostListModel);
            command.setTitle(ConstantsManager.getInstance().getConstants().cancel());
            command.setIsCancel(true);
            hostModel.getCommands().add(command);
            if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                hostModel.getName().setIsChangable(false);
                hostModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
            }
        }
    };
    AsyncDataProvider.getDataCenterList(_asyncQuery);
}
#end_block

#method_before
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getHostPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap(new ValueObjectMap(model.getPmOptionsMap(), false));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(new ValueObjectMap(model.getPmSecondaryOptionsMap(), false));
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider externalProvider = (Provider) model.getExternalProviders().getSelectedItem();
        if (externalProvider != null) {
            parameters.setProvider(externalProvider.getId());
            parameters.setNetworkMappings((String) model.getNeutronAgentModel().getInterfaceMappings().getEntity());
        }
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#method_after
public void onSaveInternal(boolean approveInitiated) {
    HostModel model = (HostModel) getWindow();
    if (model.getProgress() != null) {
        return;
    }
    VDS host = model.getIsNew() ? new VDS() : (VDS) Cloner.clone(getSelectedItem());
    // Save changes.
    host.setVdsName((String) model.getName().getEntity());
    host.setComment((String) model.getComment().getEntity());
    host.setHostName((String) model.getHost().getEntity());
    host.setPort(Integer.parseInt(model.getPort().getEntity().toString()));
    host.setSshPort(Integer.parseInt(model.getAuthSshPort().getEntity().toString()));
    boolean sshUsernameSet = model.getUserName().getEntity() != null;
    host.setSshUsername(sshUsernameSet ? model.getUserName().getEntity().toString() : null);
    boolean sshFpSet = model.getFetchSshFingerprint().getEntity() != null;
    host.setSshKeyFingerprint(!sshFpSet ? null : (String) model.getFetchSshFingerprint().getEntity());
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    boolean consoleAddressSet = (Boolean) model.getConsoleAddressEnabled().getEntity();
    host.setConsoleAddress(!consoleAddressSet ? null : (String) model.getConsoleAddress().getEntity());
    Guid oldClusterId = host.getVdsGroupId();
    Guid newClusterId = ((VDSGroup) model.getCluster().getSelectedItem()).getId();
    host.setVdsGroupId(newClusterId);
    host.setVdsSpmPriority(model.getSpmPriorityValue());
    host.setPmProxyPreferences(model.getPmProxyPreferences());
    // Save primary PM parameters.
    host.setManagementIp((String) model.getManagementIp().getEntity());
    host.setPmUser((String) model.getPmUserName().getEntity());
    host.setPmPassword((String) model.getPmPassword().getEntity());
    host.setPmType((String) model.getPmType().getSelectedItem());
    host.setPmOptionsMap((model.getPmOptionsMap()));
    // Save secondary PM parameters.
    host.setPmSecondaryIp((String) model.getPmSecondaryIp().getEntity());
    host.setPmSecondaryUser((String) model.getPmSecondaryUserName().getEntity());
    host.setPmSecondaryPassword((String) model.getPmSecondaryPassword().getEntity());
    host.setPmSecondaryType((String) model.getPmSecondaryType().getSelectedItem());
    host.setPmSecondaryOptionsMap(model.getPmSecondaryOptionsMap());
    // Save other PM parameters.
    host.setpm_enabled((Boolean) model.getIsPm().getEntity());
    host.setPmSecondaryConcurrent((Boolean) model.getPmSecondaryConcurrent().getEntity());
    cancelConfirm();
    model.startProgress(null);
    final boolean isVirt = ((VDSGroup) model.getCluster().getSelectedItem()).supportsVirtService();
    if (model.getIsNew()) {
        AddVdsActionParameters parameters = new AddVdsActionParameters();
        parameters.setVdsId(host.getId());
        parameters.setvds(host);
        if (model.getUserPassword().getEntity() != null) {
            parameters.setPassword((String) model.getUserPassword().getEntity());
        }
        parameters.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
        if (networkProvider != null) {
            parameters.setProviderId(networkProvider.getId());
            parameters.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
        }
        Frontend.RunAction(VdcActionType.AddVds, parameters, new IFrontendActionAsyncCallback() {

            @Override
            public void executed(FrontendActionAsyncResult result) {
                Object[] array = (Object[]) result.getState();
                HostListModel localModel = (HostListModel) array[0];
                boolean localApproveInitiated = (Boolean) array[1];
                localModel.postOnSaveInternal(result.getReturnValue(), localApproveInitiated);
            }
        }, new Object[] { this, approveInitiated });
    } else // Update VDS -> consists of changing VDS cluster first and then updating rest of VDS properties:
    {
        UpdateVdsActionParameters parameters = new UpdateVdsActionParameters();
        parameters.setvds(host);
        parameters.setVdsId(host.getId());
        // $NON-NLS-1$
        parameters.setPassword("");
        parameters.setInstallVds(false);
        parameters.setRebootAfterInstallation(isVirt);
        parameters.setAuthMethod(model.getAuthenticationMethod());
        if (!oldClusterId.equals(newClusterId)) {
            Frontend.RunAction(VdcActionType.ChangeVDSCluster, new ChangeVDSClusterParameters(newClusterId, host.getId()), new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    Object[] array = (Object[]) result.getState();
                    HostListModel localModel = (HostListModel) array[0];
                    UpdateVdsActionParameters localParameters = (UpdateVdsActionParameters) array[1];
                    boolean localApproveInitiated = (Boolean) array[2];
                    VdcReturnValueBase localReturnValue = result.getReturnValue();
                    if (localReturnValue != null && localReturnValue.getSucceeded()) {
                        localModel.postOnSaveInternalChangeCluster(localParameters, localApproveInitiated);
                    } else {
                        localModel.getWindow().stopProgress();
                    }
                }
            }, new Object[] { this, parameters, approveInitiated });
        } else {
            postOnSaveInternalChangeCluster(parameters, approveInitiated);
        }
    }
}
#end_block

#method_before
public void activate() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    for (Object item : getSelectedItems()) {
        VDS vds = (VDS) item;
        list.add(new VdsActionParameters(vds.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.ActivateVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#method_after
public void activate() {
    ArrayList<VdcActionParametersBase> list = new ArrayList<VdcActionParametersBase>();
    Collections.sort((List<VDS>) getSelectedItems(), new Linq.VdsSPMPriorityComparer());
    for (VDS vds : (List<VDS>) getSelectedItems()) {
        list.add(new VdsActionParameters(vds.getId()));
    }
    Frontend.RunMultipleAction(VdcActionType.ActivateVds, list, new IFrontendMultipleActionAsyncCallback() {

        @Override
        public void executed(FrontendMultipleActionAsyncResult result) {
        }
    }, null);
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#method_after
private void updateActionAvailability() {
    ArrayList<VDS> items = getSelectedItems() != null ? Linq.<VDS>cast(getSelectedItems()) : new ArrayList<VDS>();
    boolean isAllPMEnabled = Linq.findAllVDSByPmEnabled(items).size() == items.size();
    getEditCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getEditWithPMemphasisCommand().setIsExecutionAllowed(items.size() == 1 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.UpdateVds));
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RemoveVds));
    getActivateCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ActivateVds));
    // or special case where its installation failed but its oVirt node
    boolean approveAvailability = items.size() == 1 && (VdcActionUtils.canExecute(items, VDS.class, VdcActionType.ApproveVds) || (items.get(0).getStatus() == VDSStatus.InstallFailed && items.get(0).getVdsType() == VDSType.oVirtNode));
    getApproveCommand().setIsExecutionAllowed(approveAvailability);
    getApproveCommand().setIsAvailable(approveAvailability);
    getMaintenanceCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.MaintenanceVds));
    getRestartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RestartVds) && isAllPMEnabled);
    getStartCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StartVds) && isAllPMEnabled);
    getStopCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.StopVds) && isAllPMEnabled);
    setIsPowerManagementEnabled(getRestartCommand().getIsExecutionAllowed() || getStartCommand().getIsExecutionAllowed() || getStopCommand().getIsExecutionAllowed());
    getManualFenceCommand().setIsExecutionAllowed(items.size() == 1);
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host);
    getNewCommand().setIsAvailable(isAvailable);
    getRemoveCommand().setIsAvailable(isAvailable);
    getSelectAsSpmCommand().setIsExecutionAllowed(isSelectAsSpmCommandAllowed(items));
    updateConfigureLocalStorageCommandAvailability();
    getRefreshCapabilitiesCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, VDS.class, VdcActionType.RefreshHostCapabilities));
}
#end_block

#method_before
public byte[] getExternalId() {
    return externalId;
}
#method_after
public ExternalId getExternalId() {
    return externalId;
}
#end_block

#method_before
public void setExternalId(byte[] externalId) {
    this.externalId = externalId;
}
#method_after
public void setExternalId(ExternalId externalId) {
    this.externalId = externalId;
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + Arrays.hashCode(externalId);
    result = prime * result + ((department == null) ? 0 : department.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((email == null) ? 0 : email.hashCode());
    result = prime * result + ((groupNames == null) ? 0 : groupNames.hashCode());
    result = prime * result + (isAdmin ? 1231 : 1237);
    result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
    result = prime * result + ((note == null) ? 0 : note.hashCode());
    result = prime * result + ((role == null) ? 0 : role.hashCode());
    result = prime * result + status;
    result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
    result = prime * result + ((loginName == null) ? 0 : loginName.hashCode());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((externalId == null) ? 0 : externalId.hashCode());
    result = prime * result + ((department == null) ? 0 : department.hashCode());
    result = prime * result + ((domain == null) ? 0 : domain.hashCode());
    result = prime * result + ((email == null) ? 0 : email.hashCode());
    result = prime * result + ((groupNames == null) ? 0 : groupNames.hashCode());
    result = prime * result + (isAdmin ? 1231 : 1237);
    result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
    result = prime * result + ((note == null) ? 0 : note.hashCode());
    result = prime * result + ((role == null) ? 0 : role.hashCode());
    result = prime * result + status;
    result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
    result = prime * result + ((loginName == null) ? 0 : loginName.hashCode());
    return result;
}
#end_block

#method_before
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbUser other = (DbUser) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && Arrays.equals(externalId, other.externalId) && ObjectUtils.objectsEqual(department, other.department) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(email, other.email) && ObjectUtils.objectsEqual(groupNames, other.groupNames) && isAdmin == other.isAdmin && ObjectUtils.objectsEqual(firstName, other.firstName) && ObjectUtils.objectsEqual(note, other.note) && ObjectUtils.objectsEqual(role, other.role) && status == other.status && ObjectUtils.objectsEqual(lastName, other.lastName) && ObjectUtils.objectsEqual(loginName, other.loginName));
}
#method_after
@Override
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj == null) {
        return false;
    }
    if (getClass() != obj.getClass()) {
        return false;
    }
    DbUser other = (DbUser) obj;
    return (ObjectUtils.objectsEqual(id, other.id) && ObjectUtils.objectsEqual(externalId, other.externalId) && ObjectUtils.objectsEqual(department, other.department) && ObjectUtils.objectsEqual(domain, other.domain) && ObjectUtils.objectsEqual(email, other.email) && ObjectUtils.objectsEqual(groupNames, other.groupNames) && isAdmin == other.isAdmin && ObjectUtils.objectsEqual(firstName, other.firstName) && ObjectUtils.objectsEqual(note, other.note) && ObjectUtils.objectsEqual(role, other.role) && status == other.status && ObjectUtils.objectsEqual(lastName, other.lastName) && ObjectUtils.objectsEqual(loginName, other.loginName));
}
#end_block

#method_before
@Test
public void testDoGet_WithoutUserInfoObject() throws IOException, ServletException, NoSuchAlgorithmException {
    doReturn(null).when(testServlet).getLoggedInUser(anyString());
    doReturn(mockDigest).when(testServlet).getMd5Digest(any(HttpServletRequest.class));
    testServlet.doGet(mockRequest, mockResponse);
    verify(mockRequest).setAttribute(eq(GwtDynamicHostPageServlet.MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey()), anyString());
    verify(mockRequest, never()).setAttribute(eq(GwtDynamicHostPageServlet.MD5Attributes.ATTR_USER_INFO.getKey()), any(ObjectNode.class));
    verify(mockRequest).setAttribute(GwtDynamicHostPageServlet.MD5Attributes.ATTR_STYLES.getKey(), new ArrayList<BrandingTheme>());
    verify(mockRequest).setAttribute(GwtDynamicHostPageServlet.MD5Attributes.ATTR_MESSAGES.getKey(), // $NON-NLS-1$
    null);
}
#method_after
@Test
public void testDoGet_WithoutUserInfoObject() throws IOException, ServletException, NoSuchAlgorithmException {
    doReturn(null).when(testServlet).getLoggedInUser(anyString());
    doReturn(mockDigest).when(testServlet).getMd5Digest(any(HttpServletRequest.class));
    testServlet.doGet(mockRequest, mockResponse);
    verify(mockRequest).setAttribute(eq(GwtDynamicHostPageServlet.MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey()), anyString());
    verify(mockRequest, never()).setAttribute(eq(GwtDynamicHostPageServlet.MD5Attributes.ATTR_USER_INFO.getKey()), any(ObjectNode.class));
    verify(mockRequest).setAttribute(GwtDynamicHostPageServlet.MD5Attributes.ATTR_MESSAGES.getKey(), // $NON-NLS-1$
    null);
}
#end_block

#method_before
@Test
public void testDoGet_WithUserInfoObject() throws IOException, ServletException, NoSuchAlgorithmException {
    // $NON-NLS-1$
    String userInfo = "{ \"foo\": \"bar\" }";
    when(mockUserInfoObject.toString()).thenReturn(userInfo);
    when(mockRequest.getAttribute(GwtDynamicHostPageServlet.MD5Attributes.ATTR_USER_INFO.getKey())).thenReturn(mockUserInfoObject);
    doReturn(mockDigest).when(testServlet).getMd5Digest(any(HttpServletRequest.class));
    testServlet.doGet(mockRequest, mockResponse);
    verify(mockRequest).setAttribute(eq(GwtDynamicHostPageServlet.MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey()), anyString());
    verify(mockRequest).setAttribute(eq(GwtDynamicHostPageServlet.MD5Attributes.ATTR_USER_INFO.getKey()), any(ObjectNode.class));
    verify(mockRequest).setAttribute(GwtDynamicHostPageServlet.MD5Attributes.ATTR_STYLES.getKey(), new ArrayList<BrandingTheme>());
    verify(mockRequest).setAttribute(GwtDynamicHostPageServlet.MD5Attributes.ATTR_MESSAGES.getKey(), // $NON-NLS-1$
    null);
}
#method_after
@Test
public void testDoGet_WithUserInfoObject() throws IOException, ServletException, NoSuchAlgorithmException {
    // $NON-NLS-1$
    String userInfo = "{ \"foo\": \"bar\" }";
    when(mockUserInfoObject.toString()).thenReturn(userInfo);
    when(mockRequest.getAttribute(GwtDynamicHostPageServlet.MD5Attributes.ATTR_USER_INFO.getKey())).thenReturn(mockUserInfoObject);
    doReturn(mockDigest).when(testServlet).getMd5Digest(any(HttpServletRequest.class));
    testServlet.doGet(mockRequest, mockResponse);
    verify(mockRequest).setAttribute(eq(GwtDynamicHostPageServlet.MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey()), anyString());
    verify(mockRequest).setAttribute(eq(GwtDynamicHostPageServlet.MD5Attributes.ATTR_USER_INFO.getKey()), any(ObjectNode.class));
    verify(mockRequest).setAttribute(GwtDynamicHostPageServlet.MD5Attributes.ATTR_MESSAGES.getKey(), // $NON-NLS-1$
    null);
}
#end_block

#method_before
private void updateActionAvailability() {
    ArrayList items = (((ArrayList) getSelectedItems()) != null) ? (ArrayList) getSelectedItems() : new ArrayList();
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.CanExecute(items, DbUser.class, VdcActionType.RemoveUser));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
}
#method_after
private void updateActionAvailability() {
    ArrayList items = (((ArrayList) getSelectedItems()) != null) ? (ArrayList) getSelectedItems() : new ArrayList();
    getRemoveCommand().setIsExecutionAllowed(items.size() > 0 && VdcActionUtils.canExecute(items, DbUser.class, VdcActionType.RemoveUser));
    getAssignTagsCommand().setIsExecutionAllowed(items.size() > 0);
}
#end_block

#method_before
@Test
public void testExecuteQuery() {
    Guid templateID = Guid.newGuid();
    List<VmNetworkInterface> expectedResult = Collections.singletonList(new VmNetworkInterface());
    IdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getId()).thenReturn(templateID);
    VmNetworkInterfaceDao vmNetworkInterfaceDAOMock = mock(VmNetworkInterfaceDao.class);
    when(vmNetworkInterfaceDAOMock.getAllForTemplate(templateID, getUser().getId(), paramsMock.isFiltered())).thenReturn(expectedResult);
    when(getDbFacadeMockInstance().getVmNetworkInterfaceDao()).thenReturn(vmNetworkInterfaceDAOMock);
    getQuery().executeQueryCommand();
    @SuppressWarnings("unchecked")
    List<VmNetworkInterface> result = (List<VmNetworkInterface>) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong interfaces returned", expectedResult, result);
}
#method_after
@Test
public void testExecuteQuery() {
    Guid templateID = Guid.newGuid();
    List<VmNetworkInterface> expectedResult = Collections.singletonList(new VmNetworkInterface());
    IdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getId()).thenReturn(templateID);
    VmNetworkInterfaceDao vmNetworkInterfaceDAOMock = mock(VmNetworkInterfaceDao.class);
    when(vmNetworkInterfaceDAOMock.getAllForTemplate(templateID, getUser().getId(), paramsMock.isFiltered())).thenReturn(expectedResult);
    when(getDbFacadeMockInstance().getVmNetworkInterfaceDao()).thenReturn(vmNetworkInterfaceDAOMock);
    getQuery().executeQueryCommand();
    List<VmNetworkInterface> result = getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong interfaces returned", expectedResult, result);
}
#end_block

#method_before
protected void performLogin(T loginModel) {
    DbUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = (String) loginModel.getPassword().getEntity();
    // UiCommon login preparation
    Frontend.setLoggedInUser(loggedUser);
    Frontend.setLoginPassword(loginPassword);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#method_after
protected void performLogin(T loginModel) {
    DbUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = (String) loginModel.getPassword().getEntity();
    // UiCommon login preparation
    Frontend.initLoggedInUser(loggedUser, loginPassword);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#end_block

#method_before
@Test
public void testIsStoragePoolMasterUpWhenDown() {
    StoragePool storagePoolToCheck = dbFacade.getStoragePoolDao().get(STORAGE_POOL_WITH_MASTER_DOWN);
    assertNotNull(storagePoolToCheck);
    Guid masterStorageDomainGuid = dbFacade.getStorageDomainDao().getMasterStorageDomainIdForPool(STORAGE_POOL_WITH_MASTER_DOWN);
    assertNotNull(masterStorageDomainGuid);
    StoragePoolIsoMap storagePoolIsoMapToCheck = dbFacade.getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(masterStorageDomainGuid, storagePoolToCheck.getId()));
    assertNotNull(storagePoolIsoMapToCheck);
    storagePoolIsoMapToCheck.setstatus(StorageDomainStatus.InActive);
    dbFacade.getStoragePoolIsoMapDao().update(storagePoolIsoMapToCheck);
    assertFalse(dbFacade.isStoragePoolMasterUp(STORAGE_POOL_WITH_MASTER_DOWN));
}
#method_after
@Test
public void testIsStoragePoolMasterUpWhenDown() {
    StoragePool storagePoolToCheck = dbFacade.getStoragePoolDao().get(STORAGE_POOL_WITH_MASTER_DOWN);
    assertNotNull(storagePoolToCheck);
    Guid masterStorageDomainGuid = dbFacade.getStorageDomainDao().getMasterStorageDomainIdForPool(STORAGE_POOL_WITH_MASTER_DOWN);
    assertNotNull(masterStorageDomainGuid);
    StoragePoolIsoMap storagePoolIsoMapToCheck = dbFacade.getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(masterStorageDomainGuid, storagePoolToCheck.getId()));
    assertNotNull(storagePoolIsoMapToCheck);
    storagePoolIsoMapToCheck.setStatus(StorageDomainStatus.InActive);
    dbFacade.getStoragePoolIsoMapDao().update(storagePoolIsoMapToCheck);
    assertFalse(dbFacade.isStoragePoolMasterUp(STORAGE_POOL_WITH_MASTER_DOWN));
}
#end_block

#method_before
@Override
public void login() {
    // Completely override the base class functionality.
    if (!validate()) {
        return;
    }
    startProgress(null);
    getUserName().setIsChangable(false);
    getPassword().setIsChangable(false);
    getDomain().setIsChangable(false);
    getLoginCommand().setIsExecutionAllowed(false);
    getIsAutoConnect().setIsChangable(false);
    Frontend.RunAction(VdcActionType.LoginUser, new LoginUserParameters((String) getUserName().getEntity(), (String) getPassword().getEntity(), // $NON-NLS-1$
    (String) getDomain().getSelectedItem(), // $NON-NLS-1$
    "", // $NON-NLS-1$
    "", // $NON-NLS-1$
    ""), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            UserPortalLoginModel model = (UserPortalLoginModel) result.getState();
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success) {
                model.setLoggedUser((DbUser) returnValue.getActionReturnValue());
                model.raiseLoggedInEvent();
            } else {
                // $NON-NLS-1$
                model.getPassword().setEntity("");
                if (returnValue != null) {
                    model.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                }
                model.getUserName().setIsChangable(true);
                model.getPassword().setIsChangable(true);
                model.getDomain().setIsChangable(true);
                model.getLoginCommand().setIsExecutionAllowed(true);
                getIsAutoConnect().setIsChangable(true);
                model.getLoginFailedEvent().raise(this, EventArgs.Empty);
            }
            stopProgress();
        }
    }, this);
}
#method_after
@Override
public void login() {
    // Completely override the base class functionality.
    if (!validate()) {
        getLoginFailedEvent().raise(this, EventArgs.Empty);
        return;
    }
    startProgress(null);
    getUserName().setIsChangable(false);
    getPassword().setIsChangable(false);
    getDomain().setIsChangable(false);
    getLoginCommand().setIsExecutionAllowed(false);
    getIsAutoConnect().setIsChangable(false);
    Frontend.RunAction(VdcActionType.LoginUser, new LoginUserParameters((String) getUserName().getEntity(), (String) getPassword().getEntity(), // $NON-NLS-1$
    (String) getDomain().getSelectedItem(), // $NON-NLS-1$
    "", // $NON-NLS-1$
    "", // $NON-NLS-1$
    ""), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            UserPortalLoginModel model = (UserPortalLoginModel) result.getState();
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success) {
                model.setLoggedUser((DbUser) returnValue.getActionReturnValue());
                model.raiseLoggedInEvent();
            } else {
                // $NON-NLS-1$
                model.getPassword().setEntity("");
                if (returnValue != null) {
                    model.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                }
                model.getUserName().setIsChangable(true);
                model.getPassword().setIsChangable(true);
                model.getDomain().setIsChangable(true);
                model.getLoginCommand().setIsExecutionAllowed(true);
                getIsAutoConnect().setIsChangable(true);
                model.getLoginFailedEvent().raise(this, EventArgs.Empty);
            }
            stopProgress();
        }
    }, this);
}
#end_block

#method_before
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(Object targetObject) {
    UserPortalLoginModel loginModel = (UserPortalLoginModel) targetObject;
    AsyncDataProvider.getPermissionsByAdElementId(new AsyncQuery(targetObject, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<permissions> permissions = (ArrayList<permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (permissions permission : permissions) {
                // ALL Everyone/NetworkUser persmissions
                if (isEveyoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission) || isEveyoneNetworUserPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveyoneNetworUserPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.networkUser.asGuid());
        }

        private boolean isEveyoneUserPortalBasedVmPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getId());
}
#method_after
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(Object targetObject) {
    UserPortalLoginModel loginModel = (UserPortalLoginModel) targetObject;
    AsyncDataProvider.getPermissionsByAdElementId(new AsyncQuery(targetObject, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<permissions> permissions = (ArrayList<permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (permissions permission : permissions) {
                // ALL Everyone/NetworkUser persmissions
                if (isEveryoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission) || isEveryoneVnicProfileUserPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveryoneVnicProfileUserPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.vnicProfileUser.asGuid());
        }

        private boolean isEveryoneUserPortalBasedVmPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getId());
}
#end_block

#method_before
private DiskImage createDiskImage() {
    return new DiskImage(true, new Date(), new Date(), 1L, "1", Guid.newGuid(), "2", Guid.newGuid(), 1L, Guid.newGuid(), ImageStatus.OK, new Date(), "", VmEntityType.VM, 1, null, null, QuotaEnforcementTypeEnum.DISABLED, false);
}
#method_after
private DiskImage createDiskImage() {
    DiskImage di = new DiskImage();
    di.setActive(true);
    di.setId(Guid.newGuid());
    di.setImageId(Guid.newGuid());
    di.setParentId(Guid.newGuid());
    di.setImageStatus(ImageStatus.OK);
    return di;
}
#end_block

#method_before
private DiskImage createDiskSnapshot(Guid diskId) {
    return new DiskImage(RandomUtils.instance().nextBoolean(), new Date(), new Date(), 1L, "1", Guid.newGuid(), "2", Guid.newGuid(), 1L, diskId, ImageStatus.OK, new Date(), "", VmEntityType.VM, 1, null, null, QuotaEnforcementTypeEnum.DISABLED, false);
}
#method_after
private DiskImage createDiskSnapshot(Guid diskId) {
    DiskImage di = new DiskImage();
    di.setActive(false);
    di.setId(diskId);
    di.setImageId(Guid.newGuid());
    di.setParentId(Guid.newGuid());
    di.setImageStatus(ImageStatus.OK);
    return di;
}
#end_block

#method_before
protected void executeCommandWithConsoleSafenessWarning(final UICommand command) {
    VM vm = getEntity();
    if (vm.getAllowConsoleReconnect() || vm.getConsoleCurentUserName() == null || Frontend.getLoggedInUser().getId().equals(vm.getConsoleUserId())) {
        command.execute();
        return;
    }
    // now we ask if the currently connected user has permission to reconnect (async)
    HasAdElementReconnectPermissionParameters params = new HasAdElementReconnectPermissionParameters(vm.getConsoleUserId(), vm.getId());
    AsyncQuery query = new AsyncQuery();
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            boolean returnValue = ((Boolean) ((VdcQueryReturnValue) result).getReturnValue());
            if (returnValue) {
                command.execute();
            } else {
                displayConsoleConnectConfirmPopup(command);
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, params, query);
}
#method_after
protected void executeCommandWithConsoleSafenessWarning(final UICommand command) {
    VM vm = getEntity();
    if (vm.getAllowConsoleReconnect() || vm.getConsoleCurentUserName() == null || Frontend.getLoggedInUser().getId().equals(vm.getConsoleUserId())) {
        command.execute();
        return;
    }
    // now we ask if the currently connected user has permission to reconnect (async)
    final HasAdElementReconnectPermissionParameters consoleUserReconnectPermParams = new HasAdElementReconnectPermissionParameters(vm.getConsoleUserId(), vm.getId());
    final HasAdElementReconnectPermissionParameters portalUserReconnectPermParams = new HasAdElementReconnectPermissionParameters(Frontend.getLoggedInUser().getId(), vm.getId());
    final AsyncQuery portalUserReconnectPermissionQuery = new AsyncQuery();
    portalUserReconnectPermissionQuery.setModel(this);
    portalUserReconnectPermissionQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            boolean returnValue = ((VdcQueryReturnValue) result).getReturnValue();
            if (returnValue) {
                displayConsoleConnectConfirmPopup(command);
            } else {
                // user will be stopped by backend validation
                command.execute();
            }
        }
    };
    final AsyncQuery consoleUserReconnectPermissionQuery = new AsyncQuery();
    consoleUserReconnectPermissionQuery.setModel(this);
    consoleUserReconnectPermissionQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            boolean returnValue = ((VdcQueryReturnValue) result).getReturnValue();
            if (returnValue) {
                command.execute();
            } else {
                Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, portalUserReconnectPermParams, portalUserReconnectPermissionQuery);
            }
        }
    };
    Frontend.RunQuery(VdcQueryType.HasAdElementReconnectPermission, consoleUserReconnectPermParams, consoleUserReconnectPermissionQuery);
}
#end_block

#method_before
public DbUser getUserById(Guid userId) {
    IdQueryParameters queryParameters = new IdQueryParameters(userId);
    VdcQueryReturnValue userQueryResponse = runQuery(VdcQueryType.GetDbUserByUserId, queryParameters);
    DbUser returnValue = null;
    if (userQueryResponse != null && userQueryResponse.getSucceeded()) {
        returnValue = (DbUser) userQueryResponse.getReturnValue();
    }
    return returnValue;
}
#method_after
public DbUser getUserById(Guid userId) {
    IdQueryParameters queryParameters = new IdQueryParameters(userId);
    VdcQueryReturnValue userQueryResponse = runQuery(VdcQueryType.GetDbUserByUserId, queryParameters);
    DbUser returnValue = null;
    if (userQueryResponse != null && userQueryResponse.getSucceeded()) {
        returnValue = userQueryResponse.getReturnValue();
    }
    return returnValue;
}
#end_block

#method_before
protected int getMaxResults() {
    if (getUriInfo() != null && QueryHelper.hasMatrixParam(getUriInfo(), MAX)) {
        HashMap<String, String> matrixConstraints = QueryHelper.getMatrixConstraints(getUriInfo(), MAX);
        String maxString = matrixConstraints.get(MAX);
        try {
            return Integer.valueOf(maxString);
        } catch (NumberFormatException e) {
            LOG.error("Max number of results is not a valid number: '" + maxString + "'. Resorting to default behavior - no limit on number of query results.");
            return NO_LIMIT;
        }
    } else {
        return NO_LIMIT;
    }
}
#method_after
protected int getMaxResults() throws MalformedNumberException {
    if (getUriInfo() != null && QueryHelper.hasMatrixParam(getUriInfo(), MAX)) {
        HashMap<String, String> matrixConstraints = QueryHelper.getMatrixConstraints(getUriInfo(), MAX);
        String maxString = matrixConstraints.get(MAX);
        try {
            return Integer.valueOf(maxString);
        } catch (NumberFormatException e) {
            LOG.error("Max number of results is not a valid number: " + maxString);
            throw new MalformedNumberException("Max number of results is not a valid number: " + maxString);
        }
    } else {
        return NO_LIMIT;
    }
}
#end_block

#method_before
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    List<BrandingTheme> brandingThemes;
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set attribute for themes.
    brandingThemes = brandingManager.getBrandingThemes();
    request.setAttribute(MD5Attributes.ATTR_STYLES.getKey(), brandingThemes);
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getLocaleFromRequest(request)));
    // Set class of servlet
    request.setAttribute(MD5Attributes.ATTR_APPLICATION_TYPE.getKey(), getApplicationType());
    // Set attribute for userInfo object
    DbUser loggedInUser = getLoggedInUser(request.getSession().getId());
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
    }
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#method_after
@Override
protected void doGet(final HttpServletRequest request, final HttpServletResponse response) throws IOException, ServletException {
    // Set attribute for selector script
    request.setAttribute(MD5Attributes.ATTR_SELECTOR_SCRIPT.getKey(), getSelectorScriptName());
    // Set the messages that need to be replaced.
    request.setAttribute(MD5Attributes.ATTR_MESSAGES.getKey(), getBrandingMessages(getLocaleFromRequest(request)));
    // Set class of servlet
    request.setAttribute(MD5Attributes.ATTR_APPLICATION_TYPE.getKey(), getApplicationType());
    // Set attribute for userInfo object
    DbUser loggedInUser = getLoggedInUser(request.getSession().getId());
    if (loggedInUser != null) {
        request.setAttribute(MD5Attributes.ATTR_USER_INFO.getKey(), getUserInfoObject(loggedInUser));
    }
    try {
        // Calculate MD5 for use with If-None-Match request header
        String md5sum = getMd5Sum(request);
        if (request.getHeader(IF_NONE_MATCH_HEADER) != null && request.getHeader(IF_NONE_MATCH_HEADER).equals(md5sum)) {
            response.setStatus(HttpServletResponse.SC_NOT_MODIFIED);
        } else {
            RequestDispatcher dispatcher = request.getRequestDispatcher(HOST_JSP);
            response.setContentType(UTF_CONTENT_TYPE);
            response.addHeader(ETAG_HEADER, md5sum);
            if (dispatcher != null) {
                dispatcher.include(request, response);
            }
        }
    } catch (NoSuchAlgorithmException ex) {
        throw new ServletException(ex);
    }
}
#end_block

#method_before
@Test
public void testExecuteQuery() {
    Guid vmID = Guid.newGuid();
    VM vm = new VM();
    Guid vdsID = Guid.newGuid();
    vm.setRunOnVds(vdsID);
    VDS vds = new VDS();
    vds.setId(vdsID);
    VdsNetworkInterface managementInterface = new VdsNetworkInterface();
    managementInterface.setAddress("my_address");
    IdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getId()).thenReturn(vmID);
    InterfaceDao interfaceDAOMock = mock(InterfaceDao.class);
    VmDAO vmDAOMock = mock(VmDAO.class);
    when(getDbFacadeMockInstance().getVmDao()).thenReturn(vmDAOMock);
    when(vmDAOMock.get(vmID)).thenReturn(vm);
    when(interfaceDAOMock.getManagedInterfaceForVds(vdsID, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(managementInterface);
    when(getDbFacadeMockInstance().getInterfaceDao()).thenReturn(interfaceDAOMock);
    getQuery().executeQueryCommand();
    String result = (String) getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong address returned", "my_address", result);
}
#method_after
@Test
public void testExecuteQuery() {
    Guid vmID = Guid.newGuid();
    VM vm = new VM();
    Guid vdsID = Guid.newGuid();
    vm.setRunOnVds(vdsID);
    VDS vds = new VDS();
    vds.setId(vdsID);
    VdsNetworkInterface managementInterface = new VdsNetworkInterface();
    managementInterface.setAddress("my_address");
    IdQueryParameters paramsMock = getQueryParameters();
    when(paramsMock.getId()).thenReturn(vmID);
    InterfaceDao interfaceDAOMock = mock(InterfaceDao.class);
    VmDAO vmDAOMock = mock(VmDAO.class);
    when(getDbFacadeMockInstance().getVmDao()).thenReturn(vmDAOMock);
    when(vmDAOMock.get(vmID)).thenReturn(vm);
    when(interfaceDAOMock.getManagedInterfaceForVds(vdsID, getUser().getId(), getQueryParameters().isFiltered())).thenReturn(managementInterface);
    when(getDbFacadeMockInstance().getInterfaceDao()).thenReturn(interfaceDAOMock);
    getQuery().executeQueryCommand();
    String result = getQuery().getQueryReturnValue().getReturnValue();
    assertEquals("Wrong address returned", "my_address", result);
}
#end_block

#method_before
private MenuCell<GlusterTaskSupport> getRebalanceActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask().getType() == GlusterTaskType.REBALANCE;
        }
    };
    menuCell.addMenuItem(constants.statusRebalance(), getMainModel().getStatusRebalanceCommand());
    menuCell.addMenuItem(constants.stopRebalance(), getMainModel().getStopRebalanceCommand());
    return menuCell;
}
#method_after
private MenuCell<GlusterTaskSupport> getRebalanceActivityMenu(ApplicationConstants constants) {
    MenuCell<GlusterTaskSupport> menuCell = new MenuCell<GlusterTaskSupport>() {

        @Override
        protected boolean isVisible(GlusterTaskSupport value) {
            return value.getAsyncTask() != null && value.getAsyncTask().getType() == GlusterTaskType.REBALANCE;
        }
    };
    menuCell.addMenuItem(constants.statusRebalance(), getMainModel().getStatusRebalanceCommand());
    menuCell.addMenuItem(constants.stopRebalance(), getMainModel().getStopRebalanceCommand());
    return menuCell;
}
#end_block

#method_before
@Override
public Response start(Action action) {
    if (isStartRunOnce(action)) {
        RunVmOnceParams params = map(map(getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), id, true), new VM()), new RunVmOnceParams(guid));
        if (action.isSetVm()) {
            validateEnums(VM.class, action.getVm());
            VM vm = action.getVm();
            params = map(vm, params);
            if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
                validateParameters(vm.getPlacementPolicy(), "host.id|name");
                params.setDestinationVdsId(getHostId(vm.getPlacementPolicy().getHost()));
            }
        }
        if (action.isSetPause() && action.isPause()) {
            params.setRunAndPause(true);
        }
        return doAction(VdcActionType.RunVmOnce, params, action);
    } else {
        RunVmParams params = new RunVmParams(guid);
        if (action.isSetPause() && action.isPause()) {
            params.setRunAndPause(true);
        }
        return doAction(VdcActionType.RunVm, params, action);
    }
}
#method_after
@Override
public Response start(Action action) {
    RunVmParams params;
    VdcActionType actionType;
    if (action.isSetVm()) {
        VM vm = action.getVm();
        validateEnums(VM.class, vm);
        actionType = VdcActionType.RunVmOnce;
        params = map(vm, map(map(getEntity(entityType, VdcQueryType.GetVmByVmId, new IdQueryParameters(guid), id, true), new VM()), new RunVmOnceParams(guid)));
        if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
            validateParameters(vm.getPlacementPolicy(), "host.id|name");
            params.setDestinationVdsId(getHostId(vm.getPlacementPolicy().getHost()));
        }
    } else {
        actionType = VdcActionType.RunVm;
        params = new RunVmParams(guid);
    }
    if (action.isSetPause() && action.isPause()) {
        params.setRunAndPause(true);
    }
    return doAction(actionType, params, action);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(vdsReturnaValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        return;
    }
    endStepJob();
    releaseVolumeLock();
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    if (!vdsReturnaValue.getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        setSucceeded(false);
        return;
    }
    endStepJob();
    releaseVolumeLock();
    setSucceeded(vdsReturnaValue.getSucceeded());
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<GlusterBrickEntity, VolumeListModel, VolumeBrickListModel> getVolumeBrickListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AddBrickPopupPresenterWidget> addBrickPopupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider, final Provider<ReplaceBrickPopupPresenterWidget> replaceBrickPopupProvider, final Provider<BrickAdvancedDetailsPopupPresenterWidget> brickDetailsPopupProvider) {
    return new SearchableDetailTabModelProvider<GlusterBrickEntity, VolumeListModel, VolumeBrickListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class, VolumeBrickListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeBrickListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAddBricksCommand()) {
                return addBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getReplaceBrickCommand()) {
                return replaceBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getBrickAdvancedDetailsCommand()) {
                return brickDetailsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VolumeBrickListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveBricksCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<GlusterBrickEntity, VolumeListModel, VolumeBrickListModel> getVolumeBrickListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<AddBrickPopupPresenterWidget> addBrickPopupProvider, final Provider<RemoveBrickPopupPresenterWidget> removeConfirmPopupProvider, final Provider<RemoveBrickPopupPresenterWidget> removeBrickPopupProvider, final Provider<ReplaceBrickPopupPresenterWidget> replaceBrickPopupProvider, final Provider<BrickAdvancedDetailsPopupPresenterWidget> brickDetailsPopupProvider) {
    return new SearchableDetailTabModelProvider<GlusterBrickEntity, VolumeListModel, VolumeBrickListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class, VolumeBrickListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(VolumeBrickListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAddBricksCommand()) {
                return addBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getRemoveBricksCommand()) {
                return removeBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getReplaceBrickCommand()) {
                return replaceBrickPopupProvider.get();
            } else if (lastExecutedCommand == getModel().getBrickAdvancedDetailsCommand()) {
                return brickDetailsPopupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(VolumeBrickListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveBricksCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        closeConfirmationWindow();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    } else if (command.getName().equals("stop_rebalance_from_status")) {
        // $NON-NLS-1$
        stopRebalance();
    }
}
#end_block

#method_before
private void onStopRebalance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    model.startProgress(null);
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    GlusterVolumeRebalanceParameters param = new GlusterVolumeRebalanceParameters(volumeEntity.getId(), false, false);
    Frontend.RunAction(VdcActionType.StopRebalanceGlusterVolume, param, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow();
            localModel.stopProgress();
            setConfirmWindow(null);
            // if(result.getReturnValue().getSucceeded()) {
            showRebalanceStatus();
        // }
        }
    });
}
#method_after
private void onStopRebalance() {
    ConfirmationModel model = (ConfirmationModel) getConfirmWindow();
    if (model.getProgress() != null) {
        return;
    }
    if (getSelectedItems() == null) {
        return;
    }
    model.startProgress(null);
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    GlusterVolumeRebalanceParameters param = new GlusterVolumeRebalanceParameters(volumeEntity.getId(), false, false);
    Frontend.RunAction(VdcActionType.StopRebalanceGlusterVolume, param, new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            ConfirmationModel localModel = (ConfirmationModel) getConfirmWindow();
            localModel.stopProgress();
            setConfirmWindow(null);
            showRebalanceStatus();
        }
    });
}
#end_block

#method_before
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) returnValue;
            cModel.stopProgress();
            if ((rebalanceStatusEntity == null) || (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.UNKNOWN)) {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusConfirmationMessage(volumeEntity.getName()));
                cModel.getCommands().add(rebalanceStatusOk);
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                    UICommand stopRebalanceFromStatus = // $NON-NLS-1$
                    new UICommand("stop_rebalance_from_status", VolumeListModel.this);
                    stopRebalanceFromStatus.setIsCancel(true);
                    stopRebalanceFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRebalance());
                    rebalanceStatusModel.getCommands().add(stopRebalanceFromStatus);
                    if (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.ABORTED) {
                        stopRebalanceFromStatus.setIsExecutionAllowed(false);
                    }
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                } else {
                    VolumeRebalanceStatusModel statusModel = (VolumeRebalanceStatusModel) getWindow();
                    statusModel.getCommands().get(0).setIsAvailable(false);
                    statusModel.showStatus(rebalanceStatusEntity);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#method_after
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    cModel.getCommands().add(rebalanceStatusOk);
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) returnValue;
            if ((rebalanceStatusEntity == null) || (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.UNKNOWN)) {
                cModel.stopProgress();
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusConfirmationMessage(volumeEntity.getName()));
            } else {
                setConfirmWindow(null);
                if (getWindow() == null) {
                    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                    setWindow(rebalanceStatusModel);
                    rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                    rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                    rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                    UICommand stopRebalanceFromStatus = // $NON-NLS-1$
                    new UICommand("stop_rebalance_from_status", VolumeListModel.this);
                    stopRebalanceFromStatus.setIsCancel(true);
                    stopRebalanceFromStatus.setTitle(ConstantsManager.getInstance().getConstants().stopRebalance());
                    rebalanceStatusModel.getCommands().add(stopRebalanceFromStatus);
                    stopRebalanceFromStatus.setIsExecutionAllowed(rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.STARTED);
                    // $NON-NLS-1$
                    UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                    cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                    cancelRebalance.setIsCancel(true);
                    rebalanceStatusModel.getCommands().add(cancelRebalance);
                } else {
                    VolumeRebalanceStatusModel statusModel = (VolumeRebalanceStatusModel) getWindow();
                    statusModel.getCommands().get(0).setIsExecutionAllowed(false);
                    statusModel.showStatus(rebalanceStatusEntity);
                }
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps == null) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    createJobToMonitor(task);
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step, task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#method_after
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(final VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        final GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        if (steps == null || steps.isEmpty()) {
            // the task may have been started from the CLI
            // need to add job to monitor
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    try {
                        createJobToMonitor(cluster, task);
                    } catch (VdcBLLException e) {
                        log.error("Error creating job for task from CLI", e);
                    }
                    return null;
                }
            });
        }
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step.getStepType(), task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#end_block

#method_before
private void createJobToMonitor(GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
        default:
            actionType = VdcActionType.Unknown;
    }
    VdcReturnValueBase result = Backend.getInstance().RunAction(VdcActionType.AddExternalJob, new AddInternalJobParameters(actionType, true));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid jobId = (Guid) result.getActionReturnValue();
    result = Backend.getInstance().RunAction(VdcActionType.AddExternalStep, new AddExternalStepParameters(jobId, "", StepEnum.EXECUTING));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
    Guid execStepId = (Guid) result.getActionReturnValue();
    result = Backend.getInstance().RunAction(VdcActionType.AddExternalStep, new AddExternalStepParameters(execStepId, "", step));
    if (!result.getSucceeded()) {
        // log and return
        throw new VdcBLLException(result.getFault().getError());
    }
}
#method_after
private void createJobToMonitor(VDSGroup cluster, GlusterAsyncTask task) {
    if (task.getStatus() != JobExecutionStatus.STARTED) {
        // there's no need to monitor jobs that are failed or completed
        return;
    }
    StepEnum step = task.getType().getStep();
    VdcActionType actionType;
    switch(step) {
        case REBALANCING_VOLUME:
            actionType = VdcActionType.StartRebalanceGlusterVolume;
            break;
        default:
            actionType = VdcActionType.Unknown;
    }
    Guid jobId = addJob(cluster, task, actionType);
    Guid execStepId = addExecutingStep(jobId);
    Guid asyncStepId = addAsyncTaskStep(cluster, task, step, execStepId);
    Step asyncStep = getStepDao().get(asyncStepId);
    ExecutionHandler.updateStepExternalId(asyncStep, task.getTaskId(), ExternalSystemType.GLUSTER);
}
#end_block

#method_before
private static String getTaskMessage(VDSGroup cluster, Step step, GlusterAsyncTask task) {
    if (task == null) {
        return null;
    }
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, cluster.getName());
    values.put(GlusterConstants.VOLUME, task.getTaskParameters().getVolumeName());
    values.put("status", task.getStatus().toString());
    values.put("info", task.getMessage());
    return ExecutionMessageDirector.resolveStepMessage(step.getStepType(), values);
}
#method_after
private static String getTaskMessage(VDSGroup cluster, StepEnum stepType, GlusterAsyncTask task) {
    if (task == null) {
        return null;
    }
    Map<String, String> values = getMessageMap(cluster, task);
    return ExecutionMessageDirector.resolveStepMessage(stepType, values);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    return null;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    // Not needed for admin operations.
    return Collections.emptyList();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retValue = super.canDoAction();
    if (getParameters().getActionType() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_EMPTY_DESCRIPTION);
        retValue = false;
    }
    return retValue;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retValue = super.canDoAction();
    if (getParameters().getActionType() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_EMPTY_ACTION_TYPE);
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, ActionGroup.INJECT_EXTERNAL_TASKS));
    return permissionList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionList = new ArrayList<PermissionSubject>();
    permissionList.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, getParameters().getActionType().getActionGroup()));
    return permissionList;
}
#end_block

#method_before
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#method_after
private static void initHostSeverities() {
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_HOST_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_HOST_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAME, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_ERROR_UPDATING_NAMES_ALL_TAKEN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_NAME_IS_ACTIVE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_AUTO_APPROVE_PATTERN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_EMPTY_ID, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_REGISTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_REGISTER_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_REGISTER_EXISTING_VDS_UPDATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ALERT_FENCE_IS_NOT_CONFIGURED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_TEST_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_OPERATION_SKIPPED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_FENCE_STATUS_VERIFICATION_FAILED, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_ALERT_SECONDARY_AGENT_USED_FOR_FENCE_OPERATION, AuditLogSeverity.ALERT);
    severities.put(AuditLogType.VDS_RUN_IN_NO_KVM_MODE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_VERSION_NOT_SUPPORTED_FOR_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CLUSTER_VERSION_NOT_SUPPORTED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_CPU_LOWER_THAN_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CPU_FLAGS_NX_IS_MISSING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_CPU_RETRIEVE_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SET_NONOPERATIONAL_IFACE_DOWN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_DOMAIN_DELAY_INTERVAL, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_ADD_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_ADD_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_RECOVER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_RECOVER_FAILED_VMS_UNKNOWN, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MAINTENANCE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MAINTENANCE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE_MIGRATION_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.HOST_REFRESHED_CAPABILITIES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.HOST_REFRESH_CAPABILITIES_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_REMOVE_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_RESTART, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_SELECTED_SPM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_RESTART, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_START, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_VDS_STOP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_VDS_STOP, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_SLOW_STORAGE_RESPONSE_TIME, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_FAILED_TO_RUN_VMS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_WARNING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INSTALL_IN_PROGRESS_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_INITIATED_RUN_VM_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_APPROVE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_APPROVE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_FAILED_TO_GET_HOST_HARDWARE_INFO, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIALIZING, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_VM_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_DETECTED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_HOSTED_ON_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALREADY_IN_REQUESTED_STATUS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_STATUS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_MANUAL_FENCE_FAILED_CALL_FENCE_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_VDS_MAINTENANCE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ALERT_FENCE_NO_PROXY_HOST, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_LOW_MEM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_MEM_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_CPU_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_NETWORK_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_HIGH_SWAP_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_SWAP, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_STORAGE_CONNECTION_FAILED_BUT_LAST_VDS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGES_CONNECTION_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_STORAGE_VDS_STATS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_LOW_DISK_SPACE_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VDS_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_ACTIVATE_FAILED_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_SET_NON_OPERATIONAL_VM_NETWORK_IS_BRIDGELESS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.EMULATED_MACHINES_INCOMPATIBLE_WITH_CLUSTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_TIME_DRIFT_ALERT, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.PROXY_HOST_SELECTION, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.VDS_UNTRUSTED, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private static void initClusterPolicySeverities() {
    severities.put(AuditLogType.USER_ADD_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_ADD_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_REMOVE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_UPDATE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
}
#method_after
private static void initClusterPolicySeverities() {
    severities.put(AuditLogType.USER_ADD_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_ADD_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_REMOVE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_CLUSTER_POLICY, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_TO_UPDATE_CLUSTER_POLICY, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY, AuditLogSeverity.ERROR);
}
#end_block

#method_before
@Override
public void updateBrickStatuses(List<GlusterBrickEntity> bricks) {
    for (GlusterBrickEntity brick : bricks) {
        updateBrickStatus(brick.getId(), brick.getStatus());
    }
}
#method_after
@Override
public void updateBrickStatuses(List<GlusterBrickEntity> bricks) {
    updateAllInBatch("UpdateGlusterVolumeBrickStatus", bricks, getBatchMapper());
}
#end_block

#method_before
@Override
public GlusterBrickEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(getGuidDefaultEmpty(rs, "id"));
    brick.setVolumeId(getGuidDefaultEmpty(rs, "volume_id"));
    Guid serverId = getGuidDefaultEmpty(rs, "server_id");
    brick.setServerId(serverId);
    // Update the brick with server name. This is useful as the brick is typically represented in the form
    // serverName:brickDirectory though the database table (gluster_volume_bricks) stores just the server id
    brick.setServerName(getHostNameOfServer(serverId));
    brick.setBrickDirectory(rs.getString("brick_dir"));
    brick.setBrickOrder(rs.getInt("brick_order"));
    brick.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    brick.getAsyncTask().setTaskId(getGuidDefaultEmpty(rs, "task_id"));
    return brick;
}
#method_after
@Override
public GlusterBrickEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterBrickEntity brick = new GlusterBrickEntity();
    brick.setId(getGuidDefaultEmpty(rs, "id"));
    brick.setVolumeId(getGuidDefaultEmpty(rs, "volume_id"));
    Guid serverId = getGuidDefaultEmpty(rs, "server_id");
    brick.setServerId(serverId);
    // Update the brick with server name. This is useful as the brick is typically represented in the form
    // serverName:brickDirectory though the database table (gluster_volume_bricks) stores just the server id
    brick.setServerName(getHostNameOfServer(serverId));
    brick.setBrickDirectory(rs.getString("brick_dir"));
    brick.setBrickOrder(rs.getInt("brick_order"));
    brick.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    brick.getAsyncTask().setTaskId(getGuid(rs, "task_id"));
    return brick;
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    super.setActionMessageParameters();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__START_REMOVE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_BRICK);
}
#method_after
@Override
protected void setActionMessageParameters() {
    super.setActionMessageParameters();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE_BRICKS_START);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_BRICK);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    if (getParameters().getBricks() == null || getParameters().getBricks().size() == 0) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_BRICKS_REQUIRED);
        return false;
    }
    if (getGlusterVolume().getBricks().size() == 1 || getGlusterVolume().getBricks().size() <= getParameters().getBricks().size()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REMOVE_ALL_BRICKS_FROM_VOLUME);
        return false;
    }
    if (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) {
        if (getParameters().getReplicaCount() < getGlusterVolume().getReplicaCount() - 1) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_REDUCE_REPLICA_COUNT_MORE_THAN_ONE);
            return false;
        } else if (getParameters().getReplicaCount() > getGlusterVolume().getReplicaCount()) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_CAN_NOT_INCREASE_REPLICA_COUNT);
            return false;
        }
    }
    return validateBricks(getParameters().getBricks());
}
#method_after
@Override
protected boolean canDoAction() {
    if (!super.canDoAction()) {
        return false;
    }
    GlusterBrickValidator brickValidator = new GlusterBrickValidator();
    return validate(brickValidator.validateBricks(getParameters().getBricks(), getGlusterVolume(), getParameters().getReplicaCount()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    int replicaCount = (getGlusterVolume().getVolumeType() == GlusterVolumeType.REPLICATE || getGlusterVolume().getVolumeType() == GlusterVolumeType.DISTRIBUTED_REPLICATE) ? getParameters().getReplicaCount() : 0;
    startSubStep();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(upServer.getId(), getGlusterVolumeName(), bricks, replicaCount, false));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    GlusterAsyncTask glusterTask = (GlusterAsyncTask) returnValue.getReturnValue();
    handleTaskReturn(glusterTask);
    updateBricksWithTaskID(glusterTask);
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#method_after
@Override
protected void executeCommand() {
    int replicaCount = getGlusterVolume().getVolumeType().isReplicatedType() ? getParameters().getReplicaCount() : 0;
    startSubStep();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StartRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(upServer.getId(), getGlusterVolumeName(), getParameters().getBricks(), replicaCount, false));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.START_REMOVING_GLUSTER_VOLUME_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    GlusterAsyncTask glusterTask = (GlusterAsyncTask) returnValue.getReturnValue();
    handleTaskReturn(glusterTask);
    updateBricksWithTaskID(glusterTask);
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#end_block

#method_before
protected void updateBricksWithTaskID(GlusterAsyncTask asyncTask) {
    for (GlusterBrickEntity brickEntity : getParameters().getBricks()) {
        getGlusterBrickDao().updateBrickTask(brickEntity.getId(), asyncTask.getTaskId());
    }
    getGlusterVolumeDao().updateVolumeTask(getGlusterVolumeId(), asyncTask.getTaskId());
}
#method_after
protected void updateBricksWithTaskID(GlusterAsyncTask asyncTask) {
    for (GlusterBrickEntity brickEntity : getParameters().getBricks()) {
        brickEntity.getAsyncTask().setTaskId(asyncTask.getTaskId());
    }
    getGlusterBrickDao().updateBrickTasksInBatch(getParameters().getBricks());
    getGlusterVolumeDao().updateVolumeTask(getGlusterVolumeId(), asyncTask.getTaskId());
}
#end_block

#method_before
@Override
protected StepEnum getStepType() {
    return StepEnum.REMOVING_GLUSTER_VOLUME_BIRCK;
}
#method_after
@Override
protected StepEnum getStepType() {
    return StepEnum.REMOVING_BRICKS;
}
#end_block

#method_before
protected void removeAllInBatch(String procedureName, Collection<T> paramValue, MapSqlParameterMapper<T> mapper) {
    getCallsHandler().executeStoredProcAsBatch(procedureName == null ? getProcedureNameForRemove() : procedureName, paramValue, mapper);
}
#method_after
protected void removeAllInBatch(String procedureName, Collection<T> paramValues, MapSqlParameterMapper<T> mapper) {
    getCallsHandler().executeStoredProcAsBatch(procedureName == null ? getProcedureNameForRemove() : procedureName, paramValues, mapper);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE_BRICK_STOP);
    super.setActionMessageParameters();
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REMOVE_BRICKS_STOP);
    super.setActionMessageParameters();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (volume.getAsyncTask() == null || volume.getAsyncTask().getType() != GlusterTaskType.REMOVE_BRICK || volume.getAsyncTask().getStatus() != JobExecutionStatus.STARTED) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICK_NOT_STARTED);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity volume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (!(GlusterTaskUtils.isTaskOfType(volume, GlusterTaskType.REMOVE_BRICK)) || !(GlusterTaskUtils.isTaskStatus(volume, JobExecutionStatus.STARTED))) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REMOVE_BRICKS_NOT_STARTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected StepEnum getStepType() {
    return StepEnum.REMOVING_BRICK;
}
#method_after
@Override
protected StepEnum getStepType() {
    return StepEnum.REMOVING_BRICKS;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StopRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), volume.getName(), volume.getBricks(), volume.getReplicaCount()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    endStepJob();
    releaseVolumeLock();
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#method_after
@Override
protected void executeCommand() {
    GlusterVolumeEntity volume = getGlusterVolume();
    VDSReturnValue returnValue = runVdsCommand(VDSCommandType.StopRemoveGlusterVolumeBricks, new GlusterVolumeRemoveBricksVDSParameters(getUpServer().getId(), volume.getName(), getParameters().getBricks()));
    setSucceeded(returnValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_FAILED, returnValue.getVdsError().getMessage());
        return;
    }
    endStepJob();
    releaseVolumeLock();
    getReturnValue().setActionReturnValue(returnValue.getReturnValue());
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOPPED;
    } else {
        return AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    if (getSucceeded()) {
        return AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP;
    } else {
        return AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP_FAILED;
    }
}
#end_block

#method_before
@Test
public void testExecuteCommand() {
    cmd = spy(new StopRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTask, getBricks(volumeWithRemoveBricksTask, 2))));
    prepareMocks(cmd);
    mockBackend(true, null);
    assertTrue(cmd.canDoAction());
    cmd.executeCommand();
    verify(cmd, times(1)).endStepJob();
    verify(cmd, times(1)).releaseVolumeLock();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOPPED);
}
#method_after
@Test
public void testExecuteCommand() {
    cmd = spy(new StopRemoveGlusterVolumeBricksCommand(new GlusterVolumeRemoveBricksParameters(volumeWithRemoveBricksTask, getBricks(volumeWithRemoveBricksTask, 2))));
    prepareMocks(cmd);
    mockBackend(true, null);
    assertTrue(cmd.canDoAction());
    cmd.executeCommand();
    verify(cmd, times(1)).endStepJob();
    verify(cmd, times(1)).releaseVolumeLock();
    assertEquals(cmd.getAuditLogTypeValue(), AuditLogType.GLUSTER_VOLUME_REMOVE_BRICKS_STOP);
}
#end_block

#method_before
@Override
public void run() {
    ExternalSchedulerDiscoveryResult discoveryResult = ExternalSchedulerFactory.getInstance().runDiscover();
    if (discoveryResult != null) {
        updateDB(discoveryResult);
        log.info("PolicyUnits updated");
    } else {
        markExternalPoliciesAsDisabled();
        log.warn("Discovery returned empty result, disabled external policy units");
    }
}
#method_after
@Override
public void run() {
    ExternalSchedulerDiscoveryResult discoveryResult = ExternalSchedulerFactory.getInstance().runDiscover();
    if (discoveryResult != null) {
        updateDB(discoveryResult);
        log.info("PolicyUnits updated");
    } else {
        AuditLogableBase loggable = new AuditLogableBase();
        AuditLogDirector.log(loggable, AuditLogType.FAILED_TO_CONNECT_TO_SCHEDULER_PROXY);
        markAllExternalPoliciesAsDisabled();
        log.warn("Discovery returned empty result, disabled external policy units");
    }
}
#end_block

#method_before
private void updateDB(ExternalSchedulerDiscoveryResult discoveryResult) {
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    List<PolicyUnit> foundInBoth = new LinkedList<PolicyUnit>();
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getFilters()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.Filter);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getScores()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.Weight);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getBalance()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.LoadBalancing);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    allPolicyUnits.removeAll(foundInBoth);
    // found in the db but not found in discovery, mark as such
    markExternalPoliciesAsDisabled();
    SchedulingManager.getInstance().reloadPolicyUnits();
}
#method_after
private void updateDB(ExternalSchedulerDiscoveryResult discoveryResult) {
    List<PolicyUnit> allPolicyUnits = getPolicyUnitDao().getAll();
    List<PolicyUnit> foundInBoth = new LinkedList<PolicyUnit>();
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getFilters()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.Filter);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getScores()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.Weight);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    for (ExternalSchedulerDiscoveryUnit unit : discoveryResult.getBalance()) {
        PolicyUnit found = compareToDB(allPolicyUnits, unit, PolicyUnitType.LoadBalancing);
        if (found != null) {
            foundInBoth.add(found);
        }
    }
    allPolicyUnits.removeAll(foundInBoth);
    // found in the db but not found in discovery, mark as such
    markExternalPoliciesAsDisabled(allPolicyUnits);
    SchedulingManager.getInstance().reloadPolicyUnits();
}
#end_block

#method_before
public void markExternalPoliciesAsDisabled() {
    for (PolicyUnit policyUnit : getPolicyUnitDao().getAll()) {
        if (!policyUnit.isInternal()) {
            policyUnit.setEnabled(false);
            getPolicyUnitDao().update(policyUnit);
        }
    }
}
#method_after
private void markExternalPoliciesAsDisabled(List<PolicyUnit> units) {
    for (PolicyUnit policyUnit : units) {
        if (!policyUnit.isInternal()) {
            policyUnit.setEnabled(false);
            getPolicyUnitDao().update(policyUnit);
        }
    }
}
#end_block

#method_before
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        discoveryThread.start();
    } else {
        discoveryThread.markExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#method_after
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        discoveryThread.start();
    } else {
        discoveryThread.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#end_block

#method_before
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        discoveryThread.start();
    } else {
        discoveryThread.markExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#method_after
public void init() {
    log.info("Initializing Scheduling manager");
    loadPolicyUnits();
    loadClusterPolicies();
    ExternalSchedulerDiscoveryThread discoveryThread = new ExternalSchedulerDiscoveryThread();
    if (Config.<Boolean>GetValue(ConfigValues.ExternalSchedulerEnabled)) {
        log.info("Starting external scheduler dicovery thread");
        discoveryThread.start();
    } else {
        discoveryThread.markAllExternalPoliciesAsDisabled();
        log.info("External scheduler disabled, discovery skipped");
    }
    log.info("Initialized Scheduling manager");
}
#end_block

#method_before
@Override
public int compare(VnicProfileView vnicProfile1, VnicProfileView vnicProfile2) {
    if (vnicProfile1 == null) {
        return vnicProfile2 == null ? 0 : 1;
    } else if (vnicProfile2 == null) {
        return -1;
    }
    int retVal = lexoNumeric.compare(vnicProfile1.getNetworkName(), vnicProfile2.getNetworkName());
    return retVal == 0 ? lexoNumeric.compare(vnicProfile1.getName(), vnicProfile2.getName()) : retVal;
}
#method_after
@Override
public int compare(VnicProfileView vnicProfile1, VnicProfileView vnicProfile2) {
    if (vnicProfile1 == VnicProfileView.EMPTY) {
        return vnicProfile2 == VnicProfileView.EMPTY ? 0 : 1;
    } else if (vnicProfile2 == VnicProfileView.EMPTY) {
        return -1;
    }
    int retVal = lexoNumeric.compare(vnicProfile1.getNetworkName(), vnicProfile2.getNetworkName());
    return retVal == 0 ? lexoNumeric.compare(vnicProfile1.getName(), vnicProfile2.getName()) : retVal;
}
#end_block

#method_before
@Override
public int compare(PolicyUnit pu1, PolicyUnit pu2) {
    if (pu1.isInternal() != pu2.isInternal()) {
        return !pu1.isInternal() ? -1 : 1;
    }
    if (pu1.isEnabled() != pu2.isEnabled()) {
        return !pu1.isEnabled() ? -1 : 1;
    }
    if (pu1.getPolicyUnitType() != pu2.getPolicyUnitType()) {
        if (pu1.getPolicyUnitType().equals(PolicyUnitType.Filter)) {
            return -1;
        }
        if (pu2.getPolicyUnitType().equals(PolicyUnitType.Filter)) {
            return 1;
        }
        if (pu1.getPolicyUnitType().equals(PolicyUnitType.LoadBalancing)) {
            return 1;
        }
        if (pu2.getPolicyUnitType().equals(PolicyUnitType.LoadBalancing)) {
            return -1;
        }
    }
    return lexoNumeric.compare(pu1.getName(), pu2.getName());
}
#method_after
@Override
public int compare(PolicyUnit pu1, PolicyUnit pu2) {
    if (pu1.isInternal() != pu2.isInternal()) {
        return !pu1.isInternal() ? -1 : 1;
    }
    if (pu1.isEnabled() != pu2.isEnabled()) {
        return !pu1.isEnabled() ? -1 : 1;
    }
    if (pu1.getPolicyUnitType() != pu2.getPolicyUnitType()) {
        if (pu1.getPolicyUnitType().equals(PolicyUnitType.Filter) || pu2.getPolicyUnitType().equals(PolicyUnitType.LoadBalancing)) {
            return -1;
        }
        if (pu2.getPolicyUnitType().equals(PolicyUnitType.Filter) || pu1.getPolicyUnitType().equals(PolicyUnitType.LoadBalancing)) {
            return 1;
        }
    }
    return lexoNumeric.compare(pu1.getName(), pu2.getName());
}
#end_block

#method_before
private void initTable(final ApplicationResources resources, final ApplicationConstants constants, ApplicationMessages messages) {
    policyUnitTable = new ListModelObjectCellTable<PolicyUnit, ListModel>();
    policyUnitTableContainer.add(policyUnitTable);
    policyUnitTable.addColumn(new WebAdminImageResourceColumn<PolicyUnit>() {

        @Override
        public ImageResource getValue(PolicyUnit object) {
            if (object.isInternal()) {
                setTitle(constants.internalPolicyUnit());
                return resources.lockImage();
            }
            setTitle(constants.externalPolicyUnit());
            return resources.exteranlPolicyUnitImage();
        }
    }, constants.empty(), // $NON-NLS-1$
    "20px");
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            return object.getName();
        }
    }, constants.policyUnitName());
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            return EnumTranslator.createAndTranslate(object.getPolicyUnitType());
        }
    }, constants.policyUnitType());
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            if (!object.isEnabled()) {
                return constants.disabledPolicyUnit();
            }
            // $NON-NLS-1$
            return "";
        }
    });
    Column<PolicyUnit, String> removeButtonColumn = new Column<PolicyUnit, String>(new NullableButtonCell()) {

        @Override
        public String getValue(PolicyUnit object) {
            if (!object.isEnabled()) {
                return constants.removePolicyUnit();
            }
            return null;
        }
    };
    // $NON-NLS-1$
    policyUnitTable.addColumn(removeButtonColumn, constants.empty(), "50px");
    removeButtonColumn.setFieldUpdater(new FieldUpdater<PolicyUnit, String>() {

        @Override
        public void update(int index, PolicyUnit object, String value) {
            model.remove(object);
        }
    });
}
#method_after
private void initTable(final ApplicationResources resources, final ApplicationConstants constants, ApplicationMessages messages) {
    policyUnitTable = new ListModelObjectCellTable<PolicyUnit, ListModel>();
    policyUnitTable.enableColumnResizing();
    policyUnitTableContainer.add(policyUnitTable);
    policyUnitTable.addColumn(new WebAdminImageResourceColumn<PolicyUnit>() {

        @Override
        public ImageResource getValue(PolicyUnit object) {
            if (object.isInternal()) {
                setTitle(constants.internalPolicyUnit());
                return resources.lockImage();
            }
            setTitle(constants.externalPolicyUnit());
            return resources.exteranlPolicyUnitImage();
        }
    }, constants.empty(), // $NON-NLS-1$
    "20px");
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            return object.getName();
        }
    }, constants.policyUnitName(), // $NON-NLS-1$
    "180px");
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            return EnumTranslator.createAndTranslate(object.getPolicyUnitType());
        }
    }, constants.policyUnitType(), // $NON-NLS-1$
    "100px");
    policyUnitTable.addColumn(new TextColumnWithTooltip<PolicyUnit>() {

        @Override
        public String getValue(PolicyUnit object) {
            if (!object.isEnabled()) {
                return constants.disabledPolicyUnit();
            }
            return constants.empty();
        }
    }, constants.empty(), // $NON-NLS-1$
    "75px");
    Column<PolicyUnit, String> removeButtonColumn = new Column<PolicyUnit, String>(new NullableButtonCell()) {

        @Override
        public String getValue(PolicyUnit object) {
            if (!object.isEnabled()) {
                return constants.removePolicyUnit();
            }
            return null;
        }
    };
    // $NON-NLS-1$
    policyUnitTable.addColumn(removeButtonColumn, constants.empty(), "80px");
    removeButtonColumn.setFieldUpdater(new FieldUpdater<PolicyUnit, String>() {

        @Override
        public void update(int index, PolicyUnit object, String value) {
            model.remove(object);
        }
    });
}
#end_block

#method_before
private void managePolicyUnits() {
    if (getWindow() != null) {
        return;
    }
    policyUnitModel = new ManagePolicyUnitModel();
    policyUnitModel.setTitle(ConstantsManager.getInstance().getConstants().managePolicyUnits());
    // $NON-NLS-1$
    policyUnitModel.setHashName("manage_policy_units");
    policyUnitModel.setPolicyUnits(new ListModel());
    policyUnitModel.getPolicyUnits().setItems(sort(policyUnits));
    policyUnitModel.setRefreshPolicyUnits(this);
    // $NON-NLS-1$
    UICommand command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().close());
    command.setIsCancel(true);
    policyUnitModel.getCommands().add(command);
    setWindow(policyUnitModel);
}
#method_after
private void managePolicyUnits() {
    if (getWindow() != null) {
        return;
    }
    policyUnitModel = new ManagePolicyUnitModel();
    policyUnitModel.setTitle(ConstantsManager.getInstance().getConstants().managePolicyUnits());
    // $NON-NLS-1$
    policyUnitModel.setHashName("manage_policy_units");
    policyUnitModel.setPolicyUnits(new ListModel());
    policyUnitModel.getPolicyUnits().setItems(sort(policyUnits));
    policyUnitModel.getRefreshPolicyUnitsEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            setIsQueryFirstTime(true);
            syncSearch();
        }
    });
    // $NON-NLS-1$
    UICommand command = new UICommand("Cancel", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().close());
    command.setIsCancel(true);
    policyUnitModel.getCommands().add(command);
    setWindow(policyUnitModel);
}
#end_block

#method_before
public void remove(final PolicyUnit policyUnit) {
    Frontend.RunAction(VdcActionType.RemoveExternalPolicyUnit, new RemoveExternalPolicyUnitParameters(policyUnit.getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            if (result.getReturnValue() != null && result.getReturnValue().getSucceeded()) {
                getRefreshPolicyUnits().refreshPolicyUnits();
            }
        }
    });
}
#method_after
public void remove(final PolicyUnit policyUnit) {
    Frontend.RunAction(VdcActionType.RemoveExternalPolicyUnit, new RemoveExternalPolicyUnitParameters(policyUnit.getId()), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            getRefreshPolicyUnitsEvent().raise(this, null);
        }
    });
}
#end_block

#method_before
private void closeConfirmationWindow() {
    getConfirmWindow().stopProgress();
    setConfirmWindow(null);
}
#method_after
private void closeConfirmationWindow() {
    if (getConfirmWindow() == null) {
        return;
    }
    getConfirmWindow().stopProgress();
    setConfirmWindow(null);
}
#end_block

#method_before
@Override
protected void executeIrsBrokerCommand() {
    floppyList = getIrsProxy().getFloppyList(getParameters().getStoragePoolId().toString());
    proceedProxyReturnValue();
    setReturnValue(floppyList.getFileToMetadata());
}
#method_after
@Override
protected void executeIrsBrokerCommand() {
    floppyList = getIrsProxy().getFloppyList(getParameters().getStoragePoolId().toString());
    proceedProxyReturnValue();
    setReturnValue(floppyList.getFileStats());
}
#end_block

#method_before
private static boolean refreshIsoFileListMetaData(final Guid repoStorageDomainId, final RepoFileMetaDataDAO repoFileMetaDataDao, final Map<String, Map<String, String>> isoDomainList, final ImageFileType imageType) {
    Lock syncObject = getSyncObject(repoStorageDomainId, imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                long currentTime = System.currentTimeMillis();
                repoFileMetaDataDao.removeRepoDomainFileList(repoStorageDomainId, imageType);
                RepoImage repo_md;
                for (Map.Entry<String, Map<String, String>> isoFile : isoDomainList.entrySet()) {
                    repo_md = new RepoImage();
                    repo_md.setLastRefreshed(currentTime);
                    repo_md.setSize(retrieveIsoFileSize(isoFile));
                    repo_md.setRepoDomainId(repoStorageDomainId);
                    repo_md.setDateCreated(null);
                    repo_md.setRepoImageId(isoFile.getKey());
                    repo_md.setRepoImageName(null);
                    repo_md.setFileType(imageType);
                    repoFileMetaDataDao.addRepoFileMap(repo_md);
                }
                return true;
            }
        });
    } finally {
        syncObject.unlock();
    }
}
#method_after
private static boolean refreshIsoFileListMetaData(final Guid repoStorageDomainId, final RepoFileMetaDataDAO repoFileMetaDataDao, final Map<String, Map<String, Object>> fileStats, final ImageFileType imageType) {
    Lock syncObject = getSyncObject(repoStorageDomainId, imageType);
    try {
        syncObject.lock();
        return (Boolean) TransactionSupport.executeInScope(TransactionScopeOption.RequiresNew, new TransactionMethod<Object>() {

            @Override
            public Object runInTransaction() {
                long currentTime = System.currentTimeMillis();
                repoFileMetaDataDao.removeRepoDomainFileList(repoStorageDomainId, imageType);
                RepoImage repo_md;
                for (Map.Entry<String, Map<String, Object>> entry : fileStats.entrySet()) {
                    repo_md = new RepoImage();
                    repo_md.setLastRefreshed(currentTime);
                    repo_md.setSize(retrieveIsoFileSize(entry));
                    repo_md.setRepoDomainId(repoStorageDomainId);
                    repo_md.setDateCreated(null);
                    repo_md.setRepoImageId(entry.getKey());
                    repo_md.setRepoImageName(null);
                    repo_md.setFileType(imageType);
                    repoFileMetaDataDao.addRepoFileMap(repo_md);
                }
                return true;
            }
        });
    } finally {
        syncObject.unlock();
    }
}
#end_block

#method_before
private static long retrieveIsoFileSize(Map.Entry<String, Map<String, String>> isoFile) {
    // cannot determine the correct size of the iso file.
    if (isoFile.getValue().isEmpty() || !isoFile.getValue().containsKey("size")) {
        return 0;
    } else {
        return Long.valueOf(isoFile.getValue().get("size"));
    }
}
#method_after
private static long retrieveIsoFileSize(Map.Entry<String, Map<String, Object>> fileStats) {
    try {
        return Long.valueOf((String) fileStats.getValue().get(VdsProperties.size));
    } catch (RuntimeException e) {
        // Illegal number or null are treated as not available,
        // handling exception in UI will be much more complicated.
        log.errorFormat("File's '{0}' size is illegal number", fileStats.getKey(), e);
        return StorageConstants.SIZE_IS_NOT_AVAILABLE;
    }
}
#end_block

#method_before
private boolean updateIsoListFromVDSM(Guid repoStoragePoolId, Guid repoStorageDomainId) {
    boolean refreshIsoSucceeded = false;
    if (repoStorageDomainId != null) {
        try {
            // Get Iso domain file list from storage pool.
            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetIsoList, new IrsBaseVDSCommandParameters(repoStoragePoolId));
            @SuppressWarnings("unchecked")
            Map isoDomainList = (Map) returnValue.getReturnValue();
            if (returnValue.getSucceeded() && isoDomainList != null) {
                log.debugFormat("The refresh process from VDSM, for Iso files succeeded.");
                // Set the Iso domain file list fetched from VDSM into the DB.
                refreshIsoSucceeded = refreshIsoFileListMetaData(repoStorageDomainId, repoStorageDom, isoDomainList, ImageFileType.ISO);
            }
        } catch (Exception e) {
            refreshIsoSucceeded = false;
            log.warnFormat("The refresh process from VDSM, for Iso files failed.");
            log.error(e);
        }
    }
    return refreshIsoSucceeded;
}
#method_after
private boolean updateIsoListFromVDSM(Guid repoStoragePoolId, Guid repoStorageDomainId) {
    boolean refreshIsoSucceeded = false;
    if (repoStorageDomainId != null) {
        try {
            // Get Iso domain file list from storage pool.
            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetIsoList, new IrsBaseVDSCommandParameters(repoStoragePoolId));
            @SuppressWarnings("unchecked")
            Map<String, Map<String, Object>> fileStats = (Map<String, Map<String, Object>>) returnValue.getReturnValue();
            if (returnValue.getSucceeded() && fileStats != null) {
                log.debugFormat("The refresh process from VDSM, for Iso files succeeded.");
                // Set the Iso domain file list fetched from VDSM into the DB.
                refreshIsoSucceeded = refreshIsoFileListMetaData(repoStorageDomainId, repoStorageDom, fileStats, ImageFileType.ISO);
            }
        } catch (Exception e) {
            refreshIsoSucceeded = false;
            log.warnFormat("The refresh process from VDSM, for Iso files failed.");
            log.error(e);
        }
    }
    return refreshIsoSucceeded;
}
#end_block

#method_before
private boolean updateFloppyListFromVDSM(Guid repoStoragePoolId, Guid repoStorageDomainId) {
    boolean refreshFloppySucceeded = false;
    if (repoStorageDomainId != null) {
        try {
            // Get Iso domain floppy file list from storage pool.
            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetFloppyList, new IrsBaseVDSCommandParameters(repoStoragePoolId));
            @SuppressWarnings("unchecked")
            Map<String, Map<String, String>> isoDomainFloppyList = (Map<String, Map<String, String>>) returnValue.getReturnValue();
            if (returnValue.getSucceeded() && isoDomainFloppyList != null) {
                // Set the Iso domain floppy file list fetched from VDSM into the DB.
                refreshFloppySucceeded = refreshIsoFileListMetaData(repoStorageDomainId, repoStorageDom, isoDomainFloppyList, ImageFileType.Floppy);
            }
            log.debugFormat("The refresh process from VDSM, for Floppy files succeeded.");
        } catch (Exception e) {
            refreshFloppySucceeded = false;
            log.warnFormat("The refresh process from VDSM, for Floppy files failed.");
            log.error(e);
        }
    }
    return refreshFloppySucceeded;
}
#method_after
private boolean updateFloppyListFromVDSM(Guid repoStoragePoolId, Guid repoStorageDomainId) {
    boolean refreshFloppySucceeded = false;
    if (repoStorageDomainId != null) {
        try {
            // Get Iso domain floppy file list from storage pool.
            VDSReturnValue returnValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.GetFloppyList, new IrsBaseVDSCommandParameters(repoStoragePoolId));
            @SuppressWarnings("unchecked")
            Map<String, Map<String, Object>> fileStats = (Map<String, Map<String, Object>>) returnValue.getReturnValue();
            if (returnValue.getSucceeded() && fileStats != null) {
                // Set the Iso domain floppy file list fetched from VDSM into the DB.
                refreshFloppySucceeded = refreshIsoFileListMetaData(repoStorageDomainId, repoStorageDom, fileStats, ImageFileType.Floppy);
            }
            log.debugFormat("The refresh process from VDSM, for Floppy files succeeded.");
        } catch (Exception e) {
            refreshFloppySucceeded = false;
            log.warnFormat("The refresh process from VDSM, for Floppy files failed.");
            log.error(e);
        }
    }
    return refreshFloppySucceeded;
}
#end_block

#method_before
@Override
protected void executeVdsBrokerCommand() {
    isoList = getBroker().getIsoList(getParameters().getStoragePoolId().toString());
    proceedProxyReturnValue();
    setReturnValue(isoList.getFileToMetadata());
}
#method_after
@Override
protected void executeVdsBrokerCommand() {
    isoList = getBroker().getIsoList(getParameters().getStoragePoolId().toString());
    proceedProxyReturnValue();
    setReturnValue(isoList.getFileStats());
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeActivityColumn(), constants.activitiesOnVolume(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> rebalanceSubActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    rebalanceSubActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    rebalanceSubActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopRebalanceCommand();
        }
    });
    rebalanceSubActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.statusRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStatusRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume(), rebalanceSubActions, CommandLocation.ContextAndToolBar));
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    MenuCell<GlusterVolumeEntity> rebalanceMenuCell = getRebalanceActivityMenu(constants);
    List<HasCell<GlusterVolumeEntity, ?>> list = new ArrayList<HasCell<GlusterVolumeEntity, ?>>();
    list.add(new VolumeActivityStatusColumn());
    list.add(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(new VolumeActivitySeperatorCell<GlusterVolumeEntity>()) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    });
    list.add(new Column<GlusterVolumeEntity, GlusterVolumeEntity>(rebalanceMenuCell) {

        @Override
        public GlusterVolumeEntity getValue(GlusterVolumeEntity object) {
            return object;
        }
    });
    getTable().addColumn(new VolumeActivityColumn(list), constants.activitiesOnVolume(), // $NON-NLS-1$
    "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
}
#end_block

#method_before
public String getTransportTypes() {
    return transportTypes;
}
#method_after
public Set<TransportType> getTransportTypes() {
    return transportTypes;
}
#end_block

#method_before
public void setTransportTypes(Set<TransportType> transportTypes) {
    Translator transportTypeTranslator = EnumTranslator.Create(TransportType.class);
    StringBuilder transportTypesBuilder = new StringBuilder();
    Iterator<TransportType> iterator = transportTypes.iterator();
    while (iterator.hasNext()) {
        TransportType transportType = iterator.next();
        if (transportTypeTranslator.containsKey(transportType)) {
            transportTypesBuilder.append(transportTypeTranslator.get(transportType));
        } else {
            transportTypesBuilder.append(transportType.toString());
        }
        if (iterator.hasNext()) {
            // $NON-NLS-1$
            transportTypesBuilder.append(", ");
        }
    }
    this.transportTypes = new String(transportTypesBuilder.toString());
}
#method_after
public void setTransportTypes(Set<TransportType> transportTypes) {
    this.transportTypes = transportTypes;
}
#end_block

#method_before
void initTable(ApplicationResources resources, final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<RepoImage> fileNameColumn = new TextColumnWithTooltip<RepoImage>() {

        @Override
        public String getValue(RepoImage object) {
            return object.getRepoImageTitle();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(fileNameColumn, constants.fileNameIso(), "500px");
    TextColumnWithTooltip<RepoImage> typeColumn = new TextColumnWithTooltip<RepoImage>() {

        @Override
        public String getValue(RepoImage object) {
            return object.getFileType().toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(typeColumn, constants.typeIso(), "200px");
    TextColumnWithTooltip<RepoImage> sizeColumn = new DiskSizeColumn<RepoImage>(DiskSizeUnit.BYTE, Format.FORMATTED) {

        @Override
        protected Long getRawValue(RepoImage object) {
            return object.getSize();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sizeColumn, constants.actualSizeTemplate(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<RepoImage>(constants.importImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getImportImagesCommand();
        }
    });
    getTable().showRefreshButton();
}
#method_after
void initTable(ApplicationResources resources, final ApplicationConstants constants) {
    getTable().enableColumnResizing();
    TextColumnWithTooltip<RepoImage> fileNameColumn = new TextColumnWithTooltip<RepoImage>() {

        @Override
        public String getValue(RepoImage object) {
            return object.getRepoImageTitle();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(fileNameColumn, constants.fileNameIso(), "500px");
    TextColumnWithTooltip<RepoImage> typeColumn = new TextColumnWithTooltip<RepoImage>() {

        @Override
        public String getValue(RepoImage object) {
            return object.getFileType().toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(typeColumn, constants.typeIso(), "200px");
    TextColumnWithTooltip<RepoImage> sizeColumn = new DiskSizeColumn<RepoImage>(SizeConverter.SizeUnit.BYTES, DiskSizeRenderer.Format.HUMAN_READABLE) {

        @Override
        protected Long getRawValue(RepoImage object) {
            return object.getSize();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(sizeColumn, constants.actualSizeTemplate(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<RepoImage>(constants.importImage()) {

        @Override
        protected UICommand resolveCommand() {
            return getDetailModel().getImportImagesCommand();
        }
    });
    getTable().showRefreshButton();
}
#end_block

#method_before
protected boolean isUnavailable(T size) {
    return size == null;
}
#method_after
protected boolean isUnavailable(T size) {
    return size == null || size.longValue() == StorageConstants.SIZE_IS_NOT_AVAILABLE;
}
#end_block

#method_before
@Override
public String render(T size) {
    if (isUnavailable(size)) {
        return CONSTANTS.unAvailablePropertyLabel();
    }
    double sizeInGB = getSizeInGigabytes(size);
    if (format == Format.DEFAULT) {
        // $NON-NLS-1$ //$NON-NLS-2$
        return (sizeInGB >= 1) ? Double.valueOf(sizeInGB).longValue() + " GB" : "< 1 GB";
    } else {
        return format(sizeInGB);
    }
}
#method_after
@Override
public String render(T size) {
    if (isUnavailable(size)) {
        return CONSTANTS.unAvailablePropertyLabel();
    }
    switch(format) {
        case GIGABYTE:
            return renderGigabyteSize(size.longValue());
        case HUMAN_READABLE:
            return renderHumanReadableSize(size.longValue());
        default:
            // $NON-NLS-1$ //$NON-NLS-2$
            throw new RuntimeException("Format '" + format + "' is not supported!");
    }
}
#end_block

#method_before
protected boolean updateVnicForBackwardCompatibility() {
    if (!validate(VnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), getParameters().getNetworkName(), getParameters().isPortMirroring(), getVm().getStaticData(), getCurrentUser().getUserId()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean updateVnicForBackwardCompatibility() {
    if (!validate(VnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), getVm().getStaticData(), getCurrentUser().getUserId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
@NotNull(message = VmNic.VALIDATION_MESSAGE_MAC_ADDRESS_NOT_NULL, groups = { UpdateVmNic.class })
@Pattern.List({ @Pattern(regexp = "(^$)|(" + UNICAST_MAC_ADDRESS_FORMAT + ")", message = VmNic.VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { CreateEntity.class }), @Pattern(regexp = UNICAST_MAC_ADDRESS_FORMAT, message = VmNic.VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { UpdateEntity.class }) })
@Override
public String getMacAddress() {
    return super.getMacAddress();
}
#method_after
@NotNull(message = VmNic.VALIDATION_MESSAGE_MAC_ADDRESS_NOT_NULL, groups = { UpdateVmNic.class })
@Pattern.List({ @Pattern(regexp = "(^$)|(" + UNICAST_MAC_ADDRESS_FORMAT + ")", message = VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { CreateEntity.class }), @Pattern(regexp = UNICAST_MAC_ADDRESS_FORMAT, message = VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { UpdateEntity.class }), @Pattern(regexp = NON_NULLABLE_MAC_ADDRESS_FORMAT, message = VALIDATION_MESSAGE_MAC_ADDRESS_INVALID, groups = { CreateEntity.class, UpdateEntity.class }) })
@Override
public String getMacAddress() {
    return super.getMacAddress();
}
#end_block

#method_before
private String createMacAddress(String value) {
    StringBuilder builder = new StringBuilder();
    for (int j = 0; j < value.length(); j += 2) {
        String group = value.substring(j, j + 2);
        // skip multi-cast MAC Addresses
        if (j == 0) {
            if (StringUtils.contains(MAC_ADDRESS_MULTICAST_MSB, group.charAt(1))) {
                return null;
            }
        }
        builder.append(group);
        builder.append(":");
    }
    builder.deleteCharAt(builder.length() - 1);
    return builder.toString();
}
#method_after
private String createMacAddress(String value) {
    StringBuilder builder = new StringBuilder();
    for (int j = 0; j < value.length(); j += 2) {
        String group = value.substring(j, j + 2);
        // skip multi-cast MAC Addresses
        if (j == 0 && StringUtils.contains(MAC_ADDRESS_MULTICAST_LSB, group.charAt(1))) {
            return null;
        }
        builder.append(group);
        if (j + 2 < value.length()) {
            builder.append(":");
        }
    }
    return builder.toString();
}
#end_block

#method_before
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBrickStatus(String volumeName, String[] bricksList, int replicaCount) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeRemoveBrickStatus(volumeName, bricksList, replicaCount);
        GlusterVolumeTaskReturnForXmlRpc wrapper = new GlusterVolumeTaskReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRemoveBrickStatus(String volumeName, String[] bricksList) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeRemoveBrickStatus(volumeName, bricksList);
        GlusterVolumeTaskReturnForXmlRpc wrapper = new GlusterVolumeTaskReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case RemoveGlusterServerFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBrickStatusFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#method_after
@Override
protected void proceedProxyReturnValue() {
    VdcBllErrors returnStatus = GetReturnValueFromStatus(getReturnStatus());
    switch(returnStatus) {
        case GlusterGeneralException:
        case GlusterPermissionDeniedException:
        case GlusterSyntaxErrorException:
        case GlusterMissingArgumentException:
        case GlusterCmdExecFailedException:
        case GlusterXmlErrorException:
        case GlusterVolumeCreateFailed:
        case GlusterVolumeStartFailed:
        case GlusterVolumeStopFailed:
        case AddBricksToGlusterVolumeFailed:
        case GlusterVolumeSetOptionFailed:
        case GlusterVolumeRebalanceStartFailed:
        case GlusterVolumeDeleteFailed:
        case GlusterVolumeReplaceBrickStartFailed:
        case GlusterVolumeListFailed:
        case GlusterVolumeOptionInfoFailed:
        case GlusterVolumeResetOptionsFailed:
        case GlusterVolumeRemoveBricksFailed:
        case GlusterVolumeProfileStartFailed:
        case GlusterVolumeProfileStopFailed:
        case GlusterAddHostFailed:
        case RemoveGlusterServerFailed:
        case GlusterPeerListFailed:
        case GlusterVolumeStatusFailed:
        case GlusterVolumeProfileInfoFailed:
        case GlusterHookFailed:
        case GlusterHookEnableFailed:
        case GlusterHookDisableFailed:
        case GlusterHookNotFound:
        case GlusterHookListException:
        case GlusterHostUUIDNotFound:
        case GlusterHookConflict:
        case GlusterServicesListFailed:
        case GlusterHookUpdateFailed:
        case GlusterHookAlreadyExists:
        case GlusterHookChecksumMismatch:
        case GlusterHookAddFailed:
        case GlusterHookRemoveFailed:
        case GlusterServicesActionFailed:
        case GlusterServiceActionNotSupported:
        case GlusterVolumeRebalanceStopFailed:
        case GlusterVolumeStatusAllFailedException:
        case GlusterVolumeRebalanceStatusFailedException:
        case GlusterVolumeRemoveBrickStatusFailed:
            // Capture error from gluster command and record failure
            getVDSReturnValue().setVdsError(new VDSError(returnStatus, getReturnStatus().mMessage));
            getVDSReturnValue().setSucceeded(false);
            break;
        default:
            super.proceedProxyReturnValue();
            break;
    }
}
#end_block

#method_before
public static boolean isTaskOfType(GlusterVolumeEntity volume, GlusterTaskType type) {
    if (volume.getAsyncTask() != null && volume.getAsyncTask().getType() == type) {
        return true;
    }
    return false;
}
#method_after
public static boolean isTaskOfType(GlusterTaskSupport supportObj, GlusterTaskType type) {
    if (supportObj.getAsyncTask() != null && supportObj.getAsyncTask().getType() == type) {
        return true;
    }
    return false;
}
#end_block

#method_before
public static boolean isTaskStatus(GlusterVolumeEntity volume, JobExecutionStatus status) {
    if (volume.getAsyncTask() != null && volume.getAsyncTask().getStatus() == status) {
        return true;
    }
    return false;
}
#method_after
public static boolean isTaskStatus(GlusterTaskSupport supportObj, JobExecutionStatus status) {
    if (supportObj.getAsyncTask() != null && supportObj.getAsyncTask().getStatus() == status) {
        return true;
    }
    return false;
}
#end_block

#method_before
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
}
#method_after
@SuppressWarnings("deprecation")
private static void initStorageSeverities() {
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ADD_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_UPDATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAIN_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ATTACH_STORAGE_DOMAINS_TO_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DETACH_STORAGE_DOMAIN_FROM_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_DEACTIVATE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_EXTENDED_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_CONNECT_HOSTS_TO_LUN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_REMOVE_VG, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_REMOVE_VG_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_FAILED_CHANGE_STORAGE_POOL_STATUS, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_NO_HOST_FOR_SPM, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FORCE_REMOVE_STORAGE_DOMAIN_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_DONE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED_NO_MASTER, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECONSTRUCT_MASTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_MOVE_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_UPDATE_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FAILED_UPDATE_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_EXTEND_DISK_SIZE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_HOTPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_HOTUNPLUG_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_HOTUNPLUG_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_COPY_TEMPLATE_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_COPIED_TEMPLATE_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FAILED_MOVED_VM_DISK, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_MOVED_VM_DISK_FINISHED_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.USER_FINISHED_REMOVE_DISK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_FINISHED_FAILED_REMOVE_DISK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.IRS_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.IRS_DISK_SPACE_LOW, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_SUCCEEDED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_DEACTIVATED_STORAGE_DOMAIN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_FROM_NON_OPERATIONAL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.RECOVERY_STORAGE_POOL, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.CONNECT_STORAGE_SERVERS_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.CONNECT_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_ERROR, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REFRESH_REPOSITORY_IMAGE_LIST_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_ACTIVATE_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_RESET_IRS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATED_STORAGE_DOMAIN_ASYNC, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_ACTIVATE_STORAGE_DOMAIN_FAILED_ASYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.STORAGE_DOMAIN_TASKS_ERROR, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPDATE_OVF_FOR_STORAGE_POOL_FAILED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.UPGRADE_STORAGE_POOL_ENCOUNTERED_PROBLEMS, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_START, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_FAILURE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.DISK_ALIGNMENT_SCAN_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.USER_IMPORT_IMAGE_FINISHED_FAILURE, AuditLogSeverity.ERROR);
}
#end_block

#method_before
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
}
#method_after
private static void initNetworkSeverities() {
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_FROM_VDS_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_BOND_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_MATCH_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_VDS_NETWORK_NOT_MATCH_CLUSTER, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_VM_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_TEMPLATE_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ADD_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_REMOVE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ATTACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DETACH_NETWORK_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDTAE_NETWORK_ON_CLUSTER_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_DISPLAY_TO_VDS_GROUP_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_UPDATE_NETWORK_TO_VDS_INTERFACE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_HOST_USING_WRONG_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_HOST_MISSING_CLUSER_VLAN, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_COMMINT_NETWORK_CHANGES_FAILED, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.MAC_POOL_EMPTY, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESS_IS_IN_USE_UNPLUG, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.MAC_ADDRESSES_POOL_NOT_INITIALIZED, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.VDS_NETWORKS_OUT_OF_SYNC, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_ACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_SUCCESS, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.NETWORK_DEACTIVATE_VM_INTERFACE_FAILURE, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.INVALID_INTERFACE_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.VLAN_ID_MISMATCH_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.SETUP_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK_CONFIGURATION, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.PERSIST_NETWORK_FAILED_FOR_MANAGEMENT_NETWORK, AuditLogSeverity.WARNING);
    severities.put(AuditLogType.ADD_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.ADD_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.UPDATE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE, AuditLogSeverity.NORMAL);
    severities.put(AuditLogType.REMOVE_VNIC_PROFILE_FAILED, AuditLogSeverity.ERROR);
    severities.put(AuditLogType.NETWORK_WITHOUT_INTERFACES, AuditLogSeverity.WARNING);
}
#end_block

#method_before
private String getConsoleUserName(VdcUser user) {
    String domain = user.getDomainControler();
    String name = user.getUserName();
    if (StringUtils.isEmpty(name) || name.contains("@") || StringUtils.isEmpty(domain)) {
        return name;
    } else {
        return name + "@" + domain;
    }
}
#method_after
String getConsoleUserName() {
    VdcUser user = getCurrentUser();
    String domain = user.getDomainControler();
    String name = user.getUserName();
    if (StringUtils.isEmpty(name) || name.contains("@") || StringUtils.isEmpty(domain)) {
        return name;
    } else {
        return name + "@" + domain;
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    // Check that the virtual machine is in state that allows connections
    // to the console:
    final VMStatus status = vm.getStatus();
    if (status != VMStatus.Up && status != VMStatus.Paused && status != VMStatus.PoweringUp && status != VMStatus.PoweringDown && status != VMStatus.RebootInProgress) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL);
        return false;
    }
    // subjects:
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // Check that the virtual machine is in state that allows connections
    // to the console:
    final VMStatus status = vm.getStatus();
    if (status != VMStatus.Up && status != VMStatus.Paused && status != VMStatus.PoweringUp && status != VMStatus.PoweringDown && status != VMStatus.RebootInProgress) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_STATUS_ILLEGAL, LocalizedVmStatus.from(vm.getStatus()));
    }
    // subjects:
    return true;
}
#end_block

#method_before
@Before
public void setUp() {
    adUser = new LdapUser("UserName", Guid.newGuid(), "DomainController");
}
#method_after
@Before
public void setUp() {
    adUser = new LdapUser();
    adUser.setUserName("UserName");
    adUser.setUserId(Guid.newGuid());
    adUser.setDomainControler("DomainController");
}
#end_block

#method_before
protected String getSearchPattern() {
    String user_defined_pattern = QueryHelper.getConstraint(getUriInfo(), "", modelType);
    return user_defined_pattern.equals("Users : ") ? user_defined_pattern + USERS_SEARCH_PATTERN : user_defined_pattern + AND_SEARCH_PATTERN + USERS_SEARCH_PATTERN;
}
#method_after
private String getSearchPattern() {
    String user_defined_pattern = QueryHelper.getConstraint(getUriInfo(), "", modelType);
    return user_defined_pattern.equals("Users : ") ? user_defined_pattern + USERS_SEARCH_PATTERN : user_defined_pattern + AND_SEARCH_PATTERN + USERS_SEARCH_PATTERN;
}
#end_block

#method_before
protected String getDomain(User user) {
    if (user.isSetDomain() && user.getDomain().isSetName()) {
        return user.getDomain().getName();
    } else if (user.isSetDomain() && user.getDomain().isSetId()) {
        List<String> domains = getBackendCollection(String.class, VdcQueryType.GetDomainList, new VdcQueryParametersBase());
        for (String domain : domains) {
            Guid domainId = new Guid(domain.getBytes(), true);
            if (domainId.toString().equals(user.getDomain().getId())) {
                return domain;
            }
        }
        throw new WebFaultException(null, "Domain: '" + user.getDomain().getId().toString() + "' does not exist.", Response.Status.BAD_REQUEST);
    } else if (user.isSetUserName() && user.getUserName().contains("@")) {
        return user.getUserName().substring(user.getUserName().indexOf("@") + 1);
    }
    return null;
}
#method_after
protected String getDomain(User user) {
    if (user.isSetDomain() && user.getDomain().isSetName()) {
        return user.getDomain().getName();
    } else if (user.isSetDomain() && user.getDomain().isSetId()) {
        List<String> domains = getBackendCollection(String.class, VdcQueryType.GetDomainList, new GetDomainListParameters());
        for (String domain : domains) {
            Guid domainId = new Guid(domain.getBytes(), true);
            if (domainId.toString().equals(user.getDomain().getId())) {
                return domain;
            }
        }
        throw new WebFaultException(null, "Domain: '" + user.getDomain().getId().toString() + "' does not exist.", Response.Status.BAD_REQUEST);
    } else if (user.isSetUserName() && user.getUserName().contains("@")) {
        return user.getUserName().substring(user.getUserName().indexOf("@") + 1);
    }
    return null;
}
#end_block

#method_before
protected List<DbUser> getDbUsersForDomain() {
    return asCollection(DbUser.class, getEntity(ArrayList.class, SearchType.DBUser, getSearchPattern("*", getCurrentDomain())));
}
#method_after
protected List<DbUser> getDbUsersForDomain() {
    return asCollection(DbUser.class, getEntity(ArrayList.class, SearchType.DBUser, getDirectoryUserSearchPattern("*", getCurrentDomain())));
}
#end_block

#method_before
protected Users mapDbUserCollection(List<DbUser> entities) {
    Users collection = new Users();
    for (DbUser entity : entities) {
        collection.getUsers().add(addLinks(modifyDomain(map(entity)), BaseResource.class));
    }
    return collection;
}
#method_after
protected Users mapDbUserCollection(List<DbUser> entities) {
    Users collection = new Users();
    for (DbUser entity : entities) {
        User user = map(entity);
        user = populate(user, entity);
        user = addLinks(user, BaseResource.class);
        collection.getUsers().add(user);
    }
    return collection;
}
#end_block

#method_before
@Override
public Response add(User user) {
    validateParameters(user, "userName");
    if (!isNameContainsDomain(user)) {
        // user-name may contain the domain (e.g: oliel@xxx.yyy)
        validateParameters(user, "domain.id|name");
    }
    String domain = getDomain(user);
    LdapUser adUser = getEntity(LdapUser.class, SearchType.AdUser, getSearchPattern(user.getUserName(), domain));
    if (adUser == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such user: " + user.getUserName() + " in domain " + domain).build();
    }
    AddUserParameters newUser = new AddUserParameters();
    newUser.setAdUser(adUser);
    return performCreate(VdcActionType.AddUser, newUser, new UserIdResolver(adUser.getUserId()), BaseResource.class);
}
#method_after
@Override
public Response add(User user) {
    validateParameters(user, "userName");
    if (!isNameContainsDomain(user)) {
        // user-name may contain the domain (e.g: oliel@xxx.yyy)
        validateParameters(user, "domain.id|name");
    }
    String domain = getDomain(user);
    LdapUser adUser = getEntity(LdapUser.class, SearchType.AdUser, getDirectoryUserSearchPattern(user.getUserName(), domain));
    if (adUser == null) {
        return Response.status(Status.BAD_REQUEST).entity("No such user: " + user.getUserName() + " in domain " + domain).build();
    }
    AddUserParameters newUser = new AddUserParameters();
    newUser.setAdUser(adUser);
    return performCreate(VdcActionType.AddUser, newUser, new UserIdResolver(adUser.getUserId()), BaseResource.class);
}
#end_block

#method_before
private Users mapUsers(List<LdapUser> entities) {
    Users collection = new Users();
    for (LdapUser entity : entities) {
        User user = map(entity);
        user = addLinks(user, true);
        user = modifyDomain(user);
        collection.getUsers().add(user);
    }
    return collection;
}
#method_after
private Users mapUsers(List<LdapUser> entities) {
    Users collection = new Users();
    for (LdapUser entity : entities) {
        User user = map(entity);
        user = populate(user, entity);
        user = addLinks(user, true);
        collection.getUsers().add(user);
    }
    return collection;
}
#end_block

#method_before
@Override
public User get() {
    DirectoryIdQueryParameters queryParameters = new DirectoryIdQueryParameters(parent.getDirectory().getName(), guid);
    User user = performGet(VdcQueryType.GetDirectoryUserById, queryParameters, BaseResource.class);
    user = modifyDomain(user);
    return user;
}
#method_after
@Override
public User get() {
    DirectoryIdQueryParameters queryParameters = new DirectoryIdQueryParameters(parent.getDirectory().getName(), guid);
    return performGet(VdcQueryType.GetDirectoryUserById, queryParameters, BaseResource.class);
}
#end_block

#method_before
protected void doTestBadRemove(boolean canDo, boolean success, String detail) throws Exception {
    setUpGetEntityExpectations();
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveUser, AdElementParametersBase.class, new String[] { "AdElementId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.remove(GUIDS[0].toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#method_after
private void doTestBadRemove(boolean canDo, boolean success, String detail) throws Exception {
    setUpGetEntityExpectations();
    setUriInfo(setUpActionExpectations(VdcActionType.RemoveUser, AdElementParametersBase.class, new String[] { "AdElementId" }, new Object[] { GUIDS[0] }, canDo, success));
    try {
        collection.remove(GUIDS[0].toString());
        fail("expected WebApplicationException");
    } catch (WebApplicationException wae) {
        verifyFault(wae, detail);
    }
}
#end_block

#method_before
@Test
public void testAddUser_4() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, VdcQueryParametersBase.class, new String[] {}, new Object[] {}, setUpDomains());
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ": allnames=" + NAMES[0]);
    User model = new User();
    model.setUserName(NAMES[0]);
    Domain domain = new Domain();
    domain.setId(new Guid(DOMAIN.getBytes(), true).toString());
    model.setDomain(domain);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#method_after
@Test
public void testAddUser_4() throws Exception {
    setUpEntityQueryExpectations(VdcQueryType.GetDomainList, GetDomainListParameters.class, new String[] {}, new Object[] {}, setUpDomains());
    setUpAddUserExpectations("ADUSER@" + DOMAIN + ": allnames=" + NAMES[0]);
    User model = new User();
    model.setUserName(NAMES[0]);
    Domain domain = new Domain();
    domain.setId(new Guid(DOMAIN.getBytes(), true).toString());
    model.setDomain(domain);
    Response response = collection.add(model);
    verifyAddUser(response);
}
#end_block

#method_before
private List<String> setUpDomains() {
    List<String> domains = new LinkedList<String>();
    domains.add("some.domain");
    domains.add(DOMAIN);
    return domains;
}
#method_after
private List<String> setUpDomains() {
    List<String> domains = new LinkedList<>();
    domains.add("some.domain");
    domains.add(DOMAIN);
    return domains;
}
#end_block

#method_before
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setName(entity.getDomain());
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = DbUser.class, to = User.class)
public static User map(DbUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getFirstName());
    model.setUserName(entity.getLoginName());
    model.setId(entity.getId().toString());
    model.setLastName(entity.getLastName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroupNames() != null && entity.getGroupNames().trim().length() > 0) {
        model.setGroups(new Groups());
        for (String name : entity.getGroupNames().split(",")) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomain())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomain().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
@Mapping(from = LdapUser.class, to = User.class)
public static User map(LdapUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getName());
    model.setUserName(entity.getUserName());
    model.setId(entity.getUserId().toString());
    model.setLastName(entity.getSurName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (String name : entity.getGroups().keySet()) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomainControler())) {
        Domain dom = new Domain();
        dom.setName(entity.getDomainControler());
        dom.setId(new Guid(entity.getDomainControler().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#method_after
@Mapping(from = LdapUser.class, to = User.class)
public static User map(LdapUser entity, User template) {
    User model = template != null ? template : new User();
    model.setName(entity.getName());
    model.setUserName(entity.getUserName());
    model.setId(entity.getUserId().toString());
    model.setLastName(entity.getSurName());
    model.setEmail(entity.getEmail());
    model.setDepartment(entity.getDepartment());
    if (entity.getGroups() != null) {
        model.setGroups(new Groups());
        for (String name : entity.getGroups().keySet()) {
            Group group = new Group();
            group.setName(name);
            model.getGroups().getGroups().add(group);
        }
    }
    if (!StringUtils.isEmpty(entity.getDomainControler())) {
        Domain dom = new Domain();
        dom.setId(new Guid(entity.getDomainControler().getBytes(), true).toString());
        model.setDomain(dom);
    }
    return model;
}
#end_block

#method_before
protected void performLogin(T loginModel) {
    VdcUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = (String) loginModel.getPassword().getEntity();
    // UiCommon login preparation
    Frontend.setLoggedInUser(loggedUser);
    Frontend.setLoginPassword(loginPassword);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#method_after
protected void performLogin(T loginModel) {
    VdcUser loggedUser = loginModel.getLoggedUser();
    String loginPassword = (String) loginModel.getPassword().getEntity();
    // UiCommon login preparation
    Frontend.initLoggedInUser(loggedUser, loginPassword);
    beforeUiCommonInitEvent(loginModel);
    UiCommonInitEvent.fire(eventBus);
    // UI login actions
    user.onUserLogin(loggedUser);
    // Post-login actions
    loginModel.getPassword().setEntity(null);
}
#end_block

#method_before
private static void handleNotLoggedInEvent(String errorMessage) {
    if (errorMessage != null && errorMessage.equals("USER_IS_NOT_LOGGED_IN")) {
        // $NON-NLS-1$
        frontendNotLoggedInEvent.raise(Frontend.class, EventArgs.Empty);
    }
}
#method_after
private static void handleNotLoggedInEvent(String errorMessage) {
    if ("USER_IS_NOT_LOGGED_IN".equals(errorMessage)) {
        // $NON-NLS-1$
        frontendNotLoggedInEvent.raise(Frontend.class, EventArgs.Empty);
    }
}
#end_block

#method_before
static void RunMultipleActions(final List<VdcActionType> actionTypes, final List<VdcActionParametersBase> parameters, final List<IFrontendActionAsyncCallback> callbacks, final IFrontendActionAsyncCallback failureCallback, final Object state, final GenericApiGWTServiceAsync service) {
    if (actionTypes.isEmpty() || parameters.isEmpty() || callbacks.isEmpty()) {
        return;
    }
    runActionImpl(actionTypes.get(0), parameters.get(0), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(final FrontendActionAsyncResult result) {
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success || failureCallback == null) {
                IFrontendActionAsyncCallback callback = callbacks.get(0);
                if (callback != null) {
                    callback.executed(result);
                }
                actionTypes.remove(0);
                parameters.remove(0);
                callbacks.remove(0);
                RunMultipleActions(actionTypes, parameters, callbacks, failureCallback, state, service);
            } else {
                failureCallback.executed(result);
            }
        }
    }, state, true, service);
}
#method_after
public static void RunMultipleActions(VdcActionType actionType, List<VdcActionParametersBase> parameters, List<IFrontendActionAsyncCallback> callbacks) {
    RunMultipleActions(actionType, parameters, callbacks, null);
}
#end_block

#method_before
public static void RunMultipleActions(VdcActionType actionType, List<VdcActionParametersBase> parameters, IFrontendActionAsyncCallback successCallback, Object state) {
    if (parameters == null || parameters.isEmpty()) {
        return;
    }
    int n = parameters.size();
    VdcActionType[] actionTypes = new VdcActionType[n];
    IFrontendActionAsyncCallback[] callbacks = new IFrontendActionAsyncCallback[n];
    Arrays.fill(actionTypes, actionType);
    callbacks[n - 1] = successCallback;
    RunMultipleActions(new LinkedList<VdcActionType>(Arrays.asList(actionTypes)), parameters, new LinkedList<IFrontendActionAsyncCallback>(Arrays.asList(callbacks)), null, state);
}
#method_after
public static void RunMultipleActions(VdcActionType actionType, List<VdcActionParametersBase> parameters, IFrontendActionAsyncCallback successCallback, Object state) {
    if (parameters == null || parameters.isEmpty()) {
        return;
    }
    int n = parameters.size();
    IFrontendActionAsyncCallback[] callbacks = new IFrontendActionAsyncCallback[n];
    callbacks[n - 1] = successCallback;
    RunMultipleActions(actionType, parameters, new LinkedList<IFrontendActionAsyncCallback>(Arrays.asList(callbacks)), state);
}
#end_block

#method_before
static void LoginAsync(final String userName, final String password, final String domain, final AsyncQuery callback, final GenericApiGWTServiceAsync service) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async Login.");
    service.Login(userName, password, domain, new AsyncCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from Login.");
            setLoggedInUser(null);
            callback.getDel().onSuccess(callback.getModel(), result);
            setLoginPassword(null);
            if (getLoginHandler() != null && result.getSucceeded()) {
                getLoginHandler().onLoginSuccess(userName, password, domain);
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            if (callback.isHandleFailure()) {
                setLoggedInUser(null);
                callback.getDel().onSuccess(callback.getModel(), null);
                setLoginPassword(null);
            }
        }
    });
}
#method_after
static void LoginAsync(final String userName, final String password, final String domain, final AsyncQuery callback, final GenericApiGWTServiceAsync service) {
    // $NON-NLS-1$
    logger.finer("Frontend: Invoking async Login.");
    service.Login(userName, password, domain, new AsyncCallback<VdcReturnValueBase>() {

        @Override
        public void onSuccess(final VdcReturnValueBase result) {
            // $NON-NLS-1$
            logger.finer("Succesful returned result from Login.");
            clearLoggedInUser();
            result.setCanDoActionMessages((ArrayList<String>) translateError(result));
            callback.getDel().onSuccess(callback.getModel(), result);
            if (getLoginHandler() != null && result.getSucceeded()) {
                getLoginHandler().onLoginSuccess(userName, password, domain);
            }
        }

        @Override
        public void onFailure(final Throwable caught) {
            if (ignoreFailure(caught)) {
                return;
            }
            // $NON-NLS-1$
            logger.log(Level.SEVERE, "Failed to execute RunQuery: " + caught, caught);
            getEventsHandler().runQueryFailed(null);
            failureEventHandler(caught);
            if (callback.isHandleFailure()) {
                clearLoggedInUser();
                callback.getDel().onSuccess(callback.getModel(), null);
            }
        }
    });
}
#end_block

#method_before
@Override
public void login() {
    // Completely override the base class functionality.
    if (!validate()) {
        return;
    }
    startProgress(null);
    getUserName().setIsChangable(false);
    getPassword().setIsChangable(false);
    getDomain().setIsChangable(false);
    getLoginCommand().setIsExecutionAllowed(false);
    getIsAutoConnect().setIsChangable(false);
    Frontend.RunAction(VdcActionType.LoginUser, new LoginUserParameters((String) getUserName().getEntity(), (String) getPassword().getEntity(), // $NON-NLS-1$
    (String) getDomain().getSelectedItem(), // $NON-NLS-1$
    "", // $NON-NLS-1$
    "", // $NON-NLS-1$
    ""), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            UserPortalLoginModel model = (UserPortalLoginModel) result.getState();
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success) {
                model.setLoggedUser((VdcUser) returnValue.getActionReturnValue());
                model.raiseLoggedInEvent();
            } else {
                // $NON-NLS-1$
                model.getPassword().setEntity("");
                if (returnValue != null) {
                    model.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                }
                model.getUserName().setIsChangable(true);
                model.getPassword().setIsChangable(true);
                model.getDomain().setIsChangable(true);
                model.getLoginCommand().setIsExecutionAllowed(true);
                getIsAutoConnect().setIsChangable(true);
                model.getLoginFailedEvent().raise(this, EventArgs.Empty);
            }
            stopProgress();
        }
    }, this);
}
#method_after
@Override
public void login() {
    // Completely override the base class functionality.
    if (!validate()) {
        getLoginFailedEvent().raise(this, EventArgs.Empty);
        return;
    }
    startProgress(null);
    getUserName().setIsChangable(false);
    getPassword().setIsChangable(false);
    getDomain().setIsChangable(false);
    getLoginCommand().setIsExecutionAllowed(false);
    getIsAutoConnect().setIsChangable(false);
    Frontend.RunAction(VdcActionType.LoginUser, new LoginUserParameters((String) getUserName().getEntity(), (String) getPassword().getEntity(), // $NON-NLS-1$
    (String) getDomain().getSelectedItem(), // $NON-NLS-1$
    "", // $NON-NLS-1$
    "", // $NON-NLS-1$
    ""), new IFrontendActionAsyncCallback() {

        @Override
        public void executed(FrontendActionAsyncResult result) {
            UserPortalLoginModel model = (UserPortalLoginModel) result.getState();
            VdcReturnValueBase returnValue = result.getReturnValue();
            boolean success = returnValue != null && returnValue.getSucceeded();
            if (success) {
                model.setLoggedUser((VdcUser) returnValue.getActionReturnValue());
                model.raiseLoggedInEvent();
            } else {
                // $NON-NLS-1$
                model.getPassword().setEntity("");
                if (returnValue != null) {
                    model.setMessage(Linq.firstOrDefault(returnValue.getCanDoActionMessages()));
                }
                model.getUserName().setIsChangable(true);
                model.getPassword().setIsChangable(true);
                model.getDomain().setIsChangable(true);
                model.getLoginCommand().setIsExecutionAllowed(true);
                getIsAutoConnect().setIsChangable(true);
                model.getLoginFailedEvent().raise(this, EventArgs.Empty);
            }
            stopProgress();
        }
    }, this);
}
#end_block

#method_before
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(Object targetObject) {
    UserPortalLoginModel loginModel = (UserPortalLoginModel) targetObject;
    AsyncDataProvider.getPermissionsByAdElementId(new AsyncQuery(targetObject, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<permissions> permissions = (ArrayList<permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (permissions permission : permissions) {
                // ALL Everyone/NetworkUser persmissions
                if (isEveyoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission) || isEveyoneNetworUserPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveyoneNetworUserPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.networkUser.asGuid());
        }

        private boolean isEveyoneUserPortalBasedVmPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getUserId());
}
#method_after
// Get logged user's permissions and create a list of roles associated with the user (and proceed to Step3).
public void getUserRoles(Object targetObject) {
    UserPortalLoginModel loginModel = (UserPortalLoginModel) targetObject;
    AsyncDataProvider.getPermissionsByAdElementId(new AsyncQuery(targetObject, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ArrayList<permissions> permissions = (ArrayList<permissions>) returnValue;
            ArrayList<Guid> roleIdList = new ArrayList<Guid>();
            for (permissions permission : permissions) {
                // ALL Everyone/NetworkUser persmissions
                if (isEveryoneUserPortalBasedVmPermission(permission) || isEveryoneQuotaConsumerPermission(permission) || isEveryoneVnicProfileUserPermission(permission)) {
                    continue;
                }
                if (!roleIdList.contains(permission.getrole_id())) {
                    roleIdList.add(permission.getrole_id());
                }
            }
            UserPortalLoginModel loginModel1 = (UserPortalLoginModel) target;
            loginModel1.setLoggedUserActionGroupList(new ArrayList<ActionGroup>());
            if (roleIdList.size() > 0) {
                loginModel1.setRolesCounter(roleIdList.size());
                loginModel1.updateUserActionGroups(loginModel1, roleIdList);
            } else {
                checkIsENGINEUser(loginModel1);
            }
        }

        private boolean isEveryoneVnicProfileUserPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.vnicProfileUser.asGuid());
        }

        private boolean isEveryoneUserPortalBasedVmPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.userTemplateBasedVM.asGuid());
        }

        private boolean isEveryoneQuotaConsumerPermission(permissions permission) {
            return permission.getad_element_id().equals(ApplicationGuids.everyone.asGuid()) && permission.getrole_id().equals(ApplicationGuids.quotaConsumer.asGuid());
        }
    }), loginModel.getLoggedUser().getUserId());
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    // Everything is OK:
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Check that the virtual machine exists:
    final VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // Everything is OK:
    return true;
}
#end_block

#method_before
@Override
public Principal validate(String sessionId) {
    Principal principal = null;
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setSessionId(sessionId);
    VdcQueryReturnValue queryReturnValue = backend.RunPublicQuery(VdcQueryType.ValidateSession, params);
    if (queryReturnValue != null) {
        VdcUser vdcUser = (VdcUser) queryReturnValue.getReturnValue();
        if (vdcUser != null) {
            principal = new Principal(vdcUser.getUserName(), null, vdcUser.getDomainControler());
            sessionHelper.setSessionId(sessionId);
            current.set(vdcUser);
        }
    }
    if (principal != null) {
        validateSessionSucceeded(queryReturnValue);
    } else {
        validateSessionFailed(queryReturnValue);
    }
    return principal;
}
#method_after
@Override
public Principal validate(String sessionId) {
    Principal principal = null;
    VdcQueryParametersBase params = new VdcQueryParametersBase();
    params.setSessionId(sessionId);
    VdcQueryReturnValue queryReturnValue = backend.RunPublicQuery(VdcQueryType.ValidateSession, params);
    if (queryReturnValue != null) {
        VdcUser vdcUser = queryReturnValue.getReturnValue();
        if (vdcUser != null) {
            principal = new Principal(vdcUser.getUserName(), null, vdcUser.getDomainControler());
            sessionHelper.setSessionId(sessionId);
            current.set(vdcUser);
        }
    }
    if (principal != null) {
        validateSessionSucceeded(queryReturnValue);
    } else {
        validateSessionFailed(queryReturnValue);
    }
    return principal;
}
#end_block

#method_before
@Override
public void onLogout() {
    AsyncQuery query = new AsyncQuery();
    query.setHandleFailure(true);
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            // IE optimization: reload entire application on user logout
            if (clientAgentType.isIE8OrBelow()) {
                Window.Location.reload();
            }
            Frontend.setLoggedInUser(null);
            Frontend.setLoginPassword(null);
            getLoginModel().resetAfterLogout();
            AsyncDataProvider.clearCache();
            connectAutomaticallyManager.resetAlreadyOpened();
            ApplicationInit.super.onLogout();
        }
    };
    Frontend.LogoffAsync(Frontend.getLoggedInUser(), query);
}
#method_after
@Override
public void onLogout() {
    AsyncQuery query = new AsyncQuery();
    query.setHandleFailure(true);
    query.setModel(this);
    query.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object ReturnValue) {
            // IE optimization: reload entire application on user logout
            if (clientAgentType.isIE8OrBelow()) {
                Window.Location.reload();
            }
            Frontend.clearLoggedInUser();
            getLoginModel().resetAfterLogout();
            AsyncDataProvider.clearCache();
            connectAutomaticallyManager.resetAlreadyOpened();
            ApplicationInit.super.onLogout();
        }
    };
    Frontend.LogoffAsync(Frontend.getLoggedInUser(), query);
}
#end_block

#method_before
private void addEntry(T value) {
    final HorizontalPanel entry = new HorizontalPanel();
    entry.addStyleName(style.entryStyle());
    contentPanel.add(entry);
    final V widget = createWidget(value);
    Pair<T, V> item = new Pair<T, V>(value, widget);
    items.add(item);
    entry.add(widget);
    PushButton button = createButton(item);
    entry.add(button);
    final boolean ghost = isGhost(value);
    toggleGhost(value, widget, ghost);
    widget.addValueChangeHandler(new ValueChangeHandler<T>() {

        private boolean wasGhost = ghost;

        @Override
        public void onValueChange(ValueChangeEvent<T> event) {
            T value = event.getValue();
            boolean becomingGhost = isGhost(value);
            if (becomingGhost != wasGhost) {
                ((PushButton) entry.getWidget(entry.getWidgetCount() - 1)).setEnabled(!becomingGhost);
                toggleGhost(value, widget, becomingGhost);
                wasGhost = becomingGhost;
            }
        }
    });
    onAdd(value, widget);
}
#method_after
private void addEntry(T value) {
    final V widget = createWidget(value);
    Pair<T, V> item = new Pair<T, V>(value, widget);
    items.add(item);
    PushButton button = createButton(item);
    final boolean ghost = isGhost(value);
    toggleGhost(value, widget, ghost);
    widget.addValueChangeHandler(new ValueChangeHandler<T>() {

        private boolean wasGhost = ghost;

        @Override
        public void onValueChange(ValueChangeEvent<T> event) {
            T value = event.getValue();
            boolean becomingGhost = isGhost(value);
            if (becomingGhost != wasGhost) {
                ((AddRemoveRowPanel) widget.getParent()).setButtonEnabled(!becomingGhost);
                toggleGhost(value, widget, becomingGhost);
                wasGhost = becomingGhost;
            }
        }
    });
    AddRemoveRowPanel entry = new AddRemoveRowPanel(widget, button);
    contentPanel.add(entry);
    onAdd(value, widget);
}
#end_block

#method_before
private PushButton createButton(final Pair<T, V> item) {
    boolean ghostItem = isGhost(item.getFirst());
    final PushButton button = new PushButton(new Image(ghostItem ? resources.increaseIcon() : resources.decreaseIcon()));
    button.addStyleName(style.buttonStyle());
    button.setEnabled(!ghostItem);
    button.addClickHandler(ghostItem ? new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            swapAddButton(item, button);
            addGhostEntry();
        }
    } : new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            removeEntry(item);
        }
    });
    return button;
}
#method_after
private PushButton createButton(final Pair<T, V> item) {
    boolean ghostItem = isGhost(item.getFirst());
    final PushButton button = new PushButton(new Image(ghostItem ? resources.increaseIcon() : resources.decreaseIcon()));
    button.addStyleName(style.buttonStyle());
    button.setEnabled(!ghostItem);
    button.addClickHandler(ghostItem ? new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            ((AddRemoveRowPanel) item.getSecond().getParent()).swapButton(createButton(item));
            addGhostEntry();
        }
    } : new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            removeEntry(item);
        }
    });
    return button;
}
#end_block

#method_before
private void setAllListModelsUnavailable() {
    for (ListModel m : listModelCollection) {
        m.setIsAvailable(false);
    }
}
#method_after
private void setAllListModelsUnavailable() {
    for (ListModel m : getItems()) {
        m.setIsAvailable(false);
    }
}
#end_block

#method_before
private void initItems() {
    listModelCollection = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    listModelCollection.add(dataCenterList);
    clusterList = new ClusterListModel();
    listModelCollection.add(clusterList);
    hostList = new HostListModel();
    listModelCollection.add(hostList);
    storageList = new StorageListModel();
    listModelCollection.add(storageList);
    vmList = new VmListModel();
    listModelCollection.add(vmList);
    poolList = new PoolListModel();
    listModelCollection.add(poolList);
    templateList = new TemplateListModel();
    listModelCollection.add(templateList);
    eventList = new EventListModel();
    listModelCollection.add(eventList);
    quotaList = new QuotaListModel();
    listModelCollection.add(quotaList);
    volumeList = new VolumeListModel();
    listModelCollection.add(volumeList);
    diskList = new DiskListModel();
    listModelCollection.add(diskList);
    userList = new UserListModel();
    listModelCollection.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl());
    listModelCollection.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    listModelCollection.add(networkList);
    providerList = new ProviderListModel();
    listModelCollection.add(providerList);
    profileList = new VnicProfileListModel();
    listModelCollection.add(profileList);
    setItems(listModelCollection);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#method_after
private void initItems() {
    ObservableCollection<SearchableListModel> list = new ObservableCollection<SearchableListModel>();
    dataCenterList = new DataCenterListModel();
    list.add(dataCenterList);
    clusterList = new ClusterListModel();
    list.add(clusterList);
    hostList = new HostListModel();
    list.add(hostList);
    storageList = new StorageListModel();
    list.add(storageList);
    vmList = new VmListModel();
    list.add(vmList);
    poolList = new PoolListModel();
    list.add(poolList);
    templateList = new TemplateListModel();
    list.add(templateList);
    eventList = new EventListModel();
    list.add(eventList);
    quotaList = new QuotaListModel();
    list.add(quotaList);
    volumeList = new VolumeListModel();
    list.add(volumeList);
    diskList = new DiskListModel();
    list.add(diskList);
    userList = new UserListModel();
    list.add(userList);
    reportsList = new ReportsListModel(ReportInit.getInstance().getReportBaseUrl());
    list.add(reportsList);
    reportsList.setIsAvailable(false);
    networkList = new NetworkListModel();
    list.add(networkList);
    providerList = new ProviderListModel();
    list.add(providerList);
    profileList = new VnicProfileListModel();
    list.add(profileList);
    setItems(list);
    roleListModel = new RoleListModel();
    systemPermissionListModel = new SystemPermissionListModel();
    clusterPolicyListModel = new ClusterPolicyListModel();
    // Activate the default list model.
    setSelectedItem(getDefaultItem());
}
#end_block

#method_before
private void init() {
    menu = menuFor(item);
    getElement().addClassName(style.itemPanel());
    setWidget(getContents());
    addDomHandler(new ContextMenuHandler() {

        @Override
        public void onContextMenu(ContextMenuEvent event) {
            NetworkItemPanel sourcePanel = (NetworkItemPanel) event.getSource();
            NativeEvent nativeEvent = event.getNativeEvent();
            showContextMenu(sourcePanel, nativeEvent.getClientX(), nativeEvent.getClientY());
            event.stopPropagation();
            event.preventDefault();
        }
    }, ContextMenuEvent.getType());
    // drag start
    addBitlessDomHandler(new DragStartHandler() {

        @Override
        public void onDragStart(DragStartEvent event) {
            if (!draggable) {
                return;
            }
            NetworkItemPanel sourcePanel = (NetworkItemPanel) event.getSource();
            // Required: set data for the event.
            // $NON-NLS-1$
            lastDragData = sourcePanel.item.getType() + " " + sourcePanel.item.getName();
            // $NON-NLS-1$
            event.setData("Text", lastDragData);
            // show a ghost of the widget under cursor.
            NativeEvent nativeEvent = event.getNativeEvent();
            int x = nativeEvent.getClientX() - sourcePanel.getAbsoluteLeft();
            int y = nativeEvent.getClientY() - sourcePanel.getAbsoluteTop();
            event.getDataTransfer().setDragImage(sourcePanel.getElement(), x, y);
        }
    }, DragStartEvent.getType());
}
#method_after
private void init() {
    menu = menuFor(item);
    getElement().addClassName(style.itemPanel());
    setWidget(getContents());
    addDomHandler(new ContextMenuHandler() {

        @Override
        public void onContextMenu(ContextMenuEvent event) {
            NetworkItemPanel sourcePanel = (NetworkItemPanel) event.getSource();
            NativeEvent nativeEvent = event.getNativeEvent();
            showContextMenu(sourcePanel, nativeEvent.getClientX(), nativeEvent.getClientY());
            event.stopPropagation();
            event.preventDefault();
        }
    }, ContextMenuEvent.getType());
    // drag start
    if (draggable) {
        addBitlessDomHandler(new DragStartHandler() {

            @Override
            public void onDragStart(DragStartEvent event) {
                NetworkItemPanel sourcePanel = (NetworkItemPanel) event.getSource();
                // Required: set data for the event.
                // $NON-NLS-1$
                lastDragData = sourcePanel.item.getType() + " " + sourcePanel.item.getName();
                // $NON-NLS-1$
                event.setData("Text", lastDragData);
                // show a ghost of the widget under cursor.
                NativeEvent nativeEvent = event.getNativeEvent();
                int x = nativeEvent.getClientX() - sourcePanel.getAbsoluteLeft();
                int y = nativeEvent.getClientY() - sourcePanel.getAbsoluteTop();
                event.getDataTransfer().setDragImage(sourcePanel.getElement(), x, y);
            }
        }, DragStartEvent.getType());
    }
}
#end_block

#method_before
@Override
public boolean storageDomainRemoved(StorageDomainStatic storageDomain) {
    List<StorageServerConnections> list = DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage());
    for (StorageServerConnections connection : FilterConnectionsUsedByOthers(list, storageDomain.getStorage())) {
        DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.getid());
    }
    removeStorageDomainLuns(storageDomain);
    return true;
}
#method_after
@Override
public boolean storageDomainRemoved(StorageDomainStatic storageDomain) {
    List<StorageServerConnections> list = DbFacade.getInstance().getStorageServerConnectionDao().getAllForVolumeGroup(storageDomain.getStorage());
    for (StorageServerConnections connection : FilterConnectionsUsedByOthers(list, storageDomain.getStorage())) {
        DbFacade.getInstance().getStorageServerConnectionDao().remove(connection.getid());
    }
    // There is no need to remove entries from lun_storage_server_connection_map,
    // as the foreign key from the luns table is defined as ON DELETE CASCADE.
    removeStorageDomainLuns(storageDomain);
    return true;
}
#end_block

#method_before
public final String extendedGuideUrl() {
    return formatString(DynamicMessageKey.EXTENDED_GUIDE_URL, LocaleInfo.getCurrentLocale().getLocaleName());
}
#method_after
public final String extendedGuideUrl() {
    return formatString(DynamicMessageKey.EXTENDED_GUIDE_URL, getCurrentLocaleAsString());
}
#end_block

#method_before
protected void bindCommonInfrastructure() {
    bindEventBus();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(RootPresenter.class).asEagerSingleton();
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
}
#method_after
protected void bindCommonInfrastructure(Class<? extends PlaceManager> placeManager) {
    bindEventBus();
    bind(TokenFormatter.class).to(ParameterTokenFormatter.class).in(Singleton.class);
    bind(RootPresenter.class).asEagerSingleton();
    bind(PlaceManager.class).to(placeManager);
    bind(placeManager).in(Singleton.class);
    bind(CurrentUser.class).in(Singleton.class);
    bind(LoggedInGatekeeper.class).in(Singleton.class);
    bind(ErrorPopupManager.class).to(ErrorPopupManagerImpl.class).in(Singleton.class);
    bind(AsyncCallFailureHandler.class).asEagerSingleton();
    bind(ClientAgentType.class).in(Singleton.class);
    bind(ClientStorage.class).in(Singleton.class);
    bind(ApplicationFocusManager.class).asEagerSingleton();
    bind(LockInteractionManager.class).asEagerSingleton();
}
#end_block

#method_before
@Override
protected void onReset() {
    // extended guide when switching away from the basic (but it is still visible), and vice versa.
    if (!placeManager.isMainSectionBasicPlaceVisible()) {
        header.setGuideUrl(basicGuideUrl);
    } else {
        header.setGuideUrl(extendedGuideUrl);
    }
}
#method_after
@Override
protected void onReset() {
    // extended guide when switching away from the basic (but it is still visible), and vice versa.
    if (placeManager.isMainSectionBasicPlaceVisible()) {
        header.setGuideUrl(basicGuideUrl);
    } else {
        header.setGuideUrl(extendedGuideUrl);
    }
}
#end_block

#method_before
public final String guideUrl() {
    return formatString(DynamicMessageKey.GUIDE_URL, LocaleInfo.getCurrentLocale().getLocaleName());
}
#method_after
public final String guideUrl() {
    return formatString(DynamicMessageKey.GUIDE_URL, getCurrentLocaleAsString());
}
#end_block

#method_before
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new I18NNameValidation() });
    getNicType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMAC().setIsValid(true);
    if (getMAC().getIsChangable()) {
        getMAC().validateEntity(new IValidation[] { new NotEmptyValidation(), new MacAddressValidation() });
    }
    return getName().getIsValid() && getNicType().getIsValid() && getMAC().getIsValid();
}
#method_after
public boolean validate() {
    getName().validateEntity(new IValidation[] { new NotEmptyValidation(), new NoSpecialCharactersWithDotValidation() });
    getNicType().validateSelectedItem(new IValidation[] { new NotEmptyValidation() });
    getMAC().setIsValid(true);
    if (getMAC().getIsChangable()) {
        getMAC().validateEntity(new IValidation[] { new NotEmptyValidation(), new MacAddressValidation() });
    }
    return getName().getIsValid() && getNicType().getIsValid() && getMAC().getIsValid();
}
#end_block

#method_before
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        editPopup = new SetupNetworksEditBondModel(entity);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                setBondOptions(entity, bondDialogModel);
                sourceListModel.setConfirmWindow(null);
            }
        };
    } else if (item instanceof LogicalNetworkModel) {
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNic().getEntity() : logicalNetwork.getAttachedToNic().getEntity();
        if (logicalNetwork.isManagement()) {
            /**
             * **************
             *  Management Network Dialog
             * ***************
             */
            editPopup = new HostManagementNetworkModel(true);
            final HostManagementNetworkModel mgmntDialogModel = (HostManagementNetworkModel) editPopup;
            mgmntDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            mgmntDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
            mgmntDialogModel.setEntity(logicalNetwork.getEntity());
            mgmntDialogModel.getAddress().setEntity(entity.getAddress());
            mgmntDialogModel.getSubnet().setEntity(entity.getSubnet());
            mgmntDialogModel.getGateway().setEntity(entity.getGateway());
            mgmntDialogModel.setNoneBootProtocolAvailable(false);
            mgmntDialogModel.getBondingOptions().setIsAvailable(false);
            mgmntDialogModel.getInterface().setIsAvailable(false);
            mgmntDialogModel.setBootProtocol(entity.getBootProtocol());
            mgmntDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
            mgmntDialogModel.getIsToSync().setEntity(HostSetupNetworksModel.this.networksToSync.contains(logicalNetwork.getName()));
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand command) {
                    if (!mgmntDialogModel.validate()) {
                        return;
                    }
                    entity.setBootProtocol(mgmntDialogModel.getBootProtocol());
                    entity.setAddress((String) mgmntDialogModel.getAddress().getEntity());
                    entity.setSubnet((String) mgmntDialogModel.getSubnet().getEntity());
                    entity.setGateway((String) mgmntDialogModel.getGateway().getEntity());
                    if ((Boolean) mgmntDialogModel.getIsToSync().getEntity()) {
                        HostSetupNetworksModel.this.networksToSync.add(logicalNetwork.getName());
                    } else {
                        HostSetupNetworksModel.this.networksToSync.remove(logicalNetwork.getName());
                    }
                    sourceListModel.setConfirmWindow(null);
                }
            };
        } else {
            /**
             * **************
             *  Network Dialog
             * ***************
             */
            editPopup = new HostInterfaceModel(true);
            final HostInterfaceModel networkDialogModel = (HostInterfaceModel) editPopup;
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
            networkDialogModel.getAddress().setEntity(entity.getAddress());
            networkDialogModel.getSubnet().setEntity(entity.getSubnet());
            networkDialogModel.getGateway().setEntity(entity.getGateway());
            networkDialogModel.startProgress(null);
            AsyncDataProvider.isMultipleGatewaysSupported(getEntity().getVdsGroupCompatibilityVersion().getValue(), new AsyncQuery(this, new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model, Object returnValue) {
                    networkDialogModel.stopProgress();
                    networkDialogModel.getGateway().setIsAvailable((Boolean) returnValue);
                }
            }));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getBondingOptions().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangable(false);
            networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getEntity());
            networkDialogModel.setBootProtocol(entity.getBootProtocol());
            networkDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
            networkDialogModel.getIsToSync().setEntity(HostSetupNetworksModel.this.networksToSync.contains(logicalNetwork.getName()));
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand command) {
                    if (!networkDialogModel.validate()) {
                        return;
                    }
                    entity.setBootProtocol(networkDialogModel.getBootProtocol());
                    entity.setAddress((String) networkDialogModel.getAddress().getEntity());
                    entity.setSubnet((String) networkDialogModel.getSubnet().getEntity());
                    entity.setGateway((String) networkDialogModel.getGateway().getEntity());
                    if ((Boolean) networkDialogModel.getIsToSync().getEntity()) {
                        HostSetupNetworksModel.this.networksToSync.add(logicalNetwork.getName());
                    } else {
                        HostSetupNetworksModel.this.networksToSync.remove(logicalNetwork.getName());
                    }
                    sourceListModel.setConfirmWindow(null);
                }
            };
        }
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OK", okTarget);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#method_after
public void onEdit(NetworkItemModel<?> item) {
    Model editPopup = null;
    BaseCommandTarget okTarget = null;
    if (item instanceof BondNetworkInterfaceModel) {
        /**
         * **************
         *  Bond Dialog
         * ***************
         */
        final VdsNetworkInterface entity = ((NetworkInterfaceModel) item).getEntity();
        editPopup = new SetupNetworksEditBondModel(entity);
        final SetupNetworksBondModel bondDialogModel = (SetupNetworksBondModel) editPopup;
        // OK Target
        okTarget = new BaseCommandTarget() {

            @Override
            public void executeCommand(UICommand command) {
                setBondOptions(entity, bondDialogModel);
                sourceListModel.setConfirmWindow(null);
            }
        };
    } else if (item instanceof LogicalNetworkModel) {
        final LogicalNetworkModel logicalNetwork = (LogicalNetworkModel) item;
        final VdsNetworkInterface entity = logicalNetwork.hasVlan() ? logicalNetwork.getVlanNic().getEntity() : logicalNetwork.getAttachedToNic().getEntity();
        if (logicalNetwork.isManagement()) {
            /**
             * **************
             *  Management Network Dialog
             * ***************
             */
            editPopup = new HostManagementNetworkModel(true);
            final HostManagementNetworkModel mgmntDialogModel = (HostManagementNetworkModel) editPopup;
            mgmntDialogModel.setTitle(ConstantsManager.getInstance().getConstants().editManagementNetworkTitle());
            mgmntDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
            mgmntDialogModel.setEntity(logicalNetwork.getEntity());
            mgmntDialogModel.getAddress().setEntity(entity.getAddress());
            mgmntDialogModel.getSubnet().setEntity(entity.getSubnet());
            mgmntDialogModel.getGateway().setEntity(entity.getGateway());
            mgmntDialogModel.setNoneBootProtocolAvailable(false);
            mgmntDialogModel.getBondingOptions().setIsAvailable(false);
            mgmntDialogModel.getInterface().setIsAvailable(false);
            mgmntDialogModel.setBootProtocol(entity.getBootProtocol());
            mgmntDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
            mgmntDialogModel.getIsToSync().setEntity(HostSetupNetworksModel.this.networksToSync.contains(logicalNetwork.getName()));
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand command) {
                    if (!mgmntDialogModel.validate()) {
                        return;
                    }
                    entity.setBootProtocol(mgmntDialogModel.getBootProtocol());
                    entity.setAddress((String) mgmntDialogModel.getAddress().getEntity());
                    entity.setSubnet((String) mgmntDialogModel.getSubnet().getEntity());
                    entity.setGateway((String) mgmntDialogModel.getGateway().getEntity());
                    if ((Boolean) mgmntDialogModel.getIsToSync().getEntity()) {
                        HostSetupNetworksModel.this.networksToSync.add(logicalNetwork.getName());
                    } else {
                        HostSetupNetworksModel.this.networksToSync.remove(logicalNetwork.getName());
                    }
                    sourceListModel.setConfirmWindow(null);
                }
            };
        } else {
            /**
             * **************
             *  Network Dialog
             * ***************
             */
            editPopup = new HostInterfaceModel(true);
            final HostInterfaceModel networkDialogModel = (HostInterfaceModel) editPopup;
            networkDialogModel.setTitle(ConstantsManager.getInstance().getMessages().editNetworkTitle(logicalNetwork.getName()));
            networkDialogModel.setOriginalNetParams(netToBeforeSyncParams.get(logicalNetwork.getName()));
            networkDialogModel.getAddress().setEntity(entity.getAddress());
            networkDialogModel.getSubnet().setEntity(entity.getSubnet());
            networkDialogModel.getGateway().setEntity(entity.getGateway());
            networkDialogModel.getGateway().setIsAvailable((Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.MultipleGatewaysSupported, getEntity().getVdsGroupCompatibilityVersion().getValue()));
            networkDialogModel.getName().setIsAvailable(false);
            networkDialogModel.getBondingOptions().setIsAvailable(false);
            networkDialogModel.getNetwork().setIsChangable(false);
            networkDialogModel.getNetwork().setSelectedItem(logicalNetwork.getEntity());
            networkDialogModel.setBootProtocol(entity.getBootProtocol());
            networkDialogModel.getIsToSync().setIsChangable(!logicalNetwork.isInSync());
            networkDialogModel.getIsToSync().setEntity(HostSetupNetworksModel.this.networksToSync.contains(logicalNetwork.getName()));
            // OK Target
            okTarget = new BaseCommandTarget() {

                @Override
                public void executeCommand(UICommand command) {
                    if (!networkDialogModel.validate()) {
                        return;
                    }
                    entity.setBootProtocol(networkDialogModel.getBootProtocol());
                    entity.setAddress((String) networkDialogModel.getAddress().getEntity());
                    entity.setSubnet((String) networkDialogModel.getSubnet().getEntity());
                    entity.setGateway((String) networkDialogModel.getGateway().getEntity());
                    if ((Boolean) networkDialogModel.getIsToSync().getEntity()) {
                        HostSetupNetworksModel.this.networksToSync.add(logicalNetwork.getName());
                    } else {
                        HostSetupNetworksModel.this.networksToSync.remove(logicalNetwork.getName());
                    }
                    sourceListModel.setConfirmWindow(null);
                }
            };
        }
    }
    // ok command
    // $NON-NLS-1$
    UICommand okCommand = new UICommand("OK", okTarget);
    okCommand.setTitle(ConstantsManager.getInstance().getConstants().ok());
    okCommand.setIsDefault(true);
    // cancel command
    UICommand cancelCommand = new UICommand("Cancel", new // $NON-NLS-1$
    BaseCommandTarget() {

        @Override
        public void executeCommand(UICommand command) {
            sourceListModel.setConfirmWindow(null);
        }
    });
    cancelCommand.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    cancelCommand.setIsCancel(true);
    if (editPopup != null) {
        editPopup.getCommands().add(okCommand);
        editPopup.getCommands().add(cancelCommand);
    }
    sourceListModel.setConfirmWindow(editPopup);
}
#end_block

#method_before
public void enableColumnResizing() {
    columnResizingEnabled = true;
    // $NON-NLS-1$
    setWidth("100%", true);
}
#method_after
public void enableColumnResizing() {
    columnResizingEnabled = true;
    // Column resize implementation needs table-layout:fixed (disable browser-specific table layout algorithm)
    // $NON-NLS-1$
    setWidth("100%", true);
}
#end_block

#method_before
@Override
protected void connect() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        getLogger().debug("Connecting to RDP console...");
        boolean haveFqdn = false;
        if (getUseFqdnIfAvailable()) {
            // $NON-NLS-1$
            getLogger().debug("RDP connection is using FQDN if available");
            if (!StringHelper.isNullOrEmpty(getEntity().getVmFQDN())) {
                // $NON-NLS-1$
                getLogger().debug("RDP connection is using FQDN because it is available");
                getrdp().setAddress(getEntity().getVmFQDN());
            }
        }
        if (!haveFqdn) {
            // $NON-NLS-1$
            getLogger().debug("RDP connection is not using FQDN");
            // $NON-NLS-1$
            getrdp().setAddress(getEntity().getVmHost().split("[ ]", -1)[0]);
        }
        getrdp().setGuestID(getEntity().getId().toString());
        // Try to connect.
        try {
            getrdp().connect();
            updateActionAvailability();
        } catch (RuntimeException ex) {
            // $NON-NLS-1$
            getLogger().error("Exception on RDP connect", ex);
        }
    }
}
#method_after
@Override
protected void connect() {
    if (getEntity() != null) {
        // $NON-NLS-1$
        getLogger().debug("Connecting to RDP console...");
        boolean haveFqdn = false;
        if (getUseFqdnIfAvailable()) {
            // $NON-NLS-1$
            getLogger().debug("RDP connection is using FQDN if available");
            if (!StringHelper.isNullOrEmpty(getEntity().getVmFQDN())) {
                // $NON-NLS-1$
                getLogger().debug("RDP connection is using FQDN because it is available");
                haveFqdn = true;
                getrdp().setAddress(getEntity().getVmFQDN());
            }
        }
        if (!haveFqdn) {
            // $NON-NLS-1$
            getLogger().debug("RDP connection is not using FQDN");
            // $NON-NLS-1$
            getrdp().setAddress(getEntity().getVmHost().split("[ ]", -1)[0]);
        }
        getrdp().setGuestID(getEntity().getId().toString());
        // Try to connect.
        try {
            getrdp().connect();
            updateActionAvailability();
        } catch (RuntimeException ex) {
            // $NON-NLS-1$
            getLogger().error("Exception on RDP connect", ex);
        }
    }
}
#end_block

#method_before
private static StoragePool cloneStorage_pool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setStorageType(instance.getStorageType());
    obj.setstatus(instance.getstatus());
    obj.setmaster_domain_version(instance.getmaster_domain_version());
    obj.setLVER(instance.getLVER());
    obj.setrecovery_mode(instance.getrecovery_mode());
    obj.setspm_vds_id(instance.getspm_vds_id());
    obj.setcompatibility_version(instance.getcompatibility_version());
    return obj;
}
#method_after
private static StoragePool cloneStorage_pool(StoragePool instance) {
    StoragePool obj = new StoragePool();
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setStorageType(instance.getStorageType());
    obj.setStatus(instance.getStatus());
    obj.setmaster_domain_version(instance.getmaster_domain_version());
    obj.setLVER(instance.getLVER());
    obj.setrecovery_mode(instance.getrecovery_mode());
    obj.setspm_vds_id(instance.getspm_vds_id());
    obj.setcompatibility_version(instance.getcompatibility_version());
    return obj;
}
#end_block

#method_before
private static VDSGroup cloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setcpu_name(instance.getcpu_name());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    return obj;
}
#method_after
private static VDSGroup cloneVDSGroup(VDSGroup instance) {
    VDSGroup obj = new VDSGroup();
    obj.setId(instance.getId());
    obj.setName(instance.getName());
    obj.setdescription(instance.getdescription());
    obj.setComment(instance.getComment());
    obj.setcpu_name(instance.getcpu_name());
    obj.setcompatibility_version(instance.getcompatibility_version());
    obj.setMigrateOnError(instance.getMigrateOnError());
    obj.setTransparentHugepages(instance.getTransparentHugepages());
    obj.setStoragePoolId(instance.getStoragePoolId());
    obj.setmax_vds_memory_over_commit(instance.getmax_vds_memory_over_commit());
    obj.setCountThreadsAsCores(instance.getCountThreadsAsCores());
    obj.setEmulatedMachine(instance.getEmulatedMachine());
    obj.setDetectEmulatedMachine(instance.isDetectEmulatedMachine());
    return obj;
}
#end_block

#method_before
private static Object cloneClusterPolicy(ClusterPolicy clusterPolicy) {
    ClusterPolicy obj = new ClusterPolicy();
    if (clusterPolicy.getId() != null) {
        obj.setId(clusterPolicy.getId());
    }
    obj.setName(clusterPolicy.getName());
    obj.setDescription(clusterPolicy.getDescription());
    obj.setLocked(clusterPolicy.isLocked());
    obj.setDefaultPolicy(clusterPolicy.isDefaultPolicy());
    if (clusterPolicy.getFilters() != null) {
        obj.setFilters(new ArrayList<Guid>());
        for (Guid policyUnitId : clusterPolicy.getFilters()) {
            obj.getFilters().add(policyUnitId);
        }
    }
    if (clusterPolicy.getFilterPositionMap() != null) {
        obj.setFilterPositionMap(new HashMap<Guid, Integer>());
        for (Entry<Guid, Integer> entry : clusterPolicy.getFilterPositionMap().entrySet()) {
            obj.getFilterPositionMap().put(entry.getKey(), new Integer(entry.getValue()));
        }
    }
    if (clusterPolicy.getFunctions() != null) {
        obj.setFunctions(new ArrayList<Pair<Guid, Integer>>());
        for (Pair<Guid, Integer> pair : clusterPolicy.getFunctions()) {
            obj.getFunctions().add(new Pair<Guid, Integer>(pair.getFirst(), pair.getSecond()));
        }
    }
    if (clusterPolicy.getBalance() != null) {
        obj.setBalance(clusterPolicy.getBalance());
    }
    if (clusterPolicy.getParameterMap() != null) {
        obj.setParameterMap(new LinkedHashMap());
        for (Entry<String, String> entry : clusterPolicy.getParameterMap().entrySet()) {
            obj.getParameterMap().put(entry.getKey(), entry.getValue());
        }
    }
    return obj;
}
#method_after
private static Object cloneClusterPolicy(ClusterPolicy clusterPolicy) {
    ClusterPolicy obj = new ClusterPolicy();
    if (clusterPolicy.getId() != null) {
        obj.setId(clusterPolicy.getId());
    }
    obj.setName(clusterPolicy.getName());
    obj.setDescription(clusterPolicy.getDescription());
    obj.setLocked(clusterPolicy.isLocked());
    obj.setDefaultPolicy(clusterPolicy.isDefaultPolicy());
    if (clusterPolicy.getFilters() != null) {
        obj.setFilters(new ArrayList<Guid>());
        for (Guid policyUnitId : clusterPolicy.getFilters()) {
            obj.getFilters().add(policyUnitId);
        }
    }
    if (clusterPolicy.getFilterPositionMap() != null) {
        obj.setFilterPositionMap(new HashMap<Guid, Integer>());
        for (Entry<Guid, Integer> entry : clusterPolicy.getFilterPositionMap().entrySet()) {
            obj.getFilterPositionMap().put(entry.getKey(), entry.getValue());
        }
    }
    if (clusterPolicy.getFunctions() != null) {
        obj.setFunctions(new ArrayList<Pair<Guid, Integer>>());
        for (Pair<Guid, Integer> pair : clusterPolicy.getFunctions()) {
            obj.getFunctions().add(new Pair<Guid, Integer>(pair.getFirst(), pair.getSecond()));
        }
    }
    if (clusterPolicy.getBalance() != null) {
        obj.setBalance(clusterPolicy.getBalance());
    }
    if (clusterPolicy.getParameterMap() != null) {
        obj.setParameterMap(new LinkedHashMap());
        for (Entry<String, String> entry : clusterPolicy.getParameterMap().entrySet()) {
            obj.getParameterMap().put(entry.getKey(), entry.getValue());
        }
    }
    return obj;
}
#end_block

#method_before
public VMStatus getStatus() {
    return this.status;
}
#method_after
@Override
public VMStatus getStatus() {
    return this.status;
}
#end_block

#method_before
public void setStatus(VMStatus value) {
    this.status = value;
}
#method_after
@Override
public void setStatus(VMStatus value) {
    this.status = value;
}
#end_block

#method_before
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuidDefaultEmpty(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    return entity;
}
#method_after
@Override
public VM mapRow(ResultSet rs, int rowNum) throws SQLException {
    VM entity = new VM();
    entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
    entity.setName(rs.getString("vm_name"));
    entity.setQuotaId(getGuid(rs, "quota_id"));
    entity.setQuotaName(rs.getString("quota_name"));
    entity.setQuotaEnforcementType(QuotaEnforcementTypeEnum.forValue(rs.getInt("quota_enforcement_type")));
    entity.setVmMemSizeMb(rs.getInt("vm_mem_size_mb"));
    entity.setVmtGuid(getGuidDefaultEmpty(rs, "vmt_guid"));
    entity.setVmOs(rs.getInt("vm_os"));
    entity.setVmDescription(rs.getString("vm_description"));
    entity.setVdsGroupId(getGuidDefaultEmpty(rs, "vds_group_id"));
    entity.setComment(rs.getString("vm_comment"));
    entity.setVmDomain(rs.getString("vm_domain"));
    entity.setVmCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vm_creation_date")));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setVdsGroupDescription(rs.getString("vds_group_description"));
    entity.setVmtName(rs.getString("vmt_name"));
    entity.setVmtMemSizeMb(rs.getInt("vmt_mem_size_mb"));
    entity.setVmtOsId(rs.getInt("vmt_os"));
    entity.setVmtCreationDate(DbFacadeUtils.fromDate(rs.getTimestamp("vmt_creation_date")));
    entity.setVmtChildCount(rs.getInt("vmt_child_count"));
    entity.setVmtNumOfCpus(rs.getInt("vmt_num_of_cpus"));
    entity.setVmtNumOfSockets(rs.getInt("vmt_num_of_sockets"));
    entity.setVmtCpuPerSocket(rs.getInt("vmt_cpu_per_socket"));
    entity.setVmtDescription(rs.getString("vmt_description"));
    entity.setStatus(VMStatus.forValue(rs.getInt("status")));
    entity.setVmIp(rs.getString("vm_ip"));
    entity.setVmFQDN(rs.getString("vm_fqdn"));
    entity.setVmHost(rs.getString("vm_host"));
    entity.setVmPid((Integer) rs.getObject("vm_pid"));
    entity.setDbGeneration(rs.getLong("db_generation"));
    entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
    entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
    entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
    entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
    entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
    entity.setConsoleUserId(getGuid(rs, "console_user_id"));
    entity.setGuestOs(rs.getString("guest_os"));
    entity.setCpuUser(rs.getDouble("cpu_user"));
    entity.setCpuSys(rs.getDouble("cpu_sys"));
    entity.setElapsedTime(rs.getDouble("elapsed_time"));
    entity.setUsageNetworkPercent((Integer) rs.getObject("usage_network_percent"));
    entity.setUsageMemPercent((Integer) rs.getObject("usage_mem_percent"));
    entity.setUsageCpuPercent((Integer) rs.getObject("usage_cpu_percent"));
    entity.setRunOnVds(getGuid(rs, "run_on_vds"));
    entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
    entity.setAppList(rs.getString("app_list"));
    entity.setDisplay((Integer) rs.getObject("display"));
    entity.setVmPoolName(rs.getString("vm_pool_name"));
    entity.setVmPoolId(getGuid(rs, "vm_pool_id"));
    entity.setNumOfMonitors(rs.getInt("num_of_monitors"));
    entity.setSingleQxlPci(rs.getBoolean("single_qxl_pci"));
    entity.setAllowConsoleReconnect(rs.getBoolean("allow_console_reconnect"));
    entity.setInitialized(rs.getBoolean("is_initialized"));
    entity.setNumOfSockets(rs.getInt("num_of_sockets"));
    entity.setCpuPerSocket(rs.getInt("cpu_per_socket"));
    entity.setUsbPolicy(UsbPolicy.forValue(rs.getInt("usb_policy")));
    entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
    entity.setSession(SessionState.forValue(rs.getInt("session")));
    entity.setDisplayIp(rs.getString("display_ip"));
    entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
    entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
    entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
    entity.setRunOnVdsName(rs.getString("run_on_vds_name"));
    entity.setTimeZone(rs.getString("time_zone"));
    entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
    entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
    entity.setAutoStartup(rs.getBoolean("auto_startup"));
    entity.setStateless(rs.getBoolean("is_stateless"));
    entity.setSmartcardEnabled(rs.getBoolean("is_smartcard_enabled"));
    entity.setDeleteProtected(rs.getBoolean("is_delete_protected"));
    entity.setDedicatedVmForVds(getGuid(rs, "dedicated_vm_for_vds"));
    entity.setFailBack(rs.getBoolean("fail_back"));
    entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
    entity.setClientIp(rs.getString("client_ip"));
    entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
    entity.setVdsGroupCpuName(rs.getString("vds_group_cpu_name"));
    entity.setVmType(VmType.forValue(rs.getInt("vm_type")));
    entity.setStoragePoolId(getGuidDefaultEmpty(rs, "storage_pool_id"));
    entity.setStoragePoolName(rs.getString("storage_pool_name"));
    entity.setTransparentHugePages(rs.getBoolean("transparent_hugepages"));
    entity.setNiceLevel(rs.getInt("nice_level"));
    entity.setCpuShares(rs.getInt("cpu_shares"));
    entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
    entity.setDefaultBootSequence(BootSequence.forValue(rs.getInt("default_boot_sequence")));
    entity.setDefaultDisplayType(DisplayType.forValue(rs.getInt("default_display_type")));
    entity.setPriority(rs.getInt("priority"));
    entity.setIsoPath(rs.getString("iso_path"));
    entity.setOrigin(OriginType.forValue(rs.getInt("origin")));
    entity.setInitrdUrl(rs.getString("initrd_url"));
    entity.setKernelUrl(rs.getString("kernel_url"));
    entity.setKernelParams(rs.getString("kernel_params"));
    entity.setVdsGroupCompatibilityVersion(new Version(rs.getString("vds_group_compatibility_version")));
    entity.setExitMessage(rs.getString("exit_message"));
    entity.setExitStatus(VmExitStatus.forValue(rs.getInt("exit_status")));
    entity.setVmPauseStatus(VmPauseStatus.forValue(rs.getInt("pause_status")));
    entity.setMigrationSupport(MigrationSupport.forValue(rs.getInt("migration_support")));
    String predefinedProperties = rs.getString("predefined_properties");
    String userDefinedProperties = rs.getString("userdefined_properties");
    entity.setPredefinedProperties(predefinedProperties);
    entity.setUserDefinedProperties(userDefinedProperties);
    entity.setCustomProperties(VmPropertiesUtils.getInstance().customProperties(predefinedProperties, userDefinedProperties));
    entity.setMinAllocatedMem(rs.getInt("min_allocated_mem"));
    entity.setHash(rs.getString("hash"));
    entity.setCpuPinning(rs.getString("cpu_pinning"));
    entity.setUseHostCpuFlags(rs.getBoolean("host_cpu_flags"));
    entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
    entity.setTunnelMigration((Boolean) rs.getObject("tunnel_migration"));
    entity.setVncKeyboardLayout(rs.getString("vnc_keyboard_layout"));
    entity.setRunAndPause(rs.getBoolean("is_run_and_pause"));
    entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
    entity.setTrustedService(rs.getBoolean("trusted_service"));
    entity.setRunOnce(rs.getBoolean("is_run_once"));
    entity.setCreatedByUserId(getGuid(rs, "created_by_user_id"));
    return entity;
}
#end_block

#method_before
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setDomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        staticVm.setTimeZone(vm.getTimezone());
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    return staticVm;
}
#method_after
@Mapping(from = VM.class, to = VmStatic.class)
public static VmStatic map(VM vm, VmStatic template) {
    VmStatic staticVm = template != null ? template : new VmStatic();
    if (vm.isSetName()) {
        staticVm.setName(vm.getName());
    }
    if (vm.isSetId()) {
        staticVm.setId(GuidUtils.asGuid(vm.getId()));
    }
    if (vm.isSetDescription()) {
        staticVm.setDescription(vm.getDescription());
    }
    if (vm.isSetComment()) {
        staticVm.setComment(vm.getComment());
    }
    if (vm.isSetMemory()) {
        staticVm.setMemSizeMb((int) (vm.getMemory() / BYTES_PER_MB));
    } else if (staticVm.getMemSizeMb() == 0) {
        // TODO: Get rid of this logic code when Backend supports default memory.
        staticVm.setMemSizeMb(DEFAULT_MEMORY_SIZE);
    }
    if (vm.isSetTemplate() && vm.getTemplate().getId() != null) {
        staticVm.setVmtGuid(GuidUtils.asGuid(vm.getTemplate().getId()));
    }
    if (vm.isSetCluster() && vm.getCluster().getId() != null) {
        staticVm.setVdsGroupId(GuidUtils.asGuid(vm.getCluster().getId()));
    }
    if (vm.isSetCpu()) {
        if (vm.getCpu().isSetMode()) {
            staticVm.setUseHostCpuFlags(CpuMode.fromValue(vm.getCpu().getMode()) == CpuMode.HOST_PASSTHROUGH);
        }
        if (vm.getCpu().isSetTopology()) {
            if (vm.getCpu().getTopology().getCores() != null) {
                staticVm.setCpuPerSocket(vm.getCpu().getTopology().getCores());
            }
            if (vm.getCpu().getTopology().getSockets() != null) {
                staticVm.setNumOfSockets(vm.getCpu().getTopology().getSockets());
            }
        }
        if (vm.getCpu().isSetCpuTune()) {
            staticVm.setCpuPinning(cpuTuneToString(vm.getCpu().getCpuTune()));
        }
    }
    if (vm.isSetCpuShares()) {
        staticVm.setCpuShares(vm.getCpuShares());
    }
    if (vm.isSetOs()) {
        if (vm.getOs().isSetType()) {
            staticVm.setOsId(mapOsType(vm.getOs().getType()));
        }
        if (vm.getOs().isSetBoot() && vm.getOs().getBoot().size() > 0) {
            staticVm.setDefaultBootSequence(map(vm.getOs().getBoot(), null));
        }
        if (vm.getOs().isSetKernel()) {
            staticVm.setKernelUrl(vm.getOs().getKernel());
        }
        if (vm.getOs().isSetInitrd()) {
            staticVm.setInitrdUrl(vm.getOs().getInitrd());
        }
        if (vm.getOs().isSetCmdline()) {
            staticVm.setKernelParams(vm.getOs().getCmdline());
        }
    }
    if (vm.isSetType()) {
        VmType vmType = VmType.fromValue(vm.getType());
        if (vmType != null) {
            staticVm.setVmType(map(vmType, null));
        }
    }
    if (vm.isSetStateless()) {
        staticVm.setStateless(vm.isStateless());
    }
    if (vm.isSetDeleteProtected()) {
        staticVm.setDeleteProtected(vm.isDeleteProtected());
    }
    if (vm.isSetHighAvailability()) {
        HighAvailability ha = vm.getHighAvailability();
        if (ha.isSetEnabled()) {
            staticVm.setAutoStartup(ha.isEnabled());
        }
        if (ha.isSetPriority()) {
            staticVm.setPriority(ha.getPriority());
        }
    }
    if (vm.isSetOrigin()) {
        staticVm.setOrigin(map(vm.getOrigin(), (OriginType) null));
    }
    if (vm.isSetDisplay()) {
        if (vm.getDisplay().isSetType()) {
            DisplayType displayType = DisplayType.fromValue(vm.getDisplay().getType());
            if (displayType != null) {
                staticVm.setDefaultDisplayType(map(displayType, null));
            }
        }
        if (vm.getDisplay().isSetMonitors()) {
            staticVm.setNumOfMonitors(vm.getDisplay().getMonitors());
        }
        if (vm.getDisplay().isSetSingleQxlPci()) {
            staticVm.setSingleQxlPci(vm.getDisplay().isSingleQxlPci());
        }
        if (vm.getDisplay().isSetAllowOverride()) {
            staticVm.setAllowConsoleReconnect(vm.getDisplay().isAllowOverride());
        }
        if (vm.getDisplay().isSetSmartcardEnabled()) {
            staticVm.setSmartcardEnabled(vm.getDisplay().isSmartcardEnabled());
        }
        if (vm.getDisplay().isSetKeyboardLayout()) {
            String layout = vm.getDisplay().getKeyboardLayout();
            if (layout.isEmpty()) {
                // uniquely represent unset keyboard layout as null
                layout = null;
            }
            staticVm.setVncKeyboardLayout(layout);
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetAffinity()) {
        VmAffinity vmAffinity = VmAffinity.fromValue(vm.getPlacementPolicy().getAffinity());
        if (vmAffinity != null) {
            staticVm.setMigrationSupport(map(vmAffinity, null));
        }
    }
    if (vm.isSetPlacementPolicy() && vm.getPlacementPolicy().isSetHost()) {
        staticVm.setDedicatedVmForVds(createGuidFromString(vm.getPlacementPolicy().getHost().getId()));
    }
    if (vm.isSetDomain() && vm.getDomain().isSetName()) {
        staticVm.setDomain(vm.getDomain().getName());
    }
    if (vm.isSetMemoryPolicy() && vm.getMemoryPolicy().isSetGuaranteed()) {
        Long memGuaranteed = vm.getMemoryPolicy().getGuaranteed() / BYTES_PER_MB;
        staticVm.setMinAllocatedMem(memGuaranteed.intValue());
    }
    if (vm.isSetTimezone()) {
        String timezone = vm.getTimezone();
        if (timezone.isEmpty()) {
            // normalize default timezone representation
            timezone = null;
        }
        staticVm.setTimeZone(timezone);
    }
    if (vm.isSetCustomProperties()) {
        staticVm.setCustomProperties(CustomPropertiesParser.parse(vm.getCustomProperties().getCustomProperty()));
    }
    if (vm.isSetQuota() && vm.getQuota().isSetId()) {
        staticVm.setQuotaId(GuidUtils.asGuid(vm.getQuota().getId()));
    }
    if (vm.isSetTunnelMigration()) {
        staticVm.setTunnelMigration(vm.isTunnelMigration());
    }
    return staticVm;
}
#end_block

#method_before
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            model.getGuestInfo().setIps(new IPs());
            model.getGuestInfo().setFqdn(hasFqdn ? entity.getVmFQDN() : "");
            if (hasIps) {
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        model.getGuestInfo().getIps().getIPs().add(ip);
                    }
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#method_after
@Mapping(from = org.ovirt.engine.core.common.businessentities.VM.class, to = org.ovirt.engine.api.model.VM.class)
public static VM map(org.ovirt.engine.core.common.businessentities.VM entity, VM template) {
    VM model = template != null ? template : new VM();
    model.setId(entity.getId().toString());
    model.setName(entity.getName());
    model.setDescription(entity.getVmDescription());
    model.setComment(entity.getComment());
    model.setMemory((long) entity.getMemSizeMb() * BYTES_PER_MB);
    if (entity.getVmtGuid() != null) {
        model.setTemplate(new Template());
        model.getTemplate().setId(entity.getVmtGuid().toString());
    }
    if (entity.getStatus() != null) {
        model.setStatus(StatusUtils.create(map(entity.getStatus(), null)));
        if (entity.getStatus() == VMStatus.Paused) {
            model.getStatus().setDetail(entity.getVmPauseStatus().name().toLowerCase());
        }
    }
    if (entity.getBootSequence() != null || entity.getKernelUrl() != null || entity.getInitrdUrl() != null || entity.getKernelParams() != null) {
        OperatingSystem os = new OperatingSystem();
        os.setType(SimpleDependecyInjector.getInstance().get(OsRepository.class).getUniqueOsNames().get(entity.getVmOsId()));
        os.setKernel(entity.getKernelUrl());
        os.setInitrd(entity.getInitrdUrl());
        os.setCmdline(entity.getKernelParams());
        model.setOs(os);
    }
    if (entity.getVdsGroupId() != null) {
        Cluster cluster = new Cluster();
        cluster.setId(entity.getVdsGroupId().toString());
        model.setCluster(cluster);
    }
    CpuTopology topology = new CpuTopology();
    topology.setSockets(entity.getNumOfSockets());
    topology.setCores(entity.getNumOfCpus() / entity.getNumOfSockets());
    final CPU cpu = new CPU();
    model.setCpu(cpu);
    if (entity.isUseHostCpuFlags()) {
        cpu.setMode(CpuMode.HOST_PASSTHROUGH.value());
    }
    cpu.setCpuTune(stringToCpuTune(entity.getCpuPinning()));
    cpu.setTopology(topology);
    model.setCpuShares(entity.getCpuShares());
    if (entity.getVmPoolId() != null) {
        VmPool pool = new VmPool();
        pool.setId(entity.getVmPoolId().toString());
        model.setVmPool(pool);
    }
    if (entity.getDynamicData() != null && entity.getStatus().isRunningOrPaused()) {
        if (model.getOs() != null && entity.getBootSequence() != null) {
            for (Boot boot : map(entity.getBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getRunOnVds() != null) {
            model.setHost(new Host());
            model.getHost().setId(entity.getRunOnVds().toString());
        }
        final boolean hasIps = entity.getVmIp() != null && !entity.getVmIp().isEmpty();
        final boolean hasFqdn = entity.getVmFQDN() != null && !entity.getVmFQDN().isEmpty();
        if (hasIps || hasFqdn) {
            model.setGuestInfo(new GuestInfo());
            if (hasFqdn) {
                model.getGuestInfo().setFqdn(entity.getVmFQDN());
            }
            if (hasIps) {
                IPs ips = new IPs();
                for (String item : entity.getVmIp().split(" ")) {
                    if (!item.equals("")) {
                        IP ip = new IP();
                        ip.setAddress(item.trim());
                        ips.getIPs().add(ip);
                    }
                }
                if (!ips.getIPs().isEmpty()) {
                    model.getGuestInfo().setIps(ips);
                }
            }
        }
        if (entity.getLastStartTime() != null) {
            model.setStartTime(DateMapper.map(entity.getLastStartTime(), null));
        }
        model.setDisplay(new Display());
        model.getDisplay().setType(map(entity.getDisplayType(), null));
        model.getDisplay().setAddress(entity.getDisplayIp());
        Integer displayPort = entity.getDisplay();
        model.getDisplay().setPort(displayPort == null || displayPort == -1 ? null : displayPort);
        Integer displaySecurePort = entity.getDisplaySecurePort();
        model.getDisplay().setSecurePort(displaySecurePort == null || displaySecurePort == -1 ? null : displaySecurePort);
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
    } else {
        if (model.getOs() != null) {
            for (Boot boot : map(entity.getDefaultBootSequence(), null)) {
                model.getOs().getBoot().add(boot);
            }
        }
        if (entity.getDefaultDisplayType() != null) {
            model.setDisplay(new Display());
            model.getDisplay().setType(map(entity.getDefaultDisplayType(), null));
        }
    }
    if (model.getDisplay() != null) {
        model.getDisplay().setMonitors(entity.getNumOfMonitors());
        model.getDisplay().setSingleQxlPci(entity.getSingleQxlPci());
        model.getDisplay().setAllowOverride(entity.getAllowConsoleReconnect());
        model.getDisplay().setSmartcardEnabled(entity.isSmartcardEnabled());
        model.getDisplay().setKeyboardLayout(entity.getVncKeyboardLayout());
    }
    model.setType(map(entity.getVmType(), null));
    model.setStateless(entity.isStateless());
    model.setDeleteProtected(entity.isDeleteProtected());
    model.setHighAvailability(new HighAvailability());
    model.getHighAvailability().setEnabled(entity.isAutoStartup());
    model.getHighAvailability().setPriority(entity.getPriority());
    if (entity.getOrigin() != null) {
        model.setOrigin(map(entity.getOrigin(), null));
    }
    if (entity.getVmCreationDate() != null) {
        model.setCreationTime(DateMapper.map(entity.getVmCreationDate(), null));
    }
    model.setPlacementPolicy(new VmPlacementPolicy());
    if (entity.getDedicatedVmForVds() != null) {
        model.getPlacementPolicy().setHost(new Host());
        model.getPlacementPolicy().getHost().setId(entity.getDedicatedVmForVds().toString());
    }
    VmAffinity vmAffinity = map(entity.getMigrationSupport(), null);
    if (vmAffinity != null) {
        model.getPlacementPolicy().setAffinity(vmAffinity.value());
    }
    if (entity.getVmDomain() != null && !entity.getVmDomain().isEmpty()) {
        Domain domain = new Domain();
        domain.setName(entity.getVmDomain());
        model.setDomain(domain);
    }
    MemoryPolicy policy = new MemoryPolicy();
    policy.setGuaranteed((long) entity.getMinAllocatedMem() * (long) BYTES_PER_MB);
    model.setMemoryPolicy(policy);
    model.setTimezone(entity.getTimeZone());
    if (!StringUtils.isEmpty(entity.getCustomProperties())) {
        CustomProperties hooks = new CustomProperties();
        hooks.getCustomProperty().addAll(CustomPropertiesParser.parse(entity.getCustomProperties(), false));
        model.setCustomProperties(hooks);
    }
    if (entity.getUsbPolicy() != null) {
        Usb usb = new Usb();
        usb.setEnabled(UsbMapperUtils.getIsUsbEnabled(entity.getUsbPolicy()));
        UsbType usbType = UsbMapperUtils.getUsbType(entity.getUsbPolicy());
        if (usbType != null) {
            usb.setType(usbType.value());
        }
        model.setUsb(usb);
    }
    if (entity.getQuotaId() != null) {
        Quota quota = new Quota();
        quota.setId(entity.getQuotaId().toString());
        model.setQuota(quota);
    }
    model.setTunnelMigration(entity.getTunnelMigration());
    return model;
}
#end_block

#method_before
static String cpuTuneToString(final CpuTune tune) {
    final StringBuilder builder = new StringBuilder();
    boolean first = true;
    for (final VCpuPin pin : tune.getVcpuPin()) {
        if (first) {
            first = false;
        } else {
            builder.append("_");
        }
        builder.append(pin.getVcpu()).append('#').append(pin.getCpuSet());
    }
    return builder.toString();
}
#method_after
static String cpuTuneToString(final CpuTune tune) {
    final StringBuilder builder = new StringBuilder();
    boolean first = true;
    for (final VCpuPin pin : tune.getVCpuPin()) {
        if (first) {
            first = false;
        } else {
            builder.append("_");
        }
        builder.append(pin.getVcpu()).append('#').append(pin.getCpuSet());
    }
    return builder.toString();
}
#end_block

#method_before
static CpuTune stringToCpuTune(String cpuPinning) {
    if (cpuPinning == null || cpuPinning.equals("")) {
        return null;
    }
    final CpuTune cpuTune = new CpuTune();
    for (String strCpu : cpuPinning.split("_")) {
        VCpuPin pin = stringToVCpupin(strCpu);
        cpuTune.getVcpuPin().add(pin);
    }
    return cpuTune;
}
#method_after
static CpuTune stringToCpuTune(String cpuPinning) {
    if (cpuPinning == null || cpuPinning.equals("")) {
        return null;
    }
    final CpuTune cpuTune = new CpuTune();
    for (String strCpu : cpuPinning.split("_")) {
        VCpuPin pin = stringToVCpupin(strCpu);
        cpuTune.getVCpuPin().add(pin);
    }
    return cpuTune;
}
#end_block

#method_before
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#method_after
protected boolean canDoAddVmCommand() {
    boolean returnValue = false;
    returnValue = areParametersLegal(getReturnValue().getCanDoActionMessages());
    // Check if number of monitors passed is legal
    returnValue = returnValue && checkNumberOfMonitors() && checkSingleQxlDisplay();
    returnValue = returnValue && checkPciAndIdeLimit(getParameters().getVmStaticData().getNumOfMonitors(), getVmInterfaces(), getVmDisks(), isVirtioScsiEnabled(), getReturnValue().getCanDoActionMessages()) && canAddVm(getReturnValue().getCanDoActionMessages(), destStorages.values()) && hostToRunExist();
    return returnValue;
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.CheckCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
public static boolean checkCpuSockets(int num_of_sockets, int cpu_per_socket, String compatibility_version, List<String> CanDoActionMessages) {
    boolean retValue = true;
    if (retValue && (num_of_sockets * cpu_per_socket) > Config.<Integer>GetValue(ConfigValues.MaxNumOfVmCpus, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_CPU.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets > Config.<Integer>GetValue(ConfigValues.MaxNumOfVmSockets, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_NUM_SOCKETS.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket > Config.<Integer>GetValue(ConfigValues.MaxNumOfCpuPerSocket, compatibility_version)) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MAX_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && cpu_per_socket < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_CPU_PER_SOCKET.toString());
        retValue = false;
    }
    if (retValue && num_of_sockets < 1) {
        CanDoActionMessages.add(VdcBllMessages.ACTION_TYPE_FAILED_MIN_NUM_SOCKETS.toString());
        retValue = false;
    }
    return retValue;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    if (getVmTemplate().isDisabled()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_IS_DISABLED);
    }
    if (!buildAndCheckDestStorageDomains()) {
        return false;
    }
    // otherwise..
    storageToDisksMap = ImagesHandler.buildStorageToDiskMap(getImagesToCheckDestinationStorageDomains(), diskInfoDestinationMap);
    if (!canDoAddVmCommand()) {
        return false;
    }
    VM vmFromParams = getParameters().getVm();
    if (StringUtils.isEmpty(vmFromParams.getName())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_MAY_NOT_BE_EMPTY);
    }
    // check that VM name is not too long
    if (!isVmNameValidLength(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NAME_LENGTH_IS_TOO_LONG);
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (!checkPayload(getParameters().getVmPayload(), getParameters().getVmStaticData().getIsoPath())) {
            return false;
        }
        // otherwise, we save the content in base64 string
        for (Map.Entry<String, String> entry : getParameters().getVmPayload().getFiles().entrySet()) {
            entry.setValue(Base64.encodeBase64String(entry.getValue().getBytes()));
        }
    }
    // Check that the USB policy is legal
    if (!VmHandler.isUsbPolicyLegal(vmFromParams.getUsbPolicy(), vmFromParams.getOs(), getVdsGroup(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    // check cpuPinning if the check haven't failed yet
    if (!isCpuPinningValid(vmFromParams.getCpuPinning(), vmFromParams.getStaticData())) {
        return false;
    }
    if (vmFromParams.isUseHostCpuFlags() && vmFromParams.getMigrationSupport() == MigrationSupport.MIGRATABLE) {
        return failCanDoAction(VdcBllMessages.VM_HOSTCPU_MUST_BE_PINNED_TO_HOST);
    }
    if (!checkCpuSockets()) {
        return false;
    }
    if (!isCpuSharesValid(vmFromParams)) {
        return failCanDoAction(VdcBllMessages.QOS_CPU_SHARES_OUT_OF_RANGE);
    }
    if (Boolean.TRUE.equals(getParameters().isVirtioScsiEnabled()) && !FeatureSupported.virtIoScsi(getVdsGroup().getcompatibility_version())) {
        return failCanDoAction(VdcBllMessages.VIRTIO_SCSI_INTERFACE_IS_NOT_AVAILABLE_FOR_CLUSTER_LEVEL);
    }
    return true;
}
#end_block

#method_before
protected boolean checkCpuSockets() {
    return AddVmCommand.CheckCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkCpuSockets() {
    return AddVmCommand.checkCpuSockets(getParameters().getVmStaticData().getNumOfSockets(), getParameters().getVmStaticData().getCpuPerSocket(), getVdsGroup().getcompatibility_version().toString(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected Collection<DiskImage> getImagesToCheckDestinationStorageDomains() {
    return getVmTemplate().getDiskMap().values();
}
#method_after
protected Collection<DiskImage> getImagesToCheckDestinationStorageDomains() {
    return getVmTemplate().getDiskTemplateMap().values();
}
#end_block

#method_before
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.VerifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#method_after
protected boolean verifyAddVM(List<String> reasons, int vmPriority) {
    return VmHandler.verifyAddVm(reasons, getVmInterfaces().size(), vmPriority);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions(newDiskImages);
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#method_after
@Override
protected void executeVmCommand() {
    ArrayList<String> errorMessages = new ArrayList<String>();
    if (canAddVm(errorMessages, destStorages.values())) {
        TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                addVmStatic();
                addVmDynamic();
                addVmNetwork();
                addVmStatistics();
                addActiveSnapshot();
                addVmPermission();
                getCompensationContext().stateChanged();
                return null;
            }
        });
        if (addVmImages()) {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    copyVmDevices();
                    addDiskPermissions();
                    addVmPayload();
                    updateSmartCardDevices();
                    addVmWatchdog();
                    setActionReturnValue(getVm().getId());
                    setSucceeded(true);
                    return null;
                }
            });
        }
    } else {
        log.errorFormat("Failed to add vm . The reasons are: {0}", StringUtils.join(errorMessages, ','));
    }
}
#end_block

#method_before
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), newDiskImages, _vmInterfaces, getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled());
}
#method_after
protected void copyVmDevices() {
    VmDeviceUtils.copyVmDevices(getVmTemplateId(), getVmId(), getSrcDeviceIdToTargetDeviceIdMapping(), getParameters().isSoundDeviceEnabled(), getParameters().isConsoleEnabled(), isVirtioScsiEnabled());
}
#end_block

#method_before
protected boolean areParametersLegal(List<String> reasons) {
    boolean returnValue = false;
    final VmStatic vmStaticData = getParameters().getVmStaticData();
    if (vmStaticData != null) {
        returnValue = IsLegalClusterId(vmStaticData.getVdsGroupId(), reasons);
        if (!validatePinningAndMigration(reasons, vmStaticData, getParameters().getVm().getCpuPinning())) {
            returnValue = false;
        }
        returnValue = returnValue && VmHandler.isMemorySizeLegal(vmStaticData.getOsId(), vmStaticData.getMemSizeMb(), reasons, getVdsGroup().getcompatibility_version());
    }
    return returnValue;
}
#method_after
protected boolean areParametersLegal(List<String> reasons) {
    boolean returnValue = false;
    final VmStatic vmStaticData = getParameters().getVmStaticData();
    if (vmStaticData != null) {
        returnValue = isLegalClusterId(vmStaticData.getVdsGroupId(), reasons);
        if (!validatePinningAndMigration(reasons, vmStaticData, getParameters().getVm().getCpuPinning())) {
            returnValue = false;
        }
        returnValue = returnValue && VmHandler.isMemorySizeLegal(vmStaticData.getOsId(), vmStaticData.getMemSizeMb(), reasons, getVdsGroup().getcompatibility_version());
    }
    return returnValue;
}
#end_block

#method_before
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        iface.setId(Guid.newGuid());
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#method_after
protected void addVmNetwork() {
    // Add interfaces from template
    for (VmNic iface : getVmInterfaces()) {
        Guid id = Guid.newGuid();
        srcVmNicIdToTargetVmNicIdMapping.put(iface.getId(), id);
        iface.setId(id);
        iface.setMacAddress(MacPoolManager.getInstance().allocateNewMac());
        iface.setSpeed(VmInterfaceType.forValue(iface.getType()).getSpeed());
        iface.setVmTemplateId(null);
        iface.setVmId(getParameters().getVmStaticData().getId());
        getVmNicDao().save(iface);
        getCompensationContext().snapshotNewEntity(iface);
        DbFacade.getInstance().getVmNetworkStatisticsDao().save(iface.getStatistics());
        getCompensationContext().snapshotNewEntity(iface.getStatistics());
    }
}
#end_block

#method_before
protected boolean addVmImages() {
    if (getVmTemplate().getDiskMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.LockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                newDiskImages.add((DiskImage) result.getActionReturnValue());
            }
        }
    }
    return true;
}
#method_after
protected boolean addVmImages() {
    if (getVmTemplate().getDiskTemplateMap().size() > 0) {
        if (getVm().getStatus() != VMStatus.Down) {
            log.error("Cannot add images. VM is not Down");
            throw new VdcBLLException(VdcBllErrors.IRS_IMAGE_STATUS_ILLEGAL);
        }
        VmHandler.lockVm(getVmId());
        for (DiskImage dit : getImagesToCheckDestinationStorageDomains()) {
            CreateSnapshotFromTemplateParameters tempVar = new CreateSnapshotFromTemplateParameters(dit.getImageId(), getParameters().getVmStaticData().getId());
            tempVar.setDestStorageDomainId(diskInfoDestinationMap.get(dit.getId()).getStorageIds().get(0));
            tempVar.setDiskAlias(diskInfoDestinationMap.get(dit.getId()).getDiskAlias());
            tempVar.setStorageDomainId(dit.getStorageIds().get(0));
            tempVar.setVmSnapshotId(getVmSnapshotId());
            tempVar.setParentCommand(VdcActionType.AddVm);
            tempVar.setEntityInfo(getParameters().getEntityInfo());
            tempVar.setParentParameters(getParameters());
            tempVar.setQuotaId(diskInfoDestinationMap.get(dit.getId()).getQuotaId());
            VdcReturnValueBase result = getBackend().runInternalAction(VdcActionType.CreateSnapshotFromTemplate, tempVar, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            /**
             * if couldn't create snapshot then stop the transaction and the command
             */
            if (!result.getSucceeded()) {
                throw new VdcBLLException(result.getFault().getError());
            } else {
                getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
                DiskImage newImage = (DiskImage) result.getActionReturnValue();
                srcDiskIdToTargetDiskIdMapping.put(dit.getId(), newImage.getId());
            }
        }
    }
    return true;
}
#end_block

#method_before
protected void addVmPermission() {
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissions perms = new permissions(getCurrentUser().getUserId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
        MultiLevelAdministrationHandler.addPermission(perms);
        getCompensationContext().snapshotNewEntity(perms);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        copyTemplatePermissions();
    }
}
#method_after
protected void addVmPermission() {
    UniquePermissionsSet permissionsToAdd = new UniquePermissionsSet();
    if ((getParameters()).isMakeCreatorExplicitOwner()) {
        permissionsToAdd.addPermission(getCurrentUser().getUserId(), PredefinedRoles.VM_OPERATOR.getId(), getVmId(), VdcObjectType.VM);
    }
    if (getParameters().isCopyTemplatePermissions() && !getVmTemplateId().equals(VmTemplateHandler.BlankVmTemplateId)) {
        copyTemplatePermissions(permissionsToAdd);
    }
    if (!permissionsToAdd.isEmpty()) {
        List<permissions> permissionsList = permissionsToAdd.asPermissionList();
        MultiLevelAdministrationHandler.addPermission(permissionsList.toArray(new permissions[permissionsList.size()]));
        getCompensationContext().snapshotNewEntities(permissionsList);
    }
}
#end_block

#method_before
private void copyTemplatePermissions() {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getCurrentUser().getUserId(), false);
    List<permissions> vmPermissions = new ArrayList<permissions>();
    for (permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        vmPermissions.add(new permissions(getCurrentUser().getUserId(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM));
    }
    if (vmPermissions.size() > 0) {
        MultiLevelAdministrationHandler.addPermission(vmPermissions.toArray(new permissions[vmPermissions.size()]));
        getCompensationContext().snapshotNewEntities(vmPermissions);
    }
}
#method_after
private void copyTemplatePermissions(UniquePermissionsSet permissionsToAdd) {
    PermissionDAO dao = getDbFacade().getPermissionDao();
    List<permissions> templatePermissions = dao.getAllForEntity(getVmTemplateId(), getCurrentUser().getUserId(), false);
    for (permissions templatePermission : templatePermissions) {
        boolean templateOwnerRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_OWNER.getId());
        boolean templateUserRole = templatePermission.getrole_id().equals(PredefinedRoles.TEMPLATE_USER.getId());
        if (templateOwnerRole || templateUserRole) {
            continue;
        }
        permissionsToAdd.addPermission(templatePermission.getad_element_id(), templatePermission.getrole_id(), getVmId(), VdcObjectType.VM);
    }
}
#end_block

#method_before
protected void addDiskPermissions(List<DiskImage> newDiskImages) {
    permissions[] permsArray = new permissions[newDiskImages.size()];
    for (int i = 0; i < newDiskImages.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getUserId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImages.get(i).getId(), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#method_after
protected void addDiskPermissions() {
    List<Guid> newDiskImageIds = new ArrayList<>(srcDiskIdToTargetDiskIdMapping.values());
    permissions[] permsArray = new permissions[newDiskImageIds.size()];
    for (int i = 0; i < newDiskImageIds.size(); i++) {
        permsArray[i] = new permissions(getCurrentUser().getUserId(), PredefinedRoles.DISK_OPERATOR.getId(), newDiskImageIds.get(i), VdcObjectType.Disk);
    }
    MultiLevelAdministrationHandler.addPermission(permsArray);
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    return Collections.singletonMap(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.REMOTE_VM, getVmIsBeingImportedMessage()));
}
#method_after
@Override
protected Map<String, Pair<String, String>> getSharedLocks() {
    return Collections.singletonMap(getParameters().getContainerId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.REMOTE_VM, getVmIsBeingImportedMessage()));
}
#end_block

#method_before
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? (List<VM>) qRetVal.getReturnValue() : null;
}
#method_after
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#end_block

#method_before
private boolean validateImageConfig(List<String> canDoActionMessages, Map<Guid, StorageDomain> domainsMap, DiskImage image) {
    return ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
}
#method_after
private boolean validateImageConfig(List<String> canDoActionMessages, Map<Guid, StorageDomain> domainsMap, DiskImage image) {
    return ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
}
#end_block

#method_before
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
    if (!setDomainsForMemoryImages(domainMap)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
        if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#method_after
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVdsCluster()) {
        return false;
    }
    Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
    if (!setDomainsForMemoryImages(domainMap)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
        if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean validateNoDuplicateVm() {
    VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
    if (duplicateVm != null) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
        addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getName()));
        return false;
    }
    return true;
}
#method_after
protected boolean validateNoDuplicateVm() {
    VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
    if (duplicateVm != null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS, String.format("$VmName %1$s", duplicateVm.getName()));
    }
    return true;
}
#end_block

#method_before
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BlankVmTemplateId.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = (Map<VmTemplate, ?>) qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#method_after
private boolean isTemplateExistsOnExportDomain() {
    if (VmTemplateHandler.BlankVmTemplateId.equals(getParameters().getVm().getVmtGuid())) {
        return true;
    }
    VdcQueryReturnValue qRetVal = Backend.getInstance().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId()));
    if (qRetVal.getSucceeded()) {
        Map<VmTemplate, ?> templates = qRetVal.getReturnValue();
        for (VmTemplate template : templates.keySet()) {
            if (getParameters().getVm().getVmtGuid().equals(template.getId())) {
                return true;
            }
        }
    }
    return false;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = (List<StorageDomain>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
private void processImages() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmImagesAndSnapshots();
            updateSnapshotsFromExport();
            moveOrCopyAllImageGroups();
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity());
            VmHandler.LockVm(getVm().getId());
            if (getParameters().isImportAsNewEntity()) {
                getParameters().setVm(getVm());
                setVmId(getVm().getId());
            }
            return null;
        }
    });
}
#method_after
private void processImages() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmImagesAndSnapshots();
            updateSnapshotsFromExport();
            moveOrCopyAllImageGroups();
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity());
            VmHandler.lockVm(getVm().getId());
            if (getParameters().isImportAsNewEntity()) {
                getParameters().setVm(getVm());
                setVmId(getVm().getId());
            }
            return null;
        }
    });
}
#end_block

#method_before
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForDisk(DiskImage disk, Guid containerID) {
    Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
    Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
    params.setParentCommand(getActionType());
    params.setUseCopyCollapse(getParameters().getCopyCollapse());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
    if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(originalDiskId)) {
        DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(originalDiskId);
        params.setVolumeType(diskImageBase.getVolumeType());
        params.setVolumeFormat(diskImageBase.getVolumeFormat());
    }
    params.setParentParameters(getParameters());
    return params;
}
#method_after
private MoveOrCopyImageGroupParameters buildMoveOrCopyImageGroupParametersForDisk(DiskImage disk, Guid containerID) {
    Guid originalDiskId = newDiskIdForDisk.get(disk.getId()).getId();
    Guid destinationDomain = imageToDestinationDomainMap.get(originalDiskId);
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(containerID, originalDiskId, newDiskIdForDisk.get(disk.getId()).getImageId(), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
    params.setParentCommand(getActionType());
    params.setUseCopyCollapse(getParameters().getCopyCollapse());
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setForceOverride(getParameters().getForceOverride());
    params.setSourceDomainId(getParameters().getSourceDomainId());
    params.setStoragePoolId(getParameters().getStoragePoolId());
    params.setImportEntity(true);
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVm().getId()));
    params.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    params.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
    if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(originalDiskId)) {
        DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(originalDiskId);
        params.setVolumeType(diskImageBase.getVolumeType());
        params.setVolumeFormat(diskImageBase.getVolumeFormat());
    }
    params.setParentParameters(getParameters());
    return params;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<>();
    List<String> invalidIfaceNames = new ArrayList<>();
    Map<String, Network> networksInClusterByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getVdsGroupId()));
    List<VnicProfileView> vnicProfilesInDc = getDbFacade().getVnicProfileViewDao().getAllForDataCenter(getStoragePoolId());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.updateNicWithVnicProfile(iface, getVdsGroup().getcompatibility_version(), networksInClusterByName, vnicProfilesInDc, getCurrentUser().getUserId())) {
            markNicHasNoProfile(invalidNetworkNames, invalidIfaceNames, iface);
        }
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
private void endVmRelatedOps() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
}
#method_after
private void endVmRelatedOps() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.unLockVm(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
}
#end_block

#method_before
public VMStatus getStatus() {
    return this.vmDynamic.getStatus();
}
#method_after
@Override
public VMStatus getStatus() {
    return this.vmDynamic.getStatus();
}
#end_block

#method_before
public void setStatus(VMStatus value) {
    this.vmDynamic.setStatus(value);
}
#method_after
@Override
public void setStatus(VMStatus value) {
    this.vmDynamic.setStatus(value);
}
#end_block

#method_before
@Override
protected org.ovirt.engine.core.common.businessentities.VM getInverse(VmStatic to) {
    VmStatistics statistics = new VmStatistics();
    statistics.setcpu_user(new Double(10L));
    statistics.setcpu_sys(new Double(20L));
    VmDynamic dynamic = new VmDynamic();
    dynamic.setStatus(VMStatus.Up);
    dynamic.setBootSequence(to.getDefaultBootSequence());
    dynamic.setDisplayType(to.getDefaultDisplayType());
    org.ovirt.engine.core.common.businessentities.VM ret = new org.ovirt.engine.core.common.businessentities.VM(to, dynamic, statistics);
    ret.setUsageMemPercent(Integer.valueOf(50));
    return ret;
}
#method_after
@Override
protected org.ovirt.engine.core.common.businessentities.VM getInverse(VmStatic to) {
    VmStatistics statistics = new VmStatistics();
    statistics.setcpu_user(10.0);
    statistics.setcpu_sys(20.0);
    VmDynamic dynamic = new VmDynamic();
    dynamic.setStatus(VMStatus.Up);
    dynamic.setBootSequence(to.getDefaultBootSequence());
    dynamic.setDisplayType(to.getDefaultDisplayType());
    org.ovirt.engine.core.common.businessentities.VM ret = new org.ovirt.engine.core.common.businessentities.VM(to, dynamic, statistics);
    ret.setUsageMemPercent(50);
    return ret;
}
#end_block

#method_before
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    from.setTimezone("Australia/Darwin");
    return from;
}
#method_after
@Override
protected VM postPopulate(VM from) {
    from.setType(MappingTestHelper.shuffle(VmType.class).value());
    from.setOrigin(OriginType.VMWARE.name().toLowerCase());
    from.getDisplay().setType(MappingTestHelper.shuffle(DisplayType.class).value());
    from.getPayloads().getPayload().get(0).setType(MappingTestHelper.shuffle(VmDeviceType.class).value());
    for (Boot boot : from.getOs().getBoot()) {
        boot.setDev(MappingTestHelper.shuffle(BootDevice.class).value());
    }
    while (from.getCpu().getTopology().getSockets() == 0) {
        from.getCpu().getTopology().setSockets(MappingTestHelper.rand(100));
    }
    while (from.getCpu().getTopology().getCores() == 0) {
        from.getCpu().getTopology().setCores(MappingTestHelper.rand(100));
    }
    CpuTune cpuTune = new CpuTune();
    VCpuPin pin = new VCpuPin();
    pin.setVcpu(33);
    pin.setCpuSet("1-4,6");
    cpuTune.getVCpuPin().add(pin);
    from.getCpu().setCpuTune(cpuTune);
    from.setTimezone("Australia/Darwin");
    return from;
}
#end_block

#method_before
@Test
public void stringToCpuTune() {
    CpuTune cpuTune = VmMapper.stringToCpuTune("0#0");
    assertNotNull(cpuTune);
    assertNotNull(cpuTune.getVcpuPin());
    assertEquals(1, cpuTune.getVcpuPin().size());
    assertEquals(0, cpuTune.getVcpuPin().get(0).getVcpu());
    assertEquals("0", cpuTune.getVcpuPin().get(0).getCpuSet());
}
#method_after
@Test
public void stringToCpuTune() {
    CpuTune cpuTune = VmMapper.stringToCpuTune("0#0");
    assertNotNull(cpuTune);
    assertNotNull(cpuTune.getVCpuPin());
    assertEquals(1, cpuTune.getVCpuPin().size());
    assertEquals(0, cpuTune.getVCpuPin().get(0).getVcpu());
    assertEquals("0", cpuTune.getVCpuPin().get(0).getCpuSet());
}
#end_block

#method_before
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if (fqdn != null) {
            if (fqdn.toLowerCase().equals("localhost") || fqdn.toLowerCase().equals("localhost.localdomain")) {
                vm.setVmFQDN(null);
            } else {
                vm.setVmFQDN(fqdn);
            }
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
}
#method_after
public static void updateVMDynamicData(VmDynamic vm, Map<String, Object> xmlRpcStruct) {
    if (xmlRpcStruct.containsKey(VdsProperties.vm_guid)) {
        vm.setId(new Guid((String) xmlRpcStruct.get(VdsProperties.vm_guid)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.session)) {
        String session = (String) xmlRpcStruct.get(VdsProperties.session);
        try {
            vm.setSession(SessionState.valueOf(session));
        } catch (Exception e) {
            log.errorFormat("vm session value illegal : {0}", session);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.kvmEnable)) {
        vm.setKvmEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.kvmEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.acpiEnable)) {
        vm.setAcpiEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.acpiEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.win2kHackEnable)) {
        vm.setWin2kHackEnable(Boolean.parseBoolean((String) xmlRpcStruct.get(VdsProperties.win2kHackEnable)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.status)) {
        vm.setStatus(convertToVmStatus((String) xmlRpcStruct.get(VdsProperties.status)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_port)) {
        try {
            vm.setDisplay(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_port));
        }
    } else if (xmlRpcStruct.containsKey(VdsProperties.display)) {
        try {
            vm.setDisplay(VNC_START_PORT + Integer.parseInt(xmlRpcStruct.get(VdsProperties.display).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display value illegal : {0}", xmlRpcStruct.get(VdsProperties.display));
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.display_secure_port)) {
        try {
            vm.setDisplaySecurePort(Integer.parseInt(xmlRpcStruct.get(VdsProperties.display_secure_port).toString()));
        } catch (NumberFormatException e) {
            log.errorFormat("vm display_secure_port value illegal : {0}", xmlRpcStruct.get(VdsProperties.display_secure_port));
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayType))) {
        String displayType = xmlRpcStruct.get(VdsProperties.displayType).toString();
        try {
            vm.setDisplayType(DisplayType.valueOf(displayType));
        } catch (Exception e2) {
            log.errorFormat("vm display type value illegal : {0}", displayType);
        }
    }
    if (xmlRpcStruct.containsKey((VdsProperties.displayIp))) {
        vm.setDisplayIp((String) xmlRpcStruct.get(VdsProperties.displayIp));
    }
    if (xmlRpcStruct.containsKey((VdsProperties.utc_diff))) {
        String utc_diff = xmlRpcStruct.get(VdsProperties.utc_diff).toString();
        if (utc_diff.startsWith("+")) {
            utc_diff = utc_diff.substring(1);
        }
        try {
            vm.setUtcDiff(Integer.parseInt(utc_diff));
        } catch (NumberFormatException e) {
            log.errorFormat("vm offset (utc_diff) value illegal : {0}", utc_diff);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.hash)) {
        String hash = (String) xmlRpcStruct.get(VdsProperties.hash);
        try {
            vm.setHash(hash);
        } catch (Exception e) {
            log.errorFormat("vm hash value illegal : {0}", hash);
        }
    }
    /**
     * vm disks
     */
    if (xmlRpcStruct.containsKey(VdsProperties.vm_disks)) {
        initDisks(xmlRpcStruct, vm);
    }
    // ------------- vm internal agent data
    vm.setGuestLastLoginTime(AssignDateTImeFromEpoch(xmlRpcStruct, VdsProperties.guest_last_login_time));
    vm.setVmHost(AssignStringValue(xmlRpcStruct, VdsProperties.vm_host));
    String guestUserName = AssignStringValue(xmlRpcStruct, VdsProperties.guest_cur_user_name);
    vm.setGuestCurrentUserName(guestUserName);
    initAppsList(xmlRpcStruct, vm);
    vm.setGuestOs(AssignStringValue(xmlRpcStruct, VdsProperties.guest_os));
    if (xmlRpcStruct.containsKey(VdsProperties.VM_FQDN)) {
        vm.setVmFQDN(AssignStringValue(xmlRpcStruct, VdsProperties.VM_FQDN));
        String fqdn = vm.getVmFQDN().trim();
        if ("localhost".equalsIgnoreCase(fqdn) || "localhost.localdomain".equalsIgnoreCase(fqdn)) {
            vm.setVmFQDN(null);
        } else {
            vm.setVmFQDN(fqdn);
        }
    }
    vm.setVmIp(AssignStringValue(xmlRpcStruct, VdsProperties.VM_IP));
    if (vm.getVmIp() != null) {
        if (vm.getVmIp().startsWith("127.0.")) {
            vm.setVmIp(null);
        } else {
            vm.setVmIp(vm.getVmIp().trim());
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_code)) {
        String exitCodeStr = xmlRpcStruct.get(VdsProperties.exit_code).toString();
        vm.setExitStatus(VmExitStatus.forValue(Integer.parseInt(exitCodeStr)));
    }
    if (xmlRpcStruct.containsKey(VdsProperties.exit_message)) {
        String exitMsg = (String) xmlRpcStruct.get(VdsProperties.exit_message);
        vm.setExitMessage(exitMsg);
    }
    // if monitorResponse returns negative it means its erroneous
    if (xmlRpcStruct.containsKey(VdsProperties.monitorResponse)) {
        int response = Integer.parseInt(xmlRpcStruct.get(VdsProperties.monitorResponse).toString());
        if (response < 0) {
            vm.setStatus(VMStatus.NotResponding);
        }
    }
    if (xmlRpcStruct.containsKey(VdsProperties.clientIp)) {
        vm.setClientIp(xmlRpcStruct.get(VdsProperties.clientIp).toString());
    }
    VmPauseStatus pauseStatus = VmPauseStatus.NONE;
    if (xmlRpcStruct.containsKey(VdsProperties.pauseCode)) {
        String pauseCodeStr = (String) xmlRpcStruct.get(VdsProperties.pauseCode);
        try {
            pauseStatus = VmPauseStatus.valueOf(pauseCodeStr);
        } catch (IllegalArgumentException ex) {
            log.error("Error in parsing vm pause status. Setting value to NONE");
            pauseStatus = VmPauseStatus.NONE;
        }
    }
    vm.setPauseStatus(pauseStatus);
    if (xmlRpcStruct.containsKey(VdsProperties.watchdogEvent)) {
        Map<String, Object> watchdogStruct = (Map<String, Object>) xmlRpcStruct.get(VdsProperties.watchdogEvent);
        double time = Double.parseDouble(watchdogStruct.get(VdsProperties.time).toString());
        // vdsm may not send the action http://gerrit.ovirt.org/14134
        String action = watchdogStruct.containsKey(VdsProperties.action) ? watchdogStruct.get(VdsProperties.action).toString() : null;
        vm.setLastWatchdogEvent((long) time);
        vm.setLastWatchdogAction(action);
    }
}
#end_block

#method_before
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, Network network, VDS vds) {
    if (interfaces.size() != 1) {
        AuditLogableBase logable = new AuditLogableBase(vds.getId());
        logable.addCustomValue("NetworkName", network.getName());
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        AuditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#method_after
private static void reportInvalidInterfacesForNetwork(List<VdsNetworkInterface> interfaces, Network network, VDS vds) {
    if (interfaces.isEmpty()) {
        AuditLogDirector.log(createHostNetworkAuditLog(network, vds), AuditLogType.NETWORK_WITHOUT_INTERFACES);
    } else if (interfaces.size() > 1) {
        AuditLogableBase logable = createHostNetworkAuditLog(network, vds);
        logable.addCustomValue("Interfaces", StringUtils.join(Entities.objectNames(interfaces), ","));
        AuditLogDirector.log(logable, AuditLogType.BRIDGED_NETWORK_OVER_MULTIPLE_INTERFACES);
    }
}
#end_block

#method_before
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Integer> currVlans, Map<String, Integer> networkVlans, Map<String, Object> network, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        if (currVlans.containsKey(iface.getName())) {
            networkVlans.put(net.getName(), currVlans.get(iface.getName()));
        }
        // set the management ip
        if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        boolean bridgedNetwork = isBridgedNetwork(network);
        iface.setBridged(bridgedNetwork);
        setGatewayIfManagementNetwork(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
    }
}
#method_after
private static void updateNetworkDetailsInInterface(VdsNetworkInterface iface, Map<String, Integer> currVlans, Map<String, Integer> networkVlans, Map<String, Object> network, VDS host, Network net) {
    if (iface != null) {
        iface.setNetworkName(net.getName());
        if (currVlans.containsKey(iface.getName())) {
            networkVlans.put(net.getName(), currVlans.get(iface.getName()));
        }
        // set the management ip
        if (StringUtils.equals(iface.getNetworkName(), NetworkUtils.getEngineNetwork())) {
            iface.setType(iface.getType() | VdsInterfaceType.MANAGEMENT.getValue());
        }
        iface.setAddress(net.getAddr());
        iface.setSubnet(net.getSubnet());
        boolean bridgedNetwork = isBridgedNetwork(network);
        iface.setBridged(bridgedNetwork);
        setGatewayIfNecessary(iface, host, net.getGateway());
        if (bridgedNetwork) {
            Map<String, Object> networkConfig = (Map<String, Object>) network.get("cfg");
            addBootProtocol(networkConfig, host, iface);
        }
    }
}
#end_block

#method_before
private static void addBootProtocol(Map<String, Object> cfg, VDS host, VdsNetworkInterface iface) {
    NetworkBootProtocol bootproto = NetworkBootProtocol.NONE;
    if (cfg != null) {
        String bootProtocol = (String) cfg.get("BOOTPROTO");
        if (bootProtocol != null) {
            if (bootProtocol.toLowerCase().equals("dhcp")) {
                bootproto = NetworkBootProtocol.DHCP;
            } else if (bootProtocol.toLowerCase().equals("none") || bootProtocol.toLowerCase().equals("static")) {
                if (StringUtils.isNotEmpty((String) cfg.get("IPADDR"))) {
                    bootproto = NetworkBootProtocol.STATIC_IP;
                }
            }
        } else if (StringUtils.isNotEmpty((String) cfg.get("IPADDR"))) {
            bootproto = NetworkBootProtocol.STATIC_IP;
        }
        if (bootproto == NetworkBootProtocol.STATIC_IP) {
            String gateway = (String) cfg.get(VdsProperties.GATEWAY);
            if (StringUtils.isNotEmpty(gateway)) {
                setGatewayIfManagementNetwork(iface, host, gateway.toString());
            }
        }
    }
    iface.setBootProtocol(bootproto);
}
#method_after
private static void addBootProtocol(Map<String, Object> cfg, VDS host, VdsNetworkInterface iface) {
    NetworkBootProtocol bootproto = NetworkBootProtocol.NONE;
    if (cfg != null) {
        String bootProtocol = (String) cfg.get("BOOTPROTO");
        if (bootProtocol != null) {
            if (bootProtocol.toLowerCase().equals("dhcp")) {
                bootproto = NetworkBootProtocol.DHCP;
            } else if (bootProtocol.toLowerCase().equals("none") || bootProtocol.toLowerCase().equals("static")) {
                if (StringUtils.isNotEmpty((String) cfg.get("IPADDR"))) {
                    bootproto = NetworkBootProtocol.STATIC_IP;
                }
            }
        } else if (StringUtils.isNotEmpty((String) cfg.get("IPADDR"))) {
            bootproto = NetworkBootProtocol.STATIC_IP;
        }
        if (bootproto == NetworkBootProtocol.STATIC_IP) {
            String gateway = (String) cfg.get(VdsProperties.GATEWAY);
            if (StringUtils.isNotEmpty(gateway)) {
                setGatewayIfNecessary(iface, host, gateway.toString());
            }
        }
    }
    iface.setBootProtocol(bootproto);
}
#end_block

#method_before
private static <T extends VmBase> void addOtherDevices(T entity, List<VmDevice> vmDeviceToAdd) {
    boolean hasCD = false;
    boolean hasSoundCard = false;
    for (VmDevice vmDevice : entity.getManagedDeviceMap().values()) {
        if (isDiskOrInterface(vmDevice)) {
            // skip disks/interfaces that were added separately.
            continue;
        }
        vmDevice.setIsManaged(true);
        if (vmDevice.getType() == VmDeviceGeneralType.VIDEO) {
            vmDevice.setSpecParams(getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()));
        }
        if (vmDevice.getDevice().equals(VmDeviceType.CDROM.getName())) {
            hasCD = true;
        }
        if (vmDevice.getDevice().equals(VmDeviceType.SOUND.getName())) {
            hasSoundCard = true;
        }
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCD) {
        // add an empty CD
        addEmptyCD(entity.getId());
    }
    // add sound card for desktops imported from old versions only, since devices didnt exist
    Version ovfVer = new Version(entity.getOvfVersion());
    if (!hasSoundCard && VmDeviceCommonUtils.isOldClusterVersion(ovfVer) && entity.getVmType() == VmType.Desktop) {
        addSoundCard(entity);
    }
    for (VmDevice vmDevice : entity.getUnmanagedDeviceList()) {
        vmDeviceToAdd.add(vmDevice);
    }
}
#method_after
private static <T extends VmBase> void addOtherDevices(T entity, List<VmDevice> vmDeviceToAdd) {
    boolean hasCD = false;
    boolean hasSoundCard = false;
    for (VmDevice vmDevice : entity.getManagedDeviceMap().values()) {
        if (isDiskOrInterface(vmDevice)) {
            // skip disks/interfaces that were added separately.
            continue;
        }
        vmDevice.setIsManaged(true);
        if (vmDevice.getType() == VmDeviceGeneralType.VIDEO) {
            vmDevice.setSpecParams(getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()));
        }
        if (vmDevice.getDevice().equals(VmDeviceType.CDROM.getName())) {
            hasCD = true;
        }
        if (VmDeviceCommonUtils.isSound(vmDevice)) {
            hasSoundCard = true;
        }
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCD) {
        // add an empty CD
        addEmptyCD(entity.getId());
    }
    // add sound card for desktops imported from old versions only, since devices didnt exist
    Version ovfVer = new Version(entity.getOvfVersion());
    if (!hasSoundCard && VmDeviceCommonUtils.isOldClusterVersion(ovfVer) && entity.getVmType() == VmType.Desktop) {
        addSoundCard(entity);
    }
    for (VmDevice vmDevice : entity.getUnmanagedDeviceList()) {
        vmDeviceToAdd.add(vmDevice);
    }
}
#end_block

#method_before
@Override
protected void executeCommand() {
    Guid storagePoolId = (getDiskImage().getStoragePoolId() != null) ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid storageDomainId = !CollectionUtils.isEmpty(getDiskImage().getStorageIds()) ? getDiskImage().getStorageIds().get(0) : Guid.Empty;
    VDSReturnValue vdsReturnValue = mergeSnapshots(storagePoolId, storageDomainId);
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(vdsReturnValue, storageDomainId));
        setSucceeded(vdsReturnValue.getSucceeded());
    } else {
        setSucceeded(false);
    }
}
#method_after
@Override
protected void executeCommand() {
    Guid storagePoolId = (getDiskImage().getStoragePoolId() != null) ? getDiskImage().getStoragePoolId() : Guid.Empty;
    Guid storageDomainId = !CollectionUtils.isEmpty(getDiskImage().getStorageIds()) ? getDiskImage().getStorageIds().get(0) : Guid.Empty;
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.RemoveSnapshot);
    VDSReturnValue vdsReturnValue = mergeSnapshots(storagePoolId, storageDomainId);
    if (vdsReturnValue != null && vdsReturnValue.getCreationInfo() != null) {
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue, storageDomainId));
        setSucceeded(vdsReturnValue.getSucceeded());
    } else {
        setSucceeded(false);
    }
}
#end_block

#method_before
private Guid createTask(VDSReturnValue vdsReturnValue, Guid storageDomainId) {
    Guid taskId = persistAsyncTaskPlaceHolder(VdcActionType.RemoveSnapshot);
    String message = ExecutionMessageDirector.resolveStepMessage(StepEnum.MERGE_SNAPSHOTS, getJobMessageProperties());
    return super.createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.RemoveSnapshot, message, VdcObjectType.Storage, storageDomainId);
}
#method_after
private Guid createTask(Guid taskId, VDSReturnValue vdsReturnValue, Guid storageDomainId) {
    String message = ExecutionMessageDirector.resolveStepMessage(StepEnum.MERGE_SNAPSHOTS, getJobMessageProperties());
    return super.createTask(taskId, vdsReturnValue.getCreationInfo(), VdcActionType.RemoveSnapshot, message, VdcObjectType.Storage, storageDomainId);
}
#end_block

#method_before
public static List<Guid> fetchDomainsReportedAsProblematic(Guid storagePoolId, List<VDSDomainsData> vdsDomainsData) {
    IrsProxyData proxy = _irsProxyData.get(storagePoolId);
    if (proxy != null) {
        return proxy.getDomainsReportedAsProblematic(vdsDomainsData);
    }
    return Collections.emptyList();
}
#method_after
public static List<Guid> fetchDomainsReportedAsProblematic(Guid storagePoolId, List<VDSDomainsData> vdsDomainsData) {
    IrsProxyData proxy = _irsProxyData.get(storagePoolId);
    if (proxy != null) {
        return proxy.obtainDomainsReportedAsProblematic(vdsDomainsData);
    }
    return Collections.emptyList();
}
#end_block

#method_before
protected void listenOnManualRefresh() {
    final AbstractRefreshManager<T> manager = this;
    refreshPanel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (manualRefreshCallback != null) {
                manualRefreshCallback.onManualRefresh();
            }
            ManualRefreshEvent.fire(manager);
            controller.refresh();
        }
    });
}
#method_after
protected void listenOnManualRefresh() {
    refreshPanel.addClickHandler(new ClickHandler() {

        @Override
        public void onClick(ClickEvent event) {
            if (manualRefreshCallback != null) {
                manualRefreshCallback.onManualRefresh();
            }
            ManualRefreshEvent.fire(AbstractRefreshManager.this);
            controller.refresh();
        }
    });
}
#end_block

#method_before
@Override
protected boolean canAddDomain() {
    // !AddSANStorageDomainParametersValue.IsExistingStorageDomain &&
    if (((getParameters().getLunIds() == null || getParameters().getLunIds().isEmpty()) && StringUtils.isEmpty(getStorageDomain().getStorage()))) {
        return failCanDoAction(VdcBllMessages.ERROR_CANNOT_CREATE_STORAGE_DOMAIN_WITHOUT_VG_LV);
    }
    if (isLunsAlreadyPartOfStorageDomains(getParameters().getLunIds())) {
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canAddDomain() {
    // !AddSANStorageDomainParametersValue.IsExistingStorageDomain &&
    if (((getParameters().getLunIds() == null || getParameters().getLunIds().isEmpty()) && StringUtils.isEmpty(getStorageDomain().getStorage()))) {
        return failCanDoAction(VdcBllMessages.ERROR_CANNOT_CREATE_STORAGE_DOMAIN_WITHOUT_VG_LV);
    }
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    return true;
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
protected boolean canDoAction() {
    super.canDoAction();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EXTEND);
    if (isLunsAlreadyPartOfStorageDomains(getParameters().getLunIds())) {
        return false;
    }
    boolean returnValue = checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active);
    if (returnValue && (getStorageDomain().getStorageType() == StorageType.NFS || getStorageDomain().getStorageType() == StorageType.UNKNOWN)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        returnValue = false;
    } else {
        final ConnectAllHostsToLunCommandReturnValue connectResult = (ConnectAllHostsToLunCommandReturnValue) Backend.getInstance().runInternalAction(VdcActionType.ConnectAllHostsToLun, new ExtendSANStorageDomainParameters(getParameters().getStorageDomainId(), getParameters().getLunIds()));
        if (!connectResult.getSucceeded()) {
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_EXTEND_CONNECTION_FAILED);
            if (connectResult.getFailedVds() != null) {
                getReturnValue().getCanDoActionMessages().add(String.format("$hostName %1s", connectResult.getFailedVds().getName()));
            }
            String lunId = connectResult.getFailedLun() != null ? connectResult.getFailedLun().getLUN_id() : "";
            getReturnValue().getCanDoActionMessages().add(String.format("$lun %1s", lunId));
            returnValue = false;
        } else {
            // use luns list from connect command
            getParameters().setLunsList((ArrayList<LUNs>) connectResult.getActionReturnValue());
        }
    }
    return returnValue;
}
#method_after
@SuppressWarnings("unchecked")
@Override
protected boolean canDoAction() {
    super.canDoAction();
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__EXTEND);
    if (isLunsAlreadyInUse(getParameters().getLunIds())) {
        return false;
    }
    boolean returnValue = checkStorageDomain() && checkStorageDomainStatus(StorageDomainStatus.Active);
    if (returnValue && (getStorageDomain().getStorageType() == StorageType.NFS || getStorageDomain().getStorageType() == StorageType.UNKNOWN)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        returnValue = false;
    } else {
        final ConnectAllHostsToLunCommandReturnValue connectResult = (ConnectAllHostsToLunCommandReturnValue) Backend.getInstance().runInternalAction(VdcActionType.ConnectAllHostsToLun, new ExtendSANStorageDomainParameters(getParameters().getStorageDomainId(), getParameters().getLunIds()));
        if (!connectResult.getSucceeded()) {
            addCanDoActionMessage(VdcBllMessages.ERROR_CANNOT_EXTEND_CONNECTION_FAILED);
            if (connectResult.getFailedVds() != null) {
                getReturnValue().getCanDoActionMessages().add(String.format("$hostName %1s", connectResult.getFailedVds().getName()));
            }
            String lunId = connectResult.getFailedLun() != null ? connectResult.getFailedLun().getLUN_id() : "";
            getReturnValue().getCanDoActionMessages().add(String.format("$lun %1s", lunId));
            returnValue = false;
        } else {
            // use luns list from connect command
            getParameters().setLunsList((ArrayList<LUNs>) connectResult.getActionReturnValue());
        }
    }
    return returnValue;
}
#end_block

#method_before
@Test
public void lunAlreadyPartOfStorageDomains() {
    LUNs lun1 = new LUNs();
    lun1.setLUN_id(GUIDS[0].toString());
    lun1.setStorageDomainId(Guid.newGuid());
    LUNs lun2 = new LUNs();
    lun2.setLUN_id(GUIDS[1].toString());
    lun2.setStorageDomainId(Guid.newGuid());
    doReturn(lunDAO).when(cmd).getLunDao();
    when(lunDAO.getAll()).thenReturn(Arrays.asList(lun1, lun2));
    List<String> specifiedLunIds = Collections.singletonList(GUIDS[0].toString());
    assertTrue(cmd.isLunsAlreadyPartOfStorageDomains(specifiedLunIds));
    List<String> messages = cmd.getReturnValue().getCanDoActionMessages();
    assertEquals(messages.size(), 2);
    assertEquals(messages.get(0), VdcBllMessages.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS.toString());
    assertEquals(messages.get(1), String.format("$lunIds %1$s", specifiedLunIds.get(0)));
}
#method_after
@Test
public void lunAlreadyPartOfStorageDomains() {
    LUNs lun1 = new LUNs();
    lun1.setLUN_id(GUIDS[0].toString());
    lun1.setStorageDomainId(Guid.newGuid());
    LUNs lun2 = new LUNs();
    lun2.setLUN_id(GUIDS[1].toString());
    lun2.setStorageDomainId(Guid.newGuid());
    doReturn(lunDAO).when(cmd).getLunDao();
    when(lunDAO.getAll()).thenReturn(Arrays.asList(lun1, lun2));
    List<String> specifiedLunIds = Collections.singletonList(GUIDS[0].toString());
    assertTrue(cmd.isLunsAlreadyInUse(specifiedLunIds));
    List<String> messages = cmd.getReturnValue().getCanDoActionMessages();
    assertEquals(messages.size(), 2);
    assertEquals(messages.get(0), VdcBllMessages.ACTION_TYPE_FAILED_LUNS_ALREADY_PART_OF_STORAGE_DOMAINS.toString());
    assertEquals(messages.get(1), String.format("$lunIds %1$s", cmd.getFormattedLunId(lun1, lun1.getStorageDomainName())));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        try {
            Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
            VDSReturnValue vdsReturnValue = performImageVdsmOperation();
            getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getStorageDomainId()));
        } catch (VdcBLLException e) {
            if (e.getErrorCode() == VdcBllErrors.ImageDoesNotExistInDomainError) {
                log.warnFormat("The image group with id {0} wasn't actually deleted from the storage domain {1} " + "because it didn't exist in it", getDiskImage().getId(), getStorageDomainId());
            } else // so technically the image doesn't exist after renaming but the actual delete can still fail.
            if (isImageRemovedFromStorage()) {
                log.infoFormat("The image group with id {0} was deleted from storage");
            } else {
                throw e;
            }
        }
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport) {
            performImageDbOperations();
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    if (getDiskImage() != null) {
        try {
            Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
            VDSReturnValue vdsReturnValue = performImageVdsmOperation();
            getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Storage, getStorageDomainId()));
        } catch (VdcBLLException e) {
            if (e.getErrorCode() == VdcBllErrors.ImageDoesNotExistInDomainError) {
                log.infoFormat("Disk '{0}' doesn't exist on storage domain '{1}', rolling forward", getDiskImage().getId(), getStorageDomainId());
            } else // In this case, Engine has to check whether image still exists on the storage or not.
            if (e.getErrorCode() == VdcBllErrors.ImageDeleteError && isImageRemovedFromStorage()) {
                log.infoFormat("Disk '{0}' was deleted from storage domain '{1}'", getDiskImage().getId(), getStorageDomainId());
            } else {
                throw e;
            }
        }
        if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport) {
            performImageDbOperations();
        }
    } else {
        log.warn("DiskImage is null, nothing to remove");
    }
    setSucceeded(true);
}
#end_block

#method_before
protected boolean isImageRemovedFromStorage() {
    VDSReturnValue retValue = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getDiskImage().getStoragePoolId()));
    if (retValue.getSucceeded()) {
        List<Guid> ids = (List<Guid>) retValue.getReturnValue();
        for (Guid id : ids) {
            if (id.equals(getDiskImage().getId())) {
                return false;
            }
        }
        return true;
    } else {
        log.warnFormat("Failed to retrieve list of images from storage domain '" + getStorageDomainId() + "', " + "therefore there is no proof that image was deleted!");
        return false;
    }
}
#method_after
protected boolean isImageRemovedFromStorage() {
    VDSReturnValue retValue = getBackend().getResourceManager().RunVdsCommand(VDSCommandType.GetImagesList, new GetImagesListVDSCommandParameters(getStorageDomainId(), getDiskImage().getStoragePoolId()));
    if (retValue.getSucceeded()) {
        List<Guid> ids = (List<Guid>) retValue.getReturnValue();
        for (Guid id : ids) {
            if (id.equals(getDiskImage().getId())) {
                return false;
            }
        }
        return true;
    } else {
        log.warnFormat("Could not retrieve image list from storage domain '{0}' '{1}', disk '{2}' might " + "not have been deleted", getStorageDomainId(), getStorageDomain().getName(), getDiskImage().getId());
        return false;
    }
}
#end_block

#method_before
private static <T extends VmBase> void addOtherDevices(T entity, List<VmDevice> vmDeviceToAdd) {
    boolean hasCD = false;
    boolean hasSoundCard = false;
    for (VmDevice vmDevice : entity.getManagedDeviceMap().values()) {
        if (isDiskOrInterface(vmDevice)) {
            // skip disks/interfaces that were added separately.
            continue;
        }
        vmDevice.setIsManaged(true);
        if (vmDevice.getType() == VmDeviceGeneralType.VIDEO) {
            vmDevice.setSpecParams(getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()));
        }
        if (vmDevice.getDevice().equals(VmDeviceType.CDROM.getName())) {
            hasCD = true;
        }
        if (vmDevice.getType() == VmDeviceGeneralType.SOUND) {
            hasSoundCard = true;
        }
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCD) {
        // add an empty CD
        addEmptyCD(entity.getId());
    }
    // add sound card for desktops imported from old versions only, since devices didnt exist
    Version ovfVer = new Version(entity.getOvfVersion());
    if (!hasSoundCard && VmDeviceCommonUtils.isOldClusterVersion(ovfVer) && entity.getVmType() == VmType.Desktop) {
        addSoundCard(entity);
    }
    for (VmDevice vmDevice : entity.getUnmanagedDeviceList()) {
        vmDeviceToAdd.add(vmDevice);
    }
}
#method_after
private static <T extends VmBase> void addOtherDevices(T entity, List<VmDevice> vmDeviceToAdd) {
    boolean hasCD = false;
    boolean hasSoundCard = false;
    for (VmDevice vmDevice : entity.getManagedDeviceMap().values()) {
        if (isDiskOrInterface(vmDevice)) {
            // skip disks/interfaces that were added separately.
            continue;
        }
        vmDevice.setIsManaged(true);
        if (vmDevice.getType() == VmDeviceGeneralType.VIDEO) {
            vmDevice.setSpecParams(getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()));
        }
        if (vmDevice.getDevice().equals(VmDeviceType.CDROM.getName())) {
            hasCD = true;
        }
        if (VmDeviceCommonUtils.isSound(vmDevice)) {
            hasSoundCard = true;
        }
        vmDeviceToAdd.add(vmDevice);
    }
    if (!hasCD) {
        // add an empty CD
        addEmptyCD(entity.getId());
    }
    // add sound card for desktops imported from old versions only, since devices didnt exist
    Version ovfVer = new Version(entity.getOvfVersion());
    if (!hasSoundCard && VmDeviceCommonUtils.isOldClusterVersion(ovfVer) && entity.getVmType() == VmType.Desktop) {
        addSoundCard(entity);
    }
    for (VmDevice vmDevice : entity.getUnmanagedDeviceList()) {
        vmDeviceToAdd.add(vmDevice);
    }
}
#end_block

#method_before
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        List<GlusterVolumeEntity> list = Linq.<GlusterVolumeEntity>cast(getSelectedItems());
        for (GlusterVolumeEntity volume : list) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            GlusterAsyncTask asyncTask = volume.getAsyncTask();
            if (asyncTask != null) {
                allowStartRebalance = allowStartRebalance && asyncTask.getStatus() != JobExecutionStatus.STARTED;
            }
        }
        if (list.size() == 1) {
            GlusterVolumeEntity volumeEntity = list.get(0);
            GlusterAsyncTask asyncTask = volumeEntity.getAsyncTask();
            allowStopRebalance = volumeEntity.getStatus() == GlusterStatus.UP && asyncTask != null && asyncTask.getType() == GlusterTaskType.REBALANCE && asyncTask.getStatus() == JobExecutionStatus.STARTED;
        } else {
            allowStopRebalance = false;
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
                allowStopRebalance = false;
            }
            allowStartRebalance = allowStartRebalance && (volume.getAsyncTask() == null || Guid.isNullOrEmpty(volume.getAsyncTask().getTaskId()));
            allowStopRebalance = allowStopRebalance && (volume.getAsyncTask() != null && volume.getAsyncTask().getStatus() != null && volume.getAsyncTask().getStatus() == JobExecutionStatus.STARTED);
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
public void showStatus(GlusterVolumeTaskStatusEntity rebalanceStatusEntity) {
    List<GlusterVolumeTaskStatusForHost> rebalanceSessionsList = rebalanceStatusEntity.getHostwiseStatusDetails();
    List<EntityModel> sessionList = new ArrayList<EntityModel>();
    for (GlusterVolumeTaskStatusForHost hostDetail : rebalanceSessionsList) {
        EntityModel sessionModel = new EntityModel(hostDetail);
        sessionList.add(sessionModel);
    }
    getStartedTime().setEntity(rebalanceStatusEntity.getStartTime() == null ? ConstantsManager.getInstance().getConstants().notAvailableLabel() : rebalanceStatusEntity.getStartTime());
    getStatusTime().setEntity(rebalanceStatusEntity.getStatusTime() == null ? ConstantsManager.getInstance().getConstants().notAvailableLabel() : rebalanceStatusEntity.getStatusTime());
    getRebalanceSessions().setItems(sessionList);
    if (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FINISHED) {
        setStatusAvailable(true);
    } else {
        setStatusAvailable(false);
        if (!(rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.ABORTED || rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FAILED)) {
            refresh(getEntity());
        }
    }
}
#method_after
public void showStatus(GlusterVolumeTaskStatusEntity rebalanceStatusEntity) {
    List<GlusterVolumeTaskStatusForHost> rebalanceSessionsList = rebalanceStatusEntity.getHostwiseStatusDetails();
    List<EntityModel> sessionList = new ArrayList<EntityModel>();
    for (GlusterVolumeTaskStatusForHost hostDetail : rebalanceSessionsList) {
        EntityModel sessionModel = new EntityModel(hostDetail);
        sessionList.add(sessionModel);
    }
    getStartedTime().setEntity(rebalanceStatusEntity.getStartTime() == null ? ConstantsManager.getInstance().getConstants().notAvailableLabel() : rebalanceStatusEntity.getStartTime());
    getStatusTime().setEntity(rebalanceStatusEntity.getStatusTime() == null ? ConstantsManager.getInstance().getConstants().notAvailableLabel() : rebalanceStatusEntity.getStatusTime());
    getRebalanceSessions().setItems(sessionList);
    if (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FINISHED) {
        setStatusAvailable(true);
        refresh.cancel();
    } else {
        setStatusAvailable(false);
        if ((rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.ABORTED || rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.FAILED)) {
            refresh.cancel();
        }
    }
}
#end_block

#method_before
public void cancelRefresh() {
    if (refresh == null) {
        return;
    } else {
        refresh.cancel();
    }
}
#method_after
public void cancelRefresh() {
    if (refresh != null) {
        refresh.cancel();
    }
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    DiskImage diskImage = null;
    try {
        diskImage = getDiskImage();
    } catch (OpenStackImageException e) {
        log.errorFormat("Unable to get the disk image from the provider proxy: {0}", e.getMessage());
        switch(e.getErrorType()) {
            case UNSUPPORTED_CONTAINER_FORMAT:
            case UNSUPPORTED_DISK_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_NOT_SUPPORTED);
            case UNABLE_TO_DOWNLOAD_IMAGE:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_DOWNLOAD_ERROR);
            case UNRECOGNIZED_IMAGE_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_UNRECOGNIZED);
        }
    }
    if (diskImage == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    DiskImage diskImage = null;
    try {
        diskImage = getDiskImage();
    } catch (OpenStackImageException e) {
        log.errorFormat("Unable to get the disk image from the provider proxy: {0} ({1})", e.getMessage(), e.getErrorType());
        switch(e.getErrorType()) {
            case UNSUPPORTED_CONTAINER_FORMAT:
            case UNSUPPORTED_DISK_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_NOT_SUPPORTED);
            case UNABLE_TO_DOWNLOAD_IMAGE:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_DOWNLOAD_ERROR);
            case UNRECOGNIZED_IMAGE_FORMAT:
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_UNRECOGNIZED);
        }
    }
    if (diskImage == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    return true;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    return isVmExist() && isVmInUpPausedDownStatus() && canRunActionOnNonManagedVm() && isDiskExist(disk) && checkCanPerformPlugUnPlugDisk() && isVmNotInPreviewSnapshot() && imageStorageValidation();
}
#method_after
@Override
protected boolean canDoAction() {
    return isVmExist() && isVmInUpPausedDownStatus() && canRunActionOnNonManagedVm() && isDiskExist(getDisk()) && checkCanPerformPlugUnPlugDisk() && isVmNotInPreviewSnapshot() && imageStorageValidation();
}
#end_block

#method_before
private boolean imageStorageValidation() {
    // so we don't need to check the storage domain activity.
    if (disk.getDiskStorageType() != DiskStorageType.IMAGE || !getVm().getStatus().isRunningOrPaused()) {
        return true;
    }
    DiskImage diskImage = (DiskImage) disk;
    StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(diskImage.getStorageIds().get(0), diskImage.getStoragePoolId());
    StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
    return validate(storageDomainValidator.isDomainExistAndActive());
}
#method_after
private boolean imageStorageValidation() {
    // so we don't need to check the storage domain activity.
    if (getDisk().getDiskStorageType() != DiskStorageType.IMAGE || !getVm().getStatus().isRunningOrPaused()) {
        return true;
    }
    DiskImage diskImage = (DiskImage) getDisk();
    StorageDomain storageDomain = getStorageDomainDAO().getForStoragePool(diskImage.getStorageIds().get(0), diskImage.getStoragePoolId());
    StorageDomainValidator storageDomainValidator = getStorageDomainValidator(storageDomain);
    return validate(storageDomainValidator.isDomainExistAndActive());
}
#end_block

#method_before
private boolean checkCanPerformPlugUnPlugDisk() {
    if (getVm().getStatus().isUpOrPaused()) {
        setVdsId(getVm().getRunOnVds());
        if (!isHotPlugSupported() || !isOsSupportingHotPlug() || !isInterfaceSupportedForPlugUnPlug(disk)) {
            return false;
        }
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(disk.getId(), getVmId()));
    if (getPlugAction() == VDSCommandType.HotPlugDisk && oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
    }
    if (getPlugAction() == VDSCommandType.HotUnPlugDisk && !oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
    }
    return true;
}
#method_after
private boolean checkCanPerformPlugUnPlugDisk() {
    if (getVm().getStatus().isUpOrPaused()) {
        setVdsId(getVm().getRunOnVds());
        if (!canPerformHotPlug() || !isInterfaceSupportedForPlugUnPlug(disk)) {
            return false;
        }
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(getDisk().getId(), getVmId()));
    if (getPlugAction() == VDSCommandType.HotPlugDisk && oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
    }
    if (getPlugAction() == VDSCommandType.HotUnPlugDisk && !oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (getVm().getStatus().isUpOrPaused()) {
        performPlugCommand(getPlugAction(), disk, oldVmDevice);
    }
    final VmDevice device = getVmDeviceDao().get(oldVmDevice.getId());
    device.setIsPlugged(!oldVmDevice.getIsPlugged());
    final List<VmDevice> devices = VmDeviceUtils.updateBootOrderInVmDevice(getVm().getStaticData());
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            getVmStaticDAO().incrementDbGeneration(getVm().getId());
            getVmDeviceDao().updateAll("UpdateVmDeviceForHotPlugDisk", Arrays.asList(device));
            getVmDeviceDao().updateAll("UpdateVmDeviceBootOrder", devices);
            return null;
        }
    });
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    if (getVm().getStatus().isUpOrPaused()) {
        performPlugCommand(getPlugAction(), getDisk(), oldVmDevice);
    }
    // At this point disk is already plugged to or unplugged from VM (depends on the command),
    // so device's 'isPlugged' property should be updated accordingly in DB
    updateDeviceIsPluggedProperty();
    // device is already plugged to or unplugged from VM.
    if (disk.isBoot()) {
        updateBootOrder();
    }
    getVmStaticDAO().incrementDbGeneration(getVm().getId());
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> exclusiveLock = new HashMap<>();
    exclusiveLock.put(disk.getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED));
    return exclusiveLock;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    Map<String, Pair<String, String>> exclusiveLock = new HashMap<>();
    exclusiveLock.put(getDisk().getId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.DISK, VdcBllMessages.ACTION_TYPE_FAILED_DISKS_LOCKED));
    if (getDisk().isBoot()) {
        exclusiveLock.put(getVmId().toString(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_DISK_BOOT, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return exclusiveLock;
}
#end_block

#method_before
private boolean checkCanPerformPlugUnPlugDisk() {
    if (getVm().getStatus().isUpOrPaused()) {
        setVdsId(getVm().getRunOnVds());
        if (!isHotPlugSupported() || !isOsSupportingHotPlug() || !isInterfaceSupportedForPlugUnPlug(disk)) {
            return false;
        }
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(disk.getId(), getVmId()));
    if (getPlugAction() == VDSCommandType.HotPlugDisk && oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
    }
    if (getPlugAction() == VDSCommandType.HotUnPlugDisk && !oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
    }
    return true;
}
#method_after
private boolean checkCanPerformPlugUnPlugDisk() {
    if (getVm().getStatus().isUpOrPaused()) {
        setVdsId(getVm().getRunOnVds());
        if (!canPerformHotPlug() || !isInterfaceSupportedForPlugUnPlug(disk)) {
            return false;
        }
    }
    oldVmDevice = getVmDeviceDao().get(new VmDeviceId(disk.getId(), getVmId()));
    if (getPlugAction() == VDSCommandType.HotPlugDisk && oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_UNPLUGGED);
    }
    if (getPlugAction() == VDSCommandType.HotUnPlugDisk && !oldVmDevice.getIsPlugged()) {
        return failCanDoAction(VdcBllMessages.HOT_UNPLUG_DISK_IS_NOT_PLUGGED);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    lockImage();
    VDSReturnValue vdsReturnValue = null;
    Guid sourceDomainId = getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId().getValue() : getDiskImage().getStorageIds().get(0);
    if (getParameters().getUseCopyCollapse()) {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(getStorageDomain().getStoragePoolId().getValue(), sourceDomainId, getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getParameters().getVolumeFormat(), getParameters().getVolumeType(), isWipeAfterDelete(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    } else {
        vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, new MoveImageGroupVDSCommandParameters(getDiskImage().getStoragePoolId().getValue(), sourceDomainId, getDiskImage().getId(), getParameters().getStorageDomainId(), getParameters().getContainerId(), ImageOperation.Copy, isWipeAfterDelete(), getParameters().getForceOverride(), getStoragePool().getcompatibility_version().toString()));
    }
    if (vdsReturnValue.getSucceeded()) {
        AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
        getReturnValue().getInternalTaskIdList().add(createTask(taskCreationInfo, getParameters().getParentCommand(), VdcObjectType.Storage, sourceDomainId, getParameters().getStorageDomainId()));
        // Add storage domain in db only if there is new entity in DB.
        if (!shouldUpdateStorageDisk() && getParameters().getAddImageDomainMapping()) {
            getImageStorageDomainMapDao().save(new image_storage_domain_map(getParameters().getImageId(), getParameters().getStorageDomainId()));
        }
        // update quota
        if (getParameters().getQuotaId() != null) {
            getImageDao().updateQuotaForImageAndSnapshots(getParameters().getDestImageGroupId(), getParameters().getQuotaId());
        }
        setSucceeded(true);
    }
}
#method_after
@Override
protected void executeCommand() {
    lockImage();
    VDSReturnValue vdsReturnValue = null;
    Guid sourceDomainId = getParameters().getSourceDomainId() != null ? getParameters().getSourceDomainId() : getDiskImage().getStorageIds().get(0);
    Guid taskId = persistAsyncTaskPlaceHolder(getParameters().getParentCommand());
    if (getParameters().getUseCopyCollapse()) {
        vdsReturnValue = runVdsCommand(VDSCommandType.CopyImage, new CopyImageVDSCommandParameters(getStorageDomain().getStoragePoolId(), sourceDomainId, getParameters().getContainerId(), getParameters().getImageGroupID(), getParameters().getImageId(), getParameters().getDestImageGroupId(), getParameters().getDestinationImageId(), "", getParameters().getStorageDomainId(), getParameters().getCopyVolumeType(), getParameters().getVolumeFormat(), getParameters().getVolumeType(), isWipeAfterDelete(), getParameters().getForceOverride()));
    } else {
        vdsReturnValue = runVdsCommand(VDSCommandType.MoveImageGroup, new MoveImageGroupVDSCommandParameters(getDiskImage() != null ? getDiskImage().getStoragePoolId() : getStorageDomain().getStoragePoolId(), sourceDomainId, getDiskImage() != null ? getDiskImage().getId() : getParameters().getImageGroupID(), getParameters().getStorageDomainId(), getParameters().getContainerId(), ImageOperation.Copy, isWipeAfterDelete(), getParameters().getForceOverride()));
    }
    if (vdsReturnValue.getSucceeded()) {
        AsyncTaskCreationInfo taskCreationInfo = vdsReturnValue.getCreationInfo();
        getReturnValue().getInternalVdsmTaskIdList().add(createTask(taskId, taskCreationInfo, getParameters().getParentCommand(), VdcObjectType.Storage, sourceDomainId, getParameters().getStorageDomainId()));
        // Add storage domain in db only if there is new entity in DB.
        if (!shouldUpdateStorageDisk() && getParameters().getAddImageDomainMapping()) {
            getImageStorageDomainMapDao().save(new image_storage_domain_map(getParameters().getImageId(), getParameters().getStorageDomainId()));
        }
        // update quota
        if (getParameters().getQuotaId() != null) {
            getImageDao().updateQuotaForImageAndSnapshots(getParameters().getDestImageGroupId(), getParameters().getQuotaId());
        }
        setSucceeded(true);
    }
}
#end_block

#method_before
@Override
protected void revertTasks() {
    if (getParameters().getRevertDbOperationScope() != null) {
        Guid destImageId = getParameters().getDestinationImageId();
        RemoveImageParameters removeImageParams = new RemoveImageParameters(destImageId);
        removeImageParams.setParentParameters(removeImageParams);
        removeImageParams.setParentCommand(VdcActionType.RemoveImage);
        removeImageParams.setStorageDomainId(getParameters().getStorageDomainId());
        removeImageParams.setDbOperationScope(getParameters().getRevertDbOperationScope());
        removeImageParams.setEntityId(getDestinationImageId());
        // Setting the image as the monitored entity, so there will not be dependency
        VdcReturnValueBase returnValue = checkAndPerformRollbackUsingCommand(VdcActionType.RemoveImage, removeImageParams);
        if (returnValue.getSucceeded()) {
            // Starting to monitor the the tasks - RemoveImage is an internal command
            // which adds the taskId on the internal task ID list
            startPollingAsyncTasks(returnValue.getInternalTaskIdList());
        }
    }
}
#method_after
@Override
protected void revertTasks() {
    if (getParameters().getRevertDbOperationScope() != null) {
        Guid destImageId = getParameters().getDestinationImageId();
        RemoveImageParameters removeImageParams = new RemoveImageParameters(destImageId);
        if (getParameters().getParentCommand() == VdcActionType.AddVmFromSnapshot) {
            removeImageParams.setParentParameters(getParameters());
            removeImageParams.setParentCommand(VdcActionType.CopyImageGroup);
        } else {
            removeImageParams.setParentParameters(removeImageParams);
            removeImageParams.setParentCommand(VdcActionType.RemoveImage);
            removeImageParams.setStorageDomainId(getParameters().getStorageDomainId());
            removeImageParams.setDbOperationScope(getParameters().getRevertDbOperationScope());
            removeImageParams.setShouldLockImage(getParameters().isShouldLockImageOnRevert());
        }
        removeImageParams.setEntityInfo(new EntityInfo(VdcObjectType.Disk, getDestinationImageId()));
        // Setting the image as the monitored entity, so there will not be dependency
        VdcReturnValueBase returnValue = checkAndPerformRollbackUsingCommand(VdcActionType.RemoveImage, removeImageParams);
        if (returnValue.getSucceeded()) {
            // Starting to monitor the the tasks - RemoveImage is an internal command
            // which adds the taskId on the internal task ID list
            startPollingAsyncTasks(returnValue.getInternalVdsmTaskIdList());
        }
    }
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                // we force export template image to COW+Sparse but we don't update
                // the ovf so the import
                // will set the original format
                MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
                p.setParentCommand(getActionType());
                p.setParentParameters(getParameters());
                p.setEntityId(getParameters().getEntityId());
                p.setUseCopyCollapse(true);
                p.setCopyVolumeType(CopyVolumeType.SharedVol);
                p.setVolumeFormat(disk.getVolumeFormat());
                p.setVolumeType(disk.getVolumeType());
                p.setForceOverride(getParameters().getForceOverride());
                p.setRevertDbOperationScope(ImageDbOperationScope.NONE);
                p.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
                VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.CopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                if (!vdcRetValue.getSucceeded()) {
                    throw new VdcBLLException(vdcRetValue.getFault().getError(), vdcRetValue.getFault().getMessage());
                }
                getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
            }
            return null;
        }
    });
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(final Guid containerID, final Iterable<DiskImage> disks) {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            for (DiskImage disk : disks) {
                // we force export template image to COW+Sparse but we don't update
                // the ovf so the import
                // will set the original format
                MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, disk.getId(), disk.getImageId(), getParameters().getStorageDomainId(), getMoveOrCopyImageOperation());
                p.setParentCommand(getActionType());
                p.setParentParameters(getParameters());
                p.setEntityInfo(getParameters().getEntityInfo());
                p.setUseCopyCollapse(true);
                p.setCopyVolumeType(CopyVolumeType.SharedVol);
                p.setVolumeFormat(disk.getVolumeFormat());
                p.setVolumeType(disk.getVolumeType());
                p.setForceOverride(getParameters().getForceOverride());
                p.setRevertDbOperationScope(ImageDbOperationScope.NONE);
                p.setShouldLockImageOnRevert(false);
                p.setSourceDomainId(imageFromSourceDomainMap.get(disk.getId()).getStorageIds().get(0));
                VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.CopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
                if (!vdcRetValue.getSucceeded()) {
                    throw new VdcBLLException(vdcRetValue.getFault().getError(), vdcRetValue.getFault().getMessage());
                }
                getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    boolean retVal = validate(storageDomainValidator.isDomainExistAndActive());
    if (retVal) {
        // export must be to export domain
        if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
            retVal = false;
        }
    }
    retVal = retVal && super.canDoAction();
    // check if template (with no override option)
    if (retVal && !getParameters().getForceOverride()) {
        retVal = !ExportVmCommand.CheckTemplateInStorageDomain(getVmTemplate().getStoragePoolId().getValue(), getParameters().getStorageDomainId(), getVmTemplateId());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVmTemplate() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    StorageDomainValidator storageDomainValidator = new StorageDomainValidator(getStorageDomain());
    boolean retVal = validate(storageDomainValidator.isDomainExistAndActive());
    if (retVal) {
        // export must be to export domain
        if (getStorageDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_SPECIFY_DOMAIN_IS_NOT_EXPORT_DOMAIN);
            retVal = false;
        }
    }
    retVal = retVal && super.canDoAction();
    // check if template (with no override option)
    if (retVal && !getParameters().getForceOverride()) {
        retVal = !ExportVmCommand.CheckTemplateInStorageDomain(getVmTemplate().getStoragePoolId(), getParameters().getStorageDomainId(), getVmTemplateId());
        if (!retVal) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED);
        }
    }
    return retVal;
}
#end_block

#method_before
@Override
protected void incrementDbGeneration() {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
    OvfDataUpdater.getInstance().loadTemplateData(getVmTemplate());
    VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
    // update the target (export) domain
    OvfDataUpdater.getInstance().buildMetadataDictionaryForTemplate(getVmTemplate(), metaDictionary);
    OvfDataUpdater.getInstance().executeUpdateVmInSpmCommand(getVmTemplate().getStoragePoolId().getValue(), metaDictionary, getParameters().getStorageDomainId());
}
#method_after
@Override
protected void incrementDbGeneration() {
    // and there's no need for exporting the template's ovf.
    if (getParameters().getTaskGroupSuccess()) {
        Map<Guid, KeyValuePairCompat<String, List<Guid>>> metaDictionary = new HashMap<Guid, KeyValuePairCompat<String, List<Guid>>>();
        OvfDataUpdater.getInstance().loadTemplateData(getVmTemplate());
        VmTemplateHandler.UpdateDisksFromDb(getVmTemplate());
        // update the target (export) domain
        OvfDataUpdater.getInstance().buildMetadataDictionaryForTemplate(getVmTemplate(), metaDictionary);
        OvfDataUpdater.getInstance().executeUpdateVmInSpmCommand(getVmTemplate().getStoragePoolId(), metaDictionary, getParameters().getStorageDomainId());
    }
}
#end_block

#method_before
protected void copyDiskImage(DiskImage diskImage, Guid srcStorageDomainId, Guid destStorageDomainId, VdcActionType parentCommandType) {
    DiskImage newDiskImage = cloneDiskImage(getVmId(), destStorageDomainId, Guid.NewGuid(), Guid.NewGuid(), diskImage);
    ImagesHandler.setDiskAlias(newDiskImage, getVm());
    MoveOrCopyImageGroupParameters parameters = createCopyParameters(newDiskImage, srcStorageDomainId, diskImage.getId(), diskImage.getImageId(), parentCommandType);
    parameters.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    VdcReturnValueBase result = executeChildCopyingCommand(parameters);
    handleCopyResult(newDiskImage, parameters, result);
}
#method_after
protected void copyDiskImage(DiskImage diskImage, Guid srcStorageDomainId, Guid destStorageDomainId, VdcActionType parentCommandType) {
    DiskImage newDiskImage = cloneDiskImage(getVmId(), destStorageDomainId, Guid.newGuid(), Guid.newGuid(), diskImage);
    ImagesHandler.setDiskAlias(newDiskImage, getVm());
    MoveOrCopyImageGroupParameters parameters = createCopyParameters(newDiskImage, srcStorageDomainId, diskImage.getId(), diskImage.getImageId(), parentCommandType);
    parameters.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
    VdcReturnValueBase result = executeChildCopyingCommand(parameters);
    handleCopyResult(diskImage, newDiskImage, result);
}
#end_block

#method_before
private void removeVmImages() {
    // Remove vm images, in case they were not already removed by child commands
    List<VdcActionParametersBase> imageParams = getParameters().getImagesParameters();
    if (imageParams != null) {
        for (VdcActionParametersBase param : imageParams) {
            DiskImage diskImage = getDiskImageToRemoveByParam((MoveOrCopyImageGroupParameters) param);
            if (diskImage != null) {
                ImagesHandler.removeDiskImage(diskImage, getVmId());
            }
        }
    }
}
#method_after
private void removeVmImages() {
    // Remove vm images, in case they were not already removed by child commands
    List<VdcActionParametersBase> imageParams = getParameters().getImagesParameters();
    for (VdcActionParametersBase param : imageParams) {
        DiskImage diskImage = getDiskImageToRemoveByParam((MoveOrCopyImageGroupParameters) param);
        if (diskImage != null) {
            ImagesHandler.removeDiskImage(diskImage, getVmId());
        }
    }
}
#end_block

#method_before
protected MoveOrCopyImageGroupParameters createCopyParameters(DiskImage diskImage, Guid srcStorageDomainId, Guid srcImageGroupId, Guid srcImageId, VdcActionType parentCommandType) {
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(getVmId(), srcImageGroupId, srcImageId, diskImage.getId(), diskImage.getImageId(), diskImage.getStorageIds().get(0), ImageOperation.Copy);
    params.setAddImageDomainMapping(false);
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setVolumeFormat(diskImage.getVolumeFormat());
    params.setVolumeType(diskImage.getVolumeType());
    params.setUseCopyCollapse(true);
    params.setSourceDomainId(srcStorageDomainId);
    params.setWipeAfterDelete(diskImage.isWipeAfterDelete());
    params.setEntityId(getVmId());
    params.setParentParameters(getParameters());
    params.setParentCommand(parentCommandType);
    return params;
}
#method_after
protected MoveOrCopyImageGroupParameters createCopyParameters(DiskImage diskImage, Guid srcStorageDomainId, Guid srcImageGroupId, Guid srcImageId, VdcActionType parentCommandType) {
    MoveOrCopyImageGroupParameters params = new MoveOrCopyImageGroupParameters(getVmId(), srcImageGroupId, srcImageId, diskImage.getId(), diskImage.getImageId(), diskImage.getStorageIds().get(0), ImageOperation.Copy);
    params.setAddImageDomainMapping(false);
    params.setCopyVolumeType(CopyVolumeType.LeafVol);
    params.setVolumeFormat(diskImage.getVolumeFormat());
    params.setVolumeType(diskImage.getVolumeType());
    params.setUseCopyCollapse(true);
    params.setSourceDomainId(srcStorageDomainId);
    params.setWipeAfterDelete(diskImage.isWipeAfterDelete());
    params.setEntityInfo(new EntityInfo(VdcObjectType.VM, getVmId()));
    params.setParentParameters(getParameters());
    params.setParentCommand(parentCommandType);
    return params;
}
#end_block

#method_before
protected void handleCopyResult(DiskImage copiedDiskImage, VdcActionParametersBase parameters, VdcReturnValueBase result) {
    // If a copy cannot be made, abort
    if (!result.getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    } else {
        ImagesHandler.addDiskImageWithNoVmDevice(copiedDiskImage);
        getTaskIdList().addAll(result.getInternalTaskIdList());
        newDiskImages.add(copiedDiskImage);
    }
}
#method_after
private void handleCopyResult(DiskImage srcDiskImage, DiskImage copiedDiskImage, VdcReturnValueBase result) {
    // If a copy cannot be made, abort
    if (!result.getSucceeded()) {
        throw new VdcBLLException(VdcBllErrors.VolumeCreationError);
    } else {
        ImagesHandler.addDiskImageWithNoVmDevice(copiedDiskImage);
        getTaskIdList().addAll(result.getInternalVdsmTaskIdList());
        getSrcDiskIdToTargetDiskIdMapping().put(srcDiskImage.getId(), copiedDiskImage.getId());
    }
}
#end_block

#method_before
@Override
protected boolean buildAndCheckDestStorageDomains() {
    if (diskInfoDestinationMap.isEmpty()) {
        List<StorageDomain> domains = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(getStoragePoolId().getValue());
        Map<Guid, StorageDomain> storageDomainsMap = new HashMap<Guid, StorageDomain>();
        for (StorageDomain storageDomain : domains) {
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination())) {
                storageDomainsMap.put(storageDomain.getId(), storageDomain);
            }
        }
        for (Disk disk : getDiskImagesToBeCloned()) {
            DiskImage image = (DiskImage) disk;
            for (Guid storageId : image.getStorageIds()) {
                if (storageDomainsMap.containsKey(storageId)) {
                    diskInfoDestinationMap.put(image.getId(), image);
                    break;
                }
            }
        }
        if (getDiskImagesToBeCloned().size() != diskInfoDestinationMap.size()) {
            logErrorOneOrMoreActiveDomainsAreMissing();
            return false;
        }
        List<Guid> storageDomainDest = new ArrayList<Guid>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            Guid storageDomainId = diskImage.getStorageIds().get(0);
            if (storageDomainDest.contains(storageDomainId)) {
                destStorages.put(storageDomainId, storageDomainsMap.get(storageDomainId));
            }
            storageDomainDest.add(storageDomainId);
        }
        return true;
    }
    return super.buildAndCheckDestStorageDomains();
}
#method_after
@Override
protected boolean buildAndCheckDestStorageDomains() {
    if (diskInfoDestinationMap.isEmpty()) {
        List<StorageDomain> domains = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(getStoragePoolId());
        Map<Guid, StorageDomain> storageDomainsMap = new HashMap<Guid, StorageDomain>();
        for (StorageDomain storageDomain : domains) {
            StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
            if (validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination())) {
                storageDomainsMap.put(storageDomain.getId(), storageDomain);
            }
        }
        for (Disk disk : getDiskImagesToBeCloned()) {
            DiskImage image = (DiskImage) disk;
            for (Guid storageId : image.getStorageIds()) {
                if (storageDomainsMap.containsKey(storageId)) {
                    diskInfoDestinationMap.put(image.getId(), image);
                    break;
                }
            }
        }
        if (getDiskImagesToBeCloned().size() != diskInfoDestinationMap.size()) {
            logErrorOneOrMoreActiveDomainsAreMissing();
            return false;
        }
        List<Guid> storageDomainDest = new ArrayList<Guid>();
        for (DiskImage diskImage : diskInfoDestinationMap.values()) {
            Guid storageDomainId = diskImage.getStorageIds().get(0);
            if (storageDomainDest.contains(storageDomainId)) {
                destStorages.put(storageDomainId, storageDomainsMap.get(storageDomainId));
            }
            storageDomainDest.add(storageDomainId);
        }
        return true;
    }
    return super.buildAndCheckDestStorageDomains();
}
#end_block

#method_before
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, VdcBllMessages.ACTION_TYPE_FAILED_OBJECT_LOCKED));
    }
    return null;
}
#method_after
@Override
protected Map<String, Pair<String, String>> getExclusiveLocks() {
    if (!StringUtils.isBlank(getParameters().getVm().getName())) {
        return Collections.singletonMap(getParameters().getVm().getName(), LockMessagesMatchUtil.makeLockingPair(LockingGroup.VM_NAME, VdcBllMessages.ACTION_TYPE_FAILED_NAME_ALREADY_USED));
    }
    return null;
}
#end_block

#method_before
private void initImportClonedVm() {
    Guid guid = Guid.NewGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setName(getParameters().getVm().getName());
    getVm().setStoragePoolId(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        iface.setId(Guid.NewGuid());
    }
}
#method_after
private void initImportClonedVm() {
    Guid guid = Guid.newGuid();
    getVm().setId(guid);
    setVmId(guid);
    getVm().setName(getParameters().getVm().getName());
    getVm().setStoragePoolId(getParameters().getStoragePoolId());
    getParameters().setVm(getVm());
    for (VmNic iface : getVm().getInterfaces()) {
        iface.setId(Guid.newGuid());
    }
}
#end_block

#method_before
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
    if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getVm().getImages()) {
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
        }
        Map<Guid, List<DiskImage>> images = getImagesLeaf(getVm().getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, diskList.get(diskList.size() - 1));
        }
    }
    return true;
}
#method_after
private boolean canDoActionBeforeCloneVm(Map<Guid, StorageDomain> domainsMap) {
    List<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    if (getVm() != null) {
        setDescription(getVmName());
    }
    if (!checkStoragePool()) {
        return false;
    }
    Set<Guid> destGuids = new HashSet<Guid>(imageToDestinationDomainMap.values());
    for (Guid destGuid : destGuids) {
        StorageDomain storageDomain = getStorageDomain(destGuid);
        StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
        if (!validate(validator.isDomainExistAndActive()) || !validate(validator.domainIsValidDestination())) {
            return false;
        }
        domainsMap.put(destGuid, storageDomain);
    }
    if (getParameters().isImportAsNewEntity() && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORT_CLONE_NOT_COLLAPSED);
    }
    setSourceDomainId(getParameters().getSourceDomainId());
    StorageDomainValidator validator = new StorageDomainValidator(getSourceDomain());
    if (validator.isDomainExistAndActive().isValid() && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
    }
    List<VM> vms = getVmsFromExportDomain();
    if (vms == null) {
        return false;
    }
    VM vm = LinqUtils.firstOrNull(vms, new Predicate<VM>() {

        @Override
        public boolean eval(VM evalVm) {
            return evalVm.getId().equals(getParameters().getVm().getId());
        }
    });
    if (vm != null) {
        // At this point we should work with the VM that was read from
        // the OVF
        setVm(vm);
        // Iterate over all the VM images (active image and snapshots)
        for (DiskImage image : getVm().getImages()) {
            if (Guid.Empty.equals(image.getVmSnapshotId())) {
                return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
            }
            if (getParameters().getCopyCollapse()) {
                // a match with the image from the VM.
                for (DiskImage p : imageList) {
                    // only if requested by the user
                    if (p.getImageId().equals(image.getImageId())) {
                        if (p.getVolumeFormat() != null) {
                            image.setvolumeFormat(p.getVolumeFormat());
                        }
                        if (p.getVolumeType() != null) {
                            image.setVolumeType(p.getVolumeType());
                        }
                        // Validate the configuration of the image got from the parameters.
                        if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                            return false;
                        }
                        break;
                    }
                }
            } else {
                // If no copy collapse sent, validate each image configuration (snapshot or active image).
                if (!validateImageConfig(canDoActionMessages, domainsMap, image)) {
                    return false;
                }
            }
            image.setStoragePoolId(getParameters().getStoragePoolId());
            // we put the source domain id in order that copy will
            // work properly.
            // we fix it to DestDomainId in
            // MoveOrCopyAllImageGroups();
            image.setStorageIds(new ArrayList<Guid>(Arrays.asList(getParameters().getSourceDomainId())));
        }
        Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
        for (Map.Entry<Guid, List<DiskImage>> entry : images.entrySet()) {
            Guid id = entry.getKey();
            List<DiskImage> diskList = entry.getValue();
            getVm().getDiskMap().put(id, ImagesHandler.getActiveVolumeDisk(diskList));
        }
    }
    return true;
}
#end_block

#method_before
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    if (!qRetVal.getSucceeded()) {
        return null;
    }
    return (List<VM>) qRetVal.getReturnValue();
}
#method_after
protected List<VM> getVmsFromExportDomain() {
    GetAllFromExportDomainQueryParameters p = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
    VdcQueryReturnValue qRetVal = getBackend().runInternalQuery(VdcQueryType.GetVmsFromExportDomain, p);
    return qRetVal.getSucceeded() ? qRetVal.<List<VM>>getReturnValue() : null;
}
#end_block

#method_before
private boolean validateImageConfig(List<String> canDoActionMessages, Map<Guid, StorageDomain> domainsMap, DiskImage image) {
    return ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
}
#method_after
private boolean validateImageConfig(List<String> canDoActionMessages, Map<Guid, StorageDomain> domainsMap, DiskImage image) {
    return ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
}
#end_block

#method_before
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !templateExistsOnExportDomain()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING);
        addCanDoActionMessage(String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
        return false;
    }
    if (!validateVdsCluster()) {
        return false;
    }
    Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
    for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
        if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateMacAddress(getVm().getInterfaces())) {
        return false;
    }
    return true;
}
#method_after
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVdsCluster()) {
        return false;
    }
    Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
    if (!setDomainsForMemoryImages(domainMap)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
        if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean validateNoDuplicateVm() {
    VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
    if (duplicateVm != null) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS);
        addCanDoActionMessage(String.format("$VmName %1$s", duplicateVm.getName()));
        return false;
    }
    return true;
}
#method_after
protected boolean validateNoDuplicateVm() {
    VmStatic duplicateVm = getVmStaticDAO().get(getVm().getId());
    if (duplicateVm != null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_IMPORT_VM_EXISTS, String.format("$VmName %1$s", duplicateVm.getName()));
    }
    return true;
}
#end_block

#method_before
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = (List<StorageDomain>) Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            retValue = false;
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#method_after
protected boolean checkTemplateInStorageDomain() {
    boolean retValue = getParameters().isImportAsNewEntity() || checkIfDisksExist(imageList);
    if (retValue && !VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && !getParameters().getCopyCollapse()) {
        List<StorageDomain> domains = Backend.getInstance().runInternalQuery(VdcQueryType.GetStorageDomainsByVmTemplateId, new IdQueryParameters(getVm().getVmtGuid())).getReturnValue();
        List<Guid> domainsId = LinqUtils.foreach(domains, new Function<StorageDomain, Guid>() {

            @Override
            public Guid eval(StorageDomain storageDomainStatic) {
                return storageDomainStatic.getId();
            }
        });
        if (Collections.disjoint(domainsId, imageToDestinationDomainMap.values())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_NOT_FOUND_ON_DESTINATION_DOMAIN);
        }
    }
    return retValue;
}
#end_block

#method_before
private boolean templateExists() {
    if (getVmTemplate() == null && !getParameters().getCopyCollapse()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
        return false;
    }
    return true;
}
#method_after
private boolean templateExists() {
    if (getVmTemplate() == null && !getParameters().getCopyCollapse()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_TEMPLATE_DOES_NOT_EXIST);
    }
    return true;
}
#end_block

#method_before
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getVm().getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId().getValue() : Guid.Empty;
        Guid storageDomainId = getParameters().getSourceDomainId();
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
            return false;
        }
    }
    return true;
}
#method_after
protected boolean checkImagesGUIDsLegal() {
    for (DiskImage image : getVm().getImages()) {
        Guid imageGUID = image.getImageId();
        Guid storagePoolId = image.getStoragePoolId() != null ? image.getStoragePoolId() : Guid.Empty;
        Guid storageDomainId = getParameters().getSourceDomainId();
        Guid imageGroupId = image.getId() != null ? image.getId() : Guid.Empty;
        VDSReturnValue retValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.DoesImageExist, new GetImageInfoVDSCommandParameters(storagePoolId, storageDomainId, imageGroupId, imageGUID));
        if (Boolean.FALSE.equals(retValue.getReturnValue())) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IMAGE_DOES_NOT_EXIST);
        }
    }
    return true;
}
#end_block

#method_before
protected boolean canAddVm() {
    // Checking if a desktop with same name already exists
    boolean exists = VmHandler.isVmWithSameNameExistStatic(getVm().getName());
    if (exists) {
        addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_VM_NAME_EXISTS);
    }
    return !exists;
}
#method_after
protected boolean canAddVm() {
    // Checking if a desktop with same name already exists
    if (VmHandler.isVmWithSameNameExistStatic(getVm().getName())) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_IMPORT_VM_NAME_EXISTS);
    }
    return true;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        VM vm = getVm();
        // vm related ops
        if (vm.getImages().isEmpty()) {
            endVmRelatedOps();
        } else {
            processImages();
        }
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    try {
        addVmToDb();
        processImages();
        // vm related ops
        if (getReturnValue().getVdsmTaskIdList().isEmpty()) {
            endVmRelatedOps();
        }
    } catch (RuntimeException e) {
        MacPoolManager.getInstance().freeMacs(macsAdded);
        throw e;
    }
    setSucceeded(true);
}
#end_block

#method_before
private void addVmToDb() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmStatic();
            addVmDynamic();
            addVmInterfaces();
            addVmStatistics();
            getCompensationContext().stateChanged();
            return null;
        }
    });
    freeLock();
}
#method_after
private void addVmToDb() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmStatic();
            addVmDynamic();
            addVmInterfaces();
            addVmStatistics();
            getCompensationContext().stateChanged();
            return null;
        }
    });
}
#end_block

#method_before
private void processImages() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmImagesAndSnapshots();
            updateSnapshotsFromExport();
            moveOrCopyAllImageGroups();
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity());
            VmHandler.LockVm(getVm().getId());
            if (getParameters().isImportAsNewEntity()) {
                getParameters().setVm(getVm());
                setVmId(getVm().getId());
            }
            return null;
        }
    });
}
#method_after
private void processImages() {
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            addVmImagesAndSnapshots();
            updateSnapshotsFromExport();
            moveOrCopyAllImageGroups();
            VmDeviceUtils.addImportedDevices(getVm().getStaticData(), getParameters().isImportAsNewEntity());
            VmHandler.lockVm(getVm().getId());
            if (getParameters().isImportAsNewEntity()) {
                getParameters().setVm(getVm());
                setVmId(getVm().getId());
            }
            return null;
        }
    });
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups() {
    moveOrCopyAllImageGroups(getVm().getId(), ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false));
}
#method_after
@Override
protected void moveOrCopyAllImageGroups() {
    moveOrCopyAllImageGroups(getVm().getId(), ImagesHandler.filterImageDisks(getVm().getDiskMap().values(), false, false));
    copyAllMemoryImages(getVm().getId());
}
#end_block

#method_before
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    int i = 0;
    for (DiskImage disk : disks) {
        Guid destinationDomain = imageToDestinationDomainMap.get(diskGuidList.get(i));
        MoveOrCopyImageGroupParameters p = new MoveOrCopyImageGroupParameters(containerID, diskGuidList.get(i), imageGuidList.get(i), disk.getId(), disk.getImageId(), destinationDomain, getMoveOrCopyImageOperation());
        p.setParentCommand(getActionType());
        p.setUseCopyCollapse(getParameters().getCopyCollapse());
        p.setCopyVolumeType(CopyVolumeType.LeafVol);
        p.setForceOverride(getParameters().getForceOverride());
        p.setSourceDomainId(getParameters().getSourceDomainId());
        p.setStoragePoolId(getParameters().getStoragePoolId());
        p.setImportEntity(true);
        p.setEntityId(getVm().getId());
        p.setRevertDbOperationScope(ImageDbOperationScope.IMAGE);
        p.setQuotaId(disk.getQuotaId() != null ? disk.getQuotaId() : getParameters().getQuotaId());
        if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(diskGuidList.get(i))) {
            DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(diskGuidList.get(i));
            p.setVolumeType(diskImageBase.getVolumeType());
            p.setVolumeFormat(diskImageBase.getVolumeFormat());
        }
        p.setParentParameters(getParameters());
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.CopyImageGroup, p, ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getTaskIdList().addAll(vdcRetValue.getInternalTaskIdList());
        i++;
    }
}
#method_after
@Override
protected void moveOrCopyAllImageGroups(Guid containerID, Iterable<DiskImage> disks) {
    for (DiskImage disk : disks) {
        VdcReturnValueBase vdcRetValue = Backend.getInstance().runInternalAction(VdcActionType.CopyImageGroup, buildMoveOrCopyImageGroupParametersForDisk(disk, containerID), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
        if (!vdcRetValue.getSucceeded()) {
            throw new VdcBLLException(vdcRetValue.getFault().getError(), "ImportVmCommand::MoveOrCopyAllImageGroups: Failed to copy disk!");
        }
        getReturnValue().getVdsmTaskIdList().addAll(vdcRetValue.getInternalVdsmTaskIdList());
    }
}
#end_block

#method_before
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.NewGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = diskList.get(diskList.size() - 1);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setImageTemplateId(VmTemplateHandler.BlankVmTemplateId);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            if (getParameters().isImportAsNewEntity()) {
                disk.setId(Guid.NewGuid());
                disk.setImageId(Guid.NewGuid());
                for (int i = 0; i < diskList.size() - 1; i++) {
                    diskList.get(i).setId(disk.getId());
                }
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().getSnapshots().clear();
        getVm().getSnapshots().add(snapshot);
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId().getValue();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = diskList.get(diskList.size() - 1);
            diskGuidList.add(disk.getId());
            imageGuidList.add(disk.getImageId());
            snapshotId = disk.getVmSnapshotId().getValue();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#method_after
protected void addVmImagesAndSnapshots() {
    Map<Guid, List<DiskImage>> images = ImagesHandler.getImagesLeaf(getVm().getImages());
    if (getParameters().getCopyCollapse()) {
        Guid snapshotId = Guid.newGuid();
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = ImagesHandler.getActiveVolumeDisk(diskList);
            disk.setParentId(VmTemplateHandler.BlankVmTemplateId);
            disk.setImageTemplateId(VmTemplateHandler.BlankVmTemplateId);
            disk.setVmSnapshotId(snapshotId);
            disk.setActive(true);
            if (getParameters().getVm().getDiskMap() != null && getParameters().getVm().getDiskMap().containsKey(disk.getId())) {
                DiskImageBase diskImageBase = (DiskImageBase) getParameters().getVm().getDiskMap().get(disk.getId());
                disk.setvolumeFormat(diskImageBase.getVolumeFormat());
                disk.setVolumeType(diskImageBase.getVolumeType());
            }
            setDiskStorageDomainInfo(disk);
            if (getParameters().isImportAsNewEntity()) {
                generateNewDiskId(diskList, disk);
            } else {
                newDiskIdForDisk.put(disk.getId(), disk);
            }
            disk.setCreationDate(new Date());
            saveImage(disk);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            saveBaseDisk(disk);
            saveDiskImageDynamic(disk);
        }
        Snapshot snapshot = addActiveSnapshot(snapshotId);
        getVm().setSnapshots(Arrays.asList(snapshot));
    } else {
        Guid snapshotId = null;
        for (DiskImage disk : getVm().getImages()) {
            disk.setActive(false);
            setDiskStorageDomainInfo(disk);
            saveImage(disk);
            snapshotId = disk.getVmSnapshotId();
            saveSnapshotIfNotExists(snapshotId, disk);
            saveDiskImageDynamic(disk);
        }
        int aliasCounter = 0;
        for (List<DiskImage> diskList : images.values()) {
            DiskImage disk = ImagesHandler.getActiveVolumeDisk(diskList);
            newDiskIdForDisk.put(disk.getId(), disk);
            snapshotId = disk.getVmSnapshotId();
            disk.setActive(true);
            ImagesHandler.setDiskAlias(disk, getVm(), ++aliasCounter);
            updateImage(disk);
            saveBaseDisk(disk);
        }
        // Update active snapshot's data, since it was inserted as a regular snapshot.
        updateActiveSnapshot(snapshotId);
    }
}
#end_block

#method_before
protected Snapshot addActiveSnapshot(Guid snapshotId) {
    return new SnapshotsManager().addActiveSnapshot(snapshotId, getVm(), getCompensationContext());
}
#method_after
protected Snapshot addActiveSnapshot(Guid snapshotId) {
    return snapshotsManager.addActiveSnapshot(snapshotId, getVm(), getMemoryVolumeForNewActiveSnapshot(), getCompensationContext());
}
#end_block

#method_before
private void updateSnapshotsFromExport() {
    if (getVm().getSnapshots() != null) {
        for (Snapshot snapshot : getVm().getSnapshots()) {
            if (getSnapshotDao().exists(getVm().getId(), snapshot.getId())) {
                getSnapshotDao().update(snapshot);
            } else {
                getSnapshotDao().save(snapshot);
            }
        }
    }
}
#method_after
private void updateSnapshotsFromExport() {
    if (getVm().getSnapshots() == null) {
        return;
    }
    for (Snapshot snapshot : getVm().getSnapshots()) {
        if (getSnapshotDao().exists(getVm().getId(), snapshot.getId())) {
            getSnapshotDao().update(snapshot);
        } else {
            getSnapshotDao().save(snapshot);
        }
    }
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    List<String> invalidNetworkNames = new ArrayList<String>();
    List<String> invalidIfaceNames = new ArrayList<String>();
    Map<String, Network> networksInClusterByName = Entities.entitiesByName(getNetworkDAO().getAllForCluster(getVm().getVdsGroupId()));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        if (!vmInterfaceManager.isValidVmNetwork(iface, networksInClusterByName)) {
            invalidNetworkNames.add(iface.getNetworkName());
            invalidIfaceNames.add(iface.getName());
            iface.setNetworkName(null);
        }
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    auditInvalidInterfaces(invalidNetworkNames, invalidIfaceNames);
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
private void initInterface(VmNetworkInterface iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.NewGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
    iface.setVmName(getVm().getName());
}
#method_after
private void initInterface(VmNic iface) {
    if (iface.getId() == null) {
        iface.setId(Guid.newGuid());
    }
    fillMacAddressIfMissing(iface);
    iface.setVmTemplateId(null);
    iface.setVmId(getVmId());
}
#end_block

#method_before
@Override
protected void endSuccessfully() {
    endImportCommand();
}
#method_after
@Override
protected void endSuccessfully() {
    checkTrustedService();
    endImportCommand();
}
#end_block

#method_before
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading
    setVm(null);
    // it form DB
    VM vmFromParams = getParameters().getVm();
    if (getVm() != null) {
        endActionOnAllImageGroups();
        removeVmNetworkInterfaces();
        new SnapshotsManager().removeSnapshots(getVm().getId());
        getVmDynamicDAO().remove(getVmId());
        getVmStatisticsDAO().remove(getVmId());
        new SnapshotsManager().removeSnapshots(getVmId());
        getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(vmFromParams);
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#method_after
@Override
protected void endWithFailure() {
    // Going to try and refresh the VM by re-loading it form DB
    setVm(null);
    if (getVm() != null) {
        removeVmSnapshots(getVm());
        endActionOnAllImageGroups();
        removeVmNetworkInterfaces();
        getVmDynamicDAO().remove(getVmId());
        getVmStatisticsDAO().remove(getVmId());
        getVmStaticDAO().remove(getVmId());
        setSucceeded(true);
    } else {
        // Setting VM from params, for logging purposes
        setVm(getParameters().getVm());
        // No point in trying to end action again, as the imported VM does not exist in the DB.
        getReturnValue().setEndActionTryAgain(false);
    }
}
#end_block

#method_before
private void endVmRelatedOps() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.UnLockVm(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
}
#method_after
private void endVmRelatedOps() {
    setVm(null);
    if (getVm() != null) {
        VmHandler.unLockVm(getVm());
    } else {
        setCommandShouldBeLogged(false);
        log.warn("ImportVmCommand::EndImportCommand: Vm is null - not performing full EndAction");
    }
}
#end_block

#method_before
public NGuid getSourceDomainId() {
    return sourceDomainId;
}
#method_after
public Guid getSourceDomainId() {
    return sourceDomainId;
}
#end_block

#method_before
public void setSourceDomainId(NGuid value) {
    sourceDomainId = value;
}
#method_after
public void setSourceDomainId(Guid value) {
    sourceDomainId = value;
}
#end_block

#method_before
@Override
protected void selectExternalProvider() {
    Network network = getNetwork();
    if (network.isExternal()) {
        for (Provider provider : (Iterable<Provider>) getExternalProviders().getItems()) {
            if (provider.getId().equals(network.getProvidedBy().getProviderId())) {
                getExternalProviders().setSelectedItem(provider);
                return;
            }
        }
    }
}
#method_after
@Override
protected void selectExternalProvider() {
    final Network network = getNetwork();
    getExternalProviders().setSelectedItem(Linq.firstOrDefault((Iterable<Provider>) getExternalProviders().getItems(), new Linq.NetworkSameProviderPredicate(network)));
}
#end_block

#method_before
private void setStyle() {
    inboundAverageEditor.setContentWidgetStyleName(style.valueWidth());
    inboundAverageEditor.setLabelStyleName(style.hideLabelStyle());
    inboundPeakEditor.setContentWidgetStyleName(style.valueWidth());
    inboundPeakEditor.setLabelStyleName(style.hideLabelStyle());
    inboundBurstEditor.setContentWidgetStyleName(style.valueWidth());
    inboundBurstEditor.setLabelStyleName(style.hideLabelStyle());
    outboundAverageEditor.setContentWidgetStyleName(style.valueWidth());
    outboundAverageEditor.setLabelStyleName(style.hideLabelStyle());
    outboundPeakEditor.setContentWidgetStyleName(style.valueWidth());
    outboundPeakEditor.setLabelStyleName(style.hideLabelStyle());
    outboundBurstEditor.setContentWidgetStyleName(style.valueWidth());
    outboundBurstEditor.setLabelStyleName(style.hideLabelStyle());
}
#method_after
private void setStyle() {
    inboundAverageEditor.setContentWidgetStyleName(style.valueWidth());
    inboundPeakEditor.setContentWidgetStyleName(style.valueWidth());
    inboundBurstEditor.setContentWidgetStyleName(style.valueWidth());
    outboundAverageEditor.setContentWidgetStyleName(style.valueWidth());
    outboundPeakEditor.setContentWidgetStyleName(style.valueWidth());
    outboundBurstEditor.setContentWidgetStyleName(style.valueWidth());
}
#end_block

#method_before
private void processStoragePoolStatus() {
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(getVds().getStoragePoolId());
        if (pool != null && pool.getstatus() == StoragePoolStatus.NotOperational) {
            pool.setstatus(StoragePoolStatus.NonResponsive);
            DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), pool.getstatus());
            StoragePoolStatusHandler.PoolStatusChanged(pool.getId(), pool.getstatus());
        }
    }
}
#method_after
private void processStoragePoolStatus() {
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(getVds().getStoragePoolId());
        if (pool != null && pool.getStatus() == StoragePoolStatus.NotOperational) {
            pool.setStatus(StoragePoolStatus.NonResponsive);
            DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), pool.getStatus());
            StoragePoolStatusHandler.poolStatusChanged(pool.getId(), pool.getStatus());
        }
    }
}
#end_block

#method_before
private boolean InitializeStorage() {
    boolean returnValue = false;
    // connect any storage
    if (getStoragePool() == null || StoragePoolStatus.Uninitialized == getStoragePool().getstatus() || StoragePoolStatus.Maintenance == getStoragePool().getstatus()) {
        returnValue = true;
        connectPoolSucceeded = true;
    } else {
        HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(getStoragePool(), getVds());
        Backend.getInstance().runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params);
        returnValue = connectHostToPool();
        connectPoolSucceeded = returnValue;
    }
    return returnValue;
}
#method_after
private boolean InitializeStorage() {
    boolean returnValue = false;
    // connect any storage
    if (getStoragePool() == null || StoragePoolStatus.Uninitialized == getStoragePool().getStatus() || StoragePoolStatus.Maintenance == getStoragePool().getStatus()) {
        returnValue = true;
        connectPoolSucceeded = true;
    } else {
        HostStoragePoolParametersBase params = new HostStoragePoolParametersBase(getStoragePool(), getVds());
        Backend.getInstance().runInternalAction(VdcActionType.ConnectHostToStoragePoolServers, params);
        returnValue = connectHostToPool();
        connectPoolSucceeded = returnValue;
    }
    return returnValue;
}
#end_block

#method_before
private boolean connectHostToPool() {
    final VDS vds = getVds();
    EventResult result = ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getStoragePool().getId(), null, vds.getId(), EventType.VDSCONNECTTOPOOL), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(getStoragePool().getId(), vds);
        }
    });
    if (result != null) {
        return result.isSuccess();
    }
    return false;
}
#method_after
private boolean connectHostToPool() {
    final VDS vds = getVds();
    EventResult result = ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(getStoragePool().getId(), null, vds.getId(), EventType.VDSCONNECTTOPOOL, "Trying to connect host " + vds.getHostName() + " with id " + vds.getId() + " to the pool " + getStoragePool().getId()), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            return runConnectHostToPoolEvent(getStoragePool().getId(), vds);
        }
    });
    if (result != null) {
        return result.isSuccess();
    }
    return false;
}
#end_block

#method_before
protected boolean proceedVdsStats() {
    boolean returnValue = true;
    try {
        runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
        List<Guid> problematicDomainsIds = IrsBrokerCommand.checkIfDomainsReportedAsProblematic(getVds().getStoragePoolId(), getVds().getDomains());
        for (Guid domainId : problematicDomainsIds) {
            StorageDomainStatic domainInfo = getStorageDomainStaticDAO().get(domainId);
            log.errorFormat("Storage Domain {0} of pool {1} is in problem in host {1}", domainInfo != null ? domainInfo.getStorageName() : domainId, getVds().getName(), getStoragePool().getName());
            if (domainInfo == null || domainInfo.getStorageDomainType().isDataDomain()) {
                returnValue = false;
            }
        }
    } catch (VdcBLLException e) {
        log.errorFormat("Could not get Host statistics for Host {0}, Error is {1}", getVds().getName(), e);
        returnValue = false;
    }
    return returnValue;
}
#method_after
protected boolean proceedVdsStats() {
    boolean returnValue = true;
    try {
        runVdsCommand(VDSCommandType.GetStats, new VdsIdAndVdsVDSCommandParametersBase(getVds()));
        List<Guid> problematicDomainsIds = IrsBrokerCommand.fetchDomainsReportedAsProblematic(getVds().getStoragePoolId(), getVds().getDomains());
        for (Guid domainId : problematicDomainsIds) {
            StorageDomainStatic domainInfo = getStorageDomainStaticDAO().get(domainId);
            log.errorFormat("Storage Domain {0} of pool {1} is in problem in host {2}", domainInfo != null ? domainInfo.getStorageName() : domainId, getStoragePool().getName(), getVds().getName());
            if (domainInfo == null || domainInfo.getStorageDomainType().isDataDomain()) {
                returnValue = false;
            }
        }
    } catch (VdcBLLException e) {
        log.errorFormat("Could not get Host statistics for Host {0}, Error is {1}", getVds().getName(), e);
        returnValue = false;
    }
    return returnValue;
}
#end_block

#method_before
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.NonResponsive || storagePool.getstatus() == StoragePoolStatus.Contend)) {
                    proceedStoragePoolStats(storagePool);
                }
            }
        }
    } catch (Exception ex) {
    }
}
#method_after
@OnTimerMethodAnnotation("_updatingTimer_Elapsed")
public void _updatingTimer_Elapsed() {
    try {
        synchronized (syncObj) {
            if (!_disposed) {
                StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
                if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
                    proceedStoragePoolStats(storagePool);
                }
            }
        }
    } catch (Exception ex) {
    }
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = mCurrentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getstatus() != StoragePoolStatus.NonResponsive && storagePool.getstatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>GetValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getstatus() == StoragePoolStatus.NonResponsive || storagePool.getstatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setstatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getstatus());
    }
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getmaster_domain_version();
        java.util.HashSet<Guid> domainsInVds = new java.util.HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
}
#method_after
@SuppressWarnings("unchecked")
private void proceedStoragePoolStats(StoragePool storagePool) {
    // ugly patch because vdsm doesnt check if host is spm on spm
    // operations
    VDSReturnValue result = null;
    Guid curVdsId = mCurrentVdsId;
    if (curVdsId != null) {
        result = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(curVdsId, _storagePoolId));
    }
    if (result == null || !result.getSucceeded() || (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() != SpmStatus.SPM)) {
        // update pool status to problematic until fence will happen
        if (storagePool.getStatus() != StoragePoolStatus.NonResponsive && storagePool.getStatus() != StoragePoolStatus.NotOperational) {
            if (result != null && result.getVdsError() != null) {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_WITH_ERROR, result.getVdsError().getCode());
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE);
            }
        }
        // then cause failover with attempts
        if (result != null && !(result.getExceptionObject() instanceof VDSNetworkException)) {
            HashMap<Guid, AsyncTaskStatus> tasksList = (HashMap<Guid, AsyncTaskStatus>) ResourceManager.getInstance().runVdsCommand(VDSCommandType.HSMGetAllTasksStatuses, new VdsIdVDSCommandParametersBase(curVdsId)).getReturnValue();
            boolean allTasksFinished = true;
            if (tasksList != null) {
                for (AsyncTaskStatus taskStatus : tasksList.values()) {
                    if (AsyncTaskStatusEnum.finished != taskStatus.getStatus()) {
                        allTasksFinished = false;
                        break;
                    }
                }
            }
            if ((tasksList == null) || allTasksFinished) {
                nullifyInternalProxies();
            } else {
                if (_errorAttempts < Config.<Integer>GetValue(ConfigValues.SPMFailOverAttempts)) {
                    _errorAttempts++;
                    log.warnFormat("failed getting spm status for pool {0}:{1}, attempt number {2}", _storagePoolId, storagePool.getName(), _errorAttempts);
                } else {
                    nullifyInternalProxies();
                    _errorAttempts = 0;
                }
            }
        }
    } else if (result.getSucceeded() && ((SpmStatusResult) result.getReturnValue()).getSpmStatus() == SpmStatus.SPM && (storagePool.getStatus() == StoragePoolStatus.NonResponsive || storagePool.getStatus() == StoragePoolStatus.Contend)) {
        // if recovered from network exception set back to up
        DbFacade.getInstance().getStoragePoolDao().updateStatus(storagePool.getId(), StoragePoolStatus.Up);
        storagePool.setStatus(StoragePoolStatus.Up);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
    }
    GetStoragePoolInfoVDSCommandParameters tempVar = new GetStoragePoolInfoVDSCommandParameters(_storagePoolId);
    tempVar.setIgnoreFailoverLimit(true);
    VDSReturnValue storagePoolInfoResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.GetStoragePoolInfo, tempVar);
    if (storagePoolInfoResult.getSucceeded()) {
        KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>> data = (KeyValuePairCompat<StoragePool, java.util.List<StorageDomain>>) storagePoolInfoResult.getReturnValue();
        int masterVersion = data.getKey().getmaster_domain_version();
        java.util.HashSet<Guid> domainsInVds = new java.util.HashSet<Guid>();
        for (StorageDomain domainData : data.getValue()) {
            domainsInVds.add(domainData.getId());
            proceedStorageDomain(domainData, masterVersion, storagePool);
        }
        List<StorageDomain> domainsInDb = DbFacade.getInstance().getStorageDomainDao().getAllForStoragePool(_storagePoolId);
        for (final StorageDomain domainInDb : domainsInDb) {
            if (domainInDb.getStorageDomainType() != StorageDomainType.Master && domainInDb.getStatus() != StorageDomainStatus.Locked && !domainsInVds.contains(domainInDb.getId())) {
                // domain not attached to pool anymore
                DbFacade.getInstance().getStoragePoolIsoMapDao().remove(new StoragePoolIsoMapId(domainInDb.getId(), _storagePoolId));
            }
        }
    }
}
#end_block

#method_before
private void proceedStorageDomain(StorageDomain data, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getstatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getStorageDomainType() == StorageDomainType.Master) || (data.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setStoragePoolId(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getstatus() != StorageDomainStatus.Locked && domainPoolMap.getstatus() != data.getStatus()) {
            if (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getStatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getStatus() != null && data.getStatus() == StorageDomainStatus.InActive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setstatus(StoragePoolStatus.Maintenance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getstatus() != StorageDomainStatus.InActive && data.getStatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getAvailableDiskSize() != null && data.getUsedDiskSize() != null) {
                double freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.addCustomValue("DiskSpace", (data.getAvailableDiskSize()).toString());
                    data.setStorageName(domainFromDb.getStorageName());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setStorageName(domainFromDb.getStorageName());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getStorageName(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#method_after
private void proceedStorageDomain(StorageDomain data, int dataMasterVersion, StoragePool storagePool) {
    StorageDomain storage_domain = DbFacade.getInstance().getStorageDomainDao().getForStoragePool(data.getId(), _storagePoolId);
    StorageDomainStatic domainFromDb = null;
    StoragePoolIsoMap domainPoolMap = null;
    if (storage_domain != null) {
        domainFromDb = storage_domain.getStorageStaticData();
        domainPoolMap = storage_domain.getStoragePoolIsoMapData();
        // If the domain is master in the DB
        if (domainFromDb.getStorageDomainType() == StorageDomainType.Master && domainPoolMap != null && domainPoolMap.getStatus() != StorageDomainStatus.Locked) {
            // and the domain is not master in the VDSM
            if (!((data.getStorageDomainType() == StorageDomainType.Master) || (data.getStorageDomainType() == StorageDomainType.Unknown))) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master in DB and VDSM", MessageFormat.format("Master domain is not in sync between DB and VDSM. " + "Domain {0} marked as master in DB and not in the storage", domainFromDb.getStorageName()));
            } else // mismatch
            if (dataMasterVersion != storagePool.getmaster_domain_version()) {
                reconstructMasterDomainNotInSync(data.getStoragePoolId(), domainFromDb.getId(), "Mismatch between master version in DB and VDSM", MessageFormat.format("Master domain version is not in sync between DB and VDSM. " + "Domain {0} marked as master, but the version in DB: {1} and in VDSM: {2}", domainFromDb.getStorageName(), storagePool.getmaster_domain_version(), dataMasterVersion));
            }
        }
        boolean statusChanged = false;
        if (domainPoolMap == null) {
            data.setStoragePoolId(_storagePoolId);
            DbFacade.getInstance().getStoragePoolIsoMapDao().save(data.getStoragePoolIsoMapData());
            statusChanged = true;
        } else if (domainPoolMap.getStatus() != StorageDomainStatus.Locked && domainPoolMap.getStatus() != data.getStatus()) {
            if (domainPoolMap.getStatus() != StorageDomainStatus.InActive && data.getStatus() != StorageDomainStatus.InActive) {
                DbFacade.getInstance().getStoragePoolIsoMapDao().update(data.getStoragePoolIsoMapData());
                statusChanged = true;
            }
            if (data.getStatus() != null && data.getStatus() == StorageDomainStatus.InActive && domainFromDb.getStorageDomainType() == StorageDomainType.Master) {
                StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(domainPoolMap.getstorage_pool_id());
                if (pool != null) {
                    DbFacade.getInstance().getStoragePoolDao().updateStatus(pool.getId(), StoragePoolStatus.Maintenance);
                    pool.setStatus(StoragePoolStatus.Maintenance);
                    ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(pool.getId(), StoragePoolStatus.Maintenance);
                }
            }
        }
        // update dynamic data
        if (statusChanged || (domainPoolMap.getStatus() != StorageDomainStatus.InActive && data.getStatus() == StorageDomainStatus.Active)) {
            DbFacade.getInstance().getStorageDomainDynamicDao().update(data.getStorageDynamicData());
            if (data.getAvailableDiskSize() != null && data.getUsedDiskSize() != null) {
                double freePercent = data.getStorageDynamicData().getfreeDiskPercent();
                int freeDiskInGB = data.getStorageDynamicData().getfreeDiskInGB();
                AuditLogType type = AuditLogType.UNASSIGNED;
                boolean spaceThresholdMet = freeDiskInGB <= Config.<Integer>GetValue(ConfigValues.FreeSpaceCriticalLowInGB);
                boolean percentThresholdMet = freePercent <= Config.<Integer>GetValue(ConfigValues.FreeSpaceLow);
                if (spaceThresholdMet && percentThresholdMet) {
                    type = AuditLogType.IRS_DISK_SPACE_LOW_ERROR;
                } else {
                    if (spaceThresholdMet || percentThresholdMet) {
                        type = AuditLogType.IRS_DISK_SPACE_LOW;
                    }
                }
                if (type != AuditLogType.UNASSIGNED) {
                    AuditLogableBase logable = new AuditLogableBase();
                    logable.setStorageDomain(data);
                    logable.setStoragePoolId(_storagePoolId);
                    logable.addCustomValue("DiskSpace", (data.getAvailableDiskSize()).toString());
                    data.setStorageName(domainFromDb.getStorageName());
                    AuditLogDirector.log(logable, type);
                }
            }
            Set<VdcBllErrors> alerts = data.getAlerts();
            if (alerts != null && !alerts.isEmpty()) {
                AuditLogableBase logable = new AuditLogableBase();
                logable.setStorageDomain(data);
                data.setStorageName(domainFromDb.getStorageName());
                logable.setStoragePoolId(_storagePoolId);
                for (VdcBllErrors alert : alerts) {
                    switch(alert) {
                        case VG_METADATA_CRITICALLY_FULL:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_VG_METADATA_CRITICALLY_FULL);
                            break;
                        case SMALL_VG_METADATA:
                            AuditLogDirector.log(logable, AuditLogType.STORAGE_ALERT_SMALL_VG_METADATA);
                            break;
                        default:
                            log.errorFormat("Unrecognized alert for domain {0}(id = {1}): {2}", data.getStorageName(), data.getId(), alert);
                            break;
                    }
                }
            }
        }
    } else {
        log.debugFormat("The domain with id {0} was not found in DB", data.getId());
    }
}
#end_block

#method_before
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, masterDomainId, null, EventType.RECONSTRUCT), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            log.warnFormat(logMessage);
            AuditLogableBase logable = new AuditLogableBase(mCurrentVdsId);
            logable.setStorageDomainId(masterDomainId);
            AuditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId, false);
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#method_after
private void reconstructMasterDomainNotInSync(final Guid storagePoolId, final Guid masterDomainId, final String exceptionMessage, final String logMessage) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, masterDomainId, null, EventType.RECONSTRUCT, "Reconstruct caused by failure to execute spm command"), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            log.warnFormat(logMessage);
            AuditLogableBase logable = new AuditLogableBase(mCurrentVdsId);
            logable.setStorageDomainId(masterDomainId);
            AuditLogDirector.log(logable, AuditLogType.SYSTEM_MASTER_DOMAIN_NOT_IN_SYNC);
            return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, storagePoolId, false);
        }
    });
    throw new IRSNoMasterDomainException(exceptionMessage);
}
#end_block

#method_before
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getstatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>GetValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>GetValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int clientRetries = Config.<Integer>GetValue(ConfigValues.vdsRetries);
                Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, IrsServerConnector.class, Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers));
                privatemIrsProxy = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#method_after
public IIrsServer getIrsProxy() {
    if (getmIrsProxy() == null) {
        final StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
        // don't try to start spm on uninitialized pool
        if (storagePool.getStatus() != StoragePoolStatus.Uninitialized) {
            String host = TransactionSupport.executeInScope(TransactionScopeOption.Suppress, new TransactionMethod<String>() {

                @Override
                public String runInTransaction() {
                    return gethostFromVds();
                }
            });
            if (host != null) {
                // Get the values of the timeouts:
                int clientTimeOut = Config.<Integer>GetValue(ConfigValues.vdsTimeout) * 1000;
                int connectionTimeOut = Config.<Integer>GetValue(ConfigValues.vdsConnectionTimeout) * 1000;
                int clientRetries = Config.<Integer>GetValue(ConfigValues.vdsRetries);
                Pair<IrsServerConnector, HttpClient> returnValue = XmlRpcUtils.getConnection(host, getmIrsPort(), clientTimeOut, connectionTimeOut, clientRetries, IrsServerConnector.class, Config.<Boolean>GetValue(ConfigValues.UseSecureConnectionWithServers));
                privatemIrsProxy = new IrsServerWrapper(returnValue.getFirst(), returnValue.getSecond());
                runStoragePoolUpEvent(storagePool);
            }
        }
    }
    return getmIrsProxy();
}
#end_block

#method_before
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getstatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getVdsSpmId(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#method_after
private String gethostFromVds() {
    _isSpmStartCalled = false;
    String returnValue = null;
    Guid curVdsId = (mCurrentVdsId != null) ? mCurrentVdsId : Guid.Empty;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool == null) {
        log.infoFormat("hostFromVds::Finished elect spm, storage pool {0} was removed", _storagePoolId);
        return null;
    }
    List<VDS> prioritizedVdsInPool = getPrioritizedVdsInPool();
    mCurrentVdsId = null;
    // If VDS is in initialize status, wait for it to be up (or until
    // configurable timeout is reached)
    waitForVdsIfIsInitializing(curVdsId);
    // update pool status to problematic while selecting spm
    StoragePoolStatus prevStatus = storagePool.getStatus();
    if (prevStatus != StoragePoolStatus.NonResponsive) {
        try {
            ResourceManager.getInstance().getEventListener().storagePoolStatusChange(_storagePoolId, StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC_SEARCHING_NEW_SPM, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
        } catch (RuntimeException ex) {
            throw new IRSStoragePoolStatusException(ex);
        }
    }
    VDS selectedVds = null;
    SpmStatusResult spmStatus = null;
    if (prioritizedVdsInPool != null && prioritizedVdsInPool.size() > 0) {
        selectedVds = prioritizedVdsInPool.get(0);
    } else if (!Guid.Empty.equals(curVdsId) && !getTriedVdssList().contains(curVdsId)) {
        selectedVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        if (selectedVds.getStatus() != VDSStatus.Up || selectedVds.getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
            selectedVds = null;
        }
    }
    if (selectedVds != null) {
        // Stores origin host id in case and will be needed to disconnect from storage pool
        Guid selectedVdsId = selectedVds.getId();
        Integer selectedVdsSpmId = selectedVds.getVdsSpmId();
        mTriedVdssList.add(selectedVdsId);
        VDSReturnValue returnValueFromVds = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId));
        spmStatus = (SpmStatusResult) returnValueFromVds.getReturnValue();
        if (spmStatus != null) {
            mCurrentVdsId = selectedVds.getId();
            boolean performedPoolConnect = false;
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            if (spmStatus.getSpmStatus() == SpmStatus.Unknown_Pool) {
                Guid masterId = DbFacade.getInstance().getStorageDomainDao().getMasterStorageDomainIdForPool(_storagePoolId);
                VDSReturnValue connectResult = ResourceManager.getInstance().runVdsCommand(VDSCommandType.ConnectStoragePool, new ConnectStoragePoolVDSCommandParameters(selectedVds.getId(), _storagePoolId, selectedVds.getVdsSpmId(), masterId, storagePool.getmaster_domain_version()));
                if (!connectResult.getSucceeded() && connectResult.getExceptionObject() instanceof IRSNoMasterDomainException) {
                    throw connectResult.getExceptionObject();
                } else if (!connectResult.getSucceeded()) {
                    // failover
                    throw new IRSNonOperationalException("Could not connect host to Data Center(Storage issue)");
                }
                performedPoolConnect = true;
                // refresh spmStatus result
                spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(selectedVds.getId(), _storagePoolId)).getReturnValue();
                log.infoFormat("hostFromVds::Connected host to pool - selectedVds - {0}, spmStatus {1}, storage pool {2}", selectedVds.getName(), spmStatus.getSpmStatus().toString(), storagePool.getName());
            }
            RefObject<VDS> tempRefObject = new RefObject<VDS>(selectedVds);
            spmStatus = handleSpmStatusResult(curVdsId, prioritizedVdsInPool, storagePool, tempRefObject, spmStatus);
            selectedVds = tempRefObject.argvalue;
            if (selectedVds != null) {
                RefObject<VDS> tempRefObject2 = new RefObject<VDS>(selectedVds);
                RefObject<SpmStatusResult> tempRefObject3 = new RefObject<SpmStatusResult>(spmStatus);
                returnValue = handleSelectedVdsForSPM(storagePool, tempRefObject2, tempRefObject3, prevStatus);
                selectedVds = tempRefObject2.argvalue;
                spmStatus = tempRefObject3.argvalue;
            } else {
                mCurrentVdsId = null;
            }
            if (performedPoolConnect && selectedVds == null) {
                // if could not start spm on this host and connected to
                // pool here
                // then disconnect
                ResourceManager.getInstance().runVdsCommand(VDSCommandType.DisconnectStoragePool, new DisconnectStoragePoolVDSCommandParameters(selectedVdsId, _storagePoolId, selectedVdsSpmId));
            }
        } else {
            log.infoFormat("hostFromVds::selectedVds - {0}, spmStatus returned null!", selectedVds.getName());
            if (returnValueFromVds.getExceptionObject() instanceof IRSNoMasterDomainException) {
                throw returnValueFromVds.getExceptionObject();
            }
        }
    }
    return returnValue;
}
#end_block

#method_before
private String handleSelectedVdsForSPM(StoragePool storagePool, RefObject<VDS> selectedVds, RefObject<SpmStatusResult> spmStatus, StoragePoolStatus prevStatus) {
    String returnValue = null;
    if (spmStatus.argvalue == null || spmStatus.argvalue.getSpmStatus() != SpmStatus.SPM) {
        movePoolToProblematicInDB(storagePool);
        selectedVds.argvalue = null;
        log.infoFormat("spm start treatment ended and status is not SPM!!! status: {0} - setting selectedVds to null!", spmStatus.argvalue.getSpmStatus().toString());
    } else {
        Init(selectedVds.argvalue);
        storagePool.setLVER(spmStatus.argvalue.getSpmLVER());
        storagePool.setspm_vds_id(selectedVds.argvalue.getId());
        // host move pool to up
        if (prevStatus != StoragePoolStatus.NotOperational && prevStatus != StoragePoolStatus.NonResponsive) {
            storagePool.setstatus(prevStatus);
        } else {
            storagePool.setstatus(StoragePoolStatus.Up);
        }
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getstatus());
        returnValue = selectedVds.argvalue.getHostName();
        log.infoFormat("Initialize Irs proxy from vds: {0}", returnValue);
        AuditLogableBase logable = new AuditLogableBase(selectedVds.argvalue.getId());
        logable.addCustomValue("ServerIp", returnValue);
        AuditLogDirector.log(logable, AuditLogType.IRS_HOSTED_ON_VDS);
    }
    return returnValue;
}
#method_after
private String handleSelectedVdsForSPM(StoragePool storagePool, RefObject<VDS> selectedVds, RefObject<SpmStatusResult> spmStatus, StoragePoolStatus prevStatus) {
    String returnValue = null;
    if (spmStatus.argvalue == null || spmStatus.argvalue.getSpmStatus() != SpmStatus.SPM) {
        movePoolToProblematicInDB(storagePool);
        selectedVds.argvalue = null;
        log.infoFormat("spm start treatment ended and status is not SPM!!! status: {0} - setting selectedVds to null!", spmStatus.argvalue.getSpmStatus().toString());
    } else {
        Init(selectedVds.argvalue);
        storagePool.setLVER(spmStatus.argvalue.getSpmLVER());
        storagePool.setspm_vds_id(selectedVds.argvalue.getId());
        // host move pool to up
        if (prevStatus != StoragePoolStatus.NotOperational && prevStatus != StoragePoolStatus.NonResponsive) {
            storagePool.setStatus(prevStatus);
        } else {
            storagePool.setStatus(StoragePoolStatus.Up);
        }
        DbFacade.getInstance().getStoragePoolDao().update(storagePool);
        ResourceManager.getInstance().getEventListener().storagePoolStatusChanged(storagePool.getId(), storagePool.getStatus());
        returnValue = selectedVds.argvalue.getHostName();
        log.infoFormat("Initialize Irs proxy from vds: {0}", returnValue);
        AuditLogableBase logable = new AuditLogableBase(selectedVds.argvalue.getId());
        logable.addCustomValue("ServerIp", returnValue);
        AuditLogDirector.log(logable, AuditLogType.IRS_HOSTED_ON_VDS);
    }
    return returnValue;
}
#end_block

#method_before
private void waitForVdsIfIsInitializing(Guid curVdsId) {
    if (!Guid.Empty.equals(curVdsId)) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        String vdsName = vds.getName();
        if (vds.getStatus() == VDSStatus.Initializing) {
            // 5 Sec
            final int DELAY = 5;
            int total = 0;
            Integer maxSecToWait = Config.GetValue(ConfigValues.WaitForVdsInitInSec);
            while (total <= maxSecToWait && DbFacade.getInstance().getVdsDynamicDao().get(curVdsId).getstatus() == VDSStatus.Initializing) {
                try {
                    Thread.sleep(DELAY * 1000);
                } catch (InterruptedException e) {
                    log.errorFormat("Interrupt exception {0}", e.getMessage());
                    // exit the while block
                    break;
                }
                total += DELAY;
                log.infoFormat("Waiting to Host {0} to finish initialization for {1} Sec.", vdsName, total);
            }
        }
    }
}
#method_after
private void waitForVdsIfIsInitializing(Guid curVdsId) {
    if (!Guid.Empty.equals(curVdsId)) {
        VDS vds = DbFacade.getInstance().getVdsDao().get(curVdsId);
        String vdsName = vds.getName();
        if (vds.getStatus() == VDSStatus.Initializing) {
            // 5 Sec
            final int DELAY = 5;
            int total = 0;
            Integer maxSecToWait = Config.GetValue(ConfigValues.WaitForVdsInitInSec);
            while (total <= maxSecToWait && DbFacade.getInstance().getVdsDynamicDao().get(curVdsId).getStatus() == VDSStatus.Initializing) {
                try {
                    Thread.sleep(DELAY * 1000);
                } catch (InterruptedException e) {
                    log.errorFormat("Interrupt exception {0}", e.getMessage());
                    // exit the while block
                    break;
                }
                total += DELAY;
                log.infoFormat("Waiting to Host {0} to finish initialization for {1} Sec.", vdsName, total);
            }
        }
    }
}
#end_block

#method_before
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setstatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getName(), storagePool.getName(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus != null && spmStatus.getSpmStatus() == SpmStatus.SPM) {
                _isSpmStartCalled = true;
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#method_after
private SpmStatusResult handleSpmStatusResult(Guid curVdsId, List<VDS> vdsByPool, final StoragePool storagePool, RefObject<VDS> selectedVds, SpmStatusResult spmStatus) {
    if (spmStatus.getSpmStatus() == SpmStatus.Free) {
        int vdsSpmIdToFence = -1;
        boolean startSpm = true;
        if (spmStatus.getSpmId() != -1) {
            int spmId = spmStatus.getSpmId();
            Guid spmVdsId = Guid.Empty;
            VDS spmVds = null;
            if (selectedVds.argvalue.getVdsSpmId() == spmId) {
                spmVdsId = selectedVds.argvalue.getId();
            } else {
                for (VDS tempVds : vdsByPool) {
                    if (tempVds.getVdsSpmId() == spmId) {
                        log.infoFormat("Found spm host {0}, host name: {1}, according to spmId: {2}.", tempVds.getId(), tempVds.getName(), spmId);
                        spmVds = tempVds;
                        break;
                    }
                }
                // non operational we want to find it as well
                if (spmVds == null) {
                    List<VDS> nonOperationalVds = DbFacade.getInstance().getVdsDao().getAllForStoragePoolAndStatus(_storagePoolId, VDSStatus.NonOperational);
                    for (VDS tempVds : nonOperationalVds) {
                        if (tempVds.getVdsSpmId() == spmId) {
                            spmVds = tempVds;
                            break;
                        }
                    }
                }
                if (spmVds != null) {
                    spmVdsId = spmVds.getId();
                } else if (!curVdsId.equals(Guid.Empty)) {
                    VDS currentVds = DbFacade.getInstance().getVdsDao().get(curVdsId);
                    if (currentVds != null && currentVds.getStatus() == VDSStatus.Up && currentVds.getVdsSpmId() != null && currentVds.getVdsSpmId().equals(spmId)) {
                        spmVdsId = curVdsId;
                        spmVds = currentVds;
                    }
                }
            }
            try {
                if (!spmVdsId.equals(Guid.Empty)) {
                    SpmStatusResult destSpmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStatus, new SpmStatusVDSCommandParameters(spmVdsId, _storagePoolId)).getReturnValue();
                    log.infoFormat("SpmStatus on vds {0}: {1}", spmVdsId, destSpmStatus == null ? "NULL" : destSpmStatus.getSpmStatus().toString());
                    /**
                     * intentional unreachable code
                     */
                    if (destSpmStatus != null && destSpmStatus.getSpmStatus() == SpmStatus.SPM) {
                        if (spmVdsId != selectedVds.argvalue.getId() && spmVds != null && spmVds.getStatus() == VDSStatus.Up) {
                            selectedVds.argvalue = spmVds;
                            startSpm = false;
                            log.infoFormat("Using old spm server: {0}, no start needed", spmVds.getName());
                            return destSpmStatus;
                        } else // VDS is non-operational and SPM
                        {
                            log.warn("Host reports to be SPM but is not up. " + spmVdsId);
                            vdsSpmIdToFence = spmStatus.getSpmId();
                        }
                    } else // it is not SPM and continue.
                    if (destSpmStatus == null || (destSpmStatus.getSpmStatus() != SpmStatus.Free && destSpmStatus.getSpmStatus() != SpmStatus.Unknown_Pool)) {
                        vdsSpmIdToFence = spmStatus.getSpmId();
                    }
                } else {
                    log.errorFormat("SPM Init: could not find reported vds or not up - pool:{0} vds_spm_id: {1}", storagePool.getName(), spmStatus.getSpmId());
                    vdsSpmIdToFence = spmStatus.getSpmId();
                }
            } catch (Exception ex) {
                vdsSpmIdToFence = spmStatus.getSpmId();
            }
        }
        if (startSpm) {
            vds_spm_id_map map = DbFacade.getInstance().getVdsSpmIdMapDao().get(_storagePoolId, vdsSpmIdToFence);
            if (map != null) {
                VDS vdsToFenceObject = DbFacade.getInstance().getVdsDao().get(map.getId());
                if (vdsToFenceObject != null) {
                    log.infoFormat("SPM selection - vds seems as spm {0}", vdsToFenceObject.getName());
                    if (vdsToFenceObject.getStatus() == VDSStatus.NonResponsive) {
                        log.warn("spm vds is non responsive, stopping spm selection.");
                        selectedVds.argvalue = null;
                        return spmStatus;
                    } else {
                        // try to stop spm
                        VDSReturnValue spmStopReturnValue = ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStop, new SpmStopVDSCommandParameters(vdsToFenceObject.getId(), _storagePoolId));
                        // continue with spm selection
                        if (spmStopReturnValue != null && spmStopReturnValue.getSucceeded()) {
                            log.info("spm stop succeeded, continuing with spm selection");
                        } else // if spm stop failed for any reason we stop spm
                        // selection
                        {
                            log.warn("spm stop on spm failed, stopping spm selection!");
                            selectedVds.argvalue = null;
                            return spmStatus;
                        }
                    }
                }
            }
            storagePool.setStatus(StoragePoolStatus.Contend);
            storagePool.setspm_vds_id(selectedVds.argvalue.getId());
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    DbFacade.getInstance().getStoragePoolDao().update(storagePool);
                    return null;
                }
            });
            log.infoFormat("starting spm on vds {0}, storage pool {1}, prevId {2}, LVER {3}", selectedVds.argvalue.getName(), storagePool.getName(), spmStatus.getSpmId(), spmStatus.getSpmLVER());
            spmStatus = (SpmStatusResult) ResourceManager.getInstance().runVdsCommand(VDSCommandType.SpmStart, new SpmStartVDSCommandParameters(selectedVds.argvalue.getId(), _storagePoolId, spmStatus.getSpmId(), spmStatus.getSpmLVER(), storagePool.getrecovery_mode(), vdsSpmIdToFence != -1, storagePool.getStoragePoolFormatType())).getReturnValue();
            if (spmStatus != null && spmStatus.getSpmStatus() == SpmStatus.SPM) {
                _isSpmStartCalled = true;
            } else {
                ResourceManager.getInstance().getEventListener().storagePoolStatusChange(storagePool.getId(), StoragePoolStatus.NonResponsive, AuditLogType.SYSTEM_CHANGE_STORAGE_POOL_STATUS_PROBLEMATIC, VdcBllErrors.ENGINE, TransactionScopeOption.RequiresNew);
                if (spmStatus != null) {
                    TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            StoragePool pool = DbFacade.getInstance().getStoragePoolDao().get(storagePool.getId());
                            pool.setspm_vds_id(null);
                            DbFacade.getInstance().getStoragePoolDao().update(pool);
                            return null;
                        }
                    });
                }
                throw new IrsSpmStartFailedException();
            }
        }
    }
    return spmStatus;
}
#end_block

#method_before
public void UpdateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getstatus() == StoragePoolStatus.Up || storagePool.getstatus() == StoragePoolStatus.NonResponsive)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setstatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in UpdateVdsDomainsData", ex);
        }
    }
    updateDomainInProblem(vdsId, vdsName, domainsInProblems);
}
#method_after
public void UpdateVdsDomainsData(final Guid vdsId, final String vdsName, final ArrayList<VDSDomainsData> data) {
    Set<Guid> domainsInProblems = null;
    StoragePool storagePool = DbFacade.getInstance().getStoragePoolDao().get(_storagePoolId);
    if (storagePool != null && (storagePool.getStatus() == StoragePoolStatus.Up || storagePool.getStatus() == StoragePoolStatus.NonResponsive)) {
        try {
            // build a list of all domains in pool
            // which are in status Active or Unknown
            Set<Guid> domainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Active));
            domainsInPool.addAll(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.Unknown));
            Set<Guid> inActiveDomainsInPool = new HashSet<Guid>(DbFacade.getInstance().getStorageDomainStaticDao().getAllIds(_storagePoolId, StorageDomainStatus.InActive));
            // build a list of all the domains in
            // pool (domainsInPool) that are not
            // visible by the host.
            List<Guid> domainsInPoolThatNonVisibleByVds = new ArrayList<Guid>();
            Set<Guid> dataDomainIds = new HashSet<Guid>();
            for (VDSDomainsData tempData : data) {
                dataDomainIds.add(tempData.getDomainId());
            }
            for (Guid tempDomainId : domainsInPool) {
                if (!dataDomainIds.contains(tempDomainId)) {
                    domainsInPoolThatNonVisibleByVds.add(tempDomainId);
                }
            }
            // build a list of domains that the host
            // reports as in problem (code!=0) or (code==0
            // && lastChecl >
            // ConfigValues.MaxStorageVdsTimeoutCheckSec)
            // and are contained in the Active or
            // Unknown domains in pool
            List<Guid> domainsSeenByVdsInProblem = new ArrayList<Guid>();
            for (VDSDomainsData tempData : data) {
                if (domainsInPool.contains(tempData.getDomainId())) {
                    if (isDomainReportedAsProblematic(tempData, false)) {
                        domainsSeenByVdsInProblem.add(tempData.getDomainId());
                    } else if (tempData.getDelay() > Config.<Double>GetValue(ConfigValues.MaxStorageVdsDelayCheckSec)) {
                        logDelayedDomain(vdsId, tempData);
                    }
                } else if (inActiveDomainsInPool.contains(tempData.getDomainId()) && !isDomainReportedAsProblematic(tempData, false)) {
                    log.warnFormat("Storage Domain {0} was reported by Host {1} as Active in Pool {2}, moving to active status", getDomainIdTuple(tempData.getDomainId()), vdsName, _storagePoolId);
                    StoragePoolIsoMap map = DbFacade.getInstance().getStoragePoolIsoMapDao().get(new StoragePoolIsoMapId(tempData.getDomainId(), _storagePoolId));
                    map.setStatus(StorageDomainStatus.Active);
                    DbFacade.getInstance().getStoragePoolIsoMapDao().update(map);
                }
            }
            // build a list of all potential domains
            // in problem
            domainsInProblems = new HashSet<Guid>();
            domainsInProblems.addAll(domainsInPoolThatNonVisibleByVds);
            domainsInProblems.addAll(domainsSeenByVdsInProblem);
        } catch (RuntimeException ex) {
            log.error("error in UpdateVdsDomainsData", ex);
        }
    }
    updateDomainInProblem(vdsId, vdsName, domainsInProblems);
}
#end_block

#method_before
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Set<Guid> domainsInProblems) {
    if (domainsInProblems != null) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
                updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
                return result;
            }
        });
    }
}
#method_after
private void updateDomainInProblem(final Guid vdsId, final String vdsName, final Set<Guid> domainsInProblems) {
    if (domainsInProblems != null) {
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventSync(new Event(_storagePoolId, null, vdsId, EventType.DOMAINMONITORING, ""), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                EventResult result = new EventResult(true, EventType.DOMAINMONITORING);
                updateProblematicVdsData(vdsId, vdsName, domainsInProblems);
                return result;
            }
        });
    }
}
#end_block

#method_before
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer(final Guid domainId) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            if (_domainsInProblem.containsKey(domainId)) {
                log.info("starting ProcessDomainRecovery for domain " + getDomainIdTuple(domainId));
                result = ProcessDomainRecovery(domainId);
            }
            _timers.remove(domainId);
            return result;
        }
    });
}
#method_after
@OnTimerMethodAnnotation("OnTimer")
public void OnTimer(final Guid domainId) {
    ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(_storagePoolId, domainId, null, EventType.DOMAINFAILOVER, ""), new Callable<EventResult>() {

        @Override
        public EventResult call() {
            EventResult result = null;
            if (_domainsInProblem.containsKey(domainId)) {
                log.info("starting ProcessDomainRecovery for domain " + getDomainIdTuple(domainId));
                result = ProcessDomainRecovery(domainId);
            }
            _timers.remove(domainId);
            return result;
        }
    });
}
#end_block

#method_before
protected IrsProxyData getCurrentIrsProxyData() {
    IrsProxyData returnValue;
    if (_irsProxyData.containsKey(getParameters().getStoragePoolId())) {
        returnValue = _irsProxyData.get(getParameters().getStoragePoolId());
    } else {
        _irsProxyData.put(getParameters().getStoragePoolId(), new IrsProxyData(getParameters().getStoragePoolId()));
        returnValue = _irsProxyData.get(getParameters().getStoragePoolId());
    }
    return returnValue;
}
#method_after
protected IrsProxyData getCurrentIrsProxyData() {
    if (!_irsProxyData.containsKey(getParameters().getStoragePoolId())) {
        _irsProxyData.put(getParameters().getStoragePoolId(), new IrsProxyData(getParameters().getStoragePoolId()));
    }
    return _irsProxyData.get(getParameters().getStoragePoolId());
}
#end_block

#method_before
@Override
protected void executeVDSCommand() {
    boolean isStartReconstruct = false;
    synchronized (getCurrentIrsProxyData().syncObj) {
        try {
            if (getIrsProxy() != null) {
                ExecuteIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(VdcBllErrors.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.errorFormat("IrsBroker::Failed::{0} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            log.errorFormat("Exception: {0}", ex.getMessage());
            if (getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSUnicodeArgumentException ex) {
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException ex) {
            throw ex;
        } catch (IrsOperationFailedNoFailoverException ex) {
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && VdcBllErrors.SpmStatusError == ex.getVdsError().getCode()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            getCurrentIrsProxyData().getTriedVdssList().clear();
        }
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#method_after
@Override
protected void executeVDSCommand() {
    boolean isStartReconstruct = false;
    synchronized (getCurrentIrsProxyData().syncObj) {
        try {
            if (getIrsProxy() != null) {
                executeIrsBrokerCommand();
            } else {
                if (getVDSReturnValue().getVdsError() == null) {
                    getVDSReturnValue().setExceptionString("Cannot allocate IRS server");
                    VDSError tempVar = new VDSError();
                    tempVar.setCode(VdcBllErrors.IRS_REPOSITORY_NOT_FOUND);
                    tempVar.setMessage("Cannot allocate IRS server");
                    getVDSReturnValue().setVdsError(tempVar);
                }
                getVDSReturnValue().setSucceeded(false);
            }
        } catch (UndeclaredThrowableException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(new VDSError(VdcBllErrors.VDS_NETWORK_ERROR, ex.getMessage()));
            if (ExceptionUtils.getRootCause(ex) != null) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (XmlRpcRunTimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex.isNetworkError()) {
                log.errorFormat("IrsBroker::Failed::{0} - network exception.", getCommandName());
                getVDSReturnValue().setSucceeded(false);
            } else {
                log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
                throw new IRSProtocolException(ex);
            }
        } catch (IRSNoMasterDomainException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            log.errorFormat("IrsBroker::Failed::{0}", getCommandName());
            log.errorFormat("Exception: {0}", ex.getMessage());
            if (getCurrentIrsProxyData().getHasVdssForSpmSelection()) {
                failover();
            } else {
                isStartReconstruct = true;
            }
        } catch (IRSUnicodeArgumentException ex) {
            throw new IRSGenericException("UNICODE characters are not supported.", ex);
        } catch (IRSStoragePoolStatusException | IrsOperationFailedNoFailoverException ex) {
            throw ex;
        } catch (IRSNonOperationalException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (ex.getVdsError() != null && VdcBllErrors.SpmStatusError == ex.getVdsError().getCode()) {
                getCurrentIrsProxyData().setCurrentVdsId(Guid.Empty);
            }
            failover();
        } catch (IRSErrorException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            getVDSReturnValue().setVdsError(ex.getVdsError());
            logException(ex);
            if (log.isDebugEnabled()) {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            failover();
        } catch (RuntimeException ex) {
            getVDSReturnValue().setExceptionString(ex.toString());
            getVDSReturnValue().setExceptionObject(ex);
            if (ex instanceof VDSExceptionBase) {
                getVDSReturnValue().setVdsError(((VDSExceptionBase) ex).getVdsError());
            }
            if (ExceptionUtils.getRootCause(ex) != null && ExceptionUtils.getRootCause(ex) instanceof SocketException) {
                logException(ExceptionUtils.getRootCause(ex));
            } else {
                LoggedUtils.logError(log, LoggedUtils.getObjectId(this), this, ex);
            }
            // always failover because of changes in vdsm error, until we
            // realize what to do in each case:
            failover();
        } finally {
            getCurrentIrsProxyData().getTriedVdssList().clear();
        }
    }
    if (isStartReconstruct) {
        startReconstruct();
    }
}
#end_block

#method_before
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getStorageDomainType() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId(), true);
            }
        });
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#method_after
private void startReconstruct() {
    StorageDomainStatic masterDomain = null;
    List<StorageDomainStatic> storageDomainStaticList = DbFacade.getInstance().getStorageDomainStaticDao().getAllForStoragePool(getParameters().getStoragePoolId());
    for (StorageDomainStatic storageDomainStatic : storageDomainStaticList) {
        if (storageDomainStatic.getStorageDomainType() == StorageDomainType.Master) {
            masterDomain = storageDomainStatic;
            break;
        }
    }
    if (masterDomain != null) {
        final Guid masterDomainId = masterDomain.getId();
        ((EventQueue) EjbUtils.findBean(BeanType.EVENTQUEUE_MANAGER, BeanProxyType.LOCAL)).submitEventAsync(new Event(getParameters().getStoragePoolId(), masterDomainId, null, EventType.RECONSTRUCT, "IrsBrokerCommand.startReconstruct()"), new Callable<EventResult>() {

            @Override
            public EventResult call() {
                return ResourceManager.getInstance().getEventListener().masterDomainNotOperational(masterDomainId, getParameters().getStoragePoolId(), true);
            }
        });
    } else {
        log.errorFormat("IrsBroker::IRSNoMasterDomainException:: Could not find master domain for pool {0} !!!", getParameters().getStoragePoolId());
    }
}
#end_block

#method_before
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
}
#method_after
@Override
protected void configure() {
    // Common stuff
    bindCommonPresenters();
    // Login section
    bindPresenter(LoginSectionPresenter.class, LoginSectionPresenter.ViewDef.class, LoginSectionView.class, LoginSectionPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(LoginPopupPresenterWidget.class, LoginPopupPresenterWidget.ViewDef.class, LoginPopupView.class);
    // Main section: common stuff
    bindPresenter(MainSectionPresenter.class, MainSectionPresenter.ViewDef.class, MainSectionView.class, MainSectionPresenter.ProxyDef.class);
    bindPresenter(MainContentPresenter.class, MainContentPresenter.ViewDef.class, MainContentView.class, MainContentPresenter.ProxyDef.class);
    bindSingletonPresenterWidget(HeaderPresenterWidget.class, HeaderPresenterWidget.ViewDef.class, HeaderView.class);
    bindSingletonPresenterWidget(SearchPanelPresenterWidget.class, SearchPanelPresenterWidget.ViewDef.class, SearchPanelView.class);
    bindSingletonPresenterWidget(AboutPopupPresenterWidget.class, AboutPopupPresenterWidget.ViewDef.class, AboutPopupView.class);
    bindSingletonPresenterWidget(ConfigurePopupPresenterWidget.class, ConfigurePopupPresenterWidget.ViewDef.class, ConfigurePopupView.class);
    bindPresenterWidget(RolePopupPresenterWidget.class, RolePopupPresenterWidget.ViewDef.class, RolePopupView.class);
    bindPresenterWidget(ClusterPolicyPopupPresenterWidget.class, ClusterPolicyPopupPresenterWidget.ViewDef.class, ClusterPolicyPopupView.class);
    // Main section: main tabs
    bindPresenter(MainTabPanelPresenter.class, MainTabPanelPresenter.ViewDef.class, MainTabPanelView.class, MainTabPanelPresenter.ProxyDef.class);
    bindPresenter(MainTabDataCenterPresenter.class, MainTabDataCenterPresenter.ViewDef.class, MainTabDataCenterView.class, MainTabDataCenterPresenter.ProxyDef.class);
    bindPresenter(MainTabClusterPresenter.class, MainTabClusterPresenter.ViewDef.class, MainTabClusterView.class, MainTabClusterPresenter.ProxyDef.class);
    bindPresenter(MainTabHostPresenter.class, MainTabHostPresenter.ViewDef.class, MainTabHostView.class, MainTabHostPresenter.ProxyDef.class);
    bindPresenter(MainTabNetworkPresenter.class, MainTabNetworkPresenter.ViewDef.class, MainTabNetworkView.class, MainTabNetworkPresenter.ProxyDef.class);
    bindPresenter(MainTabVnicProfilePresenter.class, MainTabVnicProfilePresenter.ViewDef.class, MainTabVnicProfileView.class, MainTabVnicProfilePresenter.ProxyDef.class);
    bindPresenter(MainTabProviderPresenter.class, MainTabProviderPresenter.ViewDef.class, MainTabProviderView.class, MainTabProviderPresenter.ProxyDef.class);
    bindPresenter(MainTabStoragePresenter.class, MainTabStoragePresenter.ViewDef.class, MainTabStorageView.class, MainTabStoragePresenter.ProxyDef.class);
    bindPresenter(MainTabVirtualMachinePresenter.class, MainTabVirtualMachinePresenter.ViewDef.class, MainTabVirtualMachineView.class, MainTabVirtualMachinePresenter.ProxyDef.class);
    bindPresenter(MainTabPoolPresenter.class, MainTabPoolPresenter.ViewDef.class, MainTabPoolView.class, MainTabPoolPresenter.ProxyDef.class);
    bindPresenter(MainTabTemplatePresenter.class, MainTabTemplatePresenter.ViewDef.class, MainTabTemplateView.class, MainTabTemplatePresenter.ProxyDef.class);
    bindPresenter(MainTabUserPresenter.class, MainTabUserPresenter.ViewDef.class, MainTabUserView.class, MainTabUserPresenter.ProxyDef.class);
    bindPresenter(MainTabEventPresenter.class, MainTabEventPresenter.ViewDef.class, MainTabEventView.class, MainTabEventPresenter.ProxyDef.class);
    bindPresenter(MainTabReportsPresenter.class, MainTabReportsPresenter.ViewDef.class, MainTabReportsView.class, MainTabReportsPresenter.ProxyDef.class);
    bindPresenter(MainTabQuotaPresenter.class, MainTabQuotaPresenter.ViewDef.class, MainTabQuotaView.class, MainTabQuotaPresenter.ProxyDef.class);
    bindPresenter(MainTabVolumePresenter.class, MainTabVolumePresenter.ViewDef.class, MainTabVolumeView.class, MainTabVolumePresenter.ProxyDef.class);
    bindPresenter(MainTabDiskPresenter.class, MainTabDiskPresenter.ViewDef.class, MainTabDiskView.class, MainTabDiskPresenter.ProxyDef.class);
    // Main section: sub tabs
    // DataCenter
    bindPresenter(DataCenterSubTabPanelPresenter.class, DataCenterSubTabPanelPresenter.ViewDef.class, DataCenterSubTabPanelView.class, DataCenterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterStoragePresenter.class, SubTabDataCenterStoragePresenter.ViewDef.class, SubTabDataCenterStorageView.class, SubTabDataCenterStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkPresenter.class, SubTabDataCenterNetworkPresenter.ViewDef.class, SubTabDataCenterNetworkView.class, SubTabDataCenterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterNetworkQoSPresenter.class, SubTabDataCenterNetworkQoSPresenter.ViewDef.class, SubTabDataCenterNetworkQoSView.class, SubTabDataCenterNetworkQoSPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterClusterPresenter.class, SubTabDataCenterClusterPresenter.ViewDef.class, SubTabDataCenterClusterView.class, SubTabDataCenterClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterQuotaPresenter.class, SubTabDataCenterQuotaPresenter.ViewDef.class, SubTabDataCenterQuotaView.class, SubTabDataCenterQuotaPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterPermissionPresenter.class, SubTabDataCenterPermissionPresenter.ViewDef.class, SubTabDataCenterPermissionView.class, SubTabDataCenterPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabDataCenterEventPresenter.class, SubTabDataCenterEventPresenter.ViewDef.class, SubTabDataCenterEventView.class, SubTabDataCenterEventPresenter.ProxyDef.class);
    bindPresenterWidget(RecoveryStoragePopupPresenterWidget.class, RecoveryStoragePopupPresenterWidget.ViewDef.class, RecoveryStorageConfirmationPopupView.class);
    // Storage
    bindPresenter(StorageSubTabPanelPresenter.class, StorageSubTabPanelPresenter.ViewDef.class, StorageSubTabPanelView.class, StorageSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageGeneralPresenter.class, SubTabStorageGeneralPresenter.ViewDef.class, SubTabStorageGeneralView.class, SubTabStorageGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDataCenterPresenter.class, SubTabStorageDataCenterPresenter.ViewDef.class, SubTabStorageDataCenterView.class, SubTabStorageDataCenterPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmBackupPresenter.class, SubTabStorageVmBackupPresenter.ViewDef.class, SubTabStorageVmBackupView.class, SubTabStorageVmBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplateBackupPresenter.class, SubTabStorageTemplateBackupPresenter.ViewDef.class, SubTabStorageTemplateBackupView.class, SubTabStorageTemplateBackupPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageVmPresenter.class, SubTabStorageVmPresenter.ViewDef.class, SubTabStorageVmView.class, SubTabStorageVmPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageTemplatePresenter.class, SubTabStorageTemplatePresenter.ViewDef.class, SubTabStorageTemplateView.class, SubTabStorageTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabStorageIsoPresenter.class, SubTabStorageIsoPresenter.ViewDef.class, SubTabStorageIsoView.class, SubTabStorageIsoPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageDiskPresenter.class, SubTabStorageDiskPresenter.ViewDef.class, SubTabStorageDiskView.class, SubTabStorageDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabStoragePermissionPresenter.class, SubTabStoragePermissionPresenter.ViewDef.class, SubTabStoragePermissionView.class, SubTabStoragePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabStorageEventPresenter.class, SubTabStorageEventPresenter.ViewDef.class, SubTabStorageEventView.class, SubTabStorageEventPresenter.ProxyDef.class);
    // Cluster
    bindPresenter(ClusterSubTabPanelPresenter.class, ClusterSubTabPanelPresenter.ViewDef.class, ClusterSubTabPanelView.class, ClusterSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGeneralPresenter.class, SubTabClusterGeneralPresenter.ViewDef.class, SubTabClusterGeneralView.class, SubTabClusterGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterHostPresenter.class, SubTabClusterHostPresenter.ViewDef.class, SubTabClusterHostView.class, SubTabClusterHostPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterVmPresenter.class, SubTabClusterVmPresenter.ViewDef.class, SubTabClusterVmView.class, SubTabClusterVmPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterNetworkPresenter.class, SubTabClusterNetworkPresenter.ViewDef.class, SubTabClusterNetworkView.class, SubTabClusterNetworkPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterServicePresenter.class, SubTabClusterServicePresenter.ViewDef.class, SubTabClusterServiceView.class, SubTabClusterServicePresenter.ProxyDef.class);
    bindPresenter(SubTabClusterGlusterHookPresenter.class, SubTabClusterGlusterHookPresenter.ViewDef.class, SubTabClusterGlusterHookView.class, SubTabClusterGlusterHookPresenter.ProxyDef.class);
    bindPresenter(SubTabClusterPermissionPresenter.class, SubTabClusterPermissionPresenter.ViewDef.class, SubTabClusterPermissionView.class, SubTabClusterPermissionPresenter.ProxyDef.class);
    // Host
    bindPresenter(HostSubTabPanelPresenter.class, HostSubTabPanelPresenter.ViewDef.class, HostSubTabPanelView.class, HostSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGeneralPresenter.class, SubTabHostGeneralPresenter.ViewDef.class, SubTabHostGeneralView.class, SubTabHostGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabHostHardwarePresenter.class, SubTabHostHardwarePresenter.ViewDef.class, SubTabHostHardwareView.class, SubTabHostHardwarePresenter.ProxyDef.class);
    bindPresenter(SubTabHostVmPresenter.class, SubTabHostVmPresenter.ViewDef.class, SubTabHostVmView.class, SubTabHostVmPresenter.ProxyDef.class);
    bindPresenter(SubTabHostInterfacePresenter.class, SubTabHostInterfacePresenter.ViewDef.class, SubTabHostInterfaceView.class, SubTabHostInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabHostHookPresenter.class, SubTabHostHookPresenter.ViewDef.class, SubTabHostHookView.class, SubTabHostHookPresenter.ProxyDef.class);
    bindPresenter(SubTabHostGlusterSwiftPresenter.class, SubTabHostGlusterSwiftPresenter.ViewDef.class, SubTabHostGlusterSwiftView.class, SubTabHostGlusterSwiftPresenter.ProxyDef.class);
    bindPresenter(SubTabHostPermissionPresenter.class, SubTabHostPermissionPresenter.ViewDef.class, SubTabHostPermissionView.class, SubTabHostPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabHostEventPresenter.class, SubTabHostEventPresenter.ViewDef.class, SubTabHostEventView.class, SubTabHostEventPresenter.ProxyDef.class);
    // VirtualMachine
    bindPresenter(VirtualMachineSubTabPanelPresenter.class, VirtualMachineSubTabPanelPresenter.ViewDef.class, VirtualMachineSubTabPanelView.class, VirtualMachineSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineGeneralPresenter.class, SubTabVirtualMachineGeneralPresenter.ViewDef.class, SubTabVirtualMachineGeneralView.class, SubTabVirtualMachineGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineNetworkInterfacePresenter.class, SubTabVirtualMachineNetworkInterfacePresenter.ViewDef.class, SubTabVirtualMachineNetworkInterfaceView.class, SubTabVirtualMachineNetworkInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineVirtualDiskPresenter.class, SubTabVirtualMachineVirtualDiskPresenter.ViewDef.class, SubTabVirtualMachineVirtualDiskView.class, SubTabVirtualMachineVirtualDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSnapshotPresenter.class, SubTabVirtualMachineSnapshotPresenter.ViewDef.class, SubTabVirtualMachineSnapshotView.class, SubTabVirtualMachineSnapshotPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineApplicationPresenter.class, SubTabVirtualMachineApplicationPresenter.ViewDef.class, SubTabVirtualMachineApplicationView.class, SubTabVirtualMachineApplicationPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachinePermissionPresenter.class, SubTabVirtualMachinePermissionPresenter.ViewDef.class, SubTabVirtualMachinePermissionView.class, SubTabVirtualMachinePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineSessionsPresenter.class, SubTabVirtualMachineSessionsPresenter.ViewDef.class, SubTabVirtualMachineSessionsView.class, SubTabVirtualMachineSessionsPresenter.ProxyDef.class);
    bindPresenter(SubTabVirtualMachineEventPresenter.class, SubTabVirtualMachineEventPresenter.ViewDef.class, SubTabVirtualMachineEventView.class, SubTabVirtualMachineEventPresenter.ProxyDef.class);
    // Pool
    bindPresenter(PoolSubTabPanelPresenter.class, PoolSubTabPanelPresenter.ViewDef.class, PoolSubTabPanelView.class, PoolSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolGeneralPresenter.class, SubTabPoolGeneralPresenter.ViewDef.class, SubTabPoolGeneralView.class, SubTabPoolGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolVmPresenter.class, SubTabPoolVmPresenter.ViewDef.class, SubTabPoolVmView.class, SubTabPoolVmPresenter.ProxyDef.class);
    bindPresenter(SubTabPoolPermissionPresenter.class, SubTabPoolPermissionPresenter.ViewDef.class, SubTabPoolPermissionView.class, SubTabPoolPermissionPresenter.ProxyDef.class);
    bindPresenterWidget(PoolNewPopupPresenterWidget.class, PoolNewPopupPresenterWidget.ViewDef.class, PoolNewPopupView.class);
    bindPresenterWidget(PoolEditPopupPresenterWidget.class, PoolEditPopupPresenterWidget.ViewDef.class, PoolEditPopupView.class);
    // Template
    bindPresenter(TemplateSubTabPanelPresenter.class, TemplateSubTabPanelPresenter.ViewDef.class, TemplateSubTabPanelView.class, TemplateSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateGeneralPresenter.class, SubTabTemplateGeneralPresenter.ViewDef.class, SubTabTemplateGeneralView.class, SubTabTemplateGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateVmPresenter.class, SubTabTemplateVmPresenter.ViewDef.class, SubTabTemplateVmView.class, SubTabTemplateVmPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateInterfacePresenter.class, SubTabTemplateInterfacePresenter.ViewDef.class, SubTabTemplateInterfaceView.class, SubTabTemplateInterfacePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateDiskPresenter.class, SubTabTemplateDiskPresenter.ViewDef.class, SubTabTemplateDiskView.class, SubTabTemplateDiskPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateStoragePresenter.class, SubTabTemplateStoragePresenter.ViewDef.class, SubTabTemplateStorageView.class, SubTabTemplateStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabTemplatePermissionPresenter.class, SubTabTemplatePermissionPresenter.ViewDef.class, SubTabTemplatePermissionView.class, SubTabTemplatePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabTemplateEventPresenter.class, SubTabTemplateEventPresenter.ViewDef.class, SubTabTemplateEventView.class, SubTabTemplateEventPresenter.ProxyDef.class);
    // User
    bindPresenter(UserSubTabPanelPresenter.class, UserSubTabPanelPresenter.ViewDef.class, UserSubTabPanelView.class, UserSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGeneralPresenter.class, SubTabUserGeneralPresenter.ViewDef.class, SubTabUserGeneralView.class, SubTabUserGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabUserPermissionPresenter.class, SubTabUserPermissionPresenter.ViewDef.class, SubTabUserPermissionView.class, SubTabUserPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventNotifierPresenter.class, SubTabUserEventNotifierPresenter.ViewDef.class, SubTabUserEventNotifierView.class, SubTabUserEventNotifierPresenter.ProxyDef.class);
    bindPresenter(SubTabUserEventPresenter.class, SubTabUserEventPresenter.ViewDef.class, SubTabUserEventView.class, SubTabUserEventPresenter.ProxyDef.class);
    bindPresenter(SubTabUserGroupPresenter.class, SubTabUserGroupPresenter.ViewDef.class, SubTabUserGroupView.class, SubTabUserGroupPresenter.ProxyDef.class);
    bindPresenter(SubTabUserQuotaPresenter.class, SubTabUserQuotaPresenter.ViewDef.class, SubTabUserQuotaView.class, SubTabUserQuotaPresenter.ProxyDef.class);
    // Quota
    bindPresenter(QuotaSubTabPanelPresenter.class, QuotaSubTabPanelPresenter.ViewDef.class, QuotaSubTabPanelView.class, QuotaSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaClusterPresenter.class, SubTabQuotaClusterPresenter.ViewDef.class, SubTabQuotaClusterView.class, SubTabQuotaClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaStoragePresenter.class, SubTabQuotaStoragePresenter.ViewDef.class, SubTabQuotaStorageView.class, SubTabQuotaStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaVmPresenter.class, SubTabQuotaVmPresenter.ViewDef.class, SubTabQuotaVmView.class, SubTabQuotaVmPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaTemplatePresenter.class, SubTabQuotaTemplatePresenter.ViewDef.class, SubTabQuotaTemplateView.class, SubTabQuotaTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaUserPresenter.class, SubTabQuotaUserPresenter.ViewDef.class, SubTabQuotaUserView.class, SubTabQuotaUserPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaPermissionPresenter.class, SubTabQuotaPermissionPresenter.ViewDef.class, SubTabQuotaPermissionView.class, SubTabQuotaPermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabQuotaEventPresenter.class, SubTabQuotaEventPresenter.ViewDef.class, SubTabQuotaEventView.class, SubTabQuotaEventPresenter.ProxyDef.class);
    // Disk
    bindPresenter(DiskSubTabPanelPresenter.class, DiskSubTabPanelPresenter.ViewDef.class, DiskSubTabPanelView.class, DiskSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskGeneralPresenter.class, SubTabDiskGeneralPresenter.ViewDef.class, SubTabDiskGeneralView.class, SubTabDiskGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskVmPresenter.class, SubTabDiskVmPresenter.ViewDef.class, SubTabDiskVmView.class, SubTabDiskVmPresenter.ProxyDef.class);
    bindPresenter(SubTabDiskTemplatePresenter.class, SubTabDiskTemplatePresenter.ViewDef.class, SubTabDiskTemplateView.class, SubTabDiskTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskStoragePresenter.class, SubTabDiskStoragePresenter.ViewDef.class, SubTabDiskStorageView.class, SubTabDiskStoragePresenter.ProxyDef.class);
    bindPresenter(SubTabDiskPermissionPresenter.class, SubTabDiskPermissionPresenter.ViewDef.class, SubTabDiskPermissionView.class, SubTabDiskPermissionPresenter.ProxyDef.class);
    // Network
    bindPresenter(NetworkSubTabPanelPresenter.class, NetworkSubTabPanelPresenter.ViewDef.class, NetworkSubTabPanelView.class, NetworkSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkGeneralPresenter.class, SubTabNetworkGeneralPresenter.ViewDef.class, SubTabNetworkGeneralView.class, SubTabNetworkGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkProfilePresenter.class, SubTabNetworkProfilePresenter.ViewDef.class, SubTabNetworkProfileView.class, SubTabNetworkProfilePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkClusterPresenter.class, SubTabNetworkClusterPresenter.ViewDef.class, SubTabNetworkClusterView.class, SubTabNetworkClusterPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkHostPresenter.class, SubTabNetworkHostPresenter.ViewDef.class, SubTabNetworkHostView.class, SubTabNetworkHostPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkVmPresenter.class, SubTabNetworkVmPresenter.ViewDef.class, SubTabNetworkVmView.class, SubTabNetworkVmPresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkTemplatePresenter.class, SubTabNetworkTemplatePresenter.ViewDef.class, SubTabNetworkTemplateView.class, SubTabNetworkTemplatePresenter.ProxyDef.class);
    bindPresenter(SubTabNetworkPermissionPresenter.class, SubTabNetworkPermissionPresenter.ViewDef.class, SubTabNetworkPermissionView.class, SubTabNetworkPermissionPresenter.ProxyDef.class);
    // Provider
    bindPresenter(ProviderSubTabPanelPresenter.class, ProviderSubTabPanelPresenter.ViewDef.class, ProviderSubTabPanelView.class, ProviderSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderGeneralPresenter.class, SubTabProviderGeneralPresenter.ViewDef.class, SubTabProviderGeneralView.class, SubTabProviderGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabProviderNetworkPresenter.class, SubTabProviderNetworkPresenter.ViewDef.class, SubTabProviderNetworkView.class, SubTabProviderNetworkPresenter.ProxyDef.class);
    // Profile
    bindPresenter(VnicProfileSubTabPanelPresenter.class, VnicProfileSubTabPanelPresenter.ViewDef.class, VnicProfileSubTabPanelView.class, VnicProfileSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfilePermissionPresenter.class, SubTabVnicProfilePermissionPresenter.ViewDef.class, SubTabVnicProfilePermissionView.class, SubTabVnicProfilePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileVmPresenter.class, SubTabVnicProfileVmPresenter.ViewDef.class, SubTabVnicProfileVmView.class, SubTabVnicProfileVmPresenter.ProxyDef.class);
    bindPresenter(SubTabVnicProfileTemplatePresenter.class, SubTabVnicProfileTemplatePresenter.ViewDef.class, SubTabVnicProfileTemplateView.class, SubTabVnicProfileTemplatePresenter.ProxyDef.class);
    // Main section: popups
    // Permissions
    bindPresenterWidget(PermissionsPopupPresenterWidget.class, PermissionsPopupPresenterWidget.ViewDef.class, PermissionsPopupView.class);
    bindPresenterWidget(SystemPermissionsRemoveConfirmationPopupPresenterWidget.class, SystemPermissionsRemoveConfirmationPopupPresenterWidget.ViewDef.class, SystemPermissionsRemoveConfirmationPopupView.class);
    // Bookmarks
    bindPresenterWidget(BookmarkPopupPresenterWidget.class, BookmarkPopupPresenterWidget.ViewDef.class, BookmarkPopupView.class);
    // Tags
    bindPresenterWidget(TagPopupPresenterWidget.class, TagPopupPresenterWidget.ViewDef.class, TagPopupView.class);
    // Guide
    bindPresenterWidget(GuidePopupPresenterWidget.class, GuidePopupPresenterWidget.ViewDef.class, GuidePopupView.class);
    bindPresenterWidget(MoveHostPopupPresenterWidget.class, MoveHostPopupPresenterWidget.ViewDef.class, MoveHostPopupView.class);
    // DataCenter
    bindPresenterWidget(DataCenterPopupPresenterWidget.class, DataCenterPopupPresenterWidget.ViewDef.class, DataCenterPopupView.class);
    bindPresenterWidget(FindMultiStoragePopupPresenterWidget.class, FindMultiStoragePopupPresenterWidget.ViewDef.class, FindMultiStoragePopupView.class);
    bindPresenterWidget(FindSingleStoragePopupPresenterWidget.class, FindSingleStoragePopupPresenterWidget.ViewDef.class, FindSingleStoragePopupView.class);
    bindPresenterWidget(NewDataCenterNetworkPopupPresenterWidget.class, NewDataCenterNetworkPopupPresenterWidget.ViewDef.class, NewDataCenterNetworkPopupView.class);
    bindPresenterWidget(EditDataCenterNetworkPopupPresenterWidget.class, EditDataCenterNetworkPopupPresenterWidget.ViewDef.class, EditDataCenterNetworkPopupView.class);
    bindPresenterWidget(DataCenterForceRemovePopupPresenterWidget.class, DataCenterForceRemovePopupPresenterWidget.ViewDef.class, DataCenterForceRemovePopupView.class);
    // Cluster
    bindPresenterWidget(NewClusterNetworkPopupPresenterWidget.class, NewClusterNetworkPopupPresenterWidget.ViewDef.class, NewClusterNetworkPopupView.class);
    bindPresenterWidget(ClusterManageNetworkPopupPresenterWidget.class, ClusterManageNetworkPopupPresenterWidget.ViewDef.class, ClusterManageNetworkPopupView.class);
    bindPresenterWidget(ClusterPopupPresenterWidget.class, ClusterPopupPresenterWidget.ViewDef.class, ClusterPopupView.class);
    bindPresenterWidget(VolumePopupPresenterWidget.class, VolumePopupPresenterWidget.ViewDef.class, VolumePopupView.class);
    bindPresenterWidget(DetachGlusterHostsPopupPresenterWidget.class, DetachGlusterHostsPopupPresenterWidget.ViewDef.class, DetachGlusterHostsPopupView.class);
    bindPresenterWidget(GlusterHookContentPopupPresenterWidget.class, GlusterHookContentPopupPresenterWidget.ViewDef.class, GlusterHookContentPopupView.class);
    bindPresenterWidget(GlusterHookResolveConflictsPopupPresenterWidget.class, GlusterHookResolveConflictsPopupPresenterWidget.ViewDef.class, GlusterHookResolveConflictsPopupView.class);
    bindPresenterWidget(VolumeRebalanceStatusPopupPresenterWidget.class, VolumeRebalanceStatusPopupPresenterWidget.ViewDef.class, VolumeRebalanceStatusPopupView.class);
    bindPresenterWidget(ManageGlusterSwiftPopupPresenterWidget.class, ManageGlusterSwiftPopupPresenterWidget.ViewDef.class, ManageGlusterSwiftPopupView.class);
    // Host
    bindPresenterWidget(HostPopupPresenterWidget.class, HostPopupPresenterWidget.ViewDef.class, HostPopupView.class);
    bindPresenterWidget(HostInstallPopupPresenterWidget.class, HostInstallPopupPresenterWidget.ViewDef.class, HostInstallPopupView.class);
    bindPresenterWidget(HostInterfacePopupPresenterWidget.class, HostInterfacePopupPresenterWidget.ViewDef.class, HostInterfacePopupView.class);
    bindPresenterWidget(SetupNetworksInterfacePopupPresenterWidget.class, SetupNetworksInterfacePopupPresenterWidget.ViewDef.class, SetupNetworksInterfacePopupView.class);
    bindPresenterWidget(HostManagementPopupPresenterWidget.class, HostManagementPopupPresenterWidget.ViewDef.class, HostManagementPopupView.class);
    bindPresenterWidget(SetupNetworksManagementPopupPresenterWidget.class, SetupNetworksManagementPopupPresenterWidget.ViewDef.class, SetupNetworksManagementPopupView.class);
    bindPresenterWidget(HostBondPopupPresenterWidget.class, HostBondPopupPresenterWidget.ViewDef.class, HostBondPopupView.class);
    bindPresenterWidget(SetupNetworksBondPopupPresenterWidget.class, SetupNetworksBondPopupPresenterWidget.ViewDef.class, SetupNetworksBondPopupView.class);
    bindPresenterWidget(HostSetupNetworksPopupPresenterWidget.class, HostSetupNetworksPopupPresenterWidget.ViewDef.class, HostSetupNetworksPopupView.class);
    bindPresenterWidget(DetachConfirmationPopupPresenterWidget.class, DetachConfirmationPopupPresenterWidget.ViewDef.class, DetachConfirmationPopupView.class);
    bindPresenterWidget(ManualFencePopupPresenterWidget.class, ManualFencePopupPresenterWidget.ViewDef.class, ManualFenceConfirmationPopupView.class);
    bindPresenterWidget(ConfigureLocalStoragePopupPresenterWidget.class, ConfigureLocalStoragePopupPresenterWidget.ViewDef.class, HostConfigureLocalStoragePopupView.class);
    bindPresenterWidget(HostManagementConfirmationPopupPresenterWidget.class, HostManagementConfirmationPopupPresenterWidget.ViewDef.class, HostManagementConfirmationPopupView.class);
    bindPresenterWidget(MultipleHostsPopupPresenterWidget.class, MultipleHostsPopupPresenterWidget.ViewDef.class, MultipleHostsPopupView.class);
    // Storage
    bindPresenterWidget(StoragePopupPresenterWidget.class, StoragePopupPresenterWidget.ViewDef.class, StoragePopupView.class);
    bindPresenterWidget(FindMultiDcPopupPresenterWidget.class, FindMultiDcPopupPresenterWidget.ViewDef.class, FindMultiDcPopupView.class);
    bindPresenterWidget(FindSingleDcPopupPresenterWidget.class, FindSingleDcPopupPresenterWidget.ViewDef.class, FindSingleDcPopupView.class);
    bindPresenterWidget(ImportVmPopupPresenterWidget.class, ImportVmPopupPresenterWidget.ViewDef.class, ImportVmPopupView.class);
    bindPresenterWidget(ImportTemplatePopupPresenterWidget.class, ImportTemplatePopupPresenterWidget.ViewDef.class, ImportTemplatePopupView.class);
    bindPresenterWidget(ImportCloneDialogPresenterWidget.class, ImportCloneDialogPresenterWidget.ViewDef.class, ImportCloneDialogPopupView.class);
    bindPresenterWidget(DisksAllocationPopupPresenterWidget.class, DisksAllocationPopupPresenterWidget.ViewDef.class, DisksAllocationPopupView.class);
    bindPresenterWidget(ChangeQuotaPopupPresenterWidget.class, ChangeQuotaPopupPresenterWidget.ViewDef.class, ChangeQuotaPopupView.class);
    bindPresenterWidget(ImportExportImagePopupPresenterWidget.class, ImportExportImagePopupPresenterWidget.ViewDef.class, ImportExportImagePopupView.class);
    // Storage Remove
    bindPresenterWidget(StorageRemovePopupPresenterWidget.class, StorageRemovePopupPresenterWidget.ViewDef.class, StorageRemovePopupView.class);
    // Storage Destroy
    bindPresenterWidget(StorageDestroyPopupPresenterWidget.class, StorageDestroyPopupPresenterWidget.ViewDef.class, StorageDestroyPopupView.class);
    bindPresenterWidget(StorageForceCreatePopupPresenterWidget.class, StorageForceCreatePopupPresenterWidget.ViewDef.class, StorageForceCreatePopupView.class);
    bindPresenterWidget(VmPopupPresenterWidget.class, VmPopupPresenterWidget.ViewDef.class, VmPopupView.class);
    // VM Snapshot Create
    bindPresenterWidget(VmSnapshotCreatePopupPresenterWidget.class, VmSnapshotCreatePopupPresenterWidget.ViewDef.class, VmSnapshotCreatePopupView.class);
    // VM Snapshot Preview
    bindPresenterWidget(VmSnapshotPreviewPopupPresenterWidget.class, VmSnapshotPreviewPopupPresenterWidget.ViewDef.class, VmSnapshotPreviewPopupView.class);
    // VM Clone from Snapshot
    bindPresenterWidget(VmClonePopupPresenterWidget.class, VmClonePopupPresenterWidget.ViewDef.class, VmClonePopupView.class);
    // VM Assign Tags
    bindPresenterWidget(AssignTagsPopupPresenterWidget.class, AssignTagsPopupPresenterWidget.ViewDef.class, AssignTagsPopupView.class);
    // VM RunOnce
    bindPresenterWidget(VmRunOncePopupPresenterWidget.class, VmRunOncePopupPresenterWidget.ViewDef.class, VmRunOncePopupView.class);
    // VM Make Template
    bindPresenterWidget(VmMakeTemplatePopupPresenterWidget.class, VmMakeTemplatePopupPresenterWidget.ViewDef.class, VmMakeTemplatePopupView.class);
    // VM Change CD
    bindPresenterWidget(VmChangeCDPopupPresenterWidget.class, VmChangeCDPopupPresenterWidget.ViewDef.class, VmChangeCDPopupView.class);
    // VM Migrate
    bindPresenterWidget(VmMigratePopupPresenterWidget.class, VmMigratePopupPresenterWidget.ViewDef.class, VmMigratePopupView.class);
    // VM Export
    bindPresenterWidget(VmExportPopupPresenterWidget.class, VmExportPopupPresenterWidget.ViewDef.class, VmExportPopupView.class);
    // VM Remove
    bindPresenterWidget(VmRemovePopupPresenterWidget.class, VmRemovePopupPresenterWidget.ViewDef.class, VmRemovePopupView.class);
    // VM VNC info
    bindPresenterWidget(VncInfoPopupPresenterWidget.class, VncInfoPopupPresenterWidget.ViewDef.class, VncInfoPopupView.class);
    // VM Add/Edit Interface
    bindPresenterWidget(VmInterfacePopupPresenterWidget.class, VmInterfacePopupPresenterWidget.ViewDef.class, VmInterfacePopupView.class);
    // VM Add/Edit Disk
    bindPresenterWidget(VmDiskPopupPresenterWidget.class, VmDiskPopupPresenterWidget.ViewDef.class, VmDiskPopupView.class);
    // VM Detach/Remove Disk
    bindPresenterWidget(VmDiskRemovePopupPresenterWidget.class, VmDiskRemovePopupPresenterWidget.ViewDef.class, VmDiskRemovePopupView.class);
    // Edit Template
    bindPresenterWidget(TemplateNewPresenterWidget.class, TemplateNewPresenterWidget.ViewDef.class, TemplateNewPopupView.class);
    // Add/Edit Template's NIC
    bindPresenterWidget(TemplateInterfacePopupPresenterWidget.class, TemplateInterfacePopupPresenterWidget.ViewDef.class, TemplateInterfacePopupView.class);
    // Users Manage Events
    bindPresenterWidget(ManageEventsPopupPresenterWidget.class, ManageEventsPopupPresenterWidget.ViewDef.class, ManageEventsPopupView.class);
    // Reports
    bindPresenterWidget(ReportPresenterWidget.class, ReportPresenterWidget.ViewDef.class, ReportView.class);
    // Quota
    bindPresenterWidget(QuotaPopupPresenterWidget.class, QuotaPopupPresenterWidget.ViewDef.class, QuotaPopupView.class);
    // Network QoS
    bindPresenterWidget(NetworkQoSPopupPresenterWidget.class, NetworkQoSPopupPresenterWidget.ViewDef.class, NetworkQoSPopupView.class);
    bindPresenterWidget(EditQuotaClusterPopupPresenterWidget.class, EditQuotaClusterPopupPresenterWidget.ViewDef.class, EditQuotaClusterPopupView.class);
    bindPresenterWidget(EditQuotaStoragePopupPresenterWidget.class, EditQuotaStoragePopupPresenterWidget.ViewDef.class, EditQuotaStoragePopupView.class);
    // Volume
    bindPresenter(VolumeSubTabPanelPresenter.class, VolumeSubTabPanelPresenter.ViewDef.class, VolumeSubTabPanelView.class, VolumeSubTabPanelPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeGeneralPresenter.class, SubTabVolumeGeneralPresenter.ViewDef.class, SubTabVolumeGeneralView.class, SubTabVolumeGeneralPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeBrickPresenter.class, SubTabVolumeBrickPresenter.ViewDef.class, SubTabVolumeBrickView.class, SubTabVolumeBrickPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeParameterPresenter.class, SubTabVolumeParameterPresenter.ViewDef.class, SubTabVolumeParameterView.class, SubTabVolumeParameterPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumePermissionPresenter.class, SubTabVolumePermissionPresenter.ViewDef.class, SubTabVolumePermissionView.class, SubTabVolumePermissionPresenter.ProxyDef.class);
    bindPresenter(SubTabVolumeEventPresenter.class, SubTabVolumeEventPresenter.ViewDef.class, SubTabVolumeEventView.class, SubTabVolumeEventPresenter.ProxyDef.class);
    bindPresenterWidget(AddBrickPopupPresenterWidget.class, AddBrickPopupPresenterWidget.ViewDef.class, AddBrickPopupView.class);
    bindPresenterWidget(ReplaceBrickPopupPresenterWidget.class, ReplaceBrickPopupPresenterWidget.ViewDef.class, ReplaceBrickPopupView.class);
    bindPresenterWidget(BrickAdvancedDetailsPopupPresenterWidget.class, BrickAdvancedDetailsPopupPresenterWidget.ViewDef.class, BrickAdvancedDetailsPopupView.class);
    bindPresenterWidget(VolumeParameterPopupPresenterWidget.class, VolumeParameterPopupPresenterWidget.ViewDef.class, VolumeParameterPopupView.class);
    // Network
    bindPresenterWidget(NewNetworkPopupPresenterWidget.class, NewNetworkPopupPresenterWidget.ViewDef.class, NewNetworkPopupView.class);
    bindPresenterWidget(EditNetworkPopupPresenterWidget.class, EditNetworkPopupPresenterWidget.ViewDef.class, EditNetworkPopupView.class);
    // Event
    bindPresenterWidget(EventPopupPresenterWidget.class, EventPopupPresenterWidget.ViewDef.class, EventPopupView.class);
    // Provider
    bindPresenterWidget(ProviderPopupPresenterWidget.class, ProviderPopupPresenterWidget.ViewDef.class, ProviderPopupView.class);
    bindPresenterWidget(ImportNetworksPopupPresenterWidget.class, ImportNetworksPopupPresenterWidget.ViewDef.class, ImportNetworksPopupView.class);
    // Profile
    bindPresenterWidget(VnicProfilePopupPresenterWidget.class, VnicProfilePopupPresenterWidget.ViewDef.class, VnicProfilePopupView.class);
}
#end_block

#method_before
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
}
#method_after
public static void initCache(LoginModel loginModel) {
    AsyncDataProvider.cacheConfigValues(new AsyncQuery(loginModel, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            getDefaultConfigurationVersion(target);
        }
    }));
    initOsNames();
    initUniqueOsNames();
    initLinuxOsTypes();
    initWindowsOsTypes();
    initHasSpiceSupport();
}
#end_block

#method_before
public static void hasSpiceSupport(int osId, Version version, AsyncQuery callback) {
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.HasSpiceSupport, osId, version), callback);
}
#method_after
public static Boolean hasSpiceSupport(int osId, Version version) {
    return spiceSupportMatrix.get(osId).get(version);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#method_after
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#end_block

#method_before
@Provides
@Singleton
public SearchableDetailModelProvider<permissions, VolumeListModel, PermissionListModel> getVolumePermissionListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<PermissionsPopupPresenterWidget> popupProvider, final Provider<RemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<permissions, VolumeListModel, PermissionListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class, PermissionListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(PermissionListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAddCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(PermissionListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#method_after
@Provides
@Singleton
public SearchableDetailModelProvider<permissions, VolumeListModel, PermissionListModel> getVolumePermissionListProvider(EventBus eventBus, Provider<DefaultConfirmationPopupPresenterWidget> defaultConfirmPopupProvider, final Provider<PermissionsPopupPresenterWidget> popupProvider, final Provider<RolePermissionsRemoveConfirmationPopupPresenterWidget> removeConfirmPopupProvider) {
    return new SearchableDetailTabModelProvider<permissions, VolumeListModel, PermissionListModel>(eventBus, defaultConfirmPopupProvider, VolumeListModel.class, PermissionListModel.class) {

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends Model, ?> getModelPopup(PermissionListModel source, UICommand lastExecutedCommand, Model windowModel) {
            if (lastExecutedCommand == getModel().getAddCommand()) {
                return popupProvider.get();
            } else {
                return super.getModelPopup(source, lastExecutedCommand, windowModel);
            }
        }

        @Override
        public AbstractModelBoundPopupPresenterWidget<? extends ConfirmationModel, ?> getConfirmModelPopup(PermissionListModel source, UICommand lastExecutedCommand) {
            if (lastExecutedCommand == getModel().getRemoveCommand()) {
                return removeConfirmPopupProvider.get();
            } else {
                return super.getConfirmModelPopup(source, lastExecutedCommand);
            }
        }
    };
}
#end_block

#method_before
private void localize(final ApplicationConstants constants) {
    startedTimeEditor.setLabel(constants.rebalanceStartTime());
    volumeEditor.setLabel(constants.rebalanceVolumeName());
    clusterEditor.setLabel(constants.rebalanceClusterVolume());
    statusTimeEditor.setLabel(constants.rebalanceStatusTime());
}
#method_after
private void localize(final ApplicationConstants constants) {
    startedTimeEditor.setLabel(constants.rebalanceStartTime());
    volumeEditor.setLabel(constants.rebalanceVolumeName());
    clusterEditor.setLabel(constants.rebalanceClusterVolume());
    statusTimeEditor.setLabel(constants.rebalanceStatusTime());
    statusLabel.setText(constants.rebalanceComplete());
    statusLabel.setVisible(false);
}
#end_block

#method_before
void initEditors(ApplicationConstants constants) {
    rebalanceHostsTable = new EntityModelCellTable<ListModel>(false, true);
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getHostName();
        }
    }, constants.rebalanceSessionHost());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getFilesMoved() + "";
        }
    }, constants.rebalanceFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            long size = entity.getTotalSizeMoved();
            if (size > (1024 * 1024 * 1024)) {
                entity.setTotalSizeMoved(bytesToGbs(entity.getTotalSizeMoved()));
                // $NON-NLS-1$
                return entity.getTotalSizeMoved() + " gb";
            } else if (size > (1024 * 1024)) {
                entity.setTotalSizeMoved(bytesToMbs(entity.getTotalSizeMoved()));
                // $NON-NLS-1$
                return entity.getTotalSizeMoved() + " mb";
            } else if (size > 1024) {
                entity.setTotalSizeMoved(bytesToKbs(entity.getTotalSizeMoved()));
                // $NON-NLS-1$
                return entity.getTotalSizeMoved() + " kb";
            } else {
                // $NON-NLS-1$
                return entity.getTotalSizeMoved() + " bytes";
            }
        }
    }, constants.rebalanceSize());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesFailed());
        }
    }, constants.rebalanceFailedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesSkipped());
        }
    }, constants.rebalanceSkippedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesScanned());
        }
    }, constants.rebalanceScannedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getRunTime());
        }
    }, constants.rebalanceRunTime());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getStatus().toString();
        }
    }, constants.rebalanceStatus());
}
#method_after
void initEditors(ApplicationConstants constants) {
    rebalanceHostsTable = new EntityModelCellTable<ListModel>(false, true);
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getHostName();
        }
    }, constants.rebalanceSessionHost());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getFilesMoved() + "";
        }
    }, constants.rebalanceFileCount());
    rebalanceHostsTable.addEntityModelColumn(new RebalanceFileSizeColumn<EntityModel>(messages) {

        @Override
        protected Long getRawValue(EntityModel object) {
            return ((GlusterVolumeTaskStatusForHost) (object.getEntity())).getTotalSizeMoved();
        }
    }, constants.rebalanceSize());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesFailed());
        }
    }, constants.rebalanceFailedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesSkipped());
        }
    }, constants.rebalanceSkippedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getFilesScanned());
        }
    }, constants.rebalanceScannedFileCount());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return String.valueOf(entity.getRunTime());
        }
    }, constants.rebalanceRunTime());
    rebalanceHostsTable.addEntityModelColumn(new EntityModelTextColumn<GlusterVolumeTaskStatusForHost>() {

        @Override
        protected String getText(GlusterVolumeTaskStatusForHost entity) {
            return entity.getStatus().toString();
        }
    }, constants.rebalanceStatus());
}
#end_block

#method_before
@Override
public void edit(final VolumeRebalanceStatusModel object) {
    driver.edit(object);
    rebalanceHostsTable.asEditor().edit(object.getRebalanceSessions());
}
#method_after
@Override
public void edit(final VolumeRebalanceStatusModel object) {
    driver.edit(object);
    rebalanceHostsTable.asEditor().edit(object.getRebalanceSessions());
    object.getPropertyChangedEvent().addListener(new IEventListener() {

        @Override
        public void eventRaised(Event ev, Object sender, EventArgs args) {
            PropertyChangedEventArgs e = (PropertyChangedEventArgs) args;
            if (e.PropertyName.equals("IS_STATUS_APPLICABLE")) {
                // $NON-NLS-1$
                statusLabel.setVisible(object.isStatusAvailable());
            }
        }
    });
}
#end_block

#method_before
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            allowStartRebalance = allowStartRebalance && (volume.getAsyncTask() == null || Guid.isNullOrEmpty(volume.getAsyncTask().getTaskId()));
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowStopRebalance = true;
    boolean allowStatusRebalance = true;
    boolean allowOptimize = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowStopRebalance = false;
        allowStatusRebalance = false;
        allowOptimize = false;
    } else {
        for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
                allowStopRebalance = false;
            }
            allowStartRebalance = allowStartRebalance && (volume.getAsyncTask() == null || Guid.isNullOrEmpty(volume.getAsyncTask().getTaskId()));
            allowStopRebalance = allowStopRebalance && (volume.getAsyncTask() != null && volume.getAsyncTask().getStatus() != null && volume.getAsyncTask().getStatus() == JobExecutionStatus.STARTED);
        }
        allowStatusRebalance = getRebalanceStatusAvailability(getSelectedItems());
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getStopRebalanceCommand().setIsExecutionAllowed(allowStopRebalance);
    getStatusRebalanceCommand().setIsExecutionAllowed(allowStatusRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("rebalanceNotStarted")) {
        // $NON-NLS-1$
        setConfirmWindow(null);
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getStopRebalanceCommand())) {
        stopRebalance();
    } else if (command.getName().equals("onStopRebalance")) {
        // $NON-NLS-1$
        onStopRebalance();
    } else if (command.equals(getStatusRebalanceCommand())) {
        showRebalanceStatus();
    } else if (command.getName().equals("CancelRebalanceStatus")) {
        // $NON-NLS-1$
        cancelRebalanceStatus();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    }
}
#end_block

#method_before
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
    rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
    setWindow(rebalanceStatusModel);
    rebalanceStatusModel.showStatusDetails();
    // $NON-NLS-1$
    UICommand command = new UICommand("CancelRebalanceStatus", this);
    command.setTitle(ConstantsManager.getInstance().getConstants().close());
    command.setIsCancel(true);
    rebalanceStatusModel.getCommands().add(command);
}
#method_after
private void showRebalanceStatus() {
    if (getSelectedItem() == null) {
        return;
    }
    final ConfirmationModel cModel = new ConfirmationModel();
    final GlusterVolumeEntity volumeEntity = (GlusterVolumeEntity) getSelectedItem();
    setConfirmWindow(cModel);
    cModel.setTitle(ConstantsManager.getInstance().getConstants().rebalanceStatusTitle());
    // $NON-NLS-1$
    cModel.startProgress(ConstantsManager.getInstance().getConstants().rebalanceStatusFetchMessage());
    // $NON-NLS-1$
    final UICommand rebalanceStatusOk = new UICommand("rebalanceNotStarted", VolumeListModel.this);
    rebalanceStatusOk.setTitle(ConstantsManager.getInstance().getConstants().ok());
    rebalanceStatusOk.setIsCancel(true);
    AsyncDataProvider.getGlusterRebalanceStatus(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            GlusterVolumeTaskStatusEntity rebalanceStatusEntity = (GlusterVolumeTaskStatusEntity) returnValue;
            cModel.stopProgress();
            if ((rebalanceStatusEntity == null) || (rebalanceStatusEntity.getStatusSummary().getStatus() == JobExecutionStatus.UNKNOWN)) {
                cModel.setMessage(ConstantsManager.getInstance().getMessages().rebalanceStatusConfirmationMessage(volumeEntity.getName()));
                cModel.getCommands().add(rebalanceStatusOk);
            } else {
                setConfirmWindow(null);
                VolumeRebalanceStatusModel rebalanceStatusModel = new VolumeRebalanceStatusModel(volumeEntity);
                rebalanceStatusModel.setTitle(ConstantsManager.getInstance().getConstants().volumeRebalanceStatusTitle());
                setWindow(rebalanceStatusModel);
                rebalanceStatusModel.getVolume().setEntity(volumeEntity.getName());
                rebalanceStatusModel.getCluster().setEntity(volumeEntity.getVdsGroupName());
                rebalanceStatusModel.showStatus(rebalanceStatusEntity);
                // $NON-NLS-1$
                UICommand cancelRebalance = new UICommand("CancelRebalanceStatus", VolumeListModel.this);
                cancelRebalance.setTitle(ConstantsManager.getInstance().getConstants().close());
                cancelRebalance.setIsCancel(true);
                rebalanceStatusModel.getCommands().add(cancelRebalance);
            }
        }
    }), volumeEntity.getClusterId(), volumeEntity.getId());
}
#end_block

#method_before
private void cancelRebalanceStatus() {
    if (getWindow() == null) {
        return;
    }
    VolumeRebalanceStatusModel model = (VolumeRebalanceStatusModel) getWindow();
    model.stopRebalanceRefresh();
    cancel();
}
#method_after
private void cancelRebalanceStatus() {
    if (getWindow() == null) {
        return;
    }
    cancel();
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> transportColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            StringBuilder transportTypes = new StringBuilder();
            Iterator<TransportType> iterator = object.getTransportTypes().iterator();
            while (iterator.hasNext()) {
                TransportType transportType = iterator.next();
                if (transportTypeTranslator.containsKey(transportType)) {
                    transportTypes.append(transportTypeTranslator.get(transportType));
                } else {
                    transportTypes.append(transportType.toString());
                }
                if (iterator.hasNext()) {
                    // $NON-NLS-1$
                    transportTypes.append(", ");
                }
            }
            return transportTypes.toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(transportColumn, constants.transportTypesVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> statusColumn = new EnumColumn<GlusterVolumeEntity, GlusterStatus>() {

        @Override
        protected GlusterStatus getRawValue(GlusterVolumeEntity object) {
            return object.getStatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVolume(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> rebalanceSubActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    rebalanceSubActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    rebalanceSubActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.statusRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStatusRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume(), rebalanceSubActions, CommandLocation.ContextAndToolBar));
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> transportColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            StringBuilder transportTypes = new StringBuilder();
            Iterator<TransportType> iterator = object.getTransportTypes().iterator();
            while (iterator.hasNext()) {
                TransportType transportType = iterator.next();
                if (transportTypeTranslator.containsKey(transportType)) {
                    transportTypes.append(transportTypeTranslator.get(transportType));
                } else {
                    transportTypes.append(transportType.toString());
                }
                if (iterator.hasNext()) {
                    // $NON-NLS-1$
                    transportTypes.append(", ");
                }
            }
            return transportTypes.toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(transportColumn, constants.transportTypesVolume(), "150px");
    // $NON-NLS-1$
    getTable().addColumn(new VolumeActivityColumn(), constants.activitiesOnVolume(), "100px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> rebalanceSubActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    rebalanceSubActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    rebalanceSubActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopRebalanceCommand();
        }
    });
    rebalanceSubActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.statusRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStatusRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume(), rebalanceSubActions, CommandLocation.ContextAndToolBar));
}
#end_block

#method_before
protected void updateDefaultHost() {
    VDSGroup cluster = getModel().getSelectedCluster();
    if (cluster == null) {
        getModel().getDefaultHost().setItems(new ArrayList<VDS>());
        getModel().getDefaultHost().setSelectedItem(null);
        return;
    }
    AsyncQuery query = new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                // $NON-NLS-1$
                throw new IllegalArgumentException("The return value should be ArrayList<VDS> or VdcQueryReturnValue with return value ArrayList<VDS>");
            }
            VDS oldDefaultHost = (VDS) model.getDefaultHost().getSelectedItem();
            if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (VDS vds : hosts) {
                    if (host.getId().equals(vds.getId())) {
                        model.getDefaultHost().setItems(new ArrayList<VDS>(Arrays.asList(new VDS[] { vds })));
                        model.getDefaultHost().setSelectedItem(vds);
                        model.getDefaultHost().setIsChangable(false);
                        // $NON-NLS-1$
                        model.getDefaultHost().setInfo("Cannot choose other Host in tree context");
                        break;
                    }
                }
            } else {
                model.getDefaultHost().setItems(hosts);
                model.getDefaultHost().setSelectedItem(oldDefaultHost != null ? Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldDefaultHost.getId())) : Linq.firstOrDefault(hosts));
            }
            changeDefualtHost();
        }
    }, getModel().getHash());
    getHostListByCluster(cluster, query);
}
#method_after
protected void updateDefaultHost() {
    VDSGroup cluster = getModel().getSelectedCluster();
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    if (cluster == null) {
        getModel().getDefaultHost().setItems(new ArrayList<VDS>());
        getModel().getDefaultHost().setSelectedItem(null);
        return;
    }
    AsyncQuery query = new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                // $NON-NLS-1$
                throw new IllegalArgumentException("The return value should be ArrayList<VDS> or VdcQueryReturnValue with return value ArrayList<VDS>");
            }
            VDS oldDefaultHost = (VDS) model.getDefaultHost().getSelectedItem();
            if (model.getBehavior().getSystemTreeSelectedItem() != null && model.getBehavior().getSystemTreeSelectedItem().getType() == SystemTreeItemType.Host) {
                VDS host = (VDS) model.getBehavior().getSystemTreeSelectedItem().getEntity();
                for (VDS vds : hosts) {
                    if (host.getId().equals(vds.getId())) {
                        model.getDefaultHost().setItems(new ArrayList<VDS>(Arrays.asList(new VDS[] { vds })));
                        model.getDefaultHost().setSelectedItem(vds);
                        model.getDefaultHost().setIsChangable(false);
                        model.getDefaultHost().setChangeProhibitionReason(constants.cannotChangeHostInTreeContext());
                        break;
                    }
                }
            } else {
                model.getDefaultHost().setItems(hosts);
                model.getDefaultHost().setSelectedItem(oldDefaultHost != null ? Linq.firstOrDefault(hosts, new Linq.HostPredicate(oldDefaultHost.getId())) : Linq.firstOrDefault(hosts));
            }
            changeDefualtHost();
        }
    }, getModel().getHash());
    getHostListByCluster(cluster, query);
}
#end_block

#method_before
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        String compatibilityVersion = cluster.getcompatibility_version().toString();
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity());
        if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinningEnabled, compatibilityVersion))) {
            hasCpuPinning = false;
        } else if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinMigrationEnabled, AsyncDataProvider.getDefaultConfigurationVersion())) && isVmMigratable()) {
            hasCpuPinning = false;
        }
        getModel().getCpuPinning().setIsChangable(hasCpuPinning);
        if (!hasCpuPinning) {
            getModel().getCpuPinning().setEntity("");
        }
    }
}
#method_after
protected void updateCpuPinningVisibility() {
    if (getModel().getSelectedCluster() != null) {
        VDSGroup cluster = getModel().getSelectedCluster();
        String compatibilityVersion = cluster.getcompatibility_version().toString();
        boolean hasCpuPinning = Boolean.FALSE.equals(getModel().getIsAutoAssign().getEntity());
        if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinningEnabled, compatibilityVersion))) {
            hasCpuPinning = false;
        } else if (Boolean.FALSE.equals(AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.CpuPinMigrationEnabled, AsyncDataProvider.getDefaultConfigurationVersion())) && isVmMigratable()) {
            hasCpuPinning = false;
        }
        if (!hasCpuPinning) {
            getModel().getCpuPinning().setChangeProhibitionReason(constants.cpuPinningUnavailable());
            getModel().getCpuPinning().setEntity("");
        }
        getModel().getCpuPinning().setIsChangable(hasCpuPinning);
    }
}
#end_block

#method_before
private void initRunVmCommand() {
    RunVmParams runVmParameters = getParameters();
    if (!StringUtils.isEmpty(runVmParameters.getDiskPath())) {
        _cdImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getDiskPath(), getVm().getStoragePoolId());
    }
    if (!StringUtils.isEmpty(runVmParameters.getFloppyPath())) {
        _floppyImagePath = ImagesHandler.cdPathWindowsToLinux(runVmParameters.getFloppyPath(), getVm().getStoragePoolId());
    }
    if (getVm() != null) {
        refreshBootParameters(runVmParameters);
        getVm().setLastStartTime(new Date());
        // set vm disks
        VmHandler.updateDisksForVm(getVm(), getDiskDao().getAllForVm(getVm().getId()));
        if (getVm().getStatus() != VMStatus.Suspended) {
            memorySnapshotSupported = FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion());
            // If the VM is not hibernated, save the hibernation volume from the baseline snapshot
            memoryVolumeFromSnapshot = getActiveSnapshot().getMemoryVolume();
        }
    }
}
#method_after
private void initRunVmCommand() {
    RunVmParams runVmParameters = getParameters();
    if (getVm() != null) {
        refreshBootParameters(runVmParameters);
        getVm().setLastStartTime(new Date());
        // set vm disks
        VmHandler.updateDisksForVm(getVm(), getDiskDao().getAllForVm(getVm().getId()));
        if (getVm().getStatus() != VMStatus.Suspended) {
            memorySnapshotSupported = FeatureSupported.memorySnapshot(getVm().getVdsGroupCompatibilityVersion());
            // If the VM is not hibernated, save the hibernation volume from the baseline snapshot
            memoryVolumeFromSnapshot = getActiveSnapshot().getMemoryVolume();
        }
    }
}
#end_block

#method_before
protected String getIsoPrefixFilePath(String url) {
    String isoPrefixName = "iso://";
    // The initial Url.
    String fullPathFileName = url;
    // If file name got prefix of iso:// then set the path to the Iso domain.
    int prefixLength = isoPrefixName.length();
    if (url.length() >= prefixLength && (url.substring(0, prefixLength)).equalsIgnoreCase(isoPrefixName)) {
        fullPathFileName = cdPathWindowsToLinux(url.substring(prefixLength, url.length()));
    }
    return fullPathFileName;
}
#method_after
protected String getIsoPrefixFilePath(String url) {
    // The initial Url.
    String fullPathFileName = url;
    // If file name got prefix of iso:// then set the path to the Iso domain.
    int prefixLength = ISO_PREFIX.length();
    if (url.length() >= prefixLength && (url.substring(0, prefixLength)).equalsIgnoreCase(ISO_PREFIX)) {
        fullPathFileName = cdPathWindowsToLinux(url.substring(prefixLength));
    }
    return fullPathFileName;
}
#end_block

#method_before
protected String cdPathWindowsToLinux(String url) {
    return ImagesHandler.cdPathWindowsToLinux(url, getVm().getStoragePoolId());
}
#method_after
protected String cdPathWindowsToLinux(String url) {
    return ImagesHandler.cdPathWindowsToLinux(url, getVm().getStoragePoolId(), getVdsId());
}
#end_block

#method_before
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            VmHandler.UpdateVmGuestAgentVersion(getVm());
            incrementVdsPendingVmsCount();
            attachCd();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Failed to run desktop {0}, rerun", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#method_after
protected void runVm() {
    setActionReturnValue(VMStatus.Down);
    if (getVdsToRunOn()) {
        VMStatus status = null;
        try {
            VmHandler.updateVmGuestAgentVersion(getVm());
            incrementVdsPendingVmsCount();
            if (connectLunDisks(getVdsId())) {
                status = createVm();
                ExecutionHandler.setAsyncJob(getExecutionContext(), true);
            }
        } catch (VdcBLLException e) {
            VdcBllErrors errorCode = e.getErrorCode();
            // re-throw it. otherwise, continue (the vm will be down and a re-run will be triggered)
            switch(errorCode) {
                // should never get here with errorCode = 'Done' though
                case Done:
                case exist:
                // probably wrong xml format sent.
                case VDS_NETWORK_ERROR:
                case PROVIDER_FAILURE:
                    throw e;
                default:
                    log.warnFormat("Failed to run VM {0}: {1}", getVmName(), e.getMessage());
            }
        } finally {
            freeLock();
            decrementVdsPendingVmsCount();
        }
        setActionReturnValue(status);
        if (status != null && (status.isRunning() || status == VMStatus.RestoringState)) {
            setSucceeded(true);
        } else {
            // Try to rerun Vm on different vds no need to log the command because it is
            // being logged inside the rerun
            log.infoFormat("Trying to rerun VM {0}", getVm().getName());
            setCommandShouldBeLogged(false);
            setSucceeded(true);
            rerun();
        }
    } else {
        failedToRunVm();
        setSucceeded(false);
        _isRerun = false;
    }
}
#end_block

#method_before
protected VMStatus createVm() {
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    getVm().setLastStartTime(new Date());
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, initCreateVmParams(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotIrrelevant = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#method_after
protected VMStatus createVm() {
    // reevaluate boot parameters if VM was executed with 'run once'
    refreshBootParameters(getParameters());
    getVm().setLastStartTime(new Date());
    getVm().setCdPath(cdPathWindowsToLinux(chooseCd()));
    if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
        getVm().setFloppyPath(cdPathWindowsToLinux(getParameters().getFloppyPath()));
    }
    // Set path for initrd and kernel image.
    if (!StringUtils.isEmpty(getVm().getInitrdUrl())) {
        getVm().setInitrdUrl(getIsoPrefixFilePath(getVm().getInitrdUrl()));
    }
    if (!StringUtils.isEmpty(getVm().getKernelUrl())) {
        getVm().setKernelUrl(getIsoPrefixFilePath(getVm().getKernelUrl()));
    }
    VMStatus vmStatus = (VMStatus) getBackend().getResourceManager().RunAsyncVdsCommand(VDSCommandType.CreateVm, initCreateVmParams(), this).getReturnValue();
    // Don't use the memory from the active snapshot anymore if there's a chance that disks were changed
    memoryFromSnapshotIrrelevant = vmStatus.isRunning() || vmStatus == VMStatus.RestoringState;
    // After VM was create (or not), we can remove the quota vds group memory.
    return vmStatus;
}
#end_block

#method_before
protected CreateVmVDSCommandParameters initCreateVmParams() {
    VM vmToBeCreated = getVm();
    if (!vmToBeCreated.getInterfaces().isEmpty()) {
        initParametersForExternalNetworks();
    }
    if (vmToBeCreated.getStatus() == VMStatus.Suspended) {
        return new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    }
    if (!memorySnapshotSupported || memoryFromSnapshotIrrelevant) {
        vmToBeCreated.setHibernationVolHandle(StringUtils.EMPTY);
        return new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    }
    // otherwise, use the memory that is saved on the active snapshot (might be empty)
    vmToBeCreated.setHibernationVolHandle(memoryVolumeFromSnapshot);
    CreateVmVDSCommandParameters parameters = new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    // Mark that the hibernation volume should be cleared from the VM right after the sync part of
    // the create verb is finished (unlike hibernation volume that is created by hibernate command)
    parameters.setClearHibernationVolumes(true);
    return parameters;
}
#method_after
protected CreateVmVDSCommandParameters initCreateVmParams() {
    VM vmToBeCreated = getVm();
    vmToBeCreated.setRunOnce(false);
    if (!vmToBeCreated.getInterfaces().isEmpty()) {
        initParametersForExternalNetworks();
    }
    if (vmToBeCreated.getStatus() == VMStatus.Suspended) {
        return new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    }
    if (!memorySnapshotSupported || memoryFromSnapshotIrrelevant) {
        vmToBeCreated.setHibernationVolHandle(StringUtils.EMPTY);
        return new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    }
    // otherwise, use the memory that is saved on the active snapshot (might be empty)
    vmToBeCreated.setHibernationVolHandle(memoryVolumeFromSnapshot);
    CreateVmVDSCommandParameters parameters = new CreateVmVDSCommandParameters(getVdsId(), vmToBeCreated);
    // Mark that the hibernation volume should be cleared from the VM right after the sync part of
    // the create verb is finished (unlike hibernation volume that is created by hibernate command)
    parameters.setClearHibernationVolumes(true);
    return parameters;
}
#end_block

#method_before
protected void initParametersForExternalNetworks() {
    Map<String, Network> clusterNetworks = Entities.entitiesByName(getDbFacade().getNetworkDao().getAllForCluster(getVm().getVdsGroupId()));
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(getDbFacade().getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        String networkName = iface.getNetworkName();
        Network network = (networkName == null) ? null : clusterNetworks.get(networkName);
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.getIsPlugged()) {
            Provider<?> provider = getDbFacade().getProviderDao().get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, iface);
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice, deviceProperties);
        }
    }
}
#method_after
protected void initParametersForExternalNetworks() {
    Map<VmDeviceId, VmDevice> nicDevices = Entities.businessEntitiesById(getDbFacade().getVmDeviceDao().getVmDeviceByVmIdAndType(getVmId(), VmDeviceGeneralType.INTERFACE));
    for (VmNic iface : getVm().getInterfaces()) {
        Network network = NetworkHelper.getNetworkByVnicProfileId(iface.getVnicProfileId());
        VmDevice vmDevice = nicDevices.get(new VmDeviceId(iface.getId(), getVmId()));
        if (network != null && network.isExternal() && vmDevice.getIsPlugged()) {
            Provider<?> provider = getDbFacade().getProviderDao().get(network.getProvidedBy().getProviderId());
            NetworkProviderProxy providerProxy = ProviderProxyFactory.getInstance().create(provider);
            Map<String, String> deviceProperties = providerProxy.allocate(network, iface);
            getVm().getRuntimeDeviceCustomProperties().put(vmDevice, deviceProperties);
        }
    }
}
#end_block

#method_before
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                return getSucceeded() ? (isStatelessSnapshotExistsForVm() ? AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS : AuditLogType.VDS_INITIATED_RUN_VM) : AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getDedicatedVmForVds() != null && !getVm().getRunOnVds().equals(getVm().getDedicatedVmForVds()) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : isRunAndPaused() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isVmRunningStateless() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isVmRunningStateless() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#method_after
@Override
public AuditLogType getAuditLogTypeValue() {
    switch(getActionState()) {
        case EXECUTE:
            if (isFailedStatlessSnapshot) {
                return AuditLogType.USER_RUN_VM_FAILURE_STATELESS_SNAPSHOT_LEFT;
            }
            if (mResume) {
                return getSucceeded() ? AuditLogType.USER_RESUME_VM : AuditLogType.USER_FAILED_RESUME_VM;
            } else if (isInternalExecution()) {
                if (getSucceeded()) {
                    boolean isStateless = isStatelessSnapshotExistsForVm();
                    boolean isVdsKnown = getVds() != null;
                    if (isStateless && isVdsKnown) {
                        return AuditLogType.VDS_INITIATED_RUN_VM_AS_STATELESS;
                    } else if (isStateless) {
                        return AuditLogType.VDS_INITIATED_RUN_AS_STATELESS_VM_NOT_YET_RUNNING;
                    } else {
                        return AuditLogType.VDS_INITIATED_RUN_VM;
                    }
                }
                return AuditLogType.VDS_INITIATED_RUN_VM_FAILED;
            } else {
                return getSucceeded() ? (VMStatus) getActionReturnValue() == VMStatus.Up ? getParameters() != null && getParameters().getDestinationVdsId() == null && getVm().getDedicatedVmForVds() != null && !getVm().getRunOnVds().equals(getVm().getDedicatedVmForVds()) ? AuditLogType.USER_RUN_VM_ON_NON_DEFAULT_VDS : (isStatelessSnapshotExistsForVm() ? AuditLogType.USER_RUN_VM_AS_STATELESS : AuditLogType.USER_RUN_VM) : _isRerun ? AuditLogType.VDS_INITIATED_RUN_VM : getTaskIdList().size() > 0 ? AuditLogType.USER_INITIATED_RUN_VM : getVm().isRunAndPause() ? AuditLogType.USER_INITIATED_RUN_VM_AND_PAUSE : AuditLogType.USER_STARTED_VM : _isRerun ? AuditLogType.USER_INITIATED_RUN_VM_FAILED : AuditLogType.USER_FAILED_RUN_VM;
            }
        case END_SUCCESS:
            // command should be with 'CommandShouldBeLogged = false':
            return isVmRunningStateless() && !getSucceeded() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        case END_FAILURE:
            // be with 'CommandShouldBeLogged = false':
            return isVmRunningStateless() ? AuditLogType.USER_RUN_VM_AS_STATELESS_FINISHED_FAILURE : AuditLogType.UNASSIGNED;
        default:
            // false':
            return AuditLogType.UNASSIGNED;
    }
}
#end_block

#method_before
protected boolean initVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getStatus() == VMStatus.ImageIllegal) || (getVm().getStatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getStatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getStatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        handleMemoryAdjustments();
        handleTimeZone();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setCdPath(_cdImagePath);
        getVm().setFloppyPath(_floppyImagePath);
        getVm().setKvmEnable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
        getVm().setAcpiEnable(getParameters().getAcpiEnable());
        // Clear the first user:
        getVm().setConsoleUserId(null);
        getParameters().setRunAsStateless(getParameters().getRunAsStateless() != null ? getParameters().getRunAsStateless() : getVm().isStateless());
        getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
        (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
        getVm().setInitializationType(getParameters().getInitializationType());
        // if we attach floppy we don't need the sysprep
        if (!StringUtils.isEmpty(getVm().getFloppyPath())) {
            getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        return true;
    }
}
#method_after
protected boolean initVm() {
    if (getVm() == null) {
        log.warnFormat("ResourceManager::{0}::No such vm (where id = '{1}' )in database", getClass().getName(), getVmId().toString());
        throw new VdcBLLException(VdcBllErrors.DB_NO_SUCH_VM);
    }
    if ((getVm().getStatus() == VMStatus.ImageIllegal) || (getVm().getStatus() == VMStatus.ImageLocked)) {
        log.warnFormat("ResourceManager::{0}::vm '{1}' has {2}", getClass().getName(), getVmId().toString(), (getVm().getStatus() == VMStatus.ImageLocked ? "a locked image" : "an illegal image"));
        setActionReturnValue(getVm().getStatus());
        return false;
    } else if (!getSnapshotsValidator().vmNotDuringSnapshot(getVmId()).isValid()) {
        log.warnFormat("ResourceManager::{0}::VM {1} is during snapshot", getClass().getName(), getVmId().toString());
        return false;
    } else {
        handleMemoryAdjustments();
        VmHandler.updateDisksFromDb(getVm());
        getVm().setKvmEnable(getParameters().getKvmEnable());
        getVm().setRunAndPause(getParameters().getRunAndPause() == null ? getVm().isRunAndPause() : getParameters().getRunAndPause());
        getVm().setAcpiEnable(getParameters().getAcpiEnable());
        // Clear the first user:
        getVm().setConsoleUserId(null);
        getParameters().setRunAsStateless(getParameters().getRunAsStateless() != null ? getParameters().getRunAsStateless() : getVm().isStateless());
        getVm().setDisplayType(getParameters().getUseVnc() == null ? getVm().getDefaultDisplayType() : // the VM can run with display type which is different from its default display type
        (getParameters().getUseVnc() ? DisplayType.vnc : DisplayType.qxl));
        if (getParameters().getInitializationType() == null) {
            // if vm not initialized, use sysprep/cloud-init
            if (!getVm().isInitialized()) {
                getVm().setInitializationType(osRepository.isWindows(getVm().getVmOsId()) ? InitializationType.Sysprep : InitializationType.CloudInit);
            }
        } else {
            getVm().setInitializationType(getParameters().getInitializationType());
        }
        // if we attach floppy we don't need the sysprep
        if (!StringUtils.isEmpty(getParameters().getFloppyPath())) {
            getVmStaticDAO().update(getVm().getStaticData());
        }
        // get what cpu flags should be passed to vdsm according to cluster
        // cpu name
        getVm().setVdsGroupCpuFlagsData(CpuFlagsManagerHandler.GetVDSVerbDataByCpuName(getVm().getVdsGroupCpuName(), getVm().getVdsGroupCompatibilityVersion()));
        return true;
    }
}
#end_block

#method_before
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    VDS destinationVds = getDestinationVds();
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), null, destinationVds == null ? null : destinationVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this));
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.UpdateVmGuestAgentVersion(getVm());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#method_after
protected boolean getVdsToRunOn() {
    // use destination vds or default vds or none
    VDS destinationVds = getDestinationVds();
    Guid vdsToRunOn = SchedulingManager.getInstance().schedule(getVdsGroup(), getVm(), getRunVdssList(), null, destinationVds == null ? null : destinationVds.getId(), new ArrayList<String>(), new VdsFreeMemoryChecker(this));
    setVdsId(vdsToRunOn);
    if (vdsToRunOn != null && !Guid.Empty.equals(vdsToRunOn)) {
        getRunVdssList().add(vdsToRunOn);
    }
    VmHandler.updateVmGuestAgentVersion(getVm());
    setVds(null);
    setVdsName(null);
    if (getVdsId().equals(Guid.Empty)) {
        log.errorFormat("Can't find VDS to run the VM {0} on, so this VM will not be run.", getVmId());
        return false;
    }
    if (getVds() == null) {
        VdcBLLException outEx = new VdcBLLException(VdcBllErrors.RESOURCE_MANAGER_VDS_NOT_FOUND);
        log.error(String.format("VmHandler::%1$s", getClass().getName()), outEx);
        return false;
    }
    return true;
}
#end_block

#method_before
private void guestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    StorageDomain isoDomain = null;
    if (OsRepositoryImpl.INSTANCE.isWindows(getVm().getVmOsId()) && (null != (isoDomain = LinqUtils.firstOrNull(getStorageDomainDAO().getAllForStoragePool(getVm().getStoragePoolId()), new Predicate<StorageDomain>() {

        @Override
        public boolean eval(StorageDomain domain) {
            return domain.getStorageDomainType() == StorageDomainType.ISO;
        }
    })) && isoDomain.getStatus() == StorageDomainStatus.Active && StringUtils.isEmpty(_cdImagePath))) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (Version.OpEquality(clusterVer, new Version("4.4"))) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoImage> repoFilesMap = getIsoDomainListSyncronizer().getCachedIsoListByDomainId(isoDomain.getId(), ImageFileType.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoImage map : repoFilesMap) {
            String fileName = StringUtils.defaultString(map.getRepoImageId(), "");
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.REGEX_TOOL_PATTERN).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                Version clusterVer = new Version(matchToolPattern.group(IsoDomainListSyncronizer.TOOL_CLUSTER_LEVEL));
                int toolVersion = Integer.parseInt(matchToolPattern.group(IsoDomainListSyncronizer.TOOL_VERSION));
                if (clusterVer.compareTo(getVm().getVdsGroupCompatibilityVersion()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if ((Version.OpEquality(clusterVer, bestClusterVer)) && (toolVersion > bestToolVer)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (Version.OpEquality(vmToolsClusterVersion, bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        String rhevToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.getGuestToolsSetupIsoPrefix(), selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) runVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getStoragePoolId())).getReturnValue();
        rhevToolsPath = isoDir + File.separator + rhevToolsPath;
        getVm().setCdPath(ImagesHandler.cdPathWindowsToLinux(rhevToolsPath, getVm().getStoragePoolId()));
    }
}
#method_after
private String guestToolsVersionTreatment() {
    boolean attachCd = false;
    String selectedToolsVersion = "";
    String selectedToolsClusterVersion = "";
    Guid isoDomainId = getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId());
    if (osRepository.isWindows(getVm().getVmOsId()) && null != isoDomainId) {
        // get cluster version of the vm tools
        Version vmToolsClusterVersion = null;
        if (getVm().getHasAgent()) {
            Version clusterVer = getVm().getPartialVersion();
            if (Version.OpEquality(clusterVer, new Version("4.4"))) {
                vmToolsClusterVersion = new Version("2.1");
            } else {
                vmToolsClusterVersion = clusterVer;
            }
        }
        // Fetch cached Iso files from active Iso domain.
        List<RepoImage> repoFilesMap = getIsoDomainListSyncronizer().getCachedIsoListByDomainId(isoDomainId, ImageFileType.ISO);
        Version bestClusterVer = null;
        int bestToolVer = 0;
        for (RepoImage map : repoFilesMap) {
            String fileName = StringUtils.defaultString(map.getRepoImageId(), "");
            Matcher matchToolPattern = Pattern.compile(IsoDomainListSyncronizer.REGEX_TOOL_PATTERN).matcher(fileName);
            if (matchToolPattern.find()) {
                // Get cluster version and tool version of Iso tool.
                Version clusterVer = new Version(matchToolPattern.group(IsoDomainListSyncronizer.TOOL_CLUSTER_LEVEL));
                int toolVersion = Integer.parseInt(matchToolPattern.group(IsoDomainListSyncronizer.TOOL_VERSION));
                if (clusterVer.compareTo(getVm().getVdsGroupCompatibilityVersion()) <= 0) {
                    if ((bestClusterVer == null) || (clusterVer.compareTo(bestClusterVer) > 0)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    } else if ((Version.OpEquality(clusterVer, bestClusterVer)) && (toolVersion > bestToolVer)) {
                        bestToolVer = toolVersion;
                        bestClusterVer = clusterVer;
                    }
                }
            }
        }
        if (bestClusterVer != null && (vmToolsClusterVersion == null || vmToolsClusterVersion.compareTo(bestClusterVer) < 0 || (Version.OpEquality(vmToolsClusterVersion, bestClusterVer) && getVm().getHasAgent() && getVm().getGuestAgentVersion().getBuild() < bestToolVer))) {
            // Vm has no tools or there are new tools
            selectedToolsVersion = (Integer.toString(bestToolVer));
            selectedToolsClusterVersion = bestClusterVer.toString();
            attachCd = true;
        }
    }
    if (attachCd) {
        String rhevToolsPath = String.format("%1$s%2$s_%3$s.iso", IsoDomainListSyncronizer.getGuestToolsSetupIsoPrefix(), selectedToolsClusterVersion, selectedToolsVersion);
        String isoDir = (String) runVdsCommand(VDSCommandType.IsoDirectory, new IrsBaseVDSCommandParameters(getVm().getStoragePoolId())).getReturnValue();
        rhevToolsPath = isoDir + File.separator + rhevToolsPath;
        return rhevToolsPath;
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    List<String> messages = getReturnValue().getCanDoActionMessages();
    List<Disk> vmDisks = getDiskDao().getAllForVm(vm.getId(), true);
    VDS destVds = getDestinationVds();
    boolean canDoAction = getRunVmValidator().canRunVm(vm, messages, vmDisks, getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), destVds == null ? null : destVds.getId(), getVdsGroup()) && validateNetworkInterfaces();
    // check for Vm Payload
    if (canDoAction && getParameters().getVmPayload() != null) {
        canDoAction = checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath());
        if (canDoAction && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            addCanDoActionMessage(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
            canDoAction = false;
        } else {
            getVm().setVmPayload(getParameters().getVmPayload());
        }
    }
    return canDoAction;
}
#method_after
@Override
protected boolean canDoAction() {
    VM vm = getVm();
    if (vm == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_FOUND);
    }
    if (!validate(vm.getStaticData())) {
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    if (vm.getStatus() == VMStatus.Paused) {
        // if VM is paused, it was already checked before that it is capable to run
        return true;
    }
    if (!getRunVmValidator().canRunVm(vm, getReturnValue().getCanDoActionMessages(), getDiskDao().getAllForVm(vm.getId(), true), getParameters().getBootSequence(), getStoragePool(), isInternalExecution(), getParameters().getDiskPath(), getParameters().getFloppyPath(), getParameters().getRunAsStateless(), getRunVdssList(), getDestinationVds() != null ? getDestinationVds().getId() : null, getVdsGroup())) {
        return false;
    }
    if (!validateNetworkInterfaces()) {
        return false;
    }
    // check for Vm Payload
    if (getParameters().getVmPayload() != null) {
        if (checkPayload(getParameters().getVmPayload(), getParameters().getDiskPath()) && !StringUtils.isEmpty(getParameters().getFloppyPath()) && getParameters().getVmPayload().getType() == VmDeviceType.FLOPPY) {
            return failCanDoAction(VdcBllMessages.VMPAYLOAD_FLOPPY_EXCEEDED);
        }
        getVm().setVmPayload(getParameters().getVmPayload());
    }
    // we don't run the VM
    if (!vm.isAutoStartup() && !StringUtils.isEmpty(getVm().getIsoPath()) && getIsoDomainListSyncronizer().findActiveISODomain(getVm().getStoragePoolId()) == null) {
        return failCanDoAction(VdcBllMessages.VM_CANNOT_RUN_FROM_CD_WITHOUT_ACTIVE_STORAGE_DOMAIN_ISO);
    }
    return true;
}
#end_block

#method_before
protected boolean validateNetworkInterfaces() {
    Map<String, VmNetworkInterface> interfaceNetworkMap = Entities.interfacesByNetworkName(getVm().getInterfaces());
    Set<String> interfaceNetworkNames = interfaceNetworkMap.keySet();
    List<Network> clusterNetworks = getNetworkDAO().getAllForCluster(getVm().getVdsGroupId());
    Set<String> clusterNetworksNames = Entities.objectNames(clusterNetworks);
    return isVmInterfacesConfigured() && isVmInterfacesAttachedToClusterNetworks(clusterNetworksNames, interfaceNetworkNames) && isVmInterfacesAttachedToVmNetworks(clusterNetworks, interfaceNetworkNames);
}
#method_after
protected boolean validateNetworkInterfaces() {
    Map<String, VmNetworkInterface> interfaceNetworkMap = Entities.vmInterfacesByNetworkName(getVm().getInterfaces());
    Set<String> interfaceNetworkNames = interfaceNetworkMap.keySet();
    List<Network> clusterNetworks = getNetworkDAO().getAllForCluster(getVm().getVdsGroupId());
    Set<String> clusterNetworksNames = Entities.objectNames(clusterNetworks);
    return isVmInterfacesConfigured() && isVmInterfacesAttachedToClusterNetworks(clusterNetworksNames, interfaceNetworkNames) && isVmInterfacesAttachedToVmNetworks(clusterNetworks, interfaceNetworkNames);
}
#end_block

#method_before
private boolean isVmInterfacesConfigured() {
    for (VmNetworkInterface nic : getVm().getInterfaces()) {
        if (nic.getNetworkName() == null) {
            if (!FeatureSupported.networkLinking(getVm().getVdsGroupCompatibilityVersion())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
                return false;
            } else {
                return true;
            }
        }
    }
    return true;
}
#method_after
private boolean isVmInterfacesConfigured() {
    for (VmNetworkInterface nic : getVm().getInterfaces()) {
        if (nic.getVnicProfileId() == null) {
            if (!FeatureSupported.networkLinking(getVm().getVdsGroupCompatibilityVersion())) {
                addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_INTERFACE_NETWORK_NOT_CONFIGURED);
                return false;
            } else {
                return true;
            }
        }
    }
    return true;
}
#end_block

#method_before
@Override
public void reportCompleted() {
    if (isRunAndPaused()) {
        final ExecutionContext executionContext = getExecutionContext();
        executionContext.setShouldEndJob(true);
        ExecutionHandler.endJob(executionContext, true);
    } else {
        super.reportCompleted();
    }
}
#method_after
@Override
public void reportCompleted() {
    if (getVm().isRunAndPause() && getVmDynamicDao().get(getVmId()).getStatus() == VMStatus.Paused) {
        final ExecutionContext executionContext = getExecutionContext();
        executionContext.setShouldEndJob(true);
        ExecutionHandler.endJob(executionContext, true);
    } else {
        super.reportCompleted();
    }
}
#end_block

#method_before
public static String GetSysPrep(VM vm, String hostName, String domain, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    sysPrepContent = LoadFile(OsRepositoryImpl.INSTANCE.getSysprepPath(vm.getVmOsId(), null));
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", OsRepositoryImpl.INSTANCE.getProductKey(vm.getVmOsId(), null));
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>GetValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>GetValue(ConfigValues.OrganizationName));
    }
    return sysPrepContent;
}
#method_after
public static String GetSysPrep(VM vm, String hostName, String domain, SysPrepParams sysPrepParams) {
    String sysPrepContent = "";
    sysPrepContent = LoadFile(osRepository.getSysprepPath(vm.getVmOsId(), null));
    sysPrepContent = replace(sysPrepContent, "$ProductKey$", osRepository.getProductKey(vm.getVmOsId(), null));
    if (sysPrepContent.length() > 0) {
        sysPrepContent = populateSysPrepDomainProperties(sysPrepContent, domain, sysPrepParams);
        sysPrepContent = replace(sysPrepContent, "$ComputerName$", hostName != null ? hostName : "");
        sysPrepContent = replace(sysPrepContent, "$AdminPassword$", Config.<String>GetValue(ConfigValues.LocalAdminPassword));
        String timeZone = getTimeZone(vm);
        sysPrepContent = replace(sysPrepContent, "$TimeZone$", timeZone);
        sysPrepContent = replace(sysPrepContent, "$OrgName$", Config.<String>GetValue(ConfigValues.OrganizationName));
    }
    return sysPrepContent;
}
#end_block

#method_before
private static String getTimeZone(VM vm) {
    String timeZone;
    // Can be empty if the VM was imported.
    if (StringUtils.isEmpty(vm.getTimeZone())) {
        vm.setTimeZone(Config.<String>GetValue(ConfigValues.DefaultWindowsTimeZone));
    }
    if (OsRepositoryImpl.INSTANCE.isTimezoneValueInteger(vm.getStaticData().getOsId(), null)) {
        // send correct time zone as sysprep expect to get it (a wierd number)
        timeZone = getTimezoneIndexByKey(vm.getTimeZone());
    } else {
        timeZone = vm.getTimeZone();
    }
    return timeZone;
}
#method_after
private static String getTimeZone(VM vm) {
    String timeZone;
    // Can be empty if the VM was imported.
    if (StringUtils.isEmpty(vm.getTimeZone())) {
        vm.setTimeZone(Config.<String>GetValue(ConfigValues.DefaultWindowsTimeZone));
    }
    if (osRepository.isTimezoneValueInteger(vm.getStaticData().getOsId(), null)) {
        // send correct time zone as sysprep expect to get it (a wierd number)
        timeZone = getTimezoneIndexByKey(vm.getTimeZone());
    } else {
        timeZone = vm.getTimeZone();
    }
    return timeZone;
}
#end_block

#method_before
// we get "Afghanistan Standard Time" we return "175"
// the "Afghanistan Standard Time" is the vm Key that we get from the method getTimezoneKey()
public static String getTimezoneIndexByKey(String key) {
    for (String s : timeZoneIndex.keySet()) {
        if (getTimezoneKey(s).equals(key)) {
            return timeZoneIndex.get(s).toString();
        }
    }
    log.errorFormat("getTimezoneIndexByKey: cannot find timezone key '{0}'", key);
    return key;
}
#method_after
// we get "Afghanistan Standard Time" we return "175"
// the "Afghanistan Standard Time" is the vm Key that we get from the method getTimezoneKey()
public static String getTimezoneIndexByKey(String key) {
    for (Map.Entry<String, Integer> timeZoneEntry : timeZoneIndex.entrySet()) {
        if (getTimezoneKey(timeZoneEntry.getKey()).equals(key)) {
            return timeZoneEntry.getValue().toString();
        }
    }
    log.errorFormat("getTimezoneIndexByKey: cannot find timezone key '{0}'", key);
    return key;
}
#end_block

#method_before
public String getDisplayValue() {
    if (isDefault()) {
        final String defaultTimeZoneKey = (String) AsyncDataProvider.getConfigValuePreConverted(timeZoneType.getDefaultTimeZoneConfigurationKey());
        return timeZoneType.getTimeZoneList().get(defaultTimeZoneKey);
    } else {
        return timeZoneType.getTimeZoneList().get(timeZoneKey);
    }
}
#method_after
public String getDisplayValue() {
    if (isDefault()) {
        final String defaultTimeZoneKey = (String) AsyncDataProvider.getConfigValuePreConverted(timeZoneType.getDefaultTimeZoneConfigurationKey());
        // check if default timezone is correct
        if (!timeZoneType.getTimeZoneList().containsKey(defaultTimeZoneKey)) {
            // if not show GMT
            timeZoneKey = timeZoneType.getUltimateFallback();
        }
        return timeZoneType.getTimeZoneList().get(defaultTimeZoneKey);
    } else {
        return timeZoneType.getTimeZoneList().get(timeZoneKey);
    }
}
#end_block

#method_before
@Test
public void testHasSpiceSupport() throws Exception {
    assertTrue(OsRepositoryImpl.INSTANCE.spiceSupportMatrix().get(777).get(null));
}
#method_after
@Test
public void testHasSpiceSupport() throws Exception {
    assertTrue(OsRepositoryImpl.INSTANCE.getSpiceSupportMatrix().get(777).get(null));
}
#end_block

#method_before
@Test
public void canDoActionFailedVirtIODisk() throws Exception {
    mockVmStatusUp();
    when(osRepository.spiceSupportMatrix().get(0).get(Version.v3_1)).thenReturn(true);
    when(osRepository.getOsName(0)).thenReturn("RHEL6");
    createNotVirtIODisk();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_VIRTIO.toString()));
}
#method_after
@Test
public void canDoActionFailedVirtIODisk() throws Exception {
    mockVmStatusUp();
    mockSpiceSupportMatrix();
    when(osRepository.getOsName(0)).thenReturn("RHEL6");
    createNotVirtIODisk();
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.HOT_PLUG_DISK_IS_NOT_VIRTIO.toString()));
}
#end_block

#method_before
private static void initHasSpiceSupport() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            spiceSupportMatrix = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.HasSpiceSupportMatrix), callback);
}
#method_after
private static void initHasSpiceSupport() {
    AsyncQuery callback = new AsyncQuery();
    callback.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            spiceSupportMatrix = ((VdcQueryReturnValue) returnValue).getReturnValue();
        }
    };
    Frontend.RunQuery(VdcQueryType.OsRepository, new OsQueryParameters(OsRepositoryVerb.GetSpiceSupportMatrix), callback);
}
#end_block

#method_before
@Override
protected void executeQueryCommand() {
    switch(getParameters().getOsRepositoryVerb()) {
        case GetOsNames:
            setReturnValue(osRepository.getOsNames());
            break;
        case GetUniqueOsNames:
            setReturnValue(osRepository.getUniqueOsNames());
            break;
        case GetOsIds:
            setReturnValue(osRepository.getOsIds());
            break;
        case GetLinuxOss:
            setReturnValue(osRepository.getLinuxOss());
            break;
        case GetWindowsOss:
            setReturnValue(osRepository.getWindowsOss());
            break;
        case GetMaxOsRam:
            setReturnValue(osRepository.getMaximumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetMinimumOsRam:
            setReturnValue(osRepository.getMinimumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case HasSpiceSupportMatrix:
            setReturnValue(osRepository.spiceSupportMatrix());
            break;
        case GetNetworkDevices:
            setReturnValue(osRepository.getNetworkDevices(getParameters().getOsId(), getParameters().getVersion()));
            break;
    }
}
#method_after
@Override
protected void executeQueryCommand() {
    switch(getParameters().getOsRepositoryVerb()) {
        case GetOsNames:
            setReturnValue(osRepository.getOsNames());
            break;
        case GetUniqueOsNames:
            setReturnValue(osRepository.getUniqueOsNames());
            break;
        case GetOsIds:
            setReturnValue(osRepository.getOsIds());
            break;
        case GetLinuxOss:
            setReturnValue(osRepository.getLinuxOss());
            break;
        case GetWindowsOss:
            setReturnValue(osRepository.getWindowsOss());
            break;
        case GetMaxOsRam:
            setReturnValue(osRepository.getMaximumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetMinimumOsRam:
            setReturnValue(osRepository.getMinimumRam(getParameters().getOsId(), getParameters().getVersion()));
            break;
        case GetSpiceSupportMatrix:
            setReturnValue(osRepository.getSpiceSupportMatrix());
            break;
        case GetNetworkDevices:
            setReturnValue(osRepository.getNetworkDevices(getParameters().getOsId(), getParameters().getVersion()));
            break;
    }
}
#end_block

#method_before
private void updateDefaultSelectedConsoleProtocol(final VM vm) {
    // for wind8+ guests the RDP is selected, for all other OS the spice
    if (vm.getId() == null) {
        return;
    }
    final ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
    if (cachedModels == null) {
        return;
    }
    deselectUserSelectedProtocol(vm.getId());
    final boolean isWindowsExplorer = parentModel.getConfigurator().isClientWindowsExplorer();
    Boolean hasSpiceSupport = AsyncDataProvider.hasSpiceSupport(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if (isWindowsExplorer && hasSpiceSupport != null && hasSpiceSupport.booleanValue()) {
        cachedModels.get(RDP_INDEX).setUserSelected(true);
    } else {
        determineConsoleModelFromVm(vm, cachedModels).setUserSelected(true);
    }
    setupSelectionContext(vm);
}
#method_after
private void updateDefaultSelectedConsoleProtocol(final VM vm) {
    // for wind8+ guests the RDP is selected, for all other OS the spice
    if (vm.getId() == null) {
        return;
    }
    final ArrayList<ConsoleModel> cachedModels = cachedConsoleModels.get(vm.getId());
    if (cachedModels == null) {
        return;
    }
    deselectUserSelectedProtocol(vm.getId());
    final boolean isWindowsExplorer = parentModel.getConfigurator().isClientWindowsExplorer();
    Boolean hasSpiceSupport = AsyncDataProvider.hasSpiceSupport(vm.getOs(), vm.getVdsGroupCompatibilityVersion());
    if (isWindowsExplorer && hasSpiceSupport != null && !hasSpiceSupport) {
        cachedModels.get(RDP_INDEX).setUserSelected(true);
    } else {
        determineConsoleModelFromVm(vm, cachedModels).setUserSelected(true);
    }
    setupSelectionContext(vm);
}
#end_block

#method_before
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion());
        }
    }
    struct.put(VdsProperties.NETWORK, network == null ? "" : network.getName());
    if (vnicProfile != null && vnicProfile.isPortMirroring()) {
        struct.put(VdsProperties.PORT_MIRRORING, network == null ? Collections.<String>emptyList() : Collections.singletonList(network.getName()));
    }
    log.debugFormat("VNIC {0} is using profile {1} on network {2}", nic.getName(), vnicProfile, network.getName());
    addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile));
}
#method_after
public static void addProfileDataToNic(Map<String, Object> struct, VM vm, VmDevice vmDevice, VmNic nic) {
    VnicProfile vnicProfile = null;
    Network network = null;
    String networkName = "";
    if (nic.getVnicProfileId() != null) {
        vnicProfile = DbFacade.getInstance().getVnicProfileDao().get(nic.getVnicProfileId());
        if (vnicProfile != null) {
            network = DbFacade.getInstance().getNetworkDao().get(vnicProfile.getNetworkId());
            networkName = network.getName();
            log.debugFormat("VNIC {0} is using profile {1} on network {2}", nic.getName(), vnicProfile, networkName);
            addQosForDevice(struct, vnicProfile, vm.getVdsGroupCompatibilityVersion());
        }
    }
    struct.put(VdsProperties.NETWORK, networkName);
    if (vnicProfile != null && vnicProfile.isPortMirroring()) {
        struct.put(VdsProperties.PORT_MIRRORING, network == null ? Collections.<String>emptyList() : Collections.singletonList(networkName));
    }
    addCustomPropertiesForDevice(struct, vm, vmDevice, vm.getVdsGroupCompatibilityVersion(), getVnicCustomProperties(vnicProfile));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    DiskImage diskImage = getDiskImage();
    OpenStackImageProviderProxy proxy = getProviderProxy();
    acquireImageDbLock();
    String newImageId = proxy.createImageFromDiskImage(diskImage);
    getParameters().setParentCommand(VdcActionType.ExportRepoImage);
    Guid taskId = getAsyncTaskId();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupID()));
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.UploadImage, new UploadImageVDSCommandParameters(getParameters().getStoragePoolId(), getParameters().getStorageDomainId(), getParameters().getImageGroupID(), getParameters().getImageId(), new HttpLocationInfo(getProviderProxy().getImageUrl(newImageId), getProviderProxy().getUploadHeaders())));
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Disk, getParameters().getImageGroupID()));
    }
    getReturnValue().setActionReturnValue(newImageId);
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    DiskImage diskImage = getDiskImage();
    OpenStackImageProviderProxy proxy = getProviderProxy();
    acquireImageDbLock();
    String newImageId = proxy.createImageFromDiskImage(diskImage);
    getParameters().setParentCommand(VdcActionType.ExportRepoImage);
    Guid taskId = getAsyncTaskId();
    getParameters().setEntityInfo(new EntityInfo(VdcObjectType.Disk, getParameters().getImageGroupID()));
    VDSReturnValue vdsReturnValue = runVdsCommand(VDSCommandType.UploadImage, new UploadImageVDSCommandParameters(getStorageDomain().getStoragePoolId(), getStorageDomain().getId(), diskImage.getId(), diskImage.getImageId(), new HttpLocationInfo(getProviderProxy().getImageUrl(newImageId), getProviderProxy().getUploadHeaders())));
    if (vdsReturnValue.getSucceeded()) {
        getReturnValue().getVdsmTaskIdList().add(createTask(taskId, vdsReturnValue.getCreationInfo(), getParameters().getParentCommand(), VdcObjectType.Disk, getParameters().getImageGroupID()));
    }
    getReturnValue().setActionReturnValue(newImageId);
    setSucceeded(true);
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionSubjects = new ArrayList<>();
    permissionSubjects.add(new PermissionSubject(getDiskImage().getId(), VdcObjectType.Disk, ActionGroup.ATTACH_DISK));
    permissionSubjects.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, // ActionGroup.ACCESS_IMAGE_STORAGE ?
    ActionGroup.CREATE_DISK));
    return permissionSubjects;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    List<PermissionSubject> permissionSubjects = new ArrayList<>();
    permissionSubjects.add(new PermissionSubject(getDiskImage().getId(), VdcObjectType.Disk, ActionGroup.ATTACH_DISK));
    permissionSubjects.add(new PermissionSubject(getParameters().getDestinationDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    return permissionSubjects;
}
#end_block

#method_before
@Override
public Guid getStorageDomainId() {
    return getParameters().getStorageDomainId();
}
#method_after
@Override
public Guid getStorageDomainId() {
    return getDiskImage() != null ? getDiskImage().getStorageIds().get(0) : null;
}
#end_block

#method_before
protected DiskImage getDiskImage() {
    if (diskImage == null) {
        diskImage = getDiskImageDao().get(getParameters().getImageId());
    }
    return diskImage;
}
#method_after
protected DiskImage getDiskImage() {
    if (diskImage == null) {
        Disk disk = getDiskDao().get(getParameters().getImageGroupID());
        if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
            diskImage = (DiskImage) disk;
        }
    }
    return diskImage;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getDiskImage() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (!validate(new StoragePoolValidator(getStoragePool()).isUp())) {
        return false;
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDAO().getVmsListForDisk(getDiskImage().getId())) {
        if (vm.getStatus() != VMStatus.Down) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getDiskImage() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        return false;
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDAO().getVmsListForDisk(getDiskImage().getId())) {
        if (vm.getStatus() != VMStatus.Down) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    return true;
}
#end_block

#method_before
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put("repoimagename", getDiskImage() != null ? getDiskImage().getDiskAlias() : "");
    }
    return jobProperties;
}
#method_after
@Override
public Map<String, String> getJobMessageProperties() {
    if (jobProperties == null) {
        jobProperties = super.getJobMessageProperties();
        jobProperties.put("repoimagename", getRepoImageName());
    }
    return jobProperties;
}
#end_block

#method_before
@Override
public Response doExport(Action action) {
    validateParameters(action, "storageDomain.id|name");
    try {
        ExportRepoImageParameters exportParameters = DiskHelper.getExportRepoImageParameters(getDisk(), getStorageDomainId(action));
        return doAction(VdcActionType.ExportRepoImage, exportParameters, action);
    } catch (Exception e) {
        return handleError(e, action);
    }
}
#method_after
@Override
public Response doExport(Action action) {
    validateParameters(action, "storageDomain.id|name");
    return doAction(VdcActionType.ExportRepoImage, new ExportRepoImageParameters(guid, getStorageDomainId(action)), action);
}
#end_block

#method_before
@Override
public Response doExport(Action action) {
    validateParameters(action, "storageDomain.id|name");
    try {
        ExportRepoImageParameters exportParameters = DiskHelper.getExportRepoImageParameters(get(), getStorageDomainId(action));
        return doAction(VdcActionType.ExportRepoImage, exportParameters, action);
    } catch (Exception e) {
        return handleError(e, action);
    }
}
#method_after
@Override
public Response doExport(Action action) {
    validateParameters(action, "storageDomain.id|name");
    return doAction(VdcActionType.ExportRepoImage, new ExportRepoImageParameters(guid, getStorageDomainId(action)), action);
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<GlusterHookEntity> getBatchMapper() {
    // TODO: Implement this
    throw new RuntimeException("Unsupported operation");
}
#method_after
@SuppressWarnings("deprecation")
@Override
public MapSqlParameterMapper<GlusterHookEntity> getBatchMapper() {
    // TODO: Implement this
    throw new NotImplementedException("Unsupported operation");
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<GlusterVolumeEntity> getBatchMapper() {
    // TODO: Implement this
    throw new RuntimeException("Unsupported operation");
}
#method_after
@SuppressWarnings("deprecation")
@Override
public MapSqlParameterMapper<GlusterVolumeEntity> getBatchMapper() {
    // TODO: Implement this
    throw new NotImplementedException("Unsupported operation");
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<GlusterBrickEntity> getBatchMapper() {
    // TODO: Implement this
    throw new RuntimeException("Unsupported operation");
}
#method_after
@SuppressWarnings("deprecation")
@Override
public MapSqlParameterMapper<GlusterBrickEntity> getBatchMapper() {
    // TODO: Implement this
    throw new NotImplementedException("Unsupported operation");
}
#end_block

#method_before
@Override
public /**
 * Enables to send update procedure name as a parameter that overrides the default
 * one.
 * In case this parameter is null the default procedure is used.
 */
void updateAll(String procedureName, Collection<T> entities) {
    for (T entity : entities) {
        update(entity, procedureName == null ? getProcedureNameForUpdate() : procedureName);
    }
}
#method_after
@Override
public /**
 * Enables to send update procedure name as a parameter that overrides the default
 * one.
 * In case this parameter is null the default procedure is used.
 */
void updateAll(String procedureName, Collection<T> entities) {
    if (procedureName == null) {
        procedureName = getProcedureNameForUpdate();
    }
    for (T entity : entities) {
        update(entity, procedureName);
    }
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<GlusterVolumeOptionEntity> getBatchMapper() {
    // TODO: Implement this
    throw new RuntimeException("Unsupported operation");
}
#method_after
@SuppressWarnings("deprecation")
@Override
public MapSqlParameterMapper<GlusterVolumeOptionEntity> getBatchMapper() {
    // TODO: Implement this
    throw new NotImplementedException("Unsupported operation");
}
#end_block

#method_before
@Override
public MapSqlParameterMapper<GlusterServerService> getBatchMapper() {
    // TODO: Implement this
    throw new RuntimeException("Unsupported operation");
}
#method_after
@Override
public MapSqlParameterMapper<GlusterServerService> getBatchMapper() {
    // TODO: Implement this
    throw new NotImplementedException("Unsupported operation");
}
#end_block

#method_before
void updateFormat() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getSelectedItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.NFS || getSelectedItem().getType() == StorageType.LOCALFS) && (dataCenter.getcompatibility_version().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getcompatibility_version().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangable(true);
            formats.add(StorageFormatType.V1);
            if ((getSelectedItem().getType() == StorageType.FCP || getSelectedItem().getType() == StorageType.ISCSI) && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(getStorage() != null ? getStorage().getStorageFormat() : selectItem);
}
#method_after
void updateFormat() {
    StoragePool dataCenter = (StoragePool) getDataCenter().getSelectedItem();
    StorageFormatType selectItem = StorageFormatType.V1;
    ArrayList<StorageFormatType> formats = new ArrayList<StorageFormatType>();
    if (dataCenter != null && getSelectedItem() != null) {
        if (!dataCenter.getId().equals(UnassignedDataCenterId)) {
            getFormat().setIsChangable(false);
            // If data center has format defined and the selected-item role is Data, choose it.
            if (dataCenter.getStoragePoolFormatType() != null && getSelectedItem().getRole().isDataDomain()) {
                formats.add(dataCenter.getStoragePoolFormatType());
                selectItem = dataCenter.getStoragePoolFormatType();
            } else // and in order to make the code more explicit, it is here. ***)
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                formats.add(StorageFormatType.V1);
            } else if ((getSelectedItem().getType() == StorageType.NFS || getSelectedItem().getType() == StorageType.LOCALFS) && (dataCenter.getcompatibility_version().compareTo(Version.v3_1) < 0)) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) < 0) {
                formats.add(StorageFormatType.V1);
            } else if (getSelectedItem().getType().isBlockDomain() && dataCenter.getcompatibility_version().compareTo(Version.v3_0) == 0) {
                formats.add(StorageFormatType.V2);
                selectItem = StorageFormatType.V2;
            } else if (dataCenter.getcompatibility_version().compareTo(Version.v3_1) >= 0) {
                formats.add(StorageFormatType.V3);
                selectItem = StorageFormatType.V3;
            }
        } else // Unassigned DC:
        {
            if ((getSelectedItem().getRole() == StorageDomainType.ISO || getSelectedItem().getRole() == StorageDomainType.ImportExport)) {
                // ISO/Export domains should not be available for '(none)' DC
                return;
            }
            getFormat().setIsChangable(true);
            formats.add(StorageFormatType.V1);
            if ((getSelectedItem().getType() == StorageType.FCP || getSelectedItem().getType() == StorageType.ISCSI) && getSelectedItem().getRole() == StorageDomainType.Data) {
                formats.add(StorageFormatType.V2);
            }
            formats.add(StorageFormatType.V3);
            selectItem = StorageFormatType.V3;
        }
    }
    getFormat().setItems(formats);
    getFormat().setSelectedItem(selectItem);
}
#end_block

#method_before
@Override
public StorageFormatType getPreferred(StorageType t) {
    if (t.isBlockDomain()) {
        return StorageFormatType.V2;
    }
    return StorageFormatType.V1;
}
#method_after
@Override
public StorageFormatType getPreferred(StorageType type) {
    if (type.isBlockDomain()) {
        return StorageFormatType.V2;
    }
    return StorageFormatType.V1;
}
#end_block

#method_before
@Test
public void canDoActionVmInPreview() {
    createParameters();
    initDiskImage(diskImageId);
    initVm(VMStatus.Up, null, diskImageId);
    setVmInPreview(true);
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW)).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    assertFalse(command.canDoAction());
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW.toString()));
}
#method_after
@Test
public void canDoActionVmInPreview() {
    createParameters();
    initDiskImage(diskImageId);
    initVm(VMStatus.Up, null, diskImageId);
    setVmInPreview(true);
    doReturn(new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW)).when(snapshotsValidator).vmNotInPreview(any(Guid.class));
    CanDoActionTestUtils.runAndAssertCanDoActionFailure(command, VdcBllMessages.ACTION_TYPE_FAILED_VM_IN_PREVIEW);
}
#end_block

#method_before
private void addDisksDeactivatedMessage(List<MoveDiskParameters> moveDiskParamsList) {
    setActionMessageParameters();
    addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", StringUtils.join(getUnpluggedDisksAliases(moveDiskParamsList), ", ")));
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_DEACTIVATED);
    getReturnValue().setCanDoAction(false);
}
#method_after
private void addDisksDeactivatedMessage(List<MoveDiskParameters> moveDiskParamsList) {
    setActionMessageParameters();
    addCanDoActionMessage(String.format("$%1$s %2$s", "diskAliases", StringUtils.join(getDisksAliases(moveDiskParamsList), ", ")));
    addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_MOVE_DISKS_MIXED_PLUGGED_STATUS);
    getReturnValue().setCanDoAction(false);
}
#end_block

#method_before
protected void updateParameters() {
    Map<VM, List<MoveDiskParameters>> vmDiskParamsMap = createVmDiskParamsMap();
    for (Map.Entry<VM, List<MoveDiskParameters>> vmDiskParamsEntry : vmDiskParamsMap.entrySet()) {
        VM vm = vmDiskParamsEntry.getKey();
        List<MoveDiskParameters> moveDiskParamsList = vmDiskParamsEntry.getValue();
        if (vm == null || vm.isDown() || isAllDisksUnplugged(moveDiskParamsList)) {
            // Adding parameters for offline move
            moveDiskParametersList.addAll(moveDiskParamsList);
        } else if (vm.isRunningAndQualifyForDisksMigration()) {
            if (!isAllDisksPlugged(moveDiskParamsList)) {
                // Cannot live migrate and move disks concurrently
                addDisksDeactivatedMessage(moveDiskParamsList);
                continue;
            }
            // Adding parameters for live migrate
            liveMigrateVmDisksParametersList.add(createLiveMigrateVmDisksParameters(moveDiskParamsList, vm.getId()));
        } else {
            // Live migrate / move disk is not applicable according to VM status
            addInvalidVmStateMessage(vm);
        }
    }
}
#method_after
protected void updateParameters() {
    Map<VM, List<MoveDiskParameters>> vmDiskParamsMap = createVmDiskParamsMap();
    for (Map.Entry<VM, List<MoveDiskParameters>> vmDiskParamsEntry : vmDiskParamsMap.entrySet()) {
        VM vm = vmDiskParamsEntry.getKey();
        List<MoveDiskParameters> moveDiskParamsList = vmDiskParamsEntry.getValue();
        if (vm == null || vm.isDown() || areAllDisksPluggedToVm(moveDiskParamsList, false)) {
            // Adding parameters for offline move
            moveDiskParametersList.addAll(moveDiskParamsList);
        } else if (vm.isRunningAndQualifyForDisksMigration()) {
            if (!areAllDisksPluggedToVm(moveDiskParamsList, true)) {
                // Cannot live migrate and move disks concurrently
                addDisksDeactivatedMessage(moveDiskParamsList);
                continue;
            }
            // Adding parameters for live migrate
            liveMigrateVmDisksParametersList.add(createLiveMigrateVmDisksParameters(moveDiskParamsList, vm.getId()));
        } else {
            // Live migrate / move disk is not applicable according to VM status
            addInvalidVmStateMessage(vm);
        }
    }
}
#end_block

#method_before
private Map<VM, List<MoveDiskParameters>> createVmDiskParamsMap() {
    Map<VM, List<MoveDiskParameters>> vmDisksMap = new HashMap<>();
    for (MoveDiskParameters moveDiskParameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageDao().get(moveDiskParameters.getImageId());
        Map<Boolean, List<VM>> allVmsForDisk = getVmDAO().getForDisk(diskImage.getId());
        List<VM> vmsForPluggedDisk = allVmsForDisk.get(Boolean.TRUE);
        List<VM> vmsForUnpluggedDisk = allVmsForDisk.get(Boolean.FALSE);
        VM vm = vmsForPluggedDisk != null ? vmsForPluggedDisk.get(0) : vmsForUnpluggedDisk != null ? vmsForUnpluggedDisk.get(0) : null;
        addDiskToMap(diskImage, vmsForPluggedDisk, vmsForUnpluggedDisk);
        MultiValueMapUtils.addToMap(vm, moveDiskParameters, vmDisksMap);
    }
    return vmDisksMap;
}
#method_after
private Map<VM, List<MoveDiskParameters>> createVmDiskParamsMap() {
    Map<VM, List<MoveDiskParameters>> vmDisksMap = new HashMap<>();
    for (MoveDiskParameters moveDiskParameters : getParameters().getParametersList()) {
        DiskImage diskImage = getDiskImageDao().get(moveDiskParameters.getImageId());
        Map<Boolean, List<VM>> allVmsForDisk = getVmDAO().getForDisk(diskImage.getId());
        List<VM> vmsForPluggedDisk = allVmsForDisk.get(Boolean.TRUE);
        List<VM> vmsForUnpluggedDisk = allVmsForDisk.get(Boolean.FALSE);
        VM vm = vmsForPluggedDisk != null ? vmsForPluggedDisk.get(0) : vmsForUnpluggedDisk != null ? vmsForUnpluggedDisk.get(0) : // null is used for floating disks indication
        null;
        addDiskToMap(diskImage, vmsForPluggedDisk, vmsForUnpluggedDisk);
        MultiValueMapUtils.addToMap(vm, moveDiskParameters, vmDisksMap);
    }
    return vmDisksMap;
}
#end_block

#method_before
@Test
public void moveUnpluggedDiskVmDown() {
    command.getParameters().setParametersList(createMoveDisksParameters());
    initDiskImage(diskImageId);
    initVm(VMStatus.Down, Guid.newGuid(), diskImageId, false);
    command.updateParameters();
    assertTrue(command.getMoveDiskParametersList().size() == 1);
}
#method_after
@Test
public void moveUnpluggedDiskVmDown() {
    command.getParameters().setParametersList(createMoveDisksParameters());
    initDiskImage(diskImageId);
    initVm(VMStatus.Down, Guid.newGuid(), diskImageId, false);
    command.updateParameters();
    assertEquals(command.getMoveDiskParametersList().size(), 1);
}
#end_block

#method_before
@Test
public void moveUnpluggedDiskVmUp() {
    command.getParameters().setParametersList(createMoveDisksParameters());
    initDiskImage(diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageId, false);
    command.updateParameters();
    assertTrue(command.getMoveDiskParametersList().size() == 1);
}
#method_after
@Test
public void moveUnpluggedDiskVmUp() {
    command.getParameters().setParametersList(createMoveDisksParameters());
    initDiskImage(diskImageId);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageId, false);
    command.updateParameters();
    assertEquals(command.getMoveDiskParametersList().size(), 1);
}
#end_block

#method_before
@Test
public void movePluggedDiskAndUnpluggedDiskVmUp() {
    Guid diskImageId1 = Guid.newGuid();
    Guid diskImageId2 = Guid.newGuid();
    MoveDiskParameters moveDiskParameters1 = new MoveDiskParameters(diskImageId1, srcStorageId, dstStorageId);
    MoveDiskParameters moveDiskParameters2 = new MoveDiskParameters(diskImageId2, srcStorageId, dstStorageId);
    command.getParameters().setParametersList(Arrays.asList(moveDiskParameters1, moveDiskParameters2));
    initDiskImage(diskImageId1);
    initDiskImage(diskImageId2);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageId1, true, diskImageId2, false);
    command.updateParameters();
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_DISKS_DEACTIVATED.toString()));
}
#method_after
@Test
public void movePluggedDiskAndUnpluggedDiskVmUp() {
    Guid diskImageId1 = Guid.newGuid();
    Guid diskImageId2 = Guid.newGuid();
    MoveDiskParameters moveDiskParameters1 = new MoveDiskParameters(diskImageId1, srcStorageId, dstStorageId);
    MoveDiskParameters moveDiskParameters2 = new MoveDiskParameters(diskImageId2, srcStorageId, dstStorageId);
    command.getParameters().setParametersList(Arrays.asList(moveDiskParameters1, moveDiskParameters2));
    initDiskImage(diskImageId1);
    initDiskImage(diskImageId2);
    initVm(VMStatus.Up, Guid.newGuid(), diskImageId1, true, diskImageId2, false);
    command.updateParameters();
    assertTrue(command.getReturnValue().getCanDoActionMessages().contains(VdcBllMessages.ACTION_TYPE_FAILED_MOVE_DISKS_MIXED_PLUGGED_STATUS.toString()));
}
#end_block

#method_before
@Override
protected void executeCommand() {
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    CheckMaxMemoryOverCommitValue();
    if (!ObjectUtils.objectsEqual(oldGroup.getcompatibility_version(), getParameters().getVdsGroup().getcompatibility_version())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (getVds().getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>GetValue(ConfigValues.ClusterEmulatedMachines, vds.getVdsGroupCompatibilityVersion().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine != null) {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
    } else {
        getParameters().getVdsGroup().setEmulatedMachine(oldGroup.getEmulatedMachine());
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if ((oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) || (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null)) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        if (oldGroup.getStoragePoolId() != null) {
            for (VDS vds : allForVdsGroup) {
                getVdsSpmIdMapDAO().removeByVdsAndStoragePool(vds.getId(), oldGroup.getStoragePoolId());
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = NetworkUtils.getEngineNetwork();
    for (Network net : networks) {
        if (StringUtils.equals(net.getName(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getStoragePoolId() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getStoragePoolId());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getName(), managementNetwork)) {
                    getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true, false));
                }
            }
        }
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    // TODO: This code should be revisited and proper compensation logic should be introduced here
    CheckMaxMemoryOverCommitValue();
    if (!ObjectUtils.objectsEqual(oldGroup.getcompatibility_version(), getParameters().getVdsGroup().getcompatibility_version())) {
        String emulatedMachine = null;
        // pick an UP host randomly - all should have latest compat version already if we passed the canDo.
        for (VDS vds : allForVdsGroup) {
            if (getVds().getStatus() == VDSStatus.Up) {
                emulatedMachine = ListUtils.firstMatch(Config.<List<String>>GetValue(ConfigValues.ClusterEmulatedMachines, getParameters().getVdsGroup().getcompatibility_version().getValue()), vds.getSupportedEmulatedMachines().split(","));
                break;
            }
        }
        if (emulatedMachine == null) {
            getParameters().getVdsGroup().setDetectEmulatedMachine(true);
        } else {
            getParameters().getVdsGroup().setEmulatedMachine(emulatedMachine);
        }
    }
    getVdsGroupDAO().update(getParameters().getVdsGroup());
    if ((oldGroup.getStoragePoolId() != null && !oldGroup.getStoragePoolId().equals(getVdsGroup().getStoragePoolId())) || (oldGroup.getStoragePoolId() == null && getVdsGroup().getStoragePoolId() != null)) {
        for (VDS vds : allForVdsGroup) {
            VdsActionParameters parameters = new VdsActionParameters();
            parameters.setVdsId(vds.getId());
            VdcReturnValueBase addVdsSpmIdReturn = getBackend().runInternalAction(VdcActionType.AddVdsSpmId, parameters);
            if (!addVdsSpmIdReturn.getSucceeded()) {
                setSucceeded(false);
                getReturnValue().setFault(addVdsSpmIdReturn.getFault());
                return;
            }
        }
        if (oldGroup.getStoragePoolId() != null) {
            for (VDS vds : allForVdsGroup) {
                getVdsSpmIdMapDAO().removeByVdsAndStoragePool(vds.getId(), oldGroup.getStoragePoolId());
            }
        }
    }
    // when changing data center we check that default networks exists in
    // cluster
    List<Network> networks = getNetworkDAO().getAllForCluster(getVdsGroup().getId());
    boolean exists = false;
    String managementNetwork = NetworkUtils.getEngineNetwork();
    for (Network net : networks) {
        if (StringUtils.equals(net.getName(), managementNetwork)) {
            exists = true;
        }
    }
    if (!exists) {
        if (getVdsGroup().getStoragePoolId() != null) {
            List<Network> storagePoolNets = getNetworkDAO().getAllForDataCenter(getVdsGroup().getStoragePoolId());
            for (Network net : storagePoolNets) {
                if (StringUtils.equals(net.getName(), managementNetwork)) {
                    getNetworkClusterDAO().save(new NetworkCluster(getVdsGroup().getId(), net.getId(), NetworkStatus.OPERATIONAL, true, true, false));
                }
            }
        }
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public GlusterVolumeRebalanceTaskReturnForXmlRpc glusterVolumeRebalanceStatus(String volumeName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeRebalanceStatus(volumeName);
        GlusterVolumeRebalanceTaskReturnForXmlRpc wrapper = new GlusterVolumeRebalanceTaskReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterVolumeTaskReturnForXmlRpc glusterVolumeRebalanceStatus(String volumeName) {
    try {
        Map<String, Object> xmlRpcReturnValue = vdsServer.glusterVolumeRebalanceStatus(volumeName);
        GlusterVolumeTaskReturnForXmlRpc wrapper = new GlusterVolumeTaskReturnForXmlRpc(xmlRpcReturnValue);
        return wrapper;
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmType().setIsChangable(true);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    AsyncDataProvider.getDataCenterById(new AsyncQuery(getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            if (returnValue != null) {
                StoragePool dataCenter = (StoragePool) returnValue;
                final List<StoragePool> dataCenters = new ArrayList<StoragePool>(Arrays.asList(new StoragePool[] { dataCenter }));
                initClusters(dataCenters);
            } else {
                ExistingVmModelBehavior behavior = (ExistingVmModelBehavior) model.getBehavior();
                VM currentVm = behavior.vm;
                VDSGroup tempVar = new VDSGroup();
                tempVar.setId(currentVm.getVdsGroupId());
                tempVar.setName(currentVm.getVdsGroupName());
                tempVar.setcompatibility_version(currentVm.getVdsGroupCompatibilityVersion());
                tempVar.setStoragePoolId(currentVm.getStoragePoolId());
                VDSGroup cluster = tempVar;
                DataCenterWithCluster dataCenterWithCluster = new DataCenterWithCluster(null, cluster);
                model.getDataCenterWithClustersList().setItems(Arrays.asList(dataCenterWithCluster));
                model.getDataCenterWithClustersList().setSelectedItem(Arrays.asList(dataCenterWithCluster));
                behavior.initTemplate();
                behavior.initCdImage();
                behavior.initSoundCard(vm.getId());
            }
        }
    }, getModel().getHash()), vm.getStoragePoolId());
    AsyncDataProvider.GetWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VdcQueryReturnValue val = (VdcQueryReturnValue) returnValue;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = (Collection<VmWatchdog>) val.getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction() == null ? null : watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel() == null ? "" : watchdog.getModel().name());
            }
        }
    }), vm.getId());
}
#method_after
@Override
public void initialize(SystemTreeItemModel systemTreeSelectedItem) {
    super.initialize(systemTreeSelectedItem);
    getModel().getVmType().setIsChangable(true);
    getModel().getIsSoundcardEnabled().setIsChangable(true);
    AsyncQuery getVmNicsQuery = new AsyncQuery();
    getVmNicsQuery.asyncCallback = new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object result) {
            networkInerfaces = (List<VmNetworkInterface>) result;
            postNetworkInterfacesLoaded();
        }
    };
    AsyncDataProvider.getVmNicList(getVmNicsQuery, vm.getId());
    AsyncDataProvider.GetWatchdogByVmId(new AsyncQuery(this.getModel(), new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            UnitVmModel model = (UnitVmModel) target;
            VdcQueryReturnValue val = (VdcQueryReturnValue) returnValue;
            @SuppressWarnings("unchecked")
            Collection<VmWatchdog> watchdogs = (Collection<VmWatchdog>) val.getReturnValue();
            for (VmWatchdog watchdog : watchdogs) {
                model.getWatchdogAction().setSelectedItem(watchdog.getAction() == null ? null : watchdog.getAction().name().toLowerCase());
                model.getWatchdogModel().setSelectedItem(watchdog.getModel() == null ? "" : watchdog.getModel().name());
            }
        }
    }), vm.getId());
}
#end_block

#method_before
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getDomain().setSelectedItem(vm.getVmDomain());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(!vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().setEntity(vm.getCustomProperties());
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    Frontend.RunQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = (List<VmWatchdog>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getVncKeyboardLayout());
    if (vm.isInitialized()) {
        getModel().getTimeZone().setChangeProhibitionReason(// $NON-NLS-1$
        "Time Zone cannot be change since the Virtual Machine was booted at the first time.");
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    initPriority(vm.getPriority());
}
#method_after
@Override
public void template_SelectedItemChanged() {
    // This method will be called even if a VM created from Blank template.
    // Update model state according to VM properties.
    getModel().getName().setEntity(vm.getName());
    getModel().getDescription().setEntity(vm.getVmDescription());
    getModel().getComment().setEntity(vm.getComment());
    getModel().getMemSize().setEntity(vm.getVmMemSizeMb());
    getModel().getMinAllocatedMemory().setEntity(vm.getMinAllocatedMem());
    getModel().getOSType().setSelectedItem(vm.getVmOsId());
    getModel().getDomain().setSelectedItem(vm.getVmDomain());
    getModel().getUsbPolicy().setSelectedItem(vm.getUsbPolicy());
    getModel().getNumOfMonitors().setSelectedItem(vm.getNumOfMonitors());
    getModel().getIsSingleQxlEnabled().setEntity(vm.getSingleQxlPci());
    getModel().getAllowConsoleReconnect().setEntity(vm.getAllowConsoleReconnect());
    getModel().setBootSequence(vm.getDefaultBootSequence());
    getModel().getIsHighlyAvailable().setEntity(vm.isAutoStartup());
    getModel().getTotalCPUCores().setEntity(Integer.toString(vm.getNumOfCpus()));
    getModel().getTotalCPUCores().setIsChangable(!vm.isRunning());
    getModel().getIsStateless().setEntity(vm.isStateless());
    getModel().getIsStateless().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsRunAndPause().setEntity(vm.isRunAndPause());
    getModel().getIsRunAndPause().setIsChangable(!vm.isRunning());
    getModel().getIsRunAndPause().setIsAvailable(vm.getVmPoolId() == null);
    getModel().getIsSmartcardEnabled().setEntity(vm.isSmartcardEnabled());
    getModel().getIsDeleteProtected().setEntity(vm.isDeleteProtected());
    getModel().getNumOfSockets().setSelectedItem(vm.getNumOfSockets());
    getModel().getNumOfSockets().setIsChangable(!vm.isRunning());
    getModel().getCoresPerSocket().setIsChangable(!vm.isRunning());
    getModel().getKernel_parameters().setEntity(vm.getKernelParams());
    getModel().getKernel_path().setEntity(vm.getKernelUrl());
    getModel().getInitrd_path().setEntity(vm.getInitrdUrl());
    getModel().getCustomProperties().setEntity(vm.getCustomProperties());
    getModel().getCustomPropertySheet().setEntity(vm.getCustomProperties());
    getModel().getCpuPinning().setEntity(vm.getCpuPinning());
    getModel().getCpuSharesAmount().setEntity(vm.getCpuShares());
    updateCpuSharesSelection();
    Frontend.RunQuery(VdcQueryType.GetWatchdog, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            @SuppressWarnings("unchecked")
            List<VmWatchdog> watchdogs = (List<VmWatchdog>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            if (watchdogs.isEmpty()) {
                getModel().getWatchdogAction().setSelectedItem(null);
                getModel().getWatchdogModel().setSelectedItem(null);
            } else {
                VmWatchdog vmWatchdog = watchdogs.get(0);
                getModel().getWatchdogAction().setSelectedItem(vmWatchdog.getAction() == null ? null : vmWatchdog.getAction().name().toLowerCase());
                getModel().getWatchdogModel().setSelectedItem(vmWatchdog.getModel() == null ? "" : vmWatchdog.getModel().name());
            }
        }
    }));
    updateConsoleDevice(getVm().getId());
    getModel().getVncKeyboardLayout().setSelectedItem(vm.getVncKeyboardLayout());
    Frontend.RunQuery(VdcQueryType.IsBalloonEnabled, new IdQueryParameters(getVm().getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            getModel().getMemoryBalloonDeviceEnabled().setEntity(((VdcQueryReturnValue) returnValue).getReturnValue());
        }
    }));
    if (vm.isInitialized()) {
        UIConstants constants = ConstantsManager.getInstance().getConstants();
        getModel().getTimeZone().setChangeProhibitionReason(constants.timeZoneCannotBeChangedAfterVMInit());
        getModel().getTimeZone().setIsChangable(false);
    }
    updateTimeZone(vm.getTimeZone());
    // Update domain list
    updateDomain();
    updateHostPinning(vm.getMigrationSupport());
    getModel().getHostCpu().setEntity(vm.isUseHostCpuFlags());
    // Storage domain and provisioning are not available for an existing VM.
    getModel().getStorageDomain().setIsChangable(false);
    getModel().getProvisioning().setIsAvailable(false);
    getModel().getProvisioning().setEntity(Guid.Empty.equals(vm.getVmtGuid()));
    // Select display protocol.
    for (Object item : getModel().getDisplayProtocol().getItems()) {
        EntityModel model = (EntityModel) item;
        DisplayType displayType = (DisplayType) model.getEntity();
        if (displayType == vm.getDefaultDisplayType()) {
            getModel().getDisplayProtocol().setSelectedItem(item);
            break;
        }
    }
    initPriority(vm.getPriority());
}
#end_block

#method_before
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateCustomPropertySheet();
    updateNumOfSockets();
    updateQuotaByCluster(vm.getQuotaId(), vm.getQuotaName());
    updateCpuPinningVisibility();
    initNetworkInterfaces();
}
#method_after
@Override
public void postDataCenterWithClusterSelectedItemChanged() {
    updateDefaultHost();
    updateCustomPropertySheet();
    updateNumOfSockets();
    updateQuotaByCluster(vm.getQuotaId(), vm.getQuotaName());
    updateCpuPinningVisibility();
    updateMemoryBalloon();
    updateCpuSharesAvailability();
    updateNetworkInterfaces(networkBehavior, networkInerfaces);
}
#end_block

#method_before
@Override
public void executed(FrontendActionAsyncResult result) {
    VdcReturnValueBase returnValue = result.getReturnValue();
    if (returnValue != null && returnValue.getSucceeded()) {
        List<NicWithLogicalNetworks> nicWithLogicalNetworks = (List<NicWithLogicalNetworks>) unitVmModel.getNicsWithLogicalNetworks().getItems();
        if (nicWithLogicalNetworks == null) {
            // enter the opertation with null object if nothing has been edited by the user
            nicWithLogicalNetworks = new ArrayList<NicWithLogicalNetworks>();
        }
        doNetworkOperation(returnValue, nicWithLogicalNetworks);
    } else {
        networkCreatingManager.getCallback().queryFailed();
    }
}
#method_after
@Override
public void executed(FrontendActionAsyncResult result) {
    VdcReturnValueBase returnValue = result.getReturnValue();
    if (returnValue != null && returnValue.getSucceeded()) {
        List<VnicInstanceType> nicWithLogicalNetworks = (List<VnicInstanceType>) unitVmModel.getNicsWithLogicalNetworks().getItems();
        if (nicWithLogicalNetworks == null) {
            // enter the opertation with null object if nothing has been edited by the user
            nicWithLogicalNetworks = new ArrayList<VnicInstanceType>();
        }
        doNetworkOperation(returnValue, nicWithLogicalNetworks);
    } else {
        networkCreatingManager.getCallback().queryFailed();
    }
}
#end_block

#method_before
@Override
protected void doNetworkOperation(VdcReturnValueBase returnValue, List<NicWithLogicalNetworks> nicWithLogicalNetworks) {
    networkCreatingManager.updateOrCreateIfNothingToUpdate((Guid) returnValue.getActionReturnValue(), nicWithLogicalNetworks);
}
#method_after
@Override
protected void doNetworkOperation(VdcReturnValueBase returnValue, List<VnicInstanceType> nicWithLogicalNetworks) {
    networkCreatingManager.updateOrCreateIfNothingToUpdate((Guid) returnValue.getActionReturnValue(), nicWithLogicalNetworks);
}
#end_block

#method_before
@Override
protected void doNetworkOperation(VdcReturnValueBase returnValue, List<NicWithLogicalNetworks> nicWithLogicalNetworks) {
    networkCreatingManager.createNetworks((Guid) returnValue.getActionReturnValue(), nicWithLogicalNetworks);
}
#method_after
@Override
protected void doNetworkOperation(VdcReturnValueBase returnValue, List<VnicInstanceType> nicWithLogicalNetworks) {
    networkCreatingManager.createVnics((Guid) returnValue.getActionReturnValue(), nicWithLogicalNetworks);
}
#end_block

#method_before
@Override
protected void doNetworkOperation(VdcReturnValueBase returnValue, List<NicWithLogicalNetworks> nicWithLogicalNetworks) {
    networkCreatingManager.updateNetworks(idToUpdate, nicWithLogicalNetworks);
}
#method_after
@Override
protected void doNetworkOperation(VdcReturnValueBase returnValue, List<VnicInstanceType> nicWithLogicalNetworks) {
    networkCreatingManager.updateVnics(idToUpdate, nicWithLogicalNetworks);
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    // The snapshot being restored to
    Snapshot targetSnapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    if (targetSnapshot == null) {
        throw new VdcBLLException(VdcBllErrors.ENGINE, "Can't find target snapshot by id: " + getParameters().getDstSnapshotId());
    }
    restoreSnapshotAndRemoveObsoleteSnapshots(targetSnapshot);
    boolean succeeded = true;
    for (DiskImage image : getImagesList()) {
        if (image.getImageStatus() != ImageStatus.ILLEGAL) {
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), targetSnapshot, removedSnapshotId);
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    removeSnapshotsFromDB();
    removeNotUsedImageGroups();
    if (!getTaskIdList().isEmpty()) {
        deleteOrphanedImages();
    } else {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
        getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#method_after
@Override
protected void executeVmCommand() {
    if (!getImagesList().isEmpty()) {
        lockVmWithCompensationIfNeeded();
        if (!isInternalExecution()) {
            freeLock();
        }
    }
    // The snapshot being restored to
    Snapshot targetSnapshot = getSnapshotDao().get(getParameters().getDstSnapshotId());
    if (targetSnapshot == null) {
        throw new VdcBLLException(VdcBllErrors.ENGINE, "Can't find target snapshot by id: " + getParameters().getDstSnapshotId());
    }
    restoreSnapshotAndRemoveObsoleteSnapshots(targetSnapshot);
    boolean succeeded = true;
    for (DiskImage image : getImagesList()) {
        if (image.getImageStatus() != ImageStatus.ILLEGAL) {
            ImagesContainterParametersBase params = new RestoreFromSnapshotParameters(image.getImageId(), getVmId(), targetSnapshot, removedSnapshotId);
            VdcReturnValueBase returnValue = runAsyncTask(VdcActionType.RestoreFromSnapshot, params);
            // Save the first fault
            if (succeeded && !returnValue.getSucceeded()) {
                succeeded = false;
                getReturnValue().setFault(returnValue.getFault());
            }
        }
    }
    removeSnapshotsFromDB();
    removeUnusedImages();
    if (!getTaskIdList().isEmpty()) {
        deleteOrphanedImages();
    } else {
        getVmStaticDAO().incrementDbGeneration(getVm().getId());
        getSnapshotDao().updateStatus(getParameters().getDstSnapshotId(), SnapshotStatus.OK);
        unlockVm();
    }
    setSucceeded(succeeded);
}
#end_block

#method_before
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    Iterator<Entry<Guid, GlusterAsyncTask>> iter = runningTasks.entrySet().iterator();
    while (iter.hasNext()) {
        Entry<Guid, GlusterAsyncTask> entry = iter.next();
        Guid taskId = entry.getKey();
        GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step, task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                clearVolumeTaskAndReleaseLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#method_after
private Map<Guid, GlusterAsyncTask> updateTasksInCluster(VDSGroup cluster) {
    if (!supportsGlusterAsyncTasksFeature(cluster)) {
        return null;
    }
    Map<Guid, GlusterAsyncTask> runningTasks = getProvider().getTaskListForCluster(cluster.getId());
    if (runningTasks == null) {
        return null;
    }
    for (Entry<Guid, GlusterAsyncTask> entry : runningTasks.entrySet()) {
        Guid taskId = entry.getKey();
        GlusterAsyncTask task = entry.getValue();
        List<Step> steps = getStepDao().getStepsByExternalId(taskId);
        // update status in step table
        for (Step step : steps) {
            if (step.getEndTime() != null) {
                // we have already processed the task
                continue;
            }
            step.setDescription(getTaskMessage(cluster, step, task));
            if (hasTaskCompleted(task)) {
                step.markStepEnded(task.getStatus());
                endStepJob(step);
                releaseVolumeLock(task.getTaskId());
            } else {
                getJobRepository().updateStep(step);
            }
        }
    }
    return runningTasks;
}
#end_block

#method_before
private static boolean hasTaskCompleted(GlusterAsyncTask task) {
    if (JobExecutionStatus.ABORTED.equals(task.getStatus()) || JobExecutionStatus.FINISHED.equals(task.getStatus()) || JobExecutionStatus.FAILED.equals(task.getStatus())) {
        return true;
    }
    return false;
}
#method_after
private static boolean hasTaskCompleted(GlusterAsyncTask task) {
    if (JobExecutionStatus.ABORTED == task.getStatus() || JobExecutionStatus.FINISHED == task.getStatus() || JobExecutionStatus.FAILED == task.getStatus()) {
        return true;
    }
    return false;
}
#end_block

#method_before
@Test
public void updateTasksInCluster() {
    doReturn(getTasks()).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(volumeDao, times(1)).updateVolumeTask(VOL_GUIDS[0], null);
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[1], null);
    Mockito.verify(jobRepository, times(1)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(1)).endStepJob(any(Step.class));
}
#method_after
@Test
public void updateTasksInCluster() {
    doReturn(getTasks()).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(1)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(1)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenNoCompletedTasks() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[0], null);
    Mockito.verify(volumeDao, times(0)).updateVolumeTask(VOL_GUIDS[1], null);
    Mockito.verify(jobRepository, times(2)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenNoCompletedTasks() {
    doReturn(getTasks(JobExecutionStatus.STARTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(2)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(0)).endStepJob(any(Step.class));
}
#end_block

#method_before
@Test
public void testUpdateWhenAbortedTasks() {
    doReturn(getTasks(JobExecutionStatus.ABORTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(volumeDao, times(1)).updateVolumeTask(VOL_GUIDS[0], null);
    Mockito.verify(volumeDao, times(1)).updateVolumeTask(VOL_GUIDS[1], null);
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(2)).endStepJob(any(Step.class));
}
#method_after
@Test
public void testUpdateWhenAbortedTasks() {
    doReturn(getTasks(JobExecutionStatus.ABORTED)).when(provider).getTaskListForCluster(CLUSTER_GUIDS[1]);
    prepareMocks();
    tasksSyncJob.updateGlusterAsyncTasks();
    Mockito.verify(jobRepository, times(0)).updateStep(any(Step.class));
    Mockito.verify(tasksSyncJob, times(2)).endStepJob(any(Step.class));
}
#end_block

#method_before
public static void init() {
    if (!glusterModeSupported()) {
        log.debug("Gluster mode not supported. Will not schedule jobs for refreshing Gluster data.");
        return;
    }
    log.debug("Initializing Gluster Jobs Manager");
    SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance();
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshLightWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshHeavyWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterHookSyncJob.getInstance(), "refreshHooks", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHooks), getRefreshRate(ConfigValues.GlusterRefreshRateHooks), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterServiceSyncJob.getInstance(), "refreshGlusterServices", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterTasksSyncJob.getInstance(), "gluster_async_task_poll_event", new Class[0], new Class[0], 30, 30, TimeUnit.SECONDS);
}
#method_after
public static void init() {
    if (!glusterModeSupported()) {
        log.debug("Gluster mode not supported. Will not schedule jobs for refreshing Gluster data.");
        return;
    }
    log.debug("Initializing Gluster Jobs Manager");
    SchedulerUtil scheduler = SchedulerUtilQuartzImpl.getInstance();
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshLightWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterSyncJob.getInstance(), "refreshHeavyWeightData", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), getRefreshRate(ConfigValues.GlusterRefreshRateHeavy), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterHookSyncJob.getInstance(), "refreshHooks", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateHooks), getRefreshRate(ConfigValues.GlusterRefreshRateHooks), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterServiceSyncJob.getInstance(), "refreshGlusterServices", new Class[0], new Object[0], getRefreshRate(ConfigValues.GlusterRefreshRateLight), getRefreshRate(ConfigValues.GlusterRefreshRateLight), TimeUnit.SECONDS);
    scheduler.scheduleAFixedDelayJob(GlusterTasksSyncJob.getInstance(), "gluster_async_task_poll_event", new Class[0], new Class[0], getRefreshRate(ConfigValues.GlusterRefreshRateTasks), getRefreshRate(ConfigValues.GlusterRefreshRateTasks), TimeUnit.SECONDS);
}
#end_block

#method_before
private GlusterAsyncTask getTask(Map<String, Object> map) {
    GlusterAsyncTask task = new GlusterAsyncTask();
    return task;
}
#method_after
@SuppressWarnings("unchecked")
private GlusterAsyncTask getTask(String taskId, Map<String, Object> map) {
    GlusterAsyncTask task = new GlusterAsyncTask();
    task.setTaskId(Guid.createGuidFromString(taskId));
    task.setStatus(GlusterAsyncTaskStatus.from((String) map.get(STATUS)).getJobExecutionStatus());
    task.setType(GlusterTaskType.valueOf((String) map.get(TASK_TYPE)));
    task.setMessage(getMessage((Map<String, Object>) map.get(DATA)));
    task.setTaskParameters(new GlusterTaskParameters());
    task.getTaskParameters().setVolumeName((String) map.get(VOLUME_NAME));
    return task;
}
#end_block

#method_before
@Override
public StatusOnlyReturnForXmlRpc glusterVolumeRebalanceStart(String volumeName, Boolean fixLayoutOnly, Boolean force) {
    try {
        return new StatusOnlyReturnForXmlRpc(vdsServer.glusterVolumeRebalanceStart(volumeName, fixLayoutOnly, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#method_after
@Override
public GlusterTaskInfoReturnForXmlRpc glusterVolumeRebalanceStart(String volumeName, Boolean fixLayoutOnly, Boolean force) {
    try {
        return new GlusterTaskInfoReturnForXmlRpc(vdsServer.glusterVolumeRebalanceStart(volumeName, fixLayoutOnly, force));
    } catch (UndeclaredThrowableException ute) {
        throw new XmlRpcRunTimeException(ute);
    }
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // check if the user has permissions to add a user
    if (getParameters().getVdcUser() != null && _dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    permissions permission = getParameters().getPermission();
    List<PermissionSubject> permissionsSubject = new ArrayList<>();
    permissionsSubject.add(new PermissionSubject(permission.getObjectId(), permission.getObjectType(), getActionType().getActionGroup()));
    initUserAndGroupData();
    // user from the directory service
    if (getParameters().getVdcUser() != null && _dbUser == null) {
        permissionsSubject.add(new PermissionSubject(MultiLevelAdministrationHandler.SYSTEM_OBJECT_ID, VdcObjectType.System, VdcActionType.AddUser.getActionGroup()));
    }
    return permissionsSubject;
}
#end_block

#method_before
private static HashMap<LdapQueryType, LdapQueryMetadata> setOpenLdapMap() {
    HashMap<LdapQueryType, LdapQueryMetadata> openLdapHashMap = new HashMap<LdapQueryType, LdapQueryMetadata>();
    openLdapHashMap.put(LdapQueryType.getGroupByDN, new LdapQueryMetadataImpl("(cn=*)", "%1$s", new OpenLdapGroupContextMapper(), SearchControls.OBJECT_SCOPE, OpenLdapGroupContextMapper.GROUP_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getGroupByGuid, new LdapQueryMetadataImpl("(entryUUID=%1$s)", "", new OpenLdapGroupContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapGroupContextMapper.GROUP_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getUserByGuid, new LdapQueryMetadataImpl("(entryUUID=%1$s)", "", new OpenLdapUserContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapUserContextMapper.USERS_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getGroupByName, new LdapQueryMetadataImpl("(&(objectClass=groupOfNames)(cn=%1$s))", "", new OpenLdapGroupContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapGroupContextMapper.GROUP_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getUserByPrincipalName, new LdapQueryMetadataImpl("(uid=%1$s)", "", new OpenLdapUserContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapUserContextMapper.USERS_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getUserByName, new LdapQueryMetadataImpl("(uid=%1$s)", "", new OpenLdapUserContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapUserContextMapper.USERS_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.rootDSE, new LdapQueryMetadataImpl("(objectClass=*)", "", new DefaultRootDSEContextMapper(), SearchControls.OBJECT_SCOPE, DefaultRootDSEContextMapper.ROOTDSE_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getGroupsByGroupNames, new LdapQueryMetadataImpl("(&(objectClass=groupOfNames)(cn=%1$s))", "", new OpenLdapGroupContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapGroupContextMapper.GROUP_ATTRIBUTE_FILTER, new MultipleLdapQueryExecutionFormatter("(|", ")"), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getUsersByUserGuids, new LdapQueryMetadataImpl("(uid=%1$s)", "", new OpenLdapUserContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapUserContextMapper.USERS_ATTRIBUTE_FILTER, new MultipleLdapQueryExecutionFormatter("(|", ")"), OpenLdapGuidEncoder.getInstance()));
    LdapQueryMetadataImpl OpenLdapSearchUsersMetadata = new LdapQueryMetadataImpl("this string is replaced by user input meta-query", "", new OpenLdapUserContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapUserContextMapper.USERS_ATTRIBUTE_FILTER, new SearchQueryFotmatter(openLdapSearchSyntaxMap, upnSplitterLdapFilterSearchEnginePreProcessor), new DefaultGuidEncoder());
    openLdapHashMap.put(LdapQueryType.searchUsers, OpenLdapSearchUsersMetadata);
    LdapQueryMetadataImpl OpenLdapSearchGroupsMetadata = new LdapQueryMetadataImpl("this string is replaced by user input meta-query", "", new OpenLdapGroupContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapGroupContextMapper.GROUP_ATTRIBUTE_FILTER, new SearchQueryFotmatter(openLdapSearchSyntaxMap, noOpFilterSearchEnginePreProcessor), new DefaultGuidEncoder());
    openLdapHashMap.put(LdapQueryType.searchGroups, OpenLdapSearchGroupsMetadata);
    return openLdapHashMap;
}
#method_after
private static HashMap<LdapQueryType, LdapQueryMetadata> setOpenLdapMap() {
    HashMap<LdapQueryType, LdapQueryMetadata> openLdapHashMap = new HashMap<LdapQueryType, LdapQueryMetadata>();
    openLdapHashMap.put(LdapQueryType.getGroupByDN, new LdapQueryMetadataImpl("(cn=*)", "%1$s", new OpenLdapGroupContextMapper(), SearchControls.OBJECT_SCOPE, OpenLdapGroupContextMapper.GROUP_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getGroupByGuid, new LdapQueryMetadataImpl("(entryUUID=%1$s)", "", new OpenLdapGroupContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapGroupContextMapper.GROUP_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getUserByGuid, new LdapQueryMetadataImpl("(entryUUID=%1$s)", "", new OpenLdapUserContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapUserContextMapper.USERS_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getGroupByName, new LdapQueryMetadataImpl("(&(objectClass=groupOfNames)(cn=%1$s))", "", new OpenLdapGroupContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapGroupContextMapper.GROUP_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getUserByPrincipalName, new LdapQueryMetadataImpl("(uid=%1$s)", "", new OpenLdapUserContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapUserContextMapper.USERS_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getUserByName, new LdapQueryMetadataImpl("(uid=%1$s)", "", new OpenLdapUserContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapUserContextMapper.USERS_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.rootDSE, new LdapQueryMetadataImpl("(objectClass=*)", "", new DefaultRootDSEContextMapper(), SearchControls.OBJECT_SCOPE, DefaultRootDSEContextMapper.ROOTDSE_ATTRIBUTE_FILTER, new SimpleLdapQueryExecutionFormatter(), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getGroupsByGroupNames, new LdapQueryMetadataImpl("(&(objectClass=groupOfNames)(cn=%1$s))", "", new OpenLdapGroupContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapGroupContextMapper.GROUP_ATTRIBUTE_FILTER, new MultipleLdapQueryExecutionFormatter("(|", ")"), new DefaultGuidEncoder()));
    openLdapHashMap.put(LdapQueryType.getUsersByUserGuids, new LdapQueryMetadataImpl("(entryUUID=%1$s)", "", new OpenLdapUserContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapUserContextMapper.USERS_ATTRIBUTE_FILTER, new MultipleLdapQueryExecutionFormatter("(|", ")"), new DefaultGuidEncoder()));
    LdapQueryMetadataImpl OpenLdapSearchUsersMetadata = new LdapQueryMetadataImpl("this string is replaced by user input meta-query", "", new OpenLdapUserContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapUserContextMapper.USERS_ATTRIBUTE_FILTER, new SearchQueryFotmatter(openLdapSearchSyntaxMap, upnSplitterLdapFilterSearchEnginePreProcessor), new DefaultGuidEncoder());
    openLdapHashMap.put(LdapQueryType.searchUsers, OpenLdapSearchUsersMetadata);
    LdapQueryMetadataImpl OpenLdapSearchGroupsMetadata = new LdapQueryMetadataImpl("this string is replaced by user input meta-query", "", new OpenLdapGroupContextMapper(), SearchControls.SUBTREE_SCOPE, OpenLdapGroupContextMapper.GROUP_ATTRIBUTE_FILTER, new SearchQueryFotmatter(openLdapSearchSyntaxMap, noOpFilterSearchEnginePreProcessor), new DefaultGuidEncoder());
    openLdapHashMap.put(LdapQueryType.searchGroups, OpenLdapSearchGroupsMetadata);
    return openLdapHashMap;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVds() == null) {
        return failCanDoAction(VdcBllMessages.VDS_NOT_EXIST);
    }
    if (getVds().getStatus() != VDSStatus.Up) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_UP);
    }
    if (getStoragePoolForVds() == null) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_IN_POOL);
    }
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_ALREADY_SPM);
    }
    if (getVds().getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_MARKED_AS_NEVER_SPM);
    }
    if (getStoragePoolForVds().getStatus() != StoragePoolStatus.Up) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_STORAGE_POOL_NOT_UP);
    }
    if (isAsyncTasksRunningOnPool(getStoragePoolForVds().getId())) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_STORAGE_POOL_HAS_RUNNING_TASKS);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVds() == null) {
        return failCanDoAction(VdcBllMessages.VDS_NOT_EXIST);
    }
    if (getVds().getStatus() != VDSStatus.Up) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_UP);
    }
    if (getStoragePoolForVds() == null) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_NOT_IN_POOL);
    }
    if (getVds().getSpmStatus() != VdsSpmStatus.None) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_ALREADY_SPM);
    }
    if (getVds().getVdsSpmPriority() == BusinessEntitiesDefinitions.HOST_MIN_SPM_PRIORITY) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_VDS_MARKED_AS_NEVER_SPM);
    }
    if (!validate(new StoragePoolValidator(getStoragePoolForVds()).isUp())) {
        return false;
    }
    if (isAsyncTasksRunningOnPool(getStoragePoolForVds().getId())) {
        return failCanDoAction(VdcBllMessages.CANNOT_FORCE_SELECT_SPM_STORAGE_POOL_HAS_RUNNING_TASKS);
    }
    return true;
}
#end_block

#method_before
@Test
public void testCDAStoragePoolNotUp() {
    storagePool.setStatus(StoragePoolStatus.Uninitialized);
    assertFalse("canDoAction did not fail on a Storage Pool which is not up", command.canDoAction());
    checkMessagesContains(command, VdcBllMessages.CANNOT_FORCE_SELECT_SPM_STORAGE_POOL_NOT_UP);
}
#method_after
@Test
public void testCDAStoragePoolNotUp() {
    storagePool.setStatus(StoragePoolStatus.Uninitialized);
    assertFalse("canDoAction did not fail on a Storage Pool which is not up", command.canDoAction());
    checkMessagesContains(command, VdcBllMessages.ACTION_TYPE_FAILED_IMAGE_REPOSITORY_NOT_FOUND);
}
#end_block

#method_before
private void reportServerStatus(boolean isResponsive) {
    boolean statusChanged;
    boolean lastServerStatus = isServerUp;
    isServerUp = isResponsive;
    statusChanged = lastServerStatus ^ isResponsive;
    // reports for any server status change or in case of configure for repeatable notification
    if (statusChanged || repeatNonResponsiveNotification) {
        if (isResponsive) {
            // if server is up, report only if its status was changed from non responsive.
            if (statusChanged) {
                insertEventIntoAuditLogSafe(AuditLogType.VDC_START, AuditLogSeverity.NORMAL, ENGINE_RESPONDING_MESSAGE, "Failed auditing event down (for responsive server).");
            }
        } else {
            // reports an error for non responsive server
            EngineLocalConfig config = EngineLocalConfig.getInstance();
            if (config.getEngineUpFile().exists()) {
                // assumed crash, since engine up file is still there
                insertEventIntoAuditLogSafe(AuditLogType.VDC_STOP, AuditLogSeverity.ERROR, ENGINE_NOT_RESPONDING_ERROR, "Failed auditing event up (for crashed non responsive server).");
            } else {
                insertEventIntoAuditLogSafe(AuditLogType.VDC_STOP, AuditLogSeverity.WARNING, ENGINE_NOT_RESPONDING_ERROR, "Failed auditing event up (for stopped non responsive server).");
            }
        }
    }
}
#method_after
private void reportServerStatus(boolean isResponsive) {
    boolean statusChanged;
    boolean lastServerStatus = isServerUp;
    isServerUp = isResponsive;
    statusChanged = lastServerStatus ^ isResponsive;
    // reports for any server status change or in case of configure for repeatable notification
    if (statusChanged || repeatNonResponsiveNotification) {
        if (isResponsive) {
            // if server is up, report only if its status was changed from non responsive.
            if (statusChanged) {
                insertEventIntoAuditLogSafe(AuditLogType.VDC_START, AuditLogSeverity.NORMAL, ENGINE_RESPONDING_MESSAGE, "Failed auditing event down (for responsive server).");
            }
        } else {
            // reports an error for non responsive server
            EngineLocalConfig config = EngineLocalConfig.getInstance();
            if (config.getEngineUpMark().exists()) {
                // assumed crash, since engine up file is still there
                insertEventIntoAuditLogSafe(AuditLogType.VDC_STOP, AuditLogSeverity.ERROR, ENGINE_NOT_RESPONDING_ERROR, "Failed auditing event up (for crashed non responsive server).");
            } else {
                insertEventIntoAuditLogSafe(AuditLogType.VDC_STOP, AuditLogSeverity.WARNING, ENGINE_NOT_RESPONDING_ERROR, "Failed auditing event up (for stopped non responsive server).");
            }
        }
    }
}
#end_block

#method_before
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInTransaction(_vmDynamicToSave);
    getDbFacade().getVmStatisticsDao().updateAllInTransaction(_vmStatisticsToSave);
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInTransaction(allVmInterfaceStatistics);
    updateAllInTransaction(_vmDiskImageDynamicToSave.values(), getDbFacade().getDiskImageDynamicDao());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
}
#method_after
private void saveDataToDb() {
    if (_saveVdsDynamic) {
        _vdsManager.UpdateDynamicData(_vds.getDynamicData());
    }
    if (_saveVdsStatistics) {
        VdsStatistics stat = _vds.getStatisticsData();
        _vdsManager.UpdateStatisticsData(stat);
        checkVdsMemoryThreshold(stat);
        checkVdsCpuThreshold(stat);
        checkVdsNetworkThreshold(stat);
        checkVdsSwapThreshold(stat);
        final List<VdsNetworkStatistics> statistics = new LinkedList<VdsNetworkStatistics>();
        for (VdsNetworkInterface iface : _vds.getInterfaces()) {
            statistics.add(iface.getStatistics());
        }
        if (!statistics.isEmpty()) {
            TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    getDbFacade().getInterfaceDao().massUpdateStatisticsForVds(statistics);
                    return null;
                }
            });
        }
    }
    getDbFacade().getVmDynamicDao().updateAllInBatch(_vmDynamicToSave.values());
    getDbFacade().getVmStatisticsDao().updateAllInBatch(_vmStatisticsToSave.values());
    final List<VmNetworkStatistics> allVmInterfaceStatistics = new LinkedList<VmNetworkStatistics>();
    for (List<VmNetworkInterface> list : _vmInterfaceStatisticsToSave.values()) {
        for (VmNetworkInterface iface : list) {
            allVmInterfaceStatistics.add(iface.getStatistics());
        }
    }
    getDbFacade().getVmNetworkStatisticsDao().updateAllInBatch(allVmInterfaceStatistics);
    getDbFacade().getDiskImageDynamicDao().updateAllInBatch(_vmDiskImageDynamicToSave.values());
    saveVmDevicesToDb();
    saveVmGuestAgentNetworkDevices();
    ResourceManager.getInstance().getEventListener().addExternallyManagedVms(_externalVmsToAdd);
}
#end_block

#method_before
private void saveVmDevicesToDb() {
    updateAllInTransaction("UpdateVmDeviceRuntimeInfo", vmDeviceToSave.values(), getDbFacade().getVmDeviceDao());
    if (!removedDeviceIds.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDao().removeAll(removedDeviceIds);
                return null;
            }
        });
    }
    if (!newVmDevices.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDao().saveAll(newVmDevices);
                return null;
            }
        });
    }
}
#method_after
private void saveVmDevicesToDb() {
    getDbFacade().getVmDeviceDao().updateAllInBatch(vmDeviceToSave.values());
    if (!removedDeviceIds.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDao().removeAll(removedDeviceIds);
                return null;
            }
        });
    }
    if (!newVmDevices.isEmpty()) {
        TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Void>() {

            @Override
            public Void runInTransaction() {
                getDbFacade().getVmDeviceDao().saveAll(newVmDevices);
                return null;
            }
        });
    }
}
#end_block

#method_before
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getmem_available() == null || stat.getusage_mem_percent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getmem_available() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if (stat.getmem_available() < minAvailableThreshold || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getmem_available().toString());
        logable.addCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.addCustomValue("Threshold", stat.getmem_available() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#method_after
private void checkVdsMemoryThreshold(VdsStatistics stat) {
    Integer minAvailableThreshold = Config.GetValue(ConfigValues.LogPhysicalMemoryThresholdInMB);
    Integer maxUsedPercentageThreshold = Config.GetValue(ConfigValues.LogMaxPhysicalMemoryUsedThresholdInPercentage);
    if (stat.getMemFree() == null || stat.getusage_mem_percent() == null) {
        return;
    }
    AuditLogType valueToLog = stat.getMemFree() < minAvailableThreshold ? AuditLogType.VDS_LOW_MEM : AuditLogType.VDS_HIGH_MEM_USE;
    if ((stat.getMemFree() < minAvailableThreshold && Version.v3_2.compareTo(_vds.getVersion()) <= 0) || stat.getusage_mem_percent() > maxUsedPercentageThreshold) {
        AuditLogableBase logable = new AuditLogableBase(stat.getId());
        logable.addCustomValue("HostName", _vds.getName());
        logable.addCustomValue("AvailableMemory", stat.getMemFree().toString());
        logable.addCustomValue("UsedMemory", stat.getusage_mem_percent().toString());
        logable.addCustomValue("Threshold", stat.getMemFree() < minAvailableThreshold ? minAvailableThreshold.toString() : maxUsedPercentageThreshold.toString());
        auditLog(logable, valueToLog);
    }
}
#end_block

#method_before
private void markIsSetNonOperationalExecuted() {
    if (!_vdsManager.isSetNonOperationalExecuted()) {
        VdsDynamic vdsDynamic = getDbFacade().getVdsDynamicDao().get(_vds.getId());
        if (vdsDynamic.getstatus() == VDSStatus.NonOperational) {
            _vdsManager.setIsSetNonOperationalExecuted(true);
        }
    }
}
#method_after
private void markIsSetNonOperationalExecuted() {
    if (!_vdsManager.isSetNonOperationalExecuted()) {
        VdsDynamic vdsDynamic = getDbFacade().getVdsDynamicDao().get(_vds.getId());
        if (vdsDynamic.getStatus() == VDSStatus.NonOperational) {
            _vdsManager.setIsSetNonOperationalExecuted(true);
        }
    }
}
#end_block

#method_before
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedDownVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#method_after
private void refreshVmStats() {
    if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
        log.debug("vds::refreshVmList entered");
    }
    VdsBrokerCommand<VdsIdAndVdsVDSCommandParametersBase> command;
    if (!_vdsManager.getRefreshStatistics()) {
        command = new ListVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    } else {
        command = new GetAllVmStatsVDSCommand<VdsIdAndVdsVDSCommandParametersBase>(new VdsIdAndVdsVDSCommandParametersBase(_vds));
    }
    _runningVms = (Map<Guid, VmInternalData>) command.executeWithReturnValue();
    if (command.getVDSReturnValue().getSucceeded()) {
        List<VM> running = checkVmsStatusChanged();
        proceedWatchdogEvents();
        proceedBalloonCheck();
        proceedDownVms();
        proceedGuaranteedMemoryCheck();
        processExternallyManagedVms();
        // update repository and check if there are any vm in cache that not
        // in vdsm
        updateRepository(running);
        // Going over all returned VMs and updting the data structures
        // accordingly
        // checking the db for incoherent vm status;
        // setVmStatusDownForVmNotFound();
        refreshCommitedMemory();
        // Handle VM devices were changed (for 3.1 cluster and above)
        if (!VmDeviceCommonUtils.isOldClusterVersion(_vds.getVdsGroupCompatibilityVersion())) {
            handleVmDeviceChange();
        }
        prepareGuestAgentNetworkDevicesForUpdate();
    } else if (command.getVDSReturnValue().getExceptionObject() != null) {
        if (command.getVDSReturnValue().getExceptionObject() instanceof VDSErrorException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSNetworkException) {
            _saveVdsDynamic = _vdsManager.handleNetworkException((VDSNetworkException) command.getVDSReturnValue().getExceptionObject(), _vds);
        } else if (command.getVDSReturnValue().getExceptionObject() instanceof VDSProtocolException) {
            log.errorFormat("Failed vds listing,  vds = {0} : {1}, error = {2}", _vds.getId(), _vds.getName(), command.getVDSReturnValue().getExceptionString());
        }
        throw command.getVDSReturnValue().getExceptionObject();
    } else {
        log.error("GetCapabilitiesVDSCommand failed with no exception!");
    }
}
#end_block

#method_before
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.NewGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, false, alias, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#method_after
private Guid addNewVmDevice(Guid vmId, Map device) {
    Guid newDeviceId = Guid.Empty;
    String typeName = (String) device.get(VdsProperties.Type);
    String deviceName = (String) device.get(VdsProperties.Device);
    // do not allow null or empty device or type values
    if (StringUtils.isEmpty(typeName) || StringUtils.isEmpty(deviceName)) {
        log.errorFormat("Empty or NULL values were passed for a VM {0} device, Device is skipped", vmId);
    } else {
        String address = ((Map<String, String>) device.get(VdsProperties.Address)).toString();
        String alias = StringUtils.defaultString((String) device.get(VdsProperties.Alias));
        Object o = device.get(VdsProperties.SpecParams);
        newDeviceId = Guid.newGuid();
        VmDeviceId id = new VmDeviceId(newDeviceId, vmId);
        VmDevice newDevice = new VmDevice(id, VmDeviceGeneralType.forValue(typeName), deviceName, address, 0, o == null ? new HashMap<String, Object>() : (Map<String, Object>) o, false, true, false, alias, null);
        newVmDevices.add(newDevice);
        log.debugFormat("New device was marked for adding to VM {0} Devices : {1}", vmId, newDevice);
    }
    return newDeviceId;
}
#end_block

#method_before
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        case PoweredDown:
            {
                logable.addCustomValue("VmStatus", "PoweredDown");
                type = AuditLogType.VM_DOWN;
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#method_after
private void proceedVmBeforeDeletion(VM curVm, VmDynamic vmDynamic) {
    AuditLogType type = AuditLogType.UNASSIGNED;
    AuditLogableBase logable = new AuditLogableBase(_vds.getId(), curVm.getId());
    switch(curVm.getStatus()) {
        case MigratingFrom:
            {
                // exit status that's OK, otherwise..
                if (vmDynamic != null && vmDynamic.getExitStatus() != VmExitStatus.Normal) {
                    if (curVm.getMigratingToVds() != null) {
                        DestroyVmVDSCommand<DestroyVmVDSCommandParameters> destroyCmd = new DestroyVmVDSCommand<DestroyVmVDSCommandParameters>(new DestroyVmVDSCommandParameters(new Guid(curVm.getMigratingToVds().toString()), curVm.getId(), true, false, 0));
                        destroyCmd.execute();
                        if (destroyCmd.getVDSReturnValue().getSucceeded()) {
                            log.infoFormat("Stopped migrating vm: {0} on vds: {1}", curVm.getName(), curVm.getMigratingToVds());
                        } else {
                            log.infoFormat("Could not stop migrating vm: {0} on vds: {1}, Error: {2}", curVm.getName(), curVm.getMigratingToVds(), destroyCmd.getVDSReturnValue().getExceptionString());
                        }
                    }
                    // set vm status to down if source vm crushed
                    ResourceManager.getInstance().InternalSetVmStatus(curVm, VMStatus.Down, vmDynamic.getExitStatus(), vmDynamic.getExitMessage());
                    addVmDynamicToList(curVm.getDynamicData());
                    addVmStatisticsToList(curVm.getStatisticsData());
                    addVmInterfaceStatisticsToList(curVm.getInterfaces());
                    type = AuditLogType.VM_MIGRATION_ABORT;
                    logable.addCustomValue("MigrationError", vmDynamic.getExitMessage());
                    ResourceManager.getInstance().RemoveAsyncRunningVm(vmDynamic.getId());
                }
                break;
            }
        default:
            break;
    }
    if (type != AuditLogType.UNASSIGNED) {
        auditLog(logable, type);
    }
}
#end_block

#method_before
private void handOverVM(VM vmToRemove) {
    NGuid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.infoFormat("Handing over VM {0} {1} to Host {2}. Setting VM to status {3}", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    addVmDynamicToList(vmToRemove.getDynamicData());
    addVmStatisticsToList(vmToRemove.getStatisticsData());
    addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
}
#method_after
private void handOverVM(VM vmToRemove) {
    Guid destinationHostId = vmToRemove.getMigratingToVds();
    // when the destination VDS is NonResponsive put the VM to Uknown like the rest of its VMs, else MigratingTo
    VMStatus newVmStatus = (VDSStatus.NonResponsive == getDbFacade().getVdsDao().get(destinationHostId).getStatus()) ? VMStatus.Unknown : VMStatus.MigratingTo;
    // handing over the VM to the DST by marking it running on it. it will now be its SRC host.
    vmToRemove.setRunOnVds(destinationHostId);
    log.infoFormat("Handing over VM {0} {1} to Host {2}. Setting VM to status {3}", vmToRemove.getName(), vmToRemove.getId(), destinationHostId, newVmStatus);
    // if the DST host goes unresponsive it will take care all MigratingTo and unknown VMs
    ResourceManager.getInstance().InternalSetVmStatus(vmToRemove, newVmStatus);
    // save the VM state
    addVmDynamicToList(vmToRemove.getDynamicData());
    addVmStatisticsToList(vmToRemove.getStatisticsData());
    addVmInterfaceStatisticsToList(vmToRemove.getInterfaces());
}
#end_block

#method_before
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // dont check fields:
        props.remove("vmHost");
        props.remove("runOnVds");
        props.remove("disks");
        props.remove("bootSequence");
        props.remove("lastVdsRunOn");
        props.remove("hibernationVolHandle");
        props.remove("exitMessage");
        props.remove("lastStartTime");
        props.remove("consoleUserId");
        props.remove("consoleCurrentUserName");
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove("appList");
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains("status") && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove("status");
        }
        // if anything else changed
        if (props.size() > 0) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#method_after
private boolean updateVmRunTimeInfo(RefObject<VM> vmToUpdate, VmDynamic vmNewDynamicData) {
    boolean returnValue = false;
    if (vmToUpdate.argvalue == null) {
        vmToUpdate.argvalue = getDbFacade().getVmDao().get(vmNewDynamicData.getId());
        // if vm exists in db update info
        if (vmToUpdate.argvalue != null) {
            // TODO: This is done to keep consistency with VmDAO.getById(Guid).
            // It should probably be removed, but some research is required.
            vmToUpdate.argvalue.setInterfaces(getDbFacade().getVmNetworkInterfaceDao().getAllForVm(vmToUpdate.argvalue.getId()));
            _vmDict.put(vmToUpdate.argvalue.getId(), vmToUpdate.argvalue);
            if (vmNewDynamicData.getStatus() == VMStatus.Up) {
                if (!_succededToRunVms.contains(vmToUpdate.argvalue.getId())) {
                    _succededToRunVms.add(vmToUpdate.argvalue.getId());
                }
            }
        }
    }
    if (vmToUpdate.argvalue != null) {
        // check if dynamic data changed - update cache and DB
        List<String> props = ObjectIdentityChecker.GetChangedFields(vmToUpdate.argvalue.getDynamicData(), vmNewDynamicData);
        // dont check fields:
        props.remove("vmHost");
        props.remove("runOnVds");
        props.remove("disks");
        props.remove("bootSequence");
        props.remove("lastVdsRunOn");
        props.remove("hibernationVolHandle");
        props.remove("exitMessage");
        props.remove("lastStartTime");
        props.remove("consoleUserId");
        props.remove("consoleCurrentUserName");
        props.remove("runOnce");
        if (vmNewDynamicData.getStatus() != VMStatus.Up) {
            props.remove("appList");
            vmNewDynamicData.setAppList(vmToUpdate.argvalue.getAppList());
        } else if (props.contains("status") && vmToUpdate.argvalue.getDynamicData().getStatus() == VMStatus.PreparingForHibernate) {
            vmNewDynamicData.setStatus(VMStatus.PreparingForHibernate);
            props.remove("status");
        }
        // if anything else changed
        if (props.size() > 0) {
            vmToUpdate.argvalue.updateRunTimeDynamicData(vmNewDynamicData, _vds.getId(), _vds.getName());
            returnValue = true;
        }
    } else {
        // line.
        if (Config.<Boolean>GetValue(ConfigValues.DebugTimerLogging)) {
            log.info("VDS::UpdateVmRunTimeInfo Error: found VM on a VDS that is not in the database!");
        }
    }
    return returnValue;
}
#end_block

#method_before
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // update for the AI.
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#method_after
private void updateVmStatistics(VM vmToUpdate) {
    // check if time for vm statistics refresh - update cache and DB
    if (_vdsManager.getRefreshStatistics()) {
        VmStatistics vmStatistics = _runningVms.get(vmToUpdate.getId()).getVmStatistics();
        vmToUpdate.updateRunTimeStatisticsData(vmStatistics, vmToUpdate);
        addVmStatisticsToList(vmToUpdate.getStatisticsData());
        updateInterfaceStatistics(vmToUpdate, vmStatistics);
        for (DiskImageDynamic imageDynamic : _runningVms.get(vmToUpdate.getId()).getVmDynamic().getDisks()) {
            Disk disk = getDbFacade().getDiskDao().get(imageDynamic.getId());
            // We also check if the disk is null, as, for external VMs the disk is not in the database
            if (disk != null && disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage diskImage = (DiskImage) disk;
                Guid activeImageId = diskImage.getImageId();
                imageDynamic.setId(activeImageId);
                _vmDiskImageDynamicToSave.put(activeImageId, imageDynamic);
            }
        }
    }
}
#end_block

#method_before
private void addVmInterfaceStatisticsToList(List<VmNetworkInterface> list) {
    if (list.size() <= 0) {
        return;
    }
    _vmInterfaceStatisticsToSave.put(list.get(0).getVmId().getValue(), list);
}
#method_after
private void addVmInterfaceStatisticsToList(List<VmNetworkInterface> list) {
    if (list.size() <= 0) {
        return;
    }
    _vmInterfaceStatisticsToSave.put(list.get(0).getVmId(), list);
}
#end_block

#method_before
@Override
protected RowMapper<VmStatistics> createEntityRowMapper() {
    return new RowMapper<VmStatistics>() {

        @Override
        public VmStatistics mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmStatistics entity = new VmStatistics();
            entity.setcpu_sys(rs.getDouble("cpu_sys"));
            entity.setcpu_user(rs.getDouble("cpu_user"));
            entity.setelapsed_time(rs.getDouble("elapsed_time"));
            entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
            entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
            entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
            entity.setDisksUsage((String) rs.getObject("disks_usage"));
            entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
            return entity;
        }
    };
}
#method_after
@Override
protected RowMapper<VmStatistics> createEntityRowMapper() {
    return new RowMapper<VmStatistics>() {

        @Override
        public VmStatistics mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmStatistics entity = new VmStatistics();
            entity.setcpu_sys(rs.getDouble("cpu_sys"));
            entity.setcpu_user(rs.getDouble("cpu_user"));
            entity.setelapsed_time(rs.getDouble("elapsed_time"));
            entity.setusage_cpu_percent((Integer) rs.getObject("usage_cpu_percent"));
            entity.setusage_mem_percent((Integer) rs.getObject("usage_mem_percent"));
            entity.setusage_network_percent((Integer) rs.getObject("usage_network_percent"));
            entity.setDisksUsage((String) rs.getObject("disks_usage"));
            entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
            return entity;
        }
    };
}
#end_block

#method_before
@SuppressWarnings("unchecked")
@Override
public List<VmDynamic> getAllRunningForVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", id);
    RowMapper<VmDynamic> mapper = createEntityRowMapper();
    return getCallsHandler().executeReadList("GetVmsDynamicRunningOnVds", mapper, parameterSource);
}
#method_after
@Override
public List<VmDynamic> getAllRunningForVds(Guid id) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("vds_id", id);
    RowMapper<VmDynamic> mapper = createEntityRowMapper();
    return getCallsHandler().executeReadList("GetVmsDynamicRunningOnVds", mapper, parameterSource);
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getAppList()).addValue("guest_cur_user_name", vm.getGuestCurrentUserName()).addValue("console_cur_user_name", vm.getConsoleCurrentUserName()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_last_login_time", vm.getGuestLastLoginTime()).addValue("guest_last_logout_time", vm.getGuestLastLogoutTime()).addValue("guest_os", vm.getGuestOs()).addValue("migrating_to_vds", vm.getMigratingToVds()).addValue("run_on_vds", vm.getRunOnVds()).addValue("status", vm.getStatus()).addValue("vm_host", vm.getVmHost()).addValue("vm_ip", vm.getVmIp()).addValue("last_start_time", vm.getLastStartTime()).addValue("vm_pid", vm.getVmPid()).addValue("display", vm.getDisplay()).addValue("acpi_enable", vm.getAcpiEnable()).addValue("session", vm.getSession()).addValue("display_ip", vm.getDisplayIp()).addValue("display_type", vm.getDisplayType()).addValue("kvm_enable", vm.getKvmEnable()).addValue("boot_sequence", vm.getBootSequence()).addValue("display_secure_port", vm.getDisplaySecurePort()).addValue("utc_diff", vm.getUtcDiff()).addValue("last_vds_run_on", vm.getLastVdsRunOn()).addValue("client_ip", vm.getClientIp()).addValue("guest_requested_memory", vm.getGuestRequestedMemory()).addValue("hibernation_vol_handle", vm.getHibernationVolHandle()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("hash", vm.getHash()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()).addValue("last_watchdog_event", vm.getLastWatchdogEvent()).addValue("last_watchdog_action", vm.getLastWatchdogAction());
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(VmDynamic vm) {
    return createIdParameterMapper(vm.getId()).addValue("app_list", vm.getAppList()).addValue("guest_cur_user_name", vm.getGuestCurrentUserName()).addValue("console_cur_user_name", vm.getConsoleCurrentUserName()).addValue("console_user_id", vm.getConsoleUserId()).addValue("guest_last_login_time", vm.getGuestLastLoginTime()).addValue("guest_last_logout_time", vm.getGuestLastLogoutTime()).addValue("guest_os", vm.getGuestOs()).addValue("migrating_to_vds", vm.getMigratingToVds()).addValue("run_on_vds", vm.getRunOnVds()).addValue("status", vm.getStatus()).addValue("vm_host", vm.getVmHost()).addValue("vm_ip", vm.getVmIp()).addValue("last_start_time", vm.getLastStartTime()).addValue("vm_pid", vm.getVmPid()).addValue("display", vm.getDisplay()).addValue("acpi_enable", vm.getAcpiEnable()).addValue("session", vm.getSession()).addValue("display_ip", vm.getDisplayIp()).addValue("display_type", vm.getDisplayType()).addValue("kvm_enable", vm.getKvmEnable()).addValue("boot_sequence", vm.getBootSequence()).addValue("display_secure_port", vm.getDisplaySecurePort()).addValue("utc_diff", vm.getUtcDiff()).addValue("last_vds_run_on", vm.getLastVdsRunOn()).addValue("client_ip", vm.getClientIp()).addValue("guest_requested_memory", vm.getGuestRequestedMemory()).addValue("hibernation_vol_handle", vm.getHibernationVolHandle()).addValue("exit_status", vm.getExitStatus().getValue()).addValue("pause_status", vm.getPauseStatus().getValue()).addValue("exit_message", vm.getExitMessage()).addValue("hash", vm.getHash()).addValue("guest_agent_nics_hash", vm.getGuestAgentNicsHash()).addValue("last_watchdog_event", vm.getLastWatchdogEvent()).addValue("last_watchdog_action", vm.getLastWatchdogAction()).addValue("is_run_once", vm.isRunOnce());
}
#end_block

#method_before
@Override
protected RowMapper<VmDynamic> createEntityRowMapper() {
    return new RowMapper<VmDynamic>() {

        @Override
        public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmDynamic entity = new VmDynamic();
            entity.setAppList(rs.getString("app_list"));
            entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
            entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
            entity.setConsoleUserId(NGuid.createGuidFromString(rs.getString("console_user_id")));
            entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
            entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
            entity.setGuestOs(rs.getString("guest_os"));
            entity.setMigratingToVds(NGuid.createGuidFromString(rs.getString("migrating_to_vds")));
            entity.setRunOnVds(NGuid.createGuidFromString(rs.getString("run_on_vds")));
            entity.setStatus(VMStatus.forValue(rs.getInt("status")));
            entity.setId(Guid.createGuidFromString(rs.getString("vm_guid")));
            entity.setVmHost(rs.getString("vm_host"));
            entity.setVmIp(rs.getString("vm_ip"));
            entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
            entity.setVmPid((Integer) rs.getObject("vm_pid"));
            entity.setDisplay((Integer) rs.getObject("display"));
            entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
            entity.setSession(SessionState.forValue(rs.getInt("session")));
            entity.setDisplayIp(rs.getString("display_ip"));
            entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
            entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
            entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
            entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
            entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
            entity.setLastVdsRunOn(NGuid.createGuidFromString(rs.getString("last_vds_run_on")));
            entity.setClientIp(rs.getString("client_ip"));
            entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
            entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
            VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
            VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
            entity.setExitMessage(rs.getString("exit_message"));
            entity.setExitStatus(exitStatus);
            entity.setPauseStatus(pauseStatus);
            entity.setHash(rs.getString("hash"));
            entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
            entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
            entity.setLastWatchdogAction(rs.getString("last_watchdog_action"));
            return entity;
        }
    };
}
#method_after
@Override
protected RowMapper<VmDynamic> createEntityRowMapper() {
    return new RowMapper<VmDynamic>() {

        @Override
        public VmDynamic mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmDynamic entity = new VmDynamic();
            entity.setAppList(rs.getString("app_list"));
            entity.setGuestCurrentUserName(rs.getString("guest_cur_user_name"));
            entity.setConsoleCurrentUserName(rs.getString("console_cur_user_name"));
            entity.setConsoleUserId(getGuid(rs, "console_user_id"));
            entity.setGuestLastLoginTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_login_time")));
            entity.setGuestLastLogoutTime(DbFacadeUtils.fromDate(rs.getTimestamp("guest_last_logout_time")));
            entity.setGuestOs(rs.getString("guest_os"));
            entity.setMigratingToVds(getGuid(rs, "migrating_to_vds"));
            entity.setRunOnVds(getGuid(rs, "run_on_vds"));
            entity.setStatus(VMStatus.forValue(rs.getInt("status")));
            entity.setId(getGuidDefaultEmpty(rs, "vm_guid"));
            entity.setVmHost(rs.getString("vm_host"));
            entity.setVmIp(rs.getString("vm_ip"));
            entity.setLastStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("last_start_time")));
            entity.setVmPid((Integer) rs.getObject("vm_pid"));
            entity.setDisplay((Integer) rs.getObject("display"));
            entity.setAcpiEnable((Boolean) rs.getObject("acpi_enable"));
            entity.setSession(SessionState.forValue(rs.getInt("session")));
            entity.setDisplayIp(rs.getString("display_ip"));
            entity.setDisplayType(DisplayType.forValue(rs.getInt("display_type")));
            entity.setKvmEnable((Boolean) rs.getObject("kvm_enable"));
            entity.setBootSequence(BootSequence.forValue(rs.getInt("boot_sequence")));
            entity.setDisplaySecurePort((Integer) rs.getObject("display_secure_port"));
            entity.setUtcDiff((Integer) rs.getObject("utc_diff"));
            entity.setLastVdsRunOn(getGuid(rs, "last_vds_run_on"));
            entity.setClientIp(rs.getString("client_ip"));
            entity.setGuestRequestedMemory((Integer) rs.getObject("guest_requested_memory"));
            entity.setHibernationVolHandle(rs.getString("hibernation_vol_handle"));
            VmExitStatus exitStatus = VmExitStatus.forValue(rs.getInt("exit_status"));
            VmPauseStatus pauseStatus = VmPauseStatus.forValue(rs.getInt("pause_status"));
            entity.setExitMessage(rs.getString("exit_message"));
            entity.setExitStatus(exitStatus);
            entity.setPauseStatus(pauseStatus);
            entity.setHash(rs.getString("hash"));
            entity.setGuestAgentNicsHash(rs.getInt("guest_agent_nics_hash"));
            entity.setLastWatchdogEvent(getLong(rs, "last_watchdog_event"));
            entity.setLastWatchdogAction(rs.getString("last_watchdog_action"));
            entity.setRunOnce(rs.getBoolean("is_run_once"));
            return entity;
        }
    };
}
#end_block

#method_before
@Override
protected RowMapper<VmNetworkStatistics> createEntityRowMapper() {
    return new RowMapper<VmNetworkStatistics>() {

        @Override
        public VmNetworkStatistics mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmNetworkStatistics entity = new VmNetworkStatistics();
            entity.setId(Guid.createGuidFromString(rs.getString("id")));
            entity.setReceiveRate(rs.getDouble("rx_rate"));
            entity.setTransmitRate(rs.getDouble("tx_rate"));
            entity.setReceiveDropRate(rs.getDouble("rx_drop"));
            entity.setTransmitDropRate(rs.getDouble("tx_drop"));
            entity.setStatus(InterfaceStatus.forValue(rs.getInt("iface_status")));
            return entity;
        }
    };
}
#method_after
@Override
protected RowMapper<VmNetworkStatistics> createEntityRowMapper() {
    return new RowMapper<VmNetworkStatistics>() {

        @Override
        public VmNetworkStatistics mapRow(ResultSet rs, int rowNum) throws SQLException {
            VmNetworkStatistics entity = new VmNetworkStatistics();
            entity.setId(getGuidDefaultEmpty(rs, "id"));
            entity.setReceiveRate(rs.getDouble("rx_rate"));
            entity.setTransmitRate(rs.getDouble("tx_rate"));
            entity.setReceiveDropRate(rs.getDouble("rx_drop"));
            entity.setTransmitDropRate(rs.getDouble("tx_drop"));
            entity.setStatus(InterfaceStatus.forValue(rs.getInt("iface_status")));
            return entity;
        }
    };
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSStatus lastStatus = getVds().getStatus();
    VDSReturnValue vdsReturnValue = null;
    try {
        // Set status immediately to prevent a race (BZ 636950/656224)
        setStatus();
        // Regular (no secondary agent) , multiple sequential agents or multiple concurent agents
        if (StringUtils.isEmpty(getVds().getPmSecondaryIp())) {
            handleSingleAgent(lastStatus, vdsReturnValue);
        } else {
            if (getVds().isPmSecondaryConcurrent()) {
                handleMultipleConcurrentAgents(lastStatus, vdsReturnValue);
            } else {
                handleMultipleSequentialAgents(lastStatus, vdsReturnValue);
            }
        }
        setSucceeded(getFenceSucceeded());
    } finally {
        if (!getSucceeded()) {
            setStatus(lastStatus);
            AlertIfPowerManagementOperationFailed();
        }
    }
}
#method_after
@Override
protected void executeCommand() {
    VDSStatus lastStatus = getVds().getStatus();
    VDSReturnValue vdsReturnValue = null;
    try {
        // Set status immediately to prevent a race (BZ 636950/656224)
        setStatus();
        // Regular (no secondary agent) , multiple sequential agents or multiple concurrent agents
        if (StringUtils.isEmpty(getVds().getPmSecondaryIp())) {
            handleSingleAgent(lastStatus, vdsReturnValue);
        } else {
            if (getVds().isPmSecondaryConcurrent()) {
                handleMultipleConcurrentAgents(lastStatus, vdsReturnValue);
            } else {
                handleMultipleSequentialAgents(lastStatus, vdsReturnValue);
            }
        }
        setSucceeded(getFenceSucceeded());
    } finally {
        if (!getSucceeded()) {
            setStatus(lastStatus);
            AlertIfPowerManagementOperationFailed();
        }
    }
}
#end_block

#method_before
private void handleMultipleConcurrentAgents(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    primaryExecutor = new FenceExecutor(getVds(), getParameters().getAction());
    secondaryExecutor = new FenceExecutor(getVds(), getParameters().getAction());
    if (primaryExecutor.findProxyHost() && secondaryExecutor.findProxyHost()) {
        primaryResult = new FenceInvocationResult();
        secondaryResult = new FenceInvocationResult();
        List<Callable<FenceInvocationResult>> tasks = new ArrayList<Callable<FenceInvocationResult>>();
        Future<FenceInvocationResult> f1 = null;
        Future<FenceInvocationResult> f2 = null;
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(primaryExecutor, FenceAgentOrder.Primary);
            }
        });
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(secondaryExecutor, FenceAgentOrder.Secondary);
            }
        });
        try {
            ExecutorCompletionService<FenceInvocationResult> ecs = ThreadPoolUtil.createCompletionService(tasks);
            switch(getParameters().getAction()) {
                case Start:
                    try {
                        f1 = ecs.take();
                        setResult(f1);
                        if (primaryResult.isSucceeded() || secondaryResult.isSucceeded()) {
                            handleSpecificCommandActions();
                            setFenceSucceeded(true);
                        } else {
                            tryOtherConcurrentAgent(lastStatus, ecs);
                        }
                    } catch (InterruptedException e) {
                        tryOtherConcurrentAgent(lastStatus, ecs);
                    } catch (ExecutionException e) {
                        tryOtherConcurrentAgent(lastStatus, ecs);
                    }
                    break;
                case Stop:
                    f1 = ecs.take();
                    f2 = ecs.take();
                    if (f1.get().getOrder() == FenceAgentOrder.Primary) {
                        primaryResult = f1.get();
                        secondaryResult = f2.get();
                    } else {
                        primaryResult = f2.get();
                        secondaryResult = f1.get();
                    }
                    if (primaryResult.isSucceeded() && secondaryResult.isSucceeded()) {
                        handleSpecificCommandActions();
                        setFenceSucceeded(true);
                    } else {
                        handleError(lastStatus, !primaryResult.isSucceeded() ? primaryResult.getValue() : secondaryResult.getValue(), !primaryResult.isSucceeded() ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
                    }
                    break;
                default:
                    setFenceSucceeded(true);
                    break;
            }
        } catch (InterruptedException e) {
            log.error(e);
        } catch (ExecutionException e) {
            log.error(e);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#method_after
private void handleMultipleConcurrentAgents(VDSStatus lastStatus, VDSReturnValue vdsReturnValue) {
    primaryExecutor = new FenceExecutor(getVds(), getParameters().getAction());
    secondaryExecutor = new FenceExecutor(getVds(), getParameters().getAction());
    if (primaryExecutor.findProxyHost() && secondaryExecutor.findProxyHost()) {
        primaryResult = new FenceInvocationResult();
        secondaryResult = new FenceInvocationResult();
        List<Callable<FenceInvocationResult>> tasks = new ArrayList<Callable<FenceInvocationResult>>();
        Future<FenceInvocationResult> f1 = null;
        Future<FenceInvocationResult> f2 = null;
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(primaryExecutor, FenceAgentOrder.Primary);
            }
        });
        tasks.add(new Callable<FenceInvocationResult>() {

            @Override
            public FenceInvocationResult call() {
                return run(secondaryExecutor, FenceAgentOrder.Secondary);
            }
        });
        try {
            ExecutorCompletionService<FenceInvocationResult> ecs = ThreadPoolUtil.createCompletionService(tasks);
            switch(getParameters().getAction()) {
                case Start:
                    try {
                        f1 = ecs.take();
                        setResult(f1);
                        if (primaryResult.isSucceeded() || secondaryResult.isSucceeded()) {
                            handleSpecificCommandActions();
                            setFenceSucceeded(true);
                        } else {
                            tryOtherConcurrentAgent(lastStatus, ecs);
                        }
                    } catch (InterruptedException | ExecutionException e) {
                        tryOtherConcurrentAgent(lastStatus, ecs);
                    }
                    break;
                case Stop:
                    f1 = ecs.take();
                    f2 = ecs.take();
                    if (f1.get().getOrder() == FenceAgentOrder.Primary) {
                        primaryResult = f1.get();
                        secondaryResult = f2.get();
                    } else {
                        primaryResult = f2.get();
                        secondaryResult = f1.get();
                    }
                    if (primaryResult.isSucceeded() && secondaryResult.isSucceeded()) {
                        handleSpecificCommandActions();
                        setFenceSucceeded(true);
                    } else {
                        handleError(lastStatus, !primaryResult.isSucceeded() ? primaryResult.getValue() : secondaryResult.getValue(), !primaryResult.isSucceeded() ? FenceAgentOrder.Primary : FenceAgentOrder.Secondary);
                    }
                    break;
                default:
                    setFenceSucceeded(true);
                    break;
            }
        } catch (InterruptedException | ExecutionException e) {
            log.error(e);
        }
    } else {
        setFenceSucceeded(false);
        vdsReturnValue.setSucceeded(false);
    }
}
#end_block

#method_before
@Override
protected void executeVmCommand() {
    Set<Guid> mImagesToBeRemoved = new HashSet<Guid>();
    List<DiskImage> images = getParameters().Images;
    if (images == null) {
        images = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()), true, false);
    }
    for (DiskImage image : images) {
        if (Boolean.TRUE.equals(image.getActive())) {
            mImagesToBeRemoved.add(image.getImageId());
        }
    }
    Collection<DiskImage> failedRemoving = new LinkedList<>();
    for (final DiskImage image : images) {
        if (mImagesToBeRemoved.contains(image.getImageId())) {
            VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveImage, buildRemoveImageParameters(image), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (vdcReturnValue.getSucceeded()) {
                getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            } else {
                failedRemoving.add(image);
                log.errorFormat("Can't remove image id: {0} for VM id: {1} due to: {2}.", image.getImageId(), getParameters().getVmId(), vdcReturnValue.getFault().getMessage());
                if (getParameters().getParentCommand() != VdcActionType.RemoveVmFromImportExport && getParameters().getParentCommand() != VdcActionType.RemoveVmTemplateFromImportExport) {
                    log.error("Image will be set at illegal state with no snapshot id.");
                    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            // If VDSM task didn't succeed to initiate a task we change the disk to at illegal
                            // state.
                            updateDiskImagesToIllegal(image);
                            return true;
                        }
                    });
                } else {
                    log.error("Image is on an import domain and will not be marked as illegal.");
                }
            }
        }
    }
    setActionReturnValue(failedRemoving);
    setSucceeded(true);
}
#method_after
@Override
protected void executeVmCommand() {
    Set<Guid> mImagesToBeRemoved = new HashSet<Guid>();
    List<DiskImage> images = getParameters().Images;
    if (images == null) {
        images = ImagesHandler.filterImageDisks(DbFacade.getInstance().getDiskDao().getAllForVm(getVmId()), true, false);
    }
    for (DiskImage image : images) {
        if (Boolean.TRUE.equals(image.getActive())) {
            mImagesToBeRemoved.add(image.getImageId());
        }
    }
    Collection<DiskImage> failedRemoving = new LinkedList<>();
    for (final DiskImage image : images) {
        if (mImagesToBeRemoved.contains(image.getImageId())) {
            VdcReturnValueBase vdcReturnValue = Backend.getInstance().runInternalAction(VdcActionType.RemoveImage, buildRemoveImageParameters(image), ExecutionHandler.createDefaultContexForTasks(getExecutionContext()));
            if (vdcReturnValue.getSucceeded()) {
                getReturnValue().getInternalVdsmTaskIdList().addAll(vdcReturnValue.getInternalVdsmTaskIdList());
            } else {
                StorageDomain domain = getStorageDomainDao().get(image.getStorageIds().get(0));
                failedRemoving.add(image);
                log.errorFormat("Can't remove image id: {0} for VM id: {1} from domain id: {2} due to: {3}.", image.getImageId(), getParameters().getVmId(), image.getStorageIds().get(0), vdcReturnValue.getFault().getMessage());
                if (domain.getStorageDomainType() == StorageDomainType.Data) {
                    log.infoFormat("Image id: {0} will be set at illegal state with no snapshot id.", image.getImageId());
                    TransactionSupport.executeInScope(TransactionScopeOption.Required, new TransactionMethod<Object>() {

                        @Override
                        public Object runInTransaction() {
                            // If VDSM task didn't succeed to initiate a task we change the disk to at illegal
                            // state.
                            updateDiskImagesToIllegal(image);
                            return true;
                        }
                    });
                } else {
                    log.infoFormat("Image id: {0} is not on a data domain and will not be marked as illegal.", image.getImageId());
                }
            }
        }
    }
    setActionReturnValue(failedRemoving);
    setSucceeded(true);
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REBALANCE_STOP);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REBALANCE_STOP);
    super.setActionMessageParameters();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (!glusterVolume.isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
        return false;
    }
    if (glusterVolume.getAsyncTask() == null || glusterVolume.getAsyncTask().getStatus() != JobExecutionStatus.STARTED) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REBALANCE_NOT_STARTED);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (glusterVolume.getAsyncTask() == null || glusterVolume.getAsyncTask().getType() != GlusterTaskType.REBALANCE_VOLUME || glusterVolume.getAsyncTask().getStatus() != JobExecutionStatus.STARTED) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_REBALANCE_NOT_STARTED);
    }
    return true;
}
#end_block

#method_before
@Override
protected StepEnum getStepType() {
    return StepEnum.STOP_REBALANCING_GLUSTER_VOLUME;
}
#method_after
@Override
protected StepEnum getStepType() {
    return StepEnum.REBALANCING_VOLUME;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(vdsReturnaValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        return;
    }
    GlusterAsyncTask asyncTask = getGlusterVolume().getAsyncTask();
    List<Step> steps = DbFacade.getInstance().getStepDao().getStepsByExternalId(asyncTask.getTaskId());
    for (Step step : steps) {
        step.markStepEnded(JobExecutionStatus.ABORTED);
        endStepJob(step);
        clearVolumeTaskAndReleaseLock();
    }
    getReturnValue().setActionReturnValue(vdsReturnaValue);
}
#method_after
@Override
protected void executeCommand() {
    VDSReturnValue vdsReturnaValue = runVdsCommand(VDSCommandType.StopRebalanceGlusterVolume, new GlusterVolumeVDSParameters(upServer.getId(), getGlusterVolumeName()));
    setSucceeded(vdsReturnaValue.getSucceeded());
    if (!getSucceeded()) {
        handleVdsError(AuditLogType.GLUSTER_VOLUME_REBALANCE_STOP_FAILED, vdsReturnaValue.getVdsError().getMessage());
        return;
    }
    endStepJob();
    clearVolumeTaskAndReleaseLock();
    getReturnValue().setActionReturnValue(vdsReturnaValue);
}
#end_block

#method_before
protected void initNetworkInterfaces(final ProfileBehavior behavior, final List<VmNetworkInterface> argNics) {
    boolean hotUpdateSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.NetworkLinkingSupported, getModel().getSelectedCluster().getcompatibility_version().toString());
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VnicProfileView> profiles = (List<VnicProfileView>) returnValue;
            List<VnicInstanceType> vnicInstanceTypes = new ArrayList<VnicInstanceType>();
            List<VmNetworkInterface> nics = (argNics == null) ? new ArrayList<VmNetworkInterface>() : argNics;
            if (nics.isEmpty() && !(profiles.isEmpty() || (profiles.size() == 1 && profiles.get(0) == null))) {
                // create a default if none provided AND if there are profiles to choose from
                VmNetworkInterface networkInterface = new VmNetworkInterface();
                networkInterface.setName(AsyncDataProvider.getNewNicName(null));
                nics.add(networkInterface);
            }
            for (VmNetworkInterface nic : nics) {
                final VnicInstanceType vnicInstanceType = new VnicInstanceType(nic);
                vnicInstanceType.setItems(profiles);
                behavior.initSelectedProfile(vnicInstanceType, vnicInstanceType.getNetworkInterface());
                vnicInstanceTypes.add(vnicInstanceType);
            }
            getModel().getNicsWithLogicalNetworks().setItems(vnicInstanceTypes);
            getModel().getNicsWithLogicalNetworks().setSelectedItem(Linq.firstOrDefault(vnicInstanceTypes));
        }
    });
    behavior.initProfiles(hotUpdateSupported, getModel().getSelectedCluster().getId(), getModel().getSelectedDataCenter().getId(), query);
}
#method_after
protected void initNetworkInterfaces(final ProfileBehavior behavior, final List<VmNetworkInterface> argNics) {
    boolean hotUpdateSupported = (Boolean) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.NetworkLinkingSupported, getModel().getSelectedCluster().getcompatibility_version().toString());
    AsyncQuery query = new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            List<VnicProfileView> profiles = (List<VnicProfileView>) returnValue;
            List<VnicInstanceType> vnicInstanceTypes = new ArrayList<VnicInstanceType>();
            List<VmNetworkInterface> nics = (argNics == null) ? new ArrayList<VmNetworkInterface>() : argNics;
            if (nics.isEmpty() && profilesExist(profiles)) {
                // create a default if none provided AND if there are profiles to choose from
                VmNetworkInterface networkInterface = new VmNetworkInterface();
                networkInterface.setName(AsyncDataProvider.getNewNicName(null));
                nics.add(networkInterface);
            }
            for (VmNetworkInterface nic : nics) {
                final VnicInstanceType vnicInstanceType = new VnicInstanceType(nic);
                vnicInstanceType.setItems(profiles);
                behavior.initSelectedProfile(vnicInstanceType, vnicInstanceType.getNetworkInterface());
                vnicInstanceTypes.add(vnicInstanceType);
            }
            getModel().getNicsWithLogicalNetworks().setItems(vnicInstanceTypes);
            getModel().getNicsWithLogicalNetworks().setSelectedItem(Linq.firstOrDefault(vnicInstanceTypes));
        }
    });
    behavior.initProfiles(hotUpdateSupported, getModel().getSelectedCluster().getId(), getModel().getSelectedDataCenter().getId(), query);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getDiskImage() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    try {
        if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
            return false;
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDAO().getVmsListForDisk(getDiskImage().getId())) {
        if (vm.getStatus() != VMStatus.Down) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getDiskImage() == null) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_NOT_EXIST);
    }
    if (!validate(new StorageDomainValidator(getStorageDomain()).isDomainExistAndActive())) {
        return false;
    }
    // or that are based on a a template.
    if (!getDiskImage().getParentId().equals(Guid.Empty)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_DISK_CONFIGURATION_NOT_SUPPORTED);
    }
    for (VM vm : getVmDAO().getVmsListForDisk(getDiskImage().getId())) {
        if (vm.getStatus() != VMStatus.Down) {
            return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_VM_IS_RUNNING);
        }
    }
    return true;
}
#end_block

#method_before
Map<String, String> getMessageMap(final String prefix, final Locale locale) {
    List<BrandingTheme> messageThemes = getBrandingThemes();
    // We need this map to remove potential duplicate strings from the resource bundles.
    Map<String, String> keyValues = new HashMap<String, String>();
    if (messageThemes != null) {
        for (BrandingTheme theme : messageThemes) {
            ResourceBundle messagesBundle = theme.getMessagesBundle(locale);
            for (String key : messagesBundle.keySet()) {
                if (key.startsWith(BRAND_PREFIX + "." + prefix) || key.startsWith(COMMON_PREFIX)) {
                    // $NON-NLS-1$
                    // We can potentially override existing values here
                    // but this is fine as the themes are sorted in order
                    // And later messages should override earlier ones.
                    keyValues.put(key.replaceFirst(// $NON-NLS-1$
                    BRAND_PREFIX + "\\." + prefix + "\\.", // $NON-NLS-1$
                    "").replaceFirst(COMMON_PREFIX + "\\.", // $NON-NLS-1$
                    ""), messagesBundle.getString(key));
                }
            }
        }
    }
    return keyValues;
}
#method_after
Map<String, String> getMessageMap(final String prefix, final Locale locale) {
    List<BrandingTheme> messageThemes = getBrandingThemes();
    // We need this map to remove potential duplicate strings from the resource bundles.
    Map<String, String> keyValues = new HashMap<String, String>();
    if (messageThemes != null) {
        for (BrandingTheme theme : messageThemes) {
            List<ResourceBundle> bundles = theme.getMessagesBundle(locale);
            for (ResourceBundle bundle : bundles) {
                getKeyValuesFromResourceBundle(prefix, keyValues, bundle);
            }
        }
    }
    return keyValues;
}
#end_block

#method_before
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    FileInputStream propertiesFile;
    try {
        propertiesFile = new FileInputStream(propertiesFileName);
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#method_after
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    try (FileInputStream propertiesFile = new FileInputStream(propertiesFileName)) {
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#end_block

#method_before
public ResourceBundle getMessagesBundle() {
    // Default to US Locale.
    return getMessagesBundle(LocaleFilter.DEFAULT_LOCALE);
}
#method_after
public List<ResourceBundle> getMessagesBundle() {
    // Default to US Locale.
    return getMessagesBundle(LocaleFilter.DEFAULT_LOCALE);
}
#end_block

#method_before
public ResourceBundle getMessagesBundle(final Locale locale) {
    ResourceBundle result = null;
    try {
        File themeDirectory = new File(filePath);
        URLClassLoader urlLoader = new URLClassLoader(new URL[] { themeDirectory.toURI().toURL() });
        final String messageFileName = brandingProperties.getProperty(MESSAGES_KEY);
        String bundleName = messageFileName.lastIndexOf(PROPERTIES_FILE_SUFFIX) != -1 ? messageFileName.substring(0, messageFileName.lastIndexOf(PROPERTIES_FILE_SUFFIX)) : messageFileName;
        result = ResourceBundle.getBundle(bundleName, locale, urlLoader);
    } catch (IOException e) {
        // Unable to load messages resource bundle.
        log.warn(// $NON-NLS-1$
        "Unable to read message resource " + "bundle, returning null", // $NON-NLS-1$
        e);
    }
    return result;
}
#method_after
public List<ResourceBundle> getMessagesBundle(final Locale locale) {
    return getBundle(MESSAGES_KEY, locale);
}
#end_block

#method_before
@Test
public void testGetBrandingThemes() {
    List<BrandingTheme> result = testManager.getBrandingThemes();
    // $NON-NLS-1$
    assertNotNull("There should be a result", result);
    // $NON-NLS-1$
    assertEquals("There should be three active themes", 3, result.size());
    List<BrandingTheme> result2 = testManager.getBrandingThemes();
    // $NON-NLS-1$
    assertNotNull("There should be a result", result2);
    // $NON-NLS-1$
    assertEquals("There should be three active themes", 3, result2.size());
    // The second result should be the exact same object as the first one.
    // $NON-NLS-1$
    assertTrue("The result are not the same object", result == result2);
}
#method_after
@Test
public void testGetBrandingThemes() {
    List<BrandingTheme> result = testManager.getBrandingThemes();
    // $NON-NLS-1$
    assertNotNull("There should be a result", result);
    // $NON-NLS-1$
    assertEquals("There should be five active themes", 5, result.size());
    List<BrandingTheme> result2 = testManager.getBrandingThemes();
    // $NON-NLS-1$
    assertNotNull("There should be a result", result2);
    // $NON-NLS-1$
    assertEquals("There should be five active themes", 5, result2.size());
    // The second result should be the exact same object as the first one.
    // $NON-NLS-1$
    assertTrue("The result are not the same object", result == result2);
}
#end_block

#method_before
@Override
protected boolean acquireLockInternal() {
    final boolean acquireLock = super.acquireLockInternal();
    if (!acquireLock && getVm().isAutoStartup()) {
        AutoStartVmsRunner.getInstance().addVmToRun(getParameters().getVmId());
    }
    return acquireLock;
}
#method_after
@Override
protected boolean acquireLockInternal() {
    final boolean acquireLock = super.acquireLockInternal();
    if (!acquireLock && getVm() != null && getVm().isAutoStartup()) {
        AutoStartVmsRunner.getInstance().addVmToRun(getParameters().getVmId());
    }
    return acquireLock;
}
#end_block

#method_before
@Override
protected MapSqlParameterSource createFullParametersMapper(Step entity) {
    return createIdParameterMapper(entity.getId()).addValue("parent_step_id", entity.getParentStepId()).addValue("job_id", entity.getJobId()).addValue("step_type", EnumUtils.nameOrNull(entity.getStepType())).addValue("description", entity.getDescription()).addValue("step_number", entity.getStepNumber()).addValue("status", EnumUtils.nameOrNull(entity.getStatus())).addValue("start_time", entity.getStartTime()).addValue("end_time", entity.getEndTime()).addValue("correlation_id", entity.getCorrelationId()).addValue("external_id", entity.getExternalSystem().getId()).addValue("external_system_type", EnumUtils.nameOrNull(entity.getExternalSystem().getType()));
}
#method_after
@Override
protected MapSqlParameterSource createFullParametersMapper(Step entity) {
    return createIdParameterMapper(entity.getId()).addValue("parent_step_id", entity.getParentStepId()).addValue("job_id", entity.getJobId()).addValue("step_type", EnumUtils.nameOrNull(entity.getStepType())).addValue("description", entity.getDescription()).addValue("step_number", entity.getStepNumber()).addValue("status", EnumUtils.nameOrNull(entity.getStatus())).addValue("start_time", entity.getStartTime()).addValue("end_time", entity.getEndTime()).addValue("correlation_id", entity.getCorrelationId()).addValue("external_id", entity.getExternalSystem().getId()).addValue("external_system_type", EnumUtils.nameOrNull(entity.getExternalSystem().getType())).addValue("is_external", entity.isExternal());
}
#end_block

#method_before
@Override
protected ParameterizedRowMapper<Step> createEntityRowMapper() {
    return stepRowMapper;
}
#method_after
@Override
protected RowMapper<Step> createEntityRowMapper() {
    return stepRowMapper;
}
#end_block

#method_before
@Override
public Step mapRow(ResultSet rs, int rowNum) throws SQLException {
    Step step = new Step();
    step.setId(Guid.createGuidFromString(rs.getString("step_id")));
    step.setParentStepId(NGuid.createGuidFromString(rs.getString("parent_step_id")));
    step.setJobId(Guid.createGuidFromString(rs.getString("job_id")));
    step.setStepType(StepEnum.valueOf(rs.getString("step_type")));
    step.setDescription(rs.getString("description"));
    step.setStepNumber(rs.getInt("step_number"));
    step.setStatus(JobExecutionStatus.valueOf(rs.getString("status")));
    step.setStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("start_time")));
    step.setEndTime(DbFacadeUtils.fromDate(rs.getTimestamp("end_time")));
    step.setCorrelationId(rs.getString("correlation_id"));
    step.getExternalSystem().setId(NGuid.createGuidFromString(rs.getString("external_id")));
    step.getExternalSystem().setType(ExternalSystemType.safeValueOf(rs.getString("external_system_type")));
    return step;
}
#method_after
@Override
public Step mapRow(ResultSet rs, int rowNum) throws SQLException {
    Step step = new Step();
    step.setId(getGuidDefaultEmpty(rs, "step_id"));
    step.setParentStepId(getGuid(rs, "parent_step_id"));
    step.setJobId(getGuidDefaultEmpty(rs, "job_id"));
    step.setStepType(StepEnum.valueOf(rs.getString("step_type")));
    step.setDescription(rs.getString("description"));
    step.setStepNumber(rs.getInt("step_number"));
    step.setStatus(JobExecutionStatus.valueOf(rs.getString("status")));
    step.setStartTime(DbFacadeUtils.fromDate(rs.getTimestamp("start_time")));
    step.setEndTime(DbFacadeUtils.fromDate(rs.getTimestamp("end_time")));
    step.setCorrelationId(rs.getString("correlation_id"));
    step.getExternalSystem().setId(getGuid(rs, "external_id"));
    step.getExternalSystem().setType(ExternalSystemType.safeValueOf(rs.getString("external_system_type")));
    step.setExternal(rs.getBoolean("is_external"));
    return step;
}
#end_block

#method_before
@Override
public List<Step> getStepsByExternalId(Guid externalId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("external_id", externalId);
    return getCallsHandler().executeReadList("GetStepsByExternalId", createEntityRowMapper(), parameterSource);
}
#method_after
@Override
public List<Step> getStepsByExternalId(Guid externalId) {
    MapSqlParameterSource parameterSource = getCustomMapSqlParameterSource().addValue("external_id", externalId);
    return getCallsHandler().executeReadList("GetStepsByExternalTaskId", createEntityRowMapper(), parameterSource);
}
#end_block

#method_before
protected Map<String, String> getStepMessageMap() {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, getVdsGroupName());
    values.put(GlusterConstants.VOLUME, getGlusterVolumeName());
    // TODO: Define constants
    values.put("status", "STARTED");
    values.put("info", " ");
    return values;
}
#method_after
protected Map<String, String> getStepMessageMap() {
    Map<String, String> values = new HashMap<String, String>();
    values.put(GlusterConstants.CLUSTER, getVdsGroupName());
    values.put(GlusterConstants.VOLUME, getGlusterVolumeName());
    // TODO: Define constants
    values.put("status", JobExecutionStatus.STARTED.toString());
    values.put("info", " ");
    return values;
}
#end_block

#method_before
@Override
protected void executeCommand() {
    _asyncTaskStep = ExecutionHandler.addSubStep(this.getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), getStepType(), ExecutionMessageDirector.resolveStepMessage(getStepType(), getStepMessageMap()));
    handleTaskReturn(executeAndReturnTask());
}
#method_after
@Override
protected void executeCommand() {
    asyncTaskStep = ExecutionHandler.addSubStep(this.getExecutionContext(), getExecutionContext().getJob().getStep(StepEnum.EXECUTING), getStepType(), ExecutionMessageDirector.resolveStepMessage(getStepType(), getStepMessageMap()));
    handleTaskReturn(executeAndReturnTask());
}
#end_block

#method_before
protected void handleTaskReturn(GlusterAsyncTask asyncTask) {
    Guid externalTaskId = asyncTask.getTaskId();
    // getExecutionContext().getStep().setCorrelationId(externalTaskId.toString());
    _asyncTaskStep.setStatus(JobExecutionStatus.STARTED);
    ExecutionHandler.updateStepExternalId(_asyncTaskStep, externalTaskId, ExternalSystemType.GLUSTER);
    getExecutionContext().getJob().setStatus(JobExecutionStatus.STARTED);
    GlusterTaskManager.getInstance().addTask(externalTaskId);
}
#method_after
protected void handleTaskReturn(GlusterAsyncTask asyncTask) {
    Guid externalTaskId = asyncTask.getTaskId();
    asyncTaskStep.setStatus(JobExecutionStatus.STARTED);
    ExecutionHandler.updateStepExternalId(asyncTaskStep, externalTaskId, ExternalSystemType.GLUSTER);
    getExecutionContext().getJob().setStatus(JobExecutionStatus.STARTED);
}
#end_block

#method_before
private void updateActionAvailability() {
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        getRemoveVolumeCommand().setIsExecutionAllowed(false);
        getStopCommand().setIsExecutionAllowed(false);
        getStartCommand().setIsExecutionAllowed(false);
        getRebalanceCommand().setIsExecutionAllowed(false);
        getOptimizeForVirtStoreCommand().setIsExecutionAllowed(false);
    } else {
        getRemoveVolumeCommand().setIsExecutionAllowed(true);
        getStopCommand().setIsExecutionAllowed(true);
        getStartCommand().setIsExecutionAllowed(true);
        getRebalanceCommand().setIsExecutionAllowed(true);
        getOptimizeForVirtStoreCommand().setIsExecutionAllowed(true);
        for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
            if (volume.getStatus() == GlusterStatus.UP) {
                getRemoveVolumeCommand().setIsExecutionAllowed(false);
                getStartCommand().setIsExecutionAllowed(false);
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                getStopCommand().setIsExecutionAllowed(false);
                getRebalanceCommand().setIsExecutionAllowed(false);
            }
        }
    }
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getCreateVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#method_after
private void updateActionAvailability() {
    boolean allowStart = true;
    boolean allowStop = true;
    boolean allowRemove = true;
    boolean allowStartRebalance = true;
    boolean allowOptimize = true;
    if (getSelectedItems() == null || getSelectedItems().size() == 0) {
        allowStart = false;
        allowStop = false;
        allowRemove = false;
        allowStartRebalance = false;
        allowOptimize = false;
    } else {
        for (GlusterVolumeEntity volume : Linq.<GlusterVolumeEntity>cast(getSelectedItems())) {
            if (volume.getStatus() == GlusterStatus.UP) {
                allowStart = false;
                allowRemove = false;
            } else if (volume.getStatus() == GlusterStatus.DOWN) {
                allowStop = false;
                allowStartRebalance = false;
            }
            allowStartRebalance = allowStartRebalance && (volume.getAsyncTask() == null || Guid.isNullOrEmpty(volume.getAsyncTask().getTaskId()));
        }
    }
    getStartCommand().setIsExecutionAllowed(allowStart);
    getStopCommand().setIsExecutionAllowed(allowStop);
    getRemoveVolumeCommand().setIsExecutionAllowed(allowRemove);
    getStartRebalanceCommand().setIsExecutionAllowed(allowStartRebalance);
    getOptimizeForVirtStoreCommand().setIsExecutionAllowed(allowOptimize);
    // System tree dependent actions.
    boolean isAvailable = !(getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Volume);
    getNewVolumeCommand().setIsAvailable(isAvailable);
    getRemoveVolumeCommand().setIsAvailable(isAvailable);
}
#end_block

#method_before
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getCreateVolumeCommand())) {
        createVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getRebalanceCommand())) {
        rebalance();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    }
}
#method_after
@Override
public void executeCommand(UICommand command) {
    super.executeCommand(command);
    if (command.equals(getNewVolumeCommand())) {
        newVolume();
    } else if (command.equals(getRemoveVolumeCommand())) {
        removeVolume();
    } else if (command.getName().equals("Cancel")) {
        // $NON-NLS-1$
        cancel();
    } else if (command.getName().equals("onCreateVolume")) {
        // $NON-NLS-1$
        onCreateVolume();
    } else if (command.equals(getStartCommand())) {
        start();
    } else if (command.equals(getStopCommand())) {
        stop();
    } else if (command.equals(getStartRebalanceCommand())) {
        startRebalance();
    } else if (command.equals(getOptimizeForVirtStoreCommand())) {
        optimizeForVirtStore();
    } else if (command.getName().equals("onStop")) {
        // $NON-NLS-1$
        onStop();
    } else if (command.getName().equals("OnRemove")) {
        // $NON-NLS-1$
        onRemoveVolume();
    }
}
#end_block

#method_before
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> transportColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            StringBuilder transportTypes = new StringBuilder();
            Iterator<TransportType> iterator = object.getTransportTypes().iterator();
            while (iterator.hasNext()) {
                TransportType transportType = iterator.next();
                if (transportTypeTranslator.containsKey(transportType)) {
                    transportTypes.append(transportTypeTranslator.get(transportType));
                } else {
                    transportTypes.append(transportType.toString());
                }
                if (iterator.hasNext()) {
                    // $NON-NLS-1$
                    transportTypes.append(", ");
                }
            }
            return transportTypes.toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(transportColumn, constants.transportTypesVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> statusColumn = new EnumColumn<GlusterVolumeEntity, GlusterStatus>() {

        @Override
        protected GlusterStatus getRawValue(GlusterVolumeEntity object) {
            return object.getStatus();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(statusColumn, constants.statusVolume(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.createVolumeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getCreateVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> rebalanceSubctions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    rebalanceSubctions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRebalanceCommand();
        }
    });
    /*
        rebalanceSubctions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopRebalance()) {
            @Override
            protected UICommand resolveCommand() {
                //return getMainModel().getRebalanceStopCommand();
                return null;
            }
        });
        rebalanceSubctions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.statusRebalance()) {
            @Override
            protected UICommand resolveCommand() {
                return null;
            }
        });
        */
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume(), rebalanceSubctions, CommandLocation.OnlyFromToolBar));
}
#method_after
void initTable(ApplicationConstants constants) {
    getTable().enableColumnResizing();
    // $NON-NLS-1$
    getTable().addColumn(new VolumeStatusColumn(), constants.empty(), "30px");
    TextColumnWithTooltip<GlusterVolumeEntity> nameColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(nameColumn, constants.NameVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> clusterColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return object.getVdsGroupName();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(clusterColumn, constants.clusterVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> volumeTypeColumn = new EnumColumn<GlusterVolumeEntity, GlusterVolumeType>() {

        @Override
        protected GlusterVolumeType getRawValue(GlusterVolumeEntity object) {
            return object.getVolumeType();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(volumeTypeColumn, constants.volumeTypeVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> numOfBricksColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            return Integer.toString(object.getBricks().size());
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(numOfBricksColumn, constants.numberOfBricksVolume(), "150px");
    TextColumnWithTooltip<GlusterVolumeEntity> transportColumn = new TextColumnWithTooltip<GlusterVolumeEntity>() {

        @Override
        public String getValue(GlusterVolumeEntity object) {
            StringBuilder transportTypes = new StringBuilder();
            Iterator<TransportType> iterator = object.getTransportTypes().iterator();
            while (iterator.hasNext()) {
                TransportType transportType = iterator.next();
                if (transportTypeTranslator.containsKey(transportType)) {
                    transportTypes.append(transportTypeTranslator.get(transportType));
                } else {
                    transportTypes.append(transportType.toString());
                }
                if (iterator.hasNext()) {
                    // $NON-NLS-1$
                    transportTypes.append(", ");
                }
            }
            return transportTypes.toString();
        }
    };
    // $NON-NLS-1$
    getTable().addColumn(transportColumn, constants.transportTypesVolume(), "150px");
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.newVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getNewVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.removeVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getRemoveVolumeCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.stopVolume()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStopCommand();
        }
    });
    getTable().addActionButton(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.optimizeForVirtStore()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getOptimizeForVirtStoreCommand();
        }
    });
    List<ActionButtonDefinition<GlusterVolumeEntity>> rebalanceSubActions = new LinkedList<ActionButtonDefinition<GlusterVolumeEntity>>();
    rebalanceSubActions.add(new WebAdminButtonDefinition<GlusterVolumeEntity>(constants.startRebalance()) {

        @Override
        protected UICommand resolveCommand() {
            return getMainModel().getStartRebalanceCommand();
        }
    });
    getTable().addActionButton(new WebAdminMenuBarButtonDefinition<GlusterVolumeEntity>(constants.rebalanceVolume(), rebalanceSubActions, CommandLocation.ContextAndToolBar));
}
#end_block

#method_before
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setBricks(dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId()));
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
    }
}
#method_after
private void fetchRelatedEntities(GlusterVolumeEntity volume) {
    if (volume != null) {
        volume.setBricks(dbFacade.getGlusterBrickDao().getBricksOfVolume(volume.getId()));
        volume.setOptions(dbFacade.getGlusterOptionDao().getOptionsOfVolume(volume.getId()));
        volume.setAccessProtocols(new HashSet<AccessProtocol>(getAccessProtocolsOfVolume(volume.getId())));
        volume.setTransportTypes(new HashSet<TransportType>(getTransportTypesOfVolume(volume.getId())));
        volume.setAsyncTask(getAsyncTaskOfVolume(volume.getId()));
    }
}
#end_block

#method_before
@Override
public GlusterVolumeEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterVolumeEntity entity = new GlusterVolumeEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setName(rs.getString("vol_name"));
    entity.setVolumeType(GlusterVolumeType.valueOf(rs.getString("vol_type")));
    entity.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    entity.setReplicaCount(rs.getInt("replica_count"));
    entity.setStripeCount(rs.getInt("stripe_count"));
    entity.setTaskId(getGuidDefaultEmpty(rs, "task_id"));
    return entity;
}
#method_after
@Override
public GlusterVolumeEntity mapRow(ResultSet rs, int rowNum) throws SQLException {
    GlusterVolumeEntity entity = new GlusterVolumeEntity();
    entity.setId(getGuidDefaultEmpty(rs, "id"));
    entity.setClusterId(getGuidDefaultEmpty(rs, "cluster_id"));
    entity.setVdsGroupName(rs.getString("vds_group_name"));
    entity.setName(rs.getString("vol_name"));
    entity.setVolumeType(GlusterVolumeType.valueOf(rs.getString("vol_type")));
    entity.setStatus(GlusterStatus.valueOf(rs.getString("status")));
    entity.setReplicaCount(rs.getInt("replica_count"));
    entity.setStripeCount(rs.getInt("stripe_count"));
    return entity;
}
#end_block

#method_before
@Override
public void updateGlusterVolume(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("UpdateGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()).addValue("task_id", volume.getTaskId()));
}
#method_after
@Override
public void updateGlusterVolume(GlusterVolumeEntity volume) {
    getCallsHandler().executeModification("UpdateGlusterVolume", getCustomMapSqlParameterSource().addValue("id", volume.getId()).addValue("cluster_id", volume.getClusterId()).addValue("vol_name", volume.getName()).addValue("vol_type", EnumUtils.nameOrNull(volume.getVolumeType())).addValue("status", EnumUtils.nameOrNull(volume.getStatus())).addValue("replica_count", volume.getReplicaCount()).addValue("stripe_count", volume.getStripeCount()));
}
#end_block

#method_before
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REBALANCE_START);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__GLUSTER_VOLUME);
}
#method_after
@Override
protected void setActionMessageParameters() {
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__REBALANCE_START);
    super.setActionMessageParameters();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (!glusterVolume.isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
        return false;
    }
    if ((glusterVolume.getVolumeType() == GlusterVolumeType.REPLICATE && glusterVolume.getBricks().size() <= glusterVolume.getReplicaCount()) || (glusterVolume.getVolumeType() == GlusterVolumeType.STRIPE && glusterVolume.getBricks().size() <= glusterVolume.getStripeCount()) || (glusterVolume.getBricks().size() == 1)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_BRICKS_ARE_NOT_DISTRIBUTED);
        return false;
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    GlusterVolumeEntity glusterVolume = getGlusterVolume();
    if (!super.canDoAction()) {
        return false;
    }
    if (!glusterVolume.isOnline()) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_SHOULD_BE_STARTED);
        return false;
    }
    if (!glusterVolume.getVolumeType().isDistributedType() || (glusterVolume.getBricks().size() == 1)) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_GLUSTER_VOLUME_BRICKS_ARE_NOT_DISTRIBUTED);
        return false;
    }
    return true;
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    // VDSM does not support task return yet
    glusterTaskReturn = getBroker().glusterVolumeRebalanceStart(getParameters().getVolumeName(), getParameters().isFixLayoutOnly(), getParameters().isForceAction());
    task = glusterTaskReturn.getGlusterTask();
    // TODO : REMOVE TEMPORARY HACK
    // task = new GlusterAsyncTask();
    // task.setTaskId(Guid.NewGuid());
    setReturnValue(task);
    ProceedProxyReturnValue();
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    glusterTaskReturn = getBroker().glusterVolumeRebalanceStart(getParameters().getVolumeName(), getParameters().isFixLayoutOnly(), getParameters().isForceAction());
    task = glusterTaskReturn.getGlusterTask();
    proceedProxyReturnValue();
    setReturnValue(task);
}
#end_block

#method_before
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, getParameters(), new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDAO().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    setSucceeded(true);
}
#method_after
@Override
protected void executeCommand() {
    final Guid targetClusterId = getParameters().getClusterId();
    if (getSourceCluster().getId().equals(targetClusterId)) {
        setSucceeded(true);
        return;
    }
    // save the new cluster id
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            VdsStatic staticData = getVds().getStaticData();
            getCompensationContext().snapshotEntity(staticData);
            staticData.setVdsGroupId(targetClusterId);
            DbFacade.getInstance().getVdsStaticDao().update(staticData);
            getCompensationContext().stateChanged();
            return null;
        }
    });
    if (targetStoragePool != null && (getSourceCluster().getStoragePoolId() == null || !targetStoragePool.getId().equals(getSourceCluster().getStoragePoolId()))) {
        VdsActionParameters addVdsSpmIdParams = new VdsActionParameters(getVdsIdRef());
        addVdsSpmIdParams.setSessionId(getParameters().getSessionId());
        addVdsSpmIdParams.setCompensationEnabled(true);
        VdcReturnValueBase addVdsSpmIdReturn = Backend.getInstance().runInternalAction(VdcActionType.AddVdsSpmId, addVdsSpmIdParams, new CommandContext(getCompensationContext()));
        if (!addVdsSpmIdReturn.getSucceeded()) {
            setSucceeded(false);
            getReturnValue().setFault(addVdsSpmIdReturn.getFault());
            return;
        }
    }
    if (getSourceCluster().supportsGlusterService() && getClusterUtils().hasServers(getSourceCluster().getId())) {
        if (!glusterHostRemove(getSourceCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getTargetCluster().supportsGlusterService() && getClusterUtils().hasMultipleServers(getTargetCluster().getId())) {
        if (!glusterHostAdd(getTargetCluster().getId())) {
            setSucceeded(false);
            return;
        }
    }
    if (getSourceCluster().getStoragePoolId() != null && (targetStoragePool == null || !getSourceCluster().getStoragePoolId().equals(targetStoragePool.getId()))) {
        getVdsSpmIdMapDAO().removeByVdsAndStoragePool(getVds().getId(), getSourceCluster().getStoragePoolId());
    }
    setSucceeded(true);
}
#end_block

#method_before
@Override
public EventResult submitEventSync(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = submitTaskInternal(event, callable);
    if (task != null) {
        try {
            return task.get();
        } catch (CancellationException e) {
            log.infoFormat("Failed to submit event using submitEventSync (the event was cancelled)- pool {0} , exception {1}", event.getStoragePoolId(), e);
        } catch (Exception e) {
            log.errorFormat("Failed at submitEventSync, for pool {0} with exception {1}", event.getStoragePoolId(), e);
        }
    }
    return null;
}
#method_after
@Override
public EventResult submitEventSync(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = submitTaskInternal(event, callable);
    if (task != null) {
        try {
            return task.get();
        } catch (CancellationException e) {
            // CancellationException is normal here, as we cancel future tasks when reconstruct is running
            // This cancellation is also being reported to the log
            // Currently ignoring that exception, writing a debug message, in case other scenario of canceling an exception will be introduced
            log.debugFormat("Failed to submit event using submitEventSync (the event was cancelled)- pool {0} , exception {1}", event.getStoragePoolId(), e);
        } catch (Exception e) {
            log.errorFormat("Failed at submitEventSync, for pool {0} with exception {1}", event.getStoragePoolId(), e);
        }
    }
    return null;
}
#end_block

#method_before
private FutureTask<EventResult> submitTaskInternal(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = null;
    Guid storagePoolId = event.getStoragePoolId();
    ReentrantLock lock = getPoolLock(storagePoolId);
    lock.lock();
    try {
        Event currentEvent = poolCurrentEventMap.get(storagePoolId);
        if (currentEvent != null) {
            switch(currentEvent.getEventType()) {
                case RECOVERY:
                    if (event.getEventType() == EventType.VDSCONNECTTOPOOL || event.getEventType() == EventType.VDSCLEARCACHE || event.getEventType() == EventType.DOMAINFAILOVER) {
                        task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    } else {
                        log.debugFormat("Current event was skiped because of recovery is running now for pool {0}, event {1}", storagePoolId, event);
                    }
                    break;
                case RECONSTRUCT:
                    if (event.getEventType() == EventType.VDSCONNECTTOPOOL || event.getEventType() == EventType.RECOVERY || event.getEventType() == EventType.DOMAINFAILOVER || event.getEventType() == EventType.VDSCLEARCACHE) {
                        task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    } else {
                        log.debugFormat("Current event was skiped because of reconstruct is running now for pool {0}, event {1}", storagePoolId, event);
                    }
                    break;
                default:
                    task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    break;
            }
        } else {
            task = addTaskToQueue(event, callable, storagePoolId, false);
            poolCurrentEventMap.put(storagePoolId, event);
            ThreadPoolUtil.execute(new InternalEventQueueThread(storagePoolId, lock, poolsEventsMap, poolCurrentEventMap));
        }
    } finally {
        lock.unlock();
    }
    return task;
}
#method_after
private FutureTask<EventResult> submitTaskInternal(Event event, Callable<EventResult> callable) {
    FutureTask<EventResult> task = null;
    Guid storagePoolId = event.getStoragePoolId();
    ReentrantLock lock = getPoolLock(storagePoolId);
    lock.lock();
    try {
        Event currentEvent = poolCurrentEventMap.get(storagePoolId);
        if (currentEvent != null) {
            switch(currentEvent.getEventType()) {
                case RECOVERY:
                    if (event.getEventType() == EventType.VDSCONNECTTOPOOL || event.getEventType() == EventType.VDSCLEARCACHE || event.getEventType() == EventType.DOMAINFAILOVER) {
                        task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    } else {
                        log.debugFormat("Current event was skipped because of recovery is running now for pool {0}, event {1}", storagePoolId, event);
                    }
                    break;
                case RECONSTRUCT:
                    if (event.getEventType() == EventType.VDSCONNECTTOPOOL || event.getEventType() == EventType.RECOVERY || event.getEventType() == EventType.DOMAINFAILOVER || event.getEventType() == EventType.VDSCLEARCACHE) {
                        task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    } else {
                        log.debugFormat("Current event was skipped because of reconstruct is running now for pool {0}, event {1}", storagePoolId, event);
                    }
                    break;
                default:
                    task = addTaskToQueue(event, callable, storagePoolId, isEventShouldBeFirst(event));
                    break;
            }
        } else {
            task = addTaskToQueue(event, callable, storagePoolId, false);
            poolCurrentEventMap.put(storagePoolId, event);
            ThreadPoolUtil.execute(new InternalEventQueueThread(storagePoolId, lock, poolsEventsMap, poolCurrentEventMap));
        }
    } finally {
        lock.unlock();
    }
    return task;
}
#end_block

#method_before
@Override
public void run() {
    while (true) {
        Pair<Event, FutureTask<EventResult>> pair;
        lock.lock();
        try {
            pair = poolsEventsMap.get(storagePoolId).poll();
            if (pair != null) {
                poolCurrentEventMap.put(storagePoolId, pair.getFirst());
            } else {
                poolCurrentEventMap.remove(storagePoolId);
                poolsEventsMap.remove(storagePoolId);
                log.debugFormat("All task for event query were executed pool {0}", storagePoolId);
                break;
            }
        } finally {
            lock.unlock();
        }
        Future<EventResult> futureResult = ThreadPoolUtil.execute(pair.getSecond());
        try {
            if (futureResult.get() == null) {
                EventResult result = pair.getSecond().get();
                if (result != null && result.getEventType() == EventType.RECONSTRUCT) {
                    log.infoFormat("Finished reconstruct for pool {0}. Clearing event queue", storagePoolId);
                    lock.lock();
                    try {
                        LinkedList<Pair<Event, FutureTask<EventResult>>> queue = new LinkedList<Pair<Event, FutureTask<EventResult>>>();
                        for (Pair<Event, FutureTask<EventResult>> task : poolsEventsMap.get(storagePoolId)) {
                            EventType eventType = task.getFirst().getEventType();
                            if (eventType == EventType.VDSCONNECTTOPOOL || ((eventType == EventType.RECOVERY || eventType == EventType.DOMAINFAILOVER || eventType == EventType.VDSCLEARCACHE) && !result.isSuccess())) {
                                queue.add(task);
                            } else {
                                log.infoFormat("The following operation {0} was cancelled, because of recosntruct was run before", task.getFirst());
                                task.getSecond().cancel(true);
                            }
                        }
                        if (queue.isEmpty()) {
                            poolCurrentEventMap.remove(storagePoolId);
                            poolsEventsMap.remove(storagePoolId);
                            break;
                        } else {
                            poolsEventsMap.put(storagePoolId, queue);
                        }
                    } finally {
                        lock.unlock();
                    }
                }
            }
        } catch (Exception e) {
            log.errorFormat("Exception during process of events for pool {0}, error is {1}", storagePoolId, e.getMessage());
        }
    }
}
#method_after
@Override
public void run() {
    while (true) {
        Pair<Event, FutureTask<EventResult>> pair;
        lock.lock();
        try {
            pair = poolsEventsMap.get(storagePoolId).poll();
            if (pair != null) {
                poolCurrentEventMap.put(storagePoolId, pair.getFirst());
            } else {
                poolCurrentEventMap.remove(storagePoolId);
                poolsEventsMap.remove(storagePoolId);
                log.debugFormat("All task for event query were executed pool {0}", storagePoolId);
                break;
            }
        } finally {
            lock.unlock();
        }
        Future<EventResult> futureResult = ThreadPoolUtil.execute(pair.getSecond());
        try {
            if (futureResult.get() == null) {
                EventResult result = pair.getSecond().get();
                if (result != null && result.getEventType() == EventType.RECONSTRUCT) {
                    log.infoFormat("Finished reconstruct for pool {0}. Clearing event queue", storagePoolId);
                    lock.lock();
                    try {
                        LinkedList<Pair<Event, FutureTask<EventResult>>> queue = new LinkedList<Pair<Event, FutureTask<EventResult>>>();
                        for (Pair<Event, FutureTask<EventResult>> task : poolsEventsMap.get(storagePoolId)) {
                            EventType eventType = task.getFirst().getEventType();
                            if (eventType == EventType.VDSCONNECTTOPOOL || ((eventType == EventType.RECOVERY || eventType == EventType.DOMAINFAILOVER || eventType == EventType.VDSCLEARCACHE) && !result.isSuccess())) {
                                queue.add(task);
                            } else {
                                log.infoFormat("The following operation {0} was cancelled, because of reconstruct was run before", task.getFirst());
                                task.getSecond().cancel(true);
                            }
                        }
                        if (queue.isEmpty()) {
                            poolCurrentEventMap.remove(storagePoolId);
                            poolsEventsMap.remove(storagePoolId);
                            break;
                        } else {
                            poolsEventsMap.put(storagePoolId, queue);
                        }
                    } finally {
                        lock.unlock();
                    }
                }
            }
        } catch (Exception e) {
            log.errorFormat("Exception during process of events for pool {0}, error is {1}", storagePoolId, e.getMessage());
        }
    }
}
#end_block

#method_before
private void EndCommandAction() {
    CommandMultiAsyncTasks entityInfo = GetCommandMultiAsyncTasks();
    VdcReturnValueBase vdcReturnValue = null;
    ExecutionContext context = null;
    boolean endActionRuntimeException = false;
    AsyncTasks dbAsyncTask = getParameters().getDbAsyncTask();
    ArrayList<VdcActionParametersBase> imagesParameters = new ArrayList<VdcActionParametersBase>();
    for (EndedTaskInfo taskInfo : entityInfo.getEndedTasksInfo().getTasksInfo()) {
        VdcActionParametersBase childTaskParameters = taskInfo.getTaskParameters().getDbAsyncTask().getTaskParameters();
        boolean childTaskGroupSuccess = childTaskParameters.getTaskGroupSuccess() && taskInfo.getTaskStatus().getTaskEndedSuccessfully();
        childTaskParameters.setTaskGroupSuccess(childTaskGroupSuccess);
        if (!childTaskParameters.equals(dbAsyncTask.getActionParameters())) {
            imagesParameters.add(childTaskParameters);
        }
    }
    dbAsyncTask.getActionParameters().setImagesParameters(imagesParameters);
    try {
        log.infoFormat("CommandAsyncTask::EndCommandAction [within thread] context: Attempting to EndAction '{0}', executionIndex: '{1}'", dbAsyncTask.getActionParameters().getCommandType(), dbAsyncTask.getActionParameters().getExecutionIndex());
        try {
            /**
             * Creates context for the job which monitors the action
             */
            Guid stepId = dbAsyncTask.getStepId();
            if (stepId != null) {
                context = ExecutionHandler.createFinalizingContext(stepId);
            }
            vdcReturnValue = Backend.getInstance().endAction(getEndActionType(dbAsyncTask), dbAsyncTask.getActionParameters(), new CommandContext(context));
        } catch (VdcBLLException ex) {
            log.error(getErrorMessage());
            log.error(ex.toString());
            log.debug(ex);
        } catch (RuntimeException ex) {
            log.error(getErrorMessage(), ex);
            endActionRuntimeException = true;
        }
    } catch (RuntimeException Ex2) {
        log.error("CommandAsyncTask::EndCommandAction [within thread]: An exception has been thrown (not related to 'EndAction' itself)", Ex2);
        endActionRuntimeException = true;
    } finally {
        // if a RuntimeExcpetion occurs we clear the task from db and perform no other action
        if (endActionRuntimeException) {
            handleEndActionRuntimeException(entityInfo, dbAsyncTask);
            return;
        }
        boolean isTaskGroupSuccess = dbAsyncTask.getActionParameters().getTaskGroupSuccess();
        handleEndActionResult(entityInfo, vdcReturnValue, context, isTaskGroupSuccess);
    }
}
#method_after
private void EndCommandAction() {
    CommandMultiAsyncTasks entityInfo = GetCommandMultiAsyncTasks();
    VdcReturnValueBase vdcReturnValue = null;
    ExecutionContext context = null;
    boolean endActionRuntimeException = false;
    AsyncTasks dbAsyncTask = getParameters().getDbAsyncTask();
    ArrayList<VdcActionParametersBase> imagesParameters = new ArrayList<VdcActionParametersBase>();
    for (EndedTaskInfo taskInfo : entityInfo.getEndedTasksInfo().getTasksInfo()) {
        VdcActionParametersBase childTaskParameters = taskInfo.getTaskParameters().getDbAsyncTask().getTaskParameters();
        boolean childTaskGroupSuccess = childTaskParameters.getTaskGroupSuccess() && taskInfo.getTaskStatus().getTaskEndedSuccessfully();
        childTaskParameters.setTaskGroupSuccess(childTaskGroupSuccess);
        if (!childTaskParameters.equals(dbAsyncTask.getActionParameters())) {
            imagesParameters.add(childTaskParameters);
        }
    }
    dbAsyncTask.getActionParameters().setImagesParameters(imagesParameters);
    try {
        log.infoFormat("CommandAsyncTask::EndCommandAction [within thread] context: Attempting to EndAction '{0}', executionIndex: '{1}'", dbAsyncTask.getActionParameters().getCommandType(), dbAsyncTask.getActionParameters().getExecutionIndex());
        try {
            /**
             * Creates context for the job which monitors the action
             */
            Guid stepId = dbAsyncTask.getStepId();
            if (stepId != null) {
                context = ExecutionHandler.createFinalizingContext(stepId);
            }
            vdcReturnValue = Backend.getInstance().endAction(getEndActionType(dbAsyncTask), dbAsyncTask.getActionParameters(), new CommandContext(context));
        } catch (VdcBLLException ex) {
            log.error(getErrorMessage());
            log.error(ex.toString());
            log.debug(ex);
        } catch (RuntimeException ex) {
            log.error(getErrorMessage(), ex);
            endActionRuntimeException = true;
        }
    } catch (RuntimeException Ex2) {
        log.error("CommandAsyncTask::EndCommandAction [within thread]: An exception has been thrown (not related to 'EndAction' itself)", Ex2);
        endActionRuntimeException = true;
    } finally {
        // if a RuntimeExcpetion occurs we clear the task from db and perform no other action
        if (endActionRuntimeException) {
            handleEndActionRuntimeException(entityInfo, dbAsyncTask);
        } else {
            boolean isTaskGroupSuccess = dbAsyncTask.getActionParameters().getTaskGroupSuccess();
            handleEndActionResult(entityInfo, vdcReturnValue, context, isTaskGroupSuccess);
        }
    }
}
#end_block

#method_before
private void handleEndActionRuntimeException(CommandMultiAsyncTasks commandInfo, AsyncTasks dbAsyncTask) {
    try {
        VdcActionType actionType = getParameters().getDbAsyncTask().getaction_type();
        log.infoFormat("CommandAsyncTask::HandleEndActionResult: EndAction for action type '{0}' threw an unrecoverable RuntimeException the task will be cleared.", actionType);
        commandInfo.clearTaskWithRuntimeException(dbAsyncTask.getVdsmTaskId());
        RemoveTaskFromDB();
        if (commandInfo.getAllCleared()) {
            log.infoFormat("CommandAsyncTask::HandleEndActionRuntimeException: Removing CommandMultiAsyncTasks object for entity '{0}'", commandInfo.getCommandId());
            _multiTasksByCommandIds.remove(commandInfo.getCommandId());
        }
    } catch (RuntimeException ex) {
        log.error("CommandAsyncTask::HandleEndActionResult [within thread]: an exception has been thrown", ex);
    }
}
#method_after
private void handleEndActionRuntimeException(CommandMultiAsyncTasks commandInfo, AsyncTasks dbAsyncTask) {
    try {
        VdcActionType actionType = getParameters().getDbAsyncTask().getaction_type();
        log.infoFormat("CommandAsyncTask::HandleEndActionResult: EndAction for action type '{0}' threw an unrecoverable RuntimeException the task will be cleared.", actionType);
        commandInfo.clearTaskByVdsmTaskId(dbAsyncTask.getVdsmTaskId());
        RemoveTaskFromDB();
        if (commandInfo.getAllCleared()) {
            log.infoFormat("CommandAsyncTask::HandleEndActionRuntimeException: Removing CommandMultiAsyncTasks object for entity '{0}'", commandInfo.getCommandId());
            _multiTasksByCommandIds.remove(commandInfo.getCommandId());
        }
    } catch (RuntimeException ex) {
        log.error("CommandAsyncTask::HandleEndActionResult [within thread]: an exception has been thrown", ex);
    }
}
#end_block

#method_before
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    FileInputStream propertiesFile;
    try {
        propertiesFile = new FileInputStream(propertiesFileName);
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#method_after
public boolean load() {
    // $NON-NLS-1$
    final String propertiesFileName = filePath + "/" + BRANDING_PROPERTIES_NAME;
    available = false;
    try (FileInputStream propertiesFile = new FileInputStream(propertiesFileName)) {
        brandingProperties.load(propertiesFile);
        available = supportedBrandingVersion == getVersion(brandingProperties);
        if (!available) {
            log.warn(// $NON-NLS-1$
            "Unable to load branding theme, mismatched version: " + getVersion(brandingProperties) + " wanted version: " + // $NON-NLS-1$
            supportedBrandingVersion);
        }
    } catch (IOException e) {
        // Unable to load properties file, disable theme.
        log.warn(// $NON-NLS-1$
        "Unable to load properties file for " + // $NON-NLS-1$
        "theme located here:" + propertiesFileName, e);
    }
    return available;
}
#end_block

#method_before
public ResourceBundle getMessagesBundle() {
    // Default to US Locale.
    return getMessagesBundle(LocaleFilter.DEFAULT_LOCALE);
}
#method_after
public List<ResourceBundle> getMessagesBundle() {
    // Default to US Locale.
    return getMessagesBundle(LocaleFilter.DEFAULT_LOCALE);
}
#end_block

#method_before
public ResourceBundle getMessagesBundle(final Locale locale) {
    return getBundle(MESSAGES_KEY, locale);
}
#method_after
public List<ResourceBundle> getMessagesBundle(final Locale locale) {
    return getBundle(MESSAGES_KEY, locale);
}
#end_block

#method_before
private ResourceBundle getBundle(String name, Locale locale) {
    ResourceBundle result = null;
    try {
        File themeDirectory = new File(filePath);
        URLClassLoader urlLoader = new URLClassLoader(new URL[] { themeDirectory.toURI().toURL() });
        final String messageFileName = brandingProperties.getProperty(name);
        if (messageFileName != null) {
            String bundleName = messageFileName.lastIndexOf(PROPERTIES_FILE_SUFFIX) != -1 ? messageFileName.substring(0, messageFileName.lastIndexOf(PROPERTIES_FILE_SUFFIX)) : messageFileName;
            result = ResourceBundle.getBundle(bundleName, locale, urlLoader);
        }
    } catch (IOException e) {
        // Unable to load messages resource bundle.
        log.warn(// $NON-NLS-1$
        "Unable to read resources resource " + "bundle, returning null", // $NON-NLS-1$
        e);
    }
    return result;
}
#method_after
private List<ResourceBundle> getBundle(String name, Locale locale) {
    List<ResourceBundle> result = new ArrayList<ResourceBundle>();
    try {
        File themeDirectory = new File(filePath);
        URLClassLoader urlLoader = new URLClassLoader(new URL[] { themeDirectory.toURI().toURL() });
        final String messageFileNames = brandingProperties.getProperty(name);
        if (messageFileNames != null) {
            // The values can be a comma separated list of file names, split them and load each of them.
            for (String fileName : messageFileNames.split(",")) {
                fileName = fileName.trim();
                String bundleName = fileName.lastIndexOf(PROPERTIES_FILE_SUFFIX) != -1 ? fileName.substring(0, fileName.lastIndexOf(PROPERTIES_FILE_SUFFIX)) : messageFileNames;
                result.add(ResourceBundle.getBundle(bundleName, locale, urlLoader));
            }
        }
    } catch (IOException e) {
        // Unable to load messages resource bundle.
        log.warn(// $NON-NLS-1$
        "Unable to read resources resource " + "bundle, returning null", // $NON-NLS-1$
        e);
    }
    return result;
}
#end_block

#method_before
Map<String, String> getMessageMap(final String prefix, final Locale locale) {
    List<BrandingTheme> messageThemes = getBrandingThemes();
    // We need this map to remove potential duplicate strings from the resource bundles.
    Map<String, String> keyValues = new HashMap<String, String>();
    if (messageThemes != null) {
        for (BrandingTheme theme : messageThemes) {
            ResourceBundle messagesBundle = theme.getMessagesBundle(locale);
            getKeyValuesFromResourceBundle(prefix, keyValues, messagesBundle);
            ResourceBundle resourcesBundle = theme.getResourceBundle();
            getKeyValuesFromResourceBundle(prefix, keyValues, resourcesBundle);
        }
    }
    return keyValues;
}
#method_after
Map<String, String> getMessageMap(final String prefix, final Locale locale) {
    List<BrandingTheme> messageThemes = getBrandingThemes();
    // We need this map to remove potential duplicate strings from the resource bundles.
    Map<String, String> keyValues = new HashMap<String, String>();
    if (messageThemes != null) {
        for (BrandingTheme theme : messageThemes) {
            List<ResourceBundle> bundles = theme.getMessagesBundle(locale);
            for (ResourceBundle bundle : bundles) {
                getKeyValuesFromResourceBundle(prefix, keyValues, bundle);
            }
        }
    }
    return keyValues;
}
#end_block

#method_before
void forceRefresh(M model) {
    if (model instanceof SearchableListModel) {
        UICommand lastExecutedCommand = model.getLastExecutedCommand();
        if (lastExecutedCommand != null && !lastExecutedCommand.getIsCancel()) {
            // Refresh the grid using ForceRefresh command
            SearchableListModel searchableList = (SearchableListModel) model;
            searchableList.getForceRefreshCommand().execute();
        }
    }
}
#method_after
void forceRefresh(M model) {
    if (model instanceof SearchableListModel) {
        UICommand lastExecutedCommand = model.getLastExecutedCommand();
        if (lastExecutedCommand != null && !lastExecutedCommand.getIsCancel()) {
            // Refresh grid after invoking non-cancel command
            SearchableListModel searchableList = (SearchableListModel) model;
            searchableList.forceRefresh();
        }
    }
}
#end_block

#method_before
public ArrayList<Guid> getTaskIdList() {
    return _taskIdList;
}
#method_after
public ArrayList<Guid> getTaskIdList() {
    return taskIdList;
}
#end_block

#method_before
public void setTaskIdList(ArrayList<Guid> value) {
    _taskIdList = value;
}
#method_after
public void setTaskIdList(ArrayList<Guid> value) {
    taskIdList = value;
}
#end_block

#method_before
public NGuid getJobId() {
    return jobId;
}
#method_after
public Guid getJobId() {
    return jobId;
}
#end_block

#method_before
public void setJobId(NGuid jobId) {
    this.jobId = jobId;
}
#method_after
public void setJobId(Guid jobId) {
    this.jobId = jobId;
}
#end_block

#method_before
public static void failTaskWithoutVdsmId(final AsyncTasks task) {
    task.getTaskParameters().setTaskGroupSuccess(false);
    ExecutionHandler.endTaskStep(task.getStepId(), JobExecutionStatus.FAILED);
    removeTaskFromDbByTaskId(task.getTaskId());
    if (task.getTaskType() == AsyncTaskType.unknown) {
        return;
    }
    ThreadPoolUtil.execute(new Runnable() {

        @SuppressWarnings("synthetic-access")
        @Override
        public void run() {
            NGuid stepId = task.getStepId();
            ExecutionContext context = null;
            if (stepId != null) {
                context = ExecutionHandler.createFinalizingContext(stepId.getValue());
            }
            Backend.getInstance().endAction(task.getaction_type(), task.getActionParameters(), new CommandContext(context));
        }
    });
}
#method_after
public static void failTaskWithoutVdsmId(final AsyncTasks task) {
    ThreadPoolUtil.execute(new Runnable() {

        @SuppressWarnings("synthetic-access")
        @Override
        public void run() {
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Object>() {

                @Override
                public Object runInTransaction() {
                    logAndFailTaskWithoutVdsmId(task);
                    return null;
                }
            });
        }
    });
}
#end_block

#method_before
protected static void removeTaskFromDbByTaskId(Guid taskId) {
    try {
        if (DbFacade.getInstance().getAsyncTaskDao().remove(taskId) != 0) {
            log.infoFormat("BaseAsyncTask::RemoveTaskFromDB: Removed task {0} from DataBase", taskId);
        }
    } catch (RuntimeException e) {
        log.error(String.format("AsyncTaskManager::RemoveTaskFromDB: Removing task %1$s from DataBase threw an exception.", taskId), e);
    }
}
#method_after
protected static void removeTaskFromDbByTaskId(Guid taskId) {
    try {
        if (DbFacade.getInstance().getAsyncTaskDao().remove(taskId) != 0) {
            log.infoFormat("Removed task {0} from DataBase", taskId);
        }
    } catch (RuntimeException e) {
        log.error(String.format("Removing task %1$s from DataBase threw an exception.", taskId), e);
    }
}
#end_block

#method_before
public void AddStoragePoolExistingTasks(StoragePool sp) {
    List<AsyncTaskCreationInfo> currPoolTasks = null;
    try {
        currPoolTasks = (ArrayList<AsyncTaskCreationInfo>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SPMGetAllTasksInfo, new IrsBaseVDSCommandParameters(sp.getId())).getReturnValue();
    } catch (RuntimeException e) {
        log.error(String.format("Getting existing tasks on Storage Pool %1$s failed.", sp.getname()), e);
    }
    if (currPoolTasks != null && currPoolTasks.size() > 0) {
        synchronized (this) {
            final List<SPMAsyncTask> newlyAddedTasks = new ArrayList<SPMAsyncTask>();
            for (AsyncTaskCreationInfo creationInfo : currPoolTasks) {
                creationInfo.setStoragePoolID(sp.getId());
                if (!_tasks.containsKey(creationInfo.getVdsmTaskId())) {
                    try {
                        SPMAsyncTask task = AsyncTaskFactory.Construct(creationInfo);
                        addTaskToManager(task);
                        newlyAddedTasks.add(task);
                    } catch (Exception e) {
                        log.errorFormat("Failed to load task of type {0} with id {1}, due to: {2}.", creationInfo.getTaskType(), creationInfo.getVdsmTaskId(), ExceptionUtils.getRootCauseMessage(e));
                    }
                }
            }
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    for (SPMAsyncTask task : newlyAddedTasks) {
                        AsyncTaskUtils.addOrUpdateTaskInDB(task);
                    }
                    return null;
                }
            });
            for (SPMAsyncTask task : newlyAddedTasks) {
                StartPollingTask(task.getVdsmTaskId());
            }
            log.infoFormat("Discovered {0} tasks on Storage Pool '{1}', {2} added to manager.", currPoolTasks.size(), sp.getname(), newlyAddedTasks.size());
        }
    } else {
        log.infoFormat("Discovered no tasks on Storage Pool {0}", sp.getname());
    }
    List<AsyncTasks> tasksInDForStoragePool = tasksInDbAfterRestart.get(sp.getId());
    if (tasksInDForStoragePool != null) {
        for (AsyncTasks task : tasksInDForStoragePool) {
            if (!_tasks.containsKey(task.getVdsmTaskId())) {
                DbFacade.getInstance().getAsyncTaskDao().removeByVdsmId(task.getVdsmTaskId());
            }
        }
    }
    // Either the tasks were only in DB - so they were removed from db, or they are polled -
    // in any case no need to hold them in the map that represents the tasksInDbAfterRestart
    tasksInDbAfterRestart.remove(sp.getId());
}
#method_after
public void AddStoragePoolExistingTasks(StoragePool sp) {
    List<AsyncTaskCreationInfo> currPoolTasks = null;
    try {
        currPoolTasks = (ArrayList<AsyncTaskCreationInfo>) Backend.getInstance().getResourceManager().RunVdsCommand(VDSCommandType.SPMGetAllTasksInfo, new IrsBaseVDSCommandParameters(sp.getId())).getReturnValue();
    } catch (RuntimeException e) {
        log.error(String.format("Getting existing tasks on Storage Pool %1$s failed.", sp.getName()), e);
    }
    if (currPoolTasks != null && currPoolTasks.size() > 0) {
        synchronized (this) {
            final List<SPMAsyncTask> newlyAddedTasks = new ArrayList<SPMAsyncTask>();
            for (AsyncTaskCreationInfo creationInfo : currPoolTasks) {
                creationInfo.setStoragePoolID(sp.getId());
                if (!_tasks.containsKey(creationInfo.getVdsmTaskId())) {
                    try {
                        SPMAsyncTask task = AsyncTaskFactory.Construct(creationInfo);
                        addTaskToManager(task);
                        newlyAddedTasks.add(task);
                    } catch (Exception e) {
                        log.errorFormat("Failed to load task of type {0} with id {1}, due to: {2}.", creationInfo.getTaskType(), creationInfo.getVdsmTaskId(), ExceptionUtils.getRootCauseMessage(e));
                    }
                }
            }
            TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

                @Override
                public Void runInTransaction() {
                    for (SPMAsyncTask task : newlyAddedTasks) {
                        AsyncTaskUtils.addOrUpdateTaskInDB(task);
                    }
                    return null;
                }
            });
            for (SPMAsyncTask task : newlyAddedTasks) {
                StartPollingTask(task.getVdsmTaskId());
            }
            log.infoFormat("Discovered {0} tasks on Storage Pool '{1}', {2} added to manager.", currPoolTasks.size(), sp.getName(), newlyAddedTasks.size());
        }
    } else {
        log.infoFormat("Discovered no tasks on Storage Pool {0}", sp.getName());
    }
    List<AsyncTasks> tasksInDForStoragePool = tasksInDbAfterRestart.get(sp.getId());
    if (tasksInDForStoragePool != null) {
        for (AsyncTasks task : tasksInDForStoragePool) {
            if (!_tasks.containsKey(task.getVdsmTaskId())) {
                DbFacade.getInstance().getAsyncTaskDao().removeByVdsmTaskId(task.getVdsmTaskId());
            }
        }
    }
    // Either the tasks were only in DB - so they were removed from db, or they are polled -
    // in any case no need to hold them in the map that represents the tasksInDbAfterRestart
    tasksInDbAfterRestart.remove(sp.getId());
}
#end_block

#method_before
public synchronized void StopStoragePoolTasks(final StoragePool sp) {
    log.infoFormat("Attempting to get and stop tasks on storage pool '{0}'", sp.getname());
    AddStoragePoolExistingTasks(sp);
    List<SPMAsyncTask> list = LinqUtils.filter(_tasks.values(), new Predicate<SPMAsyncTask>() {

        @Override
        public boolean eval(SPMAsyncTask a) {
            return a.getStoragePoolID().equals(sp.getId());
        }
    });
    for (SPMAsyncTask task : list) {
        task.stopTask();
    }
}
#method_after
public synchronized void StopStoragePoolTasks(final StoragePool sp) {
    log.infoFormat("Attempting to get and stop tasks on storage pool '{0}'", sp.getName());
    AddStoragePoolExistingTasks(sp);
    List<SPMAsyncTask> list = LinqUtils.filter(_tasks.values(), new Predicate<SPMAsyncTask>() {

        @Override
        public boolean eval(SPMAsyncTask a) {
            return a.getStoragePoolID().equals(sp.getId());
        }
    });
    for (SPMAsyncTask task : list) {
        task.stopTask();
    }
}
#end_block

#method_before
public synchronized void CancelTasks(List<Guid> taskList) {
    for (Guid taskID : taskList) {
        CancelTask(taskID);
    }
}
#method_after
public synchronized void CancelTasks(List<Guid> vdsmTaskList) {
    for (Guid vdsmTaskId : vdsmTaskList) {
        CancelTask(vdsmTaskId);
    }
}
#end_block

#method_before
public synchronized void CancelTask(Guid taskID) {
    if (_tasks.containsKey(taskID)) {
        log.infoFormat("Attempting to cancel task '{0}'.", taskID);
        _tasks.get(taskID).stopTask();
        _tasks.get(taskID).ConcreteStartPollingTask();
    }
}
#method_after
public synchronized void CancelTask(Guid vdsmTaskId) {
    if (_tasks.containsKey(vdsmTaskId)) {
        log.infoFormat("Attempting to cancel task '{0}'.", vdsmTaskId);
        _tasks.get(vdsmTaskId).stopTask();
        _tasks.get(vdsmTaskId).ConcreteStartPollingTask();
    }
}
#end_block

#method_before
public static VdcReturnValueBase instantiate(SerializationStreamReader streamReader) throws SerializationException {
    // occur first
    VdcReturnValueBase vrvb = new VdcReturnValueBase();
    vrvb.setCanDoAction(streamReader.readBoolean());
    java.util.ArrayList<String> canDoActionMessages = (java.util.ArrayList<String>) streamReader.readObject();
    vrvb.setCanDoActionMessages(canDoActionMessages);
    vrvb.setSucceeded(streamReader.readBoolean());
    vrvb.setIsSyncronious(streamReader.readBoolean());
    vrvb.setActionReturnValue(streamReader.readObject());
    vrvb.setDescription(streamReader.readString());
    java.util.ArrayList<Guid> asyncTaskIdList = (java.util.ArrayList<Guid>) streamReader.readObject();
    vrvb.setAsyncTaskIdList(asyncTaskIdList);
    java.util.ArrayList<Guid> taskIdList = (java.util.ArrayList<Guid>) streamReader.readObject();
    vrvb.setTaskIdList(taskIdList);
    vrvb.setEndActionTryAgain(streamReader.readBoolean());
    vrvb.setFault((VdcFault) streamReader.readObject());
    return vrvb;
}
#method_after
public static VdcReturnValueBase instantiate(SerializationStreamReader streamReader) throws SerializationException {
    // occur first
    VdcReturnValueBase vrvb = new VdcReturnValueBase();
    vrvb.setCanDoAction(streamReader.readBoolean());
    java.util.ArrayList<String> canDoActionMessages = (java.util.ArrayList<String>) streamReader.readObject();
    vrvb.setCanDoActionMessages(canDoActionMessages);
    vrvb.setSucceeded(streamReader.readBoolean());
    vrvb.setIsSyncronious(streamReader.readBoolean());
    vrvb.setActionReturnValue(streamReader.readObject());
    vrvb.setDescription(streamReader.readString());
    java.util.ArrayList<Guid> asyncTaskIdList = (java.util.ArrayList<Guid>) streamReader.readObject();
    vrvb.setTaskPlaceHolderIdList(asyncTaskIdList);
    java.util.ArrayList<Guid> taskIdList = (java.util.ArrayList<Guid>) streamReader.readObject();
    vrvb.setTaskIdList(taskIdList);
    vrvb.setEndActionTryAgain(streamReader.readBoolean());
    vrvb.setFault((VdcFault) streamReader.readObject());
    return vrvb;
}
#end_block

#method_before
public static void serialize(SerializationStreamWriter streamWriter, VdcReturnValueBase instance) throws SerializationException {
    streamWriter.writeBoolean(instance.getCanDoAction());
    streamWriter.writeObject(instance.getCanDoActionMessages());
    streamWriter.writeBoolean(instance.getSucceeded());
    streamWriter.writeBoolean(instance.getIsSyncronious());
    streamWriter.writeObject(instance.getActionReturnValue());
    streamWriter.writeString(instance.getDescription());
    streamWriter.writeObject(instance.getAsyncTaskIdList());
    streamWriter.writeObject(instance.getTaskIdList());
    streamWriter.writeBoolean(instance.getEndActionTryAgain());
    streamWriter.writeObject(instance.getFault());
}
#method_after
public static void serialize(SerializationStreamWriter streamWriter, VdcReturnValueBase instance) throws SerializationException {
    streamWriter.writeBoolean(instance.getCanDoAction());
    streamWriter.writeObject(instance.getCanDoActionMessages());
    streamWriter.writeBoolean(instance.getSucceeded());
    streamWriter.writeBoolean(instance.getIsSyncronious());
    streamWriter.writeObject(instance.getActionReturnValue());
    streamWriter.writeString(instance.getDescription());
    streamWriter.writeObject(instance.getTaskPlaceHolderIdList());
    streamWriter.writeObject(instance.getTaskIdList());
    streamWriter.writeBoolean(instance.getEndActionTryAgain());
    streamWriter.writeObject(instance.getFault());
}
#end_block

#method_before
private void clearAsyncTasksWithOutVdsmId() {
    for (Guid asyncTaskId : getReturnValue().getAsyncTaskIdList()) {
        AsyncTasks task = DbFacade.getInstance().getAsyncTaskDao().get(asyncTaskId);
        if (task.getTaskId().equals(NGuid.Empty)) {
            AsyncTaskManager.failTaskWithoutVdsmId(task);
        }
    }
}
#method_after
private void clearAsyncTasksWithOutVdsmId() {
    for (Guid asyncTaskId : getReturnValue().getTaskPlaceHolderIdList()) {
        AsyncTasks task = getAsyncTaskDao().get(asyncTaskId);
        if (Guid.isNullOrEmpty(task.getVdsmTaskId())) {
            AsyncTaskManager.failTaskWithoutVdsmId(task);
        }
    }
}
#end_block

#method_before
protected void compensate() {
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().compensate();
        revertPreviousHandlers();
    } else {
        internalCompensate();
    }
}
#method_after
protected void compensate() {
    if (hasTaskHandlers()) {
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        revertPreviousHandlers();
    } else {
        internalCompensate();
    }
}
#end_block

#method_before
private void internalEndWithFailure() {
    log.errorFormat("Ending command with failure: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        getCurrentTaskHandler().endWithFailure();
        revertPreviousHandlers();
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollbackQuota();
}
#method_after
private void internalEndWithFailure() {
    log.errorFormat("Ending command with failure: {0}", getClass().getName());
    if (hasTaskHandlers()) {
        if (hasStepsToRevert()) {
            getCurrentTaskHandler().endWithFailure();
            revertPreviousHandlers();
        }
        startPollingAsyncTasks();
    } else {
        endWithFailure();
    }
    rollbackQuota();
}
#end_block

#method_before
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (getExecutionIndex() >= 0) {
        logRollbackedTask();
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    }
}
#method_after
private void revertPreviousHandlers() {
    getParameters().decrementExecutionIndex();
    if (hasStepsToRevert()) {
        logRollbackedTask();
        getParameters().setExecutionReason(CommandExecutionReason.ROLLBACK_FLOW);
        getCurrentTaskHandler().compensate();
        if (!hasRevertTask()) {
            // If there is no task to take us onwards, just run the previous handler's revert
            revertPreviousHandlers();
        }
    } else {
        setSucceeded(true);
    }
}
#end_block

#method_before
protected boolean checkUserAuthorization(Guid userId, final ActionGroup actionGroup, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final NGuid permId = getDbFacade().getEntityPermissions(userId, actionGroup, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAuthorization(Guid userId, final ActionGroup actionGroup, final Guid object, final VdcObjectType type) {
    // Grant if there is matching permission in the database:
    final Guid permId = getDbFacade().getEntityPermissions(userId, actionGroup, object, type);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final NGuid permId = getDbFacade().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#method_after
protected boolean checkUserAndGroupsAuthorization(Guid userId, String groupIds, final ActionGroup actionGroup, final Guid object, final VdcObjectType type, final boolean ignoreEveryone) {
    // Grant if there is matching permission in the database:
    final Guid permId = getDbFacade().getEntityPermissionsForUserAndGroups(userId, groupIds, actionGroup, object, type, ignoreEveryone);
    if (permId != null) {
        if (log.isDebugEnabled()) {
            log.debugFormat("Found permission {0} for user when running {1}, on {2} with id {3}", permId, getActionType(), type.getVdcObjectTranslation(), object);
        }
        return true;
    }
    // Deny otherwise:
    if (log.isDebugEnabled()) {
        log.debugFormat("No permission found for user when running action {0}, on object {1} for action group {2} with id {3}.", getActionType(), type.getVdcObjectTranslation(), actionGroup, object);
    }
    return false;
}
#end_block

#method_before
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append("Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#method_after
private void logRunningCommand() {
    // Set start of log for running command.
    StringBuilder logInfo = new StringBuilder("Running command: ").append(getClass().getSimpleName());
    if (hasTaskHandlers()) {
        logInfo.append(" Task handler: ").append(getCurrentTaskHandler().getClass().getSimpleName());
    }
    logInfo.append(" internal: ").append(isInternalExecution()).append(".");
    // Get permissions of object ,to get object id.
    List<PermissionSubject> permissionSubjectList = getPermissionCheckSubjects();
    // Log if there is entry in the permission map.
    if (permissionSubjectList != null && !permissionSubjectList.isEmpty()) {
        // Build entities string for entities affected by this operation.
        StringBuilder logEntityIdsInfo = new StringBuilder();
        // Iterate all over the entities , which should be affected.
        for (PermissionSubject permSubject : permissionSubjectList) {
            if (permSubject.getObjectId() != null) {
                // affected.
                if (logEntityIdsInfo.length() != 0) {
                    logEntityIdsInfo.append(", ");
                }
                logEntityIdsInfo.append(" ID: ").append(permSubject.getObjectId()).append(" Type: ").append(permSubject.getObjectType());
            }
        }
        // If found any entities, add the log to the logInfo.
        if (logEntityIdsInfo.length() != 0) {
            // Print all the entities affected.
            logInfo.append(" Entities affected : ").append(logEntityIdsInfo);
        }
    }
    // Log the final appended message to the log.
    log.info(logInfo);
}
#end_block

#method_before
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, VdcObjectType entityType, Guid... entityIds) {
    Guid retValue = Guid.Empty;
    Transaction transaction = TransactionSupport.suspend();
    try {
        Step taskStep = ExecutionHandler.addTaskStep(getExecutionContext(), StepEnum.getStepNameByTaskType(asyncTaskCreationInfo.getTaskType()), description);
        if (taskStep != null) {
            asyncTaskCreationInfo.setStepId(taskStep.getId());
        }
        SPMAsyncTask task = concreteCreateTask(taskId, asyncTaskCreationInfo, parentCommand);
        retValue = task.getVdsmTaskId();
        task.setEntityType(entityType);
        task.setAssociatedEntities(entityIds);
        AsyncTaskUtils.addOrUpdateTaskInDB(task);
        getAsyncTaskManager().lockAndAddTaskToManager(task);
        retValue = task.getVdsmTaskId();
        ExecutionHandler.updateStepExternalId(taskStep, retValue, ExternalSystemType.VDSM);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return retValue;
}
#method_after
protected Guid createTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand, String description, VdcObjectType entityType, Guid... entityIds) {
    Transaction transaction = TransactionSupport.suspend();
    try {
        return createTaskImpl(taskId, asyncTaskCreationInfo, parentCommand, description, entityType, entityIds);
    } catch (RuntimeException ex) {
        log.errorFormat("Error during CreateTask for command: {0}. Exception {1}", getClass().getName(), ex);
    } finally {
        TransactionSupport.resume(transaction);
    }
    return Guid.Empty;
}
#end_block

#method_before
private AsyncTasks getAsyncTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTasks asyncTask = null;
    if (!taskId.equals(Guid.Empty)) {
        asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
    }
    if (asyncTask != null) {
        asyncTask.setVdsmTaskId(asyncTaskCreationInfo.getVdsmTaskId());
        asyncTask.setStepId(asyncTaskCreationInfo.getStepId());
        asyncTask.setStoragePoolId(asyncTaskCreationInfo.getStoragePoolID());
        asyncTask.setTaskType(asyncTaskCreationInfo.getTaskType());
    } else {
        asyncTask = createAsyncTask(asyncTaskCreationInfo, parentCommand);
    }
    return asyncTask;
}
#method_after
private AsyncTasks getAsyncTask(Guid taskId, AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    AsyncTasks asyncTask = null;
    if (!taskId.equals(Guid.Empty)) {
        asyncTask = DbFacade.getInstance().getAsyncTaskDao().get(taskId);
    }
    if (asyncTask != null) {
        asyncTask.setVdsmTaskId(asyncTaskCreationInfo.getVdsmTaskId());
        asyncTask.setActionParameters(getParentParameters(parentCommand));
        asyncTask.setTaskParameters(getParameters());
        asyncTask.setStepId(asyncTaskCreationInfo.getStepId());
        asyncTask.setStoragePoolId(asyncTaskCreationInfo.getStoragePoolID());
        asyncTask.setTaskType(asyncTaskCreationInfo.getTaskType());
    } else {
        asyncTask = createAsyncTask(asyncTaskCreationInfo, parentCommand);
    }
    return asyncTask;
}
#end_block

#method_before
private AsyncTasks createAsyncTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    VdcActionParametersBase parentParameters = getParametersForTask(parentCommand, getParameters());
    if (parentParameters.getParametersCurrentUser() == null && getCurrentUser() != null) {
        parentParameters.setParametersCurrentUser(getCurrentUser());
    }
    return new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getVdsmTaskId(), parentParameters, getParameters(), asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType());
}
#method_after
private AsyncTasks createAsyncTask(AsyncTaskCreationInfo asyncTaskCreationInfo, VdcActionType parentCommand) {
    return new AsyncTasks(parentCommand, AsyncTaskResultEnum.success, AsyncTaskStatusEnum.running, asyncTaskCreationInfo.getVdsmTaskId(), getParentParameters(parentCommand), getParameters(), asyncTaskCreationInfo.getStepId(), getCommandId(), asyncTaskCreationInfo.getStoragePoolID(), asyncTaskCreationInfo.getTaskType());
}
#end_block

#method_before
protected boolean acquireLock() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        isReleaseExecute = annotation.isReleaseAtEndOfExecute();
        if (!annotation.isWait()) {
            returnValue = acquireLockInternal();
        } else {
            acquireLockAndWait();
        }
    }
    return returnValue;
}
#method_after
protected boolean acquireLock() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        releaseLocksAtEndOfExecute = annotation.isReleaseAtEndOfExecute();
        if (!annotation.isWait()) {
            returnValue = acquireLockInternal();
        } else {
            acquireLockAndWait();
        }
    }
    return returnValue;
}
#end_block

#method_before
public final boolean acquireLockAsyncTask() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        isReleaseExecute = annotation.isReleaseAtEndOfExecute();
        if (!isReleaseExecute) {
            returnValue = acquireLockInternal();
        }
    }
    return returnValue;
}
#method_after
public final boolean acquireLockAsyncTask() {
    LockIdNameAttribute annotation = getClass().getAnnotation(LockIdNameAttribute.class);
    boolean returnValue = true;
    if (annotation != null) {
        releaseLocksAtEndOfExecute = annotation.isReleaseAtEndOfExecute();
        if (!releaseLocksAtEndOfExecute) {
            returnValue = acquireLockInternal();
        }
    }
    return returnValue;
}
#end_block

#method_before
private void freeLockExecute() {
    if (isReleaseExecute || !getSucceeded()) {
        freeLock();
    }
}
#method_after
private void freeLockExecute() {
    if (releaseLocksAtEndOfExecute || !getSucceeded() || !hasTasks()) {
        freeLock();
    }
}
#end_block

#method_before
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        if (oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType() || (entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors()) || oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci()) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, entity.getDefaultDisplayType().getVmDeviceType(), getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(oldVmBase, entity, params.isBalloonEnabled());
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
    }
}
#method_after
public static void updateVmDevices(VmManagementParametersBase params, VM oldVm) {
    VmBase oldVmBase = oldVm.getStaticData();
    VmBase entity = params.getVmStaticData();
    if (entity != null) {
        updateCdInVmDevice(oldVmBase, entity);
        if (oldVmBase.getDefaultBootSequence() != entity.getDefaultBootSequence()) {
            updateBootOrderInVmDeviceAndStoreToDB(entity);
        }
        // if the console type has changed, recreate Video devices
        boolean displayTypeChanged = oldVmBase.getDefaultDisplayType() != entity.getDefaultDisplayType();
        boolean numOfMonitorsChanged = entity.getDefaultDisplayType() == DisplayType.qxl && oldVmBase.getNumOfMonitors() != entity.getNumOfMonitors();
        boolean singleQxlChanged = oldVmBase.getSingleQxlPci() != entity.getSingleQxlPci();
        if (displayTypeChanged || numOfMonitorsChanged || singleQxlChanged) {
            // delete all video device
            for (VmDevice device : dao.getVmDeviceByVmIdAndType(oldVmBase.getId(), VmDeviceGeneralType.VIDEO)) {
                dao.remove(device.getId());
            }
            // add video device per each monitor
            int monitors = entity.getSingleQxlPci() ? 1 : entity.getNumOfMonitors();
            for (int i = 0; i < monitors; i++) {
                addManagedDevice(new VmDeviceId(Guid.newGuid(), entity.getId()), VmDeviceGeneralType.VIDEO, entity.getDefaultDisplayType().getVmDeviceType(), getMemExpr(entity.getNumOfMonitors(), entity.getSingleQxlPci()), true, false, null);
            }
        }
        updateUSBSlots(oldVmBase, entity);
        updateMemoryBalloon(oldVmBase, entity, params.isBalloonEnabled());
        updateAudioDevice(oldVm.getStaticData(), entity, oldVm.getVdsGroupCompatibilityVersion(), params.isSoundDeviceEnabled());
        updateSmartcardDevice(oldVm, entity);
        updateConsoleDevice(entity, params.isConsoleEnabled());
    }
}
#end_block

#method_before
@Override
public void setEntity(Object value) {
    if (allKeyValueMap == null) {
        saveEntity = value;
        return;
    }
    List<KeyValueLineModel> list = new ArrayList<KeyValueLineModel>();
    KeyValueLineModel lineModel;
    if (value != null) {
        String split = (String) value;
        if (split.isEmpty()) {
            return;
        }
        String[] lines = split.split(PROPERTIES_DELIMETER);
        keyValueMap_used = new HashMap<String, String>();
        String[] splitLine;
        for (String line : lines) {
            if (line.isEmpty()) {
                continue;
            }
            splitLine = line.split(KEY_VALUE_DELIMETER, 2);
            String key = splitLine[0];
            if (allKeyValueMap.containsKey(key)) {
                keyValueMap_used.put(key, splitLine[1]);
            }
        }
        for (Map.Entry<String, String> stringStringEntry : keyValueMap_used.entrySet()) {
            lineModel = new KeyValueLineModel(this);
            lineModel.getKeys().setItems(getAvailbleKeys(stringStringEntry.getKey()));
            lineModel.getKeys().setSelectedItem(stringStringEntry.getKey());
            if (allRegExKeys.containsKey(stringStringEntry.getKey())) {
                lineModel.getValue().setIsAvailable(false);
                lineModel.getValues().setIsAvailable(true);
                lineModel.getValues().setItems(allRegExKeys.get(stringStringEntry.getKey()));
                lineModel.getValues().setSelectedItem(stringStringEntry.getValue());
            } else {
                lineModel.getValue().setEntity(stringStringEntry.getValue());
            }
            list.add(lineModel);
        }
    } else {
        lineModel = new KeyValueLineModel(this);
        lineModel.getKeys().setItems(getAvailbleKeys());
        list.add(lineModel);
    }
    for (final KeyValueLineModel keyValueLineModel : list) {
        keyValueLineModel.getKeys().getSelectedItemChangedEvent().addListener(keyChangedListener);
    }
    getKeyValueLines().setItems(list);
}
#method_after
@Override
public void setEntity(Object value) {
    if (allKeyValueMap == null) {
        saveEntity = value;
        return;
    }
    List<KeyValueLineModel> list = new ArrayList<KeyValueLineModel>();
    KeyValueLineModel lineModel;
    if (value != null) {
        String split = (String) value;
        if (split.isEmpty()) {
            return;
        }
        String[] lines = split.split(PROPERTIES_DELIMETER);
        keyValueMap_used = new HashMap<String, String>();
        String[] splitLine;
        for (String line : lines) {
            if (line.isEmpty()) {
                continue;
            }
            splitLine = line.split(KEY_VALUE_DELIMETER, 2);
            String key = splitLine[0];
            if (allKeyValueMap.containsKey(key)) {
                keyValueMap_used.put(key, splitLine[1]);
            }
        }
        for (Map.Entry<String, String> entry : keyValueMap_used.entrySet()) {
            lineModel = new KeyValueLineModel(this);
            lineModel.getKeys().setItems(getAvailbleKeys(entry.getKey()));
            lineModel.getKeys().setSelectedItem(entry.getKey());
            if (allRegExKeys.containsKey(entry.getKey())) {
                lineModel.getValue().setIsAvailable(false);
                lineModel.getValues().setIsAvailable(true);
                lineModel.getValues().setItems(allRegExKeys.get(entry.getKey()));
                lineModel.getValues().setSelectedItem(entry.getValue());
            } else {
                lineModel.getValue().setEntity(entry.getValue());
            }
            list.add(lineModel);
        }
    } else {
        lineModel = new KeyValueLineModel(this);
        lineModel.getKeys().setItems(getAvailbleKeys());
        list.add(lineModel);
    }
    for (final KeyValueLineModel keyValueLineModel : list) {
        keyValueLineModel.getKeys().getSelectedItemChangedEvent().addListener(keyChangedListener);
    }
    getKeyValueLines().setItems(list);
}
#end_block

#method_before
@Override
public String getPrefix(String namespaceURI) {
    for (Map.Entry<String, String> stringStringEntry : prefixToUri.entrySet()) {
        if (stringStringEntry.getValue().equals(namespaceURI))
            return stringStringEntry.getKey();
    }
    return null;
}
#method_after
@Override
public String getPrefix(String namespaceURI) {
    for (Map.Entry<String, String> prexiToUriEntry : prefixToUri.entrySet()) {
        if (prexiToUriEntry.getValue().equals(namespaceURI)) {
            return prexiToUriEntry.getKey();
        }
    }
    return null;
}
#end_block

#method_before
@Override
public Iterator getPrefixes(String namespaceURI) {
    List<String> prefixes = new LinkedList<String>();
    for (Map.Entry<String, String> stringStringEntry : prefixToUri.entrySet()) {
        if (stringStringEntry.getValue().equals(namespaceURI))
            prefixes.add(stringStringEntry.getKey());
    }
    return prefixes.iterator();
}
#method_after
@Override
public Iterator getPrefixes(String namespaceURI) {
    List<String> prefixes = new LinkedList<String>();
    for (Map.Entry<String, String> prefixToUriEntry : prefixToUri.entrySet()) {
        if (prefixToUriEntry.getValue().equals(namespaceURI)) {
            prefixes.add(prefixToUriEntry.getKey());
        }
    }
    return prefixes.iterator();
}
#end_block

#method_before
@Override
protected void ExecuteVdsBrokerCommand() {
    buildVmData();
    mVmReturn = getBroker().create(createInfo);
    logCommandInfo();
    ProceedProxyReturnValue();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vm.getDynamicData(), mVmReturn.mVm);
}
#method_after
@Override
protected void ExecuteVdsBrokerCommand() {
    buildVmData();
    mVmReturn = getBroker().create(createInfo);
    logCommandInfo();
    proceedProxyReturnValue();
    VdsBrokerObjectsBuilder.updateVMDynamicData(vm.getDynamicData(), mVmReturn.mVm);
}
#end_block

#method_before
private void logCommandInfo() {
    final char EQUAL = '=';
    final String SEP = ",";
    StringBuilder info = new StringBuilder();
    String sep = "";
    for (Map.Entry<String, Object> stringObjectEntry : createInfo.entrySet()) {
        info.append(sep);
        info.append(stringObjectEntry.getKey());
        info.append(EQUAL);
        info.append(stringObjectEntry.getValue());
        sep = SEP;
    }
    log.infoFormat("{0} {1}", getClass().getName(), info.toString());
}
#method_after
private void logCommandInfo() {
    final char EQUAL = '=';
    final String SEP = ",";
    StringBuilder info = new StringBuilder();
    String sep = "";
    for (Map.Entry<String, Object> createInfoEntry : createInfo.entrySet()) {
        info.append(sep);
        info.append(createInfoEntry.getKey());
        info.append(EQUAL);
        info.append(createInfoEntry.getValue());
        sep = SEP;
    }
    log.infoFormat("{0} {1}", getClass().getName(), info.toString());
}
#end_block

#method_before
private void verifyCorrectOvfDataUpdaterRun(Guid storagePoolId, Collection<Guid> needToBeUpdated, Collection<Guid> removedGuids) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> storagePoolMetadataUpdatedMap = executedUpdatedMetadataForStoragePool.get(storagePoolId);
    Map<Guid, Long> storagePoolUpdateOvfGenerationsInDb = executedUpdatedOvfGenerationIdsInDb.get(storagePoolId);
    assertTrue("not all needed vms/templates were updated in vdsm", CollectionUtils.isEqualCollection(storagePoolMetadataUpdatedMap.keySet(), needToBeUpdated));
    assertTrue("not all needed vms/templates were updated in db", CollectionUtils.isEqualCollection(storagePoolUpdateOvfGenerationsInDb.keySet(), needToBeUpdated));
    for (Map.Entry<Guid, KeyValuePairCompat<String, List<Guid>>> entry : storagePoolMetadataUpdatedMap.entrySet()) {
        assertEquals("wrong ovf data stored in storage for vm/template", entry.getKey().toString(), entry.getValue().getKey());
    }
    for (Map.Entry<Guid, Long> guidLongEntry : storagePoolUpdateOvfGenerationsInDb.entrySet()) {
        boolean isCorrectVersion = false;
        if (vms.get(guidLongEntry.getKey()) != null) {
            isCorrectVersion = guidLongEntry.getValue().equals(vms.get(guidLongEntry.getKey()).getDbGeneration());
        } else if (templates.get(guidLongEntry.getKey()) != null) {
            isCorrectVersion = guidLongEntry.getValue().equals(templates.get(guidLongEntry.getKey()).getDbGeneration());
        }
        assertTrue("wrong new ovf version persisted for vm/template", isCorrectVersion);
    }
    assertTrue("not all needed vms/templates were removed from vdsm", CollectionUtils.isEqualCollection(removedGuids, executedRemovedIds.get(storagePoolId)));
}
#method_after
private void verifyCorrectOvfDataUpdaterRun(Guid storagePoolId, Collection<Guid> needToBeUpdated, Collection<Guid> removedGuids) {
    Map<Guid, KeyValuePairCompat<String, List<Guid>>> storagePoolMetadataUpdatedMap = executedUpdatedMetadataForStoragePool.get(storagePoolId);
    Map<Guid, Long> storagePoolUpdateOvfGenerationsInDb = executedUpdatedOvfGenerationIdsInDb.get(storagePoolId);
    assertTrue("not all needed vms/templates were updated in vdsm", CollectionUtils.isEqualCollection(storagePoolMetadataUpdatedMap.keySet(), needToBeUpdated));
    assertTrue("not all needed vms/templates were updated in db", CollectionUtils.isEqualCollection(storagePoolUpdateOvfGenerationsInDb.keySet(), needToBeUpdated));
    for (Map.Entry<Guid, KeyValuePairCompat<String, List<Guid>>> entry : storagePoolMetadataUpdatedMap.entrySet()) {
        assertEquals("wrong ovf data stored in storage for vm/template", entry.getKey().toString(), entry.getValue().getKey());
    }
    for (Map.Entry<Guid, Long> storagePoolGenerationEntry : storagePoolUpdateOvfGenerationsInDb.entrySet()) {
        boolean isCorrectVersion = false;
        if (vms.get(storagePoolGenerationEntry.getKey()) != null) {
            isCorrectVersion = storagePoolGenerationEntry.getValue().equals(vms.get(storagePoolGenerationEntry.getKey()).getDbGeneration());
        } else if (templates.get(storagePoolGenerationEntry.getKey()) != null) {
            isCorrectVersion = storagePoolGenerationEntry.getValue().equals(templates.get(storagePoolGenerationEntry.getKey()).getDbGeneration());
        }
        assertTrue("wrong new ovf version persisted for vm/template", isCorrectVersion);
    }
    assertTrue("not all needed vms/templates were removed from vdsm", CollectionUtils.isEqualCollection(removedGuids, executedRemovedIds.get(storagePoolId)));
}
#end_block

#method_before
void resolveChanges() {
    Set<Object> selectedKeys = selectedSet.keySet();
    List<Object> visibleKeys = new ArrayList<Object>();
    for (T visible : dataDisplay.getVisibleItems()) {
        visibleKeys.add(getKey(visible));
    }
    if (!visibleKeys.containsAll(selectedKeys)) {
        for (Map.Entry<Object, T> objectTEntry : selectedSet.entrySet()) {
            if (!visibleKeys.contains(objectTEntry.getKey()))
                selectionChanges.put(objectTEntry.getValue(), false);
        }
    }
    if (selectionChanges.isEmpty()) {
        return;
    }
    boolean changed = false;
    for (Map.Entry<T, Boolean> entry : selectionChanges.entrySet()) {
        T object = entry.getKey();
        boolean selected = entry.getValue();
        Object key = getKey(object);
        T oldValue = selectedSet.get(key);
        if (selected) {
            if (oldValue == null || !oldValue.equals(object)) {
                selectedSet.put(getKey(object), object);
                changed = true;
            }
        } else {
            if (oldValue != null) {
                selectedSet.remove(key);
                changed = true;
            }
        }
    }
    selectionChanges.clear();
    if (changed) {
        SelectionChangeEvent.fire(this);
    }
}
#method_after
void resolveChanges() {
    Set<Object> selectedKeys = selectedSet.keySet();
    List<Object> visibleKeys = new ArrayList<Object>();
    for (T visible : dataDisplay.getVisibleItems()) {
        visibleKeys.add(getKey(visible));
    }
    if (!visibleKeys.containsAll(selectedKeys)) {
        for (Map.Entry<Object, T> selectedEntry : selectedSet.entrySet()) {
            if (!visibleKeys.contains(selectedEntry.getKey())) {
                selectionChanges.put(selectedEntry.getValue(), false);
            }
        }
    }
    if (selectionChanges.isEmpty()) {
        return;
    }
    boolean changed = false;
    for (Map.Entry<T, Boolean> entry : selectionChanges.entrySet()) {
        T object = entry.getKey();
        boolean selected = entry.getValue();
        Object key = getKey(object);
        T oldValue = selectedSet.get(key);
        if (selected) {
            if (oldValue == null || !oldValue.equals(object)) {
                selectedSet.put(getKey(object), object);
                changed = true;
            }
        } else {
            if (oldValue != null) {
                selectedSet.remove(key);
                changed = true;
            }
        }
    }
    selectionChanges.clear();
    if (changed) {
        SelectionChangeEvent.fire(this);
    }
}
#end_block

#method_before
private boolean getItemOldState(Object userObject) {
    for (Map.Entry<Object, Boolean> objectBooleanEntry : oldItemStatesMap.entrySet()) {
        if (objectBooleanEntry.getKey() != null && userObject != null && objectBooleanEntry.getKey().equals(userObject)) {
            return objectBooleanEntry.getValue();
        }
    }
    return false;
}
#method_after
private boolean getItemOldState(Object userObject) {
    for (Map.Entry<Object, Boolean> oldItemStatesEntry : oldItemStatesMap.entrySet()) {
        if (oldItemStatesEntry.getKey() != null && userObject != null && oldItemStatesEntry.getKey().equals(userObject)) {
            return oldItemStatesEntry.getValue();
        }
    }
    return false;
}
#end_block

#method_before
public static void cancelTimer(String timerName) {
    for (Map.Entry<String, Timer> stringTimerEntry : timerList.entrySet()) {
        if (stringTimerEntry.getKey().equals(timerName)) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.fine("Cancelling the timer '" + stringTimerEntry.getKey() + "'");
            stringTimerEntry.getValue().cancel();
        }
    }
}
#method_after
public static void cancelTimer(String timerName) {
    for (Map.Entry<String, Timer> timerEntry : timerList.entrySet()) {
        if (timerEntry.getKey().equals(timerName)) {
            // $NON-NLS-1$ //$NON-NLS-2$
            logger.fine("Cancelling the timer '" + timerEntry.getKey() + "'");
            timerEntry.getValue().cancel();
        }
    }
}
#end_block

#method_before
// we get "Afghanistan Standard Time" we return "175"
// the "Afghanistan Standard Time" is the vm Key that we get from the method getTimezoneKey()
public static String getTimezoneIndexByKey(String key) {
    for (Map.Entry<String, Integer> stringIntegerEntry : timeZoneIndex.entrySet()) {
        if (getTimezoneKey(stringIntegerEntry.getKey()).equals(key)) {
            return stringIntegerEntry.getValue().toString();
        }
    }
    log.errorFormat("getTimezoneIndexByKey: cannot find timezone key '{0}'", key);
    return key;
}
#method_after
// we get "Afghanistan Standard Time" we return "175"
// the "Afghanistan Standard Time" is the vm Key that we get from the method getTimezoneKey()
public static String getTimezoneIndexByKey(String key) {
    for (Map.Entry<String, Integer> timeZoneEntry : timeZoneIndex.entrySet()) {
        if (getTimezoneKey(timeZoneEntry.getKey()).equals(key)) {
            return timeZoneEntry.getValue().toString();
        }
    }
    log.errorFormat("getTimezoneIndexByKey: cannot find timezone key '{0}'", key);
    return key;
}
#end_block

#method_before
private void checkIfDefaultStorageApplicableForAllDisks() {
    boolean isDefaultStorageApplicableForAllDisks = true;
    StorageDomain defaultStorage = (StorageDomain) getStorage().getSelectedItem();
    for (Entry<Guid, ImportDiskData> guidImportDiskDataEntry : diskImportDataMap.entrySet()) {
        ImportDiskData importData = guidImportDiskDataEntry.getValue();
        if (defaultStorage != null && !importData.getStorageDomains().contains(defaultStorage)) {
            isDefaultStorageApplicableForAllDisks = false;
            break;
        } else {
            importData.setSelectedStorageDomain(defaultStorage);
        }
    }
    if ((getMessage() == null || getMessage().isEmpty()) && !isDefaultStorageApplicableForAllDisks) {
        setMessage(ConstantsManager.getInstance().getConstants().importNotApplicableForDefaultStorage());
    }
}
#method_after
private void checkIfDefaultStorageApplicableForAllDisks() {
    boolean isDefaultStorageApplicableForAllDisks = true;
    StorageDomain defaultStorage = (StorageDomain) getStorage().getSelectedItem();
    for (ImportDiskData importData : diskImportDataMap.values()) {
        if (defaultStorage != null && !importData.getStorageDomains().contains(defaultStorage)) {
            isDefaultStorageApplicableForAllDisks = false;
            break;
        } else {
            importData.setSelectedStorageDomain(defaultStorage);
        }
    }
    if ((getMessage() == null || getMessage().isEmpty()) && !isDefaultStorageApplicableForAllDisks) {
        setMessage(ConstantsManager.getInstance().getConstants().importNotApplicableForDefaultStorage());
    }
}
#end_block

#method_before
protected void getTemplatesFromExportDomain() {
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePool.getId(), ((StorageDomain) getEntity()).getId());
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar, new AsyncQuery(ImportVmModel.this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<VmTemplate, List<DiskImage>> dictionary = (HashMap<VmTemplate, List<DiskImage>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            Map<Guid, Guid> tempMap = new HashMap<Guid, Guid>();
            for (Entry<VmTemplate, List<DiskImage>> entry : dictionary.entrySet()) {
                tempMap.put(entry.getKey().getId(), null);
            }
            for (Entry<Guid, List<Disk>> guidListEntry : missingTemplateDiskMap.entrySet()) {
                if (tempMap.containsKey(guidListEntry.getKey())) {
                    for (Disk disk : guidListEntry.getValue()) {
                        addDiskImportData(disk.getId(), filteredStorageDomains, ((DiskImage) disk).getVolumeType(), new EntityModel(true));
                    }
                } else {
                    showCloseMessage(ConstantsManager.getInstance().getConstants().errorTemplateCannotBeFoundMessage());
                    return;
                }
            }
            ImportVmModel.this.setMessage(ConstantsManager.getInstance().getConstants().importMissingStorages());
            for (ImportVmData vmData : (List<ImportVmData>) getItems()) {
                if (!Guid.Empty.equals(vmData.getVm().getVmtGuid()) && missingTemplateDiskMap.containsKey(vmData.getVm().getVmtGuid())) {
                    vmData.setTemplateExistsInSetup(false);
                }
            }
            postInitDisks();
        }
    }));
}
#method_after
protected void getTemplatesFromExportDomain() {
    GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(storagePool.getId(), ((StorageDomain) getEntity()).getId());
    Frontend.RunQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar, new AsyncQuery(ImportVmModel.this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            Map<VmTemplate, List<DiskImage>> dictionary = (HashMap<VmTemplate, List<DiskImage>>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            Map<Guid, Guid> tempMap = new HashMap<Guid, Guid>();
            for (Entry<VmTemplate, List<DiskImage>> entry : dictionary.entrySet()) {
                tempMap.put(entry.getKey().getId(), null);
            }
            for (Entry<Guid, List<Disk>> missingTemplateEntry : missingTemplateDiskMap.entrySet()) {
                if (tempMap.containsKey(missingTemplateEntry.getKey())) {
                    for (Disk disk : missingTemplateEntry.getValue()) {
                        addDiskImportData(disk.getId(), filteredStorageDomains, ((DiskImage) disk).getVolumeType(), new EntityModel(true));
                    }
                } else {
                    showCloseMessage(ConstantsManager.getInstance().getConstants().errorTemplateCannotBeFoundMessage());
                    return;
                }
            }
            ImportVmModel.this.setMessage(ConstantsManager.getInstance().getConstants().importMissingStorages());
            for (ImportVmData vmData : (List<ImportVmData>) getItems()) {
                if (!Guid.Empty.equals(vmData.getVm().getVmtGuid()) && missingTemplateDiskMap.containsKey(vmData.getVm().getVmtGuid())) {
                    vmData.setTemplateExistsInSetup(false);
                }
            }
            postInitDisks();
        }
    }));
}
#end_block

#method_before
private void saveNewConsumptionValues(Map<Guid, Quota> quotaMap, Map<Guid, Double> newUsedGlobalStorageSize, Map<Guid, Map<Guid, Double>> newUsedSpecificStorageSize) {
    // cache new storage size.
    for (Map.Entry<Guid, Double> entry : newUsedGlobalStorageSize.entrySet()) {
        Quota quota = quotaMap.get(entry.getKey());
        double value = entry.getValue();
        if (value < 0) {
            log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", entry.getKey());
            quotaMap.remove(entry.getKey());
            continue;
        }
        quota.getGlobalQuotaStorage().setStorageSizeGBUsage(value);
    }
    for (Map.Entry<Guid, Map<Guid, Double>> guidMapEntry : newUsedSpecificStorageSize.entrySet()) {
        Quota quota = quotaMap.get(guidMapEntry.getKey());
        for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
            if (guidMapEntry.getValue().containsKey(quotaStorage.getStorageId())) {
                double value = guidMapEntry.getValue().get(quotaStorage.getStorageId());
                if (value < 0) {
                    log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", guidMapEntry.getKey());
                    quotaMap.remove(guidMapEntry.getKey());
                    continue;
                }
                quotaStorage.setStorageSizeGBUsage(value);
            }
        }
    }
}
#method_after
private void saveNewConsumptionValues(Map<Guid, Quota> quotaMap, Map<Guid, Double> newUsedGlobalStorageSize, Map<Guid, Map<Guid, Double>> newUsedSpecificStorageSize) {
    // cache new storage size.
    for (Map.Entry<Guid, Double> entry : newUsedGlobalStorageSize.entrySet()) {
        Quota quota = quotaMap.get(entry.getKey());
        double value = entry.getValue();
        if (value < 0) {
            log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", entry.getKey());
            quotaMap.remove(entry.getKey());
            continue;
        }
        quota.getGlobalQuotaStorage().setStorageSizeGBUsage(value);
    }
    for (Map.Entry<Guid, Map<Guid, Double>> quotaStorageEntry : newUsedSpecificStorageSize.entrySet()) {
        Quota quota = quotaMap.get(quotaStorageEntry.getKey());
        for (QuotaStorage quotaStorage : quota.getQuotaStorages()) {
            if (quotaStorageEntry.getValue().containsKey(quotaStorage.getStorageId())) {
                double value = quotaStorageEntry.getValue().get(quotaStorage.getStorageId());
                if (value < 0) {
                    log.errorFormat("Quota id {0} cached storage size is negative, removing from cache", quotaStorageEntry.getKey());
                    quotaMap.remove(quotaStorageEntry.getKey());
                    continue;
                }
                quotaStorage.setStorageSizeGBUsage(value);
            }
        }
    }
}
#end_block

#method_before
@Override
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    boolean firstTime = true;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        value = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    }
    if ("=".equals(relations)) {
        relations = getLikeSyntax(caseSensitive);
    } else if ("!=".equals(relations)) {
        relations = "NOT " + getLikeSyntax(caseSensitive);
    }
    for (Map.Entry<String, String> stringStringEntry : columnNameDict.entrySet()) {
        if (typeDict.get(stringStringEntry.getKey()) == String.class && !notFreeTextSearchableFieldsList.contains(stringStringEntry.getKey())) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(" OR ");
            }
            sb.append(StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, stringStringEntry.getValue(), relations, value));
        }
    }
    sb.append(" ) ");
    return sb.toString();
}
#method_after
@Override
public final String buildFreeTextConditionSql(String tableName, String relations, String value, boolean caseSensitive) {
    StringBuilder sb = new StringBuilder(" ( ");
    boolean firstTime = true;
    if (!StringHelper.isNullOrEmpty(value) && !"''".equals(value)) {
        value = StringFormat.format(getI18NPrefix() + "'%%%1$s%%'", StringHelper.trim(value, '\''));
    }
    if ("=".equals(relations)) {
        relations = getLikeSyntax(caseSensitive);
    } else if ("!=".equals(relations)) {
        relations = "NOT " + getLikeSyntax(caseSensitive);
    }
    for (Map.Entry<String, String> columnNameEntry : columnNameDict.entrySet()) {
        if (typeDict.get(columnNameEntry.getKey()) == String.class && !notFreeTextSearchableFieldsList.contains(columnNameEntry.getKey())) {
            if (firstTime) {
                firstTime = false;
            } else {
                sb.append(" OR ");
            }
            sb.append(StringFormat.format(" %1$s.%2$s %3$s %4$s", tableName, columnNameEntry.getValue(), relations, value));
        }
    }
    sb.append(" ) ");
    return sb.toString();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Set parameters for messeging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        if (ObjectIdentityChecker.CanUpdateField(vm, "vdsGroupId", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
            Version clusterCompatibilityVersion = targetCluster.getcompatibility_version();
            if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), clusterCompatibilityVersion.getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    // Set parameters for messaging.
    addCanDoActionMessage(VdcBllMessages.VAR__ACTION__UPDATE);
    addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM__CLUSTER);
    VM vm = getVm();
    if (vm == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    } else {
        if (!canRunActionOnNonManagedVm()) {
            return false;
        }
        if (ObjectIdentityChecker.CanUpdateField(vm, "vdsGroupId", vm.getStatus())) {
            targetCluster = DbFacade.getInstance().getVdsGroupDao().get(getParameters().getClusterId());
            if (targetCluster == null) {
                addCanDoActionMessage(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
                return false;
            }
            // Check that the target cluster is in the same data center.
            if (!targetCluster.getStoragePoolId().equals(vm.getStoragePoolId())) {
                addCanDoActionMessage(VdcBllMessages.VM_CANNOT_MOVE_TO_CLUSTER_IN_OTHER_STORAGE_POOL);
                return false;
            }
            List<VmNic> interfaces = getVmNicDao().getAllForVm(getParameters().getVmId());
            Version clusterCompatibilityVersion = targetCluster.getcompatibility_version();
            if (!validateDestinationClusterContainsNetworks(interfaces) || !validateNics(interfaces, clusterCompatibilityVersion)) {
                return false;
            }
            // Check if VM static parameters are compatible for new cluster.
            boolean isCpuSocketsValid = AddVmCommand.checkCpuSockets(vm.getStaticData().getNumOfSockets(), vm.getStaticData().getCpuPerSocket(), clusterCompatibilityVersion.getValue(), getReturnValue().getCanDoActionMessages());
            if (!isCpuSocketsValid) {
                return false;
            }
            // Check that the USB policy is legal
            if (!VmHandler.isUsbPolicyLegal(vm.getUsbPolicy(), vm.getOs(), targetCluster, getReturnValue().getCanDoActionMessages())) {
                return false;
            }
        } else {
            addCanDoActionMessage(VdcBllMessages.VM_STATUS_NOT_VALID_FOR_UPDATE);
            return false;
        }
    }
    return true;
}
#end_block

#method_before
protected Guid findImageForSameDrive(Guid snapshotId) {
    List<DiskImage> imagesFromSanpshot = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotId);
    for (DiskImage diskImage : imagesFromSanpshot) {
        if (getDiskImage().getId().equals(diskImage.getId())) {
            return diskImage.getImageId();
        }
    }
    return null;
}
#method_after
protected Guid findImageForSameDrive(Guid snapshotId) {
    List<DiskImage> imagesFromSnapshot = getDiskImageDao().getAllSnapshotsForVmSnapshot(snapshotId);
    for (DiskImage diskImage : imagesFromSnapshot) {
        if (getDiskImage().getId().equals(diskImage.getId())) {
            return diskImage.getImageId();
        }
    }
    return null;
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null && Guid.Empty.equals(super.getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
    }
    if (!ImagesHandler.CheckImagesConfiguration(getStorageDomainId(), getParameters().getDiskInfoList(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return super.canDoAction();
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVdsGroup() == null && Guid.Empty.equals(super.getStorageDomainId())) {
        return failCanDoAction(VdcBllMessages.VM_CLUSTER_IS_NOT_VALID);
    }
    if (!ImagesHandler.checkImagesConfiguration(getStorageDomainId(), getParameters().getDiskInfoList(), getReturnValue().getCanDoActionMessages())) {
        return false;
    }
    return super.canDoAction();
}
#end_block

#method_before
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    Guid vmSnapshotId = Guid.newGuid();
    for (DiskImage diskImage : mImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = executeChildCommand(diskImage.getImageId());
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
    }
}
#method_after
protected void addVmTemplateImages(Map<Guid, Guid> srcDeviceIdToTargetDeviceIdMapping) {
    for (DiskImage diskImage : mImages) {
        // The return value of this action is the 'copyImage' task GUID:
        VdcReturnValueBase retValue = executeChildCommand(diskImage.getImageId());
        if (!retValue.getSucceeded()) {
            throw new VdcBLLException(retValue.getFault().getError(), retValue.getFault().getMessage());
        }
        getReturnValue().getVdsmTaskIdList().addAll(retValue.getInternalVdsmTaskIdList());
        DiskImage newImage = (DiskImage) retValue.getActionReturnValue();
        srcDeviceIdToTargetDeviceIdMapping.put(diskImage.getId(), newImage.getId());
    }
}
#end_block

#method_before
protected boolean checkImageConfiguration() {
    return ImagesHandler.CheckImageConfiguration(getStorageDomain().getStorageStaticData(), getDiskImageInfo(), getReturnValue().getCanDoActionMessages());
}
#method_after
protected boolean checkImageConfiguration() {
    return ImagesHandler.checkImageConfiguration(getStorageDomain().getStorageStaticData(), getDiskImageInfo(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
protected boolean updateVnicForBackwardCompatibility() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper();
    if (!validate(vnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), getVmTemplate(), getCurrentUser().getUserId()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean updateVnicForBackwardCompatibility() {
    if (!validate(VnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), getVmTemplate(), getCurrentUser().getUserId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected boolean updateVnicForBackwardCompatibility() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper();
    if (!validate(vnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), getVm().getStaticData(), getCurrentUser().getUserId()))) {
        return false;
    }
    return true;
}
#method_after
protected boolean updateVnicForBackwardCompatibility() {
    if (!validate(VnicProfileHelper.updateNicForBackwardCompatibility(getParameters().getInterface(), getVm().getStaticData(), getCurrentUser().getUserId()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
private boolean validateImageConfig(List<String> canDoActionMessages, Map<Guid, StorageDomain> domainsMap, DiskImage image) {
    return ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
}
#method_after
private boolean validateImageConfig(List<String> canDoActionMessages, Map<Guid, StorageDomain> domainsMap, DiskImage image) {
    return ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(image.getId())).getStorageStaticData(), image, canDoActionMessages);
}
#end_block

#method_before
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.CheckImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVdsCluster()) {
        return false;
    }
    Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
    if (!setDomainsForMemoryImages(domainMap)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
        if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#method_after
private boolean canDoActionAfterCloneVm(Map<Guid, StorageDomain> domainsMap) {
    VM vm = getParameters().getVm();
    // check that the imported vm guid is not in engine
    if (!validateNoDuplicateVm()) {
        return false;
    }
    if (!validateNoDuplicateDiskImages(imageList)) {
        return false;
    }
    if (!validateDiskInterface(imageList)) {
        return false;
    }
    setVmTemplateId(getVm().getVmtGuid());
    if (!templateExists() || !checkTemplateInStorageDomain() || !checkImagesGUIDsLegal() || !canAddVm()) {
        return false;
    }
    if (!VmTemplateHandler.BlankVmTemplateId.equals(getVm().getVmtGuid()) && getVmTemplate() != null && getVmTemplate().getStatus() == VmTemplateStatus.Locked) {
        return failCanDoAction(VdcBllMessages.VM_TEMPLATE_IMAGE_IS_LOCKED);
    }
    if (getParameters().getCopyCollapse() && vm.getDiskMap() != null) {
        for (Disk disk : vm.getDiskMap().values()) {
            if (disk.getDiskStorageType() == DiskStorageType.IMAGE) {
                DiskImage key = (DiskImage) getVm().getDiskMap().get(disk.getId());
                if (key != null) {
                    if (!ImagesHandler.checkImageConfiguration(domainsMap.get(imageToDestinationDomainMap.get(key.getId())).getStorageStaticData(), (DiskImageBase) disk, getReturnValue().getCanDoActionMessages())) {
                        return false;
                    }
                }
            }
        }
    }
    // (backup) domain
    if (getParameters().getCopyCollapse() && !isTemplateExistsOnExportDomain()) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_IMPORTED_TEMPLATE_IS_MISSING, String.format("$DomainName %1$s", getStorageDomainStaticDAO().get(getParameters().getSourceDomainId()).getStorageName()));
    }
    if (!validateVdsCluster()) {
        return false;
    }
    Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(imageList);
    if (!setDomainsForMemoryImages(domainMap)) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
        if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
            return false;
        }
    }
    if (!validateUsbPolicy()) {
        return false;
    }
    if (!validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVm().getInterfaces()))) {
        return false;
    }
    return true;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version());
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName(), getAuditLogTypeForInvalidInterfaces());
}
#method_after
protected void addVmInterfaces() {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVm().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_VM_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVm().getInterfaces()) {
        initInterface(iface);
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        vmInterfaceManager.add(iface, getCompensationContext(), getParameters().isImportAsNewEntity(), getVdsGroup().getcompatibility_version());
        macsAdded.add(iface.getMacAddress());
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmName());
}
#end_block

#method_before
protected void synchronizeNics(VM vm, CompensationContext compensationContext, Guid userId) {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getVdsGroupId(), vm.getStoragePoolId(), vm.getVdsGroupCompatibilityVersion());
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, userId);
        vmInterfaceManager.add(vmInterface, compensationContext, false, vm.getVdsGroupCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
}
#method_after
protected void synchronizeNics(VM vm, CompensationContext compensationContext, Guid userId) {
    VmInterfaceManager vmInterfaceManager = new VmInterfaceManager();
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(vm.getVdsGroupId(), vm.getStoragePoolId(), vm.getVdsGroupCompatibilityVersion(), AuditLogType.IMPORTEXPORT_SNAPSHOT_VM_INVALID_INTERFACES);
    vmInterfaceManager.removeAll(vm.getId());
    for (VmNetworkInterface vmInterface : vm.getInterfaces()) {
        vmInterface.setVmId(vm.getId());
        // These fields might not be saved in the OVF, so fill them with reasonable values.
        if (vmInterface.getId() == null) {
            vmInterface.setId(Guid.newGuid());
        }
        vnicProfileHelper.updateNicWithVnicProfileForUser(vmInterface, userId);
        vmInterfaceManager.add(vmInterface, compensationContext, false, vm.getVdsGroupCompatibilityVersion());
    }
    vnicProfileHelper.auditInvalidInterfaces(vm.getName());
}
#end_block

#method_before
private boolean updateNicWithVnicProfile(VmNetworkInterface iface, Guid userId) {
    if (iface.getNetworkName() == null) {
        if (FeatureSupported.networkLinking(compatibilityVersion)) {
            iface.setVnicProfileId(null);
            return true;
        } else {
            return false;
        }
    }
    Network network = networksInClusterByName.get(iface.getNetworkName());
    if (network == null || !network.isVmNetwork()) {
        return false;
    }
    VnicProfile vnicProfile = getVnicProfileForNetwork(vnicProfilesInDc, network, iface.getVnicProfileName());
    if (vnicProfile == null) {
        vnicProfile = findVnicProfileForUser(userId, network);
        if (vnicProfile == null) {
            return false;
        }
    }
    iface.setVnicProfileId(vnicProfile.getId());
    return true;
}
#method_after
private boolean updateNicWithVnicProfile(VmNetworkInterface iface, Guid userId) {
    if (iface.getNetworkName() == null) {
        if (FeatureSupported.networkLinking(compatibilityVersion)) {
            iface.setVnicProfileId(null);
            return true;
        } else {
            return false;
        }
    }
    Network network = getNetworksInCluster().get(iface.getNetworkName());
    if (network == null || !network.isVmNetwork()) {
        return false;
    }
    VnicProfile vnicProfile = getVnicProfileForNetwork(network, iface.getVnicProfileName());
    if (vnicProfile == null) {
        vnicProfile = findVnicProfileForUser(userId, network);
        if (vnicProfile == null) {
            return false;
        }
    }
    iface.setVnicProfileId(vnicProfile.getId());
    return true;
}
#end_block

#method_before
private VnicProfile getVnicProfileForNetwork(List<VnicProfileView> vnicProfiles, Network network, String vnicProfileName) {
    if (vnicProfileName == null) {
        return null;
    }
    for (VnicProfileView vnicProfile : vnicProfiles) {
        if (ObjectUtils.equals(vnicProfile.getNetworkId(), network.getId()) && vnicProfileName.equals(vnicProfile.getName())) {
            return vnicProfile;
        }
    }
    return null;
}
#method_after
private VnicProfile getVnicProfileForNetwork(Network network, String vnicProfileName) {
    if (vnicProfileName == null) {
        return null;
    }
    for (VnicProfileView vnicProfile : getVnicProfilesInDc()) {
        if (ObjectUtils.equals(vnicProfile.getNetworkId(), network.getId()) && vnicProfileName.equals(vnicProfile.getName())) {
            return vnicProfile;
        }
    }
    return null;
}
#end_block

#method_before
private boolean isVnicProfilePermitted(Guid userId, VnicProfile profile, boolean portMirroringRequired) {
    return portMirroringRequired == profile.isPortMirroring() && getPermissionDAO().getEntityPermissions(userId, ActionGroup.CONFIGURE_VM_NETWORK, profile.getId(), VdcObjectType.VnicProfile) != null;
}
#method_after
private static boolean isVnicProfilePermitted(Guid userId, VnicProfile profile, boolean portMirroringRequired) {
    return portMirroringRequired == profile.isPortMirroring() && getPermissionDAO().getEntityPermissions(userId, ActionGroup.CONFIGURE_VM_NETWORK, profile.getId(), VdcObjectType.VnicProfile) != null;
}
#end_block

#method_before
public void auditInvalidInterfaces(String entityName, AuditLogType logType) {
    if (!invalidNetworkNames.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue("EntityName", entityName);
        logable.addCustomValue("Networks", StringUtils.join(invalidNetworkNames, ','));
        logable.addCustomValue("Interfaces", StringUtils.join(invalidIfaceNames, ','));
        AuditLogDirector.log(logable, logType);
    }
}
#method_after
public void auditInvalidInterfaces(String entityName) {
    if (!invalidNetworkNames.isEmpty()) {
        AuditLogableBase logable = new AuditLogableBase();
        logable.addCustomValue("EntityName", entityName);
        logable.addCustomValue("Networks", StringUtils.join(invalidNetworkNames, ','));
        logable.addCustomValue("Interfaces", StringUtils.join(invalidIfaceNames, ','));
        AuditLogDirector.log(logable, logType);
    }
}
#end_block

#method_before
public ValidationResult updateNicForBackwardCompatibility(VmNetworkInterface nic, VmBase vm, Guid userId) {
    if (nic.getVnicProfileId() != null) {
        return ValidationResult.VALID;
    }
    if (nic.getNetworkName() == null) {
        if (nic.isPortMirroring()) {
            return new ValidationResult(VdcBllMessages.PORT_MIRRORING_REQUIRES_NETWORK);
        } else {
            return ValidationResult.VALID;
        }
    }
    Network network = getNetworkDao().getByNameAndCluster(nic.getNetworkName(), vm.getVdsGroupId());
    if (network == null) {
        return new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CLUSTER);
    }
    List<VnicProfile> vnicProfiles = getVnicProfileDao().getAllForNetwork(network.getId());
    for (VnicProfile profile : vnicProfiles) {
        if (isVnicProfilePermitted(userId, profile, nic.isPortMirroring())) {
            nic.setVnicProfileId(profile.getId());
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_FIND_VNIC_PROFILE_FOR_NETWORK);
}
#method_after
public static ValidationResult updateNicForBackwardCompatibility(VmNetworkInterface nic, VmBase vm, Guid userId) {
    if (nic.getVnicProfileId() != null) {
        return ValidationResult.VALID;
    }
    if (nic.getNetworkName() == null) {
        if (nic.isPortMirroring()) {
            return new ValidationResult(VdcBllMessages.PORT_MIRRORING_REQUIRES_NETWORK);
        } else {
            return ValidationResult.VALID;
        }
    }
    Network network = getNetworkDao().getByNameAndCluster(nic.getNetworkName(), vm.getVdsGroupId());
    if (network == null) {
        return new ValidationResult(VdcBllMessages.NETWORK_NOT_EXISTS_IN_CLUSTER);
    }
    List<VnicProfile> vnicProfiles = getVnicProfileDao().getAllForNetwork(network.getId());
    for (VnicProfile profile : vnicProfiles) {
        if (isVnicProfilePermitted(userId, profile, nic.isPortMirroring())) {
            nic.setVnicProfileId(profile.getId());
            return ValidationResult.VALID;
        }
    }
    return new ValidationResult(VdcBllMessages.ACTION_TYPE_FAILED_CANNOT_FIND_VNIC_PROFILE_FOR_NETWORK);
}
#end_block

#method_before
private NetworkDao getNetworkDao() {
    return DbFacade.getInstance().getNetworkDao();
}
#method_after
private static NetworkDao getNetworkDao() {
    return DbFacade.getInstance().getNetworkDao();
}
#end_block

#method_before
private VnicProfileDao getVnicProfileDao() {
    return DbFacade.getInstance().getVnicProfileDao();
}
#method_after
private static VnicProfileDao getVnicProfileDao() {
    return DbFacade.getInstance().getVnicProfileDao();
}
#end_block

#method_before
private PermissionDAO getPermissionDAO() {
    return DbFacade.getInstance().getPermissionDao();
}
#method_after
private static PermissionDAO getPermissionDAO() {
    return DbFacade.getInstance().getPermissionDao();
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = validate(sourceDomainValidator.isDomainExistAndActive());
    }
    if (retVal && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            ArrayList<DiskImage> images = new ArrayList<DiskImage>();
            for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
                if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                    images = new ArrayList<DiskImage>(entry.getValue());
                    getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                    getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                    break;
                }
            }
            getParameters().setImages(images);
            getVmTemplate().setImages(images);
            ensureDomainMap(getParameters().getImages(), getParameters().getDestDomainId());
            HashMap<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : images) {
                if (Guid.Empty.equals(image.getVmSnapshotId())) {
                    retVal = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
                    break;
                }
                StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
                retVal = ImagesHandler.CheckImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setStoragePoolId(getParameters().getStoragePoolId());
                    image.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomain.getId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getName()));
            retVal = false;
        } else if (isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal) {
        retVal = validateNoDuplicateDiskImages(getParameters().getImages());
    }
    if (retVal && getParameters().getImages() != null && !getParameters().getImages().isEmpty()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getSize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVmTemplate().getInterfaces()));
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#method_after
@Override
protected boolean canDoAction() {
    boolean retVal = true;
    if (getVmTemplate() == null) {
        retVal = false;
    } else {
        setDescription(getVmTemplateName());
    }
    // check that the storage pool is valid
    retVal = retVal && checkStoragePool();
    if (retVal) {
        // set the source domain and check that it is ImportExport type and active
        setSourceDomainId(getParameters().getSourceDomainId());
        StorageDomainValidator sourceDomainValidator = new StorageDomainValidator(getSourceDomain());
        retVal = validate(sourceDomainValidator.isDomainExistAndActive());
    }
    if (retVal && getSourceDomain().getStorageDomainType() != StorageDomainType.ImportExport) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_STORAGE_DOMAIN_TYPE_ILLEGAL);
        retVal = false;
    }
    if (retVal) {
        // Set the template images from the Export domain and change each image id storage is to the import domain
        GetAllFromExportDomainQueryParameters tempVar = new GetAllFromExportDomainQueryParameters(getParameters().getStoragePoolId(), getParameters().getSourceDomainId());
        VdcQueryReturnValue qretVal = getBackend().runInternalQuery(VdcQueryType.GetTemplatesFromExportDomain, tempVar);
        retVal = qretVal.getSucceeded();
        if (retVal) {
            Map<VmTemplate, List<DiskImage>> templates = qretVal.getReturnValue();
            ArrayList<DiskImage> images = new ArrayList<DiskImage>();
            for (Map.Entry<VmTemplate, List<DiskImage>> entry : templates.entrySet()) {
                if (entry.getKey().getId().equals(getVmTemplate().getId())) {
                    images = new ArrayList<DiskImage>(entry.getValue());
                    getVmTemplate().setInterfaces(entry.getKey().getInterfaces());
                    getVmTemplate().setOvfVersion(entry.getKey().getOvfVersion());
                    break;
                }
            }
            getParameters().setImages(images);
            getVmTemplate().setImages(images);
            ensureDomainMap(getParameters().getImages(), getParameters().getDestDomainId());
            HashMap<Guid, DiskImage> imageMap = new HashMap<Guid, DiskImage>();
            for (DiskImage image : images) {
                if (Guid.Empty.equals(image.getVmSnapshotId())) {
                    retVal = failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_CORRUPTED_VM_SNAPSHOT_ID);
                    break;
                }
                StorageDomain storageDomain = getStorageDomain(imageToDestinationDomainMap.get(image.getId()));
                StorageDomainValidator validator = new StorageDomainValidator(storageDomain);
                retVal = validate(validator.isDomainExistAndActive()) && validate(validator.domainIsValidDestination());
                if (!retVal) {
                    break;
                }
                StorageDomainStatic targetDomain = storageDomain.getStorageStaticData();
                changeRawToCowIfSparseOnBlockDevice(targetDomain.getStorageType(), image);
                retVal = ImagesHandler.checkImageConfiguration(targetDomain, image, getReturnValue().getCanDoActionMessages());
                if (!retVal) {
                    break;
                } else {
                    image.setStoragePoolId(getParameters().getStoragePoolId());
                    image.setStorageIds(new ArrayList<Guid>(Arrays.asList(storageDomain.getId())));
                    imageMap.put(image.getImageId(), image);
                }
            }
            getVmTemplate().setDiskImageMap(imageMap);
        }
    }
    if (retVal && getParameters().isImportAsNewEntity()) {
        initImportClonedTemplate();
    }
    if (retVal) {
        VmTemplate duplicateTemplate = getVmTemplateDAO().get(getParameters().getVmTemplate().getId());
        // check that the template does not exists in the target domain
        if (duplicateTemplate != null) {
            addCanDoActionMessage(VdcBllMessages.VMT_CANNOT_IMPORT_TEMPLATE_EXISTS);
            getReturnValue().getCanDoActionMessages().add(String.format("$TemplateName %1$s", duplicateTemplate.getName()));
            retVal = false;
        } else if (isVmTemplateWithSameNameExist()) {
            addCanDoActionMessage(VdcBllMessages.VM_CANNOT_IMPORT_TEMPLATE_NAME_EXISTS);
            retVal = false;
        }
    }
    if (retVal) {
        retVal = validateNoDuplicateDiskImages(getParameters().getImages());
    }
    if (retVal && getParameters().getImages() != null && !getParameters().getImages().isEmpty()) {
        Map<StorageDomain, Integer> domainMap = getSpaceRequirementsForStorageDomains(new ArrayList<DiskImage>(getVmTemplate().getDiskImageMap().values()));
        if (domainMap.isEmpty()) {
            int sz = 0;
            if (getVmTemplate().getDiskImageMap() != null) {
                for (DiskImage image : getVmTemplate().getDiskImageMap().values()) {
                    sz += image.getSize();
                }
            }
            domainMap.put(getStorageDomain(), sz);
        }
        for (Map.Entry<StorageDomain, Integer> entry : domainMap.entrySet()) {
            if (!doesStorageDomainhaveSpaceForRequest(entry.getKey(), entry.getValue())) {
                return false;
            }
        }
    }
    if (retVal) {
        retVal = validateMacAddress(Entities.<VmNic, VmNetworkInterface>upcast(getVmTemplate().getInterfaces()));
    }
    if (!retVal) {
        addCanDoActionMessage(VdcBllMessages.VAR__ACTION__IMPORT);
        addCanDoActionMessage(VdcBllMessages.VAR__TYPE__VM_TEMPLATE);
    }
    return retVal;
}
#end_block

#method_before
protected void addVmInterfaces() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVmTemplate().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version());
    for (VmNetworkInterface iface : getVmTemplate().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.newGuid());
        }
        iface.setVmId(getVmTemplateId());
        VmNic nic = new VmNic();
        nic.setId(iface.getId());
        nic.setVmTemplateId(getVmTemplateId());
        nic.setName(iface.getName());
        nic.setLinked(iface.isLinked());
        nic.setSpeed(iface.getSpeed());
        nic.setType(iface.getType());
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        nic.setVnicProfileId(iface.getVnicProfileId());
        getVmNicDao().save(nic);
        getCompensationContext().snapshotNewEntity(nic);
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        nic.setStatistics(iStat);
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        getDbFacade().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmTemplateName(), getAuditLogTypeForInvalidInterfaces());
}
#method_after
protected void addVmInterfaces() {
    VnicProfileHelper vnicProfileHelper = new VnicProfileHelper(getVmTemplate().getVdsGroupId(), getStoragePoolId(), getVdsGroup().getcompatibility_version(), AuditLogType.IMPORTEXPORT_IMPORT_TEMPLATE_INVALID_INTERFACES);
    for (VmNetworkInterface iface : getVmTemplate().getInterfaces()) {
        if (iface.getId() == null) {
            iface.setId(Guid.newGuid());
        }
        iface.setVmId(getVmTemplateId());
        VmNic nic = new VmNic();
        nic.setId(iface.getId());
        nic.setVmTemplateId(getVmTemplateId());
        nic.setName(iface.getName());
        nic.setLinked(iface.isLinked());
        nic.setSpeed(iface.getSpeed());
        nic.setType(iface.getType());
        vnicProfileHelper.updateNicWithVnicProfileForUser(iface, getCurrentUser().getUserId());
        nic.setVnicProfileId(iface.getVnicProfileId());
        getVmNicDao().save(nic);
        getCompensationContext().snapshotNewEntity(nic);
        VmNetworkStatistics iStat = new VmNetworkStatistics();
        nic.setStatistics(iStat);
        iStat.setId(iface.getId());
        iStat.setVmId(getVmTemplateId());
        getDbFacade().getVmNetworkStatisticsDao().save(iStat);
        getCompensationContext().snapshotNewEntity(iStat);
    }
    vnicProfileHelper.auditInvalidInterfaces(getVmTemplateName());
}
#end_block

#method_before
@Override
public VdcReturnValueBase endAction() {
    VdcReturnValueBase vdcReturnValueBase = super.endAction();
    freeLock();
    return vdcReturnValueBase;
}
#method_after
@Override
public VdcReturnValueBase endAction() {
    try {
        return super.endAction();
    } finally {
        freeLock();
    }
}
#end_block

#method_before
private void freeLockExecute() {
    if (releaseLocksAtEndOfExecute || !getSucceeded() || !hasTasks()) {
        freeLock();
    }
}
#method_after
private void freeLockExecute() {
    if (releaseLocksAtEndOfExecute || !getSucceeded() || (!hasTasks() && !(this instanceof IVdsAsyncCommand))) {
        freeLock();
    }
}
#end_block

#method_before
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (readOnly ? 1231 : 1237);
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((appMode == null) ? ApplicationMode.VirtOnly.getValue() : appMode.getValue());
    return result;
}
#method_after
@Override
public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((id == null) ? 0 : id.hashCode());
    result = prime * result + ((description == null) ? 0 : description.hashCode());
    result = prime * result + (readOnly ? 1231 : 1237);
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    result = prime * result + ((type == null) ? 0 : type.hashCode());
    result = prime * result + ((appMode == null) ? 0 : appMode.getValue());
    return result;
}
#end_block

#method_before
private String getDiskIsBeingMigratedMessage() {
    if (cachedDiskIsBeingMigratedMessage == null) {
        StringBuilder builder = new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_BEING_MIGRATED.name());
        if (getImage() != null) {
            builder.append(String.format("$DiskName %1$s", getDiskAlias()));
        }
        builder.append(String.format("$OperationType %1$s", ImageOperation.Move == getParameters().getOperation() ? "moved" : "copied"));
        cachedDiskIsBeingMigratedMessage = builder.toString();
    }
    return cachedDiskIsBeingMigratedMessage;
}
#method_after
private String getDiskIsBeingMigratedMessage() {
    if (cachedDiskIsBeingMigratedMessage == null) {
        StringBuilder builder = new StringBuilder(VdcBllMessages.ACTION_TYPE_FAILED_DISK_IS_BEING_MIGRATED.name());
        if (getImage() != null) {
            builder.append(String.format("$DiskName %1$s", getDiskAlias()));
        }
        cachedDiskIsBeingMigratedMessage = builder.toString();
    }
    return cachedDiskIsBeingMigratedMessage;
}
#end_block

#method_before
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setInfo(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster) {
        clusterModel.getName().setIsChangable(false);
        // $NON-NLS-1$
        clusterModel.getName().setInfo("Cannot edit Cluster's Name in tree context");
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#method_after
public void edit() {
    final VDSGroup cluster = (VDSGroup) getSelectedItem();
    if (getWindow() != null) {
        return;
    }
    final UIConstants constants = ConstantsManager.getInstance().getConstants();
    final ClusterModel clusterModel = new ClusterModel();
    clusterModel.setEntity(cluster);
    clusterModel.init(true);
    clusterModel.getEnableTrustedService().setEntity(cluster.supportsTrustedService());
    setWindow(clusterModel);
    clusterModel.setTitle(ConstantsManager.getInstance().getConstants().editClusterTitle());
    // $NON-NLS-1$
    clusterModel.setHashName("edit_cluster");
    clusterModel.setOriginalName(cluster.getName());
    clusterModel.getName().setEntity(cluster.getName());
    clusterModel.getEnableOvirtService().setEntity(cluster.supportsVirtService());
    clusterModel.getEnableOvirtService().setIsChangable(true);
    clusterModel.getEnableGlusterService().setEntity(cluster.supportsGlusterService());
    clusterModel.getEnableGlusterService().setIsChangable(true);
    clusterModel.getEnableBallooning().setEntity(cluster.isEnableBallooning());
    if (cluster.supportsTrustedService()) {
        clusterModel.getEnableGlusterService().setIsChangable(false);
    }
    if (cluster.supportsVirtService() && !cluster.supportsGlusterService()) {
        clusterModel.getEnableTrustedService().setIsChangable(true);
    } else {
        clusterModel.getEnableTrustedService().setIsChangable(false);
    }
    AsyncDataProvider.getAllowClusterWithVirtGlusterEnabled(new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            final boolean isVirtGlusterAllowed = (Boolean) returnValue;
            AsyncQuery asyncQuery = new AsyncQuery();
            asyncQuery.setModel(clusterModel);
            asyncQuery.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<GlusterVolumeEntity> volumes = (ArrayList<GlusterVolumeEntity>) result;
                    if (volumes.size() > 0) {
                        clusterModel.getEnableGlusterService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableOvirtService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVolumeList(asyncQuery, cluster.getName());
            AsyncQuery asyncQuery1 = new AsyncQuery();
            asyncQuery1.setModel(clusterModel);
            asyncQuery1.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VM> vmList = (ArrayList<VM>) result;
                    if (vmList.size() > 0) {
                        clusterModel.getEnableOvirtService().setIsChangable(false);
                        if (!isVirtGlusterAllowed) {
                            clusterModel.getEnableGlusterService().setIsChangable(false);
                        }
                    }
                }
            };
            AsyncDataProvider.getVmListByClusterName(asyncQuery1, cluster.getName());
            AsyncQuery asyncQuery2 = new AsyncQuery();
            asyncQuery2.setModel(clusterModel);
            asyncQuery2.asyncCallback = new INewAsyncCallback() {

                @Override
                public void onSuccess(Object model1, Object result) {
                    ArrayList<VDS> vdsList = (ArrayList<VDS>) result;
                    if (vdsList.size() > 0) {
                        clusterModel.getEnableTrustedService().setIsChangable(false);
                        clusterModel.getEnableTrustedService().setChangeProhibitionReason(ConstantsManager.getInstance().getConstants().trustedServiceDisabled());
                    }
                }
            };
            AsyncDataProvider.getHostListByCluster(asyncQuery2, cluster.getName());
        }
    }));
    if (getSystemTreeSelectedItem() != null && (getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster || getSystemTreeSelectedItem().getType() == SystemTreeItemType.Cluster_Gluster)) {
        clusterModel.getName().setIsChangable(false);
        clusterModel.getName().setChangeProhibitionReason(constants.cannotEditNameInTreeContext());
    }
    // $NON-NLS-1$
    UICommand tempVar = new UICommand("OnSave", this);
    tempVar.setTitle(ConstantsManager.getInstance().getConstants().ok());
    tempVar.setIsDefault(true);
    clusterModel.getCommands().add(tempVar);
    // $NON-NLS-1$
    UICommand tempVar2 = new UICommand("Cancel", this);
    tempVar2.setTitle(ConstantsManager.getInstance().getConstants().cancel());
    tempVar2.setIsCancel(true);
    clusterModel.getCommands().add(tempVar2);
}
#end_block

#method_before
@SuppressWarnings("unchecked")
private void checkForNonResponsiveHosts(final ConfirmationModel confirmModel) {
    startProgress(null);
    Frontend.RunQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(((VDSGroup) getSelectedItem()).getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel model = (ClusterListModel) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            } else {
                // $NON-NLS-1$
                throw new IllegalArgumentException("The return value should be ArrayList<VDS> or VdcQueryReturnValue with return value ArrayList<VDS>");
            }
            boolean result = false;
            for (VDS host : hosts) {
                if (VDSStatus.NonResponsive == host.getStatus()) {
                    result = true;
                    break;
                }
            }
            if (result) {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionNonResponsiveHostsMsg());
            } else {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
            }
            model.stopProgress();
        }
    }));
}
#method_after
@SuppressWarnings("unchecked")
private void checkForNonResponsiveHosts(final ConfirmationModel confirmModel) {
    startProgress(null);
    Frontend.RunQuery(VdcQueryType.GetHostsByClusterId, new IdQueryParameters(((VDSGroup) getSelectedItem()).getId()), new AsyncQuery(this, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object target, Object returnValue) {
            ClusterListModel model = (ClusterListModel) target;
            ArrayList<VDS> hosts = null;
            if (returnValue instanceof ArrayList) {
                hosts = (ArrayList<VDS>) returnValue;
            } else if (returnValue instanceof VdcQueryReturnValue && ((VdcQueryReturnValue) returnValue).getReturnValue() instanceof ArrayList) {
                hosts = (ArrayList<VDS>) ((VdcQueryReturnValue) returnValue).getReturnValue();
            }
            boolean foundNRHosts = false;
            if (hosts != null) {
                for (VDS host : hosts) {
                    if (VDSStatus.NonResponsive == host.getStatus()) {
                        foundNRHosts = true;
                        break;
                    }
                }
            }
            if (foundNRHosts) {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionNonResponsiveHostsMsg());
            } else {
                confirmModel.setMessage(ConstantsManager.getInstance().getConstants().youAreAboutChangeClusterCompatibilityVersionMsg());
            }
            model.stopProgress();
        }
    }));
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    ArrayList<String> canDoActionMessages = getReturnValue().getCanDoActionMessages();
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && acquireLockInternal() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration(canDoActionMessages) && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#method_after
@Override
protected boolean canDoAction() {
    return isImageExist() && checkOperationIsCorrect() && canFindVmOrTemplate() && acquireLockInternal() && isImageNotLocked() && isSourceAndDestTheSame() && validateSourceStorageDomain() && validateDestStorage() && checkTemplateInDestStorageDomain() && validateSpaceRequirements() && checkImageConfiguration() && checkCanBeMoveInVm() && checkIfNeedToBeOverride();
}
#end_block

#method_before
protected boolean checkImageConfiguration(List<String> canDoActionMessages) {
    return ImagesHandler.CheckImageConfiguration(getStorageDomain().getStorageStaticData(), getImage(), canDoActionMessages);
}
#method_after
protected boolean checkImageConfiguration() {
    return ImagesHandler.CheckImageConfiguration(getStorageDomain().getStorageStaticData(), getImage(), getReturnValue().getCanDoActionMessages());
}
#end_block

#method_before
private List<VM> getVmsForDiskId() {
    if (listVms == null) {
        listVms = getVmDAO().getVmsListForDisk(getImage().getId());
    }
    return listVms;
}
#method_after
private List<VM> getVmsForDiskId() {
    if (cachedListVms == null) {
        cachedListVms = getVmDAO().getVmsListForDisk(getImage().getId());
    }
    return cachedListVms;
}
#end_block

#method_before
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (permsList == null) {
        permsList = new ArrayList<PermissionSubject>();
        DiskImage image = getImage();
        Guid diskId = image == null ? Guid.Empty : image.getId();
        permsList.add(new PermissionSubject(diskId, VdcObjectType.Disk, ActionGroup.CONFIGURE_DISK_STORAGE));
        permsList.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return permsList;
}
#method_after
@Override
public List<PermissionSubject> getPermissionCheckSubjects() {
    if (cachedPermsList == null) {
        cachedPermsList = new ArrayList<PermissionSubject>();
        DiskImage image = getImage();
        Guid diskId = image == null ? Guid.Empty : image.getId();
        cachedPermsList.add(new PermissionSubject(diskId, VdcObjectType.Disk, ActionGroup.CONFIGURE_DISK_STORAGE));
        cachedPermsList.add(new PermissionSubject(getParameters().getStorageDomainId(), VdcObjectType.Storage, ActionGroup.CREATE_DISK));
    }
    return cachedPermsList;
}
#end_block

#method_before
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            final boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            if (taskGroupSucceeded) {
                if (createdSnapshot != null) {
                    getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
                    if (isLiveSnapshotApplicable()) {
                        performLiveSnapshot(createdSnapshot);
                    } else {
                        // they are not in use since no live snapshot was created
                        if (!createdSnapshot.getMemoryVolume().isEmpty()) {
                            logMemorySavingFailed();
                            if (!removeMemoryFromSnapshot(createdSnapshot, true)) {
                                log.errorFormat("Failed to remove unused memory {0} of snapshot {1}", createdSnapshot.getMemoryVolume(), createdSnapshot.getId());
                            }
                        }
                    }
                } else {
                    log.warnFormat("No snapshot was found for VM {0} which is in LOCKED status command will be failed", getVmId());
                }
            } else {
                if (createdSnapshot != null) {
                    revertToActiveSnapshot(createdSnapshot.getId());
                    // Note that the memory volumes might not have been created
                    if (!removeMemoryFromSnapshot(createdSnapshot, false)) {
                        log.warnFormat("Failed to remove memory {0} of snapshot {1}", createdSnapshot.getMemoryVolume(), createdSnapshot.getId());
                    }
                } else {
                    log.warnFormat("No snapshot was created for VM {0} which is in LOCKED status", getVmId());
                }
            }
            incrementVmGeneration();
            endActionOnDisks();
            setSucceeded(createdSnapshot == null ? false : taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#method_after
@Override
protected void endVmCommand() {
    // The following code must be executed in an inner transaction to make the changes visible
    // to the RunVm command that might occur afterwards
    TransactionSupport.executeInNewTransaction(new TransactionMethod<Void>() {

        @Override
        public Void runInTransaction() {
            boolean taskGroupSucceeded = getParameters().getTaskGroupSuccess();
            Snapshot createdSnapshot = getSnapshotDao().get(getVmId(), getParameters().getSnapshotType(), SnapshotStatus.LOCKED);
            // handled as a failure
            if (createdSnapshot == null) {
                taskGroupSucceeded = false;
            }
            if (taskGroupSucceeded) {
                getSnapshotDao().updateStatus(createdSnapshot.getId(), SnapshotStatus.OK);
                if (isLiveSnapshotApplicable()) {
                    performLiveSnapshot(createdSnapshot);
                } else {
                    // they are not in use since no live snapshot was created
                    if (!createdSnapshot.getMemoryVolume().isEmpty()) {
                        logMemorySavingFailed();
                        if (!removeMemoryFromSnapshot(createdSnapshot, true)) {
                            log.errorFormat("Failed to remove unused memory {0} of snapshot {1}", createdSnapshot.getMemoryVolume(), createdSnapshot.getId());
                        }
                    }
                }
            } else {
                if (createdSnapshot != null) {
                    revertToActiveSnapshot(createdSnapshot.getId());
                    // Note that the memory volumes might not have been created
                    if (!removeMemoryFromSnapshot(createdSnapshot, false)) {
                        log.warnFormat("Failed to remove memory {0} of snapshot {1}", createdSnapshot.getMemoryVolume(), createdSnapshot.getId());
                    }
                } else {
                    log.warnFormat("No snapshot was created for VM {0} which is in LOCKED status", getVmId());
                }
            }
            incrementVmGeneration();
            endActionOnDisks();
            setSucceeded(taskGroupSucceeded);
            getReturnValue().setEndActionTryAgain(false);
            return null;
        }
    });
    // (during the snapshot creation process the VM couldn't be started (rerun))
    if (getVm() != null && getVm().isAutoStartup() && isVmDownUnintentionally() && getParameters().getInitialVmStatus() != VMStatus.Down) {
        Backend.getInstance().runInternalAction(VdcActionType.RunVm, new RunVmParams(getVmId()), ExecutionHandler.createInternalJobContext());
    }
}
#end_block

#method_before
private boolean isLiveSnapshotApplicable() {
    return getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && getVm().isRunning() && getVm().getRunOnVds() != null;
}
#method_after
private boolean isLiveSnapshotApplicable() {
    return getParameters().getParentCommand() != VdcActionType.RunVm && getVm() != null && (getVm().isRunning() || getVm().getStatus() == VMStatus.Paused) && getVm().getRunOnVds() != null;
}
#end_block

#method_before
private void handleVdsLiveSnapshotFailure(VdcBLLException e) {
    log.warnFormat("Wasn't able to live snpashot due to error: {0}. VM will still be configured to the new created snapshot", ExceptionUtils.getMessage(e));
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    AuditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#method_after
private void handleVdsLiveSnapshotFailure(VdcBLLException e) {
    log.warnFormat("Wasn't able to live snapshot due to error: {0}. VM will still be configured to the new created snapshot", ExceptionUtils.getMessage(e));
    addCustomValue("SnapshotName", getSnapshotName());
    addCustomValue("VmName", getVmName());
    updateCallStackFromThrowable(e);
    AuditLogDirector.log(this, AuditLogType.USER_CREATE_LIVE_SNAPSHOT_FINISHED_FAILURE);
}
#end_block

#method_before
@Override
protected boolean canDoAction() {
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(disksList);
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(sdValidator.allDomainsExistAndActive()) && validate(sdValidator.allDomainsWithinThresholds()))) {
            return false;
        }
    }
    if (getParameters().isSaveMemory() && Guid.Empty.equals(getStorageDomainIdForVmMemory())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#method_after
@Override
protected boolean canDoAction() {
    if (getVm() == null) {
        addCanDoActionMessage(VdcBllMessages.ACTION_TYPE_FAILED_VM_NOT_EXIST);
        return false;
    }
    if (!canRunActionOnNonManagedVm()) {
        return false;
    }
    // Initialize validators.
    VmValidator vmValidator = createVmValidator();
    SnapshotsValidator snapshotValidator = createSnapshotValidator();
    StoragePoolValidator spValidator = createStoragePoolValidator();
    if (!(validateVM(vmValidator) && validate(spValidator.isUp()) && validate(vmValidator.vmNotIlegal()) && validate(vmValidator.vmNotLocked()) && validate(snapshotValidator.vmNotDuringSnapshot(getVmId())) && validate(snapshotValidator.vmNotInPreview(getVmId())) && validate(vmValidator.vmNotDuringMigration()) && validate(vmValidator.vmNotRunningStateless()))) {
        return false;
    }
    List<DiskImage> disksList = getDisksList();
    if (disksList.size() > 0) {
        MultipleStorageDomainsValidator sdValidator = createMultipleStorageDomainsValidator(disksList);
        DiskImagesValidator diskImagesValidator = createDiskImageValidator(disksList);
        if (!(validate(diskImagesValidator.diskImagesNotLocked()) && validate(diskImagesValidator.diskImagesNotIllegal()) && validate(sdValidator.allDomainsExistAndActive()) && validate(sdValidator.allDomainsWithinThresholds()))) {
            return false;
        }
    }
    if (getParameters().isSaveMemory() && Guid.Empty.equals(getStorageDomainIdForVmMemory())) {
        return failCanDoAction(VdcBllMessages.ACTION_TYPE_FAILED_NO_SUITABLE_DOMAIN_FOUND);
    }
    return true;
}
#end_block

#method_before
@Override
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "DocumentationPath.csv", documentationFileFetchedEvent);
}
#method_after
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "DocumentationPath.csv", documentationFileFetchedEvent);
}
#end_block

#method_before
public boolean isWebSocketProxyDefined() {
    String wsConfig = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.WebSocketProxy);
    // $NON-NLS-1$ //$NON-NLS-2$
    return wsConfig != null && !"".equals(wsConfig) && !"Off".equalsIgnoreCase(wsConfig);
}
#method_after
public boolean isWebSocketProxyDefined() {
    String wsConfig = (String) AsyncDataProvider.getConfigValuePreConverted(ConfigurationValues.WebSocketProxy);
    // $NON-NLS-1$ $NON-NLS-2$
    return wsConfig != null && !"".equals(wsConfig) && !"Off".equalsIgnoreCase(wsConfig);
}
#end_block

#method_before
public boolean isClientWindowsExplorer() {
    // $NON-NLS-1$
    return isClientWindows() && clientBrowserType().equalsIgnoreCase("Explorer");
}
#method_after
public boolean isClientWindowsExplorer() {
    // $NON-NLS-1$ //$NON-NLS-2$
    return isClientWindows() && clientBrowserType().equalsIgnoreCase("Explorer");
}
#end_block

#method_before
public static void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#method_after
public static void getClusterGlusterServices(AsyncQuery aQuery, Guid clusterId) {
    aQuery.converterCallback = new IAsyncConverter() {

        @Override
        public Object Convert(Object source, AsyncQuery _asyncQuery) {
            return source;
        }
    };
    // Passing empty values for Volume and Brick to get the services of all the volumes/hosts in the cluster
    GlusterVolumeAdvancedDetailsParameters parameters = // $NON-NLS-1$ //$NON-NLS-2$
    new GlusterVolumeAdvancedDetailsParameters(clusterId, null, null, false);
    Frontend.RunQuery(VdcQueryType.GetGlusterVolumeAdvancedDetails, parameters, aQuery);
}
#end_block

#method_before
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#method_after
public static ArrayList<Map.Entry<String, EntityModel>> getBondingOptionList(RefObject<Map.Entry<String, EntityModel>> defaultItem) {
    ArrayList<Map.Entry<String, EntityModel>> list = new ArrayList<Map.Entry<String, EntityModel>>();
    EntityModel entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 1) Active-Backup");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=1 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 2) Load balance (balance-xor)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=2 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 4) Dynamic link aggregation (802.3ad)");
    // $NON-NLS-1$
    defaultItem.argvalue = new KeyValuePairCompat<String, EntityModel>("mode=4 miimon=100", entityModel);
    list.add(defaultItem.argvalue);
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("(Mode 5) Adaptive transmit load balancing (balance-tlb)");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("mode=5 miimon=100", entityModel));
    entityModel = new EntityModel();
    // $NON-NLS-1$
    entityModel.setEntity("");
    // $NON-NLS-1$
    list.add(new KeyValuePairCompat<String, EntityModel>("custom", entityModel));
    return list;
}
#end_block

#method_before
@Override
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "UserPortalDocumentationPath.csv", documentationFileFetchedEvent);
}
#method_after
protected void fetchDocumentationFile() {
    // $NON-NLS-1$
    fetchFile(getDocumentationBaseURL() + "UserPortalDocumentationPath.csv", documentationFileFetchedEvent);
}
#end_block

#method_before
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        if (allocatedMacs.containsKey(mac) || allocatedCustomMacs.containsKey(mac)) {
            return true;
        }
        for (String macAddress : allocatedMacs.keySet()) {
            if (StringUtils.equalsIgnoreCase(macAddress, mac)) {
                return true;
            }
        }
        for (String macAddress : allocatedCustomMacs.keySet()) {
            if (StringUtils.equalsIgnoreCase(macAddress, mac)) {
                return true;
            }
        }
        return false;
    } finally {
        lockObj.readLock().unlock();
    }
}
#method_after
public boolean isMacInUse(String mac) {
    lockObj.readLock().lock();
    try {
        return allocatedMacs.containsKey(mac) || allocatedCustomMacs.containsKey(mac);
    } finally {
        lockObj.readLock().unlock();
    }
}
#end_block

#method_before
public boolean shouldAlertUpgrade(ArrayList<RpmVersion> isos, String[] hostOs) {
    boolean alert = false;
    // $NON-NLS-1$ //$NON-NLS-2$
    String[] version_host = hostOs[1].split("\\.");
    // $NON-NLS-1$ //$NON-NLS-2$
    String[] release_host = hostOs[2].split("\\.");
    for (RpmVersion iso : isos) {
        // Major check
        if (Integer.parseInt(version_host[0].trim()) == iso.getMajor()) {
            // Minor and Build
            if (iso.getMinor() > Integer.parseInt(version_host[1].trim()) || iso.getBuild() > Integer.parseInt(version_host[2].trim())) {
                alert = true;
                break;
            }
            // Check if release contain revision
            if (Integer.toString(iso.getRevision()).length() > release_host[0].length()) {
                alert = true;
                break;
            }
            // $NON-NLS-1$ //$NON-NLS-2$
            String[] releaseISO = Integer.toString(iso.getRevision()).split("\\.");
            for (int i = 0; i < release_host.length; i++) {
                try {
                    if (Integer.parseInt(releaseISO[i].trim()) > Integer.parseInt(release_host[i].trim())) {
                        alert = true;
                        break;
                    }
                } catch (NumberFormatException e) {
                    break;
                }
            }
        }
    }
    return alert;
}
#method_after
protected static boolean shouldAlertUpgrade(ArrayList<RpmVersion> isos, String[] hostOs) {
    // HhostOs holds the following components:
    // hostOs[0] holds prefix
    // hostOs[1] holds version
    // hostOs[2] holds release
    final int VERSION_FIELDS_NUMBER = 4;
    boolean alert = false;
    // Fix hostOs[1] to be format of major.minor.build.revision
    // Add ".0" for missing parts
    // $NON-NLS-1$
    String[] hostOsVersionParts = hostOs[1].split("\\.");
    for (int counter = 0; counter < VERSION_FIELDS_NUMBER - hostOsVersionParts.length; counter++) {
        // $NON-NLS-1$
        hostOs[1] = hostOs[1].trim() + ".0";
    }
    Version hostVersion = new Version(hostOs[1].trim());
    String releaseHost = hostOs[2].trim();
    for (RpmVersion iso : isos) {
        // Major check
        if (hostVersion.getMajor() == iso.getMajor()) {
            // Minor and Buildiso.getRpmName()
            if (iso.getMinor() > hostVersion.getMinor() || iso.getBuild() > hostVersion.getBuild()) {
                alert = true;
                break;
            }
            String rpmFromIso = iso.getRpmName();
            // Removes the ".iso" file extension , and get the release part from it
            // $NON-NLS-1$
            int isoIndex = rpmFromIso.indexOf(".iso");
            if (isoIndex != -1) {
                rpmFromIso = iso.getRpmName().substring(0, isoIndex);
            }
            if (RpmVersionUtils.compareRpmParts(RpmVersionUtils.splitRpmToParts(rpmFromIso)[2], releaseHost) > 0) {
                alert = true;
                break;
            }
        }
    }
    return alert;
}
#end_block

#method_before
public void onInstall() {
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = getEntity().getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(getEntity());
    param.setVdsId(getEntity().getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? ((RpmVersion) model.getOVirtISO().getSelectedItem()).getRpmName() : null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.RunAction(VdcActionType.UpdateVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), getEntity().getVdsGroupId());
}
#method_after
public void onInstall() {
    InstallModel model = (InstallModel) getWindow();
    final boolean isOVirt = getEntity().getVdsType() == VDSType.oVirtNode;
    if (!model.validate(isOVirt)) {
        return;
    }
    UpdateVdsActionParameters param = new UpdateVdsActionParameters();
    param.setvds(getEntity());
    param.setVdsId(getEntity().getId());
    param.setPassword((String) model.getUserPassword().getEntity());
    param.setIsReinstallOrUpgrade(true);
    param.setInstallVds(true);
    param.setoVirtIsoFile(isOVirt ? ((RpmVersion) model.getOVirtISO().getSelectedItem()).getRpmName() : null);
    param.setOverrideFirewall((Boolean) model.getOverrideIpTables().getEntity());
    param.setAuthMethod(model.getAuthenticationMethod());
    Provider networkProvider = (Provider) model.getNetworkProviders().getSelectedItem();
    if (networkProvider != null) {
        param.setProviderId(networkProvider.getId());
        param.setNetworkMappings((String) model.getInterfaceMappings().getEntity());
    }
    AsyncDataProvider.getClusterById(new AsyncQuery(param, new INewAsyncCallback() {

        @Override
        public void onSuccess(Object model, Object returnValue) {
            VDSGroup cluster = (VDSGroup) returnValue;
            UpdateVdsActionParameters internalParam = (UpdateVdsActionParameters) model;
            internalParam.setRebootAfterInstallation(cluster.supportsVirtService());
            Frontend.RunAction(VdcActionType.UpdateVds, internalParam, new IFrontendActionAsyncCallback() {

                @Override
                public void executed(FrontendActionAsyncResult result) {
                    VdcReturnValueBase returnValue = result.getReturnValue();
                    if (returnValue != null && returnValue.getSucceeded()) {
                        cancel();
                    }
                }
            });
        }
    }), getEntity().getVdsGroupId());
}
#end_block

#method_before
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    getInstallCommand().setIsExecutionAllowed(true);
    getEditHostCommand().setIsExecutionAllowed(VdcActionUtils.CanExecute(new ArrayList<VDS>(Arrays.asList(new VDS[] { getEntity() })), VDS.class, VdcActionType.UpdateVds));
    // Check the network alert presense.
    setHasNICsAlert((getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty()));
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().getpm_enabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().getpm_enabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    } else if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                HostGeneralModel hostGeneralModel = (HostGeneralModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    VDS vds = hostGeneralModel.getEntity();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    String[] host = vds.getHostOs().split("-");
                    hostGeneralModel.setHasUpgradeAlert(shouldAlertUpgrade(isos, host));
                    boolean executionAllowed = vds.getStatus() != VDSStatus.Up && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.PendingApproval;
                    if (!executionAllowed) {
                        hostGeneralModel.getInstallCommand().getExecuteProhibitionReasons().add(constants.switchToMaintenanceModeToEnableUpgradeReason());
                    }
                    hostGeneralModel.getInstallCommand().setIsExecutionAllowed(executionAllowed);
                }
            }
        }), getEntity().getId());
    }
    setNonOperationalReasonEntity((getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason()));
    setHasAnyAlert(getHasNICsAlert() || getHasUpgradeAlert() || getHasManualFenceAlert() || getHasNoPowerManagementAlert() || getHasReinstallAlertNonResponsive() || getHasReinstallAlertInstallFailed() || getHasReinstallAlertMaintenance());
}
#method_after
private void updateAlerts() {
    setHasAnyAlert(false);
    setHasUpgradeAlert(false);
    setHasManualFenceAlert(false);
    setHasNoPowerManagementAlert(false);
    setHasReinstallAlertNonResponsive(false);
    setHasReinstallAlertInstallFailed(false);
    setHasReinstallAlertMaintenance(false);
    setHasNICsAlert(false);
    getInstallCommand().setIsExecutionAllowed(true);
    getEditHostCommand().setIsExecutionAllowed(VdcActionUtils.CanExecute(new ArrayList<VDS>(Arrays.asList(new VDS[] { getEntity() })), VDS.class, VdcActionType.UpdateVds));
    // Check the network alert presense.
    setHasNICsAlert((getEntity().getNetConfigDirty() == null ? false : getEntity().getNetConfigDirty()));
    // Check manual fence alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive && !getEntity().getpm_enabled() && ((getEntity().getVmActive() == null ? 0 : getEntity().getVmActive()) > 0 || getEntity().getSpmStatus() == VdsSpmStatus.SPM)) {
        setHasManualFenceAlert(true);
    } else if (!getEntity().getpm_enabled()) {
        setHasNoPowerManagementAlert(true);
    }
    // Check the reinstall alert presense.
    if (getEntity().getStatus() == VDSStatus.NonResponsive) {
        setHasReinstallAlertNonResponsive(true);
    } else if (getEntity().getStatus() == VDSStatus.InstallFailed) {
        setHasReinstallAlertInstallFailed(true);
    } else if (getEntity().getStatus() == VDSStatus.Maintenance) {
        setHasReinstallAlertMaintenance(true);
    } else if (getEntity().getVdsType() == VDSType.oVirtNode) {
        AsyncDataProvider.getoVirtISOsList(new AsyncQuery(this, new INewAsyncCallback() {

            @Override
            public void onSuccess(Object target, Object returnValue) {
                HostGeneralModel hostGeneralModel = (HostGeneralModel) target;
                ArrayList<RpmVersion> isos = (ArrayList<RpmVersion>) returnValue;
                if (isos.size() > 0) {
                    VDS vds = hostGeneralModel.getEntity();
                    // $NON-NLS-1$ //$NON-NLS-2$
                    String[] hostOsInfo = vds.getHostOs().split("-");
                    for (int counter = 0; counter < hostOsInfo.length; counter++) {
                        hostOsInfo[counter] = hostOsInfo[counter].trim();
                    }
                    hostGeneralModel.setHasUpgradeAlert(shouldAlertUpgrade(isos, hostOsInfo));
                    boolean executionAllowed = vds.getStatus() != VDSStatus.Up && vds.getStatus() != VDSStatus.Installing && vds.getStatus() != VDSStatus.PreparingForMaintenance && vds.getStatus() != VDSStatus.Reboot && vds.getStatus() != VDSStatus.PendingApproval;
                    if (!executionAllowed) {
                        hostGeneralModel.getInstallCommand().getExecuteProhibitionReasons().add(constants.switchToMaintenanceModeToEnableUpgradeReason());
                    }
                    hostGeneralModel.getInstallCommand().setIsExecutionAllowed(executionAllowed);
                }
            }
        }), getEntity().getId());
    }
    setNonOperationalReasonEntity((getEntity().getNonOperationalReason() == NonOperationalReason.NONE ? null : (NonOperationalReason) getEntity().getNonOperationalReason()));
    setHasAnyAlert(getHasNICsAlert() || getHasUpgradeAlert() || getHasManualFenceAlert() || getHasNoPowerManagementAlert() || getHasReinstallAlertNonResponsive() || getHasReinstallAlertInstallFailed() || getHasReinstallAlertMaintenance());
}
#end_block

